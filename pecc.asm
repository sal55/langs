# GAS VERSION
    .intel_syntax noprefix

    .global msys.$cmdskip
    .global main

    .text
#MCL1
    .bss
    .align    8
msys.fmtparam:
    .space    8
    .align    8
msys.$cmdskip:
$cmdskip:
    .space    8
    .data
    .align    8
msys.needgap:
    .quad     0
    .align    8
msys.outdev:
    .quad     1
    .align    8
msys.outchan:
    .quad     0
    .align    8
msys.fmtstr:
    .quad     0
    .bss
    .align    8
msys.outchan_stack:
    .space    80
    .align    8
msys.outdev_stack:
    .space    80
    .align    8
msys.fmtstr_stack:
    .space    80
msys.needgap_stack:
    .space    10
    .align    8
msys.ptr_stack:
    .space    80
    .data
    .align    8
msys.niostack:
    .quad     0
msys.digits:
    .quad     0x3736353433323130
    .quad     0x4645444342413938
    .byte     0
#ENDDATA
    .align    8
msys.defaultfmt:
    .byte     0
    .byte     0
    .byte     10
    .byte     0
    .byte     32
    .byte     102
    .byte     0
    .byte     0
    .byte     0
    .byte     82
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .bss
    .align    8
msys.rd_buffer:
    .space    8
    .align    8
msys.rd_length:
    .space    8
    .align    8
msys.rd_pos:
    .space    8
    .align    8
msys.rd_lastpos:
    .space    8
    .align    8
msys.termchar:
    .space    8
    .align    8
msys.itemerror:
    .space    8
msys.printbuffer:
    .space    4096
    .align    8
msys.printptr:
    .space    8
    .align    8
msys.printlen:
    .space    8
    .align    8
msys.nsysparams:
    .space    8
    .align    8
msys.ncmdparams:
    .space    8
    .align    8
msys.nenvstrings:
    .space    8
    .align    8
msys.sysparams:
    .space    1024
    .align    8
msys.cmdparams:
    .space    8
    .align    8
msys.envstrings:
    .space    8
msys.start.startupinfo:
    .space    128
    .align    8
msys.getfmt.fmt:
    .space    16
msys.strint.str:
    .space    100
msys.strword.str:
    .space    100
msys.strreal.str:
    .space    320
    .align    8
mlib.allocupper:
    .space    2408
    .align    8
mlib.alloccode:
    .space    8
    .align    8
mlib.allocbytes:
    .space    8
    .data
    .align    8
mlib.fdebug:
    .quad     0
    .bss
    .align    8
mlib.rfsize:
    .space    8
    .align    8
mlib.maxmemory:
    .space    8
    .align    8
mlib.maxalloccode:
    .space    8
    .data
mlib.pcm_setup:
    .byte     0
    .align    8
mlib.show:
    .quad     0
    .align    8
mlib.memtotal:
    .quad     0
    .align    8
mlib.smallmemtotal:
    .quad     0
    .align    8
mlib.smallmemobjs:
    .quad     0
    .align    8
mlib.maxmemtotal:
    .quad     0
    .bss
    .align    8
mlib.memalloctable:
    .space    24
    .align    4
mlib.memallocsize:
    .space    12
    .align    8
mlib.pcheapstart:
    .space    8
    .align    8
mlib.pcheapend:
    .space    8
    .align    8
mlib.pcheapptr:
    .space    8
mlib.sizeindextable:
    .space    2049
    .align    8
mlib.freelist:
    .space    72
    .data
    .align    8
mlib.pmnames:
    .quad     L9041
    .quad     L9042
    .quad     L9043
    .quad     L9044
    .quad     L9045
    .quad     L9046
    .align    8
mlib.seed:
    .quad     0x2989881111111272
    .quad     0x1673267373358264
    .bss
    .align    8
mlib.pcm_newblock.totalheapsize:
    .space    8
    .data
    .align    4
mlib.pcm_round.allocbytes:
    .long     0
    .long     16
    .long     32
    .long     64
    .long     128
    .long     256
    .long     512
    .long     1024
    .long     2048
    .bss
mlib.changeext.newfile:
    .space    260
mlib.extractpath.str:
    .space    260
mlib.extractbasefile.str:
    .space    100
    .data
    .align    8
mlib.nextcmdparamnew.infile:
    .quad     0
    .align    8
mlib.nextcmdparamnew.filestart:
    .quad     0
    .align    8
mlib.nextcmdparamnew.fileptr:
    .quad     0
mlib.nextcmdparamnew.colonseen:
    .byte     0
    .bss
mlib.nextcmdparamnew.str:
    .space    300
mlib.readnextfileitem.str:
    .space    256
mlib.padstr.str:
    .space    256
mlib.chr.str:
    .space    8
    .align    8
mwindows.hconsole:
    .space    8
    .align    8
mwindows.hconsolein:
    .space    8
    .align    4
mwindows.lastkey:
    .space    20
    .align    4
mwindows.pendkey:
    .space    20
    .align    8
mwindows.keypending:
    .space    8
    .align    8
mwindows.hpfreq:
    .space    8
    .data
    .align    8
mwindows.wndproc_callbackfn:
    .quad     0
    .align    8
mwindows.init_flag:
    .quad     0
    .bss
mwindows.os_gxregisterclass.registered:
    .space    1
    .data
    .align    8
mwindows.mainwndproc.count:
    .quad     0
    .bss
mwindows.os_gethostname.name:
    .space    300
    .align    8
mwindows.os_gethostname.n:
    .space    8
    .align    8
mwindows.os_peek.lastticks:
    .space    8
    .data
pcl.pc_userunpcl:
    .byte     0
    .bss
    .align    8
pc_api.pclseqno:
    .space    8
    .align    8
pc_api.stseqno:
    .space    8
    .align    8
pc_api.pcstart:
    .space    8
    .align    8
pc_api.pccurr:
    .space    8
    .align    8
pc_api.pcend:
    .space    8
    .align    8
pc_api.pcalloc:
    .space    8
pc_api.pcfixed:
    .space    1
    .align    8
pc_api.pcseqno:
    .space    8
    .align    8
pc_api.pcneedfntable:
    .space    8
    .data
    .align    8
pc_api.initpcalloc:
    .quad     0x10000
    .bss
    .align    8
pc_api.longstring:
    .space    8
    .align    8
pc_api.longstringlen:
    .space    8
    .align    8
pc_api.mlabelno:
    .space    8
pc_api.phighmem:
    .space    1
pc_api.pfullsys:
    .space    1
pc_api.fpshortnames:
    .space    1
    .align    8
pc_api.idomcl_assem:
    .space    8
    .align    8
pc_api.icheckasmlabel:
    .space    8
    .align    8
pc_api.igethostfn:
    .space    8
pc_api.strpmode.str:
    .space    32
pc_api.getfullname.str:
    .space    256
pc_api.addstr.str:
    .space    256
    .align    8
pc_decls.pinfo:
    .space    8
    .align    8
pc_decls.bspill:
    .space    8
    .align    8
pc_decls.bxspill:
    .space    8
pc_decls.r10used:
    .space    1
pc_decls.r11used:
    .space    1
pc_decls.localshadow:
    .space    1
    .align    8
pc_decls.mmpos:
    .space    8
    .align    8
pc_decls.psymboltable:
    .space    8
    .align    8
pc_decls.psymboltablex:
    .space    8
    .align    8
pc_decls.currprog:
    .space    8
    .align    8
pc_decls.currfunc:
    .space    8
    .align    8
pc_decls.blockretname:
    .space    8
    .align    8
pc_decls.entryproc:
    .space    8
    .align    8
pc_decls.sbuffer:
    .space    16
    .data
    .align    8
pc_decls.pdest:
    .quad     pc_decls.sbuffer
    .bss
    .align    8
pc_decls.plibfiles:
    .space    400
    .align    8
pc_decls.plibinst:
    .space    400
    .align    8
pc_decls.nplibfiles:
    .space    8
    .align    8
pc_decls.igetmsourceinfo:
    .space    8
pc_decls.pcldone:
    .space    1
pc_decls.mcldone:
    .space    1
pc_decls.ssdone:
    .space    1
pc_decls.objdone:
    .space    1
pc_decls.exedone:
    .space    1
pc_decls.pverbose:
    .space    1
    .align    8
pc_decls.pcmdskip:
    .space    8
    .data
    .align    8
pc_decls.assemtype:
    .quad     0x4141
    .bss
    .align    8
pc_decls.ppseqno:
    .space    8
    .data
pc_decls.fpeephole:
    .byte     1
pc_decls.fregoptim:
    .byte     1
    .bss
    .align    8
pc_decls.pcltime:
    .space    8
    .align    8
pc_decls.mcltime:
    .space    8
    .align    8
pc_decls.sstime:
    .space    8
    .align    8
pc_decls.objtime:
    .space    8
    .align    8
pc_decls.exetime:
    .space    8
    .align    8
pc_decls.$pmodulename:
    .space    8
    .align    8
pc_decls.pclflags:
    .space    1144
    .align    8
pc_decls.pstartclock:
    .space    8
    .align    8
pc_decls.npcl:
    .space    8
    .align    8
pc_diags.sbuffer:
    .space    16
    .data
    .align    8
pc_diags.dest:
    .quad     pc_diags.sbuffer
    .bss
    .align    8
pc_diags.destlinestart:
    .space    8
pc_diags.stropnd.str:
    .space    512
    .align    8
pc_diags.stropnd.longstring:
    .space    8
    .data
    .align    8
pc_run.dotrace:
    .quad     0
    .align    8
pc_run.dostep:
    .quad     1
    .bss
    .align    8
pc_run.go:
    .space    8
    .align    8
pc_run.seqno:
    .space    8
    .align    8
pc_run.emptyst:
    .space    128
    .align    8
pc_run.labeltable:
    .space    8
    .data
    .align    8
pc_tables.pstdnames:
    .quad     L9047
    .quad     L9048
    .quad     L9049
    .quad     L9050
    .quad     L9051
    .quad     L9052
    .quad     L9053
    .quad     L9054
    .quad     L9055
    .quad     L9056
    .quad     L9057
    .quad     L9058
    .quad     L9059
    .quad     L9060
pc_tables.psize:
    .quad     0x108040201080400
    .byte     2
    .byte     4
    .byte     8
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.psigned:
    .quad     0x100000000000000
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pint:
    .quad     0x101010101000000
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pfloat:
    .quad     0x10100
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pmin:
    .quad     0x906050505020100
    .byte     9
    .byte     9
    .byte     10
    .byte     11
    .byte     12
    .byte     0
#ENDDATA
pc_tables.xxpiwrb:
    .quad     0xA06060606020100
    .byte     10
    .byte     10
    .byte     10
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
pc_tables.opndnames:
    .quad     L9061
    .quad     L9062
    .quad     L9063
    .quad     L9064
    .quad     L9065
    .quad     L9066
    .quad     L9067
    .quad     L9068
    .quad     L9069
    .quad     L9070
    .quad     L9071
    .quad     L9072
    .quad     L9073
    .quad     L9074
    .align    8
pc_tables.pclnames:
    .quad     L9075
    .quad     L9076
    .quad     L9077
    .quad     L9078
    .quad     L9079
    .quad     L9080
    .quad     L9081
    .quad     L9082
    .quad     L9083
    .quad     L9084
    .quad     L9085
    .quad     L9086
    .quad     L9087
    .quad     L9088
    .quad     L9089
    .quad     L9090
    .quad     L9091
    .quad     L9092
    .quad     L9093
    .quad     L9094
    .quad     L9095
    .quad     L9096
    .quad     L9097
    .quad     L9098
    .quad     L9099
    .quad     L9100
    .quad     L9101
    .quad     L9102
    .quad     L9103
    .quad     L9104
    .quad     L9105
    .quad     L9106
    .quad     L9107
    .quad     L9108
    .quad     L9109
    .quad     L9110
    .quad     L9111
    .quad     L9112
    .quad     L9113
    .quad     L9114
    .quad     L9115
    .quad     L9116
    .quad     L9117
    .quad     L9118
    .quad     L9119
    .quad     L9120
    .quad     L9121
    .quad     L9122
    .quad     L9123
    .quad     L9124
    .quad     L9125
    .quad     L9126
    .quad     L9127
    .quad     L9128
    .quad     L9129
    .quad     L9130
    .quad     L9131
    .quad     L9132
    .quad     L9133
    .quad     L9134
    .quad     L9135
    .quad     L9136
    .quad     L9137
    .quad     L9138
    .quad     L9139
    .quad     L9140
    .quad     L9141
    .quad     L9142
    .quad     L9143
    .quad     L9144
    .quad     L9145
    .quad     L9146
    .quad     L9147
    .quad     L9148
    .quad     L9149
    .quad     L9150
    .quad     L9151
    .quad     L9152
    .quad     L9153
    .quad     L9154
    .quad     L9155
    .quad     L9156
    .quad     L9157
    .quad     L9158
    .quad     L9159
    .quad     L9160
    .quad     L9161
    .quad     L9162
    .quad     L9163
    .quad     L9164
    .quad     L9165
    .quad     L9166
    .quad     L9167
    .quad     L9168
    .quad     L9169
    .quad     L9170
    .quad     L9171
    .quad     L9172
    .quad     L9173
    .quad     L9174
    .quad     L9175
    .quad     L9176
    .quad     L9177
    .quad     L9178
    .quad     L9179
    .quad     L9180
    .quad     L9181
    .quad     L9182
    .quad     L9183
    .quad     L9184
    .quad     L9185
    .quad     L9186
    .quad     L9187
    .quad     L9188
    .quad     L9189
    .quad     L9190
    .quad     L9191
    .quad     L9192
    .quad     L9193
    .quad     L9194
    .quad     L9195
    .quad     L9196
    .quad     L9197
    .quad     L9198
    .quad     L9199
    .quad     L9200
    .quad     L9201
    .quad     L9202
    .quad     L9203
    .quad     L9204
    .quad     L9205
    .quad     L9206
    .quad     L9207
    .quad     L9208
    .quad     L9209
    .quad     L9210
    .quad     L9211
    .quad     L9212
    .quad     L9213
    .quad     L9214
    .quad     L9215
    .quad     L9216
    .quad     L9217
pc_tables.pclhastype:
    .quad     0x101010101010100
    .quad     0x101010101000000
    .quad     0x101010000000101
    .quad     0x101010101010100
    .quad     0x10101010100
    .quad     0x101010101000100
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x202010101010101
    .quad     0x101000202020202
    .quad     0x10101000000
    .quad     0
    .byte     0
    .byte     1
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pclextra:
    .quad     0x2000002000100
    .quad     0x20000
    .quad     0x2020002020000
    .quad     0x10000
    .quad     0x2020001010000
    .quad     0
    .quad     0
    .quad     0x1020200
    .quad     0
    .quad     0
    .quad     0x101010100000000
    .quad     0x101
    .quad     0x100000000000000
    .quad     1
    .quad     0
    .quad     0
    .quad     0x201000000
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
pc_tables.pclhasopnd:
    .quad     0x100000D00
    .quad     0xD00000000
    .quad     0x20000020000
    .quad     0x3030303030003
    .quad     0x303030003030300
    .quad     0xD0000
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0x3000D0101000101
    .quad     2
    .byte     0
    .byte     1
    .byte     1
    .byte     0
    .byte     0
    .byte     7
    .byte     1
#ENDDATA
pc_tables.pclargs:
    .quad     0
    .quad     0x202000000000000
    .quad     0x9090009090202
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0x101010100000000
    .quad     0x101010101010101
    .quad     0x2020201
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
pc_tables.ccnames:
    .quad     L9218
    .quad     L9219
    .quad     L9220
    .quad     L9221
    .quad     L9222
    .quad     L9223
    .quad     L9224
    .align    8
pc_tables.idnames:
    .quad     L9225
    .quad     L9226
    .quad     L9227
    .quad     L9228
    .quad     L9229
    .quad     L9230
    .quad     L9231
    .quad     L9232
    .quad     L9233
    .quad     L9234
    .bss
    .align    8
mc_genmcl.debug:
    .space    8
    .align    8
mc_genmcl.frameoffset:
    .space    8
    .align    8
mc_genmcl.paramoffset:
    .space    8
    .align    8
mc_genmcl.framebytes:
    .space    8
    .align    8
mc_genmcl.px_handlertable:
    .space    1144
    .data
mc_genmcl.scondcodes:
    .byte     4
    .byte     5
    .byte     12
    .byte     14
    .byte     13
    .byte     15
#ENDDATA
mc_genmcl.ucondcodes:
    .byte     4
    .byte     5
    .byte     2
    .byte     6
    .byte     3
    .byte     7
#ENDDATA
mc_genmcl.inithandlers.initdone:
    .byte     0
mc_genmcl.inithandlers.dupltable:
    .ascii    "MX"
#ENDDATA
    .ascii    "A@"
#ENDDATA
    .byte     21
    .byte     18
#ENDDATA
    .byte     19
    .byte     18
#ENDDATA
    .byte     22
    .byte     18
#ENDDATA
    .ascii    "wv"
#ENDDATA
    .ascii    "yx"
#ENDDATA
    .ascii    "^/"
#ENDDATA
    .ascii    "_0"
#ENDDATA
    .bss
    .align    8
mc_auxmcl.nnn:
    .space    8
    .align    8
mc_auxmcl.nauxprocs:
    .space    8
    .align    8
mc_auxmcl.nauxnoframe:
    .space    8
    .align    8
mc_auxmcl.mclframesetup:
    .space    8
    .align    8
mc_libmcl.mclseqno:
    .space    8
    .align    8
mc_libmcl.nmclopnd:
    .space    8
    .align    8
mc_libmcl.smallinttable:
    .space    96
    .align    8
mc_libmcl.nametable:
    .space    160
    .align    8
mc_libmcl.nnametable:
    .space    8
    .align    8
mc_libmcl.mgenextname.table:
    .space    160
    .align    8
mc_libmcl.mgenextname.ntable:
    .space    8
mc_stackmcl.stropndstack.str:
    .space    512
mc_genss.rex:
    .space    1
mc_genss.sizeoverride:
    .space    1
mc_genss.addroverride:
    .space    1
mc_genss.f2override:
    .space    1
mc_genss.f3override:
    .space    1
mc_genss.nowmask:
    .space    1
mc_genss.usesizeb:
    .space    1
    .align    8
mc_genss.extraparam:
    .space    8
    .data
    .align    8
mc_genss.currseg:
    .quad     0
    .bss
    .align    8
mc_genss.currdata:
    .space    8
    .align    8
mc_genss.currrelocs:
    .space    8
    .align    8
mc_genss.nrelocs:
    .space    8
mc_genss.ishighreg:
    .space    16
    .align    8
mc_genss.currmcl:
    .space    8
    .align    8
mc_genss.ripentry:
    .space    8
    .data
    .align    8
mc_genss.genrm.scaletable:
    .quad     0
    .quad     1
    .quad     0
    .quad     2
    .quad     0
    .quad     0
    .quad     0
    .quad     3
    .align    8
mc_decls.valtypenames:
    .quad     L9235
    .quad     L9236
    .quad     L9237
    .quad     L9238
    .quad     L9239
    .quad     L9240
    .quad     L9241
    .quad     L9242
    .quad     L9243
    .align    8
mc_decls.mclnames:
    .quad     L9244
    .quad     L9245
    .quad     L9246
    .quad     L9247
    .quad     L9248
    .quad     L9249
    .quad     L9250
    .quad     L9251
    .quad     L9252
    .quad     L9253
    .quad     L9254
    .quad     L9255
    .quad     L9256
    .quad     L9257
    .quad     L9258
    .quad     L9259
    .quad     L9260
    .quad     L9261
    .quad     L9262
    .quad     L9263
    .quad     L9264
    .quad     L9265
    .quad     L9266
    .quad     L9267
    .quad     L9268
    .quad     L9269
    .quad     L9270
    .quad     L9271
    .quad     L9272
    .quad     L9273
    .quad     L9274
    .quad     L9275
    .quad     L9276
    .quad     L9277
    .quad     L9278
    .quad     L9279
    .quad     L9280
    .quad     L9281
    .quad     L9282
    .quad     L9283
    .quad     L9284
    .quad     L9285
    .quad     L9286
    .quad     L9287
    .quad     L9288
    .quad     L9289
    .quad     L9290
    .quad     L9291
    .quad     L9292
    .quad     L9293
    .quad     L9294
    .quad     L9295
    .quad     L9296
    .quad     L9297
    .quad     L9298
    .quad     L9299
    .quad     L9300
    .quad     L9301
    .quad     L9302
    .quad     L9303
    .quad     L9304
    .quad     L9305
    .quad     L9306
    .quad     L9307
    .quad     L9308
    .quad     L9309
    .quad     L9310
    .quad     L9311
    .quad     L9312
    .quad     L9313
    .quad     L9314
    .quad     L9315
    .quad     L9316
    .quad     L9317
    .quad     L9318
    .quad     L9319
    .quad     L9320
    .quad     L9321
    .quad     L9322
    .quad     L9323
    .quad     L9324
    .quad     L9325
    .quad     L9326
    .quad     L9327
    .quad     L9328
    .quad     L9329
    .quad     L9330
    .quad     L9331
    .quad     L9332
    .quad     L9333
    .quad     L9334
    .quad     L9335
    .quad     L9336
    .quad     L9337
    .quad     L9338
    .quad     L9339
    .quad     L9340
    .quad     L9341
    .quad     L9342
    .quad     L9343
    .quad     L9344
    .quad     L9345
    .quad     L9346
    .quad     L9347
    .quad     L9348
    .quad     L9349
    .quad     L9350
    .quad     L9351
    .quad     L9352
    .quad     L9353
    .quad     L9354
    .quad     L9355
    .quad     L9356
    .quad     L9357
    .quad     L9358
    .quad     L9359
    .quad     L9360
    .quad     L9361
    .quad     L9362
    .quad     L9363
    .quad     L9364
    .quad     L9365
    .quad     L9366
    .quad     L9367
    .quad     L9368
    .quad     L9369
    .quad     L9370
    .quad     L9371
    .quad     L9372
    .quad     L9373
    .quad     L9374
    .quad     L9375
    .quad     L9376
    .quad     L9377
    .quad     L9378
    .quad     L9379
    .quad     L9380
    .quad     L9381
    .quad     L9382
    .quad     L9383
    .quad     L9384
    .quad     L9385
    .quad     L9386
    .quad     L9387
    .quad     L9388
    .quad     L9389
    .quad     L9390
    .quad     L9391
    .quad     L9392
    .quad     L9393
    .quad     L9394
    .quad     L9395
mc_decls.mclnopnds:
    .quad     0
    .quad     0x202020101020001
    .quad     0x100000102020202
    .quad     0x102020202020101
    .quad     0x202020101030201
    .quad     0x202020202020202
    .quad     0x101010102
    .quad     0x202020202020100
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x101010303020202
    .quad     0x10101
    .quad     0x200000000000000
    .quad     0x101010101020202
    .quad     0x101010101000000
    .quad     0x10101010100
    .quad     0x102000000
    .quad     0
#ENDDATA
mc_decls.mclcodes:
    .quad     0
    .quad     0x9000
    .quad     0xC9C3E800000000
    .quad     0x5030205000000E9
    .quad     0x601040607000004
    .quad     0x201000507040700
    .quad     0x100020303
    .quad     0x5151ACA4BDBC0000
    .quad     0x5E5E59595C5C5858
    .quad     0xEF545457572E2F00
    .quad     0xDB
    .quad     0x302006263F36600
    .quad     0xFAF9C9E9C1030200
    .quad     0x5DE0E1F3F2FBFFFE
    .quad     0x5F5D5F
    .quad     0x804020100000000
    .quad     0xE3E3E2E1E0D7
    .quad     0xE8EE000000310000
    .quad     0xF4F400EDECEAE9EB
#ENDDATA
    .align    8
mc_decls.regnames:
    .quad     L9396
    .quad     L9397
    .quad     L9398
    .quad     L9399
    .quad     L9400
    .quad     L9401
    .quad     L9402
    .quad     L9403
    .quad     L9404
    .quad     L9405
    .quad     L9406
    .quad     L9407
    .quad     L9408
    .quad     L9409
    .quad     L9410
    .quad     L9411
    .quad     L9412
    .quad     L9413
    .quad     L9414
    .quad     L9415
    .quad     L9416
mc_decls.regcodes:
    .quad     0xC0603070B0A0000
    .quad     0x5090802010F0E0D
    .byte     4
    .byte     4
    .byte     7
    .byte     5
    .byte     6
#ENDDATA
    .align    8
mc_decls.condnames:
    .quad     L9417
    .quad     L9418
    .quad     L9419
    .quad     L9420
    .quad     L9421
    .quad     L9422
    .quad     L9423
    .quad     L9424
    .quad     L9425
    .quad     L9426
    .quad     L9427
    .quad     L9428
    .quad     L9429
    .quad     L9430
    .quad     L9431
    .quad     L9432
    .quad     L9433
    .quad     L9434
    .quad     L9435
    .quad     L9436
    .align    8
mc_decls.asmcondnames:
    .quad     L9437
    .quad     L9438
    .quad     L9439
    .quad     L9440
    .quad     L9441
    .quad     L9442
    .quad     L9443
    .quad     L9444
    .quad     L9445
    .quad     L9446
    .quad     L9447
    .quad     L9448
    .quad     L9449
    .quad     L9450
    .quad     L9451
    .quad     L9452
    .quad     L9453
    .quad     L9454
    .quad     L9455
    .quad     L9456
    .align    8
mc_decls.asmrevcond:
    .quad     1
    .quad     0
    .quad     3
    .quad     2
    .quad     5
    .quad     4
    .quad     7
    .quad     6
    .quad     9
    .quad     8
    .quad     0xB
    .quad     0xA
    .quad     0xD
    .quad     0xC
    .quad     0xF
    .quad     0xE
    .quad     0x11
    .quad     0x10
    .quad     0x13
    .quad     0x12
    .align    8
mc_decls.dregnames:
    .quad     L9457
    .quad     L9458
    .quad     L9459
    .quad     L9460
    .quad     L9461
    .quad     L9462
    .quad     L9463
    .quad     L9464
    .quad     L9465
    .quad     L9466
    .quad     L9467
    .quad     L9468
    .quad     L9469
    .quad     L9470
    .quad     L9471
    .quad     L9472
    .quad     L9473
    .quad     L9474
    .quad     L9475
    .quad     L9476
    .quad     L9477
    .quad     L9478
    .quad     L9479
    .quad     L9480
    .quad     L9481
    .quad     L9482
    .quad     L9483
    .quad     L9484
    .quad     L9485
    .quad     L9486
    .quad     L9487
    .quad     L9488
    .quad     L9489
    .quad     L9490
    .quad     L9491
    .quad     L9492
    .quad     L9493
    .quad     L9494
    .quad     L9495
    .quad     L9496
    .quad     L9497
    .quad     L9498
    .quad     L9499
    .quad     L9500
    .quad     L9501
    .quad     L9502
    .quad     L9503
    .quad     L9504
    .quad     L9505
    .quad     L9506
    .quad     L9507
    .quad     L9508
    .quad     L9509
    .quad     L9510
    .quad     L9511
    .quad     L9512
    .quad     L9513
    .quad     L9514
    .quad     L9515
    .quad     L9516
    .quad     L9517
    .quad     L9518
    .quad     L9519
    .quad     L9520
    .quad     L9521
    .quad     L9522
    .quad     L9523
    .quad     L9524
    .quad     L9525
    .quad     L9526
    .quad     L9527
    .quad     L9528
    .quad     L9529
    .quad     L9530
    .quad     L9531
    .quad     L9532
    .quad     L9533
    .quad     L9534
    .quad     L9535
    .quad     L9536
    .quad     L9537
    .quad     L9538
    .quad     L9539
    .quad     L9540
    .quad     L9541
    .quad     L9542
    .quad     L9543
    .quad     L9544
    .quad     L9545
    .quad     L9546
    .quad     L9547
    .quad     L9548
    .quad     L9549
    .quad     L9550
    .quad     L9551
    .quad     L9552
    .quad     L9553
    .quad     L9554
    .quad     L9555
    .quad     L9556
    .quad     L9557
    .quad     L9558
    .quad     L9559
    .quad     L9560
    .quad     L9561
    .quad     L9562
    .quad     L9563
    .quad     L9564
    .quad     L9565
    .quad     L9566
    .quad     L9567
    .quad     L9568
    .quad     L9569
    .quad     L9570
    .quad     L9571
    .quad     L9572
    .quad     L9573
    .quad     L9574
    .quad     L9575
    .quad     L9576
    .quad     L9577
    .quad     L9578
    .quad     L9579
    .quad     L9580
    .quad     L9581
    .quad     L9582
    .quad     L9583
    .quad     L9584
    .quad     L9585
    .quad     L9586
    .quad     L9587
    .quad     L9588
    .quad     L9589
    .quad     L9590
    .quad     L9591
    .quad     L9592
    .quad     L9593
mc_decls.regsizes:
    .quad     0x808080808080808
    .quad     0x808080808080808
    .quad     0x404040404040404
    .quad     0x404040404040404
    .quad     0x202020202020202
    .quad     0x202020202020202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .quad     0x808080001010101
    .quad     0x808080808080808
    .quad     0x404040808080808
    .quad     0x404040404040404
    .quad     0x202020404040404
    .quad     0x202020202020202
    .quad     0x101010202020202
    .quad     0x101010101010101
    .quad     0x101010101010101
    .byte     1
#ENDDATA
mc_decls.regindices:
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0x807060504030201
    .quad     0x100F0E0D0C0B0A09
    .quad     0xB05010014131211
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0x20E0D100F04060C
    .quad     0xB05010A09080703
    .quad     0xF0406141312110C
    .quad     0x9080703020E0D10
    .byte     10
#ENDDATA
    .align    8
mc_decls.xmmregnames:
    .quad     L9594
    .quad     L9595
    .quad     L9596
    .quad     L9597
    .quad     L9598
    .quad     L9599
    .quad     L9600
    .quad     L9601
    .quad     L9602
    .quad     L9603
    .quad     L9604
    .quad     L9605
    .quad     L9606
    .quad     L9607
    .quad     L9608
    .quad     L9609
    .align    8
mc_decls.fregnames:
    .quad     L9610
    .quad     L9611
    .quad     L9612
    .quad     L9613
    .quad     L9614
    .quad     L9615
    .quad     L9616
    .quad     L9617
    .align    8
mc_decls.mregnames:
    .quad     L9618
    .quad     L9619
    .quad     L9620
    .quad     L9621
    .quad     L9622
    .quad     L9623
    .quad     L9624
    .quad     L9625
    .align    8
mc_decls.jmpccnames:
    .quad     L9626
    .quad     L9627
    .quad     L9628
    .quad     L9629
    .quad     L9630
    .quad     L9631
    .quad     L9632
    .quad     L9633
    .quad     L9634
    .quad     L9635
    .quad     L9636
    .quad     L9637
    .quad     L9638
    .quad     L9639
    .quad     L9640
    .quad     L9641
    .quad     L9642
    .quad     L9643
mc_decls.jmpcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
    .byte     2
    .byte     3
#ENDDATA
    .align    8
mc_decls.setccnames:
    .quad     L9644
    .quad     L9645
    .quad     L9646
    .quad     L9647
    .quad     L9648
    .quad     L9649
    .quad     L9650
    .quad     L9651
    .quad     L9652
    .quad     L9653
    .quad     L9654
    .quad     L9655
    .quad     L9656
    .quad     L9657
    .quad     L9658
    .quad     L9659
mc_decls.setcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
#ENDDATA
    .align    8
mc_decls.cmovccnames:
    .quad     L9660
    .quad     L9661
    .quad     L9662
    .quad     L9663
    .quad     L9664
    .quad     L9665
    .quad     L9666
    .quad     L9667
    .quad     L9668
    .quad     L9669
    .quad     L9670
    .quad     L9671
    .quad     L9672
    .quad     L9673
    .quad     L9674
    .quad     L9675
mc_decls.cmovcccodes:
    .quad     0x706050403020100
    .quad     0xF0E0D0C0B0A0908
#ENDDATA
    .align    8
mc_decls.segmentnames:
    .quad     L9676
    .quad     L9677
    .quad     L9678
    .quad     L9679
    .quad     L9680
    .quad     L9681
    .align    8
mc_decls.reftypenames:
    .quad     L9682
    .quad     L9683
    .quad     L9684
    .align    8
mc_decls.opndnames_ma:
    .quad     L9685
    .quad     L9686
    .quad     L9687
    .quad     L9688
    .quad     L9689
    .quad     L9690
    .bss
    .align    8
mc_decls.pclopnd:
    .space    400
mc_decls.pclreg:
    .space    50
mc_decls.pclmode:
    .space    50
mc_decls.pclcount:
    .space    50
mc_decls.pclloc:
    .space    50
mc_decls.pcltempflags:
    .space    50
    .align    8
mc_decls.pcltempopnds:
    .space    400
    .align    8
mc_decls.noperands:
    .space    8
    .align    8
mc_decls.mstackdepth:
    .space    8
    .data
    .align    8
mc_decls.locnames:
    .quad     L9691
    .quad     L9692
    .quad     L9693
    .quad     L9694
    .bss
mc_decls.workregs:
    .space    16
mc_decls.workxregs:
    .space    16
    .align    8
mc_decls.nworkregs:
    .space    8
    .align    8
mc_decls.nworkxregs:
    .space    8
    .align    8
mc_decls.nregvars:
    .space    8
    .align    8
mc_decls.nxregvars:
    .space    8
    .align    8
mc_decls.maxregvars:
    .space    8
    .align    8
mc_decls.maxxregvars:
    .space    8
    .align    8
mc_decls.xregmax:
    .space    8
mc_decls.regset:
    .space    16
mc_decls.xregset:
    .space    16
mc_decls.isregvar:
    .space    16
mc_decls.isxregvar:
    .space    16
mc_decls.usedregs:
    .space    16
mc_decls.usedxregs:
    .space    16
mc_decls.noxorclear:
    .space    1
    .data
    .align    8
mc_decls.xregnames:
    .quad     L9695
    .quad     L9696
    .quad     L9697
    .quad     L9698
    .quad     L9699
    .quad     L9700
    .quad     L9701
    .quad     L9702
    .quad     L9703
    .quad     L9704
    .quad     L9705
    .quad     L9706
    .quad     L9707
    .quad     L9708
    .quad     L9709
    .quad     L9710
    .quad     L9710
    .bss
mc_decls.callalign:
    .space    32
mc_decls.callblockret:
    .space    32
    .align    4
mc_decls.callblocksize:
    .space    128
    .align    4
mc_decls.callargsize:
    .space    512
    .align    8
mc_decls.ncalldepth:
    .space    8
    .align    8
mc_decls.lababs32:
    .space    8
    .align    8
mc_decls.lababs64:
    .space    8
    .align    8
mc_decls.labneg32:
    .space    8
    .align    8
mc_decls.labneg64:
    .space    8
    .align    8
mc_decls.labmask63:
    .space    8
    .align    8
mc_decls.laboffset64:
    .space    8
    .align    8
mc_decls.labzero:
    .space    8
    .data
    .align    8
mc_decls.kk0used:
    .quad     0
    .bss
    .align    8
mc_decls.mccode:
    .space    8
    .align    8
mc_decls.mccodex:
    .space    8
    .data
    .align    8
mc_decls.currsegment:
    .quad     0
    .bss
    .align    8
mc_decls.dstackopnd:
    .space    8
    .align    8
mc_decls.dframeopnd:
    .space    8
    .align    8
mc_decls.regtable:
    .space    1024
    .align    8
mc_decls.frameregtable:
    .space    1544
    .align    8
mc_decls.cstringlist:
    .space    8
    .align    8
mc_decls.vstringlist:
    .space    8
    .align    8
mc_decls.creallist:
    .space    8
    .align    8
mc_decls.cr32list:
    .space    8
    .align    8
mc_decls.currasmproc:
    .space    8
    .align    8
mc_decls.lab_funcnametable:
    .space    8
    .align    8
mc_decls.lab_funcaddrtable:
    .space    8
    .align    8
mc_decls.lab_funcnprocs:
    .space    8
    .align    8
mc_decls.ss_zdatalen:
    .space    8
    .align    8
mc_decls.ss_zdata:
    .space    8
    .align    8
mc_decls.ss_idata:
    .space    8
    .align    8
mc_decls.ss_code:
    .space    8
    .align    8
mc_decls.ss_idatarelocs:
    .space    8
    .align    8
mc_decls.ss_coderelocs:
    .space    8
    .align    8
mc_decls.ss_nidatarelocs:
    .space    8
    .align    8
mc_decls.ss_ncoderelocs:
    .space    8
    .align    8
mc_decls.ss_symboltable:
    .space    8
    .align    8
mc_decls.ss_nsymbols:
    .space    8
    .align    8
mc_decls.ss_symboltablesize:
    .space    8
    .align    8
mc_decls.labeldeftable:
    .space    8
    .align    8
mc_decls.aaseqno:
    .space    8
    .align    8
mc_decls.aapos:
    .space    8
    .data
mc_decls.regmodes:
    .quad     0x600000005000403
#ENDDATA
    .bss
mc_decls.pmode:
    .space    1
    .align    8
mc_decls.currpcl:
    .space    8
    .align    8
mc_decls.mclprocentry:
    .space    8
    .align    8
mc_decls.mce_oldmccodex:
    .space    8
    .align    8
mc_decls.mce_lastmcl:
    .space    8
    .align    8
mc_decls.mce_nextmcl:
    .space    8
    .align    8
mc_decls.mcf_oldmccodex:
    .space    8
    .align    8
mc_decls.mcf_lastmcl:
    .space    8
    .align    8
mc_decls.mcf_nextmcl:
    .space    8
mc_decls.fpcheckunusedlocals:
    .space    1
    .align    8
mc_decls.riplist:
    .space    8
    .align    8
mc_decls.blockdefs:
    .space    400
    .align    8
mc_decls.nblocktemps:
    .space    8
    .data
    .align    8
mc_decls.multregs:
    .quad     1
    .quad     2
    .quad     3
    .quad     0xB
    .quad     0xC
    .quad     0xD
    .align    8
mc_decls.multxregs:
    .quad     1
    .quad     2
    .quad     3
    .quad     4
    .quad     5
    .quad     6
    .bss
mc_decls.ploadopx:
    .space    14
mc_decls.ploadop:
    .space    14
    .data
    .align    8
mc_objdecls.relocnames:
    .quad     L9711
    .quad     L9712
    .quad     L9713
    .quad     L9714
    .quad     L9715
    .quad     L9716
    .quad     L9717
    .align    8
mc_writegas.asmext:
    .quad     L9718
    .bss
    .align    8
mc_writegas.nregnames:
    .space    1024
mc_writegas.currseg:
    .space    1
mc_writegas.strmcl.str:
    .space    512
mc_writegas.mstropnd.str:
    .space    512
mc_writegas.strvalue.str:
    .space    512
mc_writegas.getxregname.str:
    .space    32
mc_writegas.getdispname.str:
    .space    256
mc_writegas.gettempname.str:
    .space    128
    .align    8
mc_writeexe.libinsttable:
    .space    400
    .align    8
mc_writeexe.libinstnames:
    .space    400
    .align    8
mc_writeexe.libnotable:
    .space    400
    .align    8
mc_writeexe.basereloclist:
    .space    8
    .align    8
mc_writeexe.nbaserelocs:
    .space    8
    .align    8
mc_writeexe.maxrelocaddr:
    .space    8
    .align    8
mc_writeexe.blockbases:
    .space    4000
    .align    4
mc_writeexe.blockcounts:
    .space    2000
    .align    4
mc_writeexe.blockbytes:
    .space    2000
mc_writeexe.blockpadding:
    .space    500
    .align    8
mc_writeexe.nbaseblocks:
    .space    8
    .align    8
mc_writeexe.basetablesize:
    .space    8
    .align    8
mc_writeexe.imagebase:
    .space    8
    .align    8
mc_writeexe.imagesize:
    .space    8
    .align    8
mc_writeexe.filesize:
    .space    8
    .align    8
mc_writeexe.thunktable:
    .space    8
    .align    8
mc_writeexe.fileiatoffset:
    .space    8
    .align    8
mc_writeexe.fileiatsize:
    .space    8
    .align    8
mc_writeexe.stentrypoint:
    .space    8
    .align    8
mc_writeexe.stentrypoint2:
    .space    8
    .align    8
mc_writeexe.stentrypoint3:
    .space    8
    .align    8
mc_writeexe.sectiontable:
    .space    720
    .align    8
mc_writeexe.nsections:
    .space    8
    .align    8
mc_writeexe.importdir:
    .space    8
    .align    8
mc_writeexe.importtable:
    .space    144048
    .align    8
mc_writeexe.nimports:
    .space    8
    .align    8
mc_writeexe.exporttable:
    .space    16000
    .align    8
mc_writeexe.nexports:
    .space    8
    .align    8
mc_writeexe.dllfilename:
    .space    8
    .align    8
mc_writeexe.isdll:
    .space    8
    .align    8
mc_writeexe.dlltable:
    .space    2400
    .align    8
mc_writeexe.ndlls:
    .space    8
    .align    8
mc_writeexe.datastart:
    .space    8
    .align    8
mc_writeexe.dataptr:
    .space    8
    .align    8
mc_writeexe.userentrypoint:
    .space    8
    .align    8
mc_writeexe.exportdirvirtaddr:
    .space    8
    .align    8
mc_writeexe.exportdirvirtsize:
    .space    8
    .align    8
mc_writeexe.exportdiroffset:
    .space    8
    .align    8
mc_writeexe.blockdirvirtaddr:
    .space    8
    .align    8
mc_writeexe.blockdirvirtsize:
    .space    8
    .align    8
mc_writeexe.blockdiroffset:
    .space    8
    .data
mc_writeexe.writedosstub.stubdata:
    .quad     0x300905A4D
    .quad     0xFFFF00000004
    .quad     0xB8
    .quad     0x40
    .quad     0
    .quad     0
    .quad     0
    .quad     0x8000000000
    .quad     0xCD09B4000EBA1F0E
    .quad     0x685421CD4C01B821
    .quad     0x72676F7270207369
    .quad     0x6F6E6E6163206D61
    .quad     0x6E75722065622074
    .quad     0x20534F44206E6920
    .quad     0xA0D0D2E65646F6D
    .quad     0x24
#ENDDATA
    .bss
    .align    8
mc_writeobj.symtaboffset:
    .space    8
    .align    8
mc_writeobj.datastart:
    .space    8
    .align    8
mc_writeobj.dataptr:
    .space    8
    .align    2
mc_writeobj.symboltable:
    .space    234018
    .align    8
mc_writeobj.nsymbols:
    .space    8
    .data
    .align    8
mc_writeobj.stoffset:
    .quad     0
    .bss
    .align    8
mc_writeobj.stringtable:
    .space    40000
    .align    8
mc_writeobj.stringlengths:
    .space    40000
    .data
    .align    8
mc_writeobj.nextstringoffset:
    .quad     0
    .align    8
mc_writeobj.nstrings:
    .quad     0
    .bss
    .align    2
mc_writeobj.writerelocs.s:
    .space    10
    .align    2
mc_writeobj.makesymbol.r:
    .space    18
    .align    2
mc_writeobj.strtoaux.r:
    .space    18
    .align    2
mc_writeobj.sectiontoaux.r:
    .space    18
    .data
    .align    8
mx_decls.mcxdirnames:
    .quad     L9719
    .quad     L9720
    .quad     L9721
    .quad     L9722
    .quad     L9723
    .quad     L9724
    .quad     L9725
    .quad     L9726
    .quad     L9727
    .quad     L9728
    .quad     L9729
    .quad     L9730
    .quad     L9731
    .quad     L9732
    .align    8
mx_decls.mcxrelocnames:
    .quad     L9733
    .quad     L9734
    .quad     L9735
    .quad     L9736
    .quad     L9737
    .quad     L9738
    .bss
    .align    8
mx_decls.dllnametable:
    .space    160
    .align    8
mx_decls.dllinsttable:
    .space    160
    .align    8
mx_decls.ndlllibs:
    .space    8
    .align    8
mx_decls.libnametable:
    .space    160
    .align    8
mx_decls.libtable:
    .space    160
mx_decls.librelocated:
    .space    20
mx_decls.libinitdone:
    .space    20
    .align    8
mx_decls.nlibs:
    .space    8
    .align    8
mx_decls.symbolnametable:
    .space    24000
mx_decls.symboldefined:
    .space    3000
    .align    8
mx_decls.symboladdress:
    .space    24000
    .align    2
mx_decls.symbollibindex:
    .space    6000
mx_decls.symboldllindex:
    .space    3000
    .align    8
mx_decls.nsymbols:
    .space    8
    .data
    .align    8
mx_decls.nsymimports:
    .quad     0
    .align    8
mx_decls.nsymexports:
    .quad     0
    .align    8
mx_lib.rsegmentnames:
    .quad     L9739
    .quad     L9740
    .quad     L9741
    .quad     L9742
    .quad     L9743
    .quad     L9744
    .bss
    .align    8
mx_write.dest:
    .space    8
    .align    8
mx_write.entrypoint:
    .space    8
    .data
    .align    8
cc_cli.passnames:
    .quad     L9745
    .quad     L9746
    .quad     L9747
    .quad     L9748
    .quad     L9749
    .quad     L9750
    .quad     L9751
    .quad     L9752
    .quad     L9753
    .quad     L9754
    .quad     L9755
    .quad     L9756
    .quad     L9757
    .align    8
cc_cli.extnames:
    .quad     L9758
    .quad     L9759
    .quad     L9760
    .quad     L9760
    .quad     L9761
    .quad     L9762
    .quad     L9763
    .quad     L9763
    .quad     L9764
    .quad     L9765
    .quad     L9766
    .quad     L9767
    .quad     L9768
    .bss
cc_cli.cc_pass:
    .space    1
cc_cli.debugmode:
    .space    1
    .align    8
cc_cli.outfile:
    .space    8
    .data
    .align    8
cc_cli.outext:
    .quad     L9769
    .bss
    .align    8
cc_cli.cmdskip:
    .space    8
    .align    8
cc_cli.ttt:
    .space    8
    .data
cc_cli.fverbose:
    .byte     1
cc_cli.fshowincludes:
    .byte     0
cc_cli.dointheaders:
    .byte     1
cc_cli.highmem:
    .byte     1
    .bss
cc_cli.fshowst:
    .space    1
cc_cli.fshowstflat:
    .space    1
cc_cli.fshowast:
    .space    1
cc_cli.fshowpcl:
    .space    1
cc_cli.fshowpst:
    .space    1
cc_cli.fshowmcl:
    .space    1
cc_cli.fshowss:
    .space    1
cc_cli.fshowtypes:
    .space    1
cc_cli.fshowfiles:
    .space    1
cc_cli.fshowpaths:
    .space    1
cc_cli.fshowheaders:
    .space    1
cc_cli.fwriteheaders:
    .space    1
cc_cli.fshowlog:
    .space    1
cc_cli.fshowtiming:
    .space    1
cc_cli.fgendll:
    .space    1
cc_cli.fstdout:
    .space    1
cc_cli.fshortnames:
    .space    1
    .data
cc_cli.fwriteerrors:
    .byte     1
    .bss
    .align    8
cc_cli.entrypointname:
    .space    8
    .data
    .align    8
cc_cli.optionnames:
    .quad     L9770
    .quad     L9771
    .quad     L9772
    .quad     L9773
    .quad     L9774
    .quad     L9775
    .quad     L9776
    .quad     L9777
    .quad     L9778
    .quad     L9779
    .quad     L9780
    .quad     L9781
    .quad     L9782
    .quad     L9783
    .quad     L9784
    .quad     L9785
    .quad     L9786
    .quad     L9787
    .quad     L9788
    .quad     L9789
    .quad     L9790
    .quad     L9791
    .quad     L9792
    .quad     L9793
    .quad     L9794
    .quad     L9795
    .quad     L9796
    .quad     L9797
    .quad     L9798
    .quad     L9799
    .quad     L9800
    .quad     L9801
    .quad     L9802
    .quad     L9803
    .quad     L9804
    .quad     L9805
    .quad     L9806
    .quad     L9807
    .quad     L9808
    .quad     L9809
    .quad     L9810
    .quad     L9811
    .quad     L9812
    .quad     L9813
    .quad     L9814
    .quad     L9815
    .quad     L9816
    .quad     L9817
    .quad     L9818
    .align    8
cc_cli.optvars:
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     cc_cli.cc_pass
    .quad     pc_decls.fregoptim
    .quad     pc_decls.fpeephole
    .quad     0
    .quad     cc_cli.fshowpaths
    .quad     cc_cli.fshowheaders
    .quad     0
    .quad     cc_cli.fshowincludes
    .quad     cc_cli.fshowst
    .quad     cc_cli.fshowstflat
    .quad     cc_cli.fshowast
    .quad     cc_cli.fshowpcl
    .quad     cc_cli.fshowpst
    .quad     cc_cli.fshowmcl
    .quad     cc_cli.fshowss
    .quad     cc_cli.fshowtypes
    .quad     cc_cli.fshowfiles
    .quad     cc_cli.fshowtiming
    .quad     cc_cli.fshowtiming
    .quad     cc_cli.fverbose
    .quad     cc_cli.fverbose
    .quad     cc_cli.fverbose
    .quad     pc_decls.pverbose
    .quad     pc_decls.pverbose
    .quad     0
    .quad     0
    .quad     cc_cli.dointheaders
    .quad     cc_cli.fwriteheaders
    .quad     0
    .quad     cc_cli.fstdout
    .quad     cc_cli.fshortnames
    .quad     cc_cli.highmem
    .quad     cc_cli.highmem
cc_cli.optvalues:
    .quad     0x605050403020201
    .quad     0xC0B090A0A080807
    .quad     0x10101010000000D
    .quad     0x101010101010101
    .quad     0x201000302020101
    .quad     0x1010001000000
    .byte     2
#ENDDATA
    .align    8
cc_cli.totallines:
    .quad     0
    .align    8
cc_cli.nstringobjects:
    .quad     0
    .bss
    .align    8
cc_cli.startclock:
    .space    8
    .align    8
cc_cli.loadtime:
    .space    8
    .align    8
cc_cli.parsetime:
    .space    8
    .align    8
cc_cli.pcltime:
    .space    8
    .align    8
cc_cli.compiletime:
    .space    8
    .align    8
cc_cli.inittime:
    .space    8
    .data
    .align    8
cc_cli.showextrainfo.infotext:
    .quad     L9819
    .bss
    .align    8
cc_decls.ntypes:
    .space    8
    .align    8
cc_decls.ttnamedef:
    .space    640000
    .align    2
cc_decls.ttbasetype:
    .space    160000
    .align    8
cc_decls.ttlength:
    .space    640000
cc_decls.ttconst:
    .space    80000
    .align    2
cc_decls.tttarget:
    .space    160000
    .align    2
cc_decls.ttreftype:
    .space    160000
    .align    2
cc_decls.ttconsttype:
    .space    160000
    .align    8
cc_decls.ttsize:
    .space    640000
cc_decls.ttisref:
    .space    80000
cc_decls.ttisblock:
    .space    80000
cc_decls.ttsigned:
    .space    80000
    .align    4
cc_decls.ttshared:
    .space    320000
    .align    8
cc_decls.ttparams:
    .space    640000
    .align    8
cc_decls.tttypedef:
    .space    640000
    .align    8
cc_decls.trefchar:
    .space    8
    .align    8
cc_decls.trefwchar:
    .space    8
    .align    8
cc_decls.inputfile:
    .space    8
    .align    8
cc_decls.mainfileno:
    .space    8
    .align    8
cc_decls.libfiles:
    .space    1608
    .align    8
cc_decls.sourcefilenames:
    .space    1608
    .align    8
cc_decls.sourcefilepaths:
    .space    1608
    .align    8
cc_decls.sourcefiletext:
    .space    1608
    .align    4
cc_decls.sourcefilesizes:
    .space    804
    .align    8
cc_decls.nsourcefiles:
    .space    8
    .align    8
cc_decls.nlibfiles:
    .space    8
    .align    8
cc_decls.searchdirs:
    .space    160
    .data
    .align    8
cc_decls.nsearchdirs:
    .quad     0
    .bss
    .align    8
cc_decls.includepaths:
    .space    160
    .data
    .align    8
cc_decls.nincludepaths:
    .quad     0
    .bss
    .align    8
cc_decls.stprogram:
    .space    8
    .align    8
cc_decls.stmodule:
    .space    8
    .align    8
cc_decls.logdev:
    .space    8
    .align    8
cc_decls.nullunit:
    .space    8
    .data
    .align    8
cc_decls.clineno:
    .quad     0
    .align    8
cc_decls.cfileno:
    .quad     0
    .bss
    .align    8
cc_decls.lx:
    .space    32
    .align    8
cc_decls.nextlx:
    .space    32
    .data
    .align    8
cc_decls.debug:
    .quad     0
    .align    8
cc_decls.hstsize:
    .quad     0x10000
    .bss
    .align    8
cc_decls.hstmask:
    .space    8
    .align    8
cc_decls.hashtable:
    .space    8
    .align    4
cc_decls.blockowner:
    .space    8404
    .align    4
cc_decls.blockcounts:
    .space    8404
    .align    4
cc_decls.blockstack:
    .space    404
    .align    8
cc_decls.currblockno:
    .space    8
    .align    8
cc_decls.nextblockno:
    .space    8
    .align    8
cc_decls.blocklevel:
    .space    8
    .align    8
cc_decls.currproc:
    .space    8
    .data
    .align    8
cc_decls.dheaderfile:
    .quad     0
    .align    8
cc_decls.structpadding:
    .quad     1
    .align    8
cc_decls.callbackflag:
    .quad     0
    .bss
    .align    8
cc_decls.slineno:
    .space    8
    .align    8
cc_decls.sfileno:
    .space    8
    .data
    .align    8
cc_decls.oemname:
    .quad     L9820
    .bss
    .align    8
cc_decls.mclstr:
    .space    8
    .align    8
cc_decls.mclstrlen:
    .space    8
    .align    8
cc_decls.nunits:
    .space    8
    .align    8
cc_decls.pmodulelist:
    .space    1592
    .align    8
cc_decls.pheaderlist:
    .space    800
    .align    8
cc_decls.pliblist:
    .space    800
    .align    8
cc_decls.npmodules:
    .space    8
    .align    8
cc_decls.npheaders:
    .space    8
    .align    8
cc_decls.nplibs:
    .space    8
cc_decls.pci_target:
    .space    1
    .data
    .align    8
cc_tables.stdtypenames:
    .quad     L9821
    .quad     L9822
    .quad     L9823
    .quad     L9824
    .quad     L9825
    .quad     L9826
    .quad     L9827
    .quad     L9828
    .quad     L9829
    .quad     L9830
    .quad     L9831
    .quad     L9832
    .quad     L9833
    .quad     L9834
    .quad     L9835
    .quad     L9836
    .quad     L9837
    .quad     L9838
    .quad     L9839
    .quad     L9840
    .quad     L9841
    .quad     L9842
cc_tables.stdtypewidths:
    .quad     0x1008084020100800
    .quad     0x4040400040204020
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdsigned:
    .quad     0x101010100
    .quad     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdpcl:
    .quad     0x403030A09080700
    .quad     0x60902010605
    .byte     11
    .byte     11
    .byte     11
    .byte     11
    .byte     0
    .byte     0
#ENDDATA
cc_tables.stdsize:
    .quad     0x201010804020100
    .quad     0x8040804
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     0
#ENDDATA
    .align    8
cc_tables.catnames:
    .quad     L9843
    .quad     L9844
    .quad     L9845
    .quad     L9846
    .quad     L9847
    .align    8
cc_tables.typespecnames:
    .quad     L9848
    .quad     L9849
    .quad     L9850
    .quad     L9851
    .quad     L9852
    .quad     L9853
    .quad     L9854
    .quad     L9855
    .quad     L9856
    .quad     L9857
    .quad     L9858
    .quad     L9859
    .quad     L9860
    .quad     L9861
    .quad     L9862
    .align    4
cc_tables.typespectypes:
    .long     0
    .long     1
    .long     0
    .long     0
    .long     3
    .long     10
    .long     11
    .long     0
    .long     0
    .long     5
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
cc_tables.typespecsizes:
    .quad     0x8040404020100
    .byte     0
    .byte     1
    .byte     0
    .byte     0
    .byte     0
    .byte     4
    .byte     0
#ENDDATA
    .align    8
cc_tables.pmflagnames:
    .quad     L9863
    .quad     L9864
    .quad     L9865
    .quad     L9866
    .align    8
cc_tables.scopenames:
    .quad     L9867
    .quad     L9868
    .quad     L9869
    .quad     L9870
    .quad     L9871
    .align    8
cc_tables.cccnames:
    .quad     L9872
    .quad     L9873
    .quad     L9874
    .quad     L9875
    .quad     L9876
    .quad     L9877
    .align    8
cc_tables.linkagenames:
    .quad     L9878
    .quad     L9879
    .quad     L9880
    .quad     L9881
    .quad     L9882
    .quad     L9883
    .align    8
cc_tables.typequalnames:
    .quad     L9884
    .quad     L9885
    .quad     L9886
    .quad     L9887
    .align    8
cc_tables.fnspecnames:
    .quad     L9888
    .quad     L9889
    .quad     L9890
    .align    8
cc_tables.jtagnames:
    .quad     L9891
    .quad     L9892
    .quad     L9893
    .quad     L9894
    .quad     L9895
    .quad     L9896
    .quad     L9897
    .quad     L9898
    .quad     L9899
    .quad     L9900
    .quad     L9901
    .quad     L9902
    .quad     L9903
    .quad     L9904
    .quad     L9905
    .quad     L9906
    .quad     L9907
    .quad     L9908
    .quad     L9909
    .quad     L9910
    .quad     L9911
    .quad     L9912
    .quad     L9913
    .quad     L9914
    .quad     L9915
    .quad     L9916
    .quad     L9917
    .quad     L9918
    .quad     L9919
    .quad     L9920
    .quad     L9921
    .quad     L9922
    .quad     L9923
    .quad     L9924
    .quad     L9925
    .quad     L9926
    .quad     L9927
    .quad     L9928
    .quad     L9929
    .quad     L9930
    .quad     L9931
    .quad     L9932
    .quad     L9933
    .quad     L9934
    .quad     L9935
    .quad     L9936
    .quad     L9937
    .quad     L9938
    .quad     L9939
    .quad     L9940
    .quad     L9941
    .quad     L9942
    .quad     L9943
    .quad     L9944
    .quad     L9945
    .quad     L9946
    .quad     L9947
    .quad     L9948
    .quad     L9949
    .quad     L9950
    .quad     L9951
    .quad     L9952
    .quad     L9953
    .quad     L9954
    .quad     L9955
    .quad     L9956
    .quad     L9957
    .quad     L9958
    .quad     L9959
    .quad     L9960
    .quad     L9961
    .quad     L9962
    .quad     L9963
    .quad     L9964
    .quad     L9965
    .quad     L9966
    .quad     L9967
    .quad     L9968
    .align    8
cc_tables.symbolnames:
    .quad     L9969
    .quad     L9970
    .quad     L9971
    .quad     L9972
    .quad     L9973
    .quad     L9974
    .quad     L9975
    .quad     L9976
    .quad     L9977
    .quad     L9978
    .quad     L9979
    .quad     L9980
    .quad     L9981
    .quad     L9982
    .quad     L9983
    .quad     L9984
    .quad     L9985
    .quad     L9986
    .quad     L9987
    .quad     L9988
    .quad     L9989
    .quad     L9990
    .quad     L9991
    .quad     L9992
    .quad     L9993
    .quad     L9994
    .quad     L9995
    .quad     L9996
    .quad     L9997
    .quad     L9998
    .quad     L9999
    .quad     L10000
    .quad     L10001
    .quad     L10002
    .quad     L10003
    .quad     L10004
    .quad     L10005
    .quad     L10006
    .quad     L10007
    .quad     L10008
    .quad     L10009
    .quad     L10010
    .quad     L10011
    .quad     L10012
    .quad     L10013
    .quad     L10014
    .quad     L10015
    .quad     L10016
    .quad     L10017
    .quad     L10018
    .quad     L10019
    .quad     L10020
    .quad     L10021
    .quad     L10022
    .quad     L10023
    .quad     L10024
    .quad     L10025
    .quad     L10026
    .quad     L10027
    .quad     L10028
    .quad     L10029
    .quad     L10030
    .quad     L10031
    .quad     L10032
    .quad     L10033
    .quad     L10034
    .quad     L10035
    .quad     L10036
    .quad     L10037
    .quad     L10038
    .quad     L10039
    .quad     L10040
    .quad     L10041
    .quad     L10042
    .quad     L10043
    .quad     L10044
    .quad     L10045
    .quad     L10046
    .quad     L10047
    .quad     L10048
    .quad     L10049
    .quad     L10050
    .quad     L10051
    .quad     L10052
    .quad     L10053
    .quad     L10054
    .quad     L10055
    .quad     L10056
    .quad     L10057
    .quad     L10058
    .quad     L10059
    .quad     L10060
    .quad     L10061
    .quad     L10062
    .quad     L10063
    .quad     L10064
    .align    8
cc_tables.shortsymbolnames:
    .quad     L10065
    .quad     L10066
    .quad     L10067
    .quad     L10068
    .quad     L10068
    .quad     L10068
    .quad     L10069
    .quad     L10070
    .quad     L10071
    .quad     L10072
    .quad     L10073
    .quad     L10074
    .quad     L10075
    .quad     L10076
    .quad     L10077
    .quad     L10078
    .quad     L10079
    .quad     L10080
    .quad     L10081
    .quad     L10082
    .quad     L10083
    .quad     L10084
    .quad     L10085
    .quad     L10086
    .quad     L10087
    .quad     L10088
    .quad     L10089
    .quad     L10090
    .quad     L10091
    .quad     L10092
    .quad     L10093
    .quad     L10094
    .quad     L10095
    .quad     L10096
    .quad     L10097
    .quad     L10098
    .quad     L10099
    .quad     L10100
    .quad     L10101
    .quad     L10102
    .quad     L10103
    .quad     L10104
    .quad     L10105
    .quad     L10106
    .quad     L10107
    .quad     L10108
    .quad     L10109
    .quad     L10110
    .quad     L10111
    .quad     L10112
    .quad     L10113
    .quad     L10114
    .quad     L10115
    .quad     L10116
    .quad     L10117
    .quad     L10118
    .quad     L10118
    .quad     L10119
    .quad     L10119
    .quad     L10119
    .quad     L10120
    .quad     L10120
    .quad     L10120
    .quad     L10120
    .quad     L10121
    .quad     L10122
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10123
    .quad     L10124
cc_tables.symboltojtag:
    .quad     0x323100
    .quad     0xB0B0000
    .quad     0x2827000000000000
    .quad     0x18192E2C2D2B2A29
    .quad     0x213B48471A3C302F
    .quad     0x3F3E3D2526242322
    .quad     0x46454442434140
    .quad     0
    .quad     0
    .quad     0
    .quad     0
    .quad     0
#ENDDATA
    .align    8
cc_tables.sourcedirnames:
    .quad     L10125
    .quad     L10126
    .quad     L10127
    .quad     L10128
    .quad     L10129
    .quad     L10130
    .quad     L10131
    .quad     L10132
    .quad     L10133
    .quad     L10134
    .quad     L10135
    .quad     L10136
    .quad     L10137
    .quad     L10138
    .quad     L10139
    .align    8
cc_tables.namespacenames:
    .quad     L10140
    .quad     L10141
    .quad     L10142
    .quad     L10143
    .quad     L10144
    .align    8
cc_tables.namenames:
    .quad     L10145
    .quad     L10146
    .quad     L10147
    .quad     L10148
    .quad     L10149
    .quad     L10150
    .quad     L10151
    .quad     L10152
    .quad     L10153
    .quad     L10154
    .quad     L10155
    .quad     L10156
    .quad     L10157
    .quad     L10158
    .quad     L10159
    .align    4
cc_tables.namespaces:
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     1
    .long     1
    .long     1
    .long     1
    .long     1
    .long     4
    .long     1
    .long     2
    .long     2
    .long     3
cc_tables.name2pid:
    .quad     0x302000000000000
    .byte     4
    .byte     5
    .byte     0
    .byte     0
    .byte     0
    .byte     0
    .byte     6
#ENDDATA
    .align    8
cc_tables.stnames:
    .quad     L10160
    .quad     L10161
    .quad     L10162
    .quad     L10163
    .quad     L10164
    .quad     L10165
    .quad     L10166
    .quad     L10167
    .quad     L10168
    .quad     L10169
    .quad     L10170
    .quad     L10171
    .quad     L10172
    .quad     L10173
    .quad     L10174
    .quad     L10175
    .quad     L10176
    .quad     L10177
    .quad     L10178
    .quad     L10179
    .quad     L10180
    .quad     L10181
    .quad     L10182
    .quad     L10183
    .quad     L10184
    .quad     L10185
    .quad     L10186
    .quad     L10187
    .quad     L10188
    .quad     L10189
    .quad     L10190
    .quad     L10191
    .quad     L10192
    .quad     L10193
    .quad     L10194
    .quad     L10195
    .quad     L10196
    .quad     L10197
    .quad     L10198
    .quad     L10199
    .quad     L10200
    .quad     L10201
    .quad     L10202
    .quad     L10203
    .quad     L10204
    .quad     L10205
    .quad     L10206
    .quad     L10207
    .quad     L10208
    .quad     L10209
    .quad     L10210
    .quad     L10211
    .quad     L10212
    .quad     L10213
    .quad     L10214
    .quad     L10215
    .quad     L10216
    .quad     L10217
    .quad     L10218
    .quad     L10219
    .quad     L10220
    .quad     L10221
    .quad     L10222
    .align    4
cc_tables.stsymbols:
    .long     71
    .long     72
    .long     73
    .long     74
    .long     75
    .long     77
    .long     76
    .long     78
    .long     79
    .long     80
    .long     81
    .long     82
    .long     83
    .long     84
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     68
    .long     85
    .long     85
    .long     85
    .long     85
    .long     85
    .long     86
    .long     86
    .long     86
    .long     86
    .long     88
    .long     88
    .long     89
    .long     90
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     70
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     69
    .long     91
    .long     91
    .long     92
    .long     93
    .long     94
    .long     95
    .long     95
    .long     0
    .align    4
cc_tables.stsubcodes:
    .long     12
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     0
    .long     7
    .long     1
    .long     4
    .long     8
    .long     9
    .long     6
    .long     10
    .long     11
    .long     15
    .long     14
    .long     2
    .long     3
    .long     1
    .long     4
    .long     5
    .long     1
    .long     2
    .long     3
    .long     4
    .long     1
    .long     2
    .long     0
    .long     0
    .long     1
    .long     2
    .long     3
    .long     4
    .long     5
    .long     6
    .long     7
    .long     8
    .long     9
    .long     10
    .long     1
    .long     3
    .long     4
    .long     2
    .long     7
    .long     8
    .long     5
    .long     5
    .long     0
    .long     1
    .long     0
    .long     0
    .long     0
    .long     75
    .long     76
    .long     0
    .align    8
cc_tables.convnames:
    .quad     L10223
    .quad     L10224
    .quad     L10225
    .quad     L10226
    .quad     L10227
    .quad     L10228
    .quad     L10229
    .quad     L10230
    .quad     L10231
    .quad     L10232
    .quad     L10233
    .quad     L10234
    .quad     L10235
    .quad     L10236
    .bss
cc_tables.dominantmode:
    .space    1024
cc_tables.conversionops:
    .space    256
    .data
cc_tables.dominantsetuptable:
    .byte     1
    .byte     1
    .byte     3
#ENDDATA
    .byte     1
    .byte     2
    .byte     3
#ENDDATA
    .byte     1
    .byte     3
    .byte     3
#ENDDATA
    .byte     1
    .byte     4
    .byte     4
#ENDDATA
    .byte     1
    .byte     5
    .byte     3
#ENDDATA
    .byte     1
    .byte     6
    .byte     3
#ENDDATA
    .byte     1
    .byte     7
    .byte     3
#ENDDATA
    .byte     1
    .byte     8
    .byte     3
#ENDDATA
    .byte     1
    .byte     9
    .byte     4
#ENDDATA
    .byte     1
    .byte     10
    .byte     10
#ENDDATA
    .byte     1
    .byte     11
    .byte     11
#ENDDATA
    .byte     2
    .byte     1
    .byte     3
#ENDDATA
    .byte     2
    .byte     2
    .byte     3
#ENDDATA
    .byte     2
    .byte     3
    .byte     3
#ENDDATA
    .byte     2
    .byte     4
    .byte     4
#ENDDATA
    .byte     2
    .byte     5
    .byte     3
#ENDDATA
    .byte     2
    .byte     6
    .byte     3
#ENDDATA
    .byte     2
    .byte     7
    .byte     3
#ENDDATA
    .byte     2
    .byte     8
    .byte     3
#ENDDATA
    .byte     2
    .byte     9
    .byte     4
#ENDDATA
    .byte     2
    .byte     10
    .byte     10
#ENDDATA
    .byte     2
    .byte     11
    .byte     11
#ENDDATA
    .byte     3
    .byte     1
    .byte     3
#ENDDATA
    .byte     3
    .byte     2
    .byte     3
#ENDDATA
    .byte     3
    .byte     3
    .byte     3
#ENDDATA
    .byte     3
    .byte     4
    .byte     4
#ENDDATA
    .byte     3
    .byte     5
    .byte     3
#ENDDATA
    .byte     3
    .byte     6
    .byte     3
#ENDDATA
    .byte     3
    .byte     7
    .byte     3
#ENDDATA
    .byte     3
    .byte     8
    .byte     8
#ENDDATA
    .byte     3
    .byte     9
    .byte     4
#ENDDATA
    .byte     3
    .byte     10
    .byte     10
#ENDDATA
    .byte     3
    .byte     11
    .byte     11
#ENDDATA
    .byte     4
    .byte     1
    .byte     4
#ENDDATA
    .byte     4
    .byte     2
    .byte     4
#ENDDATA
    .byte     4
    .byte     3
    .byte     4
#ENDDATA
    .byte     4
    .byte     4
    .byte     4
#ENDDATA
    .byte     4
    .byte     5
    .byte     4
#ENDDATA
    .byte     4
    .byte     6
    .byte     4
#ENDDATA
    .byte     4
    .byte     7
    .byte     4
#ENDDATA
    .byte     4
    .byte     8
    .byte     4
#ENDDATA
    .byte     4
    .byte     9
    .byte     9
#ENDDATA
    .byte     4
    .byte     10
    .byte     10
#ENDDATA
    .byte     4
    .byte     11
    .byte     11
#ENDDATA
    .byte     5
    .byte     1
    .byte     3
#ENDDATA
    .byte     5
    .byte     2
    .byte     3
#ENDDATA
    .byte     5
    .byte     3
    .byte     3
#ENDDATA
    .byte     5
    .byte     4
    .byte     4
#ENDDATA
    .byte     5
    .byte     5
    .byte     8
#ENDDATA
    .byte     5
    .byte     6
    .byte     8
#ENDDATA
    .byte     5
    .byte     7
    .byte     8
#ENDDATA
    .byte     5
    .byte     8
    .byte     8
#ENDDATA
    .byte     5
    .byte     9
    .byte     9
#ENDDATA
    .byte     5
    .byte     10
    .byte     10
#ENDDATA
    .byte     5
    .byte     11
    .byte     11
#ENDDATA
    .byte     6
    .byte     1
    .byte     3
#ENDDATA
    .byte     6
    .byte     2
    .byte     3
#ENDDATA
    .byte     6
    .byte     3
    .byte     3
#ENDDATA
    .byte     6
    .byte     4
    .byte     4
#ENDDATA
    .byte     6
    .byte     5
    .byte     0
#ENDDATA
    .byte     6
    .byte     6
    .byte     8
#ENDDATA
    .byte     6
    .byte     7
    .byte     8
#ENDDATA
    .byte     6
    .byte     8
    .byte     8
#ENDDATA
    .byte     6
    .byte     9
    .byte     9
#ENDDATA
    .byte     6
    .byte     10
    .byte     10
#ENDDATA
    .byte     6
    .byte     11
    .byte     11
#ENDDATA
    .byte     7
    .byte     1
    .byte     3
#ENDDATA
    .byte     7
    .byte     2
    .byte     3
#ENDDATA
    .byte     7
    .byte     3
    .byte     3
#ENDDATA
    .byte     7
    .byte     4
    .byte     4
#ENDDATA
    .byte     7
    .byte     5
    .byte     8
#ENDDATA
    .byte     7
    .byte     6
    .byte     8
#ENDDATA
    .byte     7
    .byte     7
    .byte     8
#ENDDATA
    .byte     7
    .byte     8
    .byte     8
#ENDDATA
    .byte     7
    .byte     9
    .byte     9
#ENDDATA
    .byte     7
    .byte     10
    .byte     10
#ENDDATA
    .byte     7
    .byte     11
    .byte     11
#ENDDATA
    .byte     8
    .byte     1
    .byte     3
#ENDDATA
    .byte     8
    .byte     2
    .byte     3
#ENDDATA
    .byte     8
    .byte     3
    .byte     8
#ENDDATA
    .byte     8
    .byte     4
    .byte     4
#ENDDATA
    .byte     8
    .byte     5
    .byte     8
#ENDDATA
    .byte     8
    .byte     6
    .byte     8
#ENDDATA
    .byte     8
    .byte     7
    .byte     8
#ENDDATA
    .byte     8
    .byte     8
    .byte     8
#ENDDATA
    .byte     8
    .byte     9
    .byte     9
#ENDDATA
    .byte     8
    .byte     10
    .byte     10
#ENDDATA
    .byte     8
    .byte     11
    .byte     11
#ENDDATA
    .byte     9
    .byte     1
    .byte     9
#ENDDATA
    .byte     9
    .byte     2
    .byte     9
#ENDDATA
    .byte     9
    .byte     3
    .byte     9
#ENDDATA
    .byte     9
    .byte     4
    .byte     9
#ENDDATA
    .byte     9
    .byte     5
    .byte     9
#ENDDATA
    .byte     9
    .byte     6
    .byte     9
#ENDDATA
    .byte     9
    .byte     7
    .byte     9
#ENDDATA
    .byte     9
    .byte     8
    .byte     9
#ENDDATA
    .byte     9
    .byte     9
    .byte     9
#ENDDATA
    .byte     9
    .byte     10
    .byte     10
#ENDDATA
    .byte     9
    .byte     11
    .byte     11
#ENDDATA
    .byte     10
    .byte     1
    .byte     11
#ENDDATA
    .byte     10
    .byte     2
    .byte     11
#ENDDATA
    .byte     10
    .byte     3
    .byte     11
#ENDDATA
    .byte     10
    .byte     4
    .byte     11
#ENDDATA
    .byte     10
    .byte     5
    .byte     11
#ENDDATA
    .byte     10
    .byte     6
    .byte     11
#ENDDATA
    .byte     10
    .byte     7
    .byte     11
#ENDDATA
    .byte     10
    .byte     8
    .byte     11
#ENDDATA
    .byte     10
    .byte     9
    .byte     11
#ENDDATA
    .byte     10
    .byte     10
    .byte     10
#ENDDATA
    .byte     10
    .byte     11
    .byte     11
#ENDDATA
    .byte     11
    .byte     1
    .byte     11
#ENDDATA
    .byte     11
    .byte     2
    .byte     11
#ENDDATA
    .byte     11
    .byte     3
    .byte     11
#ENDDATA
    .byte     11
    .byte     4
    .byte     11
#ENDDATA
    .byte     11
    .byte     5
    .byte     11
#ENDDATA
    .byte     11
    .byte     6
    .byte     11
#ENDDATA
    .byte     11
    .byte     7
    .byte     11
#ENDDATA
    .byte     11
    .byte     8
    .byte     11
#ENDDATA
    .byte     11
    .byte     9
    .byte     11
#ENDDATA
    .byte     11
    .byte     10
    .byte     11
#ENDDATA
    .byte     11
    .byte     11
    .byte     11
#ENDDATA
cc_tables.convsetuptable:
    .byte     1
    .byte     1
    .byte     3
#ENDDATA
    .byte     1
    .byte     2
    .byte     3
#ENDDATA
    .byte     1
    .byte     3
    .byte     3
#ENDDATA
    .byte     1
    .byte     4
    .byte     3
#ENDDATA
    .byte     1
    .byte     5
    .byte     13
#ENDDATA
    .byte     1
    .byte     6
    .byte     1
#ENDDATA
    .byte     1
    .byte     7
    .byte     3
#ENDDATA
    .byte     1
    .byte     8
    .byte     3
#ENDDATA
    .byte     1
    .byte     9
    .byte     3
#ENDDATA
    .byte     1
    .byte     10
    .byte     5
#ENDDATA
    .byte     1
    .byte     11
    .byte     5
#ENDDATA
    .byte     2
    .byte     1
    .byte     12
#ENDDATA
    .byte     2
    .byte     2
    .byte     0
#ENDDATA
    .byte     2
    .byte     3
    .byte     3
#ENDDATA
    .byte     2
    .byte     4
    .byte     3
#ENDDATA
    .byte     2
    .byte     5
    .byte     13
#ENDDATA
    .byte     2
    .byte     6
    .byte     12
#ENDDATA
    .byte     2
    .byte     7
    .byte     1
#ENDDATA
    .byte     2
    .byte     8
    .byte     3
#ENDDATA
    .byte     2
    .byte     9
    .byte     3
#ENDDATA
    .byte     2
    .byte     10
    .byte     5
#ENDDATA
    .byte     2
    .byte     11
    .byte     5
#ENDDATA
    .byte     3
    .byte     1
    .byte     12
#ENDDATA
    .byte     3
    .byte     2
    .byte     12
#ENDDATA
    .byte     3
    .byte     3
    .byte     0
#ENDDATA
    .byte     3
    .byte     4
    .byte     3
#ENDDATA
    .byte     3
    .byte     5
    .byte     13
#ENDDATA
    .byte     3
    .byte     6
    .byte     12
#ENDDATA
    .byte     3
    .byte     7
    .byte     12
#ENDDATA
    .byte     3
    .byte     8
    .byte     1
#ENDDATA
    .byte     3
    .byte     9
    .byte     3
#ENDDATA
    .byte     3
    .byte     10
    .byte     5
#ENDDATA
    .byte     3
    .byte     11
    .byte     5
#ENDDATA
    .byte     4
    .byte     1
    .byte     12
#ENDDATA
    .byte     4
    .byte     2
    .byte     12
#ENDDATA
    .byte     4
    .byte     3
    .byte     12
#ENDDATA
    .byte     4
    .byte     4
    .byte     0
#ENDDATA
    .byte     4
    .byte     5
    .byte     13
#ENDDATA
    .byte     4
    .byte     6
    .byte     12
#ENDDATA
    .byte     4
    .byte     7
    .byte     12
#ENDDATA
    .byte     4
    .byte     8
    .byte     12
#ENDDATA
    .byte     4
    .byte     9
    .byte     1
#ENDDATA
    .byte     4
    .byte     10
    .byte     5
#ENDDATA
    .byte     4
    .byte     11
    .byte     5
#ENDDATA
    .byte     5
    .byte     1
    .byte     1
#ENDDATA
    .byte     5
    .byte     2
    .byte     4
#ENDDATA
    .byte     5
    .byte     3
    .byte     4
#ENDDATA
    .byte     5
    .byte     4
    .byte     4
#ENDDATA
    .byte     5
    .byte     5
    .byte     0
#ENDDATA
    .byte     5
    .byte     6
    .byte     1
#ENDDATA
    .byte     5
    .byte     7
    .byte     4
#ENDDATA
    .byte     5
    .byte     8
    .byte     4
#ENDDATA
    .byte     5
    .byte     9
    .byte     4
#ENDDATA
    .byte     5
    .byte     10
    .byte     6
#ENDDATA
    .byte     5
    .byte     11
    .byte     6
#ENDDATA
    .byte     6
    .byte     1
    .byte     1
#ENDDATA
    .byte     6
    .byte     2
    .byte     4
#ENDDATA
    .byte     6
    .byte     3
    .byte     4
#ENDDATA
    .byte     6
    .byte     4
    .byte     4
#ENDDATA
    .byte     6
    .byte     5
    .byte     13
#ENDDATA
    .byte     6
    .byte     6
    .byte     1
#ENDDATA
    .byte     6
    .byte     7
    .byte     4
#ENDDATA
    .byte     6
    .byte     8
    .byte     4
#ENDDATA
    .byte     6
    .byte     9
    .byte     4
#ENDDATA
    .byte     6
    .byte     10
    .byte     6
#ENDDATA
    .byte     6
    .byte     11
    .byte     6
#ENDDATA
    .byte     7
    .byte     1
    .byte     12
#ENDDATA
    .byte     7
    .byte     2
    .byte     1
#ENDDATA
    .byte     7
    .byte     3
    .byte     4
#ENDDATA
    .byte     7
    .byte     4
    .byte     4
#ENDDATA
    .byte     7
    .byte     5
    .byte     13
#ENDDATA
    .byte     7
    .byte     6
    .byte     12
#ENDDATA
    .byte     7
    .byte     7
    .byte     0
#ENDDATA
    .byte     7
    .byte     8
    .byte     4
#ENDDATA
    .byte     7
    .byte     9
    .byte     4
#ENDDATA
    .byte     7
    .byte     10
    .byte     6
#ENDDATA
    .byte     7
    .byte     11
    .byte     6
#ENDDATA
    .byte     8
    .byte     1
    .byte     12
#ENDDATA
    .byte     8
    .byte     2
    .byte     12
#ENDDATA
    .byte     8
    .byte     3
    .byte     1
#ENDDATA
    .byte     8
    .byte     4
    .byte     4
#ENDDATA
    .byte     8
    .byte     5
    .byte     13
#ENDDATA
    .byte     8
    .byte     6
    .byte     12
#ENDDATA
    .byte     8
    .byte     7
    .byte     12
#ENDDATA
    .byte     8
    .byte     8
    .byte     0
#ENDDATA
    .byte     8
    .byte     9
    .byte     4
#ENDDATA
    .byte     8
    .byte     10
    .byte     6
#ENDDATA
    .byte     8
    .byte     11
    .byte     6
#ENDDATA
    .byte     9
    .byte     1
    .byte     12
#ENDDATA
    .byte     9
    .byte     2
    .byte     12
#ENDDATA
    .byte     9
    .byte     3
    .byte     12
#ENDDATA
    .byte     9
    .byte     4
    .byte     1
#ENDDATA
    .byte     9
    .byte     5
    .byte     13
#ENDDATA
    .byte     9
    .byte     6
    .byte     12
#ENDDATA
    .byte     9
    .byte     7
    .byte     12
#ENDDATA
    .byte     9
    .byte     8
    .byte     12
#ENDDATA
    .byte     9
    .byte     9
    .byte     0
#ENDDATA
    .byte     9
    .byte     10
    .byte     6
#ENDDATA
    .byte     9
    .byte     11
    .byte     6
#ENDDATA
    .byte     10
    .byte     1
    .byte     7
#ENDDATA
    .byte     10
    .byte     2
    .byte     7
#ENDDATA
    .byte     10
    .byte     3
    .byte     7
#ENDDATA
    .byte     10
    .byte     4
    .byte     7
#ENDDATA
    .byte     10
    .byte     5
    .byte     8
#ENDDATA
    .byte     10
    .byte     6
    .byte     8
#ENDDATA
    .byte     10
    .byte     7
    .byte     8
#ENDDATA
    .byte     10
    .byte     8
    .byte     8
#ENDDATA
    .byte     10
    .byte     9
    .byte     8
#ENDDATA
    .byte     10
    .byte     10
    .byte     0
#ENDDATA
    .byte     10
    .byte     11
    .byte     9
#ENDDATA
    .byte     11
    .byte     1
    .byte     7
#ENDDATA
    .byte     11
    .byte     2
    .byte     7
#ENDDATA
    .byte     11
    .byte     3
    .byte     7
#ENDDATA
    .byte     11
    .byte     4
    .byte     7
#ENDDATA
    .byte     11
    .byte     5
    .byte     8
#ENDDATA
    .byte     11
    .byte     6
    .byte     8
#ENDDATA
    .byte     11
    .byte     7
    .byte     8
#ENDDATA
    .byte     11
    .byte     8
    .byte     8
#ENDDATA
    .byte     11
    .byte     9
    .byte     8
#ENDDATA
    .byte     11
    .byte     10
    .byte     10
#ENDDATA
    .byte     11
    .byte     11
    .byte     0
#ENDDATA
    .align    8
cc_tables.badexprs:
    .quad     1
    .quad     3
    .quad     0x1F
    .quad     0x18
    .quad     0x19
    .quad     0x1A
    .quad     0x1B
    .quad     0x1D
    .quad     0x20
    .quad     0x21
    .quad     0x22
    .quad     0x23
    .quad     0x24
    .quad     0x26
    .quad     0x25
    .quad     0x27
    .quad     0x28
    .quad     0x29
    .quad     0x2A
    .quad     0x2B
    .quad     0x2C
    .quad     0x2D
    .quad     0x2E
    .quad     0x2F
    .quad     0x30
    .quad     0x31
    .quad     0x32
    .quad     0x33
    .quad     0x34
    .quad     0x35
    .quad     0x36
    .quad     0x3A
    .quad     0x3B
    .quad     0x3C
    .align    8
cc_lex.tkptr:
    .quad     0
    .align    8
cc_lex.dowhitespace:
    .quad     0
    .bss
    .align    8
cc_lex.nincludes:
    .space    8
    .align    8
cc_lex.normaltkx:
    .space    32
    .data
    .align    8
cc_lex.normaltk:
    .quad     cc_lex.normaltkx
    .align    8
cc_lex.noexpand:
    .quad     0
    .bss
    .align    8
cc_lex.lx_stack:
    .space    480
    .align    8
cc_lex.lx_stackindex:
    .space    8
    .data
    .align    8
cc_lex.ifcondlevel:
    .quad     0
    .bss
    .align    8
cc_lex.headerpathlist:
    .space    160
cc_lex.headerpath:
    .space    300
    .align    8
cc_lex.lxstart:
    .space    8
    .align    8
cc_lex.lxsptr:
    .space    8
    .align    8
cc_lex.lxhashvalue:
    .space    8
    .align    8
cc_lex.lxsvalue:
    .space    8
cc_lex.alphamap:
    .space    256
cc_lex.digitmap:
    .space    256
cc_lex.commentmap:
    .space    256
cc_lex.linecommentmap:
    .space    256
cc_lex.spacemap:
    .space    256
    .align    8
cc_lex.destcopy:
    .space    8
    .align    8
cc_lex.pastedtokenlist:
    .space    696000
    .data
    .align    8
cc_lex.npastedtokens:
    .quad     0
    .align    8
cc_lex.isincludefile:
    .quad     0
    .align    8
cc_lex.firstsymbol:
    .quad     1
    .bss
    .align    8
cc_lex.reallxsptr:
    .space    8
    .align    8
cc_lex.nhstsymbols:
    .space    8
    .align    8
cc_lex.hstthreshold:
    .space    8
    .align    8
cc_lex.lex_preprocess_only.sbuffer:
    .space    16
    .data
    .align    8
cc_lex.lex_preprocess_only.dest:
    .quad     cc_lex.lex_preprocess_only.sbuffer
    .bss
cc_lex.getsourcefile.filespec:
    .space    300
    .data
    .align    8
cc_lex.lexm.doreset:
    .quad     0
    .align    8
cc_lex.lasttoken:
    .quad     0
    .bss
    .align    8
cc_lex.showtoken.buffer:
    .space    16
    .data
    .align    8
cc_lex.showtoken.dest:
    .quad     cc_lex.showtoken.buffer
    .bss
    .align    8
cc_lex.stringify.buffer:
    .space    16
    .data
    .align    8
cc_lex.stringify.deststr:
    .quad     cc_lex.stringify.buffer
    .align    8
cc_lex.expandpredefmacro.monthnames:
    .quad     L10237
    .quad     L10238
    .quad     L10239
    .quad     L10240
    .quad     L10241
    .quad     L10242
    .quad     L10243
    .quad     L10244
    .quad     L10245
    .quad     L10246
    .quad     L10247
    .quad     L10248
    .align    8
cc_lex.issimpleconstmacro.specialnames:
    .quad     L10249
    .quad     L10250
    .quad     L10251
    .bss
    .align    8
cc_parse.ist_symptr:
    .space    8
cc_parse.looptypestack:
    .space    64
    .align    8
cc_parse.loopindex:
    .space    8
    .align    8
cc_parse.casevaluestack:
    .space    512
    .data
cc_parse.ingeneric:
    .byte     0
    .bss
    .align    8
cc_genpcl.retindex:
    .space    8
    .align    8
cc_genpcl.initstaticsindex:
    .space    8
    .align    8
cc_genpcl.loopstack:
    .space    1600
    .align    8
cc_genpcl.loopindex:
    .space    8
    .align    8
cc_genpcl.zero_unit:
    .space    64
    .data
    .align    8
cc_genpcl.pzero:
    .quad     cc_genpcl.zero_unit
    .bss
    .align    8
cc_genpcl.nvarlocals:
    .space    8
    .align    8
cc_genpcl.nvarparams:
    .space    8
    .align    8
cc_blockpcl.continuestack:
    .space    512
    .align    8
cc_blockpcl.breakstack:
    .space    512
    .align    8
cc_blockpcl.loopindex:
    .space    8
    .align    8
cc_blockpcl.sw_labeltable:
    .space    8
    .align    8
cc_blockpcl.sw_valuetable:
    .space    8
    .align    8
cc_blockpcl.sw_lower:
    .space    8
    .align    8
cc_blockpcl.sw_ncases:
    .space    8
cc_blockpcl.sw_defaultseen:
    .space    1
    .align    8
cc_blockpcl.sw_defaultlabel:
    .space    8
    .align    8
cc_blockpcl.sw_breaklabel:
    .space    8
    .data
    .align    8
cc_lib.autotypeno:
    .quad     0
    .align    8
cc_lib.nextafindex:
    .quad     0
    .align    8
cc_lib.unitheapptr:
    .quad     0
    .align    8
cc_lib.remainingunits:
    .quad     0
    .bss
    .align    2
cc_lib.getoptocode.opctotable:
    .space    156
cc_lib.nextautotype.str:
    .space    32
cc_lib.getopcjname.str:
    .space    20
cc_lib.strmode.str:
    .space    16384
cc_lib.strmode2.str:
    .space    16384
cc_lib.typename.str:
    .space    300
cc_lib.getstname.name:
    .space    256
    .data
cc_support.bytemasks:
    .quad     0x8040201008040201
#ENDDATA
    .align    8
cc_headers.builtinheaders:
    .quad     1
    .align    8
cc_headers.h_assert:
    .quad     L10252
    .align    8
cc_headers.h_ctype:
    .quad     L10253
    .align    8
cc_headers.h_errno:
    .quad     L10254
    .align    8
cc_headers.h_fenv:
    .quad     L10255
    .align    8
cc_headers.h_float:
    .quad     L10256
    .align    8
cc_headers.h_inttypes:
    .quad     L10257
    .align    8
cc_headers.h_stdint:
    .quad     L10258
    .align    8
cc_headers.h_limits:
    .quad     L10259
    .align    8
cc_headers.h_locale:
    .quad     L10260
    .align    8
cc_headers.h__ansi:
    .quad     L10261
    .align    8
cc_headers.h_math:
    .quad     L10262
    .align    8
cc_headers.h_setjmp:
    .quad     L10263
    .align    8
cc_headers.h_signal:
    .quad     L10264
    .align    8
cc_headers.h_stdarg:
    .quad     L10265
    .align    8
cc_headers.h_stdbool:
    .quad     L10266
    .align    8
cc_headers.h_stddef:
    .quad     L10267
    .align    8
cc_headers.h_stdio:
    .quad     L10268
    .align    8
cc_headers.h_stdlib:
    .quad     L10269
    .align    8
cc_headers.h__syslist:
    .quad     L10270
    .align    8
cc_headers.h_string:
    .quad     L10271
    .align    8
cc_headers.h_time:
    .quad     L10272
    .align    8
cc_headers.h_utime:
    .quad     L10273
    .align    8
cc_headers.h_unistd:
    .quad     L10274
    .align    8
cc_headers.h_safelib:
    .quad     L10275
    .align    8
cc_headers.h_wchar:
    .quad     L10276
    .align    8
cc_headers.h_wctype:
    .quad     L10277
    .align    8
cc_headers.h_systypes:
    .quad     L10278
    .align    8
cc_headers.h_sysstat:
    .quad     L10279
    .align    8
cc_headers.h_systimeb:
    .quad     L10280
    .align    8
cc_headers.h_sysutime:
    .quad     L10281
    .align    8
cc_headers.h_memory:
    .quad     L10282
    .align    8
cc_headers.h_fcntl:
    .quad     L10283
    .align    8
cc_headers.h_io:
    .quad     L10284
    .align    8
cc_headers.h_direct:
    .quad     L10285
    .align    8
cc_headers.h_process:
    .quad     L10286
    .align    8
cc_headers.h_malloc:
    .quad     L10287
    .align    8
cc_headers.h_conio:
    .quad     L10288
    .align    8
cc_headers.h_winsock2:
    .quad     L10289
    .align    8
cc_headers.h__mingw:
    .quad     L10290
    .align    8
cc_headers.h_windowsx:
    .quad     L10291
    .align    8
cc_headers.stdhdrnames:
    .quad     L10292
    .quad     L10293
    .quad     L10294
    .quad     L10295
    .quad     L10296
    .quad     L10297
    .quad     L10298
    .quad     L10299
    .quad     L10300
    .quad     L10301
    .quad     L10302
    .quad     L10303
    .quad     L10304
    .quad     L10305
    .quad     L10306
    .quad     L10307
    .quad     L10308
    .quad     L10309
    .quad     L10310
    .quad     L10311
    .quad     L10312
    .quad     L10313
    .quad     L10314
    .quad     L10315
    .quad     L10316
    .quad     L10317
    .quad     L10318
    .quad     L10319
    .quad     L10320
    .quad     L10321
    .quad     L10322
    .quad     L10323
    .quad     L10324
    .quad     L10325
    .quad     L10326
    .quad     L10327
    .quad     L10328
    .quad     L10329
    .quad     L10330
    .quad     L10331
    .align    8
cc_headers.stdhdrtext:
    .quad     cc_headers.h_assert
    .quad     cc_headers.h_ctype
    .quad     cc_headers.h_errno
    .quad     cc_headers.h_fenv
    .quad     cc_headers.h_float
    .quad     cc_headers.h_inttypes
    .quad     cc_headers.h_stdint
    .quad     cc_headers.h_limits
    .quad     cc_headers.h_locale
    .quad     cc_headers.h__ansi
    .quad     cc_headers.h_math
    .quad     cc_headers.h_setjmp
    .quad     cc_headers.h_signal
    .quad     cc_headers.h_stdarg
    .quad     cc_headers.h_stdbool
    .quad     cc_headers.h_stddef
    .quad     cc_headers.h_stdio
    .quad     cc_headers.h_stdlib
    .quad     cc_headers.h__syslist
    .quad     cc_headers.h_string
    .quad     cc_headers.h_time
    .quad     cc_headers.h_utime
    .quad     cc_headers.h_unistd
    .quad     cc_headers.h_safelib
    .quad     cc_headers.h_wchar
    .quad     cc_headers.h_wctype
    .quad     cc_headers.h_systypes
    .quad     cc_headers.h_sysstat
    .quad     cc_headers.h_systimeb
    .quad     cc_headers.h_sysutime
    .quad     cc_headers.h_malloc
    .quad     cc_headers.h_fcntl
    .quad     cc_headers.h_io
    .quad     cc_headers.h_direct
    .quad     cc_headers.h_process
    .quad     cc_headers.h_memory
    .quad     cc_headers.h_conio
    .quad     cc_headers.h_winsock2
    .quad     cc_headers.h__mingw
    .quad     cc_headers.h_windowsx
    .bss
    .align    8
cc_show.currfileno:
    .space    8
    .align    8
cc_show.currlineno:
    .space    8
    .align    8
cc_show.sbuffer:
    .space    16
    .data
    .align    8
cc_show.dest:
    .quad     cc_show.sbuffer
    .bss
    .align    8
cc_show.destlinestart:
    .space    8
    .align    8
cc_show.exprstrvar:
    .space    16
    .data
    .align    8
cc_show.exprstr:
    .quad     cc_show.exprstrvar
    .bss
cc_show.getprefix.str:
    .space    512
cc_show.getdottedname.str:
    .space    256
cc_show.getlineinfok.str:
    .space    40
    .text
# Proc msys.start
msys.start:
#PROC1
#PROC2
#?>>
    .set msys.start.nargs, -8
    .set msys.start.args, -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    sub       rsp,	8
    lea       rax,	[rip+msys.start.startupinfo]
    push      rax
    lea       rcx,	[rbp + msys.start.nargs]
    lea       rdx,	[rbp + msys.start.args]
    lea       r8,	[rip+msys.envstrings]
    xor       r9d,	r9d
    sub       rsp,	32
    call      __getmainargs
    add       rsp,	48
    movsxd    r10,	eax
    mov       rbx,	r10
    movsxd    rax,	dword ptr[rbp + msys.start.nargs]
    mov       [rip+msys.nsysparams],	rax
    mov       rax,	[rip+msys.nsysparams]
    cmp       rax,	128
    jle       L3
    lea       rcx,	[rip+L10332]
    call      printf
    mov       rcx,	50
    call      exit
L3:
    movsxd    rax,	dword ptr[rbp + msys.start.nargs]
    mov       rdi,	rax
    mov       r12,	1
    cmp       rdi,	1
    jl        L6
L4:
    mov       rax,	[rbp + msys.start.args]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    lea       r10,	[rip+msys.sysparams]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
    inc       r12
    cmp       r12,	rdi
    jle       L4
L6:
    mov       rax,	[rip+msys.$cmdskip]
    inc       rax
    mov       r10,	[rip+msys.nsysparams]
    sub       r10,	rax
    mov       [rip+msys.ncmdparams],	r10
    lea       rax,	[rip+msys.sysparams]
    mov       r10,	[rip+msys.$cmdskip]
    lea       rax,	[rax + r10*8]
    mov       [rip+msys.cmdparams],	rax
    mov       rsi,	1
    xor       eax,	eax
    mov       [rip+msys.nenvstrings],	rax
    jmp       L8
L7:
    inc       qword ptr[rip+msys.nenvstrings]
    inc       rsi
L8:
    mov       rax,	[rip+msys.envstrings]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    test      rax,	rax
    jnz       L7
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.pushio
msys.pushio:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+msys.niostack]
    cmp       rax,	10
    jl        L12
    lea       rcx,	[rip+L10333]
    call      printf
    mov       rcx,	53
    call      exit
L12:
    inc       qword ptr[rip+msys.niostack]
    mov       rax,	[rip+msys.outchan]
    lea       r10,	[rip+msys.outchan_stack]
    mov       r11,	[rip+msys.niostack]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[rip+msys.outdev]
    lea       r10,	[rip+msys.outdev_stack]
    mov       r11,	[rip+msys.niostack]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[rip+msys.fmtstr]
    lea       r10,	[rip+msys.fmtstr_stack]
    mov       r11,	[rip+msys.niostack]
    mov       [r10 + r11*8-8],	rax
    mov       al,	[rip+msys.needgap]
    lea       r10,	[rip+msys.needgap_stack]
    mov       r11,	[rip+msys.niostack]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    mov       [rip+msys.needgap],	rax
    xor       eax,	eax
    mov       [rip+msys.fmtstr],	rax
    xor       eax,	eax
    mov       [rip+msys.outchan],	rax
#---------------
    add       rsp,	40
    ret       
# End 
# Proc msys.m$print_startfile
msys.m$print_startfile:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    call      msys.pushio
    mov       [rip+msys.outchan],	rdi
    test      rdi,	rdi
    jz        L15
    mov       rax,	2
    mov       [rip+msys.outdev],	rax
    jmp       L14
L15:
    mov       rax,	1
    mov       [rip+msys.outdev],	rax
L14:
    call      msys.resetprintbuffer
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc msys.m$print_startstr
msys.m$print_startstr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      msys.pushio
    mov       rax,	rbx
    lea       r10,	[rip+msys.ptr_stack]
    mov       r11,	[rip+msys.niostack]
    mov       [r10 + r11*8-8],	rax
    lea       rax,	[rip+msys.ptr_stack]
    mov       r10,	[rip+msys.niostack]
    lea       rax,	[rax + r10*8-8]
    mov       rdi,	rax
    mov       [rip+msys.outchan],	rdi
    mov       rax,	3
    mov       [rip+msys.outdev],	rax
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.m$print_startptr
msys.m$print_startptr:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    call      msys.pushio
    mov       [rip+msys.outchan],	rdi
    mov       rax,	3
    mov       [rip+msys.outdev],	rax
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc msys.m$print_startcon
msys.m$print_startcon:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      msys.pushio
    mov       rax,	1
    mov       [rip+msys.outdev],	rax
    call      msys.resetprintbuffer
#---------------
    add       rsp,	40
    ret       
# End 
# Proc msys.m$print_setfmt
msys.m$print_setfmt:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       [rip+msys.fmtstr],	rcx
#---------------
    ret       
# End 
# Proc msys.m$print_end
msys.m$print_end:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rip+msys.needgap],	rax
    mov       rcx,	1
    call      msys.nextfmtchars
    mov       rax,	[rip+msys.niostack]
    cmp       rax,	1
    jnz       L22
    mov       rax,	[rip+msys.outdev]
    cmp       rax,	1
    jz        L23
    cmp       rax,	2
    jnz       L22
L23:
    call      msys.dumpprintbuffer
L22:
    mov       rax,	[rip+msys.niostack]
    test      rax,	rax
    jz        L20
L25:
    lea       rax,	[rip+msys.outchan_stack]
    mov       r10,	[rip+msys.niostack]
    mov       rax,	[rax + r10*8-8]
    mov       [rip+msys.outchan],	rax
    lea       rax,	[rip+msys.outdev_stack]
    mov       r10,	[rip+msys.niostack]
    mov       rax,	[rax + r10*8-8]
    mov       [rip+msys.outdev],	rax
    lea       rax,	[rip+msys.fmtstr_stack]
    mov       r10,	[rip+msys.niostack]
    mov       rax,	[rax + r10*8-8]
    mov       [rip+msys.fmtstr],	rax
    lea       rax,	[rip+msys.needgap_stack]
    mov       r10,	[rip+msys.niostack]
    movzx     rax,	byte ptr[rax + r10-1]
    mov       [rip+msys.needgap],	rax
    dec       qword ptr[rip+msys.niostack]
L20:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc msys.m$print_ptr
msys.m$print_ptr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    test      rbx,	rbx
    jnz       L28
    lea       rax,	[rip+L10334]
    mov       rbx,	rax
L28:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      msys.m$print_u64
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.m$print_ptr_nf
msys.m$print_ptr_nf:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.m$print_ptr
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc msys.m$print_i64
msys.m$print_i64:
#PROC1
#PROC2
#?>>
    .set msys.m$print_i64.s, -40
    .set msys.m$print_i64.fmt, -56
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rsi,	rsi
    jnz       L32
    cmp       rbx,	0
    jl        L34
    mov       rcx,	rbx
    lea       rdx,	[rbp + msys.m$print_i64.s]
    mov       r8,	10
    xor       r9d,	r9d
    call      msys.u64tostr
    mov       rdi,	rax
    jmp       L33
L34:
    mov       rax,	rbx
    mov       r10,	-9223372036854775808
    cmp       rax,	r10
    jnz       L35
    lea       rax,	[rip+msys.defaultfmt]
    lea       r10,	[rbp + msys.m$print_i64.fmt]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    jmp       L36
L35:
    mov       al,	45
    mov       [rbp + msys.m$print_i64.s],	al
    lea       rax,	[rbp + msys.m$print_i64.s+1]
    mov       r10,	rbx
    neg       r10
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	10
    xor       r9d,	r9d
    call      msys.u64tostr
    inc       rax
    mov       rdi,	rax
L33:
    lea       rcx,	[rbp + msys.m$print_i64.s]
    mov       rdx,	rdi
    call      msys.printstr_n
    jmp       L31
L32:
    mov       rcx,	rsi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_i64.fmt]
    call      msys.strtofmt
    movzx     rax,	byte ptr[rbp + msys.m$print_i64.fmt+14]
    cmp       rax,	86
    jnz       L38
    mov       [rip+msys.fmtparam],	rbx
    xor       eax,	eax
    mov       [rip+msys.needgap],	rax
    jmp       L37
L38:
#msys.m$print_i64.dofmt:
L36:
    mov       rcx,	rbx
    lea       rdx,	[rbp + msys.m$print_i64.fmt]
    call      msys.tostr_i64
L37:
L31:
    mov       rax,	1
    mov       [rip+msys.needgap],	rax
#---------------
    add       rsp,	88
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.m$print_i64_nf
msys.m$print_i64_nf:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.m$print_i64
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc msys.m$print_bool
msys.m$print_bool:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    test      rdi,	rdi
    jz        L42
    lea       rcx,	[rip+L10335]
    mov       rdx,	rbx
    call      msys.m$print_str
    jmp       L41
L42:
    lea       rcx,	[rip+L10336]
    mov       rdx,	rbx
    call      msys.m$print_str
L41:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.m$print_u64
msys.m$print_u64:
#PROC1
#PROC2
#?>>
    .set msys.m$print_u64.s, -40
    .set msys.m$print_u64.fmt, -56
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rbx,	rbx
    jnz       L45
    lea       rcx,	[rbp + msys.m$print_u64.s]
    lea       rdx,	[rip+L10337]
    mov       r8,	rdi
    call      sprintf
    lea       rcx,	[rbp + msys.m$print_u64.s]
    call      msys.printstr
    jmp       L44
L45:
    mov       rcx,	rbx
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_u64.fmt]
    call      msys.strtofmt
    mov       rcx,	rdi
    lea       rdx,	[rbp + msys.m$print_u64.fmt]
    call      msys.tostr_u64
L44:
    mov       rax,	1
    mov       [rip+msys.needgap],	rax
#---------------
    add       rsp,	96
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.m$print_r64
msys.m$print_r64:
#PROC1
#PROC2
#?>>
    .set msys.m$print_r64.s, -360
    .set msys.m$print_r64.fmt, -376
    push      rdi
    movq      rax,	XMM15
    push      rax
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	416
    movq      XMM15,	XMM0
    mov       rdi,	rdx
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rdi,	rdi
    jnz       L48
    lea       rcx,	[rbp + msys.m$print_r64.s]
    lea       rdx,	[rip+L10338]
    movq      XMM2,	XMM15
    movq      r8,	XMM2
    call      sprintf
    lea       rcx,	[rbp + msys.m$print_r64.s]
    call      msys.printstr
    jmp       L47
L48:
    mov       rcx,	rdi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_r64.fmt]
    call      msys.strtofmt
    movq      XMM0,	XMM15
    lea       rdx,	[rbp + msys.m$print_r64.fmt]
    call      msys.tostr_r64
L47:
    mov       rax,	1
    mov       [rip+msys.needgap],	rax
#---------------
    add       rsp,	416
    pop       rbp
    pop       rcx
    movq      XMM15,	rcx
    pop       rdi
    ret       
# End 
# Proc msys.m$print_r32
msys.m$print_r32:
#PROC1
#PROC2
#?>>
    .set msys.m$print_r32.s, -360
    .set msys.m$print_r32.fmt, -376
    push      rdi
    movq      rax,	XMM15
    push      rax
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	416
    movq      XMM15,	XMM0
    mov       rdi,	rdx
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rdi,	rdi
    jnz       L51
    movq      XMM4,	XMM15
    cvtss2sd  XMM4,	XMM4
    lea       rcx,	[rbp + msys.m$print_r32.s]
    lea       rdx,	[rip+L10338]
    movq      XMM2,	XMM4
    movq      r8,	XMM2
    call      sprintf
    lea       rcx,	[rbp + msys.m$print_r32.s]
    call      msys.printstr
    jmp       L50
L51:
    mov       rcx,	rdi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_r32.fmt]
    call      msys.strtofmt
    movq      XMM4,	XMM15
    cvtss2sd  XMM4,	XMM4
    movq      XMM0,	XMM4
    lea       rdx,	[rbp + msys.m$print_r32.fmt]
    call      msys.tostr_r64
L50:
    mov       rax,	1
    mov       [rip+msys.needgap],	rax
#---------------
    add       rsp,	416
    pop       rbp
    pop       rcx
    movq      XMM15,	rcx
    pop       rdi
    ret       
# End 
# Proc msys.m$print_c8
msys.m$print_c8:
#PROC1
#PROC2
#?>>
    .set msys.m$print_c8.a, 40
    .set msys.m$print_c8.s, -32
    .set msys.m$print_c8.fmt, -48
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       [rbp+40],	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    xor       bl,	bl
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rsi,	rsi
    jz        L54
    mov       rcx,	rsi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_c8.fmt]
    call      msys.strtofmt
    mov       bl,	[rbp + msys.m$print_c8.fmt+12]
L54:
    movzx     rax,	bl
    cmp       rax,	77
    jnz       L56
    lea       rcx,	[rbp + msys.m$print_c8.a]
    mov       rdx,	8
    lea       r8,	[rbp + msys.m$print_c8.s]
    lea       r9,	[rbp + msys.m$print_c8.fmt]
    call      msys.domultichar
    mov       rdi,	rax
    jmp       L55
L56:
    mov       rax,	[rbp + msys.m$print_c8.a]
    mov       [rbp + msys.m$print_c8.s],	rax
    xor       eax,	eax
    mov       [rbp + msys.m$print_c8.s+8],	al
    lea       rcx,	[rbp + msys.m$print_c8.s]
    call      msys.getutfsize
    mov       rdi,	rax
L55:
    lea       rcx,	[rbp + msys.m$print_c8.s]
    mov       rdx,	rdi
    call      msys.printstr_n
    mov       rax,	1
    mov       [rip+msys.needgap],	rax
#---------------
    add       rsp,	88
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.m$print_str
msys.m$print_str:
#PROC1
#PROC2
#?>>
    .set msys.m$print_str.fmt, -16
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rdi,	rdi
    jnz       L59
    lea       rcx,	[rip+L10339]
    call      msys.printstr
    jmp       L57
L59:
    test      rbx,	rbx
    jnz       L61
    mov       rcx,	rdi
    call      msys.printstr
    jmp       L60
L61:
    mov       rcx,	rbx
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_str.fmt]
    call      msys.strtofmt
    mov       rcx,	rdi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_str.fmt]
    call      msys.tostr_str
L60:
    mov       rax,	1
    mov       [rip+msys.needgap],	rax
L57:
#---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.m$print_strn
msys.m$print_strn:
#PROC1
#PROC2
#?>>
    .set msys.m$print_strn.fmt, -16
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      msys.nextfmtchars
    test      rdi,	rdi
    jnz       L64
    lea       rcx,	[rip+L10339]
    call      msys.printstr
    jmp       L62
L64:
    test      rsi,	rsi
    jnz       L66
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      msys.printstr_n
    jmp       L65
L66:
    mov       rcx,	rsi
    mov       rdx,	-1
    lea       r8,	[rbp + msys.m$print_strn.fmt]
    call      msys.strtofmt
    mov       rcx,	rdi
    mov       rdx,	rbx
    lea       r8,	[rbp + msys.m$print_strn.fmt]
    call      msys.tostr_str
L65:
    mov       rax,	1
    mov       [rip+msys.needgap],	rax
L62:
#---------------
    add       rsp,	56
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.m$print_str_nf
msys.m$print_str_nf:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.m$print_str
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc msys.m$print_strsl
msys.m$print_strsl:
#PROC1
#PROC2
#?>>
    .set msys.m$print_strsl.s, 16
    .set msys.m$print_strsl.fmtstyle, 24
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+L10340]
    call      mlib.abortprogram
#---------------
    add       rsp,	40
    ret       
# End 
# Proc msys.m$print_newline
msys.m$print_newline:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rip+msys.needgap],	rax
    mov       rcx,	1
    call      msys.nextfmtchars
    lea       rcx,	[rip+L10341]
    call      msys.printstr
#---------------
    add       rsp,	40
    ret       
# End 
# Proc msys.m$print_nogap
msys.m$print_nogap:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rip+msys.needgap],	rax
#---------------
    ret       
# End 
# Proc msys.m$print_space
msys.m$print_space:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rip+msys.needgap],	rax
    lea       rcx,	[rip+L10342]
    call      msys.printstr
#---------------
    add       rsp,	40
    ret       
# End 
# Proc msys.printstr
msys.printstr:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      strlen
    mov       rcx,	rdi
    mov       rdx,	rax
    call      msys.printstr_n
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc msys.printstr_n
msys.printstr_n:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      msys.dumpstr
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.printstrn_app
msys.printstrn_app:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    test      rbx,	rbx
    jz        L76
    test      rsi,	rsi
    jnz       L78
    lea       rcx,	[rip+L10343]
    mov       rdx,	rbx
    mov       r8,	rdi
    call      printf
    jmp       L77
L78:
    mov       rcx,	rsi
    lea       rdx,	[rip+L10343]
    mov       r8,	rbx
    mov       r9,	rdi
    call      fprintf
L77:
L76:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.printchar
msys.printchar:
#PROC1
#PROC2
#?>>
    .set msys.printchar.str, -8
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       [rbp + msys.printchar.str],	dil
    xor       eax,	eax
    mov       [rbp + msys.printchar.str+1],	al
    lea       rcx,	[rbp + msys.printchar.str]
    mov       rdx,	1
    call      msys.printstr_n
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc msys.nextfmtchars
msys.nextfmtchars:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+msys.fmtstr]
    test      rax,	rax
    jnz       L82
    mov       rax,	[rip+msys.needgap]
    test      rax,	rax
    jz        L84
    mov       rcx,	32
    call      msys.printchar
L84:
    xor       eax,	eax
    mov       [rip+msys.needgap],	rax
    jmp       L80
L82:
    mov       rbx,	[rip+msys.fmtstr]
    xor       rsi,	rsi
L85:
    mov       rax,	[rip+msys.fmtstr]
    mov       dil,	[rax]
    movzx     rax,	dil
    cmp       rax,	35
    jz        L88
    test      rax,	rax
    jz        L89
    cmp       rax,	126
    jz        L90
    jmp       L91
L88:
    test      r12,	r12
    jz        L93
    jmp       L94
L93:
    inc       qword ptr[rip+msys.fmtstr]
    test      rsi,	rsi
    jz        L96
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      msys.printstr_n
L96:
    jmp       L80
L89:
    test      rsi,	rsi
    jz        L98
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      msys.printstr_n
    jmp       L97
L98:
    test      r12,	r12
    jnz       L99
    lea       rcx,	[rip+L10344]
    mov       rdx,	1
    call      msys.printstr_n
L99:
L97:
    jmp       L80
L90:
    test      rsi,	rsi
    jz        L101
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      msys.printstr_n
    xor       rsi,	rsi
L101:
    inc       qword ptr[rip+msys.fmtstr]
    mov       rax,	[rip+msys.fmtstr]
    mov       dil,	[rax]
    test      dil,	dil
    jz        L103
    inc       qword ptr[rip+msys.fmtstr]
    movzx     rax,	dil
    mov       rcx,	rax
    call      msys.printchar
L103:
    mov       rbx,	[rip+msys.fmtstr]
    jmp       L87
L91:
#msys.nextfmtchars.skip:
L94:
    inc       rsi
    inc       qword ptr[rip+msys.fmtstr]
L87:
    jmp       L85
L80:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.strtofmt
msys.strtofmt:
#PROC1
#PROC2
#?>>
    .set msys.strtofmt.str, -104
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+msys.defaultfmt]
    movdqu    XMM4,	[rax]
    movdqu    [r15],	XMM4
    test      r13,	r13
    jnz       L106
    jmp       L104
L106:
    cmp       r14,	-1
    jnz       L108
    mov       rcx,	r13
    call      strlen
    mov       r14,	rax
L108:
    lea       rcx,	[rbp + msys.strtofmt.str]
    mov       rdx,	r13
    mov       r8,	r14
    call      memcpy
    xor       eax,	eax
    mov       [rbp + r14 + msys.strtofmt.str],	al
    lea       rax,	[rbp + msys.strtofmt.str]
    mov       r13,	rax
    xor       sil,	sil
    jmp       L110
L109:
    movzx     rax,	byte ptr[r13]
    mov       rdi,	rax
    inc       r13
    cmp       rdi,	65
    jnz       L113
    mov       al,	65
    mov       [r15+8],	al
    jmp       L112
L113:
    cmp       rdi,	97
    jnz       L114
    mov       al,	97
    mov       [r15+8],	al
    jmp       L112
L114:
    mov       rcx,	rdi
    call      toupper
    movsxd    r10,	eax
    sub       r10,	66
    cmp       r10,	25
    jae       L117
    lea       rax,	[rip+L116]
    jmp       [rax + r10*8]
    .data
L116:
    .quad     L118
    .quad     L147
    .quad     L146
    .quad     L143
    .quad     L144
    .quad     L145
    .quad     L119
    .quad     L117
    .quad     L129
    .quad     L117
    .quad     L117
    .quad     L148
    .quad     L151
    .quad     L120
    .quad     L136
    .quad     L128
    .quad     L117
    .quad     L133
    .quad     L139
    .quad     L142
    .quad     L149
    .quad     L117
    .quad     L121
    .quad     L150
    .quad     L132
    .text
L118:
    mov       al,	2
    mov       [r15+2],	al
    jmp       L115
L119:
    mov       al,	16
    mov       [r15+2],	al
    jmp       L115
L120:
    mov       al,	8
    mov       [r15+2],	al
    jmp       L115
L121:
    xor       rbx,	rbx
L122:
    movzx     rax,	byte ptr[r13]
    mov       rdi,	rax
    mov       rax,	rdi
    cmp       rax,	48
    jl        L125
    cmp       rax,	57
    jg        L125
    mov       rax,	rbx
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rax,	rdi
    sub       rax,	48
    mov       rbx,	rax
    inc       r13
    jmp       L124
L125:
    jmp       L123
L124:
    jmp       L122
L123:
    mov       rax,	rbx
    cmp       rax,	2
    jl        L127
    cmp       rax,	16
    jg        L127
    mov       [r15+2],	bl
L127:
    jmp       L115
L128:
    mov       al,	34
    mov       [r15+3],	al
    jmp       L115
L129:
    movzx     rax,	byte ptr[r13]
    mov       rcx,	rax
    call      toupper
    mov       [r15+9],	al
    mov       al,	[r13]
    test      al,	al
    jz        L131
    inc       r13
L131:
    jmp       L115
L132:
    mov       al,	48
    mov       [r15+4],	al
    jmp       L115
L133:
    mov       al,	[r13]
    mov       [r15+7],	al
    mov       al,	[r13]
    test      al,	al
    jz        L135
    inc       r13
L135:
    jmp       L115
L136:
    mov       al,	[r13]
    mov       [r15+4],	al
    mov       al,	[r13]
    test      al,	al
    jz        L138
    inc       r13
L138:
    jmp       L115
L139:
    mov       al,	[r13]
    mov       [r15+10],	al
    mov       al,	[r13]
    test      al,	al
    jz        L141
    inc       r13
L141:
    jmp       L115
L142:
    mov       al,	87
    mov       [r15+11],	al
    jmp       L115
L143:
    mov       al,	101
    mov       [r15+5],	al
    jmp       L115
L144:
    mov       al,	102
    mov       [r15+5],	al
    jmp       L115
L145:
    mov       al,	103
    mov       [r15+5],	al
    jmp       L115
L146:
    mov       al,	68
    mov       [r15+13],	al
    jmp       L115
L147:
    mov       al,	67
    mov       [r15+12],	al
    jmp       L115
L148:
    mov       al,	77
    mov       [r15+12],	al
    jmp       L115
L149:
    mov       al,	86
    mov       [r15+14],	al
    jmp       L115
L150:
    lea       rax,	[r15+15]
    or        byte ptr[rax],	1
    jmp       L115
L151:
    lea       rax,	[r15+15]
    or        byte ptr[rax],	2
    jmp       L115
L117:
    mov       rax,	rdi
    cmp       rax,	46
    jz        L153
    cmp       rax,	44
    jz        L154
    cmp       rax,	95
    jz        L154
    cmp       rax,	43
    jz        L155
    cmp       rax,	126
    jz        L156
    cmp       rax,	42
    jz        L157
    jmp       L158
L153:
    mov       sil,	1
    jmp       L152
L154:
    mov       [r15+7],	dil
    jmp       L152
L155:
    mov       al,	43
    mov       [r15+6],	al
    jmp       L152
L156:
    mov       al,	126
    mov       [r15+3],	al
    jmp       L152
L157:
    mov       r12,	[rip+msys.fmtparam]
    jmp       L159
L158:
    cmp       rdi,	48
    jl        L161
    cmp       rdi,	57
    jg        L161
    lea       rax,	[rdi-48]
    mov       r12,	rax
L162:
    movzx     rax,	byte ptr[r13]
    mov       rdi,	rax
    movzx     rax,	byte ptr[r13]
    test      rax,	rax
    jz        L163
L165:
    cmp       rdi,	48
    jl        L167
    cmp       rdi,	57
    jg        L167
    inc       r13
    mov       rax,	r12
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rax,	rdi
    sub       rax,	48
    mov       r12,	rax
    jmp       L166
L167:
    jmp       L163
L166:
    jmp       L162
L163:
#msys.strtofmt.gotwidth:
L159:
    test      sil,	sil
    jnz       L169
    mov       [r15],	r12b
    mov       sil,	1
    jmp       L168
L169:
    mov       [r15+1],	r12b
L168:
L161:
L152:
L115:
L112:
L110:
    mov       al,	[r13]
    test      al,	al
    jnz       L109
L104:
#---------------
    add       rsp,	136
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.domultichar
msys.domultichar:
#PROC1
#PROC2
#?>>
    .set msys.domultichar.fmt, 88
    .set msys.domultichar.str, -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
    lea       rax,	[rbp + msys.domultichar.str]
    mov       rdi,	rax
    mov       rbx,	r13
    mov       rsi,	r13
    cmp       rsi,	0
    jle       L173
L171:
    movzx     rax,	byte ptr[r12]
    test      rax,	rax
    jz        L173
L175:
    mov       al,	[r12]
    mov       [rdi],	al
    inc       rdi
    inc       r12
    dec       rsi
    jnz       L171
L173:
    xor       eax,	eax
    mov       [rdi],	al
    lea       rcx,	[rbp + msys.domultichar.str]
    call      strlen
    lea       rcx,	[rbp + msys.domultichar.str]
    mov       rdx,	r14
    mov       r8,	rax
    mov       r9,	[rbp + msys.domultichar.fmt]
    call      msys.expandstr
L170:
#---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.expandstr
msys.expandstr:
#PROC1
#PROC2
#?>>
    .set msys.expandstr.n, 80
    .set msys.expandstr.fmt, 88
    .set msys.expandstr.av_2, -8
    .set msys.expandstr.av_3, -16
    .set msys.expandstr.av_4, -24
    .set msys.expandstr.av_5, -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     rax,	byte ptr[rax]
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L179
    cmp       rbx,	[rbp + msys.expandstr.n]
    jg        L178
L179:
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.expandstr.n]
    mov       [r14 + r10],	al
    mov       rax,	[rbp + msys.expandstr.n]
    jmp       L176
L178:
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     rax,	byte ptr[rax+9]
    cmp       rax,	76
    jnz       L181
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    mov       rax,	[rbp + msys.expandstr.n]
    add       r14,	rax
    mov       rdi,	1
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    mov       r12,	rax
    cmp       r12,	1
    jl        L184
L182:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    inc       rdi
    cmp       rdi,	r12
    jle       L182
L184:
    xor       eax,	eax
    mov       [r14],	al
    jmp       L180
L181:
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     rax,	byte ptr[rax+9]
    cmp       rax,	82
    jnz       L185
    mov       rax,	[rbp + msys.expandstr.fmt]
    movzx     rax,	byte ptr[rax+4]
    cmp       rax,	48
    jnz       L187
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+2]
    test      al,	al
    jz        L187
    movzx     rax,	byte ptr[r13]
    cmp       rax,	45
    jz        L188
    movzx     rax,	byte ptr[r13]
    cmp       rax,	43
    jnz       L187
L188:
    mov       al,	[r13]
    mov       [r14],	al
    inc       r14
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    mov       [rbp + msys.expandstr.av_2],	rax
    mov       rax,	[rbp + msys.expandstr.av_2]
    cmp       rax,	0
    jle       L191
L189:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    dec       qword ptr[rbp + msys.expandstr.av_2]
    jnz       L189
L191:
    mov       rax,	[rbp + msys.expandstr.n]
    dec       rax
    lea       r10,	[r13+1]
    mov       rcx,	r14
    mov       rdx,	r10
    mov       r8,	rax
    call      strncpy
    mov       rax,	[rbp + msys.expandstr.n]
    lea       r10,	[r14 + rax]
    sub       r10,	1
    xor       eax,	eax
    mov       [r10],	al
    jmp       L186
L187:
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    mov       [rbp + msys.expandstr.av_3],	rax
    mov       rax,	[rbp + msys.expandstr.av_3]
    cmp       rax,	0
    jle       L194
L192:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    dec       qword ptr[rbp + msys.expandstr.av_3]
    jnz       L192
L194:
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.expandstr.n]
    mov       [r14 + r10],	al
L186:
    jmp       L180
L185:
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    inc       rax
    sar       rax,	1
    mov       rsi,	rax
    mov       [rbp + msys.expandstr.av_4],	rsi
    mov       rax,	[rbp + msys.expandstr.av_4]
    cmp       rax,	0
    jle       L197
L195:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    dec       qword ptr[rbp + msys.expandstr.av_4]
    jnz       L195
L197:
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.expandstr.n]
    call      strncpy
    mov       rax,	[rbp + msys.expandstr.n]
    add       r14,	rax
    mov       rax,	rbx
    sub       rax,	[rbp + msys.expandstr.n]
    sub       rax,	rsi
    mov       [rbp + msys.expandstr.av_5],	rax
    mov       rax,	[rbp + msys.expandstr.av_5]
    cmp       rax,	0
    jle       L200
L198:
    mov       rax,	[rbp + msys.expandstr.fmt]
    mov       al,	[rax+4]
    mov       [r14],	al
    inc       r14
    dec       qword ptr[rbp + msys.expandstr.av_5]
    jnz       L198
L200:
    xor       eax,	eax
    mov       [r14],	al
L180:
    mov       rax,	rbx
L176:
#---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.u64tostr
msys.u64tostr:
#PROC1
#PROC2
#?>>
    .set msys.u64tostr.t, -360
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	368
#---------------
#PROC3
#PROC4
    xor       rbx,	rbx
    xor       eax,	eax
    mov       r12,	rax
    cmp       r8,	10
    jnz       L203
    mov       rax,	3
    jmp       L202
L203:
    mov       rax,	4
L202:
    mov       r13,	rax
L204:
    mov       rax,	rcx
    mov       r10,	r8
    push      rdx
    xor       edx,	edx
    div       r10
    xchg      rax,	rdx
    pop       rdx
    mov       rdi,	rax
    mov       rax,	rcx
    mov       r10,	r8
    push      rdx
    xor       edx,	edx
    div       r10
    pop       rdx
    mov       rcx,	rax
    lea       rax,	[rip+msys.digits]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    inc       rbx
    mov       r10,	rbx
    mov       [rbp + r10 + msys.u64tostr.t],	al
    inc       r12
    test      r9,	r9
    jz        L208
    test      rcx,	rcx
    jz        L208
    cmp       r12,	r13
    jnz       L208
    inc       rbx
    mov       rax,	rbx
    mov       r10b,	r9b
    mov       [rbp + rax + msys.u64tostr.t],	r10b
    xor       r12,	r12
L208:
    test      rcx,	rcx
    jnz       L204
    mov       rsi,	rbx
    mov       r14,	rdx
    jmp       L210
L209:
    mov       rax,	rbx
    dec       rbx
    mov       al,	[rbp + rax + msys.u64tostr.t]
    mov       [rdx],	al
    inc       rdx
L210:
    test      rbx,	rbx
    jnz       L209
    xor       eax,	eax
    mov       [rdx],	al
    mov       rax,	rsi
L201:
#---------------
    add       rsp,	368
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.i64tostrfmt
msys.i64tostrfmt:
#PROC1
#PROC2
#?>>
    .set msys.i64tostrfmt.str, -360
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	392
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    xor       rbx,	rbx
    mov       al,	[r13+11]
    test      al,	al
    jz        L214
    mov       rbx,	1
L214:
    mov       rax,	rsi
    mov       r10,	-9223372036854775808
    cmp       rax,	r10
    jnz       L216
    test      rbx,	rbx
    jnz       L216
    mov       al,	45
    mov       [rbp + msys.i64tostrfmt.str],	al
    movzx     rax,	byte ptr[r13+7]
    movzx     r10,	byte ptr[r13+2]
    lea       r11,	[rbp + msys.i64tostrfmt.str+1]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      msys.i64mintostr
    inc       rax
    mov       rdi,	rax
    jmp       L215
L216:
    test      rbx,	rbx
    jnz       L220
    cmp       rsi,	0
    jl        L219
L220:
    mov       al,	[r13+6]
    test      al,	al
    jz        L218
L219:
    cmp       rsi,	0
    jge       L222
    mov       rax,	rsi
    neg       rax
    mov       rsi,	rax
    mov       al,	45
    mov       [rbp + msys.i64tostrfmt.str],	al
    jmp       L221
L222:
    mov       al,	43
    mov       [rbp + msys.i64tostrfmt.str],	al
L221:
    movzx     rax,	byte ptr[r13+7]
    movzx     r10,	byte ptr[r13+2]
    lea       r11,	[rbp + msys.i64tostrfmt.str+1]
    mov       rcx,	rsi
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      msys.u64tostr
    inc       rax
    mov       rdi,	rax
    jmp       L217
L218:
    movzx     rax,	byte ptr[r13+7]
    movzx     r10,	byte ptr[r13+2]
    mov       rcx,	rsi
    lea       rdx,	[rbp + msys.i64tostrfmt.str]
    mov       r8,	r10
    mov       r9,	rax
    call      msys.u64tostr
    mov       rdi,	rax
L217:
L215:
    mov       al,	[r13+10]
    test      al,	al
    jz        L224
    mov       al,	[r13+10]
    mov       [rbp + rdi + msys.i64tostrfmt.str],	al
    inc       rdi
    mov       rax,	rdi
    xor       r10d,	r10d
    mov       [rbp + rax + msys.i64tostrfmt.str],	r10b
L224:
    movzx     rax,	byte ptr[r13+2]
    cmp       rax,	10
    jg        L227
    mov       al,	[r13+10]
    test      al,	al
    jz        L226
L227:
    movzx     rax,	byte ptr[r13+8]
    cmp       rax,	97
    jnz       L226
    lea       rcx,	[rbp + msys.i64tostrfmt.str]
    call      mlib.convlcstring
L226:
    lea       rcx,	[rbp + msys.i64tostrfmt.str]
    mov       rdx,	r12
    mov       r8,	rdi
    mov       r9,	r13
    call      msys.expandstr
L212:
#---------------
    add       rsp,	392
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.u64tostrfmt
msys.u64tostrfmt:
#PROC1
#PROC2
#?>>
    .set msys.u64tostrfmt.str, -360
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	400
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[r12+7]
    movzx     r10,	byte ptr[r12+2]
    mov       rcx,	rbx
    lea       rdx,	[rbp + msys.u64tostrfmt.str]
    mov       r8,	r10
    mov       r9,	rax
    call      msys.u64tostr
    mov       rdi,	rax
    mov       al,	[r12+10]
    test      al,	al
    jz        L230
    mov       al,	[r12+10]
    mov       [rbp + rdi + msys.u64tostrfmt.str],	al
    inc       rdi
    mov       rax,	rdi
    xor       r10d,	r10d
    mov       [rbp + rax + msys.u64tostrfmt.str],	r10b
L230:
    movzx     rax,	byte ptr[r12+2]
    cmp       rax,	10
    jg        L233
    mov       al,	[r12+10]
    test      al,	al
    jz        L232
    movzx     rax,	byte ptr[r12+8]
    cmp       rax,	97
    jnz       L232
L233:
L232:
    lea       rcx,	[rbp + msys.u64tostrfmt.str]
    mov       rdx,	rsi
    mov       r8,	rdi
    mov       r9,	r12
    call      msys.expandstr
L228:
#---------------
    add       rsp,	400
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.i64mintostr
msys.i64mintostr:
#PROC1
#PROC2
#?>>
    .set msys.i64mintostr.t, -360
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	392
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
#---------------
#PROC3
#PROC4
    mov       rax,	r14
    cmp       rax,	10
    jz        L236
    cmp       rax,	16
    jz        L237
    cmp       rax,	2
    jz        L238
    jmp       L239
L236:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[rip+L10345]
    call      strcpy
    mov       rbx,	3
    jmp       L235
L237:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[rip+L10346]
    call      strcpy
    mov       rbx,	1
    jmp       L235
L238:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[rip+L10347]
    call      strcpy
    mov       rbx,	7
    jmp       L235
L239:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    lea       rdx,	[rip+L10348]
    call      strcpy
L235:
    lea       rax,	[rbp + msys.i64mintostr.t]
    mov       rcx,	rax
    call      strlen
    mov       rdi,	rax
    mov       rax,	rdi
    add       r13,	rax
    test      r15,	r15
    jz        L241
    mov       rax,	rbx
    add       r13,	rax
L241:
    xor       eax,	eax
    mov       [r13],	al
    xor       rsi,	rsi
    mov       rax,	r14
    cmp       rax,	10
    jnz       L243
    mov       rax,	3
    jmp       L242
L243:
    mov       rax,	4
L242:
    mov       r12,	rax
    jmp       L245
L244:
    dec       r13
    mov       rax,	rdi
    dec       rdi
    mov       al,	[rbp + rax + msys.i64mintostr.t-1]
    mov       [r13],	al
    test      r15,	r15
    jz        L248
    test      rdi,	rdi
    jz        L248
    inc       rsi
    cmp       rsi,	r12
    jnz       L248
    dec       r13
    mov       [r13],	r15b
    xor       rsi,	rsi
L248:
L245:
    test      rdi,	rdi
    jnz       L244
    mov       rcx,	r13
    call      strlen
L234:
#---------------
    add       rsp,	392
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.strtostrfmt
msys.strtostrfmt:
#PROC1
#PROC2
#?>>
    .set msys.strtostrfmt.n, 80
    .set msys.strtostrfmt.fmt, 88
    .set msys.strtostrfmt.str, -256
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
    xor       r12,	r12
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+3]
    test      al,	al
    jnz       L252
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+8]
    test      al,	al
    jz        L251
L252:
    mov       rax,	[rbp + msys.strtostrfmt.n]
    cmp       rax,	256
    jge       L254
    lea       rax,	[rbp + msys.strtostrfmt.str]
    mov       rdi,	rax
    jmp       L253
L254:
    mov       rax,	[rbp + msys.strtostrfmt.n]
    add       rax,	3
    mov       r12,	rax
    mov       rcx,	r12
    call      mlib.pcm_alloc
    mov       rdi,	rax
L253:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+3]
    test      al,	al
    jz        L256
    mov       rbx,	rdi
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+3]
    mov       [rbx],	al
    inc       rbx
    mov       rax,	[rbp + msys.strtostrfmt.n]
    test      rax,	rax
    jz        L258
    mov       rcx,	rbx
    mov       rdx,	r13
    call      strcpy
    mov       rax,	[rbp + msys.strtostrfmt.n]
    add       rbx,	rax
L258:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    mov       al,	[rax+3]
    mov       [rbx],	al
    inc       rbx
    xor       eax,	eax
    mov       [rbx],	al
    mov       rax,	2
    add       [rbp + msys.strtostrfmt.n],	rax
    jmp       L255
L256:
    mov       rcx,	rdi
    mov       rdx,	r13
    mov       r8,	[rbp + msys.strtostrfmt.n]
    call      memcpy
L255:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    movzx     rax,	byte ptr[rax+8]
    cmp       rax,	97
    jz        L260
    cmp       rax,	65
    jz        L261
    jmp       L262
L260:
    mov       rcx,	rdi
    call      mlib.convlcstring
    jmp       L259
L261:
    mov       rcx,	rdi
    call      mlib.convucstring
L262:
L259:
    mov       r13,	rdi
L251:
    mov       rax,	[rbp + msys.strtostrfmt.fmt]
    movzx     rax,	byte ptr[rax]
    mov       rsi,	rax
    cmp       rsi,	[rbp + msys.strtostrfmt.n]
    jle       L264
    mov       rcx,	r13
    mov       rdx,	r14
    mov       r8,	[rbp + msys.strtostrfmt.n]
    mov       r9,	[rbp + msys.strtostrfmt.fmt]
    call      msys.expandstr
    mov       [rbp + msys.strtostrfmt.n],	rax
    jmp       L263
L264:
    mov       rcx,	r14
    mov       rdx,	r13
    mov       r8,	[rbp + msys.strtostrfmt.n]
    call      memcpy
L263:
    test      r12,	r12
    jz        L266
    mov       rcx,	rdi
    mov       rdx,	r12
    call      mlib.pcm_free
L266:
    mov       rax,	[rbp + msys.strtostrfmt.n]
L249:
#---------------
    add       rsp,	288
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.tostr_i64
msys.tostr_i64:
#PROC1
#PROC2
#?>>
    .set msys.tostr_i64.a, 32
    .set msys.tostr_i64.str, -360
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	400
    mov       [rbp+32],	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rbx+12]
    test      rax,	rax
    jz        L269
    cmp       rax,	77
    jz        L270
    jmp       L271
L269:
    mov       rcx,	[rbp + msys.tostr_i64.a]
    lea       rdx,	[rbp + msys.tostr_i64.str]
    mov       r8,	rbx
    call      msys.i64tostrfmt
    mov       rdi,	rax
    jmp       L268
L270:
    lea       rcx,	[rbp + msys.tostr_i64.a]
    mov       rdx,	8
    lea       r8,	[rbp + msys.tostr_i64.str]
    mov       r9,	rbx
    call      msys.domultichar
    mov       rdi,	rax
    jmp       L268
L271:
    mov       rcx,	[rbp + msys.tostr_i64.a]
    xor       edx,	edx
    call      msys.m$print_c8
    jmp       L267
L268:
    lea       rcx,	[rbp + msys.tostr_i64.str]
    mov       rdx,	rdi
    call      msys.printstr_n
L267:
#---------------
    add       rsp,	400
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.tostr_u64
msys.tostr_u64:
#PROC1
#PROC2
#?>>
    .set msys.tostr_u64.a, 32
    .set msys.tostr_u64.str, -360
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	400
    mov       [rbp+32],	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rbx+12]
    cmp       rax,	77
    jz        L274
    cmp       rax,	67
    jz        L275
    jmp       L276
L274:
    lea       rcx,	[rbp + msys.tostr_u64.a]
    mov       rdx,	8
    lea       r8,	[rbp + msys.tostr_u64.str]
    mov       r9,	rbx
    call      msys.domultichar
    mov       rdi,	rax
    jmp       L273
L275:
    mov       rcx,	[rbp + msys.tostr_u64.a]
    xor       edx,	edx
    call      msys.m$print_c8
    jmp       L272
L276:
    mov       rcx,	[rbp + msys.tostr_u64.a]
    lea       rdx,	[rbp + msys.tostr_u64.str]
    mov       r8,	rbx
    call      msys.u64tostrfmt
    mov       rdi,	rax
L273:
    lea       rcx,	[rbp + msys.tostr_u64.str]
    mov       rdx,	rdi
    call      msys.printstr_n
L272:
#---------------
    add       rsp,	400
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.tostr_r64
msys.tostr_r64:
#PROC1
#PROC2
#?>>
    .set msys.tostr_r64.str, -360
    .set msys.tostr_r64.str2, -720
    .set msys.tostr_r64.cfmt, -736
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	776
    movq      XMM15,	XMM0
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       al,	37
    mov       [rbp + msys.tostr_r64.cfmt],	al
    mov       al,	[rbx+1]
    test      al,	al
    jz        L279
    mov       al,	46
    mov       [rbp + msys.tostr_r64.cfmt+1],	al
    mov       al,	42
    mov       [rbp + msys.tostr_r64.cfmt+2],	al
    mov       al,	[rbx+5]
    mov       [rbp + msys.tostr_r64.cfmt+3],	al
    xor       eax,	eax
    mov       [rbp + msys.tostr_r64.cfmt+4],	al
    movsx     rax,	byte ptr[rbx+1]
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.cfmt]
    mov       r8,	rax
    movq      XMM3,	XMM15
    movq      r9,	XMM3
    call      sprintf
    jmp       L278
L279:
    mov       al,	[rbx+5]
    mov       [rbp + msys.tostr_r64.cfmt+1],	al
    xor       eax,	eax
    mov       [rbp + msys.tostr_r64.cfmt+2],	al
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.cfmt]
    movq      XMM2,	XMM15
    movq      r8,	XMM2
    call      sprintf
L278:
    lea       rcx,	[rbp + msys.tostr_r64.str]
    call      strlen
    mov       rdi,	rax
    movzx     rax,	byte ptr[rbx]
    mov       r10,	rdi
    cmp       r10,	rax
    jge       L281
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.str2]
    mov       r8,	rdi
    mov       r9,	rbx
    call      msys.expandstr
    mov       rdi,	rax
    lea       rcx,	[rbp + msys.tostr_r64.str]
    lea       rdx,	[rbp + msys.tostr_r64.str2]
    call      strcpy
L281:
    lea       rcx,	[rbp + msys.tostr_r64.str]
    mov       rdx,	rdi
    call      msys.printstr_n
#---------------
    add       rsp,	776
    pop       rbp
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.tostr_str
msys.tostr_str:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
#---------------
#PROC3
#PROC4
    cmp       r13,	-1
    jnz       L284
    mov       rcx,	r12
    call      strlen
    mov       r13,	rax
L284:
    mov       rdi,	r13
    mov       al,	[r14+3]
    test      al,	al
    jnz       L287
    movzx     rax,	byte ptr[r14]
    cmp       rax,	rdi
    jg        L287
    mov       al,	[r14+8]
    test      al,	al
    jnz       L287
    mov       al,	[r14+1]
    test      al,	al
    jz        L286
L287:
    mov       al,	[r14+3]
    test      al,	al
    jz        L289
    mov       rax,	2
    add       rdi,	rax
L289:
    movzx     rax,	byte ptr[r14]
    cmp       rax,	rdi
    jle       L291
    movzx     rax,	byte ptr[r14]
    mov       rdi,	rax
L291:
    lea       rax,	[rdi+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rsi,	rax
    mov       rcx,	r12
    mov       rdx,	rsi
    mov       r8,	r13
    mov       r9,	r14
    call      msys.strtostrfmt
    mov       rbx,	rax
    mov       al,	[r14+1]
    test      al,	al
    jz        L293
    movsx     rax,	byte ptr[r14+1]
    cmp       rbx,	rax
    jle       L10349
    mov       rbx,	rax
L10349:
L293:
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      msys.printstr_n
    lea       rax,	[rdi+1]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mlib.pcm_free
    jmp       L285
L286:
    mov       rcx,	r12
    mov       rdx,	r13
    call      msys.printstr_n
L285:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.getfmt
msys.getfmt:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    test      rdi,	rdi
    jz        L296
    mov       rcx,	rdi
    mov       rdx,	-1
    lea       r8,	[rip+msys.getfmt.fmt]
    call      msys.strtofmt
    lea       rax,	[rip+msys.getfmt.fmt]
    jmp       L295
L296:
    lea       rax,	[rip+msys.defaultfmt]
L295:
L294:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc msys.strint
msys.strint:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+msys.strint.str]
    call      msys.m$print_startstr
    mov       rcx,	rsi
    call      msys.getfmt
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rbx
    mov       rdx,	rax
    call      msys.tostr_i64
    call      msys.m$print_end
    lea       rcx,	[rip+msys.strint.str]
    mov       rdx,	rdi
    call      msys.getstr
L297:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.getstrint
msys.getstrint:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      msys.m$print_startstr
    xor       ecx,	ecx
    call      msys.getfmt
    mov       rcx,	rdi
    mov       rdx,	rax
    call      msys.tostr_i64
    call      msys.m$print_end
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.strword
msys.strword:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+msys.strword.str]
    call      msys.m$print_startstr
    mov       rcx,	rsi
    call      msys.getfmt
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rbx
    mov       rdx,	rax
    call      msys.tostr_u64
    call      msys.m$print_end
    lea       rcx,	[rip+msys.strword.str]
    mov       rdx,	rdi
    call      msys.getstr
L299:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.strreal
msys.strreal:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
#?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+msys.strreal.str]
    call      msys.m$print_startstr
    mov       rcx,	rbx
    call      msys.getfmt
    mov       r10,	rax
    mov       rdi,	r10
    movq      XMM0,	XMM15
    mov       rdx,	rax
    call      msys.tostr_r64
    call      msys.m$print_end
    lea       rcx,	[rip+msys.strreal.str]
    mov       rdx,	rdi
    call      msys.getstr
L300:
#---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.getstr
msys.getstr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       al,	[rbx+13]
    test      al,	al
    jz        L303
    mov       rcx,	rdi
    call      mlib.pcm_copyheapstring
    jmp       L302
L303:
    mov       rax,	rdi
L302:
L301:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.initreadbuffer
msys.initreadbuffer:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+msys.rd_buffer]
    test      rax,	rax
    jnz       L304
L306:
    mov       rcx,	16384
    call      mlib.pcm_alloc
    mov       [rip+msys.rd_buffer],	rax
    xor       eax,	eax
    mov       r10,	[rip+msys.rd_buffer]
    mov       [r10],	al
    mov       rax,	[rip+msys.rd_buffer]
    mov       [rip+msys.rd_lastpos],	rax
    mov       [rip+msys.rd_pos],	rax
L304:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc msys.m$read_conline
msys.m$read_conline:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      msys.initreadbuffer
    xor       ecx,	ecx
    mov       rdx,	[rip+msys.rd_buffer]
    mov       r8,	16384
    call      mlib.readlinen
    mov       rcx,	[rip+msys.rd_buffer]
    call      strlen
    mov       [rip+msys.rd_length],	rax
    mov       rax,	[rip+msys.rd_buffer]
    mov       [rip+msys.rd_pos],	rax
    xor       eax,	eax
    mov       [rip+msys.rd_lastpos],	rax
#---------------
    add       rsp,	40
    ret       
# End 
# Proc msys.m$read_fileline
msys.m$read_fileline:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    call      msys.initreadbuffer
    cmp       rdi,	1
    jnz       L310
    lea       rcx,	[rip+L10350]
    call      mlib.abortprogram
    jmp       L308
L310:
    mov       rcx,	rdi
    mov       rdx,	[rip+msys.rd_buffer]
    mov       r8,	16384
    call      mlib.readlinen
    mov       rcx,	[rip+msys.rd_buffer]
    call      strlen
    mov       [rip+msys.rd_length],	rax
    mov       rax,	[rip+msys.rd_buffer]
    mov       [rip+msys.rd_pos],	rax
    xor       eax,	eax
    mov       [rip+msys.rd_lastpos],	rax
L308:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc msys.m$read_strline
msys.m$read_strline:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      msys.initreadbuffer
    mov       rcx,	rbx
    call      strlen
    mov       rdi,	rax
    cmp       rdi,	16384
    jge       L313
    mov       rcx,	[rip+msys.rd_buffer]
    mov       rdx,	rbx
    call      strcpy
    jmp       L312
L313:
    mov       rcx,	[rip+msys.rd_buffer]
    mov       rdx,	rbx
    mov       r8,	16383
    call      memcpy
    mov       rax,	[rip+msys.rd_buffer]
    lea       rax,	[rax+16384]
    sub       rax,	1
    xor       r10d,	r10d
    mov       [rax],	r10b
L312:
    mov       [rip+msys.rd_length],	rdi
    mov       rax,	[rip+msys.rd_buffer]
    mov       [rip+msys.rd_pos],	rax
    xor       eax,	eax
    mov       [rip+msys.rd_lastpos],	rax
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.readitem
msys.readitem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r14,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+msys.rd_buffer]
    test      rax,	rax
    jnz       L316
    call      msys.initreadbuffer
L316:
    mov       rbx,	[rip+msys.rd_pos]
    jmp       L318
L317:
    inc       rbx
L318:
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	32
    jz        L317
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	9
    jz        L317
    mov       rsi,	rbx
    mov       rax,	rbx
    mov       [rip+msys.rd_pos],	rax
    mov       [rip+msys.rd_lastpos],	rax
    movzx     rax,	byte ptr[rbx]
    test      rax,	rax
    jnz       L321
    xor       eax,	eax
    mov       [rip+msys.termchar],	rax
    xor       eax,	eax
    mov       [r14],	rax
    mov       rax,	rbx
    jmp       L314
L321:
    xor       r12b,	r12b
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	34
    jnz       L323
    mov       r12b,	34
    inc       rbx
    jmp       L322
L323:
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	39
    jnz       L324
    mov       r12b,	39
    inc       rbx
L324:
L322:
    mov       rax,	rbx
    mov       rsi,	rax
    mov       rdi,	rax
    jmp       L326
L325:
    mov       rax,	rbx
    inc       rbx
    mov       r13b,	[rax]
    movzx     rax,	r13b
    cmp       rax,	32
    jz        L329
    cmp       rax,	9
    jz        L329
    cmp       rax,	44
    jz        L329
    cmp       rax,	61
    jnz       L330
L329:
    test      r12b,	r12b
    jnz       L333
    cmp       rdi,	rbx
    jnz       L332
L333:
    jmp       L334
L332:
    movzx     rax,	r13b
    mov       [rip+msys.termchar],	rax
    jmp       L327
L330:
#msys.readitem.normalchar:
L334:
    movzx     rax,	r13b
    movzx     r10,	r12b
    cmp       rax,	r10
    jnz       L336
    movzx     rax,	byte ptr[rbx]
    movzx     r10,	r12b
    cmp       rax,	r10
    jnz       L338
    mov       [rdi],	r13b
    inc       rbx
    inc       rdi
    jmp       L337
L338:
    movzx     rax,	byte ptr[rbx]
    mov       [rip+msys.termchar],	rax
    mov       rax,	[rip+msys.termchar]
    cmp       rax,	44
    jz        L341
    cmp       rax,	61
    jnz       L340
L341:
    inc       rbx
    movzx     rax,	byte ptr[rbx]
    mov       [rip+msys.termchar],	rax
L340:
    jmp       L327
L337:
    jmp       L335
L336:
    mov       [rdi],	r13b
    inc       rdi
L335:
L328:
L326:
    mov       al,	[rbx]
    test      al,	al
    jnz       L325
L327:
    movzx     rax,	byte ptr[rbx]
    test      rax,	rax
    jnz       L343
    xor       eax,	eax
    mov       [rip+msys.termchar],	rax
L343:
    mov       rax,	rdi
    sub       rax,	rsi
    mov       [r14],	rax
    mov       [rip+msys.rd_pos],	rbx
    mov       rax,	rsi
L314:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.strtoint
msys.strtoint:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rip+msys.itemerror],	rax
    cmp       r14,	-1
    jnz       L346
    mov       rcx,	r13
    call      strlen
    mov       r14,	rax
L346:
    xor       dil,	dil
    mov       rax,	r14
    test      rax,	rax
    jz        L348
    movzx     rax,	byte ptr[r13]
    cmp       rax,	45
    jnz       L348
    mov       dil,	1
    inc       r13
    dec       r14
    jmp       L347
L348:
    test      r14,	r14
    jz        L349
    movzx     rax,	byte ptr[r13]
    cmp       rax,	43
    jnz       L349
    inc       r13
    dec       r14
L349:
L347:
    xor       rbx,	rbx
    jmp       L351
L350:
    mov       rax,	r13
    inc       r13
    movzx     rax,	byte ptr[rax]
    mov       rsi,	rax
    dec       r14
    mov       rax,	rsi
    cmp       rax,	65
    jl        L354
    cmp       rax,	70
    jg        L354
    lea       rax,	[rsi-65]
    add       rax,	10
    mov       r12,	rax
    jmp       L353
L354:
    mov       rax,	rsi
    cmp       rax,	97
    jl        L355
    cmp       rax,	102
    jg        L355
    lea       rax,	[rsi-97]
    add       rax,	10
    mov       r12,	rax
    jmp       L353
L355:
    mov       rax,	rsi
    cmp       rax,	48
    jl        L356
    cmp       rax,	57
    jg        L356
    lea       rax,	[rsi-48]
    mov       r12,	rax
    jmp       L353
L356:
    mov       rax,	rsi
    cmp       rax,	95
    jz        L358
    cmp       rax,	39
    jnz       L357
L358:
    jmp       L351
L357:
    mov       rax,	1
    mov       [rip+msys.itemerror],	rax
    jmp       L352
L353:
    cmp       r12,	r15
    jb        L360
    mov       rax,	1
    mov       [rip+msys.itemerror],	rax
    jmp       L352
L360:
    mov       rax,	rbx
    mov       r10,	r15
    imul      rax,	r10
    add       rax,	r12
    mov       rbx,	rax
L351:
    test      r14,	r14
    jnz       L350
L352:
    test      dil,	dil
    jz        L362
    mov       rax,	rbx
    neg       rax
    jmp       L361
L362:
    mov       rax,	rbx
L361:
L344:
#---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.m$read_i64
msys.m$read_i64:
#PROC1
#PROC2
#?>>
    .set msys.m$read_i64.length, -8
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      toupper
    movsxd    r10,	eax
    mov       rbx,	r10
    mov       rax,	rbx
    cmp       rax,	67
    jz        L365
    cmp       rax,	84
    jz        L366
    cmp       rax,	69
    jz        L367
    jmp       L368
L365:
    mov       rax,	[rip+msys.rd_pos]
    mov       [rip+msys.rd_lastpos],	rax
    mov       rax,	[rip+msys.rd_pos]
    mov       al,	[rax]
    test      al,	al
    jz        L370
    mov       rax,	[rip+msys.rd_pos]
    inc       qword ptr[rip+msys.rd_pos]
    movzx     rax,	byte ptr[rax]
    jmp       L363
L370:
    xor       eax,	eax
    jmp       L363
L369:
    jmp       L364
L366:
    mov       rax,	[rip+msys.termchar]
    jmp       L363
L367:
    mov       rax,	[rip+msys.itemerror]
    jmp       L363
L368:
L364:
    lea       rcx,	[rbp + msys.m$read_i64.length]
    call      msys.readitem
    mov       rdi,	rax
    mov       rax,	rbx
    test      rax,	rax
    jz        L372
    cmp       rax,	73
    jz        L372
    cmp       rax,	66
    jz        L373
    cmp       rax,	72
    jz        L374
    jmp       L375
L372:
    mov       rcx,	rdi
    mov       rdx,	[rbp + msys.m$read_i64.length]
    mov       r8,	10
    call      msys.strtoint
    jmp       L363
L373:
    mov       rcx,	rdi
    mov       rdx,	[rbp + msys.m$read_i64.length]
    mov       r8,	2
    call      msys.strtoint
    jmp       L363
L374:
    mov       rcx,	rdi
    mov       rdx,	[rbp + msys.m$read_i64.length]
    mov       r8,	16
    call      msys.strtoint
    jmp       L363
L375:
L371:
    xor       eax,	eax
L363:
#---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.m$read_r64
msys.m$read_r64:
#PROC1
#PROC2
#?>>
    .set msys.m$read_r64.fmt, 24
    .set msys.m$read_r64.str, -512
    .set msys.m$read_r64.length, -520
    .set msys.m$read_r64.numlength, -528
    .set msys.m$read_r64.x, -536
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	568
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + msys.m$read_r64.length]
    call      msys.readitem
    mov       rdi,	rax
    mov       rax,	[rbp + msys.m$read_r64.length]
    test      rax,	rax
    jz        L379
    mov       rax,	[rbp + msys.m$read_r64.length]
    cmp       rax,	512
    jl        L378
L379:
    movq      XMM0,	[rip+L10351]
    jmp       L376
L378:
    lea       rcx,	[rbp + msys.m$read_r64.str]
    mov       rdx,	rdi
    mov       r8,	[rbp + msys.m$read_r64.length]
    call      memcpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.m$read_r64.length]
    mov       [rbp + r10 + msys.m$read_r64.str],	al
    xor       eax,	eax
    mov       [rip+msys.itemerror],	rax
    lea       rcx,	[rbp + msys.m$read_r64.str]
    lea       rdx,	[rip+L10352]
    lea       r8,	[rbp + msys.m$read_r64.x]
    lea       r9,	[rbp + msys.m$read_r64.numlength]
    call      sscanf
    movsxd    r10,	eax
    test      r10,	r10
    jz        L382
    movsxd    rax,	dword ptr[rbp + msys.m$read_r64.numlength]
    cmp       rax,	[rbp + msys.m$read_r64.length]
    jz        L381
L382:
    movq      XMM4,	[rip+L10353]
    movq      [rbp + msys.m$read_r64.x],	XMM4
    mov       rax,	1
    mov       [rip+msys.itemerror],	rax
L381:
    movq      XMM0,	[rbp + msys.m$read_r64.x]
L376:
#---------------
    add       rsp,	568
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc msys.m$read_str
msys.m$read_str:
#PROC1
#PROC2
#?>>
    .set msys.m$read_str.length, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rip+msys.itemerror],	rax
    mov       rax,	r12
    cmp       rax,	76
    jz        L386
    cmp       rax,	108
    jnz       L385
L386:
    mov       rdi,	[rip+msys.rd_pos]
    mov       rax,	[rip+msys.rd_buffer]
    mov       r10,	[rip+msys.rd_length]
    lea       rax,	[rax + r10]
    sub       rax,	[rip+msys.rd_pos]
    mov       [rbp + msys.m$read_str.length],	rax
    jmp       L384
L385:
    lea       rcx,	[rbp + msys.m$read_str.length]
    call      msys.readitem
    mov       rdi,	rax
    mov       rax,	r12
    cmp       rax,	78
    jz        L389
    cmp       rax,	110
    jnz       L388
L389:
    mov       rcx,	rdi
    mov       rdx,	[rbp + msys.m$read_str.length]
    call      mlib.iconvlcn
L388:
L384:
    cmp       rsi,	0
    jle       L391
    mov       rax,	[rbp + msys.m$read_str.length]
    cmp       rax,	rsi
    jl        L393
    lea       rax,	[rsi-1]
    mov       [rbp + msys.m$read_str.length],	rax
    mov       rax,	1
    mov       [rip+msys.itemerror],	rax
L393:
L391:
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	[rbp + msys.m$read_str.length]
    call      memcpy
    xor       eax,	eax
    mov       r10,	[rbp + msys.m$read_str.length]
    mov       [rbx + r10],	al
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.readstr
msys.readstr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	rbx
    call      msys.m$read_str
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.rereadln
msys.rereadln:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+msys.rd_buffer]
    mov       [rip+msys.rd_pos],	rax
    mov       rax,	[rip+msys.rd_pos]
    mov       [rip+msys.rd_lastpos],	rax
#---------------
    ret       
# End 
# Proc msys.reread
msys.reread:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+msys.rd_lastpos]
    mov       [rip+msys.rd_pos],	rax
#---------------
    ret       
# End 
# Proc msys.valint
msys.valint:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
#---------------
#PROC3
#PROC4
    call      msys.initreadbuffer
    mov       rdi,	[rip+msys.rd_pos]
    mov       rbx,	[rip+msys.rd_lastpos]
    mov       [rip+msys.rd_pos],	r12
    mov       rcx,	r13
    call      msys.m$read_i64
    mov       rsi,	rax
    mov       [rip+msys.rd_pos],	rdi
    mov       [rip+msys.rd_lastpos],	rbx
    mov       rax,	rsi
L397:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.valreal
msys.valreal:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    movq      rax,	XMM15
    push      rax
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    call      msys.initreadbuffer
    mov       rdi,	[rip+msys.rd_pos]
    mov       rbx,	[rip+msys.rd_lastpos]
    mov       [rip+msys.rd_pos],	rsi
    xor       ecx,	ecx
    call      msys.m$read_r64
    movq      XMM15,	XMM0
    mov       [rip+msys.rd_pos],	rdi
    mov       [rip+msys.rd_lastpos],	rbx
    movq      XMM0,	XMM15
L398:
#---------------
    add       rsp,	40
    pop       rcx
    movq      XMM15,	rcx
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.mclunimpl
msys.mclunimpl:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+L10354]
    mov       rdx,	rdi
    call      printf
    mov       rcx,	1
    call      exit
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc msys.dumpstr
msys.dumpstr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+msys.outdev]
    cmp       rax,	3
    jnz       L402
    mov       rdi,	[rip+msys.outchan]
    test      rsi,	rsi
    jz        L404
    mov       rax,	[rdi]
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcpy
    mov       rax,	rdi
    mov       r10,	rsi
    add       [rax],	r10
L404:
    mov       rax,	[rdi]
    xor       r10d,	r10d
    mov       [rax],	r10b
    jmp       L400
L402:
    test      rsi,	rsi
    jnz       L406
    jmp       L400
L406:
    test      r12,	r12
    jz        L408
    cmp       rsi,	2
    jl        L408
    mov       rax,	[rip+msys.outdev]
    cmp       rax,	1
    jnz       L408
    dec       qword ptr[rip+msys.printptr]
    mov       rax,	[rip+msys.printptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	10
    jnz       L410
    mov       rax,	[rip+msys.printptr]
    sub       rax,	1
    movzx     rax,	byte ptr[rax]
    cmp       rax,	13
    jnz       L412
    mov       rax,	[rip+msys.printptr]
    sub       rax,	1
    xor       r10d,	r10d
    mov       [rax],	r10b
    jmp       L411
L412:
    xor       eax,	eax
    mov       r10,	[rip+msys.printptr]
    mov       [r10],	al
L411:
    lea       rcx,	[rip+msys.printbuffer]
    call      puts
    jmp       L400
L410:
L408:
    mov       rax,	[rip+msys.outdev]
    cmp       rax,	1
    jz        L414
    cmp       rax,	2
    jz        L415
    jmp       L416
L414:
    lea       rcx,	[rip+L10355]
    mov       rdx,	rsi
    mov       r8,	rbx
    call      printf
    jmp       L413
L415:
    mov       rcx,	[rip+msys.outchan]
    lea       rdx,	[rip+L10355]
    mov       r8,	rsi
    mov       r9,	rbx
    call      fprintf
L416:
L413:
L400:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.dumpprintbuffer
msys.dumpprintbuffer:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+msys.printlen]
    test      rax,	rax
    jz        L419
    lea       rcx,	[rip+msys.printbuffer]
    mov       rdx,	[rip+msys.printlen]
    mov       r8,	1
    call      msys.dumpstr
L419:
    call      msys.resetprintbuffer
#---------------
    add       rsp,	40
    ret       
# End 
# Proc msys.resetprintbuffer
msys.resetprintbuffer:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+msys.printbuffer]
    mov       [rip+msys.printptr],	rax
    xor       eax,	eax
    mov       [rip+msys.printlen],	rax
#---------------
    ret       
# End 
# Proc msys.addtobuffer
msys.addtobuffer:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+msys.printlen]
    add       rax,	rbx
    cmp       rax,	4088
    jl        L423
    call      msys.dumpprintbuffer
L423:
    cmp       rbx,	4096
    jge       L425
    mov       rcx,	[rip+msys.printptr]
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	rbx
    add       [rip+msys.printptr],	rax
    mov       rax,	rbx
    add       [rip+msys.printlen],	rax
    jmp       L421
L425:
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      msys.dumpstr
L421:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.m$power_i64
msys.m$power_i64:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    cmp       rbx,	0
    jge       L428
    xor       eax,	eax
    jmp       L427
L428:
    test      rbx,	rbx
    jnz       L429
    mov       rax,	1
    jmp       L427
L429:
    cmp       rbx,	1
    jnz       L430
    mov       rax,	rdi
    jmp       L427
L430:
    mov       rax,	rbx
    and       rax,	1
    jnz       L431
    mov       rax,	rbx
    sar       rax,	1
    mov       r10,	rdi
    imul      r10,	r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      msys.m$power_i64
    jmp       L427
L431:
    lea       rax,	[rbx-1]
    sar       rax,	1
    mov       r10,	rdi
    imul      r10,	r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      msys.m$power_i64
    mov       r10,	rdi
    imul      rax,	r10
L427:
L426:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msys.getutfsize
msys.getutfsize:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    mov       rax,	rcx
    inc       rcx
    movzx     rax,	byte ptr[rax]
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L434
    xor       eax,	eax
    jmp       L433
L434:
    mov       eax,	edi
    shr       eax,	7
    and       eax,	1
    test      rax,	rax
    jnz       L435
    mov       rax,	1
    jmp       L433
L435:
    mov       rax,	rdi
    shr       rax,	5
    and       rax,	7
    cmp       rax,	6
    jnz       L436
    mov       rax,	2
    jmp       L433
L436:
    mov       rax,	rdi
    shr       rax,	4
    and       rax,	15
    cmp       rax,	14
    jnz       L437
    mov       rax,	3
    jmp       L433
L437:
    mov       rax,	rdi
    shr       rax,	3
    and       rax,	31
    cmp       rax,	30
    jnz       L438
    mov       rax,	4
    jmp       L433
L438:
    mov       rax,	1
L433:
L432:
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc mlib.pcm_alloc
mlib.pcm_alloc:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       al,	[rip+mlib.pcm_setup]
    test      al,	al
    jnz       L441
    call      mlib.pcm_init
L441:
    cmp       rbx,	2048
    jle       L443
    mov       rcx,	rbx
    call      mlib.pcm_getac
    mov       [rip+mlib.alloccode],	rax
    lea       rax,	[rip+mlib.allocupper]
    mov       r10,	[rip+mlib.alloccode]
    mov       rax,	[rax + r10*8]
    mov       [rip+mlib.allocbytes],	rax
    mov       rcx,	[rip+mlib.allocbytes]
    call      mlib.allocmem
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L445
    lea       rcx,	[rip+L10356]
    call      mlib.abortprogram
L445:
    mov       rax,	rdi
    jmp       L439
L443:
    lea       rax,	[rip+mlib.sizeindextable]
    mov       r10,	rbx
    movzx     rax,	byte ptr[rax + r10]
    mov       [rip+mlib.alloccode],	rax
    lea       rax,	[rip+mlib.allocupper]
    mov       r10,	[rip+mlib.alloccode]
    mov       rax,	[rax + r10*8]
    mov       [rip+mlib.allocbytes],	rax
    lea       rax,	[rip+mlib.freelist]
    mov       r10,	[rip+mlib.alloccode]
    mov       rax,	[rax + r10*8]
    mov       rdi,	rax
    test      rax,	rax
    jz        L447
    lea       rax,	[rip+mlib.freelist]
    mov       r10,	[rip+mlib.alloccode]
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax]
    lea       r10,	[rip+mlib.freelist]
    mov       r11,	[rip+mlib.alloccode]
    mov       [r10 + r11*8],	rax
    mov       rax,	rdi
    jmp       L439
L447:
    mov       rdi,	[rip+mlib.pcheapptr]
    mov       rax,	[rip+mlib.allocbytes]
    add       [rip+mlib.pcheapptr],	rax
    mov       rax,	[rip+mlib.pcheapptr]
    cmp       rax,	[rip+mlib.pcheapend]
    jb        L449
    mov       rcx,	[rip+mlib.allocbytes]
    call      mlib.pcm_newblock
    mov       rdi,	rax
    mov       rax,	rdi
    jmp       L439
L449:
    mov       rax,	rdi
L439:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.pcm_free
mlib.pcm_free:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    test      rsi,	rsi
    jz        L453
    test      rbx,	rbx
    jnz       L452
L453:
    jmp       L450
L452:
    cmp       rsi,	2048
    jle       L455
    mov       rcx,	rbx
    call      free
    jmp       L454
L455:
    lea       rax,	[rip+mlib.sizeindextable]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10]
    mov       rdi,	rax
    lea       rax,	[rip+mlib.freelist]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       [rbx],	rax
    mov       rax,	rbx
    lea       r10,	[rip+mlib.freelist]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
L454:
L450:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.pcm_freeac
mlib.pcm_freeac:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mlib.allocupper]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.pcm_free
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.pcm_clearmem
mlib.pcm_clearmem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	rbx
    call      memset
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.pcm_init
mlib.pcm_init:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rip+mlib.alloccode],	rax
    mov       al,	[rip+mlib.pcm_setup]
    test      al,	al
    jnz       L458
L460:
    xor       ecx,	ecx
    call      mlib.pcm_newblock
    mov       r13,	1
L461:
    mov       rdi,	1
    mov       rbx,	16
    jmp       L465
L464:
    mov       rax,	rbx
    shl       rax,	1
    mov       rbx,	rax
    inc       rdi
L465:
    cmp       r13,	rbx
    jg        L464
    mov       al,	dil
    lea       r10,	[rip+mlib.sizeindextable]
    mov       r11,	r13
    mov       [r10 + r11],	al
    inc       r13
    cmp       r13,	2048
    jle       L461
    mov       rax,	16
    lea       r10,	[rip+mlib.allocupper]
    mov       [r10+8],	rax
    mov       rsi,	16
    mov       r13,	2
L467:
    mov       rax,	rsi
    shl       rax,	1
    mov       rsi,	rax
    mov       rax,	rsi
    lea       r10,	[rip+mlib.allocupper]
    mov       r11,	r13
    mov       [r10 + r11*8],	rax
    cmp       rsi,	33554432
    jl        L471
    mov       rbx,	r13
    jmp       L469
L471:
    inc       r13
    cmp       r13,	27
    jle       L467
L469:
    lea       rax,	[rbx+1]
    mov       r13,	rax
    mov       r12,	300
    cmp       r13,	r12
    jg        L474
L472:
    mov       rax,	33554432
    add       rsi,	rax
    mov       rax,	rsi
    mov       r10,	8589934592
    cmp       rax,	r10
    jge       L476
    mov       rax,	rsi
    lea       r10,	[rip+mlib.allocupper]
    mov       r11,	r13
    mov       [r10 + r11*8],	rax
    mov       [rip+mlib.maxmemory],	rsi
    jmp       L475
L476:
    lea       rax,	[r13-1]
    mov       [rip+mlib.maxalloccode],	rax
    jmp       L474
L475:
    inc       r13
    cmp       r13,	r12
    jle       L472
L474:
    mov       al,	1
    mov       [rip+mlib.pcm_setup],	al
L458:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.pcm_getac
mlib.pcm_getac:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    cmp       rcx,	2048
    jg        L479
    lea       rax,	[rip+mlib.sizeindextable]
    mov       r10,	rcx
    movzx     rax,	byte ptr[rax + r10]
    jmp       L477
L479:
    lea       rax,	[rcx+255]
    sar       rax,	8
    mov       rcx,	rax
    cmp       rcx,	2048
    jg        L481
    lea       rax,	[rip+mlib.sizeindextable]
    mov       r10,	rcx
    movzx     rax,	byte ptr[rax + r10]
    add       rax,	8
    jmp       L477
L481:
    lea       rax,	[rcx+63]
    sar       rax,	6
    mov       rcx,	rax
    cmp       rcx,	2048
    jg        L483
    lea       rax,	[rip+mlib.sizeindextable]
    mov       r10,	rcx
    movzx     rax,	byte ptr[rax + r10]
    add       rax,	14
    jmp       L477
L483:
    lea       rax,	[rcx-2048]
    add       rax,	2047
    sar       rax,	11
    add       rax,	22
    mov       rcx,	rax
    mov       rax,	rcx
L477:
#---------------
    ret       
# End 
# Proc mlib.pcm_newblock
mlib.pcm_newblock:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	2097152
    add       [rip+mlib.pcm_newblock.totalheapsize],	rax
    xor       eax,	eax
    mov       [rip+mlib.alloccode],	rax
    mov       rcx,	2097152
    call      mlib.allocmem
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L486
    lea       rcx,	[rip+L10357]
    call      mlib.abortprogram
L486:
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	2097152
    call      memset
    mov       [rip+mlib.pcheapptr],	rdi
    lea       rax,	[rdi+2097152]
    mov       [rip+mlib.pcheapend],	rax
    mov       rax,	[rip+mlib.pcheapstart]
    test      rax,	rax
    jnz       L488
    mov       [rip+mlib.pcheapstart],	rdi
L488:
    mov       rax,	rbx
    add       [rip+mlib.pcheapptr],	rax
    mov       rax,	rdi
L484:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.pcm_round
mlib.pcm_round:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    cmp       rcx,	2048
    jle       L491
    mov       rax,	rcx
    jmp       L490
L491:
    lea       rax,	[rip+mlib.sizeindextable]
    mov       r10,	rcx
    movzx     rax,	byte ptr[rax + r10]
    lea       r10,	[rip+mlib.pcm_round.allocbytes]
    movsxd    r10,	dword ptr[r10 + rax*4]
    mov       rax,	r10
L490:
L489:
#---------------
    ret       
# End 
# Proc mlib.pcm_allocz
mlib.pcm_allocz:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	rbx
    call      memset
    mov       rax,	rdi
L492:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.pcm_copyheapstring
mlib.pcm_copyheapstring:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    test      rsi,	rsi
    jnz       L495
    xor       eax,	eax
    jmp       L493
L495:
    mov       rcx,	rsi
    call      strlen
    inc       rax
    mov       rbx,	rax
    mov       rcx,	rbx
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	rdi
L493:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.pcm_copyheapstringn
mlib.pcm_copyheapstringn:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    test      rbx,	rbx
    jnz       L498
    xor       eax,	eax
    jmp       L496
L498:
    lea       rax,	[rsi+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcpy
    xor       eax,	eax
    mov       [rdi + rsi],	al
    mov       rax,	rdi
L496:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.pcm_copyheapblock
mlib.pcm_copyheapblock:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    test      rsi,	rsi
    jnz       L501
    xor       eax,	eax
    jmp       L499
L501:
    mov       rcx,	rsi
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcpy
    mov       rax,	rdi
L499:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.allocmem
mlib.allocmem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      malloc
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L504
    mov       rax,	rdi
    jmp       L502
L504:
    call      msys.m$print_startcon
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    mov       rcx,	[rip+mlib.memtotal]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10358]
    call      mlib.abortprogram
    xor       eax,	eax
L502:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.reallocmem
mlib.reallocmem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      realloc
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L507
    mov       rax,	rdi
    jmp       L505
L507:
    call      msys.m$print_startcon
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10359]
    call      mlib.abortprogram
    xor       eax,	eax
L505:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.abortprogram
mlib.abortprogram:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10360]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	5
    call      exit
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mlib.getfilesize
mlib.getfilesize:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rsi
    call      ftell
    mov       edi,	eax
    mov       rcx,	rsi
    xor       edx,	edx
    mov       r8,	2
    call      fseek
    mov       rcx,	rsi
    call      ftell
    mov       ebx,	eax
    mov       eax,	edi
    mov       rcx,	rsi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      fseek
    mov       eax,	ebx
L509:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.readrandom
mlib.readrandom:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	r12
    xor       r8d,	r8d
    call      fseek
    mov       rcx,	rsi
    mov       rdx,	1
    mov       r8,	r13
    mov       r9,	rbx
    call      fread
    mov       rdi,	rax
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.writerandom
mlib.writerandom:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      fseek
    mov       rcx,	rbx
    mov       rdx,	1
    mov       r8,	r12
    mov       r9,	rdi
    call      fwrite
L511:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.setfilepos
mlib.setfilepos:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      fseek
    movsxd    r10,	eax
    mov       rax,	r10
L512:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.getfilepos
mlib.getfilepos:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      ftell
    movsxd    r10,	eax
    mov       rax,	r10
L513:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mlib.readfile
mlib.readfile:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	r13
    lea       rdx,	[rip+L10361]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L516
    xor       eax,	eax
    jmp       L514
L516:
    mov       rcx,	rdi
    call      mlib.getfilesize
    mov       rbx,	rax
    mov       [rip+mlib.rfsize],	rax
    lea       rax,	[rbx+2]
    mov       rcx,	rax
    call      malloc
    mov       rsi,	rax
    test      rsi,	rsi
    jnz       L518
    xor       eax,	eax
    jmp       L514
L518:
    mov       rcx,	rdi
    mov       rdx,	rsi
    xor       r8d,	r8d
    mov       r9,	rbx
    call      mlib.readrandom
    lea       rax,	[rsi + rbx]
    mov       r12,	rax
    xor       eax,	eax
    mov       [r12],	ax
    mov       rcx,	rdi
    call      fclose
    mov       rax,	rsi
L514:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.writefile
mlib.writefile:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rsi
    lea       rdx,	[rip+L10362]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L521
    xor       eax,	eax
    jmp       L519
L521:
    mov       rcx,	rdi
    mov       rdx,	r12
    xor       r8d,	r8d
    mov       r9,	r13
    call      mlib.writerandom
    mov       rbx,	rax
    mov       rcx,	rdi
    call      fclose
    mov       rax,	rbx
L519:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.checkfile
mlib.checkfile:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    lea       rdx,	[rip+L10363]
    call      fopen
    mov       rdi,	rax
    test      rax,	rax
    jz        L524
    mov       rcx,	rdi
    call      fclose
    mov       rax,	1
    jmp       L522
L524:
    xor       eax,	eax
L522:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.readlinen
mlib.readlinen:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
#---------------
#PROC3
#PROC4
    test      r13,	r13
    jnz       L527
    call      mwindows.os_getstdin
    mov       r13,	rax
L527:
    test      r13,	r13
    jnz       L529
    xor       rsi,	rsi
    mov       rax,	r14
    mov       rbx,	rax
L530:
    call      getchar
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       rdi,	13
    jz        L534
    cmp       rdi,	10
    jz        L534
    cmp       rdi,	-1
    jnz       L533
L534:
    xor       eax,	eax
    mov       [rbx],	al
    jmp       L525
L533:
    mov       rax,	rbx
    inc       rbx
    mov       r10b,	dil
    mov       [rax],	r10b
    inc       rsi
    lea       rax,	[r15-2]
    mov       r10,	rsi
    cmp       r10,	rax
    jl        L536
    xor       eax,	eax
    mov       [rbx],	al
    jmp       L525
L536:
    jmp       L530
L529:
    xor       eax,	eax
    mov       [r14],	al
    lea       rax,	[r15-2]
    mov       rcx,	r14
    mov       rdx,	rax
    mov       r8,	r13
    call      fgets
    test      rax,	rax
    jz        L525
L538:
    mov       rcx,	r14
    call      strlen
    mov       rsi,	rax
    test      rsi,	rsi
    jnz       L540
    jmp       L525
L540:
    lea       rax,	[r14 + rsi]
    sub       rax,	1
    mov       rbx,	rax
    xor       r12b,	r12b
    jmp       L542
L541:
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	13
    jz        L546
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	10
    jnz       L545
L546:
    mov       r12b,	1
L545:
    mov       rax,	rbx
    dec       rbx
    xor       r10d,	r10d
    mov       [rax],	r10b
L542:
    cmp       rbx,	r14
    jb        L547
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	13
    jz        L541
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	10
    jz        L541
L547:
    test      r12b,	r12b
    jnz       L549
    lea       rax,	[rsi+4]
    cmp       rax,	r15
    jle       L549
    call      msys.m$print_startcon
    mov       rcx,	r15
    call      msys.m$print_i64_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10364]
    call      mlib.abortprogram
L549:
L525:
#---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.iconvlcn
mlib.iconvlcn:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rdi,	rsi
    cmp       rdi,	0
    jle       L553
L551:
    movzx     rax,	byte ptr[rbx]
    mov       rcx,	rax
    call      tolower
    mov       [rbx],	al
    inc       rbx
    dec       rdi
    jnz       L551
L553:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.iconvucn
mlib.iconvucn:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rdi,	rsi
    cmp       rdi,	0
    jle       L557
L555:
    movzx     rax,	byte ptr[rbx]
    mov       rcx,	rax
    call      toupper
    mov       [rbx],	al
    inc       rbx
    dec       rdi
    jnz       L555
L557:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.convlcstring
mlib.convlcstring:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	rbx
    jmp       L560
L559:
    movzx     rax,	byte ptr[rbx]
    mov       rcx,	rax
    call      tolower
    mov       [rbx],	al
    inc       rbx
L560:
    mov       al,	[rbx]
    test      al,	al
    jnz       L559
    mov       rax,	rdi
L558:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.convucstring
mlib.convucstring:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	rbx
    jmp       L564
L563:
    movzx     rax,	byte ptr[rbx]
    mov       rcx,	rax
    call      toupper
    mov       [rbx],	al
    inc       rbx
L564:
    mov       al,	[rbx]
    test      al,	al
    jnz       L563
    mov       rax,	rdi
L562:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.changeext
mlib.changeext:
#PROC1
#PROC2
#?>>
    .set mlib.changeext.newext2, -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mlib.changeext.newfile]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      strcpy
    movzx     rax,	byte ptr[r12]
    test      rax,	rax
    jz        L568
    cmp       rax,	46
    jz        L569
    jmp       L570
L568:
    xor       eax,	eax
    mov       [rbp + mlib.changeext.newext2],	al
    xor       eax,	eax
    mov       [rbp + mlib.changeext.newext2+1],	al
    jmp       L567
L569:
    lea       rax,	[rbp + mlib.changeext.newext2]
    mov       rcx,	rax
    mov       rdx,	r12
    call      strcpy
    jmp       L567
L570:
    lea       rax,	[rbp + mlib.changeext.newext2]
    mov       rcx,	rax
    lea       rdx,	[rip+L10365]
    call      strcpy
    lea       rax,	[rbp + mlib.changeext.newext2]
    mov       rcx,	rax
    mov       rdx,	r12
    call      strcat
L567:
    mov       rcx,	rsi
    mov       rdx,	1
    call      mlib.extractext
    mov       rdi,	rax
    movzx     rax,	byte ptr[rdi]
    test      rax,	rax
    jz        L572
    cmp       rax,	46
    jz        L573
    jmp       L574
L572:
    lea       rax,	[rbp + mlib.changeext.newext2]
    lea       r10,	[rip+mlib.changeext.newfile]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcat
    jmp       L571
L573:
    lea       rax,	[rbp + mlib.changeext.newext2+1]
    lea       r10,	[rip+mlib.changeext.newfile]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcat
    jmp       L571
L574:
    mov       rax,	rdi
    sub       rax,	rsi
    sub       rax,	2
    mov       rbx,	rax
    lea       rax,	[rbp + mlib.changeext.newext2]
    lea       r10,	[rip+mlib.changeext.newfile]
    mov       r11,	rbx
    lea       r10,	[r10 + r11+1]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcpy
L571:
    lea       rax,	[rip+mlib.changeext.newfile]
L566:
#---------------
    add       rsp,	64
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.extractext
mlib.extractext:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rsi
    call      mlib.extractfile
    mov       rdi,	rax
    movzx     rax,	byte ptr[rdi]
    test      rax,	rax
    jnz       L577
    lea       rax,	[rip+L10366]
    jmp       L575
L577:
    mov       rcx,	rdi
    call      strlen
    lea       r10,	[rdi + rax]
    sub       r10,	1
    mov       rbx,	r10
    jmp       L579
L578:
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	46
    jnz       L582
    movzx     rax,	byte ptr[rbx+1]
    test      rax,	rax
    jnz       L584
    test      r12,	r12
    jz        L586
    lea       rax,	[rip+L10367]
    jmp       L585
L586:
    lea       rax,	[rip+L10368]
L585:
    jmp       L575
L584:
    lea       rax,	[rbx+1]
    jmp       L575
L582:
    dec       rbx
L579:
    cmp       rbx,	rdi
    jae       L578
    lea       rax,	[rip+L10368]
L575:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.extractpath
mlib.extractpath:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rsi
    call      strlen
    lea       r10,	[rsi + rax]
    sub       r10,	1
    mov       rdi,	r10
    jmp       L589
L588:
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	92
    jz        L592
    cmp       rax,	47
    jz        L592
    cmp       rax,	58
    jnz       L593
L592:
    mov       rax,	rdi
    sub       rax,	rsi
    inc       rax
    mov       rbx,	rax
    lea       rcx,	[rip+mlib.extractpath.str]
    mov       rdx,	rsi
    mov       r8,	rbx
    call      memcpy
    xor       eax,	eax
    lea       r10,	[rip+mlib.extractpath.str]
    mov       r11,	rbx
    mov       [r10 + r11],	al
    lea       rax,	[rip+mlib.extractpath.str]
    jmp       L587
L593:
L591:
    dec       rdi
L589:
    cmp       rdi,	rsi
    jae       L588
    lea       rax,	[rip+L10368]
L587:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.extractfile
mlib.extractfile:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      mlib.extractpath
    mov       rdi,	rax
    movzx     rax,	byte ptr[rdi]
    test      rax,	rax
    jnz       L596
    mov       rax,	rbx
    jmp       L594
L596:
    mov       rcx,	rdi
    call      strlen
    lea       r10,	[rbx + rax]
    mov       rax,	r10
L594:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.extractbasefile
mlib.extractbasefile:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	r13
    call      mlib.extractfile
    mov       rdi,	rax
    mov       rcx,	rdi
    call      strlen
    mov       r12,	rax
    test      r12,	r12
    jnz       L599
    lea       rax,	[rip+L10368]
    jmp       L597
L599:
    mov       rcx,	rdi
    xor       edx,	edx
    call      mlib.extractext
    mov       rbx,	rax
    mov       al,	[rbx]
    test      al,	al
    jz        L601
    mov       rcx,	rbx
    call      strlen
    mov       r10,	r12
    sub       r10,	rax
    dec       r10
    mov       rsi,	r10
    lea       rcx,	[rip+mlib.extractbasefile.str]
    mov       rdx,	rdi
    mov       r8,	rsi
    call      memcpy
    xor       eax,	eax
    lea       r10,	[rip+mlib.extractbasefile.str]
    mov       r11,	rsi
    mov       [r10 + r11],	al
    lea       rax,	[rip+mlib.extractbasefile.str]
    jmp       L597
L601:
    lea       rax,	[rdi + r12]
    sub       rax,	1
    movzx     rax,	byte ptr[rax]
    cmp       rax,	46
    jnz       L603
    lea       rax,	[r12-1]
    lea       rcx,	[rip+mlib.extractbasefile.str]
    mov       rdx,	rdi
    mov       r8,	rax
    call      memcpy
    xor       eax,	eax
    lea       r10,	[rip+mlib.extractbasefile.str]
    mov       r11,	r12
    mov       [r10 + r11-1],	al
    lea       rax,	[rip+mlib.extractbasefile.str]
    jmp       L597
L603:
    mov       rax,	rdi
L597:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.addext
mlib.addext:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	1
    call      mlib.extractext
    mov       rdi,	rax
    movzx     rax,	byte ptr[rdi]
    test      rax,	rax
    jnz       L606
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mlib.changeext
    jmp       L604
L606:
    mov       rax,	rbx
L604:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.pcm_alloc32
mlib.pcm_alloc32:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rax,	32
    mov       [rip+mlib.allocbytes],	rax
    lea       rax,	[rip+mlib.freelist]
    mov       rax,	[rax+16]
    mov       rdi,	rax
    test      rax,	rax
    jz        L609
    lea       rax,	[rip+mlib.freelist]
    mov       rax,	[rax+16]
    mov       rax,	[rax]
    lea       r10,	[rip+mlib.freelist]
    mov       [r10+16],	rax
    mov       rax,	rdi
    jmp       L607
L609:
    mov       rcx,	32
    call      mlib.pcm_alloc
L607:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mlib.pcm_free32
mlib.pcm_free32:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mlib.freelist]
    mov       rax,	[rax+16]
    mov       [rcx],	rax
    mov       rax,	rcx
    lea       r10,	[rip+mlib.freelist]
    mov       [r10+16],	rax
#---------------
    ret       
# End 
# Proc mlib.outbyte
mlib.outbyte:
#PROC1
#PROC2
#?>>
    .set mlib.outbyte.x, 32
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
    mov       [rbp+32],	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + mlib.outbyte.x]
    mov       rdx,	1
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc mlib.outu16
mlib.outu16:
#PROC1
#PROC2
#?>>
    .set mlib.outu16.x, 32
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
    mov       [rbp+32],	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + mlib.outu16.x]
    mov       rdx,	2
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc mlib.outu32
mlib.outu32:
#PROC1
#PROC2
#?>>
    .set mlib.outu32.x, 32
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
    mov       [rbp+32],	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + mlib.outu32.x]
    mov       rdx,	4
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc mlib.outu64
mlib.outu64:
#PROC1
#PROC2
#?>>
    .set mlib.outu64.x, 32
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
    mov       [rbp+32],	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + mlib.outu64.x]
    mov       rdx,	8
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc mlib.outstring
mlib.outstring:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      strlen
    inc       rax
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.outblock
mlib.outblock:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	1
    mov       r9,	rdi
    call      fwrite
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.myeof
mlib.myeof:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      fgetc
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       rdi,	-1
    jnz       L619
    mov       rax,	1
    jmp       L617
L619:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      ungetc
    xor       eax,	eax
L617:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.strbuffer_add
mlib.strbuffer_add:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
#---------------
#PROC3
#PROC4
    cmp       r14,	-1
    jnz       L622
    mov       rcx,	r13
    call      strlen
    mov       r14,	rax
L622:
    movsxd    rax,	dword ptr[r12+8]
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L624
    lea       rax,	[r14+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r12],	rax
    mov       eax,	[rip+mlib.allocbytes]
    mov       [r12+12],	eax
    mov       [r12+8],	r14d
    mov       rax,	[r12]
    mov       rcx,	rax
    mov       rdx,	r13
    mov       r8,	r14
    call      memcpy
    mov       rax,	[r12]
    xor       r10d,	r10d
    mov       r11,	r14
    mov       [rax + r11],	r10b
    jmp       L620
L624:
    mov       rax,	rbx
    add       rax,	r14
    mov       rdi,	rax
    lea       rax,	[rdi+1]
    movsxd    r10,	dword ptr[r12+12]
    cmp       rax,	r10
    jle       L626
    lea       rax,	[rdi+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rsi,	rax
    mov       rax,	[r12]
    mov       rcx,	rsi
    mov       rdx,	rax
    mov       r8,	rbx
    call      memcpy
    mov       [r12],	rsi
    mov       eax,	[rip+mlib.allocbytes]
    mov       [r12+12],	eax
L626:
    mov       rax,	[r12]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    mov       rdx,	r13
    mov       r8,	r14
    call      memcpy
    mov       rax,	[r12]
    xor       r10d,	r10d
    mov       r11,	rdi
    mov       [rax + r11],	r10b
    mov       [r12+8],	edi
L620:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.gs_init
mlib.gs_init:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	16
    call      mlib.pcm_clearmem
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mlib.gs_free
mlib.gs_free:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       eax,	[rdi+12]
    test      eax,	eax
    jz        L630
    movsxd    rax,	dword ptr[rdi+12]
    mov       r10,	[rdi]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.pcm_free
L630:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mlib.gs_str
mlib.gs_str:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.gs_char
mlib.gs_char:
#PROC1
#PROC2
#?>>
    .set mlib.gs_char.s, -16
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       [rbp + mlib.gs_char.s],	bl
    xor       eax,	eax
    mov       [rbp + mlib.gs_char.s+1],	al
    mov       rcx,	rdi
    lea       rdx,	[rbp + mlib.gs_char.s]
    mov       r8,	1
    call      mlib.strbuffer_add
#---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.gs_strn
mlib.gs_strn:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mlib.strbuffer_add
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.gs_strvar
mlib.gs_strvar:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbx]
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.gs_strint
mlib.gs_strint:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.gs_strln
mlib.gs_strln:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mlib.gs_str
    mov       rcx,	rdi
    call      mlib.gs_line
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.gs_strsp
mlib.gs_strsp:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[rip+L10369]
    call      mlib.gs_str
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.gs_line
mlib.gs_line:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    lea       rdx,	[rip+L10370]
    mov       r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mlib.gs_getcol
mlib.gs_getcol:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rcx+8]
L639:
#---------------
    ret       
# End 
# Proc mlib.gs_leftstr
mlib.gs_leftstr:
#PROC1
#PROC2
#?>>
    .set mlib.gs_leftstr.w, 80
    .set mlib.gs_leftstr.padch, 88
    .set mlib.gs_leftstr.str, -2560
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2592
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r13+8]
    mov       rdi,	rax
    lea       rcx,	[rbp + mlib.gs_leftstr.str]
    mov       rdx,	r14
    call      strcpy
    mov       rcx,	r14
    call      strlen
    mov       r12,	rax
    mov       rax,	[rbp + mlib.gs_leftstr.w]
    sub       rax,	r12
    mov       rsi,	rax
    cmp       rsi,	0
    jle       L642
    mov       rbx,	1
    cmp       rsi,	1
    jl        L645
L643:
    mov       rax,	r12
    add       rax,	rbx
    mov       r10b,	[rbp + mlib.gs_leftstr.padch]
    mov       [rbp + rax + mlib.gs_leftstr.str-1],	r10b
    inc       rbx
    cmp       rbx,	rsi
    jle       L643
L645:
    mov       rax,	r12
    add       rax,	rsi
    xor       r10d,	r10d
    mov       [rbp + rax + mlib.gs_leftstr.str],	r10b
L642:
    mov       rcx,	r13
    lea       rdx,	[rbp + mlib.gs_leftstr.str]
    call      mlib.gs_str
#---------------
    add       rsp,	2592
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.gs_leftint
mlib.gs_leftint:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	rsi
    mov       r9,	r12
    call      mlib.gs_leftstr
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.gs_padto
mlib.gs_padto:
#PROC1
#PROC2
#?>>
    .set mlib.gs_padto.str, -2560
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2600
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rsi+8]
    mov       r10,	r12
    sub       r10,	rax
    mov       rdi,	r10
    cmp       rdi,	0
    jle       L647
L649:
    mov       rbx,	1
    cmp       rdi,	1
    jl        L652
L650:
    mov       [rbp + rbx + mlib.gs_padto.str-1],	r13b
    inc       rbx
    cmp       rbx,	rdi
    jle       L650
L652:
    xor       eax,	eax
    mov       [rbp + rdi + mlib.gs_padto.str],	al
    mov       rcx,	rsi
    lea       rdx,	[rbp + mlib.gs_padto.str]
    call      mlib.gs_str
L647:
#---------------
    add       rsp,	2600
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.gs_println
mlib.gs_println:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rdi+8]
    test      rax,	rax
    jz        L653
L655:
    mov       rax,	[rdi]
    movsxd    r10,	dword ptr[rdi+8]
    xor       r11d,	r11d
    mov       [rax + r10],	r11b
    test      rbx,	rbx
    jnz       L657
    call      msys.m$print_startcon
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L10371]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L656
L657:
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L10371]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L656:
L653:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.nextcmdparamnew
mlib.nextcmdparamnew:
#PROC1
#PROC2
#?>>
    .set mlib.nextcmdparamnew.defext, 88
    .set mlib.nextcmdparamnew.item, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
#mlib.nextcmdparamnew.reenter:
L659:
    xor       eax,	eax
    mov       [r14],	rax
    xor       eax,	eax
    mov       [r13],	rax
    mov       rax,	[rip+mlib.nextcmdparamnew.infile]
    test      rax,	rax
    jz        L661
    lea       rcx,	[rip+mlib.nextcmdparamnew.fileptr]
    lea       rdx,	[rbp + mlib.nextcmdparamnew.item]
    call      mlib.readnextfileitem
    test      rax,	rax
    jnz       L663
    mov       rcx,	[rip+mlib.nextcmdparamnew.filestart]
    call      free
    xor       eax,	eax
    mov       [rip+mlib.nextcmdparamnew.infile],	rax
    jmp       L659
L663:
    jmp       L660
L661:
    mov       rax,	[r12]
    cmp       rax,	[rip+msys.ncmdparams]
    jle       L665
    xor       eax,	eax
    jmp       L658
L665:
    mov       rax,	[r12]
    mov       r10,	[rip+msys.cmdparams]
    mov       r10,	[r10 + rax*8]
    mov       [rbp + mlib.nextcmdparamnew.item],	r10
    mov       rax,	r12
    inc       qword ptr[rax]
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    call      strlen
    mov       rsi,	rax
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	64
    jnz       L667
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    lea       rax,	[rax+1]
    mov       rcx,	rax
    call      mlib.readfile
    mov       [rip+mlib.nextcmdparamnew.fileptr],	rax
    mov       [rip+mlib.nextcmdparamnew.filestart],	rax
    mov       rax,	[rip+mlib.nextcmdparamnew.filestart]
    test      rax,	rax
    jnz       L669
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10372]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	7
    call      exit
L669:
    mov       rax,	1
    mov       [rip+mlib.nextcmdparamnew.infile],	rax
    jmp       L659
L667:
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	58
    jnz       L671
    mov       al,	1
    mov       [rip+mlib.nextcmdparamnew.colonseen],	al
    mov       rax,	4
    jmp       L658
L671:
L660:
    xor       eax,	eax
    mov       [r14],	rax
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	45
    jnz       L673
    mov       al,	[rip+mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jz        L675
    xor       eax,	eax
    jmp       L674
L675:
    mov       rax,	1
L674:
    mov       r10,	[rbp + mlib.nextcmdparamnew.item]
    lea       r10,	[r10 + rax]
    mov       [r13],	r10
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    mov       rdx,	58
    call      strchr
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L677
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    mov       rdx,	61
    call      strchr
    mov       rdi,	rax
L677:
    test      rdi,	rdi
    jz        L679
    lea       rax,	[rdi+1]
    mov       [r14],	rax
    xor       eax,	eax
    mov       [rdi],	al
L679:
    mov       al,	[rip+mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jz        L681
    mov       rax,	5
    jmp       L680
L681:
    mov       rax,	1
L680:
    jmp       L658
L673:
    mov       rcx,	[rbp + mlib.nextcmdparamnew.item]
    xor       edx,	edx
    call      mlib.extractext
    mov       rbx,	rax
    mov       rax,	[rbp + mlib.nextcmdparamnew.item]
    mov       [r13],	rax
    movzx     rax,	byte ptr[rbx]
    test      rax,	rax
    jnz       L683
    mov       rax,	[r13]
    lea       rcx,	[rip+mlib.nextcmdparamnew.str]
    mov       rdx,	rax
    call      strcpy
    mov       rax,	[rbp + mlib.nextcmdparamnew.defext]
    test      rax,	rax
    jz        L685
    mov       al,	[rip+mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jnz       L685
    lea       rcx,	[rip+mlib.nextcmdparamnew.str]
    mov       rdx,	[rbp + mlib.nextcmdparamnew.defext]
    call      mlib.addext
    mov       [r13],	rax
L685:
    jmp       L682
L683:
    mov       rcx,	rbx
    lea       rdx,	[rip+L10373]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L687
    mov       rcx,	rbx
    lea       rdx,	[rip+L10374]
    call      mlib.eqstring
    test      rax,	rax
    jz        L686
L687:
    mov       al,	[rip+mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jz        L689
    mov       rax,	5
    jmp       L688
L689:
    mov       rax,	3
L688:
    jmp       L658
L686:
L682:
    mov       al,	[rip+mlib.nextcmdparamnew.colonseen]
    test      al,	al
    jz        L691
    mov       rax,	5
    jmp       L690
L691:
    mov       rax,	2
L690:
L658:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.readnextfileitem
mlib.readnextfileitem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
#---------------
#PROC3
#PROC4
    mov       rdi,	[r13]
#mlib.readnextfileitem.reenter:
L693:
L694:
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	32
    jz        L697
    cmp       rax,	9
    jz        L697
    cmp       rax,	13
    jz        L697
    cmp       rax,	10
    jz        L697
    cmp       rax,	26
    jz        L698
    test      rax,	rax
    jz        L698
    jmp       L699
L697:
    inc       rdi
    jmp       L696
L698:
    xor       eax,	eax
    jmp       L692
L699:
    jmp       L695
L696:
    jmp       L694
L695:
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	33
    jz        L701
    cmp       rax,	35
    jnz       L702
L701:
    inc       rdi
L703:
    mov       rax,	rdi
    inc       rdi
    movzx     rax,	byte ptr[rax]
    cmp       rax,	10
    jz        L705
    cmp       rax,	26
    jz        L706
    test      rax,	rax
    jz        L706
    jmp       L707
L705:
    jmp       L693
L706:
    lea       rax,	[rdi-1]
    mov       [r13],	rax
    xor       eax,	eax
    jmp       L692
L707:
    jmp       L703
L702:
L700:
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	34
    jnz       L710
L709:
    inc       rdi
    mov       rbx,	rdi
L711:
    movzx     rax,	byte ptr[rdi]
    test      rax,	rax
    jz        L714
    cmp       rax,	26
    jz        L714
    cmp       rax,	34
    jz        L715
    jmp       L716
L714:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10375]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	8
    call      exit
    jmp       L713
L715:
    mov       rax,	rdi
    inc       rdi
    mov       rsi,	rax
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	44
    jnz       L718
    inc       rdi
L718:
    jmp       L712
L716:
L713:
    inc       rdi
    jmp       L711
L712:
    jmp       L708
L710:
    mov       rbx,	rdi
L719:
    movzx     rax,	byte ptr[rdi]
    test      rax,	rax
    jz        L722
    cmp       rax,	26
    jz        L722
    cmp       rax,	32
    jz        L723
    cmp       rax,	9
    jz        L723
    cmp       rax,	44
    jz        L723
    cmp       rax,	13
    jz        L723
    cmp       rax,	10
    jz        L723
    jmp       L724
L722:
    mov       rsi,	rdi
    jmp       L720
L723:
    mov       rax,	rdi
    inc       rdi
    mov       rsi,	rax
    jmp       L720
L724:
L721:
    inc       rdi
    jmp       L719
L720:
L708:
    mov       rax,	rsi
    sub       rax,	rbx
    mov       r12,	rax
    cmp       r12,	256
    jl        L726
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10376]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	9
    call      exit
L726:
    lea       rcx,	[rip+mlib.readnextfileitem.str]
    mov       rdx,	rbx
    mov       r8,	r12
    call      memcpy
    xor       eax,	eax
    lea       r10,	[rip+mlib.readnextfileitem.str]
    mov       r11,	r12
    mov       [r10 + r11],	al
    lea       rax,	[rip+mlib.readnextfileitem.str]
    mov       [r14],	rax
    mov       [r13],	rdi
    mov       rax,	1
L692:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.ipadstr
mlib.ipadstr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rsi
    call      strlen
    mov       rdi,	rax
    mov       rax,	r12
    sub       rax,	rdi
    mov       rbx,	rax
    cmp       rbx,	0
    jle       L730
L728:
    mov       rcx,	rsi
    mov       rdx,	r13
    call      strcat
    dec       rbx
    jnz       L728
L730:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.padstr
mlib.padstr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+mlib.padstr.str]
    mov       rdx,	rdi
    call      strcpy
    lea       rcx,	[rip+mlib.padstr.str]
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mlib.ipadstr
    lea       rax,	[rip+mlib.padstr.str]
L731:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.chr
mlib.chr:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       al,	cl
    lea       r10,	[rip+mlib.chr.str]
    mov       [r10],	al
    xor       eax,	eax
    lea       r10,	[rip+mlib.chr.str]
    mov       [r10+1],	al
    lea       rax,	[rip+mlib.chr.str]
L732:
#---------------
    ret       
# End 
# Proc mlib.cmpstring
mlib.cmpstring:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      strcmp
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       r10,	0
    jge       L735
    mov       rax,	-1
    jmp       L734
L735:
    cmp       rdi,	0
    jle       L736
    mov       rax,	1
    jmp       L734
L736:
    xor       eax,	eax
L734:
L733:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.cmpstringn
mlib.cmpstringn:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      strncmp
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       r10,	0
    jge       L739
    mov       rax,	-1
    jmp       L738
L739:
    cmp       rdi,	0
    jle       L740
    mov       rax,	1
    jmp       L738
L740:
    xor       eax,	eax
L738:
L737:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.eqstring
mlib.eqstring:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      strcmp
    movsxd    r10,	eax
    cmp       r10,	0
    setz      r10b
    movzx     r10d,	r10b
    mov       rax,	r10
L741:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.cmpbytes
mlib.cmpbytes:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      memcmp
    movsxd    r10,	eax
    mov       rdi,	r10
    cmp       r10,	0
    jge       L744
    mov       rax,	-1
    jmp       L743
L744:
    cmp       rdi,	0
    jle       L745
    mov       rax,	1
    jmp       L743
L745:
    xor       eax,	eax
L743:
L742:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.eqbytes
mlib.eqbytes:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcmp
    movsxd    r10,	eax
    cmp       r10,	0
    setz      r10b
    movzx     r10d,	r10b
    mov       rax,	r10
L746:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.mseed
mlib.mseed:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	rcx
    lea       r10,	[rip+mlib.seed]
    mov       [r10],	rax
    test      rdx,	rdx
    jz        L749
    mov       rax,	rdx
    lea       r10,	[rip+mlib.seed]
    mov       [r10+8],	rax
    jmp       L748
L749:
    lea       rax,	[rip+mlib.seed]
    lea       rax,	[rax+8]
    mov       r10,	rcx
    xor       [rax],	r10
L748:
#---------------
    ret       
# End 
# Proc mlib.mrandom
mlib.mrandom:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mlib.seed]
    mov       rdi,	[rax]
    lea       rax,	[rip+mlib.seed]
    mov       rbx,	[rax+8]
    mov       rax,	rbx
    lea       r10,	[rip+mlib.seed]
    mov       [r10],	rax
    mov       rax,	rdi
    shl       rax,	23
    xor       rdi,	rax
    mov       rax,	rdi
    xor       rax,	rbx
    mov       r10,	rdi
    sar       r10,	17
    xor       rax,	r10
    mov       r10,	rbx
    sar       r10,	26
    xor       rax,	r10
    lea       r10,	[rip+mlib.seed]
    mov       [r10+8],	rax
    lea       rax,	[rip+mlib.seed]
    mov       rax,	[rax+8]
    add       rax,	rbx
L750:
#---------------
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.mrandomp
mlib.mrandomp:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      mlib.mrandom
    mov       r10,	9223372036854775807
    and       rax,	r10
L751:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mlib.mrandomint
mlib.mrandomint:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    call      mlib.mrandomp
    mov       r10,	rdi
    cqo       
    idiv      r10
    xchg      rax,	rdx
L752:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mlib.mrandomrange
mlib.mrandomrange:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	rsi
    sub       rax,	rbx
    inc       rax
    mov       rdi,	rax
    cmp       rdi,	0
    jg        L755
    xor       eax,	eax
    jmp       L753
L755:
    call      mlib.mrandomp
    mov       r10,	rdi
    cqo       
    idiv      r10
    xchg      rax,	rdx
    add       rax,	rbx
L753:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.mrandomreal
mlib.mrandomreal:
#PROC1
#PROC2
#?>>
    movq      rax,	XMM15
    push      rax
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
L757:
    call      mlib.mrandomp
    cvtsi2sd  XMM4,	rax
    divsd     XMM4,	[rip+L10377]
    movq      XMM15,	XMM4
    movq      XMM4,	XMM15
    comisd    XMM4,	[rip+L10378]
    jz        L757
    movq      XMM0,	XMM15
L756:
#---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    ret       
# End 
# Proc mlib.mrandomreal1
mlib.mrandomreal1:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      mlib.mrandomp
    cvtsi2sd  XMM4,	rax
    divsd     XMM4,	[rip+L10379]
    movq      XMM0,	XMM4
L760:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mlib.readline
mlib.readline:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      msys.m$read_conline
    mov       rax,	[rip+msys.rd_buffer]
L761:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mlib.findfunction
mlib.findfunction:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rbx,	1
    mov       rdi,	[rip+$nprocs]
    cmp       rdi,	1
    jl        L765
L763:
    lea       rax,	[rip+$procname]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      mlib.eqstring
    test      rax,	rax
    jz        L767
    lea       rax,	[rip+$procaddr]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    jmp       L762
L767:
    inc       rbx
    cmp       rbx,	rdi
    jle       L763
L765:
    xor       eax,	eax
L762:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mlib.roundtoblock
mlib.roundtoblock:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rdx-1]
    mov       r10,	rcx
    and       r10,	rax
    test      r10,	r10
    jnz       L770
    mov       rax,	rcx
    jmp       L768
L770:
    lea       rax,	[rdx-1]
    mov       r10,	rcx
    and       r10,	rax
    mov       rax,	rdx
    sub       rax,	r10
    mov       r10,	rcx
    add       r10,	rax
    mov       rax,	r10
L768:
#---------------
    ret       
# End 
# Proc mlib.pcm_allocnfz
mlib.pcm_allocnfz:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	rbx
    and       rax,	7
    jz        L773
    mov       rax,	rbx
    and       rax,	7
    mov       r10,	8
    sub       r10,	rax
    mov       rax,	rbx
    add       rax,	r10
    mov       rbx,	rax
L773:
    mov       rdi,	[rip+mlib.pcheapptr]
    mov       rax,	rbx
    add       [rip+mlib.pcheapptr],	rax
    mov       rax,	[rip+mlib.pcheapptr]
    cmp       rax,	[rip+mlib.pcheapend]
    jb        L775
    mov       rcx,	rbx
    call      mlib.pcm_newblock
    mov       rdi,	rax
L775:
    mov       rax,	rdi
L771:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mwindows.os_init
mwindows.os_init:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       eax,	4294967285
    mov       eax,	eax
    mov       rcx,	rax
    call      GetStdHandle
    mov       [rip+mwindows.hconsole],	rax
    mov       eax,	4294967286
    mov       eax,	eax
    mov       rcx,	rax
    call      GetStdHandle
    mov       [rip+mwindows.hconsolein],	rax
    xor       eax,	eax
    lea       r10,	[rip+mwindows.lastkey]
    mov       [r10+8],	ax
    xor       eax,	eax
    mov       [rip+mwindows.keypending],	rax
    xor       ecx,	ecx
    mov       rdx,	1
    call      SetConsoleCtrlHandler
    mov       rcx,	[rip+mwindows.hconsole]
    mov       rdx,	3
    call      SetConsoleMode
    mov       rax,	1
    mov       [rip+mwindows.init_flag],	rax
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mwindows.os_execwait
mwindows.os_execwait:
#PROC1
#PROC2
#?>>
    .set mwindows.os_execwait.workdir, 64
    .set mwindows.os_execwait.exitcode, -8
    .set mwindows.os_execwait.si, -112
    .set mwindows.os_execwait.xpi, -136
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	176
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    xor       rbx,	rbx
    mov       rax,	104
    mov       rdi,	rax
    mov       rdi,	24
    mov       rdi,	123456
    mov       rdi,	1193046
    lea       rax,	[rbp + mwindows.os_execwait.si]
    xor       r10d,	r10d
    mov       r11,	13
L10380:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L10380
    lea       rax,	[rbp + mwindows.os_execwait.xpi]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       rax,	r12
    test      rax,	rax
    jz        L779
    cmp       rax,	1
    jz        L780
    cmp       rax,	2
    jz        L781
    jmp       L782
L779:
    mov       rbx,	32
    jmp       L778
L780:
    mov       rbx,	48
    jmp       L778
L781:
    mov       rbx,	48
L782:
L778:
    mov       eax,	104
    mov       [rbp + mwindows.os_execwait.si],	eax
    lea       rax,	[rbp + mwindows.os_execwait.xpi]
    push      rax
    lea       rax,	[rbp + mwindows.os_execwait.si]
    push      rax
    push      0
    push      0
    mov       eax,	ebx
    push      rax
    push      1
    xor       ecx,	ecx
    mov       rdx,	rsi
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      CreateProcessA
    add       rsp,	80
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L784
    call      GetLastError
    mov       r10d,	eax
    mov       rdi,	r10
    lea       rcx,	[rip+L10381]
    mov       rdx,	rdi
    call      printf
    mov       rax,	-1
    jmp       L777
L784:
    mov       rax,	[rbp + mwindows.os_execwait.xpi]
    mov       rcx,	rax
    mov       rdx,	4294967295
    call      WaitForSingleObject
    mov       rax,	[rbp + mwindows.os_execwait.xpi]
    mov       rcx,	rax
    lea       rdx,	[rbp + mwindows.os_execwait.exitcode]
    call      GetExitCodeProcess
    mov       rcx,	[rbp + mwindows.os_execwait.xpi]
    call      CloseHandle
    mov       rcx,	[rbp + mwindows.os_execwait.xpi+8]
    call      CloseHandle
    mov       eax,	[rbp + mwindows.os_execwait.exitcode]
L777:
#---------------
    add       rsp,	176
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mwindows.os_execcmd
mwindows.os_execcmd:
#PROC1
#PROC2
#?>>
    .set mwindows.os_execcmd.si, -104
    .set mwindows.os_execcmd.xpi, -128
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	160
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rbp + mwindows.os_execcmd.si]
    xor       r10d,	r10d
    mov       r11,	13
L10382:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L10382
    lea       rax,	[rbp + mwindows.os_execcmd.xpi]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       eax,	104
    mov       [rbp + mwindows.os_execcmd.si],	eax
    lea       rax,	[rbp + mwindows.os_execcmd.xpi]
    push      rax
    lea       rax,	[rbp + mwindows.os_execcmd.si]
    push      rax
    push      0
    push      0
    test      rbx,	rbx
    jz        L787
    mov       rax,	16
    jmp       L786
L787:
    xor       eax,	eax
L786:
    mov       r10,	32
    or        r10,	rax
    push      r10
    push      1
    xor       ecx,	ecx
    mov       rdx,	rdi
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      CreateProcessA
    add       rsp,	80
    mov       rcx,	[rbp + mwindows.os_execcmd.xpi]
    call      CloseHandle
    mov       rcx,	[rbp + mwindows.os_execcmd.xpi+8]
    call      CloseHandle
    mov       rax,	1
L785:
#---------------
    add       rsp,	160
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mwindows.os_getch
mwindows.os_getch:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      mwindows.os_getchx
    and       rax,	255
    mov       rdi,	rax
    mov       rax,	rdi
L788:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mwindows.os_kbhit
mwindows.os_kbhit:
#PROC1
#PROC2
#?>>
    .set mwindows.os_kbhit.count, -8
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mwindows.init_flag]
    test      rax,	rax
    jnz       L791
    call      mwindows.os_init
L791:
    mov       rcx,	[rip+mwindows.hconsolein]
    lea       rdx,	[rbp + mwindows.os_kbhit.count]
    call      GetNumberOfConsoleInputEvents
    mov       eax,	[rbp + mwindows.os_kbhit.count]
    cmp       rax,	1
    setg      al
    movzx     eax,	al
L789:
#---------------
    add       rsp,	48
    pop       rbp
    ret       
# End 
# Proc mwindows.os_getdllinst
mwindows.os_getdllinst:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      LoadLibraryA
    mov       rdi,	rax
    mov       rax,	rdi
L792:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mwindows.os_getdllprocaddr
mwindows.os_getdllprocaddr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      GetProcAddress
L793:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mwindows.os_initwindows
mwindows.os_initwindows:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      mwindows.os_init
    lea       rcx,	[rip+L10383]
    call      mwindows.os_gxregisterclass
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mwindows.os_gxregisterclass
mwindows.os_gxregisterclass:
#PROC1
#PROC2
#?>>
    .set mwindows.os_gxregisterclass.r, -80
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	120
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       al,	[rip+mwindows.os_gxregisterclass.registered]
    test      al,	al
    jnz       L795
L797:
    lea       rax,	[rbp + mwindows.os_gxregisterclass.r]
    xor       r10d,	r10d
    mov       r11,	10
L10384:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L10384
    mov       eax,	80
    mov       [rbp + mwindows.os_gxregisterclass.r],	eax
    mov       eax,	40
    mov       [rbp + mwindows.os_gxregisterclass.r+4],	eax
    lea       rax,	[rip+mwindows.mainwndproc]
    mov       [rbp + mwindows.os_gxregisterclass.r+8],	rax
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+24],	rax
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+32],	rax
    xor       ecx,	ecx
    mov       rdx,	32512
    call      LoadCursorA
    mov       [rbp + mwindows.os_gxregisterclass.r+40],	rax
    mov       rax,	16
    mov       [rbp + mwindows.os_gxregisterclass.r+48],	rax
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+56],	rax
    mov       [rbp + mwindows.os_gxregisterclass.r+64],	rdi
    xor       eax,	eax
    mov       [rbp + mwindows.os_gxregisterclass.r+72],	rax
    lea       rcx,	[rbp + mwindows.os_gxregisterclass.r]
    call      RegisterClassExA
    mov       r10d,	eax
    test      r10,	r10
    jnz       L799
    call      GetLastError
    mov       r10d,	eax
    lea       rcx,	[rip+L10385]
    mov       rdx,	rdi
    mov       r8,	r10
    call      printf
    mov       rcx,	1
    call      exit
L799:
    mov       al,	1
    mov       [rip+mwindows.os_gxregisterclass.registered],	al
L795:
#---------------
    add       rsp,	120
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc mwindows.mainwndproc
mwindows.mainwndproc:
#PROC1
#PROC2
#?>>
    .set mwindows.mainwndproc.m, -48
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       rbx,	rcx
    mov       esi,	edx
    mov       r12,	r8
    mov       r13,	r9
#---------------
#PROC3
#PROC4
    mov       [rbp + mwindows.mainwndproc.m],	rbx
    mov       [rbp + mwindows.mainwndproc.m+8],	esi
    mov       [rbp + mwindows.mainwndproc.m+16],	r12
    mov       [rbp + mwindows.mainwndproc.m+24],	r13
    xor       eax,	eax
    mov       [rbp + mwindows.mainwndproc.m+40],	eax
    xor       eax,	eax
    mov       [rbp + mwindows.mainwndproc.m+44],	eax
    mov       rax,	[rip+mwindows.wndproc_callbackfn]
    test      rax,	rax
    jz        L802
    lea       rcx,	[rbp + mwindows.mainwndproc.m]
    mov       rax,	[rip+mwindows.wndproc_callbackfn]
    call      rax
    mov       rdi,	rax
    jmp       L801
L802:
    xor       rdi,	rdi
L801:
    mov       eax,	[rbp + mwindows.mainwndproc.m+8]
    cmp       rax,	2
    jnz       L804
    xor       eax,	eax
    jmp       L800
L804:
    test      rdi,	rdi
    jnz       L806
    mov       eax,	esi
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	r12
    mov       r9,	r13
    call      DefWindowProcA
    jmp       L805
L806:
    xor       eax,	eax
L805:
L800:
#---------------
    add       rsp,	88
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mwindows.os_setmesshandler
mwindows.os_setmesshandler:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       [rip+mwindows.wndproc_callbackfn],	rcx
#---------------
    ret       
# End 
# Proc mwindows.os_getchx
mwindows.os_getchx:
#PROC1
#PROC2
#?>>
    .set mwindows.os_getchx.count, -8
    .set mwindows.os_getchx.shiftdown, -16
    .set mwindows.os_getchx.capslock, -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mwindows.init_flag]
    test      rax,	rax
    jnz       L810
    call      mwindows.os_init
L810:
    mov       rax,	[rip+mwindows.keypending]
    test      rax,	rax
    jz        L812
    lea       rax,	[rip+mwindows.pendkey]
    lea       r10,	[rip+mwindows.lastkey]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11d,	[rax+16]
    mov       [r10+16],	r11d
    xor       eax,	eax
    mov       [rip+mwindows.keypending],	rax
    jmp       L811
L812:
    lea       rax,	[rip+mwindows.lastkey]
    movzx     rax,	word ptr[rax+8]
    test      rax,	rax
    jnz       L814
L815:
    xor       eax,	eax
    mov       [rbp + mwindows.os_getchx.count],	rax
    mov       rcx,	[rip+mwindows.hconsolein]
    lea       rdx,	[rip+mwindows.lastkey]
    mov       r8,	1
    lea       r9,	[rbp + mwindows.os_getchx.count]
    call      ReadConsoleInputA
    lea       rax,	[rip+mwindows.lastkey]
    movzx     rax,	word ptr[rax]
    cmp       rax,	1
    jnz       L815
    lea       rax,	[rip+mwindows.lastkey]
    mov       eax,	[rax+4]
    cmp       rax,	1
    jnz       L815
L814:
L811:
    lea       rax,	[rip+mwindows.lastkey]
    mov       eax,	[rax+16]
    and       rax,	3
    jz        L819
    mov       rax,	1
    jmp       L818
L819:
    xor       eax,	eax
L818:
    mov       r12,	rax
    lea       rax,	[rip+mwindows.lastkey]
    mov       eax,	[rax+16]
    and       rax,	12
    jz        L821
    mov       rax,	1
    jmp       L820
L821:
    xor       eax,	eax
L820:
    mov       r13,	rax
    lea       rax,	[rip+mwindows.lastkey]
    mov       eax,	[rax+16]
    and       rax,	16
    jz        L823
    mov       rax,	1
    jmp       L822
L823:
    xor       eax,	eax
L822:
    mov       [rbp + mwindows.os_getchx.shiftdown],	rax
    lea       rax,	[rip+mwindows.lastkey]
    mov       eax,	[rax+16]
    and       rax,	128
    jz        L825
    mov       rax,	1
    jmp       L824
L825:
    xor       eax,	eax
L824:
    mov       [rbp + mwindows.os_getchx.capslock],	rax
    lea       rax,	[rip+mwindows.lastkey]
    lea       rax,	[rax+8]
    dec       word ptr[rax]
    lea       rax,	[rip+mwindows.lastkey]
    movzx     rax,	byte ptr[rax+14]
    mov       rdi,	rax
    lea       rax,	[rip+mwindows.lastkey]
    movzx     rax,	word ptr[rax+10]
    and       rax,	255
    mov       rsi,	rax
    cmp       rdi,	0
    jge       L827
    cmp       rdi,	-128
    jge       L829
    xor       rdi,	rdi
    jmp       L828
L829:
    mov       rax,	256
    add       rdi,	rax
L828:
L827:
    test      r12,	r12
    jz        L831
    test      r13,	r13
    jz        L831
    cmp       rdi,	166
    jnz       L831
    xor       eax,	eax
    mov       r13,	rax
    mov       r12,	rax
    jmp       L830
L831:
    test      r12,	r12
    jnz       L834
    test      r13,	r13
    jz        L833
L834:
    xor       rdi,	rdi
    mov       rax,	rsi
    cmp       rax,	65
    jl        L836
    cmp       rsi,	90
    jg        L836
    lea       rax,	[rsi-64]
    mov       rdi,	rax
L836:
L833:
L830:
    mov       rax,	[rbp + mwindows.os_getchx.capslock]
    shl       rax,	3
    mov       r10,	r12
    shl       r10,	2
    or        rax,	r10
    mov       r10,	r13
    shl       r10,	1
    or        rax,	r10
    or        rax,	[rbp + mwindows.os_getchx.shiftdown]
    mov       rbx,	rax
    mov       rax,	rbx
    shl       rax,	24
    mov       r10,	rsi
    shl       r10,	16
    or        rax,	r10
    or        rax,	rdi
L808:
#---------------
    add       rsp,	56
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mwindows.os_getos
mwindows.os_getos:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+L10386]
L837:
#---------------
    ret       
# End 
# Proc mwindows.os_gethostsize
mwindows.os_gethostsize:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	64
L838:
#---------------
    ret       
# End 
# Proc mwindows.os_shellexec
mwindows.os_shellexec:
#PROC1
#PROC2
#?>>
    .set mwindows.os_shellexec.opc, 24
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      system
    movsxd    r10,	eax
    mov       rax,	r10
L839:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mwindows.os_sleep
mwindows.os_sleep:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      Sleep
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mwindows.os_getstdin
mwindows.os_getstdin:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+L10387]
    lea       rdx,	[rip+L10388]
    call      fopen
L841:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mwindows.os_getstdout
mwindows.os_getstdout:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+L10389]
    lea       rdx,	[rip+L10390]
    call      fopen
L842:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mwindows.os_gethostname
mwindows.os_gethostname:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    lea       rdx,	[rip+mwindows.os_gethostname.name]
    mov       r8,	300
    call      GetModuleFileNameA
    lea       rax,	[rip+mwindows.os_gethostname.name]
L843:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mwindows.os_getmpath
mwindows.os_getmpath:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+L10391]
L844:
#---------------
    ret       
# End 
# Proc mwindows.os_clock
mwindows.os_clock:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      mwindows.os_hpcounter
L845:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mwindows.os_ticks
mwindows.os_ticks:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      GetTickCount64
L846:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mwindows.os_iswindows
mwindows.os_iswindows:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	1
L847:
#---------------
    ret       
# End 
# Proc mwindows.os_getsystime
mwindows.os_getsystime:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      GetLocalTime
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mwindows.os_peek
mwindows.os_peek:
#PROC1
#PROC2
#?>>
    .set mwindows.os_peek.m, -104
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
#---------------
#PROC3
#PROC4
    call      GetTickCount64
    mov       rdi,	rax
    mov       rax,	rdi
    sub       rax,	[rip+mwindows.os_peek.lastticks]
    cmp       rax,	1000
    jl        L851
    mov       [rip+mwindows.os_peek.lastticks],	rdi
    sub       rsp,	8
    push      0
    lea       rcx,	[rbp + mwindows.os_peek.m]
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      PeekMessageA
    add       rsp,	48
L851:
#---------------
    add       rsp,	136
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc mwindows.os_allocexecmem
mwindows.os_allocexecmem:
#PROC1
#PROC2
#?>>
    .set mwindows.os_allocexecmem.oldprot, -8
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    mov       rdx,	rsi
    mov       r8,	12288
    mov       r9,	1
    call      VirtualAlloc
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L854
    xor       eax,	eax
    jmp       L852
L854:
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	64
    lea       r9,	[rbp + mwindows.os_allocexecmem.oldprot]
    call      VirtualProtect
    mov       r10d,	eax
    mov       rbx,	r10
    test      rbx,	rbx
    jnz       L856
    xor       eax,	eax
    jmp       L852
L856:
    mov       rax,	rdi
L852:
#---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mwindows.dirlist
mwindows.dirlist:
#PROC1
#PROC2
#?>>
    .set mwindows.dirlist.file, -328
    .set mwindows.dirlist.path, -632
    .set mwindows.dirlist.fullfilename, -936
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	976
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
#---------------
#PROC3
#PROC4
    xor       rbx,	rbx
    mov       rcx,	rsi
    call      mlib.extractpath
    lea       rcx,	[rbp + mwindows.dirlist.path]
    mov       rdx,	rax
    call      strcpy
    mov       rcx,	rsi
    lea       rdx,	[rbp + mwindows.dirlist.file]
    call      FindFirstFileA
    mov       rdi,	rax
    cmp       rax,	-1
    jz        L859
L860:
    mov       eax,	[rbp + mwindows.dirlist.file]
    and       rax,	16
    jz        L864
    mov       rax,	r14
    and       rax,	2
    jnz       L866
    jmp       L861
L866:
    jmp       L863
L864:
    mov       rax,	r14
    and       rax,	1
    jnz       L868
    jmp       L861
L868:
L863:
    cmp       rbx,	r13
    jl        L870
    mov       rbx,	-1
    jmp       L862
L870:
    mov       rax,	r14
    and       rax,	4
    jz        L872
    lea       rax,	[rbp + mwindows.dirlist.file+44]
    mov       rcx,	rax
    call      mlib.convlcstring
L872:
    lea       rcx,	[rbp + mwindows.dirlist.fullfilename]
    lea       rdx,	[rbp + mwindows.dirlist.path]
    call      strcpy
    lea       rax,	[rbp + mwindows.dirlist.file+44]
    lea       rcx,	[rbp + mwindows.dirlist.fullfilename]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rbp + mwindows.dirlist.fullfilename]
    call      mlib.pcm_copyheapstring
    inc       rbx
    mov       r10,	rbx
    mov       [r12 + r10*8-8],	rax
L861:
    mov       rcx,	rdi
    lea       rdx,	[rbp + mwindows.dirlist.file]
    call      FindNextFileA
    test      eax,	eax
    jnz       L860
L862:
    mov       rcx,	rdi
    call      FindClose
L859:
    mov       rax,	rbx
L857:
#---------------
    add       rsp,	976
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mwindows.os_hpcounter
mwindows.os_hpcounter:
#PROC1
#PROC2
#?>>
    .set mwindows.os_hpcounter.a, -8
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mwindows.hpfreq]
    test      rax,	rax
    jnz       L875
    call      mwindows.os_hpfreq
    mov       r10,	1000
    cqo       
    idiv      r10
    mov       [rip+mwindows.hpfreq],	rax
L875:
    lea       rcx,	[rbp + mwindows.os_hpcounter.a]
    call      QueryPerformanceCounter
    mov       rax,	[rbp + mwindows.os_hpcounter.a]
    mov       r10,	[rip+mwindows.hpfreq]
    cqo       
    idiv      r10
L873:
#---------------
    add       rsp,	48
    pop       rbp
    ret       
# End 
# Proc mwindows.os_hpfreq
mwindows.os_hpfreq:
#PROC1
#PROC2
#?>>
    .set mwindows.os_hpfreq.a, -8
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + mwindows.os_hpfreq.a]
    call      QueryPerformanceFrequency
    mov       rax,	[rbp + mwindows.os_hpfreq.a]
L876:
#---------------
    add       rsp,	48
    pop       rbp
    ret       
# End 
# Proc mwindll.os_calldllfunction
mwindll.os_calldllfunction:
#PROC1
#PROC2
#?>>
    .set mwindll.os_calldllfunction.fnaddr, 16
    .set mwindll.os_calldllfunction.retcode, 24
    .set mwindll.os_calldllfunction.nargs, 32
    .set mwindll.os_calldllfunction.args, 40
    .set mwindll.os_calldllfunction.argcodes, 48
    .set mwindll.os_calldllfunction.a, -8
    .set mwindll.os_calldllfunction.x, -16
    .set mwindll.os_calldllfunction.nextra, -24
    .set mwindll.os_calldllfunction.pushedbytes, -32
    .set mwindll.os_calldllfunction.av_1, -40
    .set mwindll.os_calldllfunction.i, -48
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+16],	rcx
    mov       [rbp+24],	rdx
    mov       [rbp+32],	r8
    mov       [rbp+40],	r9
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rbp + mwindll.os_calldllfunction.nextra],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    cmp       rax,	4
    jge       L879
    mov       rax,	4
    sub       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    mov       [rbp + mwindll.os_calldllfunction.nextra],	rax
    jmp       L878
L879:
    mov       eax,	[rbp + mwindll.os_calldllfunction.nargs]
    and       eax,	1
    test      rax,	rax
    jz        L880
    mov       rax,	1
    mov       [rbp + mwindll.os_calldllfunction.nextra],	rax
L880:
L878:
    mov       rax,	[rbp + mwindll.os_calldllfunction.nextra]
    add       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    shl       rax,	3
    mov       [rbp + mwindll.os_calldllfunction.pushedbytes],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.nextra]
    mov       [rbp + mwindll.os_calldllfunction.av_1],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.av_1]
    cmp       rax,	0
    jle       L883
L881:
    push      0
    dec       qword ptr[rbp + mwindll.os_calldllfunction.av_1]
    jnz       L881
L883:
    mov       rax,	[rbp + mwindll.os_calldllfunction.nargs]
    mov       [rbp + mwindll.os_calldllfunction.i],	rax
    mov       rax,	[rbp + mwindll.os_calldllfunction.i]
    cmp       rax,	1
    jl        L886
L884:
    mov       rax,	[rbp + mwindll.os_calldllfunction.args]
    mov       r10,	[rbp + mwindll.os_calldllfunction.i]
    mov       rax,	[rax + r10*8-8]
    mov       [rbp + mwindll.os_calldllfunction.a],	rax
    push      qword ptr[rbp + mwindll.os_calldllfunction.a]
    mov       rax,	[rbp + mwindll.os_calldllfunction.i]
    dec       rax
    mov       [rbp + mwindll.os_calldllfunction.i],	rax
    cmp       rax,	1
    jge       L884
L886:
    mov       rcx,	[rsp]
    movq      XMM0,	[rsp]
    mov       rdx,	[rsp+8]
    movq      XMM1,	[rsp+8]
    mov       r8,	[rsp+16]
    movq      XMM2,	[rsp+16]
    mov       r9,	[rsp+24]
    movq      XMM3,	[rsp+24]
    mov       rax,	[rbp + mwindll.os_calldllfunction.retcode]
    cmp       rax,	73
    jnz       L888
    mov       rax,	[rbp + mwindll.os_calldllfunction.fnaddr]
    call      rax
    mov       [rbp + mwindll.os_calldllfunction.a],	rax
    add       rsp,	[rbp + mwindll.os_calldllfunction.pushedbytes]
    mov       rax,	[rbp + mwindll.os_calldllfunction.a]
    jmp       L887
L888:
    mov       rax,	[rbp + mwindll.os_calldllfunction.fnaddr]
    call      rax
    movq      [rbp + mwindll.os_calldllfunction.x],	XMM0
    add       rsp,	[rbp + mwindll.os_calldllfunction.pushedbytes]
    movq      XMM4,	[rbp + mwindll.os_calldllfunction.x]
    movq      rax,	XMM4
L887:
L877:
#---------------
    add       rsp,	80
    pop       rbp
    ret       
# End 
# Proc pc_api.pcl_start
pc_api.pcl_start:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       al,	[rip+pc_decls.pcldone]
    test      al,	al
    jz        L891
    lea       rcx,	[rip+L10392]
    call      pc_api.pclerror
L891:
    test      rdi,	rdi
    jz        L893
    mov       rcx,	rdi
    mov       rdx,	9
    call      pc_api.pc_makesymbol
    mov       [rip+pc_decls.currprog],	rax
L893:
    mov       rax,	[rip+pc_api.initpcalloc]
    mov       [rip+pc_api.pcalloc],	rax
    test      rbx,	rbx
    jz        L895
    mov       rax,	rbx
    lea       rax,	[rax + rax*8]
    sar       rax,	3
    mov       rbx,	rax
    jmp       L897
L896:
    mov       rax,	[rip+pc_api.pcalloc]
    shl       rax,	1
    mov       [rip+pc_api.pcalloc],	rax
L897:
    mov       rax,	[rip+pc_api.pcalloc]
    cmp       rax,	rbx
    jl        L896
L895:
    mov       rax,	[rip+pc_api.pcalloc]
    shl       rax,	5
    mov       rcx,	rax
    call      mlib.pcm_allocz
    mov       [rip+pc_api.pcstart],	rax
    mov       rax,	[rip+pc_api.pcstart]
    mov       r10,	[rip+pc_api.pcalloc]
    shl       r10,	5
    lea       rax,	[rax + r10]
    sub       rax,	256
    mov       [rip+pc_api.pcend],	rax
    mov       rax,	[rip+pc_api.pcstart]
    sub       rax,	32
    mov       [rip+pc_api.pccurr],	rax
    xor       eax,	eax
    mov       [rip+pc_api.pcfixed],	al
    xor       eax,	eax
    mov       [rip+pc_api.pcseqno],	rax
    xor       eax,	eax
    mov       [rip+pc_api.pcneedfntable],	rax
    xor       eax,	eax
    mov       [rip+pc_api.mlabelno],	rax
    mov       rax,	[rip+pc_decls.currprog]
L889:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pcl_end
pc_api.pcl_end:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_api.pccurr]
    cmp       rax,	[rip+pc_api.pccurr]
    jb        L901
    mov       rax,	[rip+pc_api.pccurr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	136
    jz        L901
    mov       rcx,	136
    xor       edx,	edx
    call      pc_api.pc_gen
L901:
    mov       al,	1
    mov       [rip+pc_decls.pcldone],	al
#---------------
    add       rsp,	40
    ret       
# End 
# Proc pc_api.pcl_writepcl
pc_api.pcl_writepcl:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      pc_diags.writeallpcl
    mov       rdi,	rax
    test      rbx,	rbx
    jz        L904
    mov       al,	[rip+pc_decls.pverbose]
    test      al,	al
    jz        L906
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10393]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L906:
    movsxd    rax,	dword ptr[rdi+8]
    mov       r10,	[rdi]
    mov       rcx,	rbx
    mov       rdx,	r10
    mov       r8,	rax
    call      mlib.writefile
    lea       rax,	[rip+L10394]
    jmp       L903
L904:
    mov       rax,	[rdi]
L903:
L902:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pcl_writepst
pc_api.pcl_writepst:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      pc_diags.writepst
    mov       rdi,	rax
    test      rbx,	rbx
    jz        L909
    mov       al,	[rip+pc_decls.pverbose]
    test      al,	al
    jz        L911
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10395]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L911:
    movsxd    rax,	dword ptr[rdi+8]
    mov       r10,	[rdi]
    mov       rcx,	rbx
    mov       rdx,	r10
    mov       r8,	rax
    call      mlib.writefile
    lea       rax,	[rip+L10396]
    jmp       L908
L909:
    mov       rax,	[rdi]
L908:
L907:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pcl_genmcl
pc_api.pcl_genmcl:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
#---------------
    add       rsp,	40
    ret       
# End 
# Proc pc_api.pcl_genss
pc_api.pcl_genss:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    mov       rcx,	rdi
    call      mc_genss.genss
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_api.pcl_writess
pc_api.pcl_writess:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    mov       rcx,	r12
    call      mc_genss.genss
    mov       rax,	r12
    test      rax,	rax
    setz      al
    movzx     eax,	al
    mov       rcx,	rax
    call      mc_writess_dummy.writessdata
    mov       rdi,	rax
    test      rsi,	rsi
    jz        L916
    mov       rcx,	rsi
    lea       rdx,	[rip+L10397]
    call      fopen
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mlib.gs_println
    mov       rcx,	rbx
    call      fclose
    mov       rcx,	rdi
    call      mlib.gs_free
    xor       eax,	eax
    jmp       L915
L916:
    mov       rax,	[rdi]
L915:
L914:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pcl_writeasm
pc_api.pcl_writeasm:
#PROC1
#PROC2
#?>>
    .set pc_api.pcl_writeasm.atype, 48
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_decls.assemtype]
    cmp       rax,	1297301838
    jnz       L919
    mov       al,	2
    mov       [rip+pc_api.phighmem],	al
L919:
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    call      mc_writegas.getassemstr
    mov       rdi,	rax
    test      rsi,	rsi
    jz        L921
    mov       al,	[rip+pc_decls.pverbose]
    test      al,	al
    jz        L923
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10398]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L923:
    mov       rcx,	rsi
    lea       rdx,	[rip+L10399]
    call      fopen
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mlib.gs_println
    mov       rcx,	rbx
    call      fclose
    mov       rcx,	rdi
    call      mlib.gs_free
    xor       eax,	eax
    jmp       L920
L921:
    mov       rax,	[rdi]
L920:
L917:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pcl_writeobj
pc_api.pcl_writeobj:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    mov       rcx,	1
    call      mc_genss.genss
    xor       eax,	eax
    mov       [rip+pc_api.phighmem],	al
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10400]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rip+pc_api.phighmem]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mwindows.os_clock
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mc_writeobj.writecoff
    call      mwindows.os_clock
    sub       rax,	rdi
    mov       [rip+pc_decls.objtime],	rax
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pcl_writedll
pc_api.pcl_writedll:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       al,	2
    mov       [rip+pc_api.phighmem],	al
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    call      mwindows.os_clock
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_writeexe.writeexe
    call      mwindows.os_clock
    sub       rax,	rdi
    mov       [rip+pc_decls.exetime],	rax
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pcl_writeexe
pc_api.pcl_writeexe:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    call      mwindows.os_clock
    mov       rdi,	rax
    mov       rcx,	rbx
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_writeexe.writeexe
    call      mwindows.os_clock
    sub       rax,	rdi
    mov       [rip+pc_decls.exetime],	rax
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pcl_writemx
pc_api.pcl_writemx:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    mov       rcx,	rdi
    call      mx_write.writemcx
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_api.pcl_exec
pc_api.pcl_exec:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      mc_genmcl.genmcl
    xor       ecx,	ecx
    call      mc_genss.genss
    lea       rcx,	[rip+L10401]
    mov       rdx,	[rip+pc_decls.pcmdskip]
    call      mx_run.runlibfile
#---------------
    add       rsp,	40
    ret       
# End 
# Proc pc_api.pcl_setflags
pc_api.pcl_setflags:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    cmp       rcx,	0
    jl        L931
    mov       [rip+pc_api.phighmem],	cl
L931:
    cmp       rdx,	0
    jl        L933
    mov       [rip+pc_decls.pverbose],	dl
L933:
    cmp       r8,	0
    jl        L935
    mov       [rip+pc_api.fpshortnames],	r8b
L935:
#---------------
    ret       
# End 
# Proc pc_api.extendpclblock
pc_api.extendpclblock:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_api.pcalloc]
    shl       rax,	1
    mov       rdi,	rax
    mov       rax,	[rip+pc_api.pccurr]
    sub       rax,	[rip+pc_api.pcstart]
    shr       rax,	5
    inc       rax
    mov       rbx,	rax
    mov       rax,	32
    mov       r10,	rdi
    imul      rax,	r10
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rsi,	rax
    mov       rax,	rbx
    shl       rax,	5
    mov       rcx,	rsi
    mov       rdx,	[rip+pc_api.pcstart]
    mov       r8,	rax
    call      memcpy
    mov       rax,	rdi
    sub       rax,	rbx
    shl       rax,	5
    mov       r10,	rbx
    shl       r10,	5
    lea       r11,	[rsi + r10]
    mov       rcx,	r11
    mov       rdx,	rax
    call      mlib.pcm_clearmem
    mov       rax,	[rip+pc_api.pccurr]
    sub       rax,	[rip+pc_api.pcstart]
    shr       rax,	5
    shl       rax,	5
    lea       r10,	[rsi + rax]
    mov       [rip+pc_api.pccurr],	r10
    mov       rax,	rdi
    shl       rax,	5
    lea       r10,	[rsi + rax]
    sub       r10,	256
    mov       [rip+pc_api.pcend],	r10
    mov       rax,	[rip+pc_api.pcalloc]
    shl       rax,	5
    mov       rcx,	[rip+pc_api.pcstart]
    mov       rdx,	rax
    call      mlib.pcm_free
    mov       [rip+pc_api.pcstart],	rsi
    mov       [rip+pc_api.pcalloc],	rdi
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.newpcl
pc_api.newpcl:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_api.pccurr]
    cmp       rax,	[rip+pc_api.pcend]
    jb        L939
    call      pc_api.extendpclblock
L939:
    add       qword ptr[rip+pc_api.pccurr],	32
    mov       eax,	[rip+pc_decls.mmpos]
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+24],	eax
    inc       qword ptr[rip+pc_api.pclseqno]
    mov       rax,	[rip+pc_api.pclseqno]
    mov       r10,	[rip+pc_api.pccurr]
    lea       r10,	[r10+28]
    mov       r9d,	[r10]
    mov       r11,	-4294967041
    shl       eax,	8
    and       r9d,	r11d
    or        r9d,	eax
    mov       [r10],	r9d
    inc       qword ptr[rip+pc_decls.npcl]
    mov       rax,	[rip+pc_api.pccurr]
L937:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc pc_api.pc_gen
pc_api.pc_gen:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    test      rbx,	rbx
    jnz       L942
    call      pc_api.newpcl
    mov       rbx,	rax
L942:
    mov       [rbx],	dil
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pc_genix
pc_api.pc_genix:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi],	bl
    mov       [rdi+16],	esi
    mov       [rdi+20],	r12d
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pc_genx
pc_api.pc_genx:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    test      rsi,	rsi
    jnz       L946
    call      pc_api.newpcl
    mov       rsi,	rax
L946:
    mov       [rsi],	dil
    mov       [rsi+16],	ebx
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pc_genxy
pc_api.pc_genxy:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
#---------------
#PROC3
#PROC4
    test      r12,	r12
    jnz       L949
    call      pc_api.newpcl
    mov       r12,	rax
L949:
    mov       [r12],	dil
    mov       [r12+16],	ebx
    mov       [r12+20],	esi
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pc_gencond
pc_api.pc_gencond:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    test      rsi,	rsi
    jnz       L952
    call      pc_api.newpcl
    mov       rsi,	rax
L952:
    mov       [rsi],	dil
    mov       [rsi+2],	bl
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.genint
pc_api.genint:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	4
    mov       [rdi+1],	al
    mov       rax,	rdi
L953:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.genreal
pc_api.genreal:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
#?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       rdi,	rax
    movq      XMM4,	XMM15
    movq      [rdi+8],	XMM4
    cmp       rbx,	2
    jnz       L956
    mov       rax,	5
    jmp       L955
L956:
    mov       rax,	6
L955:
    mov       [rdi+1],	al
    mov       rax,	rdi
L954:
#---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.genrealimm
pc_api.genrealimm:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
#?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       rdi,	rax
    movq      XMM4,	XMM15
    movq      [rdi+8],	XMM4
    cmp       rbx,	2
    jnz       L959
    mov       rax,	10
    jmp       L958
L959:
    mov       rax,	11
L958:
    mov       [rdi+1],	al
    mov       rax,	rdi
L957:
#---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.genstring
pc_api.genstring:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [rdi+8],	rax
    mov       al,	7
    mov       [rdi+1],	al
    mov       rax,	rdi
L960:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.genpcstrimm
pc_api.genpcstrimm:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [rdi+8],	rax
    mov       al,	8
    mov       [rdi+1],	al
    mov       rax,	rdi
L961:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.genlabel
pc_api.genlabel:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	3
    mov       [rdi+1],	al
    mov       rax,	rdi
L962:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.genmem
pc_api.genmem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	1
    mov       [rdi+1],	al
    mov       rax,	rdi
L963:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.genmemaddr
pc_api.genmemaddr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	2
    mov       [rdi+1],	al
    mov       rax,	rdi
L964:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.gendata
pc_api.gendata:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	12
    mov       [rdi+1],	al
    mov       al,	11
    mov       [rdi+3],	al
    mov       [rdi+4],	esi
    mov       rax,	rdi
L965:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.gencomment
pc_api.gencomment:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       al,	[rip+pc_decls.fregoptim]
    test      al,	al
    jnz       L969
    mov       al,	[rip+pc_decls.fpeephole]
    test      al,	al
    jz        L968
L969:
    jmp       L966
L968:
    mov       rcx,	rdi
    call      pc_api.genpcstrimm
    mov       rcx,	135
    mov       rdx,	rax
    call      pc_api.pc_gen
L966:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_api.genname
pc_api.genname:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	8
    call      pc_api.pc_makesymbol
    mov       rcx,	rax
    call      pc_api.genmem
L970:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_api.gennameaddr
pc_api.gennameaddr:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	8
    call      pc_api.pc_makesymbol
    mov       rcx,	rax
    call      pc_api.genmemaddr
L971:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_api.genassem
pc_api.genassem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      pc_api.newpcl
    mov       rdi,	rax
    mov       [rdi+8],	rbx
    mov       al,	9
    mov       [rdi+1],	al
    mov       rax,	rdi
L972:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.strpmode
pc_api.strpmode:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+pc_api.strpmode.str]
    lea       rdx,	[rip+L10402]
    call      strcpy
    mov       rax,	rdi
    cmp       rax,	11
    jz        L975
    test      rax,	rax
    jz        L976
    jmp       L977
L975:
    lea       rcx,	[rip+pc_api.strpmode.str]
    lea       rdx,	[rip+L10403]
    call      strcpy
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rip+pc_api.strpmode.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[rip+pc_api.strpmode.str]
    jmp       L974
L976:
    lea       rax,	[rip+L10404]
    jmp       L974
L977:
    lea       rax,	[rip+pc_tables.pstdnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
L974:
L973:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pc_setmode
pc_api.pc_setmode:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       al,	cl
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+3],	al
    test      rdx,	rdx
    jz        L980
    mov       eax,	edx
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+4],	eax
    jmp       L979
L980:
    mov       rax,	[rip+pc_api.pccurr]
    movzx     rax,	byte ptr[rax+3]
    lea       r10,	[rip+pc_tables.psize]
    movzx     r10,	byte ptr[r10 + rax]
    mov       rax,	[rip+pc_api.pccurr]
    mov       [rax+4],	r10d
L979:
    mov       rax,	[rip+pc_api.pccurr]
    movzx     rax,	byte ptr[rax]
    lea       r10,	[rip+pc_tables.pclhastype]
    movzx     r10,	byte ptr[r10 + rax]
    cmp       r10,	2
    jnz       L982
    mov       rax,	[rip+pc_api.pccurr]
    movzx     rax,	byte ptr[rax+3]
    mov       r10,	[rip+pc_api.pccurr]
    lea       r10,	[r10+28]
    mov       r9d,	[r10]
    mov       r11,	-256
    and       r9d,	r11d
    or        r9d,	eax
    mov       [r10],	r9d
L982:
#---------------
    ret       
# End 
# Proc pc_api.pc_setmode2
pc_api.pc_setmode2:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_api.pccurr]
    lea       rax,	[rax+28]
    mov       r10d,	ecx
    mov       r9d,	[rax]
    mov       r11,	-256
    and       r9d,	r11d
    or        r9d,	r10d
    mov       [rax],	r9d
#---------------
    ret       
# End 
# Proc pc_api.pc_setxy
pc_api.pc_setxy:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       eax,	ecx
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+16],	eax
    mov       eax,	edx
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+20],	eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setscaleoff
pc_api.pc_setscaleoff:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       eax,	ecx
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+16],	eax
    mov       eax,	edx
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+20],	eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setoffset
pc_api.pc_setoffset:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       eax,	ecx
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+20],	eax
#---------------
    ret       
# End 
# Proc pc_api.pc_addoffset
pc_api.pc_addoffset:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_api.pccurr]
    lea       rax,	[rax+20]
    mov       r10d,	ecx
    add       [rax],	r10d
#---------------
    ret       
# End 
# Proc pc_api.pc_setincr
pc_api.pc_setincr:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       eax,	ecx
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+16],	eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setnargs
pc_api.pc_setnargs:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       eax,	ecx
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+16],	eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setnvariadics
pc_api.pc_setnvariadics:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       eax,	ecx
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+20],	eax
#---------------
    ret       
# End 
# Proc pc_api.pc_setalign
pc_api.pc_setalign:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       eax,	ecx
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+16],	eax
#---------------
    ret       
# End 
# Proc pc_api.perror
pc_api.perror:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    xor       edx,	edx
    call      pc_api.perror_s
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_api.perror_s
pc_api.perror_s:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10405]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    test      rbx,	rbx
    jz        L995
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10406]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
L995:
    mov       rcx,	1
    call      exit
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.getbasename
pc_api.getbasename:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      strlen
    lea       r10,	[rbx + rax]
    sub       r10,	1
    mov       rdi,	r10
    jmp       L998
L997:
    dec       rdi
L998:
    cmp       rdi,	rbx
    jbe       L1000
    lea       rax,	[rdi-1]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	46
    jnz       L997
L1000:
    mov       rax,	rdi
L996:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pclerror
pc_api.pclerror:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10407]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_api.pc_addsymbol
pc_api.pc_addsymbol:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_decls.psymboltable]
    test      rax,	rax
    jnz       L1004
    mov       rax,	rcx
    mov       [rip+pc_decls.psymboltablex],	rax
    mov       [rip+pc_decls.psymboltable],	rax
    jmp       L1003
L1004:
    mov       rax,	rcx
    mov       r10,	[rip+pc_decls.psymboltablex]
    mov       [r10+8],	rax
    mov       [rip+pc_decls.psymboltablex],	rcx
L1003:
#---------------
    ret       
# End 
# Proc pc_api.pc_makesymbol
pc_api.pc_makesymbol:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	128
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [rdi],	rax
    inc       qword ptr[rip+pc_api.stseqno]
    mov       rax,	[rip+pc_api.stseqno]
    mov       [rdi+120],	eax
    mov       rax,	rsi
    cmp       rax,	1
    jz        L1007
    cmp       rax,	7
    jz        L1008
    jmp       L1009
L1007:
    mov       al,	1
    mov       [rdi+80],	al
    jmp       L1006
L1008:
    mov       al,	1
    mov       [rdi+81],	al
    mov       rsi,	2
L1009:
L1006:
    mov       [rdi+72],	sil
    mov       rax,	rsi
    cmp       rax,	4
    jz        L1012
    cmp       rax,	5
    jnz       L1011
L1012:
    mov       rax,	[rip+pc_decls.currfunc]
    mov       [rdi+32],	rax
    jmp       L1010
L1011:
    test      rsi,	rsi
    jz        L1013
    mov       rcx,	rdi
    call      pc_api.pc_addsymbol
L1013:
L1010:
    mov       rax,	rdi
L1005:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.getfullname
pc_api.getfullname:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    xor       rdi,	rdi
    mov       rax,	rsi
    mov       rbx,	rax
    xor       eax,	eax
    lea       r10,	[rip+pc_api.getfullname.str]
    mov       [r10],	al
    test      r12,	r12
    jz        L1016
    lea       rcx,	[rip+pc_api.getfullname.str]
    lea       rdx,	[rip+L10408]
    call      strcpy
L1016:
    mov       al,	[rsi+80]
    test      al,	al
    jz        L1018
    test      r12,	r12
    jz        L1020
    mov       rax,	[rsi]
    lea       rcx,	[rip+pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rip+pc_api.getfullname.str]
    lea       rdx,	[rip+L10409]
    call      strcat
    jmp       L1019
L1020:
    mov       rax,	[rsi]
    lea       rcx,	[rip+pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
L1019:
    lea       rax,	[rip+pc_api.getfullname.str]
    jmp       L1014
L1018:
    movzx     rax,	byte ptr[rsi+72]
    cmp       rax,	4
    jz        L1023
    cmp       rax,	5
    jnz       L1022
L1023:
    mov       rax,	[rsi+32]
    mov       rax,	[rax]
    lea       rcx,	[rip+pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rip+pc_api.getfullname.str]
    lea       rdx,	[rip+L10410]
    call      strcat
    mov       rax,	[rsi]
    lea       rcx,	[rip+pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[rip+pc_api.getfullname.str]
    jmp       L1014
L1022:
    test      r12,	r12
    jz        L1025
    mov       rax,	[rsi]
    lea       rcx,	[rip+pc_api.getfullname.str]
    mov       rdx,	rax
    call      strcat
    jmp       L1024
L1025:
    mov       rax,	[rsi]
L1024:
L1014:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pcerrorstop
pc_api.pcerrorstop:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+L10411]
    lea       rdx,	[rip+L10412]
    call      fopen
    mov       rdi,	rax
    mov       rcx,	rdi
    call      msys.m$print_startfile
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    call      fclose
    mov       rcx,	1
    call      exit
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pc_addplib
pc_api.pc_addplib:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_decls.nplibfiles]
    cmp       rax,	50
    jl        L1029
    lea       rcx,	[rip+L10413]
    call      pc_api.perror
L1029:
    mov       rcx,	rdi
    lea       rdx,	[rip+L10414]
    call      mlib.changeext
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    inc       qword ptr[rip+pc_decls.nplibfiles]
    mov       r10,	[rip+pc_decls.nplibfiles]
    lea       r11,	[rip+pc_decls.plibfiles]
    mov       [r11 + r10*8-8],	rax
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_api.pc_defproc
pc_api.pc_defproc:
#PROC1
#PROC2
#?>>
    .set pc_api.pc_defproc.$T1, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_decls.currfunc]
    test      rax,	rax
    jz        L1032
    lea       rcx,	[rip+L10415]
    call      pc_api.pclerror
L1032:
    mov       rcx,	rdi
    call      pc_api.genmem
    mov       [rbp + pc_api.pc_defproc.$T1],	rax
    test      r12,	r12
    jz        L1034
    mov       rax,	121
    jmp       L1033
L1034:
    mov       rax,	120
L1033:
    mov       rcx,	rax
    mov       rdx,	[rbp + pc_api.pc_defproc.$T1]
    call      pc_api.pc_gen
    test      rbx,	rbx
    jnz       L1036
    movzx     rax,	byte ptr[rdi+82]
    mov       rbx,	rax
L1036:
    mov       rcx,	rbx
    xor       edx,	edx
    call      pc_api.pc_setmode
    mov       rax,	[rdi+56]
    test      rax,	rax
    jz        L1038
    mov       rax,	[rdi]
    lea       rcx,	[rip+L10416]
    mov       rdx,	rax
    call      pc_api.addstr
    mov       rcx,	rax
    call      pc_api.pclerror
L1038:
    mov       rax,	[rip+pc_api.pccurr]
    mov       [rdi+56],	rax
    mov       rax,	[rip+pc_decls.entryproc]
    test      rax,	rax
    jnz       L1040
    test      rsi,	rsi
    jz        L1040
    mov       [rip+pc_decls.entryproc],	rdi
    mov       al,	1
    mov       [rdi+83],	al
L1040:
    mov       [rip+pc_decls.currfunc],	rdi
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pc_setimport
pc_api.pc_setimport:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       [rip+pc_decls.currfunc],	rcx
#---------------
    ret       
# End 
# Proc pc_api.pc_addparam
pc_api.pc_addparam:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	[rip+pc_decls.currfunc]
    test      rdi,	rdi
    jnz       L1044
    lea       rcx,	[rip+L10417]
    call      pc_api.pclerror
L1044:
    mov       rbx,	[rdi+16]
    test      rbx,	rbx
    jnz       L1046
    mov       [rdi+16],	rsi
    jmp       L1045
L1046:
    jmp       L1048
L1047:
    mov       rbx,	[rbx+16]
L1048:
    mov       rax,	[rbx+16]
    test      rax,	rax
    jnz       L1047
    mov       [rbx+16],	rsi
L1045:
    mov       rax,	[rsi+32]
    test      rax,	rax
    jnz       L1051
    mov       rax,	[rip+pc_decls.currfunc]
    mov       [rsi+32],	rax
L1051:
    mov       rax,	[rip+pc_decls.currfunc]
    lea       rax,	[rax+112]
    inc       byte ptr[rax]
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pc_addlocal
pc_api.pc_addlocal:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	[rip+pc_decls.currfunc]
    test      rdi,	rdi
    jnz       L1054
    lea       rcx,	[rip+L10417]
    call      pc_api.pclerror
L1054:
    mov       rbx,	[rdi+24]
    test      rbx,	rbx
    jnz       L1056
    mov       [rdi+24],	rsi
    jmp       L1055
L1056:
    jmp       L1058
L1057:
    mov       rbx,	[rbx+24]
L1058:
    mov       rax,	[rbx+24]
    test      rax,	rax
    jnz       L1057
    mov       [rbx+24],	rsi
L1055:
    mov       rax,	[rsi+32]
    test      rax,	rax
    jnz       L1061
    mov       rax,	[rip+pc_decls.currfunc]
    mov       [rsi+32],	rax
L1061:
    mov       rax,	[rip+pc_decls.currfunc]
    lea       rax,	[rax+114]
    inc       word ptr[rax]
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pc_endproc
pc_api.pc_endproc:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_decls.currfunc]
    test      rax,	rax
    jnz       L1064
    lea       rcx,	[rip+L10417]
    call      pc_api.pclerror
L1064:
    mov       rcx,	122
    xor       edx,	edx
    call      pc_api.pc_gen
    xor       eax,	eax
    mov       [rip+pc_decls.currfunc],	rax
#---------------
    add       rsp,	40
    ret       
# End 
# Proc pc_api.addstr
pc_api.addstr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+pc_api.addstr.str]
    mov       rdx,	rdi
    call      strcpy
    lea       rcx,	[rip+pc_api.addstr.str]
    mov       rdx,	rbx
    call      strcat
    lea       rax,	[rip+pc_api.addstr.str]
L1065:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.merror
pc_api.merror:
#PROC1
#PROC2
#?>>
    .set pc_api.merror.filename, -8
    .set pc_api.merror.sourceline, -16
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_decls.igetmsourceinfo]
    test      rax,	rax
    jz        L1068
    mov       rcx,	[rip+pc_decls.mmpos]
    lea       rdx,	[rbp + pc_api.merror.filename]
    lea       r8,	[rbp + pc_api.merror.sourceline]
    mov       rax,	[rip+pc_decls.igetmsourceinfo]
    call      rax
    mov       rdi,	rax
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10418]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10419]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + pc_api.merror.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L1067
L1068:
    xor       rdi,	rdi
    lea       rax,	[rip+L10420]
    mov       [rbp + pc_api.merror.filename],	rax
L1067:
    mov       rax,	[rip+pc_decls.currfunc]
    test      rax,	rax
    jz        L1070
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10421]
    call      msys.m$print_str_nf
    mov       rax,	[rip+pc_decls.currfunc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1070:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10422]
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    mov       rcx,	[rbp + pc_api.merror.filename]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+pc_decls.ppseqno]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rbp + pc_api.merror.filename]
    mov       rdx,	rdi
    call      pc_api.pcerrorstop
#---------------
    add       rsp,	56
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pc_duplpst
pc_api.pc_duplpst:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	128
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	rbx
    push      rdi
    mov       r11,	16
L10423:
    mov       r10,	[rax]
    mov       [rdi],	r10
    add       rdi,	8
    add       rax,	8
    dec       r11
    jnz       L10423
    pop       rdi
    inc       qword ptr[rip+pc_api.stseqno]
    mov       rax,	[rip+pc_api.stseqno]
    mov       [rdi+120],	eax
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       rax,	rdi
L1071:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_api.pcl_cmdskip
pc_api.pcl_cmdskip:
#PROC1
#PROC2
#?>>
    .set pc_api.pcl_cmdskip.dcmdskip, 24
#?]]
#---------------
#PROC3
#PROC4
    mov       [rip+pc_decls.pcmdskip],	rcx
#---------------
    ret       
# End 
# Proc pc_api.convertstring
pc_api.convertstring:
#PROC1
#PROC2
#?>>
    .set pc_api.convertstring.str, -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    mov       rbx,	r12
    jmp       L1075
L1074:
    mov       rax,	rdi
    cmp       rax,	34
    jz        L1078
    cmp       rax,	10
    jz        L1079
    cmp       rax,	13
    jz        L1080
    cmp       rax,	9
    jz        L1081
    cmp       rax,	92
    jz        L1082
    cmp       rax,	7
    jz        L1083
    cmp       rax,	8
    jz        L1083
    cmp       rax,	26
    jz        L1083
    cmp       rax,	27
    jz        L1083
    jmp       L1084
L1078:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	34
    mov       [rax],	r10b
    jmp       L1077
L1079:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	110
    mov       [rax],	r10b
    jmp       L1077
L1080:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	114
    mov       [rax],	r10b
    jmp       L1077
L1081:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	116
    mov       [rax],	r10b
    jmp       L1077
L1082:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    jmp       L1077
L1083:
    mov       rax,	r12
    inc       r12
    mov       r10b,	60
    mov       [rax],	r10b
    mov       rax,	rdi
    mov       r10,	10
    cqo       
    idiv      r10
    add       rax,	48
    mov       r10,	r12
    inc       r12
    mov       [r10],	al
    mov       rax,	rdi
    mov       r10,	10
    cqo       
    idiv      r10
    xchg      rax,	rdx
    add       rax,	48
    mov       r10,	r12
    inc       r12
    mov       [r10],	al
    mov       rax,	r12
    inc       r12
    mov       r10b,	62
    mov       [rax],	r10b
    jmp       L1077
L1084:
    mov       rax,	rdi
    cmp       rax,	32
    jl        L1086
    cmp       rax,	126
    jg        L1086
    mov       rax,	r12
    inc       r12
    mov       r10b,	dil
    mov       [rax],	r10b
    jmp       L1085
L1086:
    mov       rax,	r12
    inc       r12
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	120
    mov       [rax],	r10b
    lea       rcx,	[rbp + pc_api.convertstring.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    lea       rdx,	[rip+L10424]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       al,	[rbp + pc_api.convertstring.str]
    mov       r10,	r12
    inc       r12
    mov       [r10],	al
    mov       al,	[rbp + pc_api.convertstring.str+1]
    mov       r10,	r12
    inc       r12
    mov       [r10],	al
L1085:
L1077:
L1075:
    mov       rax,	rsi
    inc       rsi
    movzx     rax,	byte ptr[rax]
    mov       rdi,	rax
    test      rax,	rax
    jnz       L1074
    xor       eax,	eax
    mov       [r12],	al
    mov       rax,	r12
    sub       rax,	rbx
L1073:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_diags.strpcl
pc_diags.strpcl:
#PROC1
#PROC2
#?>>
    .set pc_diags.strpcl.p, 64
    .set pc_diags.strpcl.str, -256
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       [rbp+64],	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte ptr[rax]
    mov       rdi,	rax
    mov       rax,	rdi
    cmp       rax,	127
    jz        L1089
    cmp       rax,	128
    jz        L1090
    cmp       rax,	135
    jz        L1091
    cmp       rax,	120
    jz        L1092
    cmp       rax,	121
    jz        L1092
    cmp       rax,	122
    jz        L1093
    cmp       rax,	136
    jz        L1094
    cmp       rax,	125
    jz        L1095
    cmp       rax,	123
    jz        L1096
    cmp       rax,	124
    jz        L1096
    jmp       L1097
L1089:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    mov       rdx,	1
    call      pc_diags.strlabel
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       eax,	[rax+16]
    test      eax,	eax
    jz        L1099
    lea       rcx,	[rip+L10425]
    call      pc_diags.psstr
L1099:
    jmp       L1087
L1090:
    lea       rcx,	[rip+L10426]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rax,	[rax+8]
    mov       rcx,	[rax]
    call      pc_diags.psstr
    lea       rcx,	[rip+L10427]
    call      pc_diags.psstr
    jmp       L1087
L1091:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rax,	[rax+8]
    mov       al,	[rax]
    test      al,	al
    jz        L1101
    lea       rcx,	[rip+L10428]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rcx,	[rax+8]
    call      pc_diags.psstr
    jmp       L1100
L1101:
    lea       rcx,	[rip+L10429]
    call      pc_diags.psstr
L1100:
    jmp       L1087
L1092:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       r13,	[rax+8]
    cmp       rdi,	121
    jnz       L1103
    lea       rcx,	[rip+L10430]
    call      pc_diags.psstr
    jmp       L1102
L1103:
    lea       rcx,	[rip+L10431]
    call      pc_diags.psstr
L1102:
    lea       rcx,	[rip+L10432]
    call      pc_diags.psstr
    mov       rcx,	r13
    call      pc_diags.psname
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       rax,	[rax+8]
    mov       al,	[rax+81]
    test      al,	al
    jz        L1105
    lea       rax,	[rip+L10433]
    jmp       L1104
L1105:
    lea       rax,	[rip+L10434]
L1104:
    mov       rcx,	rax
    call      pc_diags.psstr
    mov       al,	[r13+83]
    test      al,	al
    jz        L1107
    lea       rcx,	[rip+L10434]
    call      pc_diags.psstr
L1107:
    call      pc_diags.psline
    mov       r14,	[r13+16]
    jmp       L1111
L1108:
    lea       rcx,	[rip+L10435]
    call      pc_diags.psstr
    mov       eax,	[r14+84]
    movzx     r10,	byte ptr[r14+82]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[rip+L10436]
    call      pc_diags.psstr
    mov       rcx,	[r14]
    call      pc_diags.psstr
    call      pc_diags.psline
    mov       r14,	[r14+16]
L1111:
    test      r14,	r14
    jnz       L1108
    mov       r14,	[r13+24]
    jmp       L1115
L1112:
    lea       rcx,	[rip+L10437]
    call      pc_diags.psstr
    mov       eax,	[r14+84]
    movzx     r10,	byte ptr[r14+82]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[rip+L10438]
    call      pc_diags.psstr
    mov       rcx,	[r14]
    call      pc_diags.psstr
    call      pc_diags.psline
    mov       r14,	[r14+24]
L1115:
    test      r14,	r14
    jnz       L1112
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       al,	[rax+3]
    test      al,	al
    jz        L1117
    lea       rcx,	[rip+L10439]
    call      pc_diags.psstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte ptr[rax+3]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    call      pc_diags.psline
L1117:
    mov       al,	[r13+113]
    test      al,	al
    jz        L1119
    lea       rcx,	[rip+L10440]
    call      pc_diags.psstrline
L1119:
    jmp       L1087
L1093:
    lea       rcx,	[rip+L10441]
    call      pc_diags.psstr
    call      pc_diags.psline
    jmp       L1087
L1094:
    lea       rcx,	[rip+L10442]
    call      pc_diags.psstr
    jmp       L1087
L1095:
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte ptr[rax+3]
    cmp       rax,	11
    jnz       L1121
    mov       rcx,	[rbp + pc_diags.strpcl.p]
    call      pc_diags.psdata
    jmp       L1087
L1121:
    jmp       L1088
L1096:
    jmp       L1122
L1097:
L1088:
    lea       rcx,	[rip+L10443]
    call      pc_diags.psstr
#pc_diags.strpcl.skiptab:
L1122:
    mov       rax,	rdi
    cmp       rax,	26
    jz        L1124
    cmp       rax,	31
    jz        L1125
    jmp       L1126
L1124:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[rip+L10444]
    call      strcpy
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte ptr[rax+2]
    lea       r10,	[rip+pc_tables.ccnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	r10
    call      strcat
    jmp       L1123
L1125:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[rip+L10445]
    call      strcpy
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte ptr[rax+2]
    lea       r10,	[rip+pc_tables.ccnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	r10
    call      strcat
    jmp       L1123
L1126:
    lea       rax,	[rip+pc_tables.pclnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcpy
L1123:
    mov       rcx,	[rip+pc_diags.dest]
    lea       rdx,	[rbp + pc_diags.strpcl.str]
    mov       r8,	9
    mov       r9,	32
    call      mlib.gs_leftstr
    xor       eax,	eax
    mov       [rbp + pc_diags.strpcl.str],	al
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       al,	[rax+3]
    test      al,	al
    jz        L1128
    mov       rax,	[rbp + pc_diags.strpcl.p]
    mov       eax,	[rax+4]
    mov       r10,	[rbp + pc_diags.strpcl.p]
    movzx     r10,	byte ptr[r10+3]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.strpmode
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[rip+pc_tables.pclhastype]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10]
    cmp       rax,	2
    jnz       L1130
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[rip+L10446]
    call      strcat
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    rax,	dword ptr[rax+28]
    and       rax,	255
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.strpmode
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcat
L1130:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[rip+L10447]
    call      strcat
L1128:
    mov       rcx,	[rip+pc_diags.dest]
    lea       rdx,	[rbp + pc_diags.strpcl.str]
    mov       r8,	4
    mov       r9,	32
    call      mlib.gs_leftstr
    xor       eax,	eax
    mov       [rbp + pc_diags.strpcl.str],	al
    lea       rax,	[rip+pc_tables.pclextra]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10]
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L1132
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    rax,	dword ptr[rax+16]
    mov       rsi,	rax
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    rax,	dword ptr[rax+20]
    mov       r12,	rax
    test      rsi,	rsi
    jnz       L1135
    cmp       rbx,	2
    jnz       L1134
L1135:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[rip+L10448]
    call      strcat
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movsxd    rax,	dword ptr[rax+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcat
L1134:
    cmp       rbx,	2
    jnz       L1137
    test      r12,	r12
    jz        L1137
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[rip+L10448]
    call      strcat
    mov       rcx,	r12
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    mov       rdx,	rax
    call      strcat
L1137:
    lea       rcx,	[rbp + pc_diags.strpcl.str]
    lea       rdx,	[rip+L10449]
    call      strcat
L1132:
    mov       rcx,	[rip+pc_diags.dest]
    lea       rdx,	[rbp + pc_diags.strpcl.str]
    mov       r8,	5
    mov       r9,	32
    call      mlib.gs_leftstr
    mov       rax,	[rbp + pc_diags.strpcl.p]
    movzx     rax,	byte ptr[rax+1]
    test      rax,	rax
    jz        L1139
    lea       rcx,	[rip+L10449]
    call      pc_diags.psstr
    mov       rcx,	[rbp + pc_diags.strpcl.p]
    call      pc_diags.stropnd
    mov       rcx,	rax
    call      pc_diags.psstr
L1139:
    mov       rcx,	40
    call      pc_diags.pstabto
L1087:
#---------------
    add       rsp,	288
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_diags.stropnd
pc_diags.stropnd:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    test      rsi,	rsi
    jnz       L1142
    lea       rax,	[rip+L10450]
    jmp       L1140
L1142:
    xor       eax,	eax
    lea       r10,	[rip+pc_diags.stropnd.str]
    mov       [r10],	al
    movzx     rax,	byte ptr[rsi+1]
    cmp       rax,	4
    jz        L1144
    cmp       rax,	5
    jz        L1145
    cmp       rax,	10
    jz        L1145
    cmp       rax,	11
    jz        L1145
    cmp       rax,	6
    jz        L1145
    cmp       rax,	7
    jz        L1146
    cmp       rax,	1
    jz        L1147
    cmp       rax,	2
    jz        L1148
    cmp       rax,	3
    jz        L1149
    test      rax,	rax
    jz        L1150
    cmp       rax,	9
    jz        L1151
    cmp       rax,	12
    jz        L1152
    jmp       L1153
L1144:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    jmp       L1140
L1145:
    movq      XMM4,	[rsi+8]
    comisd    XMM4,	[rip+L10451]
    jnz       L1155
    lea       rcx,	[rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10452]
    call      msys.m$print_setfmt
    call      msys.m$print_end
    jmp       L1154
L1155:
    lea       rcx,	[rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    lea       rdx,	[rip+L10453]
    call      msys.m$print_r64
    call      msys.m$print_end
L1154:
    jmp       L1143
L1146:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      strlen
    mov       rdi,	rax
    cmp       rax,	256
    jge       L1157
    lea       rcx,	[rip+pc_diags.stropnd.str]
    lea       rdx,	[rip+L10454]
    call      strcpy
    lea       rax,	[rip+pc_diags.stropnd.str]
    lea       rax,	[rax+1]
    mov       r10,	[rsi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.convertstring
    lea       rcx,	[rip+pc_diags.stropnd.str]
    lea       rdx,	[rip+L10454]
    call      strcat
    jmp       L1156
L1157:
    mov       rax,	[rip+pc_diags.stropnd.longstring]
    test      rax,	rax
    jz        L1159
    mov       rcx,	[rip+pc_diags.stropnd.longstring]
    mov       rdx,	[rip+pc_api.longstringlen]
    call      mlib.pcm_free
L1159:
    mov       rax,	rdi
    shl       rax,	1
    mov       [rip+pc_api.longstringlen],	rax
    mov       rcx,	[rip+pc_api.longstringlen]
    call      mlib.pcm_alloc
    mov       [rip+pc_diags.stropnd.longstring],	rax
    mov       al,	34
    mov       r10,	[rip+pc_diags.stropnd.longstring]
    mov       [r10],	al
    mov       rax,	[rip+pc_diags.stropnd.longstring]
    lea       rax,	[rax+1]
    mov       r10,	[rsi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.convertstring
    mov       rdi,	rax
    mov       al,	34
    mov       r10,	[rip+pc_diags.stropnd.longstring]
    mov       r11,	rdi
    mov       [r10 + r11+1],	al
    xor       eax,	eax
    mov       r10,	[rip+pc_diags.stropnd.longstring]
    mov       r11,	rdi
    mov       [r10 + r11+2],	al
    mov       rax,	[rip+pc_diags.stropnd.longstring]
    jmp       L1140
L1156:
    jmp       L1143
L1147:
    mov       rbx,	[rsi+8]
    mov       rax,	[rsi+8]
    mov       rax,	[rax]
    lea       rcx,	[rip+pc_diags.stropnd.str]
    mov       rdx,	rax
    call      strcat
    movzx     rax,	byte ptr[rsi]
    cmp       rax,	123
    jz        L1162
    cmp       rax,	124
    jnz       L1161
L1162:
    lea       rcx,	[rip+pc_diags.stropnd.str]
    lea       rdx,	[rip+L10455]
    call      strcat
    mov       al,	[rbx+81]
    test      al,	al
    jz        L1164
    lea       rcx,	[rip+pc_diags.stropnd.str]
    lea       rdx,	[rip+L10455]
    call      strcat
L1164:
L1161:
    jmp       L1143
L1148:
    lea       rcx,	[rip+pc_diags.stropnd.str]
    lea       rdx,	[rip+L10456]
    call      strcpy
    jmp       L1147
L1149:
    lea       rcx,	[rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10457]
    call      msys.m$print_setfmt
    lea       rcx,	[rip+L10458]
    call      msys.m$print_str_nf
    mov       rcx,	[rsi+8]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L1143
L1150:
    lea       rax,	[rip+L10459]
    jmp       L1140
L1151:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    jmp       L1140
L1152:
    lea       rcx,	[rip+pc_diags.stropnd.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10460]
    call      msys.m$print_setfmt
    mov       eax,	[rsi+4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    mov       rcx,	[rsi+8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L1143
L1153:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10461]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rsi+1]
    lea       r10,	[rip+pc_tables.opndnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[rip+L10462]
    jmp       L1140
L1143:
    lea       rax,	[rip+pc_diags.stropnd.str]
L1140:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_diags.strpclstr
pc_diags.strpclstr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+pc_diags.dest]
    call      mlib.gs_free
    mov       rcx,	[rip+pc_diags.dest]
    call      mlib.gs_init
    xor       eax,	eax
    mov       [rip+pc_diags.destlinestart],	rax
    mov       rcx,	rdi
    call      pc_diags.strpcl
    mov       rcx,	[rip+pc_diags.dest]
    xor       edx,	edx
    call      mlib.gs_char
    mov       rax,	[rip+pc_diags.dest]
    movsxd    rax,	dword ptr[rax+8]
    cmp       rax,	rbx
    jl        L1167
    lea       rax,	[rip+L10463]
    jmp       L1165
L1167:
    mov       rax,	[rip+pc_diags.dest]
    mov       rax,	[rax]
L1165:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_diags.writepcl
pc_diags.writepcl:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      pc_diags.strpcl
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	120
    jnz       L1171
L1170:
    jmp       L1169
L1171:
    mov       rcx,	[rip+pc_diags.dest]
    call      mlib.gs_line
L1169:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_diags.writeallpcl
pc_diags.writeallpcl:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+pc_diags.dest]
    call      mlib.gs_init
    mov       rax,	[rip+pc_diags.dest]
    movsxd    rax,	dword ptr[rax+8]
    mov       [rip+pc_diags.destlinestart],	rax
    mov       rcx,	[rip+pc_diags.dest]
    lea       rdx,	[rip+L10464]
    call      mlib.gs_strln
    mov       rsi,	1
    mov       rax,	[rip+pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L1175
L1173:
    lea       rcx,	[rip+L10465]
    call      pc_diags.psstr
    lea       rax,	[rip+pc_decls.plibfiles]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8-8]
    call      pc_diags.psstr
    lea       rcx,	[rip+L10466]
    call      pc_diags.psstr
    call      pc_diags.psline
    inc       rsi
    cmp       rsi,	[rip+pc_decls.nplibfiles]
    jle       L1173
L1175:
    mov       rax,	[rip+pc_decls.nplibfiles]
    test      rax,	rax
    jz        L1177
    call      pc_diags.psline
L1177:
    mov       rbx,	[rip+pc_decls.psymboltable]
    jmp       L1181
L1178:
    movzx     rax,	byte ptr[rbx+72]
    cmp       rax,	1
    jnz       L1183
    lea       rcx,	[rip+L10467]
    call      pc_diags.psstr
    mov       rcx,	[rbx]
    call      pc_diags.psstr
    mov       al,	[rbx+113]
    test      al,	al
    jz        L1185
    lea       rcx,	[rip+L10468]
    call      pc_diags.psstr
L1185:
    call      pc_diags.psline
L1183:
    mov       rbx,	[rbx+8]
L1181:
    test      rbx,	rbx
    jnz       L1178
    mov       rdi,	[rip+pc_api.pcstart]
    jmp       L1187
L1186:
    mov       rcx,	rdi
    call      pc_diags.writepcl
    mov       rax,	[rip+pc_diags.dest]
    movsxd    rax,	dword ptr[rax+8]
    mov       [rip+pc_diags.destlinestart],	rax
    add       rdi,	32
L1187:
    cmp       rdi,	[rip+pc_api.pccurr]
    jbe       L1186
    call      pc_diags.psline
    mov       rax,	[rip+pc_api.longstring]
    test      rax,	rax
    jz        L1190
    mov       rcx,	[rip+pc_api.longstring]
    mov       rdx,	[rip+pc_api.longstringlen]
    call      mlib.pcm_free
L1190:
    mov       rax,	[rip+pc_diags.dest]
L1172:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_diags.psstr
pc_diags.psstr:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+pc_diags.dest]
    mov       rdx,	rdi
    call      mlib.gs_str
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_diags.psstrline
pc_diags.psstrline:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+pc_diags.dest]
    mov       rdx,	rdi
    call      mlib.gs_str
    mov       rcx,	[rip+pc_diags.dest]
    call      mlib.gs_line
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_diags.psline
pc_diags.psline:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+pc_diags.dest]
    lea       rdx,	[rip+L10469]
    call      mlib.gs_str
#---------------
    add       rsp,	40
    ret       
# End 
# Proc pc_diags.psint
pc_diags.psint:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	[rip+pc_diags.dest]
    mov       rdx,	rax
    call      mlib.gs_str
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_diags.psname
pc_diags.psname:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rdi]
    mov       rcx,	[rip+pc_diags.dest]
    mov       rdx,	rax
    call      mlib.gs_str
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_diags.pstabto
pc_diags.pstabto:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_diags.dest]
    movsxd    rax,	dword ptr[rax+8]
    sub       rax,	[rip+pc_diags.destlinestart]
    mov       rdi,	rax
    jmp       L1198
L1197:
    lea       rcx,	[rip+L10470]
    call      pc_diags.psstr
    inc       rdi
L1198:
    cmp       rbx,	rdi
    jg        L1197
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_diags.strlabel
pc_diags.strlabel:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+L10471]
    call      pc_diags.psstr
    mov       rcx,	rdi
    call      pc_diags.psint
    test      rbx,	rbx
    jz        L1202
    lea       rcx,	[rip+L10472]
    call      pc_diags.psstr
L1202:
    lea       rcx,	[rip+L10473]
    call      pc_diags.psstr
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_diags.psopnd
pc_diags.psopnd:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      pc_diags.stropnd
    mov       rcx,	rax
    call      pc_diags.psstr
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_diags.psdata
pc_diags.psdata:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    mov       eax,	[r13+4]
    mov       rdi,	rax
    mov       rsi,	[r13+8]
    test      rdi,	rdi
    jnz       L1206
    jmp       L1204
L1206:
    jmp       L1208
L1207:
    mov       rbx,	rdi
    cmp       rbx,	20
    jl        L1211
    mov       rbx,	20
L1211:
    mov       rax,	rbx
    sub       rdi,	rax
    lea       rcx,	[rip+L10474]
    call      pc_diags.psstr
    mov       rcx,	rbx
    call      pc_diags.psint
    lea       rcx,	[rip+L10475]
    call      pc_diags.psstr
    cmp       rbx,	10
    jge       L1213
    lea       rcx,	[rip+L10476]
    call      pc_diags.psstr
L1213:
    mov       r12,	rbx
    cmp       r12,	0
    jle       L1216
L1214:
    movzx     rax,	byte ptr[rsi]
    mov       rcx,	rax
    call      pc_diags.psint
    lea       rcx,	[rip+L10476]
    call      pc_diags.psstr
    inc       rsi
    dec       r12
    jnz       L1214
L1216:
    test      rdi,	rdi
    jz        L1218
    call      pc_diags.psline
L1218:
L1208:
    cmp       rdi,	0
    jg        L1207
L1204:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_diags.writepst
pc_diags.writepst:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    xor       dil,	dil
    xor       eax,	eax
    mov       rbx,	rax
    mov       rcx,	[rip+pc_diags.dest]
    call      mlib.gs_init
    lea       rcx,	[rip+L10477]
    call      pc_diags.psstrline
    call      pc_diags.psline
    mov       r12,	[rip+pc_decls.psymboltable]
    jmp       L1223
L1220:
    mov       rcx,	r12
    lea       rdx,	[rip+L10478]
    call      msys.strint
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[rip+L10479]
    call      pc_diags.psstr
    mov       rcx,	r12
    lea       rdx,	[rip+L10480]
    call      pc_diags.writepsymbol
    movzx     rax,	byte ptr[r12+72]
    cmp       rax,	2
    jz        L1226
    cmp       rax,	1
    jnz       L1225
L1226:
    mov       r13,	[r12+16]
    xor       rsi,	rsi
    jmp       L1230
L1227:
    lea       rcx,	[rip+L10481]
    call      pc_diags.psstr
    mov       rcx,	r13
    lea       rdx,	[rip+L10482]
    call      pc_diags.writepsymbol
    mov       r13,	[r13+16]
L1230:
    test      r13,	r13
    jnz       L1227
    mov       r13,	[r12+24]
    xor       rsi,	rsi
    jmp       L1234
L1231:
    lea       rcx,	[rip+L10483]
    call      pc_diags.psstr
    mov       rcx,	r13
    lea       rdx,	[rip+L10484]
    call      pc_diags.writepsymbol
    mov       r13,	[r13+24]
L1234:
    test      r13,	r13
    jnz       L1231
L1225:
    call      pc_diags.psline
    mov       r12,	[r12+8]
L1223:
    test      r12,	r12
    jnz       L1220
    call      pc_diags.psline
    mov       rax,	[rip+pc_diags.dest]
L1219:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_diags.writepsymbol
pc_diags.writepsymbol:
#PROC1
#PROC2
#?>>
    .set pc_diags.writepsymbol.str, -256
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    xor       dil,	dil
    lea       rcx,	[rbp + pc_diags.writepsymbol.str]
    call      msys.m$print_startstr
    mov       eax,	[rsi+120]
    mov       rcx,	rax
    lea       rdx,	[rip+L10485]
    call      msys.m$print_i64
    movzx     rax,	byte ptr[rsi+72]
    lea       r10,	[rip+pc_tables.idnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.writepsymbol.str]
    call      pc_diags.psstr
    movzx     rax,	byte ptr[rsi+72]
    lea       r10,	[rip+pc_tables.idnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      strlen
    mov       r10,	8
    sub       r10,	rax
    mov       rbx,	r10
    cmp       rbx,	0
    jle       L1238
L1236:
    lea       rcx,	[rip+L10486]
    call      pc_diags.psstr
    dec       rbx
    jnz       L1236
L1238:
    xor       eax,	eax
    mov       [rbp + pc_diags.writepsymbol.str],	al
    lea       rcx,	[rbp + pc_diags.writepsymbol.str]
    call      msys.m$print_startstr
    mov       rax,	[rsi]
    mov       rcx,	rax
    mov       rdx,	r12
    call      msys.m$print_str
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.writepsymbol.str]
    call      pc_diags.psstr
    mov       eax,	[rsi+84]
    movzx     r10,	byte ptr[rsi+82]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_api.strpmode
    mov       rcx,	rax
    call      pc_diags.psstr
    movzx     rax,	byte ptr[rsi+72]
    cmp       rax,	2
    jnz       L1240
    lea       rcx,	[rip+L10487]
    call      pc_diags.psstr
    movzx     rax,	byte ptr[rsi+112]
    mov       rcx,	rax
    call      pc_diags.psint
    lea       rcx,	[rip+L10488]
    call      pc_diags.psstr
    movsx     rax,	word ptr[rsi+114]
    mov       rcx,	rax
    call      pc_diags.psint
L1240:
    mov       al,	[rsi+81]
    test      al,	al
    jz        L1242
    lea       rcx,	[rip+L10489]
    call      pc_diags.psstr
L1242:
    mov       al,	[rsi+80]
    test      al,	al
    jz        L1244
    lea       rcx,	[rip+L10490]
    call      pc_diags.psstr
L1244:
    mov       al,	[rsi+107]
    test      al,	al
    jz        L1246
    lea       rcx,	[rip+L10491]
    call      pc_diags.psstr
    movzx     rax,	byte ptr[rsi+107]
    mov       rcx,	rax
    call      pc_diags.psint
L1246:
    mov       al,	[rsi+108]
    test      al,	al
    jz        L1248
    lea       rcx,	[rip+L10492]
    call      pc_diags.psstr
L1248:
    mov       al,	[rsi+95]
    test      al,	al
    jz        L1250
    lea       rcx,	[rip+L10493]
    call      pc_diags.psstr
L1250:
    mov       al,	[rsi+83]
    test      al,	al
    jz        L1252
    lea       rcx,	[rip+L10494]
    call      pc_diags.psstr
L1252:
    movzx     rax,	byte ptr[rsi+72]
    cmp       rax,	2
    jnz       L1254
    lea       rcx,	[rip+L10495]
    call      pc_diags.psstr
    mov       rax,	[rsi+56]
    mov       rcx,	rax
    lea       rdx,	[rip+L10496]
    call      msys.strint
    mov       rcx,	rax
    call      pc_diags.psstr
L1254:
    mov       rax,	[rsi+32]
    test      rax,	rax
    jz        L1256
    lea       rcx,	[rip+L10497]
    call      pc_diags.psstr
    mov       rax,	[rsi+32]
    mov       eax,	[rax+120]
    mov       rcx,	rax
    call      pc_diags.psint
    lea       rcx,	[rip+L10498]
    call      pc_diags.psstr
    mov       rax,	[rsi+32]
    mov       rcx,	[rax]
    call      pc_diags.psstr
    lea       rcx,	[rip+L10499]
    call      pc_diags.psstr
L1256:
    xor       eax,	eax
    test      ax,	ax
    jz        L1258
    movzx     rax,	byte ptr[rsi+72]
    cmp       rax,	3
    jnz       L1258
    mov       rax,	[rsi+56]
    test      rax,	rax
    jz        L1258
    lea       rcx,	[rip+L10500]
    call      pc_diags.psstr
    mov       rax,	[rsi+56]
    mov       rcx,	[rax]
    call      pc_diags.psstr
    lea       rcx,	[rip+L10501]
    call      pc_diags.psstr
    mov       rax,	[rsi+24]
    mov       rcx,	rax
    lea       rdx,	[rip+L10502]
    call      msys.strint
    mov       rcx,	rax
    call      pc_diags.psstr
    lea       rcx,	[rip+L10503]
    call      pc_diags.psstr
L1258:
    xor       eax,	eax
    test      ax,	ax
    jz        L1260
    movzx     rax,	byte ptr[rsi+72]
    cmp       rax,	2
    jnz       L1260
    movzx     rax,	byte ptr[rsi+104]
    shr       eax,	1
    and       eax,	1
    test      rax,	rax
    jz        L1260
    lea       rcx,	[rip+L10504]
    call      pc_diags.psstr
L1260:
    call      pc_diags.psline
#---------------
    add       rsp,	288
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_diags.showprocinfo
pc_diags.showprocinfo:
#PROC1
#PROC2
#?>>
    .set pc_diags.showprocinfo.str, -256
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	[rsi+48]
    test      rdi,	rdi
    jnz       L1263
    jmp       L1261
L1263:
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10505]
    call      msys.m$print_setfmt
    mov       rcx,	[rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10506]
    call      msys.m$print_setfmt
    movzx     rax,	byte ptr[rdi+1]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10507]
    call      msys.m$print_setfmt
    movzx     rax,	byte ptr[rdi+2]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10508]
    call      msys.m$print_setfmt
    movzx     rax,	byte ptr[rdi+3]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10509]
    call      msys.m$print_setfmt
    movzx     rax,	byte ptr[rdi+4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10510]
    call      msys.m$print_setfmt
    movzx     rax,	byte ptr[rdi+5]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10511]
    call      msys.m$print_setfmt
    movzx     rax,	byte ptr[rdi+6]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10512]
    call      msys.m$print_setfmt
    movzx     rax,	byte ptr[rdi+7]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    call      pc_diags.psline
    mov       rbx,	[rsi+16]
    jmp       L1267
L1264:
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10513]
    call      msys.m$print_setfmt
    mov       rcx,	[rbx]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rbx+92]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    movzx     rax,	byte ptr[rbx+88]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    mov       rbx,	[rbx+16]
L1267:
    test      rbx,	rbx
    jnz       L1264
    mov       rbx,	[rsi+24]
    jmp       L1271
L1268:
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10514]
    call      msys.m$print_setfmt
    mov       rcx,	[rbx]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rbx+92]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    movzx     rax,	byte ptr[rbx+88]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + pc_diags.showprocinfo.str]
    call      pc_diags.psstrline
    mov       rbx,	[rbx+24]
L1271:
    test      rbx,	rbx
    jnz       L1268
    call      pc_diags.psline
L1261:
#---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_reduce.pcl_reducetest
pc_reduce.pcl_reducetest:
#PROC1
#PROC2
#?>>
    .set pc_reduce.pcl_reducetest.pcproc, -8
    .set pc_reduce.pcl_reducetest.labelmap, -16
    .set pc_reduce.pcl_reducetest.pdef, -24
    .set pc_reduce.pcl_reducetest.callstack, -280
    .set pc_reduce.pcl_reducetest.ncall, -288
    .set pc_reduce.pcl_reducetest.nprocs, -296
    .set pc_reduce.pcl_reducetest.nleaf, -304
    .set pc_reduce.pcl_reducetest.nallparams, -312
    .set pc_reduce.pcl_reducetest.nalllocals, -320
    .set pc_reduce.pcl_reducetest.av_1, -328
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	360
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.nprocs],	rax
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.nleaf],	rax
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.nallparams],	rax
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.nalllocals],	rax
    mov       rax,	[rip+pc_api.pccurr]
    sub       rax,	[rip+pc_api.pcstart]
    shr       rax,	5
    inc       rax
    mov       rdi,	rax
    mov       r13,	[rip+pc_api.pcstart]
    mov       rax,	[rip+pc_api.mlabelno]
    shl       rax,	1
    mov       rcx,	rax
    call      mlib.pcm_allocz
    mov       [rbp + pc_reduce.pcl_reducetest.labelmap],	rax
    jmp       L1276
L1273:
    movzx     rax,	byte ptr[r13]
    cmp       rax,	127
    jz        L1278
    cmp       rax,	42
    jz        L1279
    jmp       L1280
L1278:
    jmp       L1277
L1279:
    mov       rax,	[rip+pc_api.icheckasmlabel]
    test      rax,	rax
    jz        L1282
    mov       rax,	[r13+8]
    mov       rcx,	rax
    mov       r10,	[rip+pc_api.icheckasmlabel]
    call      r10
    mov       rsi,	rax
    test      rsi,	rsi
    jz        L1284
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       r10,	rsi
    lea       rax,	[rax + r10*2-2]
    inc       word ptr[rax]
L1284:
L1282:
    jmp       L1277
L1280:
    movzx     rax,	byte ptr[r13+1]
    cmp       rax,	3
    jnz       L1286
    mov       rax,	[r13+8]
    mov       r10,	[rbp + pc_reduce.pcl_reducetest.labelmap]
    lea       r10,	[r10 + rax*2-2]
    inc       word ptr[r10]
L1286:
L1277:
    add       r13,	32
L1276:
    cmp       r13,	[rip+pc_api.pccurr]
    jbe       L1273
#pc_reduce.pcl_reducetest.skip:
    mov       r13,	[rip+pc_api.pcstart]
    mov       rax,	[rip+pc_api.pcstart]
    sub       rax,	32
    mov       r14,	rax
    xor       rbx,	rbx
    mov       rax,	rdi
    mov       [rbp + pc_reduce.pcl_reducetest.av_1],	rax
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.av_1]
    cmp       rax,	0
    jle       L1290
L1288:
    lea       rax,	[r13+32]
    mov       r15,	rax
    movzx     rax,	byte ptr[r13]
    lea       r10,	[rip+pc_tables.pclargs]
    movzx     r10,	byte ptr[r10 + rax]
    mov       r12,	r10
    test      r10,	r10
    jz        L1292
    cmp       r12,	9
    jnz       L1294
    movsxd    rax,	dword ptr[r13+16]
    mov       r12,	rax
L1294:
    mov       rax,	[rip+pc_decls.pinfo]
    movzx     rax,	byte ptr[rax+4]
    mov       r10,	r12
    cmp       rax,	r10
    cmovl     rax,	r10
    mov       r10,	[rip+pc_decls.pinfo]
    mov       [r10+4],	al
L1292:
    movzx     rax,	byte ptr[r13+3]
    cmp       rax,	11
    jnz       L1296
    mov       rax,	[rip+pc_decls.pinfo]
    test      rax,	rax
    jz        L1296
    mov       eax,	[r13+4]
    cmp       rax,	16
    jz        L1296
    mov       al,	1
    mov       r10,	[rip+pc_decls.pinfo]
    mov       [r10+7],	al
L1296:
    movzx     rax,	byte ptr[r13]
    cmp       rax,	135
    jz        L1298
    cmp       rax,	127
    jz        L1299
    cmp       rax,	120
    jz        L1300
    cmp       rax,	121
    jz        L1300
    cmp       rax,	18
    jz        L1301
    cmp       rax,	21
    jz        L1301
    cmp       rax,	19
    jz        L1301
    cmp       rax,	22
    jz        L1301
    cmp       rax,	131
    jz        L1302
    cmp       rax,	122
    jz        L1303
    cmp       rax,	42
    jz        L1304
    cmp       rax,	2
    jz        L1305
    cmp       rax,	5
    jz        L1305
    cmp       rax,	114
    jz        L1306
    cmp       rax,	113
    jz        L1307
    cmp       rax,	1
    jz        L1308
    jmp       L1309
L1298:
    jmp       L1297
L1299:
    mov       rax,	[r13+8]
    mov       r10,	[rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       r10w,	[r10 + rax*2-2]
    test      r10w,	r10w
    jz        L1311
    jmp       L1309
L1311:
    jmp       L1297
L1300:
    inc       qword ptr[rbp + pc_reduce.pcl_reducetest.nprocs]
    mov       rax,	[r13+8]
    mov       [rbp + pc_reduce.pcl_reducetest.pdef],	rax
    lea       rax,	[r14+32]
    mov       r10,	[rbp + pc_reduce.pcl_reducetest.pdef]
    mov       [r10+56],	rax
    mov       rcx,	8
    call      mlib.pcm_alloc
    mov       [rip+pc_decls.pinfo],	rax
    mov       rax,	[rip+pc_decls.pinfo]
    mov       r10,	[rbp + pc_reduce.pcl_reducetest.pdef]
    mov       [r10+48],	rax
    mov       al,	1
    mov       r10,	[rip+pc_decls.pinfo]
    mov       [r10+3],	al
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.pdef]
    mov       al,	[rax+112]
    mov       r10,	[rip+pc_decls.pinfo]
    mov       [r10+1],	al
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.pdef]
    mov       ax,	[rax+114]
    mov       r10,	[rip+pc_decls.pinfo]
    mov       [r10+2],	al
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.pdef]
    movzx     rax,	byte ptr[rax+112]
    add       [rbp + pc_reduce.pcl_reducetest.nallparams],	rax
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.pdef]
    movsx     rax,	word ptr[rax+114]
    add       [rbp + pc_reduce.pcl_reducetest.nalllocals],	rax
    xor       eax,	eax
    mov       [rbp + pc_reduce.pcl_reducetest.ncall],	rax
    lea       rax,	[r14+32]
    mov       [rbp + pc_reduce.pcl_reducetest.pcproc],	rax
    jmp       L1309
    jmp       L1297
L1301:
    xor       eax,	eax
    mov       r10,	[rip+pc_decls.pinfo]
    mov       [r10+3],	al
    dec       qword ptr[rbp + pc_reduce.pcl_reducetest.ncall]
    jmp       L1309
    jmp       L1297
L1302:
    add       r14,	32
    mov       rax,	r13
    mov       r10,	[rax]
    mov       [r14],	r10
    mov       r10,	[rax+8]
    mov       [r14+8],	r10
    mov       r10,	[rax+16]
    mov       [r14+16],	r10
    mov       r10,	[rax+24]
    mov       [r14+24],	r10
    inc       rbx
    mov       rax,	rbx
    lea       r10,	[r14+28]
    mov       r8d,	[r10]
    mov       r11,	-4294967041
    shl       eax,	8
    and       r8d,	r11d
    or        r8d,	eax
    mov       [r10],	r8d
    inc       qword ptr[rbp + pc_reduce.pcl_reducetest.ncall]
    mov       rax,	[rbp + pc_reduce.pcl_reducetest.ncall]
    mov       r10,	r14
    mov       [rbp + rax*8 + pc_reduce.pcl_reducetest.callstack-8],	r10
    jmp       L1297
L1303:
    mov       rax,	[rip+pc_decls.pinfo]
    mov       al,	[rax+3]
    test      al,	al
    jz        L1313
    inc       qword ptr[rbp + pc_reduce.pcl_reducetest.nleaf]
L1313:
    xor       eax,	eax
    mov       [rip+pc_decls.pinfo],	rax
    jmp       L1309
    jmp       L1297
L1304:
    mov       al,	1
    mov       r10,	[rip+pc_decls.pinfo]
    mov       [r10+5],	al
    jmp       L1309
    jmp       L1297
L1305:
    movzx     rax,	byte ptr[r14]
    cmp       rax,	57
    jnz       L1315
    movzx     rax,	byte ptr[r13+3]
    cmp       rax,	11
    jz        L1315
    mov       al,	[r13+3]
    mov       [r14+3],	al
    movzx     rax,	byte ptr[r13]
    cmp       rax,	2
    jnz       L1317
    mov       rax,	3
    jmp       L1316
L1317:
    mov       rax,	6
L1316:
    mov       [r14],	al
    jmp       L1314
L1315:
    jmp       L1309
L1314:
    jmp       L1297
L1306:
    movzx     rax,	byte ptr[r15]
    cmp       rax,	113
    jnz       L1319
    movsxd    rax,	dword ptr[r13+28]
    and       rax,	255
    movsxd    r10,	dword ptr[r15+28]
    and       r10,	255
    cmp       rax,	r10
    jnz       L1319
    add       r13,	32
    jmp       L1318
L1319:
    movzx     rax,	byte ptr[r15]
    cmp       rax,	28
    jz        L1321
    cmp       rax,	27
    jnz       L1320
L1321:
    movsxd    rax,	dword ptr[r13+28]
    and       rax,	255
    mov       [r15+3],	al
    jmp       L1318
L1320:
    jmp       L1309
L1318:
    jmp       L1297
L1307:
    movzx     rax,	byte ptr[r14]
    cmp       rax,	1
    jz        L1324
    cmp       rax,	2
    jz        L1324
    cmp       rax,	3
    jnz       L1323
L1324:
    movzx     rax,	byte ptr[r14+3]
    movsxd    r10,	dword ptr[r13+28]
    and       r10,	255
    cmp       rax,	r10
    jz        L1322
L1323:
    jmp       L1309
L1322:
    jmp       L1297
L1308:
    movzx     rax,	byte ptr[r13+1]
    cmp       rax,	4
    jnz       L1326
    movzx     rax,	byte ptr[r15]
    movzx     r10,	byte ptr[r14]
    cmp       r10,	rax
    jnz       L1327
    cmp       r10,	57
    jnz       L1327
    mov       rax,	1
    jmp       L1328
L1327:
    xor       eax,	eax
L1328:
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    test      ax,	ax
    jz        L1326
    mov       rax,	[r13+8]
    movsxd    r10,	dword ptr[r15+16]
    imul      rax,	r10
    movsxd    r10,	dword ptr[r15+20]
    add       rax,	r10
    lea       r10,	[r14+20]
    add       [r10],	eax
    add       r13,	32
    jmp       L1325
L1326:
    movzx     rax,	byte ptr[r15]
    cmp       rax,	11
    jnz       L1329
    add       r13,	32
    jmp       L1325
L1329:
    jmp       L1309
L1325:
    jmp       L1297
L1309:
    add       r14,	32
    mov       rax,	r13
    mov       r10,	[rax]
    mov       [r14],	r10
    mov       r10,	[rax+8]
    mov       [r14+8],	r10
    mov       r10,	[rax+16]
    mov       [r14+16],	r10
    mov       r10,	[rax+24]
    mov       [r14+24],	r10
    inc       rbx
    mov       rax,	rbx
    lea       r10,	[r14+28]
    mov       r8d,	[r10]
    mov       r11,	-4294967041
    shl       eax,	8
    and       r8d,	r11d
    or        r8d,	eax
    mov       [r10],	r8d
    movzx     rax,	byte ptr[r14+1]
    cmp       rax,	2
    jnz       L1331
    movzx     rax,	byte ptr[r14]
    cmp       rax,	1
    jnz       L1334
    mov       eax,	[r14+16]
    test      eax,	eax
    jnz       L1333
L1334:
    mov       rax,	[r14+8]
    mov       r10b,	1
    mov       [rax+88],	r10b
L1333:
L1331:
L1297:
    add       r13,	32
    dec       qword ptr[rbp + pc_reduce.pcl_reducetest.av_1]
    jnz       L1288
L1290:
    mov       [rip+pc_api.pccurr],	r14
    mov       rcx,	[rbp + pc_reduce.pcl_reducetest.labelmap]
    mov       rdx,	[rip+pc_api.mlabelno]
    call      mlib.pcm_free
#---------------
    add       rsp,	360
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_run.dispatch_loop
pc_run.dispatch_loop:
#PROC1
#PROC2
#?>>
    .set pc_run.dispatch_loop.pcentry, 72
    .set pc_run.dispatch_loop.cmain, 80
    .set pc_run.dispatch_loop.a, -8
    .set pc_run.dispatch_loop.ptrb, -16
    .set pc_run.dispatch_loop.n, -24
    .set pc_run.dispatch_loop.d, -32
    .set pc_run.dispatch_loop.callstack, -40032
    .set pc_run.dispatch_loop.callstackst, -120032
    .set pc_run.dispatch_loop.callsp, -120040
    .set pc_run.dispatch_loop.str, -120296
    .set pc_run.dispatch_loop.oldsp, -120304
    .set pc_run.dispatch_loop.ncmd, -120312
    .set pc_run.dispatch_loop.cmd, -120320
    .set pc_run.dispatch_loop.lastpos, -120328
    .set pc_run.dispatch_loop.count, -120336
    .set pc_run.dispatch_loop.av_1, -120344
    .set pc_run.dispatch_loop.av_2, -120352
    .set pc_run.dispatch_loop.$T1, -120360
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	120392
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
#---------------
#PROC3
#PROC4
    mov       rbx,	[rbp + pc_run.dispatch_loop.pcentry]
    xor       rsi,	rsi
    xor       eax,	eax
    mov       r12,	rax
    xor       eax,	eax
    mov       [rbp + pc_run.dispatch_loop.callsp],	rax
    mov       rcx,	560000
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.cmain]
    test      rax,	rax
    jz        L1337
    mov       rax,	[rip+msys.ncmdparams]
    mov       [rbp + pc_run.dispatch_loop.ncmd],	rax
    mov       rax,	[rip+msys.cmdparams]
    mov       [rbp + pc_run.dispatch_loop.cmd],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.ncmd]
    sub       rax,	[rip+pc_decls.pcmdskip]
    mov       [rbp + pc_run.dispatch_loop.ncmd],	rax
    mov       rax,	[rip+pc_decls.pcmdskip]
    shl       rax,	3
    mov       r10,	[rbp + pc_run.dispatch_loop.cmd]
    lea       r10,	[r10 + rax]
    mov       [rbp + pc_run.dispatch_loop.cmd],	r10
    inc       rsi
    mov       rax,	rsi
    mov       r10,	[rbp + pc_run.dispatch_loop.cmd]
    mov       [rdi + rax*8-8],	r10
    mov       rax,	[rbp + pc_run.dispatch_loop.ncmd]
    inc       rax
    inc       rsi
    mov       r10,	rsi
    mov       [rdi + r10*8-8],	rax
    inc       rsi
    mov       rax,	rsi
    xor       r10d,	r10d
    mov       [rdi + rax*8-8],	r10
L1337:
    xor       eax,	eax
    mov       [rbp + pc_run.dispatch_loop.lastpos],	rax
    xor       eax,	eax
    mov       [rbp + pc_run.dispatch_loop.count],	rax
    mov       rax,	[rip+pc_run.dotrace]
    test      rax,	rax
    jz        L1339
    lea       rax,	[rip+L10515]
    lea       r10,	[rip+pc_run.emptyst]
    mov       [r10],	rax
L1339:
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1342:
    .quad     L1344
    .quad     L1345
    .quad     L1348
    .quad     L1349
    .quad     L1350
    .quad     L1357
    .quad     L1358
    .quad     L1343
    .quad     L1359
    .quad     L1359
    .quad     L1360
    .quad     L1361
    .quad     L1362
    .quad     L1364
    .quad     L1365
    .quad     L1366
    .quad     L1367
    .quad     L1370
    .quad     L1371
    .quad     L1396
    .quad     L1386
    .quad     L1371
    .quad     L1404
    .quad     L1391
    .quad     L1409
    .quad     L1410
    .quad     L1411
    .quad     L1419
    .quad     L1422
    .quad     L1425
    .quad     L1426
    .quad     L1427
    .quad     L1434
    .quad     L1435
    .quad     L1438
    .quad     L1441
    .quad     L1444
    .quad     L1447
    .quad     L1447
    .quad     L1450
    .quad     L1451
    .quad     L1452
    .quad     L1453
    .quad     L1454
    .quad     L1457
    .quad     L1460
    .quad     L1463
    .quad     L1464
    .quad     L1467
    .quad     L1470
    .quad     L1471
    .quad     L1472
    .quad     L1473
    .quad     L1474
    .quad     L1475
    .quad     L1478
    .quad     L1482
    .quad     L1486
    .quad     L1487
    .quad     L1488
    .quad     L1489
    .quad     L1492
    .quad     L1495
    .quad     L1496
    .quad     L1497
    .quad     L1498
    .quad     L1499
    .quad     L1502
    .quad     L1503
    .quad     L1504
    .quad     L1505
    .quad     L1506
    .quad     L1507
    .quad     L1508
    .quad     L1509
    .quad     L1510
    .quad     L1511
    .quad     L1512
    .quad     L1513
    .quad     L1514
    .quad     L1515
    .quad     L1516
    .quad     L1517
    .quad     L1520
    .quad     L1521
    .quad     L1522
    .quad     L1523
    .quad     L1524
    .quad     L1525
    .quad     L1526
    .quad     L1527
    .quad     L1530
    .quad     L1533
    .quad     L1536
    .quad     L1536
    .quad     L1539
    .quad     L1540
    .quad     L1541
    .quad     L1542
    .quad     L1543
    .quad     L1544
    .quad     L1547
    .quad     L1551
    .quad     L1555
    .quad     L1556
    .quad     L1557
    .quad     L1558
    .quad     L1559
    .quad     L1560
    .quad     L1561
    .quad     L1562
    .quad     L1563
    .quad     L1566
    .quad     L1567
    .quad     L1568
    .quad     L1569
    .quad     L1570
    .quad     L1571
    .quad     L1572
    .quad     L1573
    .quad     L1574
    .quad     L1580
    .quad     L1581
    .quad     L1582
    .quad     L1583
    .quad     L1584
    .quad     L1595
    .quad     L1585
    .quad     L1586
    .quad     L1587
    .quad     L1588
    .quad     L1589
    .quad     L1590
    .quad     L1591
    .quad     L1592
    .quad     L1593
    .quad     L1594
L1344:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1345:
    movzx     rax,	byte ptr[rbx+1]
    cmp       rax,	4
    jnz       L1347
    mov       rax,	[rbx+8]
    inc       rsi
    mov       r10,	rsi
    mov       [rdi + r10*8-8],	rax
    jmp       L1346
L1347:
    lea       rax,	[rdi + r12*8-8]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      pc_runaux.pci_getopnd
    inc       rsi
    mov       r10,	rsi
    mov       [rdi + r10*8-8],	rax
L1346:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1348:
    movzx     rax,	byte ptr[rbx+3]
    mov       r10,	[rdi + rsi*8-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1349:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-8]
    movsxd    r10,	dword ptr[rbx+16]
    mov       r11,	[rbp + pc_run.dispatch_loop.a]
    imul      r11,	r10
    lea       rax,	[rax + r11]
    movsxd    r10,	dword ptr[rbx+20]
    lea       rax,	[rax + r10]
    mov       r13,	rax
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1350:
    movzx     rax,	byte ptr[rbx+1]
    cmp       rax,	1
    jnz       L1353
L1352:
    mov       rax,	[rbx+8]
    mov       [rbp + pc_run.dispatch_loop.d],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movzx     rax,	byte ptr[rax+72]
    cmp       rax,	3
    jnz       L1355
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       r13,	[rax+56]
    jmp       L1354
L1355:
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	11
    jnz       L1356
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movzx     rax,	byte ptr[rax+72]
    cmp       rax,	5
    jnz       L1356
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movsxd    rax,	dword ptr[rax+76]
    mov       r10,	r12
    add       r10,	rax
    mov       r10,	[rdi + r10*8-8]
    mov       r13,	r10
    jmp       L1354
L1356:
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    movsxd    rax,	dword ptr[rax+76]
    mov       r10,	r12
    add       r10,	rax
    lea       rax,	[rdi + r10*8-8]
    mov       r13,	rax
L1354:
    mov       eax,	[rbx+4]
    movzx     r10,	byte ptr[rbx+3]
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r13
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      pc_runaux.pci_storeptr
    jmp       L1351
L1353:
    mov       rcx,	rbx
    call      pc_runaux.pcusopnd
L1351:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1357:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       eax,	[rbx+4]
    movzx     r10,	byte ptr[rbx+3]
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r13
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1358:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    movsxd    r10,	dword ptr[rbx+16]
    mov       r11,	[rbp + pc_run.dispatch_loop.a]
    imul      r11,	r10
    lea       rax,	[rax + r11]
    movsxd    r10,	dword ptr[rbx+20]
    lea       rax,	[rax + r10]
    mov       r13,	rax
    mov       eax,	[rbx+4]
    movzx     r10,	byte ptr[rbx+3]
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r13
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1359:
    mov       rax,	[rdi + rsi*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    inc       rsi
    mov       rax,	rsi
    mov       r10,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rax*8-8],	r10
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1360:
    movsxd    rax,	dword ptr[rbx+16]
    dec       rax
    mov       r10,	rsi
    sub       r10,	rax
    lea       rax,	[rdi + r10*8-8]
    movsxd    r10,	dword ptr[rbx+20]
    dec       r10
    mov       r11,	rsi
    sub       r11,	r10
    lea       r10,	[rdi + r11*8-8]
    mov       r11,	[rax]
    mov       r15,	[r10]
    mov       [r10],	r11
    mov       [rax],	r15
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1361:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1362:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1364:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1365:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    mov       cl,	r10b
    shr       rax,	cl
    and       eax,	1
    mov       [rdi + rsi*8-16],	rax
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1366:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    mov       r11,	[rdi + rsi*8-24]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.pci_loadbf
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	2
    sub       rsi,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1367:
    mov       r13,	[rdi + rsi*8-16]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-24]
    test      rax,	rax
    jz        L1369
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	1
    mov       rcx,	rax
    shl       r10,	cl
    or        [rbp + pc_run.dispatch_loop.a],	r10
    jmp       L1368
L1369:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	1
    mov       rcx,	rax
    shl       r10,	cl
    not       r10
    and       [rbp + pc_run.dispatch_loop.a],	r10
L1368:
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    mov       rax,	3
    sub       rsi,	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1370:
    mov       r13,	[rdi + rsi*8-24]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-32]
    mov       r10,	[rdi + rsi*8-8]
    mov       r11,	[rdi + rsi*8-16]
    mov       rcx,	[rbp + pc_run.dispatch_loop.a]
    mov       rdx,	r11
    mov       r8,	r10
    mov       r9,	rax
    call      pc_runaux.pci_storebf
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    mov       rax,	4
    sub       rsi,	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1371:
    mov       rax,	[rbx+8]
    mov       [rbp + pc_run.dispatch_loop.d],	rax
    mov       rax,	[rip+pc_run.dotrace]
    test      rax,	rax
    jz        L1373
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + pc_run.dispatch_loop.av_1],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.av_1]
    cmp       rax,	0
    jle       L1376
L1374:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10516]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    dec       qword ptr[rbp + pc_run.dispatch_loop.av_1]
    jnz       L1374
L1376:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10517]
    call      msys.m$print_setfmt
    inc       qword ptr[rip+pc_run.seqno]
    mov       rcx,	[rip+pc_run.seqno]
    call      msys.m$print_i64_nf
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      pc_run.getlineno
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1373:
    cmp       rsi,	69900
    jle       L1378
    mov       rcx,	rbx
    lea       rdx,	[rip+L10518]
    lea       r8,	[rip+L10519]
    call      pc_runaux.pcerrorx
L1378:
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       al,	[rax+80]
    test      al,	al
    jz        L1380
    movsxd    rax,	dword ptr[rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    dec       rax
    sub       rsi,	rax
    movzx     rax,	byte ptr[rbx+3]
    push      rax
    movsxd    rax,	dword ptr[rbx+20]
    push      rax
    lea       rax,	[rdi + rsi*8-8]
    mov       rcx,	[rbp + pc_run.dispatch_loop.d]
    xor       edx,	edx
    mov       r8,	rax
    mov       r9,	[rbp + pc_run.dispatch_loop.n]
    sub       rsp,	32
    call      pc_runaux.docalldll
    add       rsp,	48
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	18
    jnz       L1382
    dec       rsi
    jmp       L1381
L1382:
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rsi*8-8],	rax
L1381:
    add       rbx,	32
    jmp       L1379
L1380:
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       rax,	[rax+56]
    test      rax,	rax
    jnz       L1383
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       rax,	[rax]
    mov       rcx,	rbx
    lea       rdx,	[rip+L10520]
    mov       r8,	rax
    call      pc_runaux.pcerrorx
    jmp       L1379
L1383:
    movsxd    rax,	dword ptr[rbx+16]
    mov       r10,	rsi
    sub       r10,	rax
    mov       [rbp + pc_run.dispatch_loop.$T1],	r10
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	21
    jnz       L1385
    mov       rax,	1
    jmp       L1384
L1385:
    xor       eax,	eax
L1384:
    mov       r10,	[rbp + pc_run.dispatch_loop.$T1]
    add       r10,	rax
    inc       qword ptr[rbp + pc_run.dispatch_loop.callsp]
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + rax*4 + pc_run.dispatch_loop.callstack-4],	r10d
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       r10,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.callstackst-8],	rax
    lea       rax,	[rbx+32]
    movsxd    r10,	dword ptr[rbx+16]
    or        rax,	r10
    inc       rsi
    mov       r10,	rsi
    mov       [rdi + r10*8-8],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.d]
    mov       rbx,	[rax+56]
L1379:
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1386:
    movsxd    rax,	dword ptr[rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    movsxd    rax,	dword ptr[rbx+20]
    sub       rsi,	rax
    mov       rax,	rsi
    dec       rsi
    mov       r12,	[rdi + rax*8-8]
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	r13
    and       rax,	15
    sub       rsi,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    cmp       rax,	1
    jge       L1388
    mov       rcx,	rbx
    lea       rdx,	[rip+L10521]
    lea       r8,	[rip+L10522]
    call      pc_runaux.pcerrorx
L1388:
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    dec       qword ptr[rbp + pc_run.dispatch_loop.callsp]
    mov       eax,	[rbp + rax*4 + pc_run.dispatch_loop.callstack-4]
    mov       [rbp + pc_run.dispatch_loop.oldsp],	rax
    cmp       rsi,	[rbp + pc_run.dispatch_loop.oldsp]
    jz        L1390
    lea       rcx,	[rbp + pc_run.dispatch_loop.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10523]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + pc_run.dispatch_loop.oldsp]
    call      msys.m$print_i64_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       rcx,	rbx
    lea       rdx,	[rbp + pc_run.dispatch_loop.str]
    lea       r8,	[rip+L10524]
    call      pc_runaux.pcerrorx
L1390:
    mov       rax,	r13
    and       rax,	-16
    mov       rbx,	rax
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1391:
    mov       rax,	[rdi + rsi*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movsxd    rax,	dword ptr[rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    movsxd    rax,	dword ptr[rbx+20]
    sub       rsi,	rax
    dec       rsi
    mov       rax,	rsi
    mov       r12,	[rdi + rax*8-8]
    dec       rsi
    mov       rax,	rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	r13
    and       rax,	15
    sub       rsi,	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rsi*8-8],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    cmp       rax,	1
    jge       L1393
    mov       rcx,	rbx
    lea       rdx,	[rip+L10525]
    lea       r8,	[rip+L10526]
    call      pc_runaux.pcerrorx
L1393:
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    dec       qword ptr[rbp + pc_run.dispatch_loop.callsp]
    mov       eax,	[rbp + rax*4 + pc_run.dispatch_loop.callstack-4]
    mov       [rbp + pc_run.dispatch_loop.oldsp],	rax
    cmp       rsi,	[rbp + pc_run.dispatch_loop.oldsp]
    jz        L1395
    lea       rcx,	[rbp + pc_run.dispatch_loop.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10527]
    call      msys.m$print_setfmt
    mov       rcx,	[rbp + pc_run.dispatch_loop.oldsp]
    call      msys.m$print_i64_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       rcx,	rbx
    lea       rdx,	[rbp + pc_run.dispatch_loop.str]
    lea       r8,	[rip+L10528]
    call      pc_runaux.pcerrorx
L1395:
    mov       rax,	r13
    and       rax,	-16
    mov       rbx,	rax
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1396:
    mov       r13,	[rdi + rsi*8-8]
    test      r13,	r13
    jnz       L1398
    mov       rcx,	rbx
    lea       rdx,	[rip+L10529]
    lea       r8,	[rip+L10530]
    call      pc_runaux.pcerrorx
L1398:
    cmp       r13,	[rip+pc_api.pcstart]
    jb        L1400
    cmp       r13,	[rip+pc_api.pccurr]
    ja        L1400
#pc_run.dispatch_loop.icallp:
L1401:
    lea       rax,	[rsi-1]
    movsxd    r10,	dword ptr[rbx+16]
    sub       rax,	r10
    mov       [rbp + pc_run.dispatch_loop.$T1],	rax
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	22
    jnz       L1403
    mov       rax,	1
    jmp       L1402
L1403:
    xor       eax,	eax
L1402:
    mov       r10,	[rbp + pc_run.dispatch_loop.$T1]
    add       r10,	rax
    inc       qword ptr[rbp + pc_run.dispatch_loop.callsp]
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + rax*4 + pc_run.dispatch_loop.callstack-4],	r10d
    lea       rax,	[rip+pc_run.emptyst]
    mov       r10,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + r10*8 + pc_run.dispatch_loop.callstackst-8],	rax
    lea       rax,	[rbx+32]
    movsxd    r10,	dword ptr[rbx+16]
    or        rax,	r10
    mov       [rdi + rsi*8-8],	rax
    mov       rbx,	r13
    jmp       L1399
L1400:
    movsxd    rax,	dword ptr[rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    dec       rsi
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    dec       rax
    sub       rsi,	rax
    movzx     rax,	byte ptr[rbx+3]
    push      rax
    movsxd    rax,	dword ptr[rbx+20]
    push      rax
    lea       rax,	[rdi + rsi*8-8]
    xor       ecx,	ecx
    mov       rdx,	r13
    mov       r8,	rax
    mov       r9,	[rbp + pc_run.dispatch_loop.n]
    sub       rsp,	32
    call      pc_runaux.docalldll
    add       rsp,	48
    dec       rsi
    add       rbx,	32
L1399:
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1404:
    mov       r13,	[rdi + rsi*8-8]
    test      r13,	r13
    jnz       L1406
    mov       rcx,	rbx
    lea       rdx,	[rip+L10531]
    lea       r8,	[rip+L10532]
    call      pc_runaux.pcerrorx
L1406:
    cmp       r13,	[rip+pc_api.pcstart]
    jb        L1408
    cmp       r13,	[rip+pc_api.pccurr]
    jbe       L1401
L1408:
    movsxd    rax,	dword ptr[rbx+16]
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    dec       rsi
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    dec       rax
    sub       rsi,	rax
    movzx     rax,	byte ptr[rbx+3]
    push      rax
    movsxd    rax,	dword ptr[rbx+20]
    push      rax
    lea       rax,	[rdi + rsi*8-8]
    xor       ecx,	ecx
    mov       rdx,	r13
    mov       r8,	rax
    mov       r9,	[rbp + pc_run.dispatch_loop.n]
    sub       rsp,	32
    call      pc_runaux.docalldll
    add       rsp,	48
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
L1407:
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1409:
    mov       rax,	[rbx+8]
    mov       r10,	[rip+pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1410:
    mov       rax,	rsi
    dec       rsi
    mov       rbx,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1411:
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1413
    movq      XMM4,	[rdi + rsi*8-8]
    movq      XMM5,	[rdi + rsi*8-16]
    movzx     rax,	byte ptr[rbx+2]
    mov       rcx,	rax
    movq      XMM1,	XMM5
    movq      XMM2,	XMM4
    call      pc_runaux.cmpreal
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    jmp       L1412
L1413:
    movzx     rax,	byte ptr[rbx+3]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1414
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    movzx     r11,	byte ptr[rbx+2]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.cmpint
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    jmp       L1412
L1414:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    movzx     r11,	byte ptr[rbx+2]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.cmpword
    mov       [rbp + pc_run.dispatch_loop.n],	rax
L1412:
    mov       eax,	[rbx+16]
    test      eax,	eax
    jz        L1416
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    test      rax,	rax
    jnz       L1416
    dec       rsi
    jmp       L1415
L1416:
    mov       rax,	2
    sub       rsi,	rax
L1415:
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    test      rax,	rax
    jz        L1418
    mov       rax,	[rbx+8]
    mov       r10,	[rip+pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1417
L1418:
    add       rbx,	32
L1417:
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1419:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    test      rax,	rax
    jz        L1421
    mov       rax,	[rbx+8]
    mov       r10,	[rip+pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1420
L1421:
    add       rbx,	32
L1420:
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1422:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    test      rax,	rax
    jnz       L1424
    mov       rax,	[rbx+8]
    mov       r10,	[rip+pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1423
L1424:
    add       rbx,	32
L1423:
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1425:
    mov       rax,	[rbx+8]
    mov       r10,	[rip+pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1426:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1427:
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jz        L1429
    cmp       rax,	1
    jz        L1430
    jmp       L1431
L1429:
    mov       rcx,	rbx
    lea       rdx,	[rip+L10533]
    lea       r8,	[rip+L10534]
    call      pc_runaux.pcerrorx
    jmp       L1428
L1430:
    mov       rcx,	rbx
    lea       rdx,	[rip+L10535]
    lea       r8,	[rip+L10536]
    call      pc_runaux.pcerrorx
    jmp       L1428
L1431:
    movzx     rax,	byte ptr[rbx+3]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1433
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    movzx     r11,	byte ptr[rbx+2]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.cmpint
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    jmp       L1432
L1433:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rdi + rsi*8-16]
    movzx     r11,	byte ptr[rbx+2]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.cmpword
    mov       [rbp + pc_run.dispatch_loop.n],	rax
L1432:
L1428:
    dec       rsi
    mov       rax,	[rbp + pc_run.dispatch_loop.n]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1434:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    jmp       L1335
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1435:
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+32]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopndaddr
    mov       r13,	rax
    mov       rax,	r13
    dec       qword ptr[rax]
    mov       rax,	[r13]
    test      rax,	rax
    jz        L1437
    mov       rax,	[rbx+8]
    mov       r10,	[rip+pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1436
L1437:
    add       rbx,	64
L1436:
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1438:
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+32]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopndaddr
    mov       r13,	rax
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+64]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopnd
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    movsxd    rax,	dword ptr[rbx+16]
    mov       r10,	r13
    add       [r10],	rax
    mov       rax,	[r13]
    cmp       rax,	[rbp + pc_run.dispatch_loop.n]
    jg        L1440
    mov       rax,	[rbx+8]
    mov       r10,	[rip+pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1439
L1440:
    add       rbx,	96
L1439:
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1441:
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+32]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopndaddr
    mov       r13,	rax
    lea       rax,	[rdi + r12*8-8]
    lea       r10,	[rbx+64]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_getopnd
    mov       [rbp + pc_run.dispatch_loop.n],	rax
    movsxd    rax,	dword ptr[rbx+16]
    mov       r10,	r13
    sub       [r10],	rax
    mov       rax,	[r13]
    cmp       rax,	[rbp + pc_run.dispatch_loop.n]
    jl        L1443
    mov       rax,	[rbx+8]
    mov       r10,	[rip+pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1442
L1443:
    add       rbx,	96
L1442:
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1444:
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	11
    jnz       L1446
    mov       rcx,	rbx
    lea       rdx,	[rip+L10537]
    lea       r8,	[rip+L10538]
    call      pc_runaux.pcerrorx
L1446:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.ptrb],	rax
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptrb]
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       r14,	rax
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	r14
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	[rbp + pc_run.dispatch_loop.ptrb]
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1447:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movsxd    rax,	dword ptr[rbx+16]
    mov       r10,	[rbp + pc_run.dispatch_loop.a]
    cmp       r10,	rax
    jl        L1449
    movsxd    rax,	dword ptr[rbx+20]
    cmp       r10,	rax
    jg        L1449
    mov       rax,	[rbx+8]
    mov       r10,	[rip+pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    lea       r10,	[r10+32]
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    shl       rax,	5
    lea       r10,	[r10 + rax]
    movsxd    rax,	dword ptr[rbx+16]
    shl       rax,	5
    sub       r10,	rax
    mov       rbx,	r10
    mov       rax,	[rbx+8]
    mov       r10,	[rip+pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
    jmp       L1448
L1449:
    lea       rax,	[rbx+32]
    mov       rax,	[rax+8]
    mov       r10,	[rip+pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rbx,	r10
L1448:
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1450:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1451:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1452:
    mov       eax,	[rbx+4]
    mov       r10,	rsi
    dec       rsi
    mov       r10,	[rdi + r10*8-8]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	rax
    call      memset
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1453:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1454:
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1456
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM5,	[rax]
    addsd     XMM5,	XMM4
    movq      [rax],	XMM5
    jmp       L1455
L1456:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    add       [r10],	rax
L1455:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1457:
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1459
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM5,	[rax]
    subsd     XMM5,	XMM4
    movq      [rax],	XMM5
    jmp       L1458
L1459:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    sub       [r10],	rax
L1458:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1460:
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1462
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM5,	[rax]
    mulsd     XMM5,	XMM4
    movq      [rax],	XMM5
    jmp       L1461
L1462:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    mov       r11,	[r10]
    imul      r11,	rax
    mov       [r10],	r11
L1461:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1463:
    movq      XMM4,	[rdi + rsi*8-16]
    movq      XMM5,	[rdi + rsi*8-8]
    divsd     XMM4,	XMM5
    movq      [rdi + rsi*8-16],	XMM4
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1464:
    movzx     rax,	byte ptr[rbx+3]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1466
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    cqo       
    idiv      r10
    mov       [rdi + rsi*8-16],	rax
    jmp       L1465
L1466:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    xor       edx,	edx
    div       r10
    mov       [rdi + rsi*8-16],	rax
L1465:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1467:
    movzx     rax,	byte ptr[rbx+3]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1469
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       [rdi + rsi*8-16],	rax
    jmp       L1468
L1469:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    xor       edx,	edx
    div       r10
    xchg      rax,	rdx
    mov       [rdi + rsi*8-16],	rax
L1468:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1470:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1471:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    and       [r10],	rax
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1472:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    or        [r10],	rax
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1473:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    xor       [r10],	rax
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1474:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    mov       cl,	al
    shl       qword ptr[r10],	cl
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1475:
    movzx     rax,	byte ptr[rbx+3]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1477
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    mov       cl,	al
    sar       qword ptr[r10],	cl
    jmp       L1476
L1477:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    mov       cl,	al
    shr       qword ptr[r10],	cl
L1476:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1478:
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1480
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM0,	[rax]
    comisd    XMM0,	XMM4
    jbe       L10539
    movq      [rax],	XMM4
L10539:
    jmp       L1479
L1480:
    movzx     rax,	byte ptr[rbx+3]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1481
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    cmp       [r10],	rax
    jle       L10540
    mov       [r10],	rax
L10540:
    jmp       L1479
L1481:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    cmp       [r10],	rax
    jbe       L10541
    mov       [r10],	rax
L10541:
L1479:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1482:
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1484
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-16]
    movq      XMM0,	[rax]
    comisd    XMM0,	XMM4
    jae       L10542
    movq      [rax],	XMM4
L10542:
    jmp       L1483
L1484:
    movzx     rax,	byte ptr[rbx+3]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1485
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    cmp       [r10],	rax
    jge       L10543
    mov       [r10],	rax
L10543:
    jmp       L1483
L1485:
    mov       rax,	[rdi + rsi*8-8]
    lea       r10,	[rdi + rsi*8-16]
    cmp       [r10],	rax
    jae       L10544
    mov       [r10],	rax
L10544:
L1483:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1486:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-8]
    movsxd    r10,	dword ptr[rbx+16]
    mov       r11,	[rbp + pc_run.dispatch_loop.a]
    imul      r11,	r10
    lea       rax,	[rax + r11]
    movsxd    r10,	dword ptr[rbx+20]
    lea       rax,	[rax + r10]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1487:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	[rdi + rsi*8-8]
    movsxd    r10,	dword ptr[rbx+16]
    mov       r11,	[rbp + pc_run.dispatch_loop.a]
    imul      r11,	r10
    sub       rax,	r11
    movsxd    r10,	dword ptr[rbx+20]
    lea       rax,	[rax + r10]
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1488:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    sub       rax,	r10
    movsxd    r10,	dword ptr[rbx+16]
    cqo       
    idiv      r10
    mov       [rdi + rsi*8-16],	rax
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1489:
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1491
    movq      XMM4,	[rdi + rsi*8-8]
    xorpd     XMM4,	[rip+L10545]
    movq      [rdi + rsi*8-8],	XMM4
    jmp       L1490
L1491:
    mov       rax,	[rdi + rsi*8-8]
    neg       rax
    mov       [rdi + rsi*8-8],	rax
L1490:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1492:
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1494
    movq      XMM4,	[rdi + rsi*8-8]
    andpd     XMM4,	[rip+L10546]
    movq      [rdi + rsi*8-8],	XMM4
    jmp       L1493
L1494:
    mov       rax,	[rdi + rsi*8-8]
    cmp       rax,	0
    jge       L10547
    neg       rax
L10547:
    mov       [rdi + rsi*8-8],	rax
L1493:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1495:
    mov       rax,	[rdi + rsi*8-8]
    not       rax
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1496:
    mov       rax,	[rdi + rsi*8-8]
    xor       rax,	1
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1497:
    mov       rax,	[rdi + rsi*8-8]
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1498:
    mov       rax,	[rdi + rsi*8-8]
    test      rax,	rax
    setz      al
    movzx     eax,	al
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1499:
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1501
    movq      XMM4,	[rdi + rsi*8-8]
    lea       rax,	[rdi + rsi*8-8]
    movq      XMM5,	[rax]
    mulsd     XMM5,	XMM4
    movq      [rax],	XMM5
    jmp       L1500
L1501:
    mov       rax,	[rdi + rsi*8-8]
    imul      rax,	rax
    mov       [rdi + rsi*8-8],	rax
L1500:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1502:
    movq      XMM4,	[rdi + rsi*8-8]
    sqrtsd    XMM4,	XMM4
    movq      [rdi + rsi*8-8],	XMM4
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1503:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1504:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1505:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1506:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1507:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1508:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1509:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1510:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1511:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1512:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1513:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1514:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1515:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1516:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1517:
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1519
    movq      XMM4,	[rdi + rsi*8-16]
    movq      XMM5,	[rdi + rsi*8-8]
    movq      XMM0,	XMM4
    movq      XMM1,	XMM5
    call      pow
    movq      [rdi + rsi*8-16],	XMM0
    jmp       L1518
L1519:
    mov       rax,	[rdi + rsi*8-16]
    mov       r10,	[rdi + rsi*8-8]
    mov       rcx,	rax
    mov       rdx,	r10
    call      msys.m$power_i64
    mov       [rdi + rsi*8-16],	rax
L1518:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1520:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1521:
    movzx     rax,	byte ptr[rbx+3]
    movsxd    r10,	dword ptr[rbx+16]
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1522:
    movzx     rax,	byte ptr[rbx+3]
    movsxd    r10,	dword ptr[rbx+16]
    neg       r10
    mov       r11,	rsi
    dec       rsi
    mov       r11,	[rdi + r11*8-8]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1523:
    mov       r13,	[rdi + rsi*8-8]
    movzx     rax,	byte ptr[rbx+3]
    movsxd    r10,	dword ptr[rbx+16]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1524:
    mov       r13,	[rdi + rsi*8-8]
    movzx     rax,	byte ptr[rbx+3]
    movsxd    r10,	dword ptr[rbx+16]
    neg       r10
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1525:
    mov       r13,	[rdi + rsi*8-8]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    movzx     rax,	byte ptr[rbx+3]
    movsxd    r10,	dword ptr[rbx+16]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1526:
    mov       r13,	[rdi + rsi*8-8]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    movzx     rax,	byte ptr[rbx+3]
    movsxd    r10,	dword ptr[rbx+16]
    neg       r10
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      pc_runaux.doincr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1527:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1529
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    addsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1528
L1529:
    mov       rax,	r14
    add       [rbp + pc_run.dispatch_loop.a],	rax
L1528:
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1530:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1532
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    subsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1531
L1532:
    mov       rax,	r14
    sub       [rbp + pc_run.dispatch_loop.a],	rax
L1531:
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1533:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1535
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    mulsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1534
L1535:
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    imul      rax,	r14
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L1534:
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1536:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1538
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    divsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1537
L1538:
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       r10,	r14
    cqo       
    idiv      r10
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L1537:
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1539:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    mov       r10,	r14
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1540:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       rax,	r14
    and       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1541:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       rax,	r14
    or        [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1542:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       rax,	r14
    xor       [rbp + pc_run.dispatch_loop.a],	rax
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1543:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    mov       cl,	r14b
    shl       qword ptr[rbp + pc_run.dispatch_loop.a],	cl
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1544:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1546
    mov       cl,	r14b
    sar       qword ptr[rbp + pc_run.dispatch_loop.a],	cl
    jmp       L1545
L1546:
    mov       cl,	r14b
    shr       qword ptr[rbp + pc_run.dispatch_loop.a],	cl
L1545:
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1547:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1549
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    maxss     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1548
L1549:
    movzx     rax,	byte ptr[rbx+3]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1550
    mov       rax,	r14
    cmp       [rbp + pc_run.dispatch_loop.a],	rax
    jle       L10548
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L10548:
    jmp       L1548
L1550:
    mov       rax,	r14
    cmp       [rbp + pc_run.dispatch_loop.a],	rax
    jbe       L10549
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L10549:
L1548:
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1551:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r14,	[rdi + rax*8-8]
    movzx     rax,	byte ptr[rbx+3]
    cmp       rax,	2
    jg        L1553
    mov       rax,	[rbp + pc_run.dispatch_loop.a]
    movq      XMM4,	rax
    mov       rax,	r14
    movq      XMM5,	rax
    minsd     XMM4,	XMM5
    movq      rax,	XMM4
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    jmp       L1552
L1553:
    movzx     rax,	byte ptr[rbx+3]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1554
    mov       rax,	r14
    cmp       [rbp + pc_run.dispatch_loop.a],	rax
    jge       L10550
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L10550:
    jmp       L1552
L1554:
    mov       rax,	r14
    cmp       [rbp + pc_run.dispatch_loop.a],	rax
    jae       L10551
    mov       [rbp + pc_run.dispatch_loop.a],	rax
L10551:
L1552:
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	r13
    mov       rdx,	[rbp + pc_run.dispatch_loop.a]
    mov       r8,	rax
    xor       r9d,	r9d
    call      pc_runaux.pci_storeptr
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1555:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    movsxd    r10,	dword ptr[rbx+16]
    imul      rax,	r10
    mov       r10,	r13
    add       [r10],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1556:
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    movsxd    r10,	dword ptr[rbx+16]
    imul      rax,	r10
    mov       r10,	r13
    sub       [r10],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1557:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1558:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1559:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1560:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1561:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1562:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1563:
    movsxd    rax,	dword ptr[rbx+28]
    and       rax,	255
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1565
    mov       rax,	[rdi + rsi*8-8]
    cvtsi2sd  XMM4,	rax
    movq      [rdi + rsi*8-8],	XMM4
    jmp       L1564
L1565:
    mov       rax,	[rdi + rsi*8-8]
    cmp       rax,	0
    jl        L10552
    cvtsi2sd  XMM4,	rax
    jmp       L10553
L10552:
    and       rax,	[rip+L10554]
    cvtsi2sd  XMM4,	rax
    addsd     XMM4,	[rip+L10555]
L10553:
    movq      [rdi + rsi*8-8],	XMM4
L1564:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1566:
    movq      XMM4,	[rdi + rsi*8-8]
    cvttsd2si rax,	XMM4
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1567:
    movsxd    rax,	dword ptr[rbx+28]
    and       rax,	255
    lea       r10,	[rdi + rsi*8-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1568:
    movsxd    rax,	dword ptr[rbx+28]
    and       rax,	255
    lea       r10,	[rdi + rsi*8-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1569:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1570:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1571:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1572:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1573:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1574:
    inc       rsi
    mov       rax,	rsi
    mov       r10,	r12
    mov       [rdi + rax*8-8],	r10
    mov       r12,	rsi
    movsxd    rax,	dword ptr[rbx+20]
    add       rsi,	rax
    mov       rax,	[rip+pc_run.dotrace]
    test      rax,	rax
    jz        L1576
    mov       rax,	[rbp + pc_run.dispatch_loop.callsp]
    mov       [rbp + pc_run.dispatch_loop.av_2],	rax
    mov       rax,	[rbp + pc_run.dispatch_loop.av_2]
    cmp       rax,	0
    jle       L1579
L1577:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10556]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    dec       qword ptr[rbp + pc_run.dispatch_loop.av_2]
    jnz       L1577
L1579:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10557]
    call      msys.m$print_setfmt
    mov       rcx,	[rip+pc_run.seqno]
    call      msys.m$print_i64_nf
    mov       rax,	[rbx+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    mov       rcx,	r12
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1576:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1580:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1581:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1582:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1583:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1584:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1585:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1586:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1587:
    mov       r13,	[rdi + rsi*8-8]
    lea       rax,	[rbx+32]
    mov       [r13],	rax
    mov       [r13+8],	rsi
    mov       [r13+16],	r12
    xor       eax,	eax
    mov       [rdi + rsi*8-8],	rax
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1588:
    mov       rax,	rsi
    dec       rsi
    mov       rax,	[rdi + rax*8-8]
    mov       [rbp + pc_run.dispatch_loop.a],	rax
    mov       rax,	rsi
    dec       rsi
    mov       r13,	[rdi + rax*8-8]
    mov       rbx,	[r13]
    mov       rsi,	[r13+8]
    mov       r12,	[r13+16]
    inc       rsi
    mov       rax,	rsi
    mov       r10,	[rbp + pc_run.dispatch_loop.a]
    mov       [rdi + rax*8-8],	r10
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1589:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1590:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1591:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1592:
    dec       rsi
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1593:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1594:
    jmp       L1363
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1595:
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
L1343:
#pc_run.dispatch_loop.unimpl:
L1363:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10558]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rbx]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10559]
    call      msys.m$print_setfmt
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movsxd    rax,	dword ptr[rbx+28]
    shr       rax,	8
    and       rax,	16777215
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
    movzx     rax,	byte ptr[rbx]
    lea       r10,	[rip+L1342]
    jmp       [r10 + rax*8]
    xor       eax,	eax
L1335:
#---------------
    add       rsp,	120392
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_run.fixuppcl
pc_run.fixuppcl:
#PROC1
#PROC2
#?>>
    .set pc_run.fixuppcl.paramslots, -8
    .set pc_run.fixuppcl.localslots, -16
    .set pc_run.fixuppcl.a, -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_api.mlabelno]
    inc       rax
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rip+pc_run.labeltable],	rax
    mov       rdi,	[rip+pc_api.pcstart]
    jmp       L1600
L1597:
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	120
    jz        L1602
    cmp       rax,	121
    jnz       L1603
L1602:
    mov       rax,	[rdi+8]
    mov       r10,	rdi
    mov       [rax+56],	r10
L1603:
L1601:
    add       rdi,	32
L1600:
    cmp       rdi,	[rip+pc_api.pccurr]
    jbe       L1597
    mov       rdi,	[rip+pc_api.pcstart]
    jmp       L1607
L1604:
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	123
    jz        L1609
    cmp       rax,	124
    jnz       L1610
L1609:
    mov       rbx,	[rdi+8]
    mov       eax,	[rdi+4]
    mov       rcx,	rax
    call      mlib.pcm_allocz
    mov       [rbx+56],	rax
L1610:
L1608:
    add       rdi,	32
L1607:
    cmp       rdi,	[rip+pc_api.pccurr]
    jbe       L1604
    mov       rdi,	[rip+pc_api.pcstart]
    jmp       L1614
L1611:
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	123
    jz        L1616
    cmp       rax,	124
    jz        L1616
    cmp       rax,	125
    jz        L1617
    cmp       rax,	120
    jz        L1618
    cmp       rax,	127
    jz        L1619
    cmp       rax,	20
    jz        L1620
    cmp       rax,	23
    jz        L1620
    jmp       L1621
L1616:
    mov       rax,	[rdi+8]
    mov       r13,	[rax+56]
    jmp       L1615
L1617:
    movzx     rax,	byte ptr[rdi+3]
    cmp       rax,	11
    jz        L1623
    movzx     rax,	byte ptr[rdi+1]
    cmp       rax,	1
    jz        L1625
    cmp       rax,	2
    jz        L1626
    jmp       L1627
L1625:
    mov       rcx,	rdi
    lea       rdx,	[rip+L10560]
    lea       r8,	[rip+L10561]
    call      pc_runaux.pcerrorx
    jmp       L1624
L1626:
    mov       rbx,	[rdi+8]
    movzx     rax,	byte ptr[rbx+72]
    cmp       rax,	3
    jz        L1629
    cmp       rax,	2
    jz        L1630
    cmp       rax,	1
    jz        L1631
    jmp       L1632
L1629:
    mov       rax,	[rbx+56]
    mov       [rbp + pc_run.fixuppcl.a],	rax
    jmp       L1628
L1630:
    mov       rax,	[rbx+56]
    mov       [rbp + pc_run.fixuppcl.a],	rax
    jmp       L1628
L1631:
    mov       rcx,	rbx
    call      pc_runaux.getdllfnptr
    mov       [rbp + pc_run.fixuppcl.a],	rax
    jmp       L1628
L1632:
    mov       rcx,	rdi
    lea       rdx,	[rip+L10562]
    lea       r8,	[rip+L10563]
    call      pc_runaux.pcerrorx
L1628:
    mov       rax,	[rbp + pc_run.fixuppcl.a]
    test      rax,	rax
    jnz       L1634
    mov       rcx,	rdi
    lea       rdx,	[rip+L10564]
    lea       r8,	[rip+L10565]
    call      pc_runaux.pcerrorx
L1634:
    jmp       L1624
L1627:
    mov       rax,	[rdi+8]
    mov       [rbp + pc_run.fixuppcl.a],	rax
L1624:
    mov       eax,	[rdi+4]
    mov       rcx,	r13
    lea       rdx,	[rbp + pc_run.fixuppcl.a]
    mov       r8,	rax
    call      memcpy
    jmp       L1622
L1623:
    mov       eax,	[rdi+4]
    mov       r10,	[rdi+8]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      memcpy
L1622:
    mov       eax,	[rdi+4]
    add       r13,	rax
    jmp       L1615
L1618:
    mov       rax,	[rdi+8]
    mov       rbx,	rax
    mov       r12,	rax
    mov       rsi,	[rbx+16]
    xor       r14,	r14
    jmp       L1638
L1635:
    mov       rax,	8
    add       r14,	rax
    mov       rax,	r14
    sar       rax,	3
    inc       rax
    neg       rax
    mov       [rsi+76],	eax
    mov       rsi,	[rsi+16]
L1638:
    test      rsi,	rsi
    jnz       L1635
    mov       rsi,	[rbx+24]
    xor       r15,	r15
    jmp       L1642
L1639:
    mov       rax,	r15
    sar       rax,	3
    inc       rax
    mov       [rsi+76],	eax
    mov       eax,	[rsi+84]
    mov       rcx,	rax
    mov       rdx,	8
    call      mlib.roundtoblock
    add       r15,	rax
    mov       rsi,	[rsi+24]
L1642:
    test      rsi,	rsi
    jnz       L1639
    mov       rax,	r14
    sar       rax,	3
    mov       [rbp + pc_run.fixuppcl.paramslots],	rax
    mov       [rdi+16],	eax
    mov       rax,	r15
    sar       rax,	3
    mov       [rbp + pc_run.fixuppcl.localslots],	rax
    mov       [rdi+20],	eax
    jmp       L1615
L1619:
    mov       rax,	[rdi+8]
    mov       r10,	rdi
    mov       r11,	[rip+pc_run.labeltable]
    mov       [r11 + rax*8-8],	r10
    jmp       L1615
L1620:
    mov       eax,	[rbp + pc_run.fixuppcl.paramslots]
    mov       [rdi+16],	eax
    mov       eax,	[rbp + pc_run.fixuppcl.localslots]
    mov       [rdi+20],	eax
L1621:
L1615:
    add       rdi,	32
L1614:
    cmp       rdi,	[rip+pc_api.pccurr]
    jbe       L1611
#---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_run.pcl_runpcl
pc_run.pcl_runpcl:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      pc_runaux.loadlibs
    call      pc_run.fixuppcl
    mov       rax,	[rip+pc_decls.entryproc]
    test      rax,	rax
    jnz       L1645
    mov       rcx,	[rip+pc_api.pcstart]
    lea       rdx,	[rip+L10566]
    lea       r8,	[rip+L10567]
    call      pc_runaux.pcerrorx
L1645:
    call      pc_runaux.docmdskip
    mov       al,	[rip+pc_decls.pverbose]
    test      al,	al
    jz        L1647
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10568]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1647:
    mov       rax,	[rip+pc_decls.entryproc]
    movzx     rax,	byte ptr[rax+112]
    cmp       rax,	2
    setz      al
    movzx     eax,	al
    mov       r10,	[rip+pc_decls.entryproc]
    mov       r10,	[r10+56]
    mov       rcx,	r10
    mov       rdx,	rax
    call      pc_run.dispatch_loop
    mov       rdi,	rax
    mov       al,	[rip+pc_decls.pverbose]
    test      al,	al
    jz        L1649
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10569]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
L1649:
    mov       rcx,	rdi
    call      exit
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_run.getlineno
pc_run.getlineno:
#PROC1
#PROC2
#?>>
    .set pc_run.getlineno.filename, -8
    .set pc_run.getlineno.sourceline, -16
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_decls.igetmsourceinfo]
    test      rax,	rax
    jz        L1652
    mov       eax,	[rdi+24]
    mov       rcx,	rax
    lea       rdx,	[rbp + pc_run.getlineno.filename]
    lea       r8,	[rbp + pc_run.getlineno.sourceline]
    mov       r10,	[rip+pc_decls.igetmsourceinfo]
    call      r10
    jmp       L1651
L1652:
    xor       eax,	eax
L1651:
L1650:
#---------------
    add       rsp,	56
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc pc_runaux.pci_getopnd
pc_runaux.pci_getopnd:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[r12+1]
    cmp       rax,	4
    jz        L1655
    cmp       rax,	1
    jz        L1656
    cmp       rax,	2
    jz        L1657
    cmp       rax,	7
    jz        L1658
    cmp       rax,	5
    jz        L1659
    cmp       rax,	6
    jz        L1659
    cmp       rax,	3
    jz        L1660
    jmp       L1661
L1655:
    mov       rdi,	[r12+8]
    jmp       L1654
L1656:
    mov       rbx,	[r12+8]
    movzx     rax,	byte ptr[rbx+72]
    cmp       rax,	3
    jnz       L1664
L1663:
    mov       rsi,	[rbx+56]
    jmp       L1662
L1664:
    movsxd    rax,	dword ptr[rbx+76]
    lea       r10,	[r13 + rax*8]
    mov       rsi,	r10
    movzx     rax,	byte ptr[rbx+82]
    cmp       rax,	11
    jnz       L1666
    movzx     rax,	byte ptr[rbx+72]
    cmp       rax,	5
    jnz       L1666
    mov       rsi,	[rsi]
L1666:
L1662:
    movzx     rax,	byte ptr[r12+3]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      pc_runaux.pci_loadptr
    mov       rdi,	rax
    jmp       L1654
L1657:
    mov       rbx,	[r12+8]
    movzx     rax,	byte ptr[rbx+72]
    cmp       rax,	4
    jz        L1668
    cmp       rax,	5
    jz        L1669
    cmp       rax,	1
    jz        L1670
    jmp       L1671
L1668:
    movsxd    rax,	dword ptr[rbx+76]
    lea       r10,	[r13 + rax*8]
    mov       rdi,	r10
    jmp       L1667
L1669:
    movsxd    rax,	dword ptr[rbx+76]
    lea       r10,	[r13 + rax*8]
    mov       rdi,	r10
    movzx     rax,	byte ptr[rbx+82]
    cmp       rax,	11
    jnz       L1673
    mov       rsi,	rdi
    mov       rdi,	[rsi]
L1673:
    jmp       L1667
L1670:
    mov       rcx,	rbx
    call      pc_runaux.getdllfnptr
    mov       rdi,	rax
    jmp       L1667
L1671:
    mov       rdi,	[rbx+56]
L1667:
    jmp       L1654
L1658:
    mov       rdi,	[r12+8]
    jmp       L1654
L1659:
    movq      XMM4,	[r12+8]
    movq      rax,	XMM4
    mov       rdi,	rax
    jmp       L1654
L1660:
    mov       rax,	[r12+8]
    mov       r10,	[rip+pc_run.labeltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rdi,	r10
    jmp       L1654
L1661:
    mov       rcx,	r12
    call      pc_runaux.pcusopnd
L1654:
    mov       rax,	rdi
L1653:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_runaux.pci_loadptr
pc_runaux.pci_loadptr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    test      rdi,	rdi
    jnz       L1676
    lea       rcx,	[rip+L10570]
    call      pc_api.pclerror
L1676:
    lea       rax,	[rbx-1]
    cmp       rax,	11
    jae       L1679
    lea       r10,	[rip+L1678]
    jmp       [r10 + rax*8]
    .data
L1678:
    .quad     L1682
    .quad     L1681
    .quad     L1690
    .quad     L1689
    .quad     L1688
    .quad     L1687
    .quad     L1686
    .quad     L1685
    .quad     L1684
    .quad     L1683
    .quad     L1680
    .text
L1680:
    mov       rax,	rdi
    jmp       L1677
L1681:
    mov       rax,	[rdi]
    jmp       L1677
L1682:
    movd      XMM4,	[rdi]
    cvtss2sd  XMM4,	XMM4
    movq      XMM15,	XMM4
    movq      XMM4,	XMM15
    movq      rax,	XMM4
    jmp       L1677
L1683:
    mov       rax,	[rdi]
    jmp       L1677
L1684:
    movsxd    rax,	dword ptr[rdi]
    jmp       L1677
L1685:
    movsx     rax,	word ptr[rdi]
    jmp       L1677
L1686:
    movsx     rax,	byte ptr[rdi]
    jmp       L1677
L1687:
    mov       rax,	[rdi]
    jmp       L1677
L1688:
    mov       eax,	[rdi]
    jmp       L1677
L1689:
    movzx     rax,	word ptr[rdi]
    jmp       L1677
L1690:
    movzx     rax,	byte ptr[rdi]
    jmp       L1677
L1679:
    xor       eax,	eax
L1677:
L1674:
#---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_runaux.pci_storeptr
pc_runaux.pci_storeptr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    movq      rax,	XMM15
    push      rax
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
#---------------
#PROC3
#PROC4
    test      rdi,	rdi
    jnz       L1693
    lea       rcx,	[rip+L10570]
    call      pc_api.pclerror
L1693:
    mov       rax,	rsi
    cmp       rax,	11
    jz        L1695
    cmp       rax,	1
    jz        L1696
    jmp       L1697
L1695:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r12
    call      memcpy
    jmp       L1694
L1696:
    mov       rax,	rbx
    movq      XMM4,	rax
    movq      XMM15,	XMM4
    movq      XMM4,	XMM15
    cvtsd2ss  XMM4,	XMM4
    movd      [rdi],	XMM4
    jmp       L1694
L1697:
    lea       rax,	[rip+pc_tables.psize]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10]
    cmp       rax,	8
    jz        L1699
    cmp       rax,	4
    jz        L1700
    cmp       rax,	2
    jz        L1701
    jmp       L1702
L1699:
    mov       [rdi],	rbx
    jmp       L1698
L1700:
    mov       [rdi],	ebx
    jmp       L1698
L1701:
    mov       [rdi],	bx
    jmp       L1698
L1702:
    mov       [rdi],	bl
L1698:
L1694:
#---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_runaux.pci_getopndaddr
pc_runaux.pci_getopndaddr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rbx+1]
    cmp       rax,	1
    jz        L1705
    mov       rcx,	rbx
    lea       rdx,	[rip+L10571]
    lea       r8,	[rip+L10572]
    call      pc_runaux.pcerrorx
L1705:
    mov       rdi,	[rbx+8]
    movzx     rax,	byte ptr[rdi+72]
    cmp       rax,	3
    jnz       L1707
    mov       rax,	[rdi+56]
    jmp       L1706
L1707:
    movsxd    rax,	dword ptr[rdi+76]
    lea       r10,	[rsi + rax*8]
    mov       rax,	r10
L1706:
L1703:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_runaux.pcerrorx
pc_runaux.pcerrorx:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10573]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L10574]
    call      msys.m$print_str_nf
    test      rdi,	rdi
    jz        L1710
    movsxd    rax,	dword ptr[rdi+28]
    shr       rax,	8
    and       rax,	16777215
    jmp       L1709
L1710:
    xor       eax,	eax
L1709:
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_runaux.pcusopnd
pc_runaux.pcusopnd:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10575]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rdi+1]
    lea       r10,	[rip+pc_tables.opndnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L10576]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rdi]
    lea       r10,	[rip+pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movsxd    rax,	dword ptr[rdi+28]
    shr       rax,	8
    and       rax,	16777215
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_runaux.docalldll
pc_runaux.docalldll:
#PROC1
#PROC2
#?>>
    .set pc_runaux.docalldll.nvars, 96
    .set pc_runaux.docalldll.retmode, 104
    .set pc_runaux.docalldll.args, -800
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	832
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
#---------------
#PROC3
#PROC4
    test      r12,	r12
    jnz       L1714
    mov       rcx,	rsi
    call      pc_runaux.getdllfnptr
    mov       r12,	rax
L1714:
    mov       rbx,	r14
    cmp       rbx,	1
    jl        L1717
L1715:
    mov       rax,	[r13 + rbx*8-8]
    mov       r10,	r14
    sub       r10,	rbx
    mov       [rbp + r10*8 + pc_runaux.docalldll.args],	rax
    dec       rbx
    cmp       rbx,	1
    jge       L1715
L1717:
    sub       rsp,	8
    push      0
    mov       rax,	[rbp + pc_runaux.docalldll.retmode]
    cmp       rax,	1
    jz        L1720
    cmp       rax,	2
    jnz       L1719
L1720:
    mov       rax,	82
    jmp       L1718
L1719:
    mov       rax,	73
L1718:
    mov       rcx,	r12
    mov       rdx,	rax
    mov       r8,	r14
    lea       r9,	[rbp + pc_runaux.docalldll.args]
    sub       rsp,	32
    call      mwindll.os_calldllfunction
    add       rsp,	48
    mov       rdi,	rax
    mov       rax,	rdi
L1712:
#---------------
    add       rsp,	832
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_runaux.getdllfnptr
pc_runaux.getdllfnptr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	[r12+56]
    test      rdi,	rdi
    jz        L1723
    mov       rax,	rdi
    jmp       L1721
L1723:
    mov       rbx,	[r12]
    mov       rsi,	1
    mov       rax,	[rip+pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L1727
L1724:
    lea       rax,	[rip+pc_decls.plibinst]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	rbx
    call      mwindows.os_getdllprocaddr
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L1729
    jmp       L1726
L1729:
    inc       rsi
    cmp       rsi,	[rip+pc_decls.nplibfiles]
    jle       L1724
L1727:
    xor       ecx,	ecx
    lea       rdx,	[rip+L10577]
    mov       r8,	rbx
    call      pc_runaux.pcerrorx
L1726:
    mov       [r12+56],	rdi
    mov       rax,	rdi
L1721:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_runaux.loadlibs
pc_runaux.loadlibs:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L1733
L1731:
    lea       rax,	[rip+pc_decls.plibfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mwindows.os_getdllinst
    lea       r10,	[rip+pc_decls.plibinst]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    lea       rax,	[rip+pc_decls.plibinst]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    test      rax,	rax
    jnz       L1735
    lea       rax,	[rip+pc_decls.plibfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    xor       ecx,	ecx
    lea       rdx,	[rip+L10578]
    mov       r8,	rax
    call      pc_runaux.pcerrorx
L1735:
    inc       rdi
    cmp       rdi,	[rip+pc_decls.nplibfiles]
    jle       L1731
L1733:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_runaux.cmpreal
pc_runaux.cmpreal:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	rcx
    cmp       rax,	1
    jz        L1738
    cmp       rax,	2
    jz        L1739
    cmp       rax,	3
    jz        L1740
    cmp       rax,	4
    jz        L1741
    cmp       rax,	5
    jz        L1742
    jmp       L1743
L1738:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setz      al
    movzx     eax,	al
    jmp       L1737
L1739:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setnz     al
    movzx     eax,	al
    jmp       L1737
L1740:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setb      al
    movzx     eax,	al
    jmp       L1737
L1741:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setbe     al
    movzx     eax,	al
    jmp       L1737
L1742:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    setae     al
    movzx     eax,	al
    jmp       L1737
L1743:
    movq      XMM4,	XMM1
    comisd    XMM4,	XMM2
    seta      al
    movzx     eax,	al
L1737:
L1736:
#---------------
    ret       
# End 
# Proc pc_runaux.cmpint
pc_runaux.cmpint:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	rcx
    cmp       rax,	1
    jz        L1746
    cmp       rax,	2
    jz        L1747
    cmp       rax,	3
    jz        L1748
    cmp       rax,	4
    jz        L1749
    cmp       rax,	5
    jz        L1750
    jmp       L1751
L1746:
    mov       rax,	rdx
    cmp       rax,	r8
    setz      al
    movzx     eax,	al
    jmp       L1745
L1747:
    mov       rax,	rdx
    cmp       rax,	r8
    setnz     al
    movzx     eax,	al
    jmp       L1745
L1748:
    mov       rax,	rdx
    cmp       rax,	r8
    setl      al
    movzx     eax,	al
    jmp       L1745
L1749:
    mov       rax,	rdx
    cmp       rax,	r8
    setle     al
    movzx     eax,	al
    jmp       L1745
L1750:
    mov       rax,	rdx
    cmp       rax,	r8
    setge     al
    movzx     eax,	al
    jmp       L1745
L1751:
    mov       rax,	rdx
    cmp       rax,	r8
    setg      al
    movzx     eax,	al
L1745:
L1744:
#---------------
    ret       
# End 
# Proc pc_runaux.cmpword
pc_runaux.cmpword:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	rcx
    cmp       rax,	1
    jz        L1754
    cmp       rax,	2
    jz        L1755
    cmp       rax,	3
    jz        L1756
    cmp       rax,	4
    jz        L1757
    cmp       rax,	5
    jz        L1758
    jmp       L1759
L1754:
    mov       rax,	rdx
    cmp       rax,	r8
    setz      al
    movzx     eax,	al
    jmp       L1753
L1755:
    mov       rax,	rdx
    cmp       rax,	r8
    setnz     al
    movzx     eax,	al
    jmp       L1753
L1756:
    mov       rax,	rdx
    cmp       rax,	r8
    setb      al
    movzx     eax,	al
    jmp       L1753
L1757:
    mov       rax,	rdx
    cmp       rax,	r8
    setbe     al
    movzx     eax,	al
    jmp       L1753
L1758:
    mov       rax,	rdx
    cmp       rax,	r8
    setae     al
    movzx     eax,	al
    jmp       L1753
L1759:
    mov       rax,	rdx
    cmp       rax,	r8
    seta      al
    movzx     eax,	al
L1753:
L1752:
#---------------
    ret       
# End 
# Proc pc_runaux.doincr
pc_runaux.doincr:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+pc_tables.psize]
    mov       r10,	r8
    movzx     rax,	byte ptr[rax + r10]
    cmp       rax,	8
    jz        L1762
    cmp       rax,	4
    jz        L1763
    cmp       rax,	2
    jz        L1764
    jmp       L1765
L1762:
    mov       rax,	rcx
    mov       r10,	rdx
    add       [rax],	r10
    jmp       L1761
L1763:
    mov       rax,	rcx
    mov       r10d,	edx
    add       [rax],	r10d
    jmp       L1761
L1764:
    mov       rax,	rcx
    mov       r10w,	dx
    add       [rax],	r10w
    jmp       L1761
L1765:
    mov       rax,	rcx
    mov       r10b,	dl
    add       [rax],	r10b
L1761:
#---------------
    ret       
# End 
# Proc pc_runaux.docmdskip
pc_runaux.docmdskip:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	[rip+pc_decls.psymboltable]
    jmp       L1770
L1767:
    mov       rax,	[rdi]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       rcx,	rax
    lea       rdx,	[rip+L10579]
    call      mlib.eqstring
    test      rax,	rax
    jz        L1772
    mov       rax,	[rdi+56]
    mov       r10b,	[rip+pc_decls.pcmdskip]
    mov       [rax],	r10b
    jmp       L1769
L1772:
    mov       rdi,	[rdi+8]
L1770:
    test      rdi,	rdi
    jnz       L1767
L1769:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc pc_runaux.pci_loadbf
pc_runaux.pci_loadbf:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
#---------------
#PROC3
#PROC4
    cmp       r8,	rdx
    jae       L1775
    mov       rax,	rdx
    mov       r10,	r8
    mov       r8,	rax
    mov       rdx,	r10
L1775:
    mov       rax,	r8
    sub       rax,	rdx
    inc       rax
    mov       rbx,	rax
    mov       rax,	-1
    push      rcx
    mov       cl,	bl
    shl       rax,	cl
    pop       rcx
    not       rax
    push      rcx
    mov       cl,	dl
    shl       rax,	cl
    pop       rcx
    mov       rdi,	rax
    mov       rax,	rcx
    and       rax,	rdi
    push      rcx
    mov       cl,	dl
    shr       rax,	cl
    pop       rcx
L1773:
#---------------
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc pc_runaux.pci_storebf
pc_runaux.pci_storebf:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
#---------------
#PROC3
#PROC4
    cmp       r8,	rdx
    jae       L1778
    mov       rax,	rdx
    mov       r10,	r8
    mov       r8,	rax
    mov       rdx,	r10
L1778:
    mov       rax,	r8
    sub       rax,	rdx
    inc       rax
    mov       rbx,	rax
    mov       rax,	-1
    push      rcx
    mov       cl,	bl
    shl       rax,	cl
    pop       rcx
    not       rax
    push      rcx
    mov       cl,	dl
    shl       rax,	cl
    pop       rcx
    mov       rdi,	rax
    mov       rax,	r9
    push      rcx
    mov       cl,	dl
    shl       rax,	cl
    pop       rcx
    and       rax,	rdi
    mov       r9,	rax
    mov       rax,	rdi
    not       rax
    mov       r10,	rcx
    and       r10,	rax
    or        r10,	r9
    mov       rax,	r10
L1776:
#---------------
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.genmcl
mc_genmcl.genmcl:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.genmcl.dummy, 32
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       al,	[rip+pc_decls.mcldone]
    test      al,	al
    jnz       L1779
L1781:
    xor       eax,	eax
    test      ax,	ax
    jnz       L1784
    xor       eax,	eax
    test      ax,	ax
    jz        L1783
L1784:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10580]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L1783:
    call      mwindows.os_clock
    mov       rdi,	rax
    call      mc_genmcl.inithandlers
    xor       ecx,	ecx
    call      mc_libmcl.mclinit
    mov       rax,	[rip+pc_api.pcstart]
    mov       [rip+mc_decls.currpcl],	rax
    lea       rcx,	[rip+L10581]
    call      mc_libmcl.mgencomment
    xor       rbx,	rbx
L1785:
    mov       rcx,	[rip+mc_decls.currpcl]
    call      mc_genmcl.convertpcl
    xor       eax,	eax
    test      ax,	ax
    jz        L1789
    mov       rax,	[rip+mc_decls.currpcl]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	127
    jz        L1789
    cmp       rax,	135
    jz        L1789
    cmp       rax,	120
    jz        L1789
    cmp       rax,	121
    jz        L1789
    cmp       rax,	20
    jz        L1789
    cmp       rax,	122
    jz        L1789
    call      mc_stackmcl.showopndstack
L1789:
    add       qword ptr[rip+mc_decls.currpcl],	32
    mov       rax,	[rip+mc_decls.currpcl]
    cmp       rax,	[rip+pc_api.pccurr]
    ja        L1790
    mov       rax,	[rip+mc_decls.currpcl]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	136
    jnz       L1785
L1790:
    call      mc_auxmcl.genrealtable
    call      mc_auxmcl.genabsneg
    call      mc_auxmcl.genstringtable
    mov       rcx,	8
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	8
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       al,	[rip+pc_decls.fpeephole]
    test      al,	al
    jz        L1792
    call      mc_optim.peephole
L1792:
    mov       al,	1
    mov       [rip+pc_decls.mcldone],	al
    call      mwindows.os_clock
    sub       rax,	rdi
    mov       [rip+pc_decls.mcltime],	rax
L1779:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.convertpcl
mc_genmcl.convertpcl:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.convertpcl.oldregset, -16
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       al,	[rsi+3]
    mov       [rip+mc_decls.pmode],	al
    mov       [rip+mc_decls.currpcl],	rsi
    mov       eax,	[rsi+24]
    mov       [rip+pc_decls.mmpos],	rax
    movsxd    rax,	dword ptr[rsi+28]
    shr       rax,	8
    and       rax,	16777215
    mov       [rip+pc_decls.ppseqno],	rax
    movzx     rax,	byte ptr[rsi]
    lea       r10,	[rip+mc_genmcl.px_handlertable]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rsi
    call      r10
    lea       rax,	[rip+mc_decls.regset]
    lea       r10,	[rbp + mc_genmcl.convertpcl.oldregset]
    movdqu    XMM4,	[rax]
    movdqu    [r10],	XMM4
    lea       rax,	[rip+mc_decls.regset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[rip+mc_decls.xregset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       rbx,	1
    mov       rax,	[rip+mc_decls.noperands]
    cmp       rax,	1
    jl        L1796
L1794:
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	rbx
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L1798
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	rbx
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	2
    jg        L1800
    mov       al,	1
    lea       r10,	[rip+mc_decls.xregset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    jmp       L1799
L1800:
    mov       al,	1
    lea       r10,	[rip+mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
L1799:
L1798:
    inc       rbx
    cmp       rbx,	[rip+mc_decls.noperands]
    jle       L1794
L1796:
    mov       rax,	[rbp + mc_genmcl.convertpcl.oldregset]
    lea       r10,	[rip+mc_decls.regset]
    mov       r10,	[r10]
    lea       r11,	[rip+mc_decls.isregvar]
    mov       r11,	[r11]
    or        r10,	r11
    mov       r11,	72340172838076673
    xor       r10,	r11
    and       rax,	r10
    mov       r10,	[rip+mc_decls.mccodex]
    lea       r10,	[r10+48]
    or        [r10],	rax
    mov       rax,	[rbp + mc_genmcl.convertpcl.oldregset+8]
    lea       r10,	[rip+mc_decls.regset]
    mov       r10,	[r10+8]
    lea       r11,	[rip+mc_decls.isregvar]
    mov       r11,	[r11+8]
    or        r10,	r11
    mov       r11,	72340172838076673
    xor       r10,	r11
    and       rax,	r10
    mov       r10,	[rip+mc_decls.mccodex]
    lea       r10,	[r10+56]
    or        [r10],	rax
#---------------
    add       rsp,	56
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.inithandlers
mc_genmcl.inithandlers:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.inithandlers.k, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       al,	[rip+mc_genmcl.inithandlers.initdone]
    test      al,	al
    jnz       L1801
L1803:
    mov       rsi,	[rip+$nprocs]
    mov       r15,	1
    cmp       rsi,	1
    jl        L1806
L1804:
    lea       rax,	[rip+$procname]
    mov       r10,	r15
    mov       rdi,	[rax + r10*8-8]
    mov       rcx,	rdi
    lea       rdx,	[rip+L10582]
    mov       r8,	3
    call      mlib.eqbytes
    test      rax,	rax
    jz        L1808
    xor       eax,	eax
    mov       [rbp + mc_genmcl.inithandlers.k],	rax
    mov       r12,	142
    cmp       r12,	0
    jl        L1812
L1809:
    lea       rax,	[rip+pc_tables.pclnames]
    mov       r10,	[rbp + mc_genmcl.inithandlers.k]
    mov       rbx,	[rax + r10*8]
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	107
    jnz       L1814
    inc       rbx
L1814:
    lea       rax,	[rdi+3]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L1816
    lea       rax,	[rip+$procaddr]
    mov       r10,	r15
    mov       rax,	[rax + r10*8-8]
    lea       r10,	[rip+mc_genmcl.px_handlertable]
    mov       r11,	[rbp + mc_genmcl.inithandlers.k]
    mov       [r10 + r11*8],	rax
    jmp       L1811
L1816:
    mov       rax,	[rbp + mc_genmcl.inithandlers.k]
    inc       rax
    mov       [rbp + mc_genmcl.inithandlers.k],	rax
    cmp       rax,	r12
    jle       L1809
L1812:
    lea       rcx,	[rip+L10583]
    mov       rdx,	rdi
    call      pc_api.merror
L1811:
L1808:
    inc       r15
    cmp       r15,	rsi
    jle       L1804
L1806:
    mov       r15,	1
    mov       r13,	9
    cmp       r13,	1
    jl        L1819
L1817:
    lea       rax,	[rip+mc_genmcl.inithandlers.dupltable]
    mov       r10,	r15
    lea       rax,	[rax + r10*2-2]
    movzx     rax,	byte ptr[rax+1]
    lea       r10,	[rip+mc_genmcl.px_handlertable]
    mov       r10,	[r10 + rax*8]
    lea       rax,	[rip+mc_genmcl.inithandlers.dupltable]
    mov       r11,	r15
    lea       rax,	[rax + r11*2-2]
    movzx     rax,	byte ptr[rax]
    lea       r11,	[rip+mc_genmcl.px_handlertable]
    mov       [r11 + rax*8],	r10
    inc       r15
    cmp       r15,	r13
    jle       L1817
L1819:
    xor       r15,	r15
    mov       rax,	142
    mov       r14,	rax
    cmp       r14,	0
    jl        L1822
L1820:
    lea       rax,	[rip+mc_genmcl.px_handlertable]
    mov       r10,	r15
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jnz       L1824
    lea       rax,	[rip+mc_genmcl.unimpl]
    lea       r10,	[rip+mc_genmcl.px_handlertable]
    mov       r11,	r15
    mov       [r10 + r11*8],	rax
L1824:
    inc       r15
    cmp       r15,	r14
    jle       L1820
L1822:
    mov       al,	1
    mov       [rip+mc_genmcl.inithandlers.initdone],	al
L1801:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.doshowpcl
mc_genmcl.doshowpcl:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.doshowpcl.str, -1256
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	1288
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    jmp       L1825
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	120
    jz        L1827
    cmp       rax,	121
    jz        L1827
    cmp       rax,	20
    jz        L1827
    cmp       rax,	122
    jz        L1827
    cmp       rax,	123
    jz        L1827
    cmp       rax,	124
    jz        L1827
    cmp       rax,	125
    jnz       L1828
L1827:
    jmp       L1826
L1828:
    lea       rcx,	[rbp + mc_genmcl.doshowpcl.str]
    lea       rdx,	[rip+L10584]
    call      strcpy
    mov       rcx,	rdi
    mov       rdx,	1256
    call      pc_diags.strpclstr
    lea       rcx,	[rbp + mc_genmcl.doshowpcl.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rbp + mc_genmcl.doshowpcl.str]
    call      mlib.pcm_copyheapstring
    mov       rcx,	rax
    call      mc_libmcl.mgencomment
L1826:
L1825:
#---------------
    add       rsp,	1288
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.unimpl
mc_genmcl.unimpl:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.unimpl.str, -104
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10585]
    call      msys.m$print_setfmt
    movzx     rax,	byte ptr[rdi]
    lea       r10,	[rip+pc_tables.pclnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.strpmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rbp + mc_genmcl.unimpl.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rbp + mc_genmcl.unimpl.str]
    call      mlib.pcm_copyheapstring
    mov       rcx,	rax
    call      mc_libmcl.mgencomment
#---------------
    add       rsp,	136
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_nop
mc_genmcl.px_nop:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_nop.p, 16
#?]]
#---------------
#PROC3
#PROC4
#---------------
    ret       
# End 
# Proc mc_genmcl.px_dupl
mc_genmcl.px_dupl:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_dupl.p, 16
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      mc_stackmcl.duplpcl
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_double
mc_genmcl.px_double:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_double.p, 16
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.ncalldepth]
    test      rax,	rax
    jz        L1834
    call      mc_stackmcl.duplpcl
    jmp       L1833
L1834:
    lea       rax,	[rip+mc_decls.pclcount]
    mov       r10,	[rip+mc_decls.noperands]
    lea       rax,	[rax + r10-1]
    inc       byte ptr[rax]
L1833:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_opnd
mc_genmcl.px_opnd:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      mc_genmcl.unimpl
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_type
mc_genmcl.px_type:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      mc_genmcl.unimpl
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_comment
mc_genmcl.px_comment:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_comment.p, 16
#?]]
#---------------
#PROC3
#PROC4
#---------------
    ret       
# End 
# Proc mc_genmcl.px_proc
mc_genmcl.px_proc:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rdi+8]
    mov       [rip+pc_decls.currfunc],	rax
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
    mov       rcx,	[rip+pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	1
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	[rip+pc_decls.currfunc]
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	4
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    lea       rcx,	[rip+L10586]
    call      mc_libmcl.mgencomment
    mov       rcx,	[rip+pc_decls.currfunc]
    call      mc_auxmcl.initproc
    lea       rcx,	[rip+L10587]
    call      mc_libmcl.mgencomment
    lea       rcx,	[rip+L10588]
    call      mc_libmcl.mgencomment
    mov       rax,	[rip+mc_decls.mccodex]
    mov       [rip+mc_decls.mclprocentry],	rax
    lea       rcx,	[rip+L10589]
    call      mc_libmcl.mgencomment
    mov       rax,	[rip+pc_decls.currfunc]
    movzx     rax,	byte ptr[rax+112]
    cmp       rax,	2
    jnz       L1840
    mov       rax,	[rip+pc_decls.currfunc]
    mov       al,	[rax+83]
    test      al,	al
    jz        L1840
    call      mc_auxmcl.fixmain
L1840:
    lea       rcx,	[rip+L10590]
    call      mc_libmcl.mgencomment
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_endproc
mc_genmcl.px_endproc:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_endproc.p, 16
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.noperands]
    test      rax,	rax
    jz        L1843
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10591]
    call      msys.m$print_str_nf
    mov       rax,	[rip+pc_decls.currfunc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10591]
    call      mc_libmcl.mgencomment
L1843:
    mov       rcx,	2
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_endprog
mc_genmcl.px_endprog:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      mc_genmcl.unimpl
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_istatic
mc_genmcl.px_istatic:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rdi+16]
    mov       rcx,	73
    mov       rdx,	rax
    call      mc_libmcl.setsegment
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	4
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_zstatic
mc_genmcl.px_zstatic:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	[rbx+8]
    movsxd    rax,	dword ptr[rbx+16]
    mov       rcx,	90
    mov       rdx,	rax
    call      mc_libmcl.setsegment
    mov       rcx,	rdi
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	4
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       eax,	[rbx+4]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	125
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_data
mc_genmcl.px_data:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rsi+3]
    cmp       rax,	11
    jnz       L1849
    mov       rcx,	rsi
    call      mc_auxmcl.do_blockdata
    jmp       L1847
L1849:
    movzx     rax,	byte ptr[rsi+1]
    cmp       rax,	4
    jz        L1851
    cmp       rax,	10
    jz        L1852
    cmp       rax,	11
    jz        L1853
    cmp       rax,	6
    jz        L1854
    cmp       rax,	7
    jz        L1855
    cmp       rax,	2
    jz        L1856
    cmp       rax,	3
    jz        L1857
    jmp       L1858
L1851:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rdi,	rax
    jmp       L1850
L1852:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	2
    call      mc_libmcl.mgenrealimm
    mov       rdi,	rax
    jmp       L1850
L1853:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       rdi,	rax
    jmp       L1850
L1854:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       rdi,	rax
    jmp       L1850
L1855:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.getstringindex
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rdi,	rax
    jmp       L1850
L1856:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenmemaddr
    mov       rdi,	rax
    mov       eax,	[rsi+20]
    mov       [rdi+12],	eax
    jmp       L1850
L1857:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rdi,	rax
    jmp       L1850
L1858:
    movzx     rax,	byte ptr[rsi+1]
    lea       r10,	[rip+pc_tables.opndnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rip+L10592]
    mov       rdx,	r10
    call      pc_api.merror
L1850:
    mov       eax,	[rsi+4]
    cmp       rax,	1
    jz        L1860
    cmp       rax,	2
    jz        L1861
    cmp       rax,	4
    jz        L1862
    cmp       rax,	8
    jz        L1863
    jmp       L1864
L1860:
    mov       rbx,	116
    jmp       L1859
L1861:
    mov       rbx,	117
    jmp       L1859
L1862:
    mov       rbx,	118
    jmp       L1859
L1863:
    mov       rbx,	119
    jmp       L1859
L1864:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10593]
    call      msys.m$print_str_nf
    mov       eax,	[rsi+4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[rip+L10594]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rsi+3]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.strpmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10595]
    lea       rdx,	[rip+L10596]
    call      pc_api.merror
L1859:
    mov       rcx,	rbx
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1847:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_label
mc_genmcl.px_label:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_load
mc_genmcl.px_load:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      mc_stackmcl.pushpcl
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_store
mc_genmcl.px_store:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rsi+3]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte ptr[rsi+3]
    cmp       rax,	11
    jz        L1869
    movzx     rax,	byte ptr[rsi+3]
    mov       r10,	[rsi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenmem
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    jmp       L1868
L1869:
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       rbx,	rax
    mov       eax,	[rsi+4]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rax
    mov       r9,	1
    call      mc_auxmcl.copyblock
L1868:
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_add
mc_genmcl.px_add:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rsi+3]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte ptr[rsi+3]
    cmp       rax,	2
    jle       L1872
    mov       rcx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      rax,	rax
    jz        L1874
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	[rip+mc_decls.noperands]
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax+8]
    cmp       rax,	1
    jnz       L1874
    mov       rcx,	52
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1873
L1874:
    movzx     rax,	byte ptr[rsi+3]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1873:
    jmp       L1871
L1872:
    movzx     rax,	byte ptr[rsi+3]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte ptr[rsi+3]
    dec       rax
    mov       r10,	65
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1871:
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_sub
mc_genmcl.px_sub:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rsi+3]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte ptr[rsi+3]
    cmp       rax,	2
    jle       L1877
    mov       rcx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      rax,	rax
    jz        L1879
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	[rip+mc_decls.noperands]
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax+8]
    cmp       rax,	1
    jnz       L1879
    mov       rcx,	53
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1878
L1879:
    movzx     rax,	byte ptr[rsi+3]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	29
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1878:
    jmp       L1876
L1877:
    movzx     rax,	byte ptr[rsi+3]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte ptr[rsi+3]
    dec       rax
    mov       r10,	67
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1876:
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_mul
mc_genmcl.px_mul:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rsi+3]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte ptr[rsi+3]
    cmp       rax,	2
    jle       L1882
    mov       rcx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      rax,	rax
    jz        L1884
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	[rip+mc_decls.noperands]
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax+8]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    jmp       L1883
L1884:
    movzx     rax,	byte ptr[rsi+3]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rcx,	34
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1883:
    jmp       L1881
L1882:
    movzx     rax,	byte ptr[rsi+3]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte ptr[rsi+3]
    dec       rax
    mov       r10,	69
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L1881:
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_div
mc_genmcl.px_div:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_div.p, 32
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    dec       rax
    mov       r10,	71
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_eval
mc_genmcl.px_eval:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rdi+3]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_widen
mc_genmcl.px_widen:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	6
    jnz       L1889
    movsxd    rax,	dword ptr[rsi+28]
    and       rax,	255
    cmp       rax,	5
    jnz       L1889
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	5
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rax,	[rip+mc_decls.mccodex]
    movzx     rax,	byte ptr[rax+33]
    cmp       rax,	11
    jz        L1891
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
L1891:
    jmp       L1888
L1889:
    movsxd    rax,	dword ptr[rsi+28]
    and       rax,	255
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    movsxd    rax,	dword ptr[rsi+28]
    and       rax,	255
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1893
    mov       rax,	18
    jmp       L1892
L1893:
    mov       rax,	19
L1892:
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    movzx     r10,	byte ptr[rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
L1888:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_jump
mc_genmcl.px_jump:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	[rsi+8]
    lea       rax,	[rsi+32]
    mov       rbx,	rax
    jmp       L1896
L1895:
    add       rbx,	32
L1896:
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	135
    jz        L1895
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	127
    jz        L1899
    cmp       rax,	24
    jz        L1900
    jmp       L1901
L1899:
    mov       rax,	[rbx+8]
    cmp       rax,	rdi
    jz        L1894
L1903:
    add       rbx,	32
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	127
    jnz       L1905
    mov       rax,	[rbx+8]
    cmp       rax,	rdi
    jz        L1894
L1905:
    jmp       L1898
L1900:
    xor       eax,	eax
    mov       [rbx],	al
L1901:
L1898:
    mov       rcx,	rdi
    call      mc_libmcl.mgenlabel
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1894:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_ijump
mc_genmcl.px_ijump:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_ijump.p, 16
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_neg
mc_genmcl.px_neg:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_neg.p, 24
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jle       L1909
    mov       rcx,	50
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1908
L1909:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.do_negreal
L1908:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_abs
mc_genmcl.px_abs:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_abs.p, 32
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jle       L1912
    xor       ecx,	ecx
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rax,	[rip+pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	26
    mov       rdx,	13
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	50
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L1911
L1912:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.do_absreal
L1911:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_bitnot
mc_genmcl.px_bitnot:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_bitnot.p, 24
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	51
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_not
mc_genmcl.px_not:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_not.p, 24
    .set mc_genmcl.px_not.$T1, -8
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	1
    mov       rdx,	3
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_not.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	40
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_not.$T1]
    call      mc_libmcl.genmc
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_toboolt
mc_genmcl.px_toboolt:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_toboolt.$T2, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r13+28]
    and       rax,	255
    mov       r12b,	al
    movzx     rax,	r12b
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	r12b
    cmp       rax,	2
    jg        L1917
    movzx     rax,	r12b
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	3
    call      mc_stackmcl.getworkregm
    mov       rsi,	rax
    movzx     rax,	r12b
    dec       rax
    mov       r10,	76
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	r12b
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[r13]
    cmp       rax,	64
    jnz       L1919
    mov       rax,	5
    jmp       L1918
L1919:
    mov       rax,	4
L1918:
    mov       rcx,	58
    mov       rdx,	rax
    mov       r8,	rsi
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	rsi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	19
    mov       rdx,	rax
    mov       r8,	rsi
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    movzx     r10,	byte ptr[rsi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
    jmp       L1916
L1917:
    mov       rcx,	41
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       r10,	rax
    mov       rbx,	r10
    mov       [rbp + mc_genmcl.px_toboolt.$T2],	rax
    movzx     rax,	byte ptr[r13]
    cmp       rax,	64
    jnz       L1921
    mov       rax,	5
    jmp       L1920
L1921:
    mov       rax,	4
L1920:
    mov       rcx,	58
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_toboolt.$T2]
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	19
    mov       rdx,	rax
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	[rip+mc_decls.pmode]
    lea       r10,	[rip+mc_decls.pclmode]
    mov       r11,	[rip+mc_decls.noperands]
    mov       [r10 + r11-3],	al
L1916:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_sqr
mc_genmcl.px_sqr:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_sqr.p, 24
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jle       L1924
    mov       rcx,	34
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    jmp       L1923
L1924:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    dec       rax
    mov       r10,	69
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
L1923:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_sqrt
mc_genmcl.px_sqrt:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_sqrt.p, 24
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    dec       rax
    mov       r10,	63
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpcc
mc_genmcl.px_jumpcc:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[r13+2]
    lea       r10,	[rip+mc_genmcl.ucondcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rdi,	r10
    mov       rax,	[r13+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r12,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	11
    jnz       L1928
    lea       rcx,	[rip+L10597]
    lea       rdx,	[rip+L10598]
    call      pc_api.merror
    jmp       L1927
L1928:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jle       L1930
    mov       rcx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    test      rax,	rax
    jz        L1932
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	[rip+mc_decls.noperands]
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax+8]
    test      rax,	rax
    jnz       L1932
    movzx     rax,	byte ptr[r13+2]
    cmp       rax,	1
    jz        L1933
    cmp       rax,	2
    jnz       L1932
L1933:
    mov       rcx,	41
    mov       rdx,	rbx
    mov       r8,	rbx
    call      mc_libmcl.genmc
    jmp       L1931
L1932:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1935
    movzx     rax,	byte ptr[r13+2]
    lea       r10,	[rip+mc_genmcl.scondcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rdi,	r10
L1935:
    mov       rcx,	42
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
L1931:
    jmp       L1929
L1930:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
L1929:
    mov       rcx,	26
    mov       rdx,	rdi
    mov       r8,	r12
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
    mov       eax,	[r13+16]
    test      eax,	eax
    jnz       L1937
    call      mc_stackmcl.poppcl
L1937:
L1927:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpt
mc_genmcl.px_jumpt:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	5
    call      mc_auxmcl.do_jumptruefalse
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpf
mc_genmcl.px_jumpf:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_auxmcl.do_jumptruefalse
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_bitand
mc_genmcl.px_bitand:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	38
    call      mc_auxmcl.do_bitwise
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_bitor
mc_genmcl.px_bitor:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	39
    call      mc_auxmcl.do_bitwise
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_bitxor
mc_genmcl.px_bitxor:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	40
    call      mc_auxmcl.do_bitwise
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_shl
mc_genmcl.px_shl:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	43
    call      mc_auxmcl.do_shift
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_shr
mc_genmcl.px_shr:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L1946
    mov       rax,	44
    jmp       L1945
L1946:
    mov       rax,	45
L1945:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.do_shift
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_retproc
mc_genmcl.px_retproc:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.mclprocentry]
    cmp       rax,	[rip+mc_decls.mccodex]
    jnz       L1949
    lea       rcx,	[rip+L10599]
    call      mc_libmcl.mgencomment
L1949:
    mov       rcx,	rdi
    call      mc_auxmcl.do_procentry
    call      mc_auxmcl.do_procexit
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_retfn
mc_genmcl.px_retfn:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_retfn.$T1, -8
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	11
    jnz       L1952
    mov       rcx,	1
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rbx,	rax
    mov       al,	1
    lea       r10,	[rip+mc_decls.regset]
    mov       [r10],	al
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	[rip+pc_decls.blockretname]
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rdi+10]
    mov       rcx,	rax
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rdi,	rax
    mov       eax,	[rsi+4]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rax
    mov       r9,	1
    call      mc_auxmcl.copyblock
    mov       rcx,	[rip+pc_decls.blockretname]
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_genmcl.px_retfn.$T1],	rax
    mov       rcx,	1
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_retfn.$T1]
    call      mc_libmcl.genmc
L1952:
    mov       rcx,	rsi
    call      mc_genmcl.px_retproc
#---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_setcall
mc_genmcl.px_setcall:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      mc_stackmcl.saveopnds
    mov       rax,	[rip+mc_decls.ncalldepth]
    cmp       rax,	32
    jl        L1955
    lea       rcx,	[rip+L10600]
    lea       rdx,	[rip+L10601]
    call      pc_api.merror
L1955:
    inc       qword ptr[rip+mc_decls.ncalldepth]
    movsxd    rax,	dword ptr[rdi+16]
    cmp       rax,	4
    jg        L1957
    mov       eax,	[rip+mc_decls.mstackdepth]
    and       eax,	1
    lea       r10,	[rip+mc_decls.callalign]
    mov       r11,	[rip+mc_decls.ncalldepth]
    mov       [r10 + r11-1],	al
    jmp       L1956
L1957:
    movsxd    rax,	dword ptr[rdi+16]
    and       eax,	1
    mov       r10d,	[rip+mc_decls.mstackdepth]
    and       r10d,	1
    xor       rax,	r10
    lea       r10,	[rip+mc_decls.callalign]
    mov       r11,	[rip+mc_decls.ncalldepth]
    mov       [r10 + r11-1],	al
L1956:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	11
    setz      al
    movzx     eax,	al
    lea       r10,	[rip+mc_decls.callblockret]
    mov       r11,	[rip+mc_decls.ncalldepth]
    mov       [r10 + r11-1],	al
    mov       eax,	[rdi+4]
    lea       r10,	[rip+mc_decls.callblocksize]
    mov       r11,	[rip+mc_decls.ncalldepth]
    mov       [r10 + r11*4-4],	eax
    lea       rax,	[rip+mc_decls.callalign]
    mov       r10,	[rip+mc_decls.ncalldepth]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L1959
    mov       rcx,	1
    call      mc_libmcl.pushslots
L1959:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_setarg
mc_genmcl.px_setarg:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rbx+16]
    lea       r10,	[rip+mc_decls.callblockret]
    mov       r11,	[rip+mc_decls.ncalldepth]
    movzx     r10,	byte ptr[r10 + r11-1]
    add       rax,	r10
    mov       rdi,	rax
    cmp       rdi,	4
    jle       L1962
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	11
    jnz       L1964
    mov       eax,	[rbx+4]
    xor       ecx,	ecx
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_auxmcl.copyblockarg
L1964:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.pushopnd
    jmp       L1961
L1962:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	11
    jnz       L1965
    mov       eax,	[rbx+4]
    lea       r10,	[rip+mc_decls.callargsize]
    mov       r11,	[rip+mc_decls.ncalldepth]
    shl       r11,	4
    lea       r10,	[r10 + r11-16]
    mov       r11,	rdi
    mov       [r10 + r11*4-4],	eax
L1965:
L1961:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_callp
mc_genmcl.px_callp:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_callp.p, 72
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+72],	rcx
#---------------
#PROC3
#PROC4
    xor       r12,	r12
    xor       eax,	eax
    mov       r13,	rax
    lea       rax,	[rip+mc_decls.callblockret]
    mov       r10,	[rip+mc_decls.ncalldepth]
    movzx     rax,	byte ptr[rax + r10-1]
    mov       r14,	rax
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    movsxd    rax,	dword ptr[rax+16]
    add       rax,	r14
    mov       rdi,	rax
    mov       rax,	rdi
    mov       r10,	4
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	19
    jz        L1969
    cmp       rax,	22
    jnz       L1968
L1969:
    mov       r12,	1
L1968:
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    movsxd    rax,	dword ptr[rax+20]
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	r12
    call      mc_auxmcl.do_pushlowargs
    xor       rsi,	rsi
    mov       rax,	rdi
    cmp       rax,	4
    jg        L1971
    mov       rax,	[rip+mc_decls.mstackdepth]
    test      rax,	rax
    jz        L1973
    mov       rax,	4
    add       rsi,	rax
    mov       rcx,	4
    call      mc_libmcl.pushslots
    lea       rax,	[rip+mc_decls.callalign]
    mov       r10,	[rip+mc_decls.ncalldepth]
    movzx     rax,	byte ptr[rax + r10-1]
    add       rsi,	rax
    jmp       L1972
L1973:
    mov       al,	1
    mov       [rip+pc_decls.localshadow],	al
L1972:
    jmp       L1970
L1971:
    lea       rax,	[rip+mc_decls.callalign]
    mov       r10,	[rip+mc_decls.ncalldepth]
    movzx     rax,	byte ptr[rax + r10-1]
    mov       r10,	rdi
    add       r10,	rax
    mov       rsi,	r10
    mov       rcx,	4
    call      mc_libmcl.pushslots
L1970:
    test      r12,	r12
    jz        L1975
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L1974
L1975:
    mov       rax,	[rbp + mc_genmcl.px_callp.p]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L1974:
    mov       rax,	rbx
    sub       rax,	r14
    mov       r15,	rax
    cmp       r15,	0
    jle       L1978
L1976:
    call      mc_stackmcl.poppcl
    dec       r15
    jnz       L1976
L1978:
    test      rsi,	rsi
    jz        L1980
    mov       rcx,	rsi
    call      mc_libmcl.popslots
L1980:
    mov       al,	[rip+mc_decls.pmode]
    test      al,	al
    jz        L1982
    mov       rcx,	[rbp + mc_genmcl.px_callp.p]
    call      mc_auxmcl.do_getretvalue
L1982:
    dec       qword ptr[rip+mc_decls.ncalldepth]
#---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpret
mc_genmcl.px_jumpret:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       al,	[rip+mc_decls.pmode]
    test      al,	al
    jz        L1985
    mov       rax,	[rip+mc_decls.noperands]
    test      rax,	rax
    jz        L1987
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    mov       r8,	1
    call      mc_stackmcl.loadparam
    call      mc_stackmcl.poppcl
L1987:
L1985:
    mov       rcx,	rdi
    call      mc_genmcl.px_jump
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_jumpretm
mc_genmcl.px_jumpretm:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r13+16]
    mov       r10,	[rip+mc_decls.noperands]
    sub       r10,	rax
    inc       r10
    mov       rdi,	r10
    movsxd    rax,	dword ptr[r13+16]
    mov       rsi,	rax
    cmp       rsi,	0
    jle       L1991
L1989:
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rcx,	rdi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    inc       rdi
    dec       rsi
    jnz       L1989
L1991:
    mov       rbx,	1
    movsxd    rax,	dword ptr[r13+16]
    mov       r12,	rax
    cmp       r12,	0
    jle       L1994
L1992:
    cmp       rbx,	4
    jnz       L1996
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	2
    jle       L1996
    mov       rbx,	11
L1996:
    mov       rcx,	rbx
    call      mc_stackmcl.movetoreg
    call      mc_stackmcl.poppcl
    inc       rbx
    dec       r12
    jnz       L1992
L1994:
    mov       rcx,	r13
    call      mc_genmcl.px_jump
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_startmx
mc_genmcl.px_startmx:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_startmx.p, 16
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      mc_stackmcl.saveopnds
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_resetmx
mc_genmcl.px_resetmx:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	1
    call      mc_stackmcl.movetoreg
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	118
    jnz       L2000
    call      mc_stackmcl.poppcl
L2000:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_stop
mc_genmcl.px_stop:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_stop.p, 16
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	6
    mov       r8,	11
    call      mc_stackmcl.loadparam
    lea       rcx,	[rip+L10602]
    call      mc_libmcl.mgenextname
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [rip+pc_decls.localshadow],	al
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_incrto
mc_genmcl.px_incrto:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	52
    mov       r8,	28
    call      mc_auxmcl.do_incr
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_decrto
mc_genmcl.px_decrto:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	53
    mov       r8,	29
    call      mc_auxmcl.do_incr
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_incrload
mc_genmcl.px_incrload:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	52
    mov       r8,	28
    call      mc_auxmcl.do_incrload
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_decrload
mc_genmcl.px_decrload:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	53
    mov       r8,	29
    call      mc_auxmcl.do_incrload
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_loadincr
mc_genmcl.px_loadincr:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	52
    mov       r8,	28
    call      mc_auxmcl.do_loadincr
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_loaddecr
mc_genmcl.px_loaddecr:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	53
    mov       r8,	29
    call      mc_auxmcl.do_loadincr
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_forup
mc_genmcl.px_forup:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	52
    mov       r8,	28
    mov       r9,	14
    call      mc_auxmcl.do_for
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_fordown
mc_genmcl.px_fordown:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	53
    mov       r8,	29
    mov       r9,	13
    call      mc_auxmcl.do_for
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_iload
mc_genmcl.px_iload:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_iload.p, 40
    .set mc_genmcl.px_iload.$T1, -8
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	11
    jz        L2012
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	2
    jnz       L2014
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	[rip+mc_decls.noperands]
    movzx     r10,	byte ptr[r10 + r11-1]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rbx,	rax
    jmp       L2013
L2014:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
L2013:
    mov       rax,	[rip+mc_decls.currpcl]
    lea       rax,	[rax+32]
    mov       rsi,	rax
    movzx     rax,	byte ptr[rsi]
    cmp       rax,	114
    jnz       L2016
    movzx     rax,	byte ptr[rsi+3]
    mov       [rbp + mc_genmcl.px_iload.$T1],	rax
    movzx     rax,	byte ptr[rsi+3]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_genmcl.getsharereg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_iload.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    movsxd    rax,	dword ptr[rsi+28]
    and       rax,	255
    lea       r10,	[rip+mc_decls.ploadop]
    movzx     r10,	byte ptr[r10 + rax]
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rsi+3]
    movzx     r10,	byte ptr[rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
    mov       [rip+mc_decls.currpcl],	rsi
    jmp       L2015
L2016:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       [rbp + mc_genmcl.px_iload.$T1],	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_genmcl.getsharereg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_iload.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    movzx     r10,	byte ptr[rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
L2015:
    jmp       L2011
L2012:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind_simp
    mov       rbx,	rax
    movzx     rax,	byte ptr[rbx+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_auxmcl.dolea
L2011:
#---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.getsharereg
mc_genmcl.getsharereg:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
#---------------
#PROC3
#PROC4
    mov       dil,	[rcx+10]
    mov       bl,	[rcx+11]
    cmp       rdx,	2
    jg        L2019
    xor       eax,	eax
    jmp       L2017
L2019:
    test      dil,	dil
    jz        L2021
    movzx     rax,	dil
    lea       r10,	[rip+mc_decls.workregs]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jnz       L2022
    movzx     rax,	dil
    cmp       rax,	11
    jl        L2021
    cmp       rax,	14
    jg        L2021
L2022:
    movzx     rax,	dil
    jmp       L2017
L2021:
    test      bl,	bl
    jz        L2023
    movzx     rax,	bl
    lea       r10,	[rip+mc_decls.workregs]
    mov       r10b,	[r10 + rax-1]
    test      r10b,	r10b
    jnz       L2024
    movzx     rax,	dil
    cmp       rax,	11
    jl        L2023
    cmp       rax,	14
    jg        L2023
L2024:
    movzx     rax,	bl
    jmp       L2017
L2023:
L2020:
    xor       eax,	eax
L2017:
#---------------
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_iloadx
mc_genmcl.px_iloadx:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_iloadx.$T1, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    call      mc_auxmcl.do_addrmode
    mov       rsi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	11
    jnz       L2027
    movzx     rax,	byte ptr[rsi+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       rbx,	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    movzx     rax,	byte ptr[rbx+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.setnewzz
    jmp       L2026
L2027:
    mov       rax,	[rip+mc_decls.currpcl]
    lea       rax,	[rax+32]
    mov       rdi,	rax
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	114
    jnz       L2029
    movzx     rax,	byte ptr[rdi+3]
    mov       [rbp + mc_genmcl.px_iloadx.$T1],	rax
    movzx     rax,	byte ptr[rdi+3]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_genmcl.getsharereg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_iloadx.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       rbx,	rax
    movsxd    rax,	dword ptr[rdi+28]
    and       rax,	255
    lea       r10,	[rip+mc_decls.ploadop]
    movzx     r10,	byte ptr[r10 + rax]
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     rax,	byte ptr[rdi+3]
    movzx     r10,	byte ptr[rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
    mov       [rip+mc_decls.currpcl],	rdi
    jmp       L2028
L2029:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       [rbp + mc_genmcl.px_iloadx.$T1],	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_genmcl.getsharereg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_iloadx.$T1]
    call      mc_stackmcl.getworkreg_rm
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    movzx     r10,	byte ptr[rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
L2028:
L2026:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_istore
mc_genmcl.px_istore:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	2
    jnz       L2032
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	[rip+mc_decls.noperands]
    movzx     r10,	byte ptr[r10 + r11-1]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rbx,	rax
    jmp       L2031
L2032:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
L2031:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	11
    jnz       L2034
    mov       rcx,	rbx
    call      mc_stackmcl.makesimpleaddr
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       rdi,	rax
    mov       eax,	[rsi+4]
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	rax
    mov       r9,	1
    call      mc_auxmcl.copyblock
    jmp       L2033
L2034:
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2033:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_istorex
mc_genmcl.px_istorex:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	rsi
    call      mc_auxmcl.do_addrmode
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	11
    jnz       L2037
    mov       rcx,	rbx
    call      mc_stackmcl.makesimpleaddr
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_stackmcl.makeopndind
    mov       rdi,	rax
    mov       eax,	[rsi+4]
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	rax
    mov       r9,	1
    call      mc_auxmcl.copyblock
    jmp       L2036
L2037:
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2036:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_storem
mc_genmcl.px_storem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       eax,	[r12+4]
    cmp       rax,	16
    jz        L2040
    lea       rcx,	[rip+L10603]
    lea       rdx,	[rip+L10604]
    call      pc_api.merror
L2040:
    mov       rcx,	16
    call      mc_libmcl.newblocktemp
    mov       rsi,	rax
    mov       rcx,	rsi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rbx,	rax
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	8
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rdi+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rdi+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.setnewzz
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_addpx
mc_genmcl.px_addpx:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rsi
    call      mc_auxmcl.do_addrmode
    mov       rbx,	rax
    movzx     rax,	byte ptr[rbx+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_auxmcl.dolea
    call      mc_stackmcl.poppcl
    movzx     rax,	byte ptr[rdi+10]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.setnewzz
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_subpx
mc_genmcl.px_subpx:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r14,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r14+16]
    mov       rdi,	rax
    movsxd    rax,	dword ptr[r14+20]
    mov       rbx,	rax
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rsi,	rax
    mov       rcx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       r13,	rax
    test      rax,	rax
    jz        L2044
    mov       rax,	[r13+8]
    mov       r10,	rdi
    imul      rax,	r10
    add       rax,	rbx
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2043
L2044:
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r12,	rax
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mc_auxmcl.scaleindex
    mov       rdi,	rax
    cmp       rdi,	1
    jle       L2046
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mc_auxmcl.mulimm
L2046:
    mov       rcx,	29
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_libmcl.genmc
    test      rbx,	rbx
    jz        L2048
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10605]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10606]
    lea       rdx,	[rip+L10607]
    call      pc_api.merror
L2048:
L2043:
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_to
mc_genmcl.px_to:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rsi+32]
    mov       [rip+mc_decls.currpcl],	rax
    mov       rdi,	rax
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rbx,	rax
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_iswap
mc_genmcl.px_iswap:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_iswap.p, 48
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rsi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       r12,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	11
    jz        L2052
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	r12
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	r12
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    jmp       L2051
L2052:
    lea       rcx,	[rip+L10608]
    lea       rdx,	[rip+L10609]
    call      pc_api.merror
L2051:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_swapstk
mc_genmcl.px_swapstk:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rdi+20]
    mov       r10,	[rip+mc_decls.noperands]
    sub       r10,	rax
    inc       r10
    movsxd    rax,	dword ptr[rdi+16]
    mov       r11,	[rip+mc_decls.noperands]
    sub       r11,	rax
    inc       r11
    mov       rcx,	r11
    mov       rdx,	r10
    call      mc_stackmcl.swapopnds
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_labeldef
mc_genmcl.px_labeldef:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_labeldef.str, -104
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	136
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rdi+8]
    mov       rax,	[rax]
    lea       rcx,	[rbp + mc_genmcl.px_labeldef.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mc_genmcl.px_labeldef.str]
    lea       rdx,	[rip+L10610]
    call      strcat
    lea       rcx,	[rbp + mc_genmcl.px_labeldef.str]
    call      mc_libmcl.mgencomment
#---------------
    add       rsp,	136
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_addto
mc_genmcl.px_addto:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	28
    mov       r8,	65
    call      mc_auxmcl.do_binto
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_subto
mc_genmcl.px_subto:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	29
    mov       r8,	67
    call      mc_auxmcl.do_binto
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_multo
mc_genmcl.px_multo:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jg        L2059
    mov       rcx,	r13
    mov       rdx,	69
    call      mc_auxmcl.do_binto_float
    jmp       L2057
L2059:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.psize]
    movzx     r10,	byte ptr[r10 + rax]
    cmp       r10,	1
    jnz       L2061
    lea       rcx,	[rip+L10611]
    lea       rdx,	[rip+L10612]
    call      pc_api.merror
L2061:
    mov       rcx,	10
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[rip+mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       r12,	rax
    test      rax,	rax
    jz        L2063
    mov       rax,	[r12+8]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    jmp       L2062
L2063:
    mov       rcx,	34
    mov       rdx,	rsi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2062:
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2057:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_bitandto
mc_genmcl.px_bitandto:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	38
    xor       r8d,	r8d
    call      mc_auxmcl.do_binto
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_bitorto
mc_genmcl.px_bitorto:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	39
    xor       r8d,	r8d
    call      mc_auxmcl.do_binto
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_bitxorto
mc_genmcl.px_bitxorto:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	40
    xor       r8d,	r8d
    call      mc_auxmcl.do_binto
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_shlto
mc_genmcl.px_shlto:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	43
    call      mc_auxmcl.do_shiftnto
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_shrto
mc_genmcl.px_shrto:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2070
    mov       rax,	44
    jmp       L2069
L2070:
    mov       rax,	45
L2069:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.do_shiftnto
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_fix
mc_genmcl.px_fix:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rsi+28]
    and       rax,	255
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.pmin]
    movzx     r10,	byte ptr[r10 + rax]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movsxd    rax,	dword ptr[rsi+28]
    and       rax,	255
    dec       rax
    mov       r10,	84
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    movzx     r10,	byte ptr[rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_float
mc_genmcl.px_float:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r14,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r14+28]
    and       rax,	255
    mov       r13b,	al
    movzx     rax,	r13b
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	r13b
    lea       r10,	[rip+pc_tables.psize]
    movzx     r10,	byte ptr[r10 + rax]
    cmp       r10,	4
    jge       L2074
    lea       rcx,	[rip+L10613]
    lea       rdx,	[rip+L10614]
    call      pc_api.merror
L2074:
    movzx     rax,	r13b
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2076
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte ptr[r14+3]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    dec       rax
    mov       r10,	86
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L2075
L2076:
    movzx     rax,	r13b
    cmp       rax,	6
    jnz       L2077
    mov       rcx,	2
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    call      mc_libmcl.mcreatefwdlabel
    mov       rsi,	rax
    call      mc_libmcl.mcreatefwdlabel
    mov       r12,	rax
    xor       ecx,	ecx
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	rsi
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	12
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	87
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	rsi
    call      mc_libmcl.mdefinefwdlabel
    mov       rax,	[rip+mc_decls.labmask63]
    test      rax,	rax
    jnz       L2079
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rax,	[rip+pc_api.mlabelno]
    mov       [rip+mc_decls.labmask63],	rax
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rax,	[rip+pc_api.mlabelno]
    mov       [rip+mc_decls.laboffset64],	rax
L2079:
    mov       rcx,	[rip+mc_decls.labmask63]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	87
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	[rip+mc_decls.laboffset64]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	66
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mdefinefwdlabel
#mc_genmcl.px_float.reduce:
L2080:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	1
    jnz       L2082
    mov       rcx,	rbx
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	88
    mov       rdx,	rax
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	1
    lea       r10,	[rip+mc_decls.pclmode]
    mov       r11,	[rip+mc_decls.noperands]
    mov       [r10 + r11-1],	al
L2082:
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    jmp       L2075
L2077:
    mov       rcx,	2
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	87
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    jmp       L2080
L2075:
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_idiv
mc_genmcl.px_idiv:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.psigned]
    movzx     r10,	byte ptr[r10 + rax]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	1
    call      mc_auxmcl.do_divrem
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_irem
mc_genmcl.px_irem:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.psigned]
    movzx     r10,	byte ptr[r10 + rax]
    mov       rcx,	rdi
    mov       rdx,	r10
    xor       r8d,	r8d
    call      mc_auxmcl.do_divrem
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_idivrem
mc_genmcl.px_idivrem:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.psigned]
    movzx     r10,	byte ptr[r10 + rax]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	2
    call      mc_auxmcl.do_divrem
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_clear
mc_genmcl.px_clear:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	6
    call      mc_stackmcl.getopnd_ind_simp
    mov       rdi,	rax
    mov       eax,	[rbx+4]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_auxmcl.clearblock
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_subp
mc_genmcl.px_subp:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	29
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movsxd    rax,	dword ptr[r12+16]
    cmp       rax,	1
    jle       L2089
    movsxd    rax,	dword ptr[r12+16]
    mov       rcx,	rax
    call      mc_libmcl.ispoweroftwo
    mov       rsi,	rax
    test      rsi,	rsi
    jz        L2091
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	45
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2090
L2091:
    call      msys.m$print_startcon
    movsxd    rax,	dword ptr[r12+16]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10615]
    lea       rdx,	[rip+L10616]
    call      pc_api.merror
L2090:
L2089:
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_switch
mc_genmcl.px_switch:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_switch.p, 64
    .set mc_genmcl.px_switch.bx, -8
    .set mc_genmcl.px_switch.ax2, -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+64],	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    movsxd    rax,	dword ptr[rax+16]
    mov       rdi,	rax
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    movsxd    rax,	dword ptr[rax+20]
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    mov       rsi,	[rax+8]
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    lea       rax,	[rax+32]
    mov       [rip+mc_decls.currpcl],	rax
    mov       rax,	[rip+mc_decls.currpcl]
    mov       r12,	[rax+8]
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r14,	rax
    mov       rax,	[rbp + mc_genmcl.px_switch.p]
    mov       eax,	[rax+4]
    cmp       rax,	8
    jge       L2094
    mov       rcx,	r14
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       r10,	rax
    mov       [rbp + mc_genmcl.px_switch.ax2],	r10
    mov       rcx,	18
    mov       rdx,	rax
    mov       r8,	r14
    call      mc_libmcl.genmc
    mov       r14,	[rbp + mc_genmcl.px_switch.ax2]
L2094:
    test      rdi,	rdi
    jz        L2096
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	r14
    mov       r8,	rax
    call      mc_libmcl.genmc
L2096:
    mov       rax,	rbx
    sub       rax,	rdi
    inc       rax
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	r14
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	3
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    movzx     rax,	byte ptr[rip+pc_api.phighmem]
    cmp       rax,	2
    jnz       L2098
    call      mc_stackmcl.getworkireg
    mov       r13,	rax
    mov       rcx,	r13
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_genmcl.px_switch.bx],	rax
    mov       rcx,	rsi
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	14
    mov       rdx,	[rbp + mc_genmcl.px_switch.bx]
    mov       r8,	rax
    call      mc_libmcl.genmc
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte ptr[r14+10]
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	8
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2097
L2098:
    sub       rsp,	8
    push      0
    mov       rax,	rsi
    push      rax
    push      0
    movzx     rax,	byte ptr[r14+10]
    xor       ecx,	ecx
    mov       rdx,	rax
    mov       r8,	8
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2097:
    call      mc_stackmcl.poppcl
    mov       rcx,	73
    mov       rdx,	1
    call      mc_libmcl.setsegment
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_switchu
mc_genmcl.px_switchu:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_switchu.p, 64
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       [rbp+64],	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + mc_genmcl.px_switchu.p]
    movsxd    rax,	dword ptr[rax+16]
    mov       rdi,	rax
    mov       rax,	[rbp + mc_genmcl.px_switchu.p]
    movsxd    rax,	dword ptr[rax+20]
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genmcl.px_switchu.p]
    mov       rsi,	[rax+8]
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r13,	rax
    movzx     rax,	byte ptr[rip+pc_api.phighmem]
    cmp       rax,	2
    jnz       L2101
    call      mc_stackmcl.getworkireg
    mov       r12,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	r12
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       r14,	rax
    mov       rcx,	rsi
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	14
    mov       rdx,	r14
    mov       r8,	rax
    call      mc_libmcl.genmc
    sub       rsp,	8
    push      0
    push      0
    push      0
    mov       rax,	rdi
    neg       rax
    shl       rax,	3
    movzx     r10,	byte ptr[r13+10]
    mov       rcx,	r12
    mov       rdx,	r10
    mov       r8,	8
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2100
L2101:
    sub       rsp,	8
    push      0
    mov       rax,	rsi
    push      rax
    push      0
    mov       rax,	rdi
    neg       rax
    shl       rax,	3
    movzx     r10,	byte ptr[r13+10]
    xor       ecx,	ecx
    mov       rdx,	r10
    mov       r8,	8
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2100:
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_swlabel
mc_genmcl.px_swlabel:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_endsw
mc_genmcl.px_endsw:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_endsw.p, 16
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_fwiden
mc_genmcl.px_fwiden:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rbx+28]
    and       rax,	255
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rcx,	89
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       al,	2
    lea       r10,	[rip+mc_decls.pclmode]
    mov       r11,	[rip+mc_decls.noperands]
    mov       [r10 + r11-1],	al
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_fnarrow
mc_genmcl.px_fnarrow:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rbx+28]
    and       rax,	255
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	88
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       al,	1
    lea       r10,	[rip+mc_decls.pclmode]
    mov       r11,	[rip+mc_decls.noperands]
    mov       [r10 + r11-1],	al
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_truncate
mc_genmcl.px_truncate:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rsi+28]
    and       rax,	255
    mov       bl,	al
    movzx     rax,	bl
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       eax,	[rsi+4]
    movzx     r10,	bl
    lea       r11,	[rip+pc_tables.psize]
    movzx     r11,	byte ptr[r11 + r10]
    cmp       rax,	r11
    jz        L2108
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.psize]
    movzx     r10,	byte ptr[r10 + rax]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mc_libmcl.changeopndsize
    movzx     r10,	bl
    lea       r11,	[rip+mc_decls.ploadop]
    movzx     r11,	byte ptr[r11 + r10]
    mov       rcx,	r11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2108:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_typepun
mc_genmcl.px_typepun:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rsi+28]
    and       rax,	255
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_libmcl.changeopndsize
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    movzx     r10,	byte ptr[rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.setnewzz
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_unload
mc_genmcl.px_unload:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_unload.p, 16
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_loadbit
mc_genmcl.px_loadbit:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_loadbit.p, 48
    .set mc_genmcl.px_loadbit.$T1, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       rbx,	rax
    test      rax,	rax
    jz        L2113
    mov       rsi,	[rbx+8]
    mov       rax,	rsi
    cmp       rax,	0
    jl        L2115
    cmp       rax,	31
    jg        L2115
    mov       rax,	5
    jmp       L2114
L2115:
    mov       rax,	6
L2114:
    mov       r12,	rax
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	r12
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    test      rsi,	rsi
    jz        L2117
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mc_libmcl.mgenint
    mov       rcx,	45
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    cmp       rsi,	63
    jz        L2120
L2119:
L2117:
    jmp       L2112
L2113:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       al,	[rip+pc_decls.r10used]
    test      al,	al
    jz        L2122
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2122:
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	3
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       rcx,	45
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       al,	[rip+pc_decls.r10used]
    test      al,	al
    jz        L2124
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2124:
L2112:
    mov       rcx,	1
    mov       rdx,	5
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_loadbit.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	38
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_loadbit.$T1]
    call      mc_libmcl.genmc
#mc_genmcl.px_loadbit.skip:
L2120:
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_assem
mc_genmcl.px_assem:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_api.idomcl_assem]
    test      rax,	rax
    jz        L2127
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    mov       r10,	[rip+pc_api.idomcl_assem]
    call      r10
    jmp       L2126
L2127:
    lea       rcx,	[rip+L10617]
    lea       rdx,	[rip+L10618]
    call      pc_api.merror
L2126:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_sin
mc_genmcl.px_sin:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    lea       rdx,	[rip+L10619]
    mov       r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_cos
mc_genmcl.px_cos:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    lea       rdx,	[rip+L10620]
    mov       r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_tan
mc_genmcl.px_tan:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    lea       rdx,	[rip+L10621]
    mov       r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_asin
mc_genmcl.px_asin:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    lea       rdx,	[rip+L10622]
    mov       r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_acos
mc_genmcl.px_acos:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    lea       rdx,	[rip+L10623]
    mov       r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_atan
mc_genmcl.px_atan:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    lea       rdx,	[rip+L10624]
    mov       r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_log
mc_genmcl.px_log:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    lea       rdx,	[rip+L10625]
    mov       r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_log10
mc_genmcl.px_log10:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    lea       rdx,	[rip+L10626]
    mov       r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_exp
mc_genmcl.px_exp:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    lea       rdx,	[rip+L10627]
    mov       r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_round
mc_genmcl.px_round:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    lea       rdx,	[rip+L10628]
    mov       r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_floor
mc_genmcl.px_floor:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    lea       rdx,	[rip+L10629]
    mov       r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_ceil
mc_genmcl.px_ceil:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    lea       rdx,	[rip+L10630]
    mov       r8,	1
    call      mc_auxmcl.do_maths
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_atan2
mc_genmcl.px_atan2:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	rdi
    lea       rdx,	[rip+L10631]
    mov       r8,	2
    call      mc_auxmcl.do_maths
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_fmod
mc_genmcl.px_fmod:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	rdi
    lea       rdx,	[rip+L10632]
    mov       r8,	2
    call      mc_auxmcl.do_maths
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_setcc
mc_genmcl.px_setcc:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    movzx     rax,	byte ptr[r13+2]
    lea       r10,	[rip+mc_genmcl.ucondcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rdi,	r10
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	11
    jnz       L2144
    lea       rcx,	[rip+L10633]
    lea       rdx,	[rip+L10634]
    call      pc_api.merror
    jmp       L2143
L2144:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jle       L2145
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2147
    movzx     rax,	byte ptr[r13+2]
    lea       r10,	[rip+mc_genmcl.scondcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rdi,	r10
L2147:
    mov       rcx,	42
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       r12,	rax
    jmp       L2143
L2145:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	3
    call      mc_stackmcl.getworkregm
    mov       r12,	rax
    movzx     rax,	byte ptr[r12+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_stackmcl.setnewzz
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
L2143:
    mov       rcx,	58
    mov       rdx,	rdi
    mov       r8,	r12
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	r12
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	19
    mov       rdx,	rax
    mov       r8,	r12
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_min
mc_genmcl.px_min:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_min.p, 16
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jle       L2150
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2152
    mov       rax,	15
    jmp       L2151
L2152:
    mov       rax,	7
L2151:
    mov       rcx,	rax
    call      mc_auxmcl.do_max_int
    jmp       L2149
L2150:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    dec       rax
    mov       r10,	112
    add       r10,	rax
    mov       rcx,	r10
    call      mc_auxmcl.do_max_float
L2149:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_max
mc_genmcl.px_max:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_max.p, 16
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jle       L2155
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2157
    mov       rax,	12
    jmp       L2156
L2157:
    mov       rax,	2
L2156:
    mov       rcx,	rax
    call      mc_auxmcl.do_max_int
    jmp       L2154
L2155:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    dec       rax
    mov       r10,	113
    add       r10,	rax
    mov       rcx,	r10
    call      mc_auxmcl.do_max_float
L2154:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_power
mc_genmcl.px_power:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jle       L2160
    mov       rcx,	82
    call      mc_auxmcl.gethostfn
    mov       rdi,	rax
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	2
    call      mc_auxmcl.do_host
    jmp       L2159
L2160:
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	rbx
    lea       rdx,	[rip+L10635]
    mov       r8,	2
    call      mc_auxmcl.do_maths
L2159:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_minto
mc_genmcl.px_minto:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_minto.p, 16
    .set mc_genmcl.px_minto.$T1, -8
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jle       L2163
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       [rbp + mc_genmcl.px_minto.$T1],	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2165
    mov       rax,	14
    jmp       L2164
L2165:
    mov       rax,	6
L2164:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_minto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L2162
L2163:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	6
    mov       rdx,	rax
    call      mc_auxmcl.do_maxto_real
L2162:
#---------------
    add       rsp,	48
    pop       rbp
    ret       
# End 
# Proc mc_genmcl.px_maxto
mc_genmcl.px_maxto:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_maxto.p, 16
    .set mc_genmcl.px_maxto.$T1, -8
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jle       L2168
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       [rbp + mc_genmcl.px_maxto.$T1],	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.psigned]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2170
    mov       rax,	13
    jmp       L2169
L2170:
    mov       rax,	3
L2169:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genmcl.px_maxto.$T1]
    call      mc_auxmcl.do_maxto_int
    jmp       L2167
L2168:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	3
    mov       rdx,	rax
    call      mc_auxmcl.do_maxto_real
L2167:
#---------------
    add       rsp,	48
    pop       rbp
    ret       
# End 
# Proc mc_genmcl.px_negto
mc_genmcl.px_negto:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_negto.p, 32
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jle       L2173
    mov       rcx,	50
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2172
L2173:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.do_negreal
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2172:
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_absto
mc_genmcl.px_absto:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_absto.p, 40
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jle       L2176
    xor       ecx,	ecx
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rax,	[rip+pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	26
    mov       rdx,	13
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	50
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2175
L2176:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.do_absreal
L2175:
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_addpxto
mc_genmcl.px_addpxto:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       rsi,	rax
    test      rax,	rax
    jz        L2179
    mov       rax,	[rsi+8]
    movsxd    r10,	dword ptr[r12+16]
    imul      rax,	r10
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2178
L2179:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movsxd    rax,	dword ptr[r12+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2178:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_subpxto
mc_genmcl.px_subpxto:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       rsi,	rax
    test      rax,	rax
    jz        L2182
    mov       rax,	[rsi+8]
    movsxd    r10,	dword ptr[r12+16]
    imul      rax,	r10
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2181
L2182:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movsxd    rax,	dword ptr[r12+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    mov       rcx,	29
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       eax,	[r12+20]
    test      eax,	eax
    jz        L2184
    lea       rcx,	[rip+L10636]
    lea       rdx,	[rip+L10637]
    call      pc_api.merror
L2184:
L2181:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_divto
mc_genmcl.px_divto:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	71
    call      mc_auxmcl.do_binto_float
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_bitnotto
mc_genmcl.px_bitnotto:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_bitnotto.p, 24
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rcx,	51
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_notto
mc_genmcl.px_notto:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_notto.p, 24
    .set mc_genmcl.px_notto.$T1, -8
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rcx,	1
    mov       rdx,	3
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_notto.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	40
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_notto.$T1]
    call      mc_libmcl.genmc
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_toboolto
mc_genmcl.px_toboolto:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_toboolto.p, 40
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       rsi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	41
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	58
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	19
    mov       rdx,	rax
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rdi
    call      mc_libmcl.genmc
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_sign
mc_genmcl.px_sign:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_sign.p, 64
    .set mc_genmcl.px_sign.ltop, -8
    .set mc_genmcl.px_sign.$T1, -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       rcx,	10
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	rbx
    call      mc_libmcl.clearreg
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jg        L2191
    mov       r14b,	7
    mov       al,	2
    mov       [rbp + mc_genmcl.px_sign.ltop],	al
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    movq      XMM0,	[rip+L10638]
    mov       rdx,	rax
    call      mc_libmcl.mgenrealmem
    movzx     r10,	byte ptr[rip+mc_decls.pmode]
    dec       r10
    mov       r11,	73
    add       r11,	r10
    mov       rcx,	r11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2190
L2191:
    mov       r14b,	15
    mov       al,	12
    mov       [rbp + mc_genmcl.px_sign.ltop],	al
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    xor       ecx,	ecx
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2190:
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rax,	[rip+pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       rsi,	r10
    movzx     r10,	r14b
    mov       rcx,	26
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rax,	[rip+pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       r12,	r10
    movzx     r10,	byte ptr[rbp + mc_genmcl.px_sign.ltop]
    mov       rcx,	26
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rax,	[rip+pc_api.mlabelno]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       r13,	r10
    mov       rcx,	25
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_genmcl.px_sign.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_genmcl.px_sign.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	25
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	r12
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rbx+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_stackmcl.setnewzz
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_loadbf
mc_genmcl.px_loadbf:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       rdi,	rax
    mov       rcx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       rbx,	rax
    test      rdi,	rdi
    jz        L2194
    test      rbx,	rbx
    jz        L2194
    mov       rax,	[rbx+8]
    mov       r10,	[rdi+8]
    mov       rcx,	rsi
    mov       rdx,	r10
    mov       r8,	rax
    call      mc_auxmcl.do_loadbf_const
    jmp       L2193
L2194:
    mov       rcx,	rsi
    call      mc_auxmcl.do_loadbf_var
L2193:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_storebit
mc_genmcl.px_storebit:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      mc_auxmcl.do_storebit
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_storebf
mc_genmcl.px_storebf:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      mc_auxmcl.do_storebf
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_loadall
mc_genmcl.px_loadall:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_loadall.p, 16
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      mc_stackmcl.checkallloaded
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_genmcl.px_setjmp
mc_genmcl.px_setjmp:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.mcreatefwdlabel
    mov       rsi,	rax
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
    mov       rcx,	6
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rdi,	rax
    mov       rcx,	rsi
    call      mc_libmcl.mgenlabel
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	8
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rip+mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	16
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rip+mc_decls.dframeopnd]
    call      mc_libmcl.genmc
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       rcx,	rdi
    call      mc_libmcl.clearreg
    mov       rcx,	r12
    call      mc_stackmcl.freeworkregs
    mov       rcx,	1
    call      mc_stackmcl.movetoreg
    mov       rcx,	rsi
    call      mc_libmcl.mdefinefwdlabel
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_longjmp
mc_genmcl.px_longjmp:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_longjmp.p, 40
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	8
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	[rip+mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	rdi
    mov       rdx,	16
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	[rip+mc_decls.dframeopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	6
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[rip+mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    mov       rdx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
    mov       rcx,	1
    call      mc_stackmcl.swapopndregs
    mov       rcx,	25
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genmcl.px_initdswx
mc_genmcl.px_initdswx:
#PROC1
#PROC2
#?>>
    .set mc_genmcl.px_initdswx.p, 16
#?]]
#---------------
#PROC3
#PROC4
#---------------
    ret       
# End 
# Proc mc_auxmcl.allocregvars
mc_auxmcl.allocregvars:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.allocregvars.params, -32
    .set mc_auxmcl.allocregvars.xparams, -64
    .set mc_auxmcl.allocregvars.leafparams, -96
    .set mc_auxmcl.allocregvars.xleafparams, -128
    .set mc_auxmcl.allocregvars.leafparamno, -136
    .set mc_auxmcl.allocregvars.xleafparamno, -144
    .set mc_auxmcl.allocregvars.locals, -400
    .set mc_auxmcl.allocregvars.xlocals, -656
    .set mc_auxmcl.allocregvars.reg, -664
    .set mc_auxmcl.allocregvars.nl, -672
    .set mc_auxmcl.allocregvars.np, -680
    .set mc_auxmcl.allocregvars.nlx, -688
    .set mc_auxmcl.allocregvars.npx, -696
    .set mc_auxmcl.allocregvars.d, -704
    .set mc_auxmcl.allocregvars.i, -712
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	712
#---------------
#PROC3
#PROC4
    xor       rdi,	rdi
    xor       eax,	eax
    mov       rbx,	rax
    xor       rsi,	rsi
    xor       eax,	eax
    mov       r12,	rax
    xor       r13,	r13
    xor       eax,	eax
    mov       r14,	rax
    mov       rax,	[rip+mc_decls.maxregvars]
    add       rax,	[rip+mc_decls.maxxregvars]
    test      rax,	rax
    jz        L2201
L2203:
    test      rcx,	rcx
    jnz       L2205
    mov       rax,	[rip+pc_decls.currfunc]
    mov       rax,	[rax+16]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    xor       r15,	r15
    jmp       L2209
L2206:
    inc       r15
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+92]
    test      al,	al
    jz        L2211
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+91]
    test      al,	al
    jnz       L2211
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+88]
    test      al,	al
    jnz       L2211
    cmp       r15,	4
    jg        L2211
    test      rdx,	rdx
    jnz       L2213
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte ptr[rax+82]
    lea       r10,	[rip+pc_tables.pint]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2215
    cmp       rdi,	4
    jge       L2217
    inc       rdi
    mov       rax,	rdi
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.params-8],	r10
L2217:
    jmp       L2214
L2215:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte ptr[rax+82]
    lea       r10,	[rip+pc_tables.pfloat]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2218
    cmp       rbx,	4
    jge       L2220
    inc       rbx
    mov       rax,	rbx
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.xparams-8],	r10
L2220:
L2218:
L2214:
    jmp       L2212
L2213:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte ptr[rax+82]
    lea       r10,	[rip+pc_tables.pint]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2222
    cmp       rsi,	4
    jge       L2224
    inc       rsi
    mov       rax,	rsi
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.leafparams-8],	r10
    mov       [rbp + rsi + mc_auxmcl.allocregvars.leafparamno-1],	r15b
L2224:
    jmp       L2221
L2222:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte ptr[rax+82]
    lea       r10,	[rip+pc_tables.pfloat]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2225
    cmp       r12,	4
    jge       L2227
    inc       r12
    mov       rax,	r12
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.xleafparams-8],	r10
    mov       [rbp + r12 + mc_auxmcl.allocregvars.xleafparamno-1],	r15b
L2227:
L2225:
L2221:
L2212:
L2211:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       rax,	[rax+16]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
L2209:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    test      rax,	rax
    jnz       L2206
L2205:
    mov       rax,	[rip+pc_decls.currfunc]
    mov       rax,	[rax+24]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    jmp       L2231
L2228:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+92]
    test      al,	al
    jz        L2233
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+91]
    test      al,	al
    jnz       L2233
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       al,	[rax+88]
    test      al,	al
    jnz       L2233
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte ptr[rax+82]
    lea       r10,	[rip+pc_tables.pint]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2235
    cmp       r13,	32
    jge       L2237
    inc       r13
    mov       rax,	r13
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.locals-8],	r10
L2237:
    jmp       L2234
L2235:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    movzx     rax,	byte ptr[rax+82]
    lea       r10,	[rip+pc_tables.pfloat]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2238
    cmp       r14,	32
    jge       L2238
    inc       r14
    mov       rax,	r14
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [rbp + rax*8 + mc_auxmcl.allocregvars.xlocals-8],	r10
L2238:
L2234:
L2233:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    mov       rax,	[rax+24]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
L2231:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.d]
    test      rax,	rax
    jnz       L2228
    test      r13,	r13
    jnz       L2240
    mov       rax,	[rip+mc_decls.maxregvars]
    mov       r10,	rdi
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       [rbp + mc_auxmcl.allocregvars.np],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.allocregvars.nl],	rax
    jmp       L2239
L2240:
    test      rdi,	rdi
    jnz       L2241
    mov       rax,	[rip+mc_decls.maxregvars]
    mov       r10,	r13
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       [rbp + mc_auxmcl.allocregvars.nl],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.allocregvars.np],	rax
    jmp       L2239
L2241:
    mov       [rbp + mc_auxmcl.allocregvars.nl],	r13
    mov       [rbp + mc_auxmcl.allocregvars.np],	rdi
    mov       rax,	[rbp + mc_auxmcl.allocregvars.np]
    add       rax,	[rbp + mc_auxmcl.allocregvars.nl]
    sub       rax,	[rip+mc_decls.maxregvars]
    mov       r15,	rax
    cmp       r15,	0
    jle       L2243
    dec       qword ptr[rbp + mc_auxmcl.allocregvars.np]
    dec       r15
    cmp       r15,	0
    jle       L2245
    mov       rax,	[rbp + mc_auxmcl.allocregvars.np]
    cmp       rax,	0
    jle       L2245
    dec       qword ptr[rbp + mc_auxmcl.allocregvars.np]
    dec       r15
L2245:
    cmp       r15,	0
    jle       L2247
    mov       rax,	r15
    sub       [rbp + mc_auxmcl.allocregvars.nl],	rax
L2247:
L2243:
L2239:
    mov       rax,	4
    mov       [rbp + mc_auxmcl.allocregvars.reg],	rax
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.nl]
    cmp       rax,	1
    jl        L2250
L2248:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.locals-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.isregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    inc       qword ptr[rbp + mc_auxmcl.allocregvars.reg]
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.allocregvars.nl]
    jle       L2248
L2250:
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.np]
    cmp       rax,	1
    jl        L2253
L2251:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.params-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.isregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    inc       qword ptr[rbp + mc_auxmcl.allocregvars.reg]
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.allocregvars.np]
    jle       L2251
L2253:
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rsi,	1
    jl        L2256
L2254:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.leafparams-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    movzx     rax,	byte ptr[rbp + rax + mc_auxmcl.allocregvars.leafparamno-1]
    add       rax,	11
    dec       rax
    mov       [rbp + mc_auxmcl.allocregvars.reg],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.reg]
    cmp       rax,	11
    jnz       L2258
    mov       al,	1
    mov       [rip+pc_decls.r10used],	al
L2258:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.reg]
    cmp       rax,	12
    jnz       L2260
    mov       al,	1
    mov       [rip+pc_decls.r11used],	al
L2260:
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.isregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	rsi
    jle       L2254
L2256:
    test      r14,	r14
    jnz       L2262
    mov       rax,	[rip+mc_decls.maxxregvars]
    mov       r10,	rbx
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       [rbp + mc_auxmcl.allocregvars.npx],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.allocregvars.nlx],	rax
    jmp       L2261
L2262:
    test      rbx,	rbx
    jnz       L2263
    mov       rax,	[rip+mc_decls.maxxregvars]
    mov       r10,	r14
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       [rbp + mc_auxmcl.allocregvars.nlx],	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.allocregvars.npx],	rax
    jmp       L2261
L2263:
    mov       [rbp + mc_auxmcl.allocregvars.nlx],	r14
    mov       [rbp + mc_auxmcl.allocregvars.npx],	rbx
    mov       rax,	[rbp + mc_auxmcl.allocregvars.npx]
    add       rax,	[rbp + mc_auxmcl.allocregvars.nlx]
    sub       rax,	[rip+mc_decls.maxregvars]
    mov       r15,	rax
    cmp       r15,	0
    jle       L2265
    dec       qword ptr[rbp + mc_auxmcl.allocregvars.npx]
    dec       r15
    cmp       r15,	0
    jle       L2267
    mov       rax,	[rbp + mc_auxmcl.allocregvars.npx]
    cmp       rax,	0
    jle       L2267
    dec       qword ptr[rbp + mc_auxmcl.allocregvars.npx]
    dec       r15
L2267:
    cmp       r15,	0
    jle       L2269
    mov       rax,	r15
    sub       [rbp + mc_auxmcl.allocregvars.nlx],	rax
L2269:
L2265:
L2261:
    mov       rax,	16
    mov       [rbp + mc_auxmcl.allocregvars.reg],	rax
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.nlx]
    cmp       rax,	1
    jl        L2272
L2270:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.xlocals-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.isxregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    dec       qword ptr[rbp + mc_auxmcl.allocregvars.reg]
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.allocregvars.nlx]
    jle       L2270
L2272:
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.npx]
    cmp       rax,	1
    jl        L2275
L2273:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.xparams-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.isxregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    dec       qword ptr[rbp + mc_auxmcl.allocregvars.reg]
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.allocregvars.npx]
    jle       L2273
L2275:
    mov       rax,	1
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       r12,	1
    jl        L2278
L2276:
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    mov       rax,	[rbp + rax*8 + mc_auxmcl.allocregvars.xleafparams-8]
    mov       [rbp + mc_auxmcl.allocregvars.d],	rax
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    movzx     rax,	byte ptr[rbp + rax + mc_auxmcl.allocregvars.xleafparamno-1]
    inc       rax
    dec       rax
    mov       [rbp + mc_auxmcl.allocregvars.reg],	rax
    mov       al,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       r10,	[rbp + mc_auxmcl.allocregvars.d]
    mov       [r10+90],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.isxregvar]
    mov       r11,	[rbp + mc_auxmcl.allocregvars.reg]
    mov       [r10 + r11-1],	al
    mov       rax,	[rbp + mc_auxmcl.allocregvars.i]
    inc       rax
    mov       [rbp + mc_auxmcl.allocregvars.i],	rax
    cmp       rax,	r12
    jle       L2276
L2278:
L2201:
#---------------
    add       rsp,	712
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.initproc
mc_auxmcl.initproc:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.initproc.$T1, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.regset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[rip+mc_decls.xregset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[rip+mc_decls.workregs]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[rip+mc_decls.workxregs]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[rip+mc_decls.isregvar]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[rip+mc_decls.isxregvar]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       rax,	3
    mov       [rip+mc_decls.nworkregs],	rax
    mov       al,	1
    lea       r10,	[rip+mc_decls.workregs]
    mov       [r10],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.workregs]
    mov       [r10+1],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.workregs]
    mov       [r10+2],	al
    mov       rax,	2
    mov       [rip+mc_decls.nworkxregs],	rax
    mov       al,	1
    lea       r10,	[rip+mc_decls.workxregs]
    mov       [r10+4],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.workxregs]
    mov       [r10+5],	al
    xor       eax,	eax
    mov       [rip+mc_decls.maxxregvars],	rax
    mov       [rip+mc_decls.maxregvars],	rax
    xor       r12,	r12
    mov       rax,	[rip+pc_decls.currfunc]
    mov       rax,	[rax+48]
    mov       [rip+pc_decls.pinfo],	rax
    mov       rax,	[rip+pc_decls.pinfo]
    test      rax,	rax
    jnz       L2281
    mov       rax,	10
    mov       [rip+mc_decls.nworkregs],	rax
    mov       rax,	12
    mov       [rip+mc_decls.nworkxregs],	rax
    mov       rsi,	4
L2282:
    mov       al,	1
    lea       r10,	[rip+mc_decls.workregs]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    inc       rsi
    cmp       rsi,	10
    jle       L2282
    mov       rsi,	7
L2285:
    mov       al,	1
    lea       r10,	[rip+mc_decls.workxregs]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    inc       rsi
    cmp       rsi,	16
    jle       L2285
    jmp       L2280
L2281:
    mov       rax,	[rip+pc_decls.currfunc]
    movzx     rax,	byte ptr[rax+112]
    mov       r10,	[rip+pc_decls.pinfo]
    movzx     r10,	byte ptr[r10+4]
    cmp       rax,	r10
    cmovl     rax,	r10
    mov       r10,	4
    cmp       r10,	rax
    cmovg     r10,	rax
    mov       r12,	r10
    mov       rax,	4
    mov       [rip+mc_decls.nworkregs],	rax
    mov       rax,	[rip+pc_decls.pinfo]
    mov       al,	[rax+7]
    test      al,	al
    jz        L2289
    inc       qword ptr[rip+mc_decls.nworkregs]
L2289:
    mov       rax,	5
    mov       [rip+mc_decls.nworkxregs],	rax
    mov       rax,	[rip+mc_decls.nworkregs]
    sub       rax,	3
    mov       rbx,	rax
    cmp       r12,	3
    jg        L2291
    test      rbx,	rbx
    jz        L2291
    mov       al,	1
    lea       r10,	[rip+mc_decls.workregs]
    mov       [r10+13],	al
    dec       rbx
    cmp       r12,	2
    jg        L2293
    test      rbx,	rbx
    jz        L2293
    mov       al,	1
    lea       r10,	[rip+mc_decls.workregs]
    mov       [r10+12],	al
    dec       rbx
L2293:
L2291:
    mov       rsi,	10
    mov       r13,	rbx
    cmp       r13,	0
    jle       L2296
L2294:
    mov       rax,	rsi
    dec       rsi
    mov       r10b,	1
    lea       r11,	[rip+mc_decls.workregs]
    mov       [r11 + rax-1],	r10b
    dec       r13
    jnz       L2294
L2296:
    mov       rsi,	7
    mov       rax,	[rip+mc_decls.nworkxregs]
    sub       rax,	2
    mov       r14,	rax
    cmp       r14,	0
    jle       L2299
L2297:
    mov       rax,	rsi
    inc       rsi
    mov       r10b,	1
    lea       r11,	[rip+mc_decls.workxregs]
    mov       [r11 + rax-1],	r10b
    dec       r14
    jnz       L2297
L2299:
L2280:
    mov       rsi,	4
L2300:
    lea       rax,	[rip+mc_decls.workregs]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2304
    inc       qword ptr[rip+mc_decls.maxregvars]
L2304:
    inc       rsi
    cmp       rsi,	10
    jle       L2300
    mov       rsi,	7
L2305:
    lea       rax,	[rip+mc_decls.workxregs]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2309
    inc       qword ptr[rip+mc_decls.maxxregvars]
L2309:
    inc       rsi
    cmp       rsi,	16
    jle       L2305
    lea       rax,	[rip+mc_decls.usedregs]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[rip+mc_decls.usedxregs]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[rip+mc_decls.pcltempflags]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    mov       [rax+40],	r10
    mov       [rax+48],	r10w
    xor       eax,	eax
    mov       [rip+pc_decls.r11used],	al
    mov       [rip+pc_decls.r10used],	al
    xor       eax,	eax
    mov       [rip+mc_decls.mstackdepth],	rax
    xor       eax,	eax
    mov       [rip+mc_decls.noperands],	rax
    xor       eax,	eax
    mov       [rip+mc_genmcl.framebytes],	rax
    mov       [rip+mc_genmcl.paramoffset],	rax
    mov       [rip+mc_genmcl.frameoffset],	rax
    xor       eax,	eax
    mov       [rip+pc_decls.localshadow],	al
    xor       eax,	eax
    mov       [rip+mc_decls.nblocktemps],	rax
    movzx     rax,	byte ptr[r15+82]
    cmp       rax,	11
    jnz       L2311
    lea       rcx,	[rip+L10639]
    mov       rdx,	8
    call      pc_api.pc_makesymbol
    mov       rdi,	rax
    mov       al,	[r15+82]
    mov       [rdi+82],	al
    mov       al,	1
    mov       [rdi+92],	al
    mov       al,	5
    mov       [rdi+72],	al
    mov       rax,	[rip+pc_decls.currfunc]
    mov       rax,	[rax+16]
    mov       [rdi+16],	rax
    mov       rax,	[rip+pc_decls.currfunc]
    mov       [rdi+32],	rax
    mov       rax,	rdi
    mov       r10,	[rip+pc_decls.currfunc]
    mov       [r10+16],	rax
    mov       [rip+pc_decls.blockretname],	rdi
L2311:
    mov       al,	[rip+pc_decls.fregoptim]
    test      al,	al
    jz        L2314
    mov       rax,	[rip+pc_decls.currfunc]
    mov       rax,	[rax+48]
    test      rax,	rax
    jnz       L2313
L2314:
    jmp       L2279
L2313:
    mov       rax,	[rip+pc_decls.currfunc]
    mov       rax,	[rax+48]
    mov       al,	[rax+5]
    test      al,	al
    jnz       L2279
L2316:
    mov       rax,	[rip+pc_decls.currfunc]
    mov       rax,	[rax+48]
    movzx     rax,	byte ptr[rax+3]
    mov       [rbp + mc_auxmcl.initproc.$T1],	rax
    mov       rax,	[rip+pc_decls.currfunc]
    mov       al,	[rax+110]
    test      al,	al
    jnz       L2317
    mov       rax,	[rip+pc_decls.currfunc]
    mov       al,	[rax+113]
    test      al,	al
    jz        L2318
L2317:
    mov       rax,	1
    jmp       L2319
L2318:
    xor       eax,	eax
L2319:
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.initproc.$T1]
    call      mc_auxmcl.allocregvars
L2279:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_procentry
mc_auxmcl.do_procentry:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_procentry.p, 72
    .set mc_auxmcl.do_procentry.ff, -8
    .set mc_auxmcl.do_procentry.r, -16
    .set mc_auxmcl.do_procentry.i, -24
    .set mc_auxmcl.do_procentry.$T1, -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	72
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_decls.mclprocentry]
    call      mc_auxmcl.setmclentry
    xor       eax,	eax
    mov       [rip+pc_decls.bxspill],	rax
    mov       [rip+pc_decls.bspill],	rax
    mov       rax,	[rip+pc_decls.currfunc]
    mov       rax,	[rax+48]
    test      rax,	rax
    jz        L2323
    mov       rax,	[rip+pc_decls.currfunc]
    mov       rax,	[rax+48]
    mov       al,	[rax+5]
    test      al,	al
    jnz       L2322
L2323:
    mov       rax,	4
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
L2324:
    lea       rax,	[rip+mc_decls.usedregs]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2329
    lea       rax,	[rip+mc_decls.isregvar]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2328
L2329:
    inc       qword ptr[rip+pc_decls.bspill]
L2328:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    cmp       rax,	10
    jle       L2324
    mov       rax,	7
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
L2330:
    lea       rax,	[rip+mc_decls.usedxregs]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2335
    lea       rax,	[rip+mc_decls.isxregvar]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2334
L2335:
    inc       qword ptr[rip+pc_decls.bxspill]
L2334:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    cmp       rax,	16
    jle       L2330
L2322:
    mov       rax,	[rip+pc_decls.currfunc]
    mov       r14,	[rax+16]
    jmp       L2339
L2336:
    mov       al,	[r14+91]
    test      al,	al
    jz        L2341
    lea       rcx,	[rip+L10640]
    lea       rdx,	[rip+L10641]
    call      pc_api.merror
L2341:
    mov       al,	[r14+90]
    test      al,	al
    jnz       L2343
    mov       rax,	[rip+mc_genmcl.paramoffset]
    add       rax,	16
    mov       r10,	[rip+pc_decls.bspill]
    add       r10,	[rip+pc_decls.bxspill]
    shl       r10,	3
    add       rax,	r10
    mov       [r14+76],	eax
    movsxd    rax,	dword ptr[r14+76]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	r14
    call      mc_writegas.getdispname
    mov       rcx,	rax
    call      mc_libmcl.mgenname
    mov       rcx,	5
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    jmp       L2342
L2343:
    movzx     rax,	byte ptr[r14+90]
    mov       r15,	rax
    lea       rax,	[rip+mc_decls.usedregs]
    movzx     rax,	byte ptr[rax+14]
    mov       [rbp + mc_auxmcl.do_procentry.ff],	rax
    xor       eax,	eax
    mov       [r14+90],	al
    movzx     rax,	byte ptr[r14+82]
    mov       rcx,	r15
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	r14
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	6
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    mov       [r14+90],	r15b
    mov       al,	[rbp + mc_auxmcl.do_procentry.ff]
    lea       r10,	[rip+mc_decls.usedregs]
    mov       [r10+14],	al
L2342:
    mov       rax,	8
    add       [rip+mc_genmcl.paramoffset],	rax
    mov       r14,	[r14+16]
L2339:
    test      r14,	r14
    jnz       L2336
    mov       rax,	[rip+pc_decls.currfunc]
    movzx     rax,	byte ptr[rax+82]
    mov       rdi,	rax
    mov       rax,	[rip+pc_decls.currfunc]
    mov       r14,	[rax+24]
    jmp       L2347
L2344:
    movzx     rax,	byte ptr[r14+82]
    lea       r10,	[rip+pc_tables.psize]
    movzx     r10,	byte ptr[r10 + rax]
    mov       r12,	r10
    movzx     rax,	byte ptr[r14+82]
    cmp       rax,	11
    jnz       L2349
    mov       eax,	[r14+84]
    mov       r12,	rax
L2349:
    mov       al,	[r14+92]
    test      al,	al
    jz        L2345
L2351:
    mov       al,	[r14+91]
    test      al,	al
    jz        L2353
    mov       rsi,	1
    jmp       L2352
L2353:
    mov       al,	[r14+90]
    test      al,	al
    jz        L2354
    movzx     rax,	byte ptr[r14+90]
    mov       r15,	rax
    lea       rax,	[rip+mc_decls.usedregs]
    movzx     rax,	byte ptr[rax+14]
    mov       [rbp + mc_auxmcl.do_procentry.ff],	rax
    xor       eax,	eax
    mov       [r14+90],	al
    movzx     rax,	byte ptr[r14+82]
    mov       rcx,	r15
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	r14
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	6
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
    mov       [r14+90],	r15b
    mov       al,	[rbp + mc_auxmcl.do_procentry.ff]
    lea       r10,	[rip+mc_decls.usedregs]
    mov       [r10+14],	al
    jmp       L2352
L2354:
    mov       rcx,	r12
    call      mc_libmcl.roundsizetg
    sub       [rip+mc_genmcl.frameoffset],	rax
    mov       eax,	[rip+mc_genmcl.frameoffset]
    mov       [r14+76],	eax
    movsxd    rax,	dword ptr[r14+76]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	r14
    call      mc_writegas.getdispname
    mov       rcx,	rax
    call      mc_libmcl.mgenname
    mov       rcx,	5
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L2352:
L2345:
    mov       r14,	[r14+24]
L2347:
    test      r14,	r14
    jnz       L2344
    xor       rbx,	rbx
    mov       rax,	1
    mov       [rbp + mc_auxmcl.do_procentry.i],	rax
L2355:
    lea       rax,	[rip+mc_decls.pcltempflags]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.i]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2359
    inc       rbx
    mov       rax,	8
    sub       [rip+mc_genmcl.frameoffset],	rax
    lea       rax,	[rip+mc_decls.pcltempopnds]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.i]
    mov       r13,	[rax + r10*8-8]
    mov       eax,	[rip+mc_genmcl.frameoffset]
    mov       [r13+12],	eax
    movsxd    rax,	dword ptr[r13+12]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_procentry.$T1],	rax
    mov       rcx,	[rip+pc_decls.currfunc]
    mov       rdx,	[rbp + mc_auxmcl.do_procentry.i]
    call      mc_writegas.gettempname
    mov       rcx,	rax
    call      mc_libmcl.mgenname
    mov       rcx,	5
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_procentry.$T1]
    call      mc_libmcl.genmc
L2359:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.i]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.i],	rax
    cmp       rax,	50
    jle       L2355
    mov       rax,	[rip+pc_decls.currfunc]
    mov       al,	[rax+108]
    test      al,	al
    jz        L2361
    mov       rax,	[rip+pc_decls.currfunc]
    mov       ax,	[rax+114]
    test      ax,	ax
    jnz       L2364
    mov       rax,	[rip+pc_decls.currfunc]
    mov       al,	[rax+112]
    test      al,	al
    jz        L2363
L2364:
    lea       rcx,	[rip+L10642]
    lea       rdx,	[rip+L10643]
    call      pc_api.merror
L2363:
    test      rbx,	rbx
    jz        L2366
    lea       rcx,	[rip+L10644]
    lea       rdx,	[rip+L10645]
    call      pc_api.merror
L2366:
    call      mc_auxmcl.resetmclentry
    jmp       L2320
L2361:
    mov       rax,	[rip+mc_genmcl.frameoffset]
    neg       rax
    mov       [rip+mc_genmcl.framebytes],	rax
    mov       rax,	[rip+pc_decls.bspill]
    add       rax,	[rip+pc_decls.bxspill]
    and       eax,	1
    test      rax,	rax
    jz        L2368
    mov       rax,	[rip+mc_genmcl.framebytes]
    and       rax,	8
    jnz       L2370
    mov       rax,	8
    add       [rip+mc_genmcl.framebytes],	rax
L2370:
    jmp       L2367
L2368:
    mov       rax,	[rip+mc_genmcl.framebytes]
    and       rax,	8
    jz        L2372
    mov       rax,	8
    add       [rip+mc_genmcl.framebytes],	rax
L2372:
L2367:
    mov       al,	[rip+pc_decls.localshadow]
    test      al,	al
    jz        L2374
    mov       rax,	32
    add       [rip+mc_genmcl.framebytes],	rax
L2374:
    mov       rax,	[rip+pc_decls.bspill]
    test      rax,	rax
    jz        L2376
    mov       rax,	4
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
L2377:
    lea       rax,	[rip+mc_decls.usedregs]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2382
    lea       rax,	[rip+mc_decls.isregvar]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2381
L2382:
    mov       rcx,	[rbp + mc_auxmcl.do_procentry.r]
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2381:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    cmp       rax,	10
    jle       L2377
L2376:
    mov       rax,	[rip+pc_decls.bxspill]
    test      rax,	rax
    jz        L2384
    mov       rcx,	1
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       r13,	rax
    mov       rax,	7
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
L2385:
    lea       rax,	[rip+mc_decls.usedxregs]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L2390
    lea       rax,	[rip+mc_decls.isxregvar]
    mov       r10,	[rbp + mc_auxmcl.do_procentry.r]
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2389
L2390:
    mov       rcx,	[rbp + mc_auxmcl.do_procentry.r]
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	17
    mov       rdx,	r13
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	12
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2389:
    mov       rax,	[rbp + mc_auxmcl.do_procentry.r]
    inc       rax
    mov       [rbp + mc_auxmcl.do_procentry.r],	rax
    cmp       rax,	16
    jle       L2385
L2384:
    lea       rcx,	[rip+L10646]
    call      mc_libmcl.mgencomment
    mov       rax,	[rip+mc_decls.mccodex]
    mov       [rip+mc_auxmcl.mclframesetup],	rax
    call      mc_auxmcl.spillparams
    lea       rcx,	[rip+L10647]
    call      mc_libmcl.mgencomment
    call      mc_auxmcl.resetmclentry
L2320:
#---------------
    add       rsp,	72
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_procexit
mc_auxmcl.do_procexit:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+L10647]
    call      mc_libmcl.mgencomment
    mov       rax,	[rip+pc_decls.currfunc]
    mov       al,	[rax+108]
    test      al,	al
    jz        L2393
    mov       rcx,	22
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2391
L2393:
    mov       rcx,	[rip+mc_auxmcl.mclframesetup]
    call      mc_auxmcl.setmclentryf
    mov       rax,	[rip+mc_genmcl.framebytes]
    test      rax,	rax
    jnz       L2396
    mov       rax,	[rip+pc_decls.currfunc]
    mov       al,	[rax+112]
    test      al,	al
    jz        L2395
L2396:
    lea       rax,	[rip+mc_decls.usedregs]
    mov       al,	[rax+14]
    test      al,	al
    jz        L2398
    mov       rcx,	12
    mov       rdx,	[rip+mc_decls.dframeopnd]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	[rip+mc_decls.dframeopnd]
    mov       r8,	[rip+mc_decls.dstackopnd]
    call      mc_libmcl.genmc
    mov       rcx,	[rip+mc_genmcl.framebytes]
    call      mc_libmcl.pushstack
    jmp       L2397
L2398:
    mov       rax,	[rip+mc_genmcl.framebytes]
    test      rax,	rax
    jz        L2400
    mov       rax,	[rip+mc_genmcl.framebytes]
    add       rax,	8
    mov       rcx,	rax
    call      mc_libmcl.pushstack
L2400:
L2397:
L2395:
    call      mc_auxmcl.resetmclentryf
    mov       rax,	[rip+mc_genmcl.framebytes]
    test      rax,	rax
    jnz       L2403
    mov       rax,	[rip+pc_decls.currfunc]
    mov       al,	[rax+112]
    test      al,	al
    jz        L2402
L2403:
    lea       rax,	[rip+mc_decls.usedregs]
    mov       al,	[rax+14]
    test      al,	al
    jz        L2405
    mov       rcx,	[rip+mc_genmcl.framebytes]
    call      mc_libmcl.popstack
    mov       rcx,	13
    mov       rdx,	[rip+mc_decls.dframeopnd]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2404
L2405:
    mov       rax,	[rip+mc_genmcl.framebytes]
    test      rax,	rax
    jz        L2407
    mov       rax,	[rip+mc_genmcl.framebytes]
    add       rax,	8
    mov       rcx,	rax
    call      mc_libmcl.popstack
L2407:
L2404:
L2402:
    mov       rax,	[rip+pc_decls.bxspill]
    test      rax,	rax
    jz        L2409
    mov       rcx,	11
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rdi,	rax
    mov       rbx,	16
L2410:
    lea       rax,	[rip+mc_decls.usedxregs]
    mov       r10,	rbx
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2414
    mov       rcx,	13
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	17
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2414:
    dec       rbx
    cmp       rbx,	7
    jge       L2410
L2409:
    mov       rax,	[rip+pc_decls.bspill]
    test      rax,	rax
    jz        L2416
    mov       rbx,	10
L2417:
    lea       rax,	[rip+mc_decls.usedregs]
    mov       r10,	rbx
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2421
    mov       rcx,	rbx
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2421:
    dec       rbx
    cmp       rbx,	4
    jge       L2417
L2416:
    mov       rcx,	22
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2391:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.spillparams
mc_auxmcl.spillparams:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.spillparams.$T1, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rsi,	16
    xor       r12,	r12
    xor       eax,	eax
    mov       r12,	rax
    mov       rax,	[rip+pc_decls.currfunc]
    mov       rdi,	[rax+16]
    mov       rax,	[rip+pc_decls.currfunc]
    mov       al,	[rax+113]
    test      al,	al
    jz        L2424
    movsxd    rax,	dword ptr[rdi+76]
    mov       r13,	rax
    mov       rax,	[rip+pc_decls.currfunc]
    movzx     rax,	byte ptr[rax+112]
    mov       r14,	rax
    cmp       r14,	3
    jg        L2427
L2425:
    sub       rsp,	8
    push      0
    push      0
    push      8
    mov       rax,	r14
    shl       rax,	3
    add       rax,	r13
    mov       rcx,	15
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rbx,	rax
    lea       rax,	[r14+11]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    inc       r14
    cmp       r14,	3
    jle       L2425
L2427:
L2424:
    jmp       L2431
L2428:
    cmp       r12,	3
    jg        L2430
L2433:
    mov       al,	[rdi+92]
    test      al,	al
    jz        L2435
    mov       al,	[rdi+90]
    test      al,	al
    jnz       L2437
    sub       rsp,	8
    push      0
    push      0
    push      8
    movsxd    rax,	dword ptr[rdi+76]
    mov       rcx,	15
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rbx,	rax
    movzx     rax,	byte ptr[rdi+82]
    cmp       rax,	2
    jz        L2439
    cmp       rax,	1
    jz        L2440
    jmp       L2441
L2439:
    lea       rax,	[r12+1]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	17
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2438
L2440:
    lea       rax,	[r12+1]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       [rbp + mc_auxmcl.spillparams.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rcx,	16
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
    jmp       L2438
L2441:
    lea       rax,	[r12+11]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
L2438:
    jmp       L2436
L2437:
    mov       al,	[rdi+90]
    test      al,	al
    jz        L2442
    movzx     rax,	byte ptr[rdi+82]
    cmp       rax,	2
    jg        L2444
    movzx     rax,	byte ptr[rdi+90]
    cmp       rax,	5
    jl        L2446
    movzx     rax,	byte ptr[rdi+82]
    lea       r10,	[r12+1]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenxreg
    mov       [rbp + mc_auxmcl.spillparams.$T1],	rax
    movzx     rax,	byte ptr[rdi+90]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rcx,	17
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L2446:
    jmp       L2443
L2444:
    movzx     rax,	byte ptr[rdi+90]
    cmp       rax,	10
    jg        L2447
    movzx     rax,	byte ptr[rdi+82]
    lea       r10,	[r12+11]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.spillparams.$T1],	rax
    movzx     rax,	byte ptr[rdi+82]
    movzx     r10,	byte ptr[rdi+90]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.spillparams.$T1]
    call      mc_libmcl.genmc
L2447:
L2443:
L2442:
L2436:
L2435:
    mov       rax,	8
    add       rsi,	rax
    inc       r12
    mov       rdi,	[rdi+16]
L2431:
    test      rdi,	rdi
    jnz       L2428
L2430:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_jumptruefalse
mc_auxmcl.do_jumptruefalse:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jle       L2450
    mov       rcx,	41
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    jmp       L2449
L2450:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    dec       rax
    mov       r10,	76
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2449:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	r12
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_bitwise
mc_auxmcl.do_bitwise:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_bitwise.p, 40
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_shift
mc_auxmcl.do_shift:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_shift.p, 48
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	[rip+mc_decls.noperands]
    mov       rsi,	[rax + r10*8-8]
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    test      rax,	rax
    jnz       L2454
    movzx     rax,	byte ptr[rsi+1]
    cmp       rax,	4
    jnz       L2454
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2453
L2454:
    mov       al,	[rip+pc_decls.r10used]
    test      al,	al
    jz        L2456
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2456:
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	3
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	[rip+pc_decls.r10used]
    test      al,	al
    jz        L2458
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2458:
L2453:
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.setmclentry
mc_auxmcl.setmclentry:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.mccodex]
    mov       [rip+mc_decls.mce_oldmccodex],	rax
    mov       [rip+mc_decls.mccodex],	rcx
    mov       rax,	[rcx]
    mov       [rip+mc_decls.mce_lastmcl],	rax
    mov       rax,	[rcx+8]
    mov       [rip+mc_decls.mce_nextmcl],	rax
#---------------
    ret       
# End 
# Proc mc_auxmcl.resetmclentry
mc_auxmcl.resetmclentry:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.mce_lastmcl]
    mov       r10,	[rip+mc_decls.mccodex]
    mov       [r10],	rax
    mov       rax,	[rip+mc_decls.mce_nextmcl]
    mov       r10,	[rip+mc_decls.mccodex]
    mov       [r10+8],	rax
    mov       rdi,	[rip+mc_decls.mccodex]
    mov       rax,	[rip+mc_decls.mce_oldmccodex]
    mov       [rip+mc_decls.mccodex],	rax
    mov       rax,	rdi
L2460:
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.setmclentryf
mc_auxmcl.setmclentryf:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.mccodex]
    mov       [rip+mc_decls.mcf_oldmccodex],	rax
    mov       [rip+mc_decls.mccodex],	rcx
    mov       rax,	[rcx]
    mov       [rip+mc_decls.mcf_lastmcl],	rax
    mov       rax,	[rcx+8]
    mov       [rip+mc_decls.mcf_nextmcl],	rax
#---------------
    ret       
# End 
# Proc mc_auxmcl.resetmclentryf
mc_auxmcl.resetmclentryf:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.mcf_lastmcl]
    mov       r10,	[rip+mc_decls.mccodex]
    mov       [r10],	rax
    mov       rax,	[rip+mc_decls.mcf_nextmcl]
    mov       r10,	[rip+mc_decls.mccodex]
    mov       [r10+8],	rax
    mov       rdi,	[rip+mc_decls.mccodex]
    mov       rax,	[rip+mc_decls.mcf_oldmccodex]
    mov       [rip+mc_decls.mccodex],	rax
    mov       rax,	rdi
L2462:
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_pushlowargs
mc_auxmcl.do_pushlowargs:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_pushlowargs.nvariadics, 80
    .set mc_auxmcl.do_pushlowargs.isptr, 88
    .set mc_auxmcl.do_pushlowargs.imode, -8
    .set mc_auxmcl.do_pushlowargs.blockret, -16
    .set mc_auxmcl.do_pushlowargs.dblock, -24
    .set mc_auxmcl.do_pushlowargs.av_1, -32
    .set mc_auxmcl.do_pushlowargs.i, -40
    .set mc_auxmcl.do_pushlowargs.$T1, -48
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
#---------------
#PROC3
#PROC4
    test      r15,	r15
    jnz       L2465
    jmp       L2463
L2465:
    lea       rax,	[rip+mc_decls.callblockret]
    mov       r10,	[rip+mc_decls.ncalldepth]
    movzx     rax,	byte ptr[rax + r10-1]
    mov       [rbp + mc_auxmcl.do_pushlowargs.blockret],	rax
    mov       r12,	11
    mov       r13,	1
    xor       rsi,	rsi
    mov       rax,	[rip+mc_decls.noperands]
    mov       [rbp + mc_auxmcl.do_pushlowargs.i],	rax
    mov       rax,	[rip+mc_decls.noperands]
    sub       rax,	r15
    inc       rax
    mov       [rbp + mc_auxmcl.do_pushlowargs.av_1],	rax
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.i]
    cmp       rax,	[rbp + mc_auxmcl.do_pushlowargs.av_1]
    jl        L2468
L2466:
    inc       rsi
    cmp       rsi,	1
    jnz       L2470
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.blockret]
    test      rax,	rax
    jz        L2470
    lea       rax,	[rip+mc_decls.callblocksize]
    mov       r10,	[rip+mc_decls.ncalldepth]
    mov       eax,	[rax + r10*4-4]
    mov       rcx,	rax
    call      mc_libmcl.newblocktemp
    mov       [rbp + mc_auxmcl.do_pushlowargs.dblock],	rax
    mov       al,	1
    mov       r10,	[rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       [r10+92],	al
    mov       rcx,	[rbp + mc_auxmcl.do_pushlowargs.dblock]
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.do_pushlowargs.$T1],	rax
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
    jmp       L2469
L2470:
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.i]
    sub       rax,	[rbp + mc_auxmcl.do_pushlowargs.isptr]
    add       rax,	[rbp + mc_auxmcl.do_pushlowargs.blockret]
    mov       rbx,	rax
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	rbx
    movzx     rax,	byte ptr[rax + r10-1]
    mov       r14,	rax
    mov       rax,	r14
    cmp       rax,	11
    jz        L2472
    cmp       rax,	2
    jz        L2473
    cmp       rax,	1
    jz        L2473
    jmp       L2474
L2472:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r12
    call      mc_stackmcl.loadparam
    mov       rdi,	rax
    lea       rax,	[rip+mc_decls.callargsize]
    mov       r10,	[rip+mc_decls.ncalldepth]
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    mov       r10,	rsi
    mov       eax,	[rax + r10*4-4]
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	rsi
    call      mc_auxmcl.copyblockarg
    jmp       L2471
L2473:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r13
    call      mc_stackmcl.loadparam
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.nvariadics]
    test      rax,	rax
    jz        L2476
    cmp       rsi,	[rbp + mc_auxmcl.do_pushlowargs.nvariadics]
    jl        L2476
    cmp       r14,	1
    jnz       L2478
    mov       rax,	5
    jmp       L2477
L2478:
    mov       rax,	6
L2477:
    mov       [rbp + mc_auxmcl.do_pushlowargs.imode],	rax
    mov       rcx,	r13
    mov       rdx,	r14
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_pushlowargs.$T1],	rax
    mov       rcx,	r12
    mov       rdx,	[rbp + mc_auxmcl.do_pushlowargs.imode]
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_pushlowargs.$T1]
    call      mc_libmcl.genmc
L2476:
    jmp       L2471
L2474:
#mc_auxmcl.do_pushlowargs.doint:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r12
    call      mc_stackmcl.loadparam
L2471:
L2469:
    inc       r12
    inc       r13
    mov       rax,	[rbp + mc_auxmcl.do_pushlowargs.i]
    dec       rax
    mov       [rbp + mc_auxmcl.do_pushlowargs.i],	rax
    cmp       rax,	[rbp + mc_auxmcl.do_pushlowargs.av_1]
    jge       L2466
L2468:
L2463:
#---------------
    add       rsp,	88
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_getretvalue
mc_auxmcl.do_getretvalue:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_getretvalue.modes, -80
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[r12+32]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	13
    jnz       L2482
    xor       rbx,	rbx
    jmp       L2484
L2483:
    movzx     rax,	byte ptr[r12+3]
    inc       rbx
    mov       r10,	rbx
    mov       [rbp + r10*8 + mc_auxmcl.do_getretvalue.modes-8],	rax
L2484:
    add       r12,	32
    mov       rax,	r12
    movzx     rax,	byte ptr[rax]
    cmp       rax,	13
    jz        L2483
    lea       rax,	[r12-32]
    mov       [rip+mc_decls.currpcl],	rax
    mov       rdi,	rbx
    cmp       rdi,	1
    jl        L2488
L2486:
    mov       rsi,	[rbp + rdi*8 + mc_auxmcl.do_getretvalue.modes-8]
    cmp       rsi,	2
    jg        L2490
    lea       rax,	[rip+mc_decls.multxregs]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    jmp       L2489
L2490:
    lea       rax,	[rip+mc_decls.multregs]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
L2489:
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_stackmcl.pushpcl_reg
    dec       rdi
    cmp       rdi,	1
    jge       L2486
L2488:
    jmp       L2481
L2482:
    movzx     rax,	byte ptr[r12+3]
    mov       rcx,	rax
    mov       rdx,	1
    call      mc_stackmcl.pushpcl_reg
L2481:
#---------------
    add       rsp,	112
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.ismemaddr
mc_auxmcl.ismemaddr:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rcx
    movzx     rax,	byte ptr[rax + r10-1]
    test      rax,	rax
    jnz       L2493
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	rcx
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte ptr[rax+1]
    cmp       rax,	2
    jnz       L2493
    mov       rax,	1
    jmp       L2491
L2493:
    xor       eax,	eax
L2491:
#---------------
    ret       
# End 
# Proc mc_auxmcl.do_incr
mc_auxmcl.do_incr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rbx+3]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movsxd    rax,	dword ptr[rbx+16]
    cmp       rax,	1
    jnz       L2496
    mov       rcx,	rsi
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2495
L2496:
    movsxd    rax,	dword ptr[rbx+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2495:
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_incrload
mc_auxmcl.do_incrload:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	[rip+mc_decls.noperands]
    movzx     r10,	byte ptr[r10 + r11-1]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    movsxd    rax,	dword ptr[rsi+16]
    cmp       rax,	1
    jnz       L2499
    mov       rcx,	r12
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2498
L2499:
    movsxd    rax,	dword ptr[rsi+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	r13
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
L2498:
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	1
    lea       r10,	[rip+mc_decls.pclloc]
    mov       r11,	[rip+mc_decls.noperands]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[rip+mc_decls.pclopnd]
    mov       r11,	[rip+mc_decls.noperands]
    mov       [r10 + r11*8-8],	rax
    mov       al,	[rdi+10]
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	[rip+mc_decls.noperands]
    mov       [r10 + r11-1],	al
    mov       al,	[rip+mc_decls.pmode]
    lea       r10,	[rip+mc_decls.pclmode]
    mov       r11,	[rip+mc_decls.noperands]
    mov       [r10 + r11-1],	al
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadincr
mc_auxmcl.do_loadincr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    movsxd    rax,	dword ptr[rsi+16]
    cmp       rax,	1
    jnz       L2502
    mov       rcx,	r12
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2501
L2502:
    movsxd    rax,	dword ptr[rsi+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	r13
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
L2501:
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_for
mc_auxmcl.do_for:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_for.addop, 80
    .set mc_auxmcl.do_for.cond, 88
    .set mc_auxmcl.do_for.mx, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
    lea       rax,	[r13+32]
    mov       rdi,	rax
    lea       rax,	[rdi+32]
    mov       [rip+mc_decls.currpcl],	rax
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rdi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.do_for.mx],	rax
    mov       rax,	[rdi+8]
    mov       al,	[rax+90]
    test      al,	al
    jz        L2505
    movsxd    rax,	dword ptr[r13+16]
    cmp       rax,	1
    jnz       L2507
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.do_for.mx]
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2506
L2507:
    movsxd    rax,	dword ptr[r13+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	[rbp + mc_auxmcl.do_for.addop]
    mov       rdx,	[rbp + mc_auxmcl.do_for.mx]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2506:
    mov       rsi,	[rbp + mc_auxmcl.do_for.mx]
    jmp       L2504
L2505:
    call      mc_stackmcl.getworkireg
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	[rbp + mc_auxmcl.do_for.mx]
    call      mc_libmcl.genmc
    movsxd    rax,	dword ptr[r13+16]
    cmp       rax,	1
    jnz       L2509
    mov       rcx,	r14
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2508
L2509:
    movsxd    rax,	dword ptr[r13+16]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	[rbp + mc_auxmcl.do_for.addop]
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2508:
    mov       rcx,	11
    mov       rdx,	[rbp + mc_auxmcl.do_for.mx]
    mov       r8,	rsi
    call      mc_libmcl.genmc
L2504:
    movzx     rax,	byte ptr[rbx+1]
    cmp       rax,	4
    jnz       L2511
    mov       rax,	[rbx+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       r12,	rax
    jmp       L2510
L2511:
    mov       rax,	[rbx+8]
    mov       rcx,	rax
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       r12,	rax
L2510:
    mov       rcx,	42
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_libmcl.genmc
    mov       rax,	[r13+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	[rbp + mc_auxmcl.do_for.cond]
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.scaleindex
mc_auxmcl.scaleindex:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	rbx
    cmp       rax,	1
    jz        L2515
    cmp       rax,	2
    jz        L2515
    cmp       rax,	4
    jz        L2515
    cmp       rax,	8
    jnz       L2514
L2515:
    mov       rax,	rbx
    jmp       L2512
L2514:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_auxmcl.mulimm
    mov       rax,	1
L2512:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.mulimm
mc_auxmcl.mulimm:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	r12
    test      rax,	rax
    jz        L2518
    cmp       rax,	1
    jz        L2519
    cmp       rax,	-1
    jz        L2520
    jmp       L2521
L2518:
    mov       rcx,	rsi
    call      mc_libmcl.clearreg
    jmp       L2516
L2519:
    jmp       L2516
L2520:
    mov       rcx,	50
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2516
L2521:
L2517:
    xor       rdi,	rdi
    mov       rax,	r12
    mov       rbx,	rax
    jmp       L2523
L2522:
    sar       rbx,	1
    inc       rdi
L2523:
    mov       eax,	ebx
    and       eax,	1
    test      rax,	rax
    jz        L2522
    test      rdi,	rdi
    jz        L2526
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	43
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2526:
    mov       rax,	rbx
    cmp       rax,	1
    jz        L2528
    cmp       rax,	3
    jz        L2529
    cmp       rax,	5
    jz        L2529
    cmp       rax,	9
    jz        L2529
    jmp       L2530
L2528:
    jmp       L2516
L2529:
    sub       rsp,	8
    push      0
    push      0
    push      0
    lea       rax,	[rbx-1]
    movzx     r10,	byte ptr[rsi+10]
    movzx     r11,	byte ptr[rsi+10]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	14
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2527
L2530:
    test      rdi,	rdi
    jz        L2532
    mov       al,	34
    mov       r10,	[rip+mc_decls.mccodex]
    mov       [r10+33],	al
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       r10,	[rip+mc_decls.mccodex]
    mov       [r10+24],	rax
    jmp       L2531
L2532:
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	34
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2531:
L2527:
L2516:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_addrmode
mc_auxmcl.do_addrmode:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_addrmode.p, 72
    .set mc_auxmcl.do_addrmode.scale, -8
    .set mc_auxmcl.do_addrmode.regix, -16
    .set mc_auxmcl.do_addrmode.d, -24
    .set mc_auxmcl.do_addrmode.q, -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	72
    mov       [rbp+72],	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.p]
    movsxd    rax,	dword ptr[rax+16]
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	rax
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.p]
    movsxd    rax,	dword ptr[rax+20]
    mov       r12,	rax
    mov       rcx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_auxmcl.do_addrmode.q],	rax
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L2535
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    mov       rax,	[rax+8]
    mov       r10,	[rbp + mc_auxmcl.do_addrmode.scale]
    imul      rax,	r10
    add       rax,	r12
    mov       r13,	rax
L2535:
    xor       rdi,	rdi
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-2]
    cmp       rax,	2
    jnz       L2537
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	2
    jnz       L2539
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    mov       r14,	rax
    mov       rcx,	r14
    lea       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r8,	[rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [rbp + mc_auxmcl.do_addrmode.regix],	rax
    sub       rsp,	8
    push      0
    push      0
    push      0
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-2]
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.regix]
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2538
L2539:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L2540
    sub       rsp,	8
    push      0
    push      0
    push      0
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-2]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	r13
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2538
L2540:
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	rax
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte ptr[rsi+10]
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	[rip+mc_decls.noperands]
    movzx     r10,	byte ptr[r10 + r11-2]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
L2538:
    jmp       L2536
L2537:
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_auxmcl.ismemaddr
    test      rax,	rax
    jz        L2541
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	[rip+mc_decls.noperands]
    mov       rax,	[rax + r10*8-16]
    mov       rax,	[rax+8]
    mov       [rbp + mc_auxmcl.do_addrmode.d],	rax
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.d]
    movzx     rax,	byte ptr[rax+72]
    cmp       rax,	3
    jnz       L2545
    movzx     rax,	byte ptr[rip+pc_api.phighmem]
    cmp       rax,	2
    jz        L2544
L2545:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.d]
    movzx     rax,	byte ptr[rax+72]
    cmp       rax,	5
    jnz       L2543
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.d]
    movzx     rax,	byte ptr[rax+82]
    cmp       rax,	11
    jnz       L2543
L2544:
    jmp       L2546
L2543:
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	2
    jnz       L2548
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    mov       r14,	rax
    mov       rcx,	r14
    lea       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r8,	[rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [rbp + mc_auxmcl.do_addrmode.regix],	rax
    sub       rsp,	8
    push      qword ptr[rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       ecx,	ecx
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.regix]
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2547
L2548:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L2549
    sub       rsp,	8
    push      qword ptr[rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    xor       ecx,	ecx
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	r13
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2547
L2549:
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	rax
    sub       rsp,	8
    push      qword ptr[rbp + mc_auxmcl.do_addrmode.d]
    push      0
    push      0
    movzx     rax,	byte ptr[rsi+10]
    xor       ecx,	ecx
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
L2547:
    jmp       L2536
L2541:
#mc_auxmcl.do_addrmode.skip:
L2546:
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	1
    jnz       L2551
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    mov       r14,	rax
    mov       rcx,	r14
    lea       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r8,	[rip+mc_decls.noperands]
    call      mc_auxmcl.scaleregvar
    mov       [rbp + mc_auxmcl.do_addrmode.regix],	rax
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte ptr[rbx+10]
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.regix]
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2550
L2551:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.q]
    test      rax,	rax
    jz        L2552
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte ptr[rbx+10]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	r13
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
    jmp       L2550
L2552:
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_addrmode.scale]
    call      mc_auxmcl.scaleindex
    mov       [rbp + mc_auxmcl.do_addrmode.scale],	rax
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte ptr[rsi+10]
    movzx     r10,	byte ptr[rbx+10]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_addrmode.scale]
    mov       r9,	r12
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rdi,	rax
L2550:
L2536:
    mov       rax,	[rbp + mc_auxmcl.do_addrmode.p]
    movzx     rax,	byte ptr[rax+3]
    lea       r10,	[rip+pc_tables.psize]
    movzx     r10,	byte ptr[r10 + rax]
    lea       rax,	[rdi+8]
    mov       r15w,	[rax]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       rax,	rdi
L2533:
#---------------
    add       rsp,	72
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.scaleregvar
mc_auxmcl.scaleregvar:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    mov       rax,	[r12]
    cmp       rax,	1
    jz        L2556
    cmp       rax,	2
    jz        L2556
    cmp       rax,	4
    jz        L2556
    cmp       rax,	8
    jnz       L2555
L2556:
    mov       rax,	rsi
    jmp       L2553
L2555:
    call      mc_stackmcl.getworkireg
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rbx,	rax
    mov       rax,	[r12]
    cmp       rax,	16
    jnz       L2558
    sub       rsp,	8
    push      0
    push      0
    push      0
    mov       rcx,	rsi
    mov       rdx,	rsi
    mov       r8,	1
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       rcx,	14
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	8
    mov       [r12],	rax
    jmp       L2557
L2558:
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	[r12]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_auxmcl.mulimm
    mov       rax,	1
    mov       [r12],	rax
L2557:
    mov       al,	1
    lea       r10,	[rip+mc_decls.pclloc]
    mov       r11,	r13
    mov       [r10 + r11-1],	al
    mov       al,	dil
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	r13
    mov       [r10 + r11-1],	al
    mov       al,	10
    lea       r10,	[rip+mc_decls.pclmode]
    mov       r11,	r13
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[rip+mc_decls.pclopnd]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    mov       rax,	rdi
L2553:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.dolea
mc_auxmcl.dolea:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rbx+11]
    movzx     r10,	word ptr[rbx+8]
    shr       r10,	12
    and       r10,	15
    cmp       r10,	rax
    jnz       L2563
    movsxd    rax,	dword ptr[rbx+12]
    cmp       rax,	r10
    jnz       L2563
    test      rax,	rax
    jnz       L2563
    mov       rax,	1
    jmp       L2564
L2563:
    xor       eax,	eax
L2564:
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    test      ax,	ax
    jz        L2562
    movzx     rax,	byte ptr[rbx+10]
    movzx     r10,	byte ptr[rdi+10]
    cmp       rax,	r10
    jz        L2561
L2562:
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2561:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_binto
mc_auxmcl.do_binto:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    cmp       rax,	2
    jg        L2567
    mov       rcx,	rsi
    mov       rdx,	r13
    call      mc_auxmcl.do_binto_float
    jmp       L2565
L2567:
    movzx     rax,	byte ptr[rsi+3]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte ptr[rsi+3]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
L2565:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_binto_float
mc_auxmcl.do_binto_float:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_binto_float.p, 48
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rdi
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    dec       rax
    mov       r10,	r12
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rsi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_shiftnto
mc_auxmcl.do_shiftnto:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_shiftnto.p, 40
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-2]
    test      rax,	rax
    jnz       L2571
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	[rip+mc_decls.noperands]
    mov       rax,	[rax + r10*8-16]
    movzx     rax,	byte ptr[rax+1]
    cmp       rax,	4
    jnz       L2571
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	[rip+mc_decls.noperands]
    mov       rax,	[rax + r10*8-16]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2570
L2571:
    mov       al,	[rip+pc_decls.r10used]
    test      al,	al
    jz        L2573
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2573:
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	3
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       rbx,	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       al,	[rip+pc_decls.r10used]
    test      al,	al
    jz        L2575
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2575:
L2570:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_divrem
mc_auxmcl.do_divrem:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_divrem.issigned, 80
    .set mc_auxmcl.do_divrem.isdiv, 88
    .set mc_auxmcl.do_divrem.shifts, -8
    .set mc_auxmcl.do_divrem.fdivto, -16
    .set mc_auxmcl.do_divrem.locyy, -24
    .set mc_auxmcl.do_divrem.loczz, -32
    .set mc_auxmcl.do_divrem.$T1, -40
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	72
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.do_divrem.fdivto],	al
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       [rbp + mc_auxmcl.do_divrem.locyy],	rax
    mov       rax,	[rip+mc_decls.noperands]
    mov       [rbp + mc_auxmcl.do_divrem.loczz],	rax
    movzx     rax,	byte ptr[r15]
    cmp       rax,	94
    jz        L2579
    cmp       rax,	95
    jnz       L2578
L2579:
    mov       rax,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       r10,	[rbp + mc_auxmcl.do_divrem.loczz]
    mov       [rbp + mc_auxmcl.do_divrem.loczz],	rax
    mov       [rbp + mc_auxmcl.do_divrem.locyy],	r10
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    mov       al,	1
    mov       [rbp + mc_auxmcl.do_divrem.fdivto],	al
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_stackmcl.makeopndind
    mov       rsi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    movzx     r10,	byte ptr[rdi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenreg
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    jmp       L2577
L2578:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
L2577:
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.isimmload
    mov       r12,	rax
    test      r12,	r12
    jz        L2581
    mov       rax,	[rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       rax,	1
    jnz       L2581
    mov       r14,	[r12+8]
    mov       rax,	r14
    test      rax,	rax
    jz        L2583
    cmp       rax,	1
    jz        L2584
    jmp       L2585
L2583:
    lea       rcx,	[rip+L10648]
    lea       rdx,	[rip+L10649]
    call      pc_api.merror
    jmp       L2582
L2584:
    call      mc_stackmcl.poppcl
    jmp       L2576
L2585:
    mov       rcx,	r14
    call      mc_libmcl.ispoweroftwo
    mov       [rbp + mc_auxmcl.do_divrem.shifts],	rax
    mov       rax,	[rbp + mc_auxmcl.do_divrem.shifts]
    test      rax,	rax
    jz        L2587
    mov       al,	[rbp + mc_auxmcl.do_divrem.fdivto]
    test      al,	al
    jnz       L2587
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.shifts]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.do_divrem.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.do_divrem.issigned]
    test      rax,	rax
    jz        L2589
    mov       rax,	44
    jmp       L2588
L2589:
    mov       rax,	45
L2588:
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	[rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    jmp       L2576
L2587:
L2582:
L2581:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.loczz]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    call      mc_auxmcl.saverdx
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	[rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_auxmcl.fixdivopnds
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.loczz]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rax,	[rbp + mc_auxmcl.do_divrem.issigned]
    test      rax,	rax
    jz        L2591
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    lea       r10,	[rip+pc_tables.psize]
    movzx     r10,	byte ptr[r10 + rax]
    cmp       r10,	8
    jz        L2593
    cmp       r10,	4
    jz        L2594
    cmp       r10,	2
    jz        L2595
    jmp       L2596
L2593:
    mov       rax,	57
    jmp       L2592
L2594:
    mov       rax,	56
    jmp       L2592
L2595:
    mov       rax,	55
    jmp       L2592
L2596:
    lea       rcx,	[rip+L10650]
    lea       rdx,	[rip+L10651]
    call      pc_api.merror
    xor       eax,	eax
L2592:
    mov       r13,	rax
    mov       rcx,	r13
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       r13,	36
    jmp       L2590
L2591:
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	rax
    call      mc_libmcl.clearreg
    mov       r13,	37
L2590:
    mov       rcx,	r13
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_divrem.isdiv]
    test      rax,	rax
    jz        L2598
    cmp       rax,	2
    jz        L2599
    jmp       L2600
L2598:
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_auxmcl.do_divrem.$T1],	rax
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    jmp       L2597
L2599:
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	2
    call      mc_stackmcl.swapopndregs
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	[rbp + mc_auxmcl.do_divrem.loczz]
    call      mc_stackmcl.swapopnds
L2600:
L2597:
    call      mc_auxmcl.restorerdx
    mov       al,	[rbp + mc_auxmcl.do_divrem.fdivto]
    test      al,	al
    jz        L2602
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	13
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rbp + mc_auxmcl.do_divrem.locyy]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.do_divrem.$T1],	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_stackmcl.makeopndind
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.do_divrem.$T1]
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
L2602:
    mov       rax,	[rbp + mc_auxmcl.do_divrem.isdiv]
    cmp       rax,	2
    jz        L2604
    call      mc_stackmcl.poppcl
L2604:
L2576:
#---------------
    add       rsp,	72
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.fixdivopnds
mc_auxmcl.fixdivopnds:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.fixdivopnds.$T1, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r14,	rcx
    mov       r15,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	r14
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rdi,	rax
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	r15
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rbx,	rax
    cmp       rdi,	1
    jz        L2605
L2607:
    mov       rcx,	r14
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       r12,	rax
    mov       rcx,	r15
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       r13,	rax
    cmp       rbx,	1
    jnz       L2609
    mov       rcx,	27
    mov       rdx,	r12
    mov       r8,	r13
    call      mc_libmcl.genmc
    mov       rcx,	r14
    mov       rdx,	r15
    call      mc_stackmcl.swapopnds
    jmp       L2605
L2609:
    lea       rax,	[rip+mc_decls.regset]
    movzx     rax,	byte ptr[rax]
    test      rax,	rax
    jnz       L2611
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rax
    mov       r8,	r12
    call      mc_libmcl.genmc
    xor       eax,	eax
    lea       r10,	[rip+mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	r14
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.regset]
    mov       [r10],	al
    jmp       L2605
L2611:
    mov       rsi,	[rip+mc_decls.noperands]
    cmp       rsi,	1
    jl        L2615
L2612:
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	1
    jnz       L2617
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	1
    jz        L2614
L2617:
    dec       rsi
    cmp       rsi,	1
    jge       L2612
L2615:
    jmp       L2605
L2614:
    mov       rcx,	r14
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_auxmcl.fixdivopnds.$T1],	rax
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixdivopnds.$T1]
    call      mc_libmcl.genmc
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	r14
    lea       rax,	[rax + r10-1]
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	rsi
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
L2605:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.saverdx
mc_auxmcl.saverdx:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       al,	[rip+pc_decls.r11used]
    test      al,	al
    jz        L2620
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2620:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_auxmcl.restorerdx
mc_auxmcl.restorerdx:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       al,	[rip+pc_decls.r11used]
    test      al,	al
    jz        L2623
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2623:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_auxmcl.clearblock
mc_auxmcl.clearblock:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.clearblock.ax, 64
    .set mc_auxmcl.clearblock.n, 72
    .set mc_auxmcl.clearblock.countreg, -8
    .set mc_auxmcl.clearblock.av_1, -16
    .set mc_auxmcl.clearblock.i, -24
    .set mc_auxmcl.clearblock.$T1, -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+64],	rcx
    mov       [rbp+72],	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    mov       r10,	8
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       r13,	rax
    mov       rax,	r13
    sub       [rbp + mc_auxmcl.clearblock.n],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    sar       rax,	3
    mov       rsi,	rax
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mc_libmcl.clearreg
    xor       r14,	r14
    mov       rax,	rsi
    cmp       rax,	1
    jl        L2626
    cmp       rax,	8
    jg        L2626
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       [rbp + mc_auxmcl.clearblock.ax],	rax
    mov       [rbp + mc_auxmcl.clearblock.av_1],	rsi
    mov       rax,	[rbp + mc_auxmcl.clearblock.av_1]
    cmp       rax,	0
    jle       L2629
L2627:
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	8
    add       r14,	rax
    dec       qword ptr[rbp + mc_auxmcl.clearblock.av_1]
    jnz       L2627
L2629:
    jmp       L2625
L2626:
    test      rsi,	rsi
    jz        L2630
    mov       rax,	rsi
    and       rax,	3
    jz        L2632
    call      mc_stackmcl.getworkireg
    mov       r10,	rax
    mov       [rbp + mc_auxmcl.clearblock.countreg],	r10
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rbx,	rax
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       r12,	[rip+pc_api.mlabelno]
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [rbp + mc_auxmcl.clearblock.ax],	rax
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.clearblock.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.ax]
    movzx     rax,	byte ptr[rax+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    xor       r14,	r14
    jmp       L2631
L2632:
    call      mc_stackmcl.getworkireg
    mov       r10,	rax
    mov       [rbp + mc_auxmcl.clearblock.countreg],	r10
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rbx,	rax
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       r12,	[rip+pc_api.mlabelno]
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    call      mc_stackmcl.makesimpleaddr
    mov       [rbp + mc_auxmcl.clearblock.ax],	rax
    mov       rax,	rsi
    sar       rax,	2
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	1
    mov       [rbp + mc_auxmcl.clearblock.i],	rax
L2633:
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	8
    add       r14,	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.i]
    inc       rax
    mov       [rbp + mc_auxmcl.clearblock.i],	rax
    cmp       rax,	4
    jle       L2633
    mov       rcx,	32
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.clearblock.$T1],	rax
    mov       rax,	[rbp + mc_auxmcl.clearblock.ax]
    movzx     rax,	byte ptr[rax+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.clearblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    xor       r14,	r14
L2631:
L2630:
L2625:
    test      r13,	r13
    jz        L2637
    mov       [rbp + mc_auxmcl.clearblock.n],	r13
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    cmp       rax,	4
    jl        L2639
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    mov       r8,	4
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	4
    sub       [rbp + mc_auxmcl.clearblock.n],	rax
    mov       rax,	4
    add       r14,	rax
L2639:
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    cmp       rax,	2
    jl        L2641
    mov       rcx,	rdi
    mov       rdx,	2
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    mov       r8,	2
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	2
    sub       [rbp + mc_auxmcl.clearblock.n],	rax
    mov       rax,	2
    add       r14,	rax
L2641:
    mov       rax,	[rbp + mc_auxmcl.clearblock.n]
    cmp       rax,	1
    jnz       L2643
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	[rbp + mc_auxmcl.clearblock.ax]
    mov       rdx,	r14
    mov       r8,	1
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2643:
L2637:
#---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_blockdata
mc_auxmcl.do_blockdata:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r14,	rcx
#---------------
#PROC3
#PROC4
    mov       eax,	[r14+4]
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L2646
    jmp       L2644
L2646:
    mov       rax,	rbx
    sar       rax,	3
    mov       rsi,	rax
    mov       rdi,	[r14+8]
    mov       r13,	rsi
    cmp       r13,	0
    jle       L2649
L2647:
    mov       rax,	rdi
    add       rdi,	8
    mov       rax,	[rax]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    dec       r13
    jnz       L2647
L2649:
    mov       rax,	rsi
    shl       rax,	3
    mov       r10,	rbx
    sub       r10,	rax
    mov       r12,	r10
    test      r12,	r12
    jz        L2651
    mov       rcx,	rdi
    mov       rdx,	r12
    mov       r8,	66
    call      mc_auxmcl.genstring_db
L2651:
    lea       rcx,	[rip+L10652]
    call      mc_libmcl.mgencomment
L2644:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.copyblock
mc_auxmcl.copyblock:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.copyblock.n, 88
    .set mc_auxmcl.copyblock.savedest, 96
    .set mc_auxmcl.copyblock.oddbytes, -8
    .set mc_auxmcl.copyblock.offset, -16
    .set mc_auxmcl.copyblock.axreg, -24
    .set mc_auxmcl.copyblock.saved, -32
    .set mc_auxmcl.copyblock.av_1, -40
    .set mc_auxmcl.copyblock.$T1, -48
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+88],	r8
    mov       [rbp+96],	r9
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.copyblock.saved],	al
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	16
    jnz       L2654
    mov       rcx,	2
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	91
    mov       rdx,	rdi
    mov       r8,	r14
    call      mc_libmcl.genmc
    mov       rcx,	91
    mov       rdx,	r13
    mov       r8,	rdi
    call      mc_libmcl.genmc
    jmp       L2652
L2654:
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    mov       r10,	8
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       [rbp + mc_auxmcl.copyblock.oddbytes],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.oddbytes]
    sub       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    sar       rax,	3
    mov       rsi,	rax
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.copyblock.offset],	rax
    mov       rax,	rsi
    cmp       rax,	1
    jl        L2656
    cmp       rax,	4
    jg        L2656
    mov       rcx,	r13
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       r13,	rax
    mov       rcx,	r14
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       r14,	rax
    mov       [rbp + mc_auxmcl.copyblock.av_1],	rsi
    mov       rax,	[rbp + mc_auxmcl.copyblock.av_1]
    cmp       rax,	0
    jle       L2659
L2657:
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	8
    add       [rbp + mc_auxmcl.copyblock.offset],	rax
    dec       qword ptr[rbp + mc_auxmcl.copyblock.av_1]
    jnz       L2657
L2659:
    jmp       L2655
L2656:
    test      rsi,	rsi
    jz        L2660
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       r12,	[rip+pc_api.mlabelno]
    mov       rax,	[rbp + mc_auxmcl.copyblock.savedest]
    test      rax,	rax
    jz        L2662
    movzx     rax,	byte ptr[r13+10]
    mov       [rbp + mc_auxmcl.copyblock.axreg],	rax
    mov       rcx,	[rbp + mc_auxmcl.copyblock.axreg]
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [rbp + mc_auxmcl.copyblock.saved],	al
L2662:
    mov       rcx,	r13
    call      mc_stackmcl.makesimpleaddr
    mov       r13,	rax
    mov       rcx,	r14
    call      mc_stackmcl.makesimpleaddr
    mov       r14,	rax
    lea       rax,	[r13+8]
    mov       r10w,	8
    mov       r15w,	[rax]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	r14
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	r13
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.copyblock.$T1],	rax
    movzx     rax,	byte ptr[r13+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.copyblock.$T1],	rax
    movzx     rax,	byte ptr[r14+10]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.copyblock.$T1]
    call      mc_libmcl.genmc
    mov       rcx,	53
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       rcx,	26
    mov       rdx,	5
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    xor       eax,	eax
    mov       [rbp + mc_auxmcl.copyblock.offset],	rax
L2660:
L2655:
    mov       rax,	[rbp + mc_auxmcl.copyblock.oddbytes]
    test      rax,	rax
    jz        L2664
    mov       rax,	[rbp + mc_auxmcl.copyblock.oddbytes]
    mov       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	4
    jl        L2666
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	4
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	4
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	4
    sub       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	4
    add       [rbp + mc_auxmcl.copyblock.offset],	rax
L2666:
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	2
    jl        L2668
    mov       rcx,	rdi
    mov       rdx,	2
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	2
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	2
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	2
    sub       [rbp + mc_auxmcl.copyblock.n],	rax
    mov       rax,	2
    add       [rbp + mc_auxmcl.copyblock.offset],	rax
L2668:
    mov       rax,	[rbp + mc_auxmcl.copyblock.n]
    cmp       rax,	1
    jnz       L2670
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	1
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	[rbp + mc_auxmcl.copyblock.offset]
    mov       r8,	1
    call      mc_libmcl.applyoffset
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	rdi
    call      mc_libmcl.genmc
L2670:
L2664:
    mov       al,	[rbp + mc_auxmcl.copyblock.saved]
    test      al,	al
    jz        L2672
    mov       rcx,	[rbp + mc_auxmcl.copyblock.axreg]
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	13
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2672:
L2652:
#---------------
    add       rsp,	88
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.genstringtable
mc_auxmcl.genstringtable:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.cstringlist]
    test      rax,	rax
    jz        L2673
L2675:
    lea       rcx,	[rip+L10653]
    call      mc_libmcl.mgencomment
    mov       rcx,	73
    mov       rdx,	8
    call      mc_libmcl.setsegment
    mov       rax,	[rip+mc_decls.kk0used]
    test      rax,	rax
    jz        L2677
    mov       rcx,	[rip+mc_decls.kk0used]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    xor       ecx,	ecx
    call      mc_auxmcl.gendb
L2677:
    mov       rdi,	[rip+mc_decls.cstringlist]
    jmp       L2681
L2678:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rax,	[rdi]
    mov       rcx,	rax
    mov       rdx,	-1
    xor       r8d,	r8d
    call      mc_auxmcl.genstring_db
    mov       rdi,	[rdi+8]
L2681:
    test      rdi,	rdi
    jnz       L2678
L2673:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.genstring_db
mc_auxmcl.genstring_db:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
#---------------
#PROC3
#PROC4
    cmp       r14,	-1
    jnz       L2684
    mov       rcx,	r13
    call      strlen
    mov       r14,	rax
L2684:
    test      r14,	r14
    jnz       L2686
    xor       ecx,	ecx
    call      mc_auxmcl.gendb
    jmp       L2682
L2686:
    xor       rbx,	rbx
    mov       rax,	r14
    mov       r12,	rax
    cmp       r12,	0
    jle       L2689
L2687:
    mov       rax,	r13
    inc       r13
    movzx     rax,	byte ptr[rax]
    mov       rdi,	rax
    cmp       rdi,	32
    jl        L2692
    cmp       rdi,	127
    jge       L2692
    mov       rax,	rdi
    cmp       rax,	34
    jz        L2693
    cmp       rax,	92
    jnz       L2691
L2693:
L2692:
    test      rbx,	rbx
    jz        L2695
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_auxmcl.gendbstring
    xor       rbx,	rbx
L2695:
    mov       rcx,	rdi
    call      mc_auxmcl.gendb
    jmp       L2690
L2691:
    test      rbx,	rbx
    jnz       L2697
    mov       rbx,	1
    lea       rax,	[r13-1]
    mov       rsi,	rax
    jmp       L2696
L2697:
    inc       rbx
L2696:
L2690:
    dec       r12
    jnz       L2687
L2689:
    test      rbx,	rbx
    jz        L2699
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_auxmcl.gendbstring
L2699:
    test      r15,	r15
    jnz       L2701
    xor       ecx,	ecx
    call      mc_auxmcl.gendb
L2701:
L2682:
#---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.gendb
mc_auxmcl.gendb:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	116
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.gendbstring
mc_auxmcl.gendbstring:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenstring
    mov       rcx,	120
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.gendq
mc_auxmcl.gendq:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.genrealtable
mc_auxmcl.genrealtable:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.creallist]
    test      rax,	rax
    jnz       L2707
    mov       rax,	[rip+mc_decls.cr32list]
    test      rax,	rax
    jz        L2705
L2707:
    lea       rcx,	[rip+L10654]
    call      mc_libmcl.mgencomment
    mov       rcx,	73
    mov       rdx,	8
    call      mc_libmcl.setsegment
    mov       rdi,	[rip+mc_decls.creallist]
    jmp       L2711
L2708:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movq      XMM4,	[rdi]
    comisd    XMM4,	[rip+L10655]
    jnz       L2713
    movq      XMM4,	[rdi]
    movq      rax,	XMM4
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2712
L2713:
    movq      XMM4,	[rdi]
    movq      rax,	XMM4
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	119
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2712:
    mov       rdi,	[rdi+8]
L2711:
    test      rdi,	rdi
    jnz       L2708
    lea       rcx,	[rip+L10656]
    call      mc_libmcl.mgencomment
    mov       rdi,	[rip+mc_decls.cr32list]
    jmp       L2717
L2714:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    movq      XMM4,	[rdi]
    comisd    XMM4,	[rip+L10657]
    jnz       L2719
    movq      XMM4,	[rdi]
    cvtsd2ss  XMM4,	XMM4
    movd      eax,	XMM4
    mov       ecx,	eax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	118
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2718
L2719:
    movq      XMM4,	[rdi]
    movq      XMM0,	XMM4
    mov       rdx,	1
    call      mc_libmcl.mgenrealimm
    mov       rcx,	118
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2718:
    mov       rdi,	[rdi+8]
L2717:
    test      rdi,	rdi
    jnz       L2714
L2705:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.genabsneg
mc_auxmcl.genabsneg:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.lababs32]
    add       rax,	[rip+mc_decls.lababs64]
    add       rax,	[rip+mc_decls.labneg32]
    add       rax,	[rip+mc_decls.labneg64]
    test      rax,	rax
    jz        L2722
    mov       rcx,	73
    mov       rdx,	16
    call      mc_libmcl.setsegment
L2722:
    mov       rax,	[rip+mc_decls.lababs32]
    test      rax,	rax
    jz        L2724
    lea       rcx,	[rip+L10658]
    call      mc_libmcl.mgencomment
    mov       rcx,	[rip+mc_decls.lababs32]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9223372034707292159
    call      mc_auxmcl.gendq
    mov       rcx,	9223372034707292159
    call      mc_auxmcl.gendq
L2724:
    mov       rax,	[rip+mc_decls.lababs64]
    test      rax,	rax
    jz        L2726
    lea       rcx,	[rip+L10659]
    call      mc_libmcl.mgencomment
    mov       rcx,	[rip+mc_decls.lababs64]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       rcx,	9223372036854775807
    call      mc_auxmcl.gendq
L2726:
    mov       rax,	[rip+mc_decls.labneg32]
    test      rax,	rax
    jz        L2728
    lea       rcx,	[rip+L10660]
    call      mc_libmcl.mgencomment
    mov       rcx,	[rip+mc_decls.labneg32]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
    mov       rcx,	-9223372034707292160
    call      mc_auxmcl.gendq
L2728:
    mov       rax,	[rip+mc_decls.labneg64]
    test      rax,	rax
    jz        L2730
    lea       rcx,	[rip+L10661]
    call      mc_libmcl.mgencomment
    mov       rcx,	[rip+mc_decls.labneg64]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
    mov       rcx,	-9223372036854775808
    call      mc_auxmcl.gendq
L2730:
    mov       rax,	[rip+mc_decls.labzero]
    test      rax,	rax
    jz        L2732
    lea       rcx,	[rip+L10662]
    call      mc_libmcl.mgencomment
    mov       rcx,	[rip+mc_decls.labzero]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    xor       ecx,	ecx
    call      mc_auxmcl.gendq
L2732:
    mov       rax,	[rip+mc_decls.labmask63]
    test      rax,	rax
    jz        L2734
    lea       rcx,	[rip+L10663]
    call      mc_libmcl.mgencomment
    mov       rcx,	[rip+mc_decls.labmask63]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	9223372036854775807
    call      mc_auxmcl.gendq
    mov       rcx,	[rip+mc_decls.laboffset64]
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	4890909195324358656
    call      mc_auxmcl.gendq
L2734:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_auxmcl.do_maths
mc_auxmcl.do_maths:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    mov       r9,	rsi
    call      mc_auxmcl.do_callrts
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_host
mc_auxmcl.do_host:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	rbx
    mov       r9,	rsi
    call      mc_auxmcl.do_callrts
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_callrts
mc_auxmcl.do_callrts:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
#---------------
#PROC3
#PROC4
    mov       rcx,	r14
    call      mc_stackmcl.saveopnds
    xor       rdi,	rdi
    mov       eax,	[rip+mc_decls.mstackdepth]
    and       eax,	1
    test      rax,	rax
    jz        L2739
    mov       rcx,	1
    call      mc_libmcl.pushslots
    mov       rdi,	1
L2739:
    mov       rcx,	r14
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_auxmcl.do_pushlowargs
    mov       rax,	[rip+mc_decls.mstackdepth]
    test      rax,	rax
    jz        L2741
    mov       rax,	4
    add       rdi,	rax
    mov       rcx,	4
    call      mc_libmcl.pushslots
    jmp       L2740
L2741:
    mov       al,	1
    mov       [rip+pc_decls.localshadow],	al
L2740:
    test      r12,	r12
    jz        L2743
    mov       rcx,	r12
    call      mc_libmcl.mgenextname
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    jmp       L2742
L2743:
    mov       rcx,	r13
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2742:
    mov       rbx,	r14
    cmp       rbx,	0
    jle       L2746
L2744:
    call      mc_stackmcl.poppcl
    dec       rbx
    jnz       L2744
L2746:
    test      rdi,	rdi
    jz        L2748
    mov       rcx,	rdi
    call      mc_libmcl.popslots
L2748:
    mov       rcx,	rsi
    call      mc_auxmcl.do_getretvalue
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_max_int
mc_auxmcl.do_max_int:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       rcx,	15
    mov       rdx,	rsi
    mov       r8,	rdi
    mov       r9,	rbx
    call      mc_libmcl.genmc_cond
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_max_float
mc_auxmcl.do_max_float:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_maxto_int
mc_auxmcl.do_maxto_int:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_maxto_int.mode, 64
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rcx,	42
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       r12,	[rip+pc_api.mlabelno]
    mov       rcx,	r12
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       rsi,	r10
    mov       rcx,	26
    mov       rdx,	r13
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_maxto_real
mc_auxmcl.do_maxto_real:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_maxto_real.mode, 72
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r14,	rcx
    mov       [rbp+72],	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_real.mode]
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.do_maxto_real.mode]
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rsi,	rax
    mov       rcx,	[rbp + mc_auxmcl.do_maxto_real.mode]
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_maxto_real.mode]
    dec       rax
    mov       r10,	73
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_libmcl.genmc
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       r13,	[rip+pc_api.mlabelno]
    mov       rcx,	r13
    call      mc_libmcl.mgenlabel
    mov       r10,	rax
    mov       r12,	r10
    mov       rcx,	26
    mov       rdx,	r14
    mov       r8,	rax
    xor       r9d,	r9d
    call      mc_libmcl.genmc_cond
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rsi
    call      mc_libmcl.genmc
    mov       rcx,	9
    mov       rdx,	r12
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_negreal
mc_auxmcl.do_negreal:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_negreal.mode, 32
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    dec       rax
    test      rax,	rax
    jz        L2755
    mov       rax,	[rip+mc_decls.labneg64]
    test      rax,	rax
    jnz       L2757
    call      mc_libmcl.mcreatefwdlabel
    mov       [rip+mc_decls.labneg64],	rax
L2757:
    mov       rcx,	[rip+mc_decls.labneg64]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	77
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2754
L2755:
    mov       rax,	[rip+mc_decls.labneg32]
    test      rax,	rax
    jnz       L2759
    call      mc_libmcl.mcreatefwdlabel
    mov       [rip+mc_decls.labneg32],	rax
L2759:
    mov       rcx,	[rip+mc_decls.labneg32]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	76
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2754:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_absreal
mc_auxmcl.do_absreal:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_absreal.mode, 32
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    dec       rax
    test      rax,	rax
    jz        L2762
    mov       rax,	[rip+mc_decls.lababs64]
    test      rax,	rax
    jnz       L2764
    call      mc_libmcl.mcreatefwdlabel
    mov       [rip+mc_decls.lababs64],	rax
L2764:
    mov       rcx,	[rip+mc_decls.lababs64]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	79
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2761
L2762:
    mov       rax,	[rip+mc_decls.lababs32]
    test      rax,	rax
    jnz       L2766
    call      mc_libmcl.mcreatefwdlabel
    mov       [rip+mc_decls.lababs32],	rax
L2766:
    mov       rcx,	[rip+mc_decls.lababs32]
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	78
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2761:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadbf_const
mc_auxmcl.do_loadbf_const:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_loadbf_const.p, 56
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    cmp       r13,	63
    jnz       L2769
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	44
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2768
L2769:
    test      r12,	r12
    jz        L2771
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	45
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2771:
    mov       rax,	r13
    sub       rax,	r12
    inc       rax
    mov       r10,	-1
    mov       cl,	al
    shl       r10,	cl
    not       r10
    mov       rsi,	r10
    cmp       rsi,	2147483647
    ja        L2773
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2772
L2773:
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    mov       rcx,	rsi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2772:
L2768:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_loadbf_var
mc_auxmcl.do_loadbf_var:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_loadbf_var.p, 16
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+L10664]
    lea       rdx,	[rip+L10665]
    call      pc_api.merror
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_auxmcl.do_storebit
mc_auxmcl.do_storebit:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_storebit.p, 72
    .set mc_auxmcl.do_storebit.offset, -8
    .set mc_auxmcl.do_storebit.mask1s, -16
    .set mc_auxmcl.do_storebit.mask0s, -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       r13,	rax
    mov       rax,	[rip+mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       r14,	rax
    test      r13,	r13
    jz        L2777
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	3
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       r15,	[r13+8]
    mov       rax,	r15
    sar       rax,	3
    mov       [rbp + mc_auxmcl.do_storebit.offset],	rax
    mov       rax,	7
    and       r15,	rax
    mov       rcx,	rdi
    mov       rdx,	[rbp + mc_auxmcl.do_storebit.offset]
    xor       r8d,	r8d
    call      mc_libmcl.applyoffset
    mov       rdi,	rax
    mov       rax,	1
    mov       cl,	r15b
    shl       rax,	cl
    mov       [rbp + mc_auxmcl.do_storebit.mask0s],	al
    mov       rax,	1
    mov       cl,	r15b
    shl       rax,	cl
    not       rax
    mov       [rbp + mc_auxmcl.do_storebit.mask1s],	al
    test      r14,	r14
    jz        L2779
    mov       rax,	[r14+8]
    test      rax,	rax
    jnz       L2781
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    movzx     r10,	byte ptr[rbp + mc_auxmcl.do_storebit.mask1s]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L2780
L2781:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    movzx     r10,	byte ptr[rbp + mc_auxmcl.do_storebit.mask0s]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	39
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L2780:
    jmp       L2778
L2779:
    mov       rax,	[rip+mc_decls.noperands]
    sub       rax,	2
    mov       rcx,	rax
    mov       rdx,	3
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rbx,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    movzx     r10,	byte ptr[rbp + mc_auxmcl.do_storebit.mask1s]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenint
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    test      r15,	r15
    jz        L2783
    mov       rcx,	r15
    mov       rdx,	3
    call      mc_libmcl.mgenint
    mov       rcx,	43
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
L2783:
    mov       rcx,	39
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2778:
    jmp       L2776
L2777:
    test      r14,	r14
    jz        L2784
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    dec       r10
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    test      r13,	r13
    jnz       L2786
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	11
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rsi,	rax
    mov       al,	[rip+pc_decls.r10used]
    test      al,	al
    jz        L2788
    mov       rcx,	12
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2788:
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	10
    mov       r8,	11
    call      mc_stackmcl.loadparam
    mov       r12,	rax
    mov       rcx,	rsi
    mov       rdx,	1
    call      mc_libmcl.changeopndsize
    mov       rcx,	43
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       al,	[rip+pc_decls.r10used]
    test      al,	al
    jz        L2790
    mov       rcx,	13
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2790:
    mov       rax,	[r14+8]
    test      rax,	rax
    jnz       L2792
    mov       rcx,	51
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	38
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
    jmp       L2791
L2792:
    mov       rcx,	39
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L2791:
    jmp       L2785
L2786:
    lea       rcx,	[rip+L10666]
    lea       rdx,	[rip+L10667]
    call      pc_api.merror
L2785:
    jmp       L2776
L2784:
    lea       rcx,	[rip+L10668]
    lea       rdx,	[rip+L10669]
    call      pc_api.merror
L2776:
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.do_storebf
mc_auxmcl.do_storebf:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.do_storebf.p, 72
    .set mc_auxmcl.do_storebf.r, -8
    .set mc_auxmcl.do_storebf.mask, -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    call      mc_stackmcl.isimmload
    mov       r15,	rax
    mov       rcx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.isimmload
    mov       [rbp + mc_auxmcl.do_storebf.r],	rax
    mov       rax,	[rbp + mc_auxmcl.do_storebf.r]
    cmp       rax,	r15
    jnz       L2795
    test      rax,	rax
    jnz       L2795
    lea       rcx,	[rip+L10670]
    lea       rdx,	[rip+L10671]
    call      pc_api.merror
L2795:
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    sub       r10,	3
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       r12,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rip+mc_decls.noperands]
    sub       r10,	2
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_stackmcl.getopnd_ind
    mov       rdi,	rax
    mov       r13,	[r15+8]
    mov       rax,	[rbp + mc_auxmcl.do_storebf.r]
    mov       r14,	[rax+8]
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rsi,	rax
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	11
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_libmcl.genmc
    mov       rax,	r14
    sub       rax,	r13
    inc       rax
    mov       r10,	-1
    mov       cl,	al
    shl       r10,	cl
    not       r10
    mov       cl,	r13b
    shl       r10,	cl
    not       r10
    mov       [rbp + mc_auxmcl.do_storebf.mask],	r10
    mov       rcx,	[rbp + mc_auxmcl.do_storebf.mask]
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	rax
    call      mc_libmcl.genmc
    test      r13,	r13
    jz        L2797
    mov       rcx,	r13
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	43
    mov       rdx,	r12
    mov       r8,	rax
    call      mc_libmcl.genmc
L2797:
    mov       rax,	[rbp + mc_auxmcl.do_storebf.p]
    mov       eax,	[rax+4]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_libmcl.changeopndsize
    mov       rcx,	38
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	39
    mov       rdx,	rbx
    mov       r8,	r12
    call      mc_libmcl.genmc
    mov       rax,	[rbp + mc_auxmcl.do_storebf.p]
    mov       eax,	[rax+4]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_libmcl.changeopndsize
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
    call      mc_stackmcl.poppcl
#---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.gethostfn
mc_auxmcl.gethostfn:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_api.igethostfn]
    test      rax,	rax
    jnz       L2800
    cmp       r13,	82
    jnz       L2803
L2802:
    lea       rax,	[rip+L10672]
    mov       rbx,	rax
    lea       rax,	[rip+L10673]
    mov       rsi,	rax
    jmp       L2801
L2803:
    xor       rbx,	rbx
L2801:
    test      rbx,	rbx
    jz        L2805
    mov       r12,	[rip+pc_decls.psymboltable]
    jmp       L2809
L2806:
    mov       rax,	[r12]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jnz       L2812
    mov       rax,	[r12]
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L2811
L2812:
    mov       rax,	r12
    jmp       L2798
L2811:
    mov       r12,	[r12+8]
L2809:
    test      r12,	r12
    jnz       L2806
L2805:
    lea       rax,	[rip+pc_tables.pclnames]
    mov       r10,	r13
    mov       rax,	[rax + r10*8]
    lea       rcx,	[rip+L10674]
    mov       rdx,	rax
    call      pc_api.merror
L2800:
    mov       rcx,	r13
    mov       rax,	[rip+pc_api.igethostfn]
    call      rax
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L2814
    lea       rax,	[rip+pc_tables.pclnames]
    mov       r10,	r13
    mov       rax,	[rax + r10*8]
    lea       rcx,	[rip+L10675]
    mov       rdx,	rax
    call      pc_api.merror
L2814:
    mov       rax,	rdi
L2798:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.copyblockarg
mc_auxmcl.copyblockarg:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.copyblockarg.argno, 72
    .set mc_auxmcl.copyblockarg.$T3, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
#---------------
#PROC3
#PROC4
    test      r12,	r12
    jnz       L2817
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10676]
    call      msys.m$print_str_nf
    mov       rax,	[rip+pc_decls.currfunc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L10677]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L2815
L2817:
    mov       rcx,	r13
    call      mc_libmcl.newblocktemp
    mov       rdi,	rax
    mov       al,	1
    mov       [rdi+92],	al
    test      r12,	r12
    jz        L2819
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rsi,	rax
    mov       rcx,	11
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_libmcl.genmc
    jmp       L2818
L2819:
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	11
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rsi,	rax
L2818:
    mov       rcx,	6
    call      mc_stackmcl.getworkregm
    mov       rbx,	rax
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	rbx
    mov       r8,	rax
    call      mc_libmcl.genmc
    movzx     rax,	byte ptr[rsi+10]
    mov       rcx,	rax
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       [rbp + mc_auxmcl.copyblockarg.$T3],	rax
    movzx     rax,	byte ptr[rbx+10]
    mov       rcx,	rax
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_auxmcl.copyblockarg.$T3]
    mov       r8,	r13
    mov       r9,	1
    call      mc_auxmcl.copyblock
    test      r12,	r12
    jz        L2821
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	r12
    mov       r8,	rax
    call      mc_libmcl.genmc
L2821:
    xor       ecx,	ecx
    call      mc_stackmcl.freeworkregs
L2815:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_auxmcl.fixmain
mc_auxmcl.fixmain:
#PROC1
#PROC2
#?>>
    .set mc_auxmcl.fixmain.$T1, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	[rip+pc_decls.currfunc]
    mov       rbx,	[rdi+16]
    mov       rsi,	[rbx+16]
    lea       rcx,	[rip+L10678]
    mov       rdx,	3
    call      pc_api.pc_makesymbol
    mov       r12,	rax
    mov       al,	6
    mov       [r12+82],	al
    mov       eax,	8
    mov       [r12+84],	eax
    lea       rcx,	[rip+L10679]
    mov       rdx,	3
    call      pc_api.pc_makesymbol
    mov       r13,	rax
    mov       al,	11
    mov       [r13+82],	al
    mov       eax,	128
    mov       [r13+84],	eax
    mov       rcx,	90
    mov       rdx,	8
    call      mc_libmcl.setsegment
    mov       rcx,	r13
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	128
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	125
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r12
    call      mc_libmcl.mgenmemaddr
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	8
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	125
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
    mov       rcx,	r12
    call      pc_api.pc_addlocal
    mov       rcx,	r13
    call      pc_api.pc_addlocal
    xor       eax,	eax
    mov       [rdi+16],	rax
    mov       [rsi+16],	rax
    mov       [rbx+16],	rax
    xor       eax,	eax
    mov       [rdi+112],	al
    mov       al,	4
    mov       [rbx+72],	al
    mov       al,	1
    mov       [rbx+92],	al
    mov       al,	4
    mov       [rsi+72],	al
    mov       al,	4
    mov       [rsi+92],	al
    mov       rcx,	rsi
    call      pc_api.pc_addlocal
    mov       rcx,	rbx
    call      pc_api.pc_addlocal
    mov       rcx,	1
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       r10,	rax
    mov       r14,	r10
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	r13
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	r14
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [r13+88],	al
    mov       rcx,	12
    mov       rdx,	r14
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	32
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	[rip+mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rcx,	rbx
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	11
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [rbx+88],	al
    mov       rcx,	rsi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	12
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [rsi+88],	al
    mov       rcx,	r12
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	13
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       al,	1
    mov       [r12+88],	al
    mov       rcx,	14
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	rax
    call      mc_libmcl.clearreg
    lea       rcx,	[rip+L10680]
    call      mc_libmcl.mgenextname
    mov       rcx,	21
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    mov       rcx,	48
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	[rip+mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
    mov       rax,	[rip+pc_decls.pcmdskip]
    test      rax,	rax
    jz        L2824
    mov       rcx,	[rip+pc_decls.pcmdskip]
    mov       rdx,	9
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	29
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
    mov       rax,	[rip+pc_decls.pcmdskip]
    shl       rax,	3
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       [rbp + mc_auxmcl.fixmain.$T1],	rax
    mov       rcx,	rsi
    mov       rdx,	6
    call      mc_libmcl.mgenmem
    mov       rcx,	28
    mov       rdx,	rax
    mov       r8,	[rbp + mc_auxmcl.fixmain.$T1]
    call      mc_libmcl.genmc
L2824:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mclinit
mc_libmcl.mclinit:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r14,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	64
    cmp       rax,	64
    jle       L2827
    lea       rcx,	[rip+L10681]
    call      mlib.abortprogram
L2827:
    mov       rbx,	1
L2828:
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_libmcl.mgenreg0
    lea       r10,	[rip+mc_decls.regtable]
    mov       r11,	rbx
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10],	rax
    mov       rcx,	rbx
    mov       rdx,	2
    call      mc_libmcl.mgenreg0
    lea       r10,	[rip+mc_decls.regtable]
    mov       r11,	rbx
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10+8],	rax
    mov       rcx,	rbx
    mov       rdx,	4
    call      mc_libmcl.mgenreg0
    lea       r10,	[rip+mc_decls.regtable]
    mov       r11,	rbx
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10+24],	rax
    mov       rcx,	rbx
    mov       rdx,	8
    call      mc_libmcl.mgenreg0
    lea       r10,	[rip+mc_decls.regtable]
    mov       r11,	rbx
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       [r10+56],	rax
    inc       rbx
    cmp       rbx,	16
    jle       L2828
    mov       r13,	-128
    mov       rsi,	64
    cmp       rsi,	-128
    jl        L2833
L2831:
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r8w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r8w,	r11w
    or        r8w,	r10w
    mov       [rax],	r8w
    mov       al,	15
    mov       [rdi+10],	al
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r8w,	[rax]
    mov       r11,	-32
    and       r8w,	r11w
    or        r8w,	r10w
    mov       [rax],	r8w
    mov       [rdi+12],	r13d
    mov       rax,	rdi
    lea       r10,	[rip+mc_decls.frameregtable]
    mov       r11,	r13
    mov       [r10 + r11*8+1024],	rax
    inc       r13
    cmp       r13,	rsi
    jle       L2831
L2833:
    mov       rcx,	15
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [rip+mc_decls.dframeopnd],	rax
    mov       rcx,	16
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [rip+mc_decls.dstackopnd],	rax
    call      mc_libmcl.initmcdest
    mov       rcx,	67
    mov       rdx,	1
    call      mc_libmcl.setsegment
    xor       eax,	eax
    mov       [rip+mc_decls.lab_funcnametable],	rax
    xor       eax,	eax
    mov       [rip+mc_decls.lab_funcaddrtable],	rax
    mov       r13,	-1
    mov       r12,	10
    cmp       r12,	-1
    jl        L2836
L2834:
    mov       rcx,	r13
    mov       rdx,	8
    call      mc_libmcl.mgenint0
    lea       r10,	[rip+mc_libmcl.smallinttable]
    mov       r11,	r13
    mov       [r10 + r11*8+8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L2834
L2836:
    test      r14,	r14
    jz        L2838
    mov       al,	1
    mov       [rip+pc_decls.mcldone],	al
L2838:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.initmcdest
mc_libmcl.initmcdest:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rip+mc_decls.mccodex],	rax
    mov       [rip+mc_decls.mccode],	rax
#---------------
    ret       
# End 
# Proc mc_libmcl.genmc
mc_libmcl.genmc:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	64
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       [rdi+33],	sil
    inc       qword ptr[rip+mc_libmcl.mclseqno]
    mov       rax,	[rip+mc_libmcl.mclseqno]
    mov       [rdi+36],	eax
    mov       eax,	[rip+pc_decls.mmpos]
    mov       [rdi+40],	eax
    mov       [rdi+16],	r12
    mov       [rdi+24],	r13
    mov       rax,	rsi
    cmp       rax,	14
    jz        L2842
    cmp       rax,	9
    jz        L2843
    cmp       rax,	11
    jz        L2844
    jmp       L2845
L2842:
    test      r13,	r13
    jz        L2847
    movzx     rax,	word ptr[r13+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jnz       L2847
    mov       rax,	[r13]
    mov       r10b,	1
    mov       [rax+88],	r10b
L2847:
    jmp       L2841
L2843:
    mov       rbx,	[r12]
    jmp       L2841
L2844:
    movzx     rax,	word ptr[r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L2850
    test      r13,	r13
    jz        L2849
    movzx     rax,	word ptr[r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L2849
L2850:
    movzx     rax,	word ptr[r12+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L2852
    mov       rax,	17
    jmp       L2851
L2852:
    mov       rax,	16
L2851:
    mov       [rdi+33],	al
L2849:
L2845:
L2841:
    mov       rax,	[rip+mc_decls.mccode]
    test      rax,	rax
    jz        L2854
    mov       rax,	[rip+mc_decls.mccodex]
    mov       [rdi],	rax
    mov       rax,	rdi
    mov       r10,	[rip+mc_decls.mccodex]
    mov       [r10+8],	rax
    mov       [rip+mc_decls.mccodex],	rdi
    jmp       L2853
L2854:
    mov       rax,	rdi
    mov       [rip+mc_decls.mccodex],	rax
    mov       [rip+mc_decls.mccode],	rax
L2853:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.genmc_cond
mc_libmcl.genmc_cond:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_libmcl.genmc
    mov       al,	bl
    mov       r10,	[rip+mc_decls.mccodex]
    mov       [r10+34],	al
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.genmc_str
mc_libmcl.genmc_str:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	-1
    call      mc_libmcl.mgenstring
    mov       rcx,	rdi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.newmclopnd
mc_libmcl.newmclopnd:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    inc       qword ptr[rip+mc_libmcl.nmclopnd]
    mov       rax,	rdi
L2857:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.duplopnd
mc_libmcl.duplopnd:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	rbx
    movdqu    XMM4,	[rax]
    movdqu    [rdi],	XMM4
    mov       rax,	rdi
L2858:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenindex
mc_libmcl.mgenindex:
#PROC1
#PROC2
#?>>
    .set mc_libmcl.mgenindex.size, 96
    .set mc_libmcl.mgenindex.labno, 104
    .set mc_libmcl.mgenindex.def, 112
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r15w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       [rdi+10],	bl
    cmp       rbx,	15
    jz        L2862
    cmp       rsi,	15
    jnz       L2861
L2862:
    mov       al,	1
    lea       r10,	[rip+mc_decls.usedregs]
    mov       [r10+14],	al
L2861:
    mov       [rdi+11],	sil
    lea       rax,	[rdi+8]
    mov       r10w,	r12w
    mov       r15w,	[rax]
    mov       r11,	-481
    shl       r10w,	5
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    lea       rax,	[rdi+8]
    mov       r10w,	[rbp + mc_libmcl.mgenindex.size]
    mov       r15w,	[rax]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       [rdi+12],	r13d
    mov       rax,	[rbp + mc_libmcl.mgenindex.labno]
    test      rax,	rax
    jz        L2864
    mov       rax,	[rbp + mc_libmcl.mgenindex.labno]
    mov       [rdi],	rax
    lea       rax,	[rdi+8]
    mov       r10w,	6
    mov       r15w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    jmp       L2863
L2864:
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    test      rax,	rax
    jz        L2865
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    mov       [rdi],	rax
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    lea       rax,	[rax+89]
    inc       byte ptr[rax]
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r15w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r15w,	r11w
    or        r15w,	r10w
    mov       [rax],	r15w
    mov       rax,	[rbp + mc_libmcl.mgenindex.def]
    movzx     rax,	byte ptr[rax+72]
    cmp       rax,	4
    jz        L2868
    cmp       rax,	5
    jnz       L2867
L2868:
    mov       al,	15
    mov       [rdi+10],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.usedregs]
    mov       [r10+14],	al
L2867:
L2865:
L2863:
    mov       rax,	rdi
L2859:
#---------------
    add       rsp,	32
    pop       rbp
    pop       r15
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgencomment
mc_libmcl.mgencomment:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	3
    mov       rdx,	rdi
    call      mc_libmcl.genmc_str
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenstring
mc_libmcl.mgenstring:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    cmp       rsi,	0
    jge       L2872
    mov       rcx,	rbx
    call      strlen
    mov       rsi,	rax
L2872:
    lea       rax,	[rsi+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rdi],	rax
    mov       rax,	[rdi]
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      memcpy
    mov       rax,	[rdi]
    xor       r10d,	r10d
    mov       r11,	rsi
    mov       [rax + r11],	r10b
    lea       rax,	[rdi+8]
    mov       r10w,	4
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2870:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenname
mc_libmcl.mgenname:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    mov       [rdi],	rax
    lea       rax,	[rdi+8]
    mov       r10w,	7
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2873:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.setsegment
mc_libmcl.setsegment:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    cmp       rsi,	[rip+mc_decls.currsegment]
    jz        L2876
    mov       rax,	rsi
    cmp       rax,	73
    jz        L2878
    cmp       rax,	90
    jz        L2879
    cmp       rax,	67
    jz        L2880
    cmp       rax,	82
    jz        L2881
    jmp       L2882
L2878:
    mov       rdi,	121
    jmp       L2877
L2879:
    mov       rdi,	122
    jmp       L2877
L2880:
    mov       rdi,	123
    jmp       L2877
L2881:
    lea       rcx,	[rip+L10682]
    lea       rdx,	[rip+L10683]
    call      pc_api.merror
    jmp       L2877
L2882:
    lea       rcx,	[rip+L10684]
    lea       rdx,	[rip+L10685]
    call      pc_api.merror
L2877:
    mov       rax,	[rip+mc_decls.mccodex]
    test      rax,	rax
    jz        L2884
    mov       rax,	[rip+mc_decls.mccodex]
    movzx     rax,	byte ptr[rax+33]
    cmp       rax,	121
    jz        L2885
    cmp       rax,	122
    jz        L2885
    cmp       rax,	123
    jnz       L2884
L2885:
    mov       al,	dil
    mov       r10,	[rip+mc_decls.mccodex]
    mov       [r10+33],	al
    jmp       L2883
L2884:
    mov       rcx,	rdi
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2883:
    mov       [rip+mc_decls.currsegment],	rsi
L2876:
    cmp       r12,	1
    jle       L2887
    mov       rax,	[rip+mc_decls.mccodex]
    movzx     rax,	byte ptr[rax+33]
    cmp       rax,	124
    jnz       L2889
    mov       rax,	[rip+mc_decls.mccodex]
    mov       rax,	[rax+16]
    mov       rbx,	[rax]
    cmp       rbx,	r12
    jge       L2874
L2891:
L2889:
    mov       rcx,	r12
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	124
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
L2887:
L2874:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.changeopndsize
mc_libmcl.changeopndsize:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L2894
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L2896
    movzx     rax,	byte ptr[rbx+10]
    lea       r10,	[rip+mc_decls.regtable]
    mov       r11,	rax
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       rax,	rsi
    mov       r10,	[r10 + rax*8-8]
    mov       rdi,	r10
    jmp       L2895
L2896:
    mov       rcx,	rbx
    call      mc_libmcl.duplopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	si
    mov       r8w,	[rax]
    mov       r11,	-32
    and       r8w,	r11w
    or        r8w,	r10w
    mov       [rax],	r8w
L2895:
    mov       rax,	rdi
    jmp       L2892
L2894:
    mov       rax,	rbx
L2892:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.applyoffset
mc_libmcl.applyoffset:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    test      rsi,	rsi
    jnz       L2899
    test      r12,	r12
    jnz       L2899
    mov       rax,	rbx
    jmp       L2897
L2899:
    mov       rcx,	rbx
    call      mc_libmcl.duplopnd
    mov       rdi,	rax
    lea       rax,	[rdi+12]
    mov       r10d,	esi
    add       [rax],	r10d
    test      r12,	r12
    jz        L2901
    lea       rax,	[rdi+8]
    mov       r10w,	r12w
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L2901:
    mov       rax,	rdi
L2897:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenint
mc_libmcl.mgenint:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+pc_tables.psize]
    mov       r10,	r12
    movzx     rax,	byte ptr[rax + r10]
    mov       rbx,	rax
    mov       rax,	rsi
    cmp       rax,	-1
    jl        L2904
    cmp       rax,	10
    jg        L2904
    cmp       rbx,	8
    jnz       L2904
    lea       rax,	[rip+mc_libmcl.smallinttable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8+8]
    jmp       L2902
L2904:
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi],	rsi
    lea       rax,	[rdi+8]
    mov       r10w,	1
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	bx
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2902:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenint0
mc_libmcl.mgenint0:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi],	rbx
    lea       rax,	[rdi+8]
    mov       r10w,	1
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	si
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2905:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenrealmem
mc_libmcl.mgenrealmem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
#?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rbx-1]
    test      rax,	rax
    jz        L2908
    movq      XMM0,	XMM15
    call      mc_libmcl.getrealindex
    mov       [rdi],	rax
    jmp       L2907
L2908:
    movq      XMM0,	XMM15
    call      mc_libmcl.getr32index
    mov       [rdi],	rax
L2907:
    lea       rax,	[rdi+8]
    mov       r10w,	6
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rip+pc_tables.psize]
    mov       r10,	rbx
    movzx     rax,	byte ptr[rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       rax,	rdi
L2906:
#---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenrealimm
mc_libmcl.mgenrealimm:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    movq      rax,	XMM15
    push      rax
#?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    movq      XMM4,	XMM15
    movq      [rdi],	XMM4
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rip+pc_tables.psize]
    mov       r10,	rbx
    movzx     rax,	byte ptr[rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       rax,	rdi
L2909:
#---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenlabel
mc_libmcl.mgenlabel:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    test      rbx,	rbx
    jnz       L2912
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rbx,	[rip+pc_api.mlabelno]
L2912:
    mov       [rdi],	rbx
    lea       rax,	[rdi+8]
    mov       r10w,	6
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2910:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenlabelmem
mc_libmcl.mgenlabelmem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      mc_libmcl.mgenlabel
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2913:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenmem
mc_libmcl.mgenmem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    mov       al,	[rsi+90]
    test      al,	al
    jz        L2916
    movzx     rax,	byte ptr[rsi+82]
    lea       r10,	[rip+pc_tables.pfloat]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L2918
    mov       rcx,	rsi
    call      mc_libmcl.mgenxregvar
    jmp       L2914
L2918:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mc_libmcl.mgenregvar
    jmp       L2914
L2917:
L2916:
    xor       rbx,	rbx
    movzx     rax,	byte ptr[rsi+72]
    cmp       rax,	4
    jz        L2921
    cmp       rax,	5
    jnz       L2920
L2921:
    mov       rbx,	15
    mov       al,	1
    lea       r10,	[rip+mc_decls.usedregs]
    mov       [r10+14],	al
L2920:
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi+10],	bl
    mov       [rdi],	rsi
    lea       rax,	[rsi+89]
    inc       byte ptr[rax]
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    test      r12,	r12
    jz        L2923
    lea       rax,	[rip+pc_tables.psize]
    mov       r10,	r12
    movzx     rax,	byte ptr[rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    jmp       L2922
L2923:
    mov       eax,	[rsi+84]
    mov       r10,	8
    cmp       rax,	r10
    cmova     rax,	r10
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L2922:
    mov       rax,	rdi
L2914:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenmemaddr
mc_libmcl.mgenmemaddr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       al,	1
    mov       [rbx+88],	al
    lea       rax,	[rbx+89]
    inc       byte ptr[rax]
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	2
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi],	rbx
    lea       rax,	[rbx+89]
    inc       byte ptr[rax]
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       rax,	rdi
L2924:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenreg0
mc_libmcl.mgenreg0:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	1
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi+10],	bl
    lea       rax,	[rdi+8]
    mov       r10w,	si
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    test      rsi,	rsi
    jnz       L2927
    lea       rcx,	[rip+L10686]
    lea       rdx,	[rip+L10687]
    call      pc_api.merror
L2927:
    mov       rax,	rdi
L2925:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenxreg
mc_libmcl.mgenxreg:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi+10],	bl
    lea       rax,	[rdi+8]
    mov       r10w,	si
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    test      rsi,	rsi
    jnz       L2930
    lea       rcx,	[rip+L10688]
    lea       rdx,	[rip+L10689]
    call      pc_api.merror
L2930:
    mov       rax,	rdi
L2928:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenreg
mc_libmcl.mgenreg:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+pc_tables.psize]
    mov       r10,	r12
    movzx     rax,	byte ptr[rax + r10]
    mov       rbx,	rax
    cmp       r12,	2
    jg        L2933
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	5
    mov       r8w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r8w,	r11w
    or        r8w,	r10w
    mov       [rax],	r8w
    mov       [rdi+10],	sil
    mov       al,	1
    lea       r10,	[rip+mc_decls.usedxregs]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    lea       rax,	[rip+pc_tables.psize]
    mov       r10,	r12
    movzx     rax,	byte ptr[rax + r10]
    lea       r10,	[rdi+8]
    mov       r8w,	[r10]
    mov       r11,	-32
    and       r8w,	r11w
    or        r8w,	ax
    mov       [r10],	r8w
    mov       rax,	rdi
    jmp       L2932
L2933:
    test      rbx,	rbx
    jnz       L2935
    mov       rbx,	8
L2935:
    mov       al,	1
    lea       r10,	[rip+mc_decls.usedregs]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    mov       rax,	rsi
    cmp       rax,	11
    jl        L2937
    cmp       rax,	14
    jg        L2937
    mov       al,	1
    lea       r10,	[rip+mc_decls.regset]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
L2937:
    lea       rax,	[rip+mc_decls.regtable]
    mov       r10,	rsi
    shl       r10,	6
    lea       rax,	[rax + r10-64]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    jmp       L2931
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg0
L2932:
L2931:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenregi
mc_libmcl.mgenregi:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.regtable]
    mov       r10,	rdi
    shl       r10,	6
    lea       rax,	[rax + r10-64]
    lea       r10,	[rip+pc_tables.psize]
    mov       r11,	rbx
    movzx     r10,	byte ptr[r10 + r11]
    mov       rax,	[rax + r10*8-8]
    jmp       L2938
    lea       rax,	[rip+pc_tables.psize]
    mov       r10,	rbx
    movzx     rax,	byte ptr[rax + r10]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mc_libmcl.mgenreg0
L2938:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenireg
mc_libmcl.mgenireg:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       [rdi+10],	bl
    lea       rax,	[rip+pc_tables.psize]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       [rdi+12],	r12d
    mov       rax,	rdi
L2939:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgentemp
mc_libmcl.mgentemp:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.pcltempflags]
    mov       r10,	rbx
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L2942
    lea       rax,	[rip+pc_tables.psize]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10]
    lea       r10,	[rip+mc_decls.pcltempopnds]
    mov       r11,	rbx
    mov       r10,	[r10 + r11*8-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.changeopndsize
    jmp       L2940
L2942:
    call      mc_libmcl.newmclopnd
    mov       rdi,	rax
    lea       rax,	[rdi+8]
    mov       r10w,	3
    mov       r9w,	[rax]
    mov       r11,	-3585
    shl       r10w,	9
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    mov       al,	15
    mov       [rdi+10],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.usedregs]
    mov       [r10+14],	al
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-61441
    shl       r10w,	12
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    lea       rax,	[rip+pc_tables.psize]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10]
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       [rdi],	rbx
    mov       rax,	rdi
    lea       r10,	[rip+mc_decls.pcltempopnds]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
    mov       al,	1
    lea       r10,	[rip+mc_decls.pcltempflags]
    mov       r11,	rbx
    mov       [r10 + r11-1],	al
    mov       rax,	rdi
L2940:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.roundsizetg
mc_libmcl.roundsizetg:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	rcx
    and       rax,	7
    jnz       L2945
    mov       rax,	rcx
    jmp       L2943
L2945:
    mov       rax,	rcx
    and       rax,	7
    mov       r10,	8
    sub       r10,	rax
    mov       rax,	rcx
    add       rax,	r10
L2943:
#---------------
    ret       
# End 
# Proc mc_libmcl.merroropnd
mc_libmcl.merroropnd:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10690]
    call      msys.m$print_setfmt
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    lea       rax,	[rip+pc_tables.opndnames]
    mov       r10,	rbx
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mcreatefwdlabel
mc_libmcl.mcreatefwdlabel:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rax,	[rip+pc_api.mlabelno]
L2947:
#---------------
    ret       
# End 
# Proc mc_libmcl.mdefinefwdlabel
mc_libmcl.mdefinefwdlabel:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      mc_libmcl.mgenlabel
    mov       rcx,	9
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenextname
mc_libmcl.mgenextname:
#PROC1
#PROC2
#?>>
    .set mc_libmcl.mgenextname.str, -64
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + mc_libmcl.mgenextname.str]
    mov       rdx,	rbx
    call      strcpy
    mov       rcx,	rbx
    call      strlen
    xor       r10d,	r10d
    mov       [rbp + rax + mc_libmcl.mgenextname.str-1],	r10b
    lea       rcx,	[rbp + mc_libmcl.mgenextname.str]
    call      mc_libmcl.findnamesym
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L2951
    mov       rcx,	128
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    lea       rcx,	[rbp + mc_libmcl.mgenextname.str]
    call      mlib.pcm_copyheapstring
    mov       [rdi],	rax
    mov       al,	1
    mov       [rdi+72],	al
    mov       al,	1
    mov       [rdi+80],	al
    mov       rcx,	rdi
    call      mc_libmcl.addnamesym
L2951:
    mov       rcx,	rdi
    call      mc_libmcl.mgenmemaddr
L2949:
#---------------
    add       rsp,	96
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenregvar
mc_libmcl.mgenregvar:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rbx+90]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      mc_libmcl.mgenreg
    mov       rdi,	rax
    mov       rax,	rdi
L2952:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.mgenxregvar
mc_libmcl.mgenxregvar:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rbx+90]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_libmcl.mgenxreg
    mov       rdi,	rax
    movzx     rax,	byte ptr[rbx+90]
    mov       r10b,	1
    lea       r11,	[rip+mc_decls.isxregvar]
    mov       [r11 + rax-1],	r10b
    mov       rax,	rdi
L2953:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.getprimreg
mc_libmcl.getprimreg:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       al,	[rcx+10]
    test      al,	al
    jz        L2956
    movzx     rax,	byte ptr[rcx+10]
    jmp       L2955
L2956:
    movzx     rax,	byte ptr[rcx+11]
L2955:
L2954:
#---------------
    ret       
# End 
# Proc mc_libmcl.pushslots
mc_libmcl.pushslots:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	rdi
    shl       rax,	3
    mov       rcx,	rax
    call      mc_libmcl.pushstack
    mov       rax,	rdi
    add       [rip+mc_decls.mstackdepth],	rax
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.popslots
mc_libmcl.popslots:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	rdi
    shl       rax,	3
    mov       rcx,	rax
    call      mc_libmcl.popstack
    mov       rax,	rdi
    sub       [rip+mc_decls.mstackdepth],	rax
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.pushstack
mc_libmcl.pushstack:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    test      rdi,	rdi
    jz        L2961
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	29
    mov       rdx,	[rip+mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2961:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.popstack
mc_libmcl.popstack:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    test      rdi,	rdi
    jz        L2964
    mov       rcx,	rdi
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rcx,	28
    mov       rdx,	[rip+mc_decls.dstackopnd]
    mov       r8,	rax
    call      mc_libmcl.genmc
L2964:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.getstringindex
mc_libmcl.getstringindex:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    test      rdi,	rdi
    jnz       L2967
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rax,	[rip+pc_api.mlabelno]
    mov       [rip+mc_decls.kk0used],	rax
    mov       rax,	[rip+mc_decls.kk0used]
    jmp       L2965
L2967:
    mov       rax,	[rip+mc_decls.cstringlist]
    test      rax,	rax
    jz        L2969
    mov       rax,	[rip+mc_decls.cstringlist]
    mov       rax,	[rax]
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mlib.eqstring
    test      rax,	rax
    jz        L2969
    mov       rax,	[rip+mc_decls.cstringlist]
    mov       rax,	[rax+16]
    jmp       L2965
L2969:
    lea       rcx,	[rip+mc_decls.cstringlist]
    mov       rdx,	rdi
    call      mc_libmcl.addconst
L2965:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.addconst
mc_libmcl.addconst:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	24
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       [rdi],	rsi
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rax,	[rip+pc_api.mlabelno]
    mov       [rdi+16],	rax
    mov       rax,	[rbx]
    mov       [rdi+8],	rax
    mov       [rbx],	rdi
    mov       rax,	[rip+pc_api.mlabelno]
L2970:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.getrealindex
mc_libmcl.getrealindex:
#PROC1
#PROC2
#?>>
    movq      rax,	XMM15
    push      rax
#?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
#---------------
#PROC3
#PROC4
    movq      XMM4,	XMM15
    movq      rax,	XMM4
    lea       rcx,	[rip+mc_decls.creallist]
    mov       rdx,	rax
    call      mc_libmcl.addconst
L2971:
#---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    ret       
# End 
# Proc mc_libmcl.getr32index
mc_libmcl.getr32index:
#PROC1
#PROC2
#?>>
    movq      rax,	XMM15
    push      rax
#?]]
    sub       rsp,	48
    movq      XMM15,	XMM0
#---------------
#PROC3
#PROC4
    movq      XMM4,	XMM15
    movq      rax,	XMM4
    lea       rcx,	[rip+mc_decls.cr32list]
    mov       rdx,	rax
    call      mc_libmcl.addconst
L2972:
#---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    ret       
# End 
# Proc mc_libmcl.ispoweroftwo
mc_libmcl.ispoweroftwo:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    xor       rbx,	rbx
    mov       rax,	60
    mov       rsi,	rax
L2974:
    inc       rbx
    mov       rax,	rdi
    shl       rax,	1
    mov       rdi,	rax
    cmp       rdi,	rcx
    jnz       L2978
    mov       rax,	rbx
    jmp       L2973
L2978:
    dec       rsi
    jnz       L2974
    xor       eax,	eax
L2973:
#---------------
    add       rsp,	16
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.axerror
mc_libmcl.axerror:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10691]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L10692]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+mc_decls.aapos]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.newblocktemp
mc_libmcl.newblocktemp:
#PROC1
#PROC2
#?>>
    .set mc_libmcl.newblocktemp.str, -16
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.nblocktemps]
    cmp       rax,	50
    jle       L2982
    lea       rcx,	[rip+L10693]
    lea       rdx,	[rip+L10694]
    call      pc_api.merror
L2982:
    inc       qword ptr[rip+mc_decls.nblocktemps]
    lea       rcx,	[rbp + mc_libmcl.newblocktemp.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10695]
    call      msys.m$print_setfmt
    mov       rcx,	[rip+mc_decls.nblocktemps]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + mc_libmcl.newblocktemp.str]
    mov       rdx,	8
    call      pc_api.pc_makesymbol
    mov       rdi,	rax
    mov       al,	11
    mov       [rdi+82],	al
    mov       [rdi+84],	ebx
    mov       al,	1
    mov       [rdi+92],	al
    mov       al,	4
    mov       [rdi+72],	al
    mov       rax,	[rip+pc_decls.currfunc]
    mov       rax,	[rax+24]
    mov       [rdi+24],	rax
    mov       rax,	[rip+pc_decls.currfunc]
    mov       [rdi+32],	rax
    mov       rax,	rdi
    mov       r10,	[rip+pc_decls.currfunc]
    mov       [r10+24],	rax
    mov       rax,	rdi
    lea       r10,	[rip+mc_decls.blockdefs]
    mov       r11,	[rip+mc_decls.nblocktemps]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	rdi
L2980:
#---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.findnamesym
mc_libmcl.findnamesym:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+mc_libmcl.nnametable]
    cmp       rax,	1
    jl        L2986
L2984:
    lea       rax,	[rip+mc_libmcl.nametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L2988
    lea       rax,	[rip+mc_libmcl.nametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    jmp       L2983
L2988:
    inc       rdi
    cmp       rdi,	[rip+mc_libmcl.nnametable]
    jle       L2984
L2986:
    xor       eax,	eax
L2983:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.addnamesym
mc_libmcl.addnamesym:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_libmcl.nnametable]
    cmp       rax,	20
    jge       L2991
    inc       qword ptr[rip+mc_libmcl.nnametable]
    mov       rax,	[rip+mc_libmcl.nnametable]
    mov       r10,	rdi
    lea       r11,	[rip+mc_libmcl.nametable]
    mov       [r11 + rax*8-8],	r10
    jmp       L2990
L2991:
    lea       rcx,	[rip+L10696]
    lea       rdx,	[rip+L10697]
    call      pc_api.merror
L2990:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.callproc
mc_libmcl.callproc:
#PROC1
#PROC2
#?>>
    .set mc_libmcl.callproc.cpname, 16
    .set mc_libmcl.callproc.name, 24
    .set mc_libmcl.callproc.lineno, 32
#?]]
#---------------
#PROC3
#PROC4
L2992:
#---------------
    ret       
# End 
# Proc mc_libmcl.mgenstringx
mc_libmcl.mgenstringx:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      mc_libmcl.getstringindex
    mov       rcx,	rax
    call      mc_libmcl.mgenlabelmem
L2993:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_libmcl.clearreg
mc_libmcl.clearreg:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L2996
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
L2996:
    mov       rcx,	40
    mov       rdx,	rdi
    mov       r8,	rdi
    call      mc_libmcl.genmc
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd
mc_stackmcl.getopnd:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	r13
    mov       rsi,	[rax + r10*8-8]
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	r13
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	1
    jz        L2999
    cmp       rax,	2
    jz        L2999
    cmp       rax,	3
    jz        L3000
    jmp       L3001
L2999:
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	r13
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenreg
    jmp       L2997
L3000:
    mov       rcx,	r13
    mov       rdx,	r14
    call      mc_libmcl.mgentemp
    mov       rbx,	rax
    mov       rax,	rbx
    jmp       L2997
L3001:
L2998:
    movzx     rax,	byte ptr[rsi+1]
    cmp       rax,	1
    jz        L3003
    cmp       rax,	2
    jz        L3004
    cmp       rax,	4
    jz        L3005
    cmp       rax,	5
    jz        L3006
    cmp       rax,	6
    jz        L3006
    cmp       rax,	7
    jz        L3007
    cmp       rax,	3
    jz        L3008
    jmp       L3009
L3003:
    mov       r12,	[rsi+8]
    cmp       r14,	11
    jnz       L3011
    movzx     rax,	byte ptr[r12+72]
    cmp       rax,	5
    jz        L3011
    mov       r14,	6
    jmp       L3004
L3011:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenmem
    mov       rdi,	rax
L3010:
    jmp       L3002
L3004:
    mov       r12,	[rsi+8]
    movzx     rax,	byte ptr[r12+72]
    cmp       rax,	5
    jnz       L3013
    movzx     rax,	byte ptr[r12+82]
    cmp       rax,	11
    jnz       L3013
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenmem
    mov       rdi,	rax
    jmp       L3012
L3013:
    mov       rcx,	r15
    mov       rdx,	r14
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenmem
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
L3012:
    jmp       L3002
L3005:
    lea       rax,	[rip+pc_tables.psize]
    mov       r10,	r14
    movzx     rax,	byte ptr[rax + r10]
    cmp       rax,	2
    jz        L3015
    cmp       rax,	4
    jz        L3016
    jmp       L3017
L3015:
    lea       rax,	[rsi+8]
    mov       r10,	65535
    and       [rax],	r10
    jmp       L3014
L3016:
    lea       rax,	[rsi+8]
    mov       r10,	4294967295
    and       [rax],	r10
L3017:
L3014:
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	r14
    call      mc_libmcl.mgenint
    mov       rbx,	rax
    mov       rax,	[rsi+8]
    cmp       rax,	-2147483648
    jl        L3019
    cmp       rax,	2147483647
    jg        L3019
    mov       rdi,	rbx
    jmp       L3018
L3019:
    mov       rcx,	r15
    mov       rdx,	r14
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L3018:
    jmp       L3002
L3006:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	r14
    call      mc_libmcl.mgenrealmem
    mov       rdi,	rax
    jmp       L3002
L3007:
    mov       rcx,	r15
    mov       rdx,	r14
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.getstringindex
    mov       rcx,	rax
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L3002
L3008:
    mov       rcx,	r15
    mov       rdx,	r14
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      mc_libmcl.mgenlabelmem
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rax
    call      mc_libmcl.genmc
    jmp       L3002
L3009:
#mc_stackmcl.getopnd.error:
    movzx     rax,	byte ptr[rsi+1]
    lea       r10,	[rip+pc_tables.opndnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rip+L10698]
    mov       rdx,	r10
    call      pc_api.merror
L3002:
    mov       rax,	rdi
L2997:
#---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.loadopnd
mc_stackmcl.loadopnd:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_stackmcl.getopnd
    mov       rdi,	rax
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rbx
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	2
    jnz       L3023
    test      r12,	r12
    jnz       L3025
    mov       rcx,	rsi
    call      mc_stackmcl.getworkreg
    mov       r12,	rax
L3025:
L3023:
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_stackmcl.loadtoreg
    mov       rdi,	rax
    xor       eax,	eax
    lea       r10,	[rip+mc_decls.pclopnd]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
    mov       al,	1
    lea       r10,	[rip+mc_decls.pclloc]
    mov       r11,	rbx
    mov       [r10 + r11-1],	al
    mov       al,	[rdi+10]
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	rbx
    mov       [r10 + r11-1],	al
    mov       rax,	rdi
L3021:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.loadparam
mc_stackmcl.loadparam:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_stackmcl.getopnd
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rsi
    mov       r8,	r12
    call      mc_stackmcl.loadtoreg_m
    mov       rdi,	rax
    mov       rax,	rdi
L3026:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.pushopnd
mc_stackmcl.pushopnd:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	r12
    mov       rsi,	[rax + r10*8-8]
    test      r13,	r13
    jnz       L3029
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	r12
    movzx     rax,	byte ptr[rax + r10-1]
    mov       r13,	rax
L3029:
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	r12
    movzx     rax,	byte ptr[rax + r10-1]
    test      rax,	rax
    jnz       L3031
    movzx     rax,	byte ptr[rsi+1]
    cmp       rax,	1
    jz        L3033
    cmp       rax,	4
    jz        L3034
    cmp       rax,	5
    jz        L3035
    jmp       L3036
L3033:
    lea       rax,	[rip+pc_tables.psize]
    mov       r10,	r13
    movzx     rax,	byte ptr[rax + r10]
    cmp       rax,	8
    jnz       L3038
    movzx     rax,	byte ptr[rip+mc_decls.pmode]
    mov       r10,	[rsi+8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_libmcl.mgenmem
    mov       rdi,	rax
    jmp       L3039
L3038:
    jmp       L3032
L3034:
    mov       rax,	[rsi+8]
    cmp       rax,	-2147483648
    jl        L3041
    cmp       rax,	2147483647
    jg        L3041
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    mov       rdx,	10
    call      mc_libmcl.mgenint
    mov       rdi,	rax
    jmp       L3039
L3041:
    jmp       L3032
L3035:
    movq      XMM4,	[rsi+8]
    movq      XMM0,	XMM4
    mov       rdx,	2
    call      mc_libmcl.mgenrealmem
    mov       rdi,	rax
    jmp       L3039
L3036:
L3032:
L3031:
    mov       rcx,	r12
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rdi,	rax
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L3043
    mov       rbx,	rdi
    cmp       r13,	4
    jnz       L3045
    mov       rax,	5
    jmp       L3044
L3045:
    mov       rax,	6
L3044:
    mov       rcx,	rax
    call      mc_stackmcl.getworkregm
    mov       rdi,	rax
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L3043:
#mc_stackmcl.pushopnd.pushit:
L3039:
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_libmcl.changeopndsize
    mov       rcx,	12
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_libmcl.genmc
    call      mc_stackmcl.poppcl
    inc       qword ptr[rip+mc_decls.mstackdepth]
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg
mc_stackmcl.loadtoreg:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3049
    cmp       rax,	5
    jnz       L3048
L3049:
    test      r12,	r12
    jz        L3052
    movzx     rax,	byte ptr[rbx+10]
    cmp       rax,	r12
    jnz       L3051
L3052:
    mov       rax,	rbx
    jmp       L3046
L3051:
L3048:
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mc_stackmcl.getworkreg_rm
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_stackmcl.loadtoreg_common
    mov       rax,	rdi
L3046:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg_m
mc_stackmcl.loadtoreg_m:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3056
    cmp       rax,	5
    jnz       L3055
L3056:
    movzx     rax,	byte ptr[rbx+10]
    cmp       rax,	r12
    jnz       L3058
    mov       rax,	rbx
    jmp       L3053
L3058:
L3055:
    mov       rcx,	r12
    mov       rdx,	rsi
    call      mc_libmcl.mgenreg
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_stackmcl.loadtoreg_common
    mov       rax,	rdi
L3053:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.loadtoreg_common
mc_stackmcl.loadtoreg_common:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3061
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jnz       L3061
    mov       rax,	[rbx]
    test      rax,	rax
    jnz       L3061
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mc_libmcl.clearreg
    jmp       L3060
L3061:
    mov       rcx,	11
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_libmcl.genmc
L3060:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.pushpcl
mc_stackmcl.pushpcl:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.noperands]
    cmp       rax,	50
    jl        L3064
    lea       rcx,	[rip+L10699]
    lea       rdx,	[rip+L10700]
    call      pc_api.merror
L3064:
    inc       qword ptr[rip+mc_decls.noperands]
    mov       rdi,	[rip+mc_decls.noperands]
    xor       eax,	eax
    lea       r10,	[rip+mc_decls.pclloc]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       rax,	rbx
    lea       r10,	[rip+mc_decls.pclopnd]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    xor       eax,	eax
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.pclcount]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	[rbx+3]
    lea       r10,	[rip+mc_decls.pclmode]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    movzx     rax,	byte ptr[rbx+1]
    cmp       rax,	1
    jnz       L3066
    mov       rax,	[rbx+8]
    mov       al,	[rax+90]
    test      al,	al
    jz        L3066
    mov       rax,	[rbx+8]
    mov       al,	[rax+90]
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	2
    lea       r10,	[rip+mc_decls.pclloc]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
L3066:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.pushpcl_reg
mc_stackmcl.pushpcl_reg:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.noperands]
    cmp       rax,	50
    jl        L3069
    lea       rcx,	[rip+L10701]
    lea       rdx,	[rip+L10702]
    call      pc_api.merror
L3069:
    test      rsi,	rsi
    jnz       L3071
    mov       rcx,	rbx
    call      mc_stackmcl.getworkreg
    mov       rsi,	rax
L3071:
    inc       qword ptr[rip+mc_decls.noperands]
    mov       rdi,	[rip+mc_decls.noperands]
    mov       al,	1
    lea       r10,	[rip+mc_decls.pclloc]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[rip+mc_decls.pclopnd]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    mov       al,	sil
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[rip+mc_decls.pclcount]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	bl
    lea       r10,	[rip+mc_decls.pclmode]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    cmp       rbx,	2
    jg        L3073
    mov       al,	1
    lea       r10,	[rip+mc_decls.xregset]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    jmp       L3072
L3073:
    mov       al,	1
    lea       r10,	[rip+mc_decls.regset]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
L3072:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.poppcl
mc_stackmcl.poppcl:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	[rip+mc_decls.noperands]
    cmp       rdi,	0
    jg        L3076
    lea       rcx,	[rip+L10703]
    lea       rdx,	[rip+L10704]
    call      pc_api.merror
L3076:
    lea       rax,	[rip+mc_decls.pclcount]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	1
    jle       L3078
    lea       rax,	[rip+mc_decls.pclcount]
    mov       r10,	rdi
    lea       rax,	[rax + r10-1]
    dec       byte ptr[rax]
    jmp       L3074
L3078:
    dec       qword ptr[rip+mc_decls.noperands]
L3074:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.duplpcl
mc_stackmcl.duplpcl:
#PROC1
#PROC2
#?>>
    .set mc_stackmcl.duplpcl.$T1, -8
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rdi,	rax
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
    mov       rcx,	rdi
    xor       edx,	edx
    call      mc_stackmcl.pushpcl_reg
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rcx,	rax
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       [rbp + mc_stackmcl.duplpcl.$T1],	rax
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rdi
    xor       r8d,	r8d
    call      mc_stackmcl.getopnd
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.duplpcl.$T1]
    call      mc_libmcl.genmc
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.getworkireg
mc_stackmcl.getworkireg:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rbx,	10
L3081:
    mov       rdi,	1
L3084:
    lea       rax,	[rip+mc_decls.workregs]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3088
    lea       rax,	[rip+mc_decls.regset]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10-1]
    test      rax,	rax
    jnz       L3088
    mov       al,	1
    lea       r10,	[rip+mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       rax,	rdi
    jmp       L3080
L3088:
    inc       rdi
    cmp       rdi,	14
    jle       L3084
    call      mc_stackmcl.savenextopnd
    dec       rbx
    jnz       L3081
    lea       rcx,	[rip+L10705]
    lea       rdx,	[rip+L10706]
    call      pc_api.merror
    xor       eax,	eax
L3080:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.getworkxreg
mc_stackmcl.getworkxreg:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	5
L3090:
    lea       rax,	[rip+mc_decls.workxregs]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3094
    lea       rax,	[rip+mc_decls.xregset]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10-1]
    test      rax,	rax
    jnz       L3094
    mov       al,	1
    lea       r10,	[rip+mc_decls.xregset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       rax,	rdi
    jmp       L3089
L3094:
    inc       rdi
    cmp       rdi,	16
    jle       L3090
    lea       rcx,	[rip+L10707]
    lea       rdx,	[rip+L10708]
    call      pc_api.merror
    xor       eax,	eax
L3089:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.getworkregm
mc_stackmcl.getworkregm:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      mc_stackmcl.getworkreg
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mc_libmcl.mgenreg
L3095:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.getworkreg
mc_stackmcl.getworkreg:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    cmp       rdi,	2
    jg        L3098
    call      mc_stackmcl.getworkxreg
    jmp       L3097
L3098:
    call      mc_stackmcl.getworkireg
L3097:
L3096:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.getworkreg_rm
mc_stackmcl.getworkreg_rm:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	rdi
    test      rax,	rax
    jz        L3102
    cmp       rax,	15
    jnz       L3101
L3102:
    mov       rcx,	rbx
    call      mc_stackmcl.getworkregm
    jmp       L3099
L3101:
    cmp       rbx,	2
    jle       L3106
    lea       rax,	[rip+mc_decls.isregvar]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L3105
L3106:
    lea       rax,	[rip+mc_decls.isxregvar]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3104
L3105:
    mov       rcx,	rbx
    call      mc_stackmcl.getworkregm
    jmp       L3099
L3104:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg
L3099:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.saveopnd
mc_stackmcl.saveopnd:
#PROC1
#PROC2
#?>>
    .set mc_stackmcl.saveopnd.$T1, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	1
    jnz       L3107
L3109:
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rdi,	rax
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rbx,	rax
    cmp       rbx,	2
    jle       L3111
    test      r12,	r12
    jnz       L3114
    mov       rax,	rdi
    cmp       rax,	4
    jl        L3115
    cmp       rax,	10
    jle       L3113
L3115:
L3114:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_stackmcl.saveopnd.$T1],	rax
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_libmcl.mgentemp
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L3113:
    xor       eax,	eax
    lea       r10,	[rip+mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    jmp       L3110
L3111:
    test      r12,	r12
    jnz       L3118
    mov       rax,	rdi
    cmp       rax,	1
    jl        L3117
    cmp       rax,	6
    jg        L3117
L3118:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenxreg
    mov       [rbp + mc_stackmcl.saveopnd.$T1],	rax
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_libmcl.mgentemp
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.saveopnd.$T1]
    call      mc_libmcl.genmc
L3117:
    xor       eax,	eax
    lea       r10,	[rip+mc_decls.xregset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
L3110:
    mov       al,	3
    lea       r10,	[rip+mc_decls.pclloc]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
L3107:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.saveopnds
mc_stackmcl.saveopnds:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rbx,	1
    mov       rax,	[rip+mc_decls.noperands]
    sub       rax,	rsi
    mov       rdi,	rax
    cmp       rdi,	1
    jl        L3122
L3120:
    mov       rcx,	rbx
    xor       edx,	edx
    call      mc_stackmcl.saveopnd
    inc       rbx
    cmp       rbx,	rdi
    jle       L3120
L3122:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.savenextopnd
mc_stackmcl.savenextopnd:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+mc_decls.noperands]
    cmp       rax,	1
    jl        L3126
L3124:
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	1
    jnz       L3128
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	2
    jle       L3128
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L3123
L3128:
    inc       rdi
    cmp       rdi,	[rip+mc_decls.noperands]
    jle       L3124
L3126:
L3123:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.savenextxopnd
mc_stackmcl.savenextxopnd:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+mc_decls.noperands]
    cmp       rax,	1
    jl        L3132
L3130:
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	1
    jnz       L3134
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	2
    jg        L3134
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_stackmcl.saveopnd
    jmp       L3129
L3134:
    inc       rdi
    cmp       rdi,	[rip+mc_decls.noperands]
    jle       L3130
L3132:
L3129:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.movetoreg
mc_stackmcl.movetoreg:
#PROC1
#PROC2
#?>>
    .set mc_stackmcl.movetoreg.$T1, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rbx,	rax
    mov       rcx,	[rip+mc_decls.noperands]
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
#mc_stackmcl.movetoreg.retry:
L3136:
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rdi,	rax
    cmp       rdi,	r12
    jz        L3135
L3138:
    cmp       rbx,	2
    jg        L3140
    lea       rax,	[rip+mc_decls.xregset]
    mov       r10,	r12
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3142
    lea       rcx,	[rip+L10709]
    lea       rdx,	[rip+L10710]
    call      pc_api.merror
L3142:
    jmp       L3139
L3140:
    lea       rax,	[rip+mc_decls.regset]
    mov       r10,	r12
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3144
    mov       rsi,	1
    mov       rax,	[rip+mc_decls.noperands]
    cmp       rax,	1
    jl        L3147
L3145:
    cmp       rbx,	2
    jle       L3149
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	r12
    jnz       L3149
    mov       rcx,	rsi
    mov       rdx,	[rip+mc_decls.noperands]
    call      mc_stackmcl.swapopnds
    mov       rcx,	r12
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_stackmcl.movetoreg.$T1],	rax
    mov       rcx,	rdi
    mov       rdx,	6
    call      mc_libmcl.mgenreg
    mov       rcx,	27
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    jmp       L3136
L3149:
    inc       rsi
    cmp       rsi,	[rip+mc_decls.noperands]
    jle       L3145
L3147:
L3144:
L3139:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg
    mov       [rbp + mc_stackmcl.movetoreg.$T1],	rax
    mov       rcx,	r12
    mov       rdx,	rbx
    call      mc_libmcl.mgenreg
    mov       rcx,	11
    mov       rdx,	rax
    mov       r8,	[rbp + mc_stackmcl.movetoreg.$T1]
    call      mc_libmcl.genmc
    mov       al,	r12b
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	[rip+mc_decls.noperands]
    mov       [r10 + r11-1],	al
    cmp       rbx,	2
    jg        L3151
    mov       al,	1
    lea       r10,	[rip+mc_decls.xregset]
    mov       r11,	r12
    mov       [r10 + r11-1],	al
    jmp       L3150
L3151:
    mov       al,	1
    lea       r10,	[rip+mc_decls.regset]
    mov       r11,	r12
    mov       [r10 + r11-1],	al
L3150:
L3135:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd_ind
mc_stackmcl.getopnd_ind:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    test      rax,	rax
    jnz       L3154
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	rsi
    mov       rdi,	[rax + r10*8-8]
    movzx     rax,	byte ptr[rdi+1]
    cmp       rax,	2
    jnz       L3156
    mov       rbx,	[rdi+8]
    movzx     rax,	byte ptr[rbx+72]
    cmp       rax,	5
    jnz       L3159
    movzx     rax,	byte ptr[rbx+82]
    cmp       rax,	11
    jz        L3158
L3159:
    mov       rax,	[rdi+8]
    mov       rcx,	rax
    mov       rdx,	r12
    call      mc_libmcl.mgenmem
    jmp       L3152
L3158:
L3156:
L3154:
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	1
    jz        L3161
    mov       rcx,	rsi
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
L3161:
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rcx,	rax
    mov       rdx,	r12
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
L3152:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.getopnd_ind_simp
mc_stackmcl.getopnd_ind_simp:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	1
    jz        L3164
    mov       rcx,	rdi
    mov       rdx,	6
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
L3164:
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rcx,	rax
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
L3162:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.swapopnds
mc_stackmcl.swapopnds:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	rcx
    lea       rax,	[rax + r10*8-8]
    lea       r10,	[rip+mc_decls.pclopnd]
    mov       r11,	rdx
    lea       r10,	[r10 + r11*8-8]
    mov       r11,	[rax]
    mov       r9,	[r10]
    mov       [r10],	r11
    mov       [rax],	r9
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rcx
    lea       rax,	[rax + r10-1]
    lea       r10,	[rip+mc_decls.pclloc]
    mov       r11,	rdx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	rcx
    lea       rax,	[rax + r10-1]
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	rdx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	rcx
    lea       rax,	[rax + r10-1]
    lea       r10,	[rip+mc_decls.pclmode]
    mov       r11,	rdx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
    lea       rax,	[rip+mc_decls.pclcount]
    mov       r10,	rcx
    lea       rax,	[rax + r10-1]
    lea       r10,	[rip+mc_decls.pclcount]
    mov       r11,	rdx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
#---------------
    ret       
# End 
# Proc mc_stackmcl.isimmload
mc_stackmcl.isimmload:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	rcx
    mov       rdi,	[rax + r10*8-8]
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rcx
    movzx     rax,	byte ptr[rax + r10-1]
    test      rax,	rax
    jnz       L3168
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	1
    jnz       L3168
    movzx     rax,	byte ptr[rdi+1]
    cmp       rax,	4
    jnz       L3168
    mov       rax,	rdi
    jmp       L3167
L3168:
    xor       eax,	eax
L3167:
L3166:
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.setnewzz
mc_stackmcl.setnewzz:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       al,	1
    lea       r10,	[rip+mc_decls.pclloc]
    mov       r11,	[rip+mc_decls.noperands]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[rip+mc_decls.pclopnd]
    mov       r11,	[rip+mc_decls.noperands]
    mov       [r10 + r11*8-8],	rax
    mov       al,	cl
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	[rip+mc_decls.noperands]
    mov       [r10 + r11-1],	al
    mov       al,	dl
    lea       r10,	[rip+mc_decls.pclmode]
    mov       r11,	[rip+mc_decls.noperands]
    mov       [r10 + r11-1],	al
#---------------
    ret       
# End 
# Proc mc_stackmcl.freeworkregs
mc_stackmcl.freeworkregs:
#PROC1
#PROC2
#?>>
    .set mc_stackmcl.freeworkregs.p, 32
    push      rdi
    push      rbx
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.regset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    lea       rax,	[rip+mc_decls.xregset]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       rbx,	1
    mov       rax,	[rip+mc_decls.noperands]
    cmp       rax,	1
    jl        L3173
L3171:
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	rbx
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rdi,	rax
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	rbx
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3175
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	rbx
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	2
    jg        L3177
    mov       al,	1
    lea       r10,	[rip+mc_decls.xregset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    jmp       L3176
L3177:
    mov       al,	1
    lea       r10,	[rip+mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
L3176:
L3175:
    inc       rbx
    cmp       rbx,	[rip+mc_decls.noperands]
    jle       L3171
L3173:
#---------------
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.swapopndregs
mc_stackmcl.swapopndregs:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	2
    jg        L3180
    lea       rcx,	[rip+L10711]
    lea       rdx,	[rip+L10712]
    call      pc_api.merror
L3180:
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	[rip+mc_decls.noperands]
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rdi,	rax
    cmp       rdi,	rsi
    jz        L3178
L3182:
    mov       rax,	[rip+mc_decls.noperands]
    dec       rax
    mov       rbx,	rax
    cmp       rbx,	1
    jl        L3186
L3183:
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rbx
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	1
    jnz       L3188
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	rbx
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	rsi
    jnz       L3188
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	[rip+mc_decls.noperands]
    lea       rax,	[rax + r10-1]
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	rbx
    lea       r10,	[r10 + r11-1]
    mov       r11b,	[rax]
    mov       r9b,	[r10]
    mov       [r10],	r11b
    mov       [rax],	r9b
    jmp       L3178
L3188:
    dec       rbx
    cmp       rbx,	1
    jge       L3183
L3186:
    xor       eax,	eax
    lea       r10,	[rip+mc_decls.regset]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       al,	sil
    lea       r10,	[rip+mc_decls.pclreg]
    mov       r11,	[rip+mc_decls.noperands]
    mov       [r10 + r11-1],	al
L3178:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.makeopndind
mc_stackmcl.makeopndind:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3191
    lea       rcx,	[rip+L10713]
    lea       rdx,	[rip+L10714]
    call      pc_api.merror
L3191:
    movzx     rax,	byte ptr[rdi+10]
    mov       rcx,	rax
    mov       rdx,	rbx
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
L3189:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.makesimpleaddr
mc_stackmcl.makesimpleaddr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[r13+10]
    mov       rsi,	rax
    movzx     rax,	byte ptr[r13+11]
    mov       r12,	rax
    cmp       rsi,	15
    jnz       L3194
    xor       rsi,	rsi
L3194:
    movzx     rax,	word ptr[r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L3196
    lea       rcx,	[rip+L10715]
    lea       rdx,	[rip+L10716]
    call      pc_api.merror
L3196:
    test      rsi,	rsi
    jnz       L3198
    test      r12,	r12
    jnz       L3198
    call      mc_stackmcl.getworkireg
    mov       rbx,	rax
    jmp       L3197
L3198:
    test      rsi,	rsi
    jz        L3199
    mov       rax,	r13
    jmp       L3192
L3199:
    test      r12,	r12
    jz        L3200
    mov       rbx,	r12
    jmp       L3197
L3200:
    mov       rbx,	r12
L3197:
    mov       rcx,	rbx
    mov       rdx,	10
    xor       r8d,	r8d
    call      mc_libmcl.mgenireg
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	10
    call      mc_libmcl.mgenreg
    mov       rcx,	14
    mov       rdx,	rax
    mov       r8,	r13
    call      mc_libmcl.genmc
    mov       rax,	rdi
L3192:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.checkallloaded
mc_stackmcl.checkallloaded:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+mc_decls.noperands]
    cmp       rax,	1
    jl        L3204
L3202:
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10-1]
    test      rax,	rax
    jnz       L3206
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte ptr[rax+1]
    cmp       rax,	1
    jnz       L3206
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte ptr[rax+3]
    mov       rcx,	rdi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_stackmcl.loadopnd
L3206:
    inc       rdi
    cmp       rdi,	[rip+mc_decls.noperands]
    jle       L3202
L3204:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.stropndstack
mc_stackmcl.stropndstack:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_stackmcl.stropndstack.str]
    mov       rdi,	rax
    test      r13,	r13
    jz        L3209
    mov       rcx,	rdi
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10717]
    call      msys.m$print_setfmt
    mov       rcx,	[rip+mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L3208
L3209:
    mov       rcx,	rdi
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10718]
    call      msys.m$print_setfmt
    mov       rcx,	[rip+mc_decls.noperands]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L3208:
    mov       rsi,	1
    mov       rax,	[rip+mc_decls.noperands]
    cmp       rax,	1
    jl        L3212
L3210:
    mov       rax,	[rip+mc_decls.noperands]
    sub       rax,	rsi
    inc       rax
    sub       rax,	1
    cmp       rax,	4
    jae       L3215
    lea       r10,	[rip+L3214]
    jmp       [r10 + rax*8]
    .data
L3214:
    .quad     L3216
    .quad     L3217
    .quad     L3218
    .quad     L3219
    .text
L3216:
    lea       rax,	[rip+L10719]
    jmp       L3213
L3217:
    lea       rax,	[rip+L10720]
    jmp       L3213
L3218:
    lea       rax,	[rip+L10721]
    jmp       L3213
L3219:
    lea       rax,	[rip+L10722]
    jmp       L3213
L3215:
    lea       rax,	[rip+L10723]
L3213:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	1
    jz        L3221
    cmp       rax,	2
    jz        L3221
    cmp       rax,	3
    jz        L3222
    jmp       L3223
L3221:
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	2
    jg        L3225
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    lea       r10,	[rip+mc_decls.xregnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      strcat
    jmp       L3224
L3225:
    lea       rax,	[rip+mc_decls.pclreg]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    lea       r10,	[rip+mc_decls.regnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      strcat
L3224:
    lea       rax,	[rip+mc_decls.pclloc]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	2
    jnz       L3227
    mov       rcx,	rdi
    lea       rdx,	[rip+L10724]
    call      strcat
L3227:
    jmp       L3220
L3222:
    mov       rcx,	rdi
    lea       rdx,	[rip+L10725]
    call      strcat
    mov       rcx,	rsi
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    jmp       L3220
L3223:
    mov       rcx,	rdi
    lea       rdx,	[rip+L10726]
    call      strcat
    movzx     rax,	byte ptr[rip+pc_api.fpshortnames]
    mov       rbx,	rax
    mov       al,	1
    mov       [rip+pc_api.fpshortnames],	al
    lea       rax,	[rip+mc_decls.pclopnd]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      pc_diags.stropnd
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    mov       [rip+pc_api.fpshortnames],	bl
    mov       rcx,	rdi
    lea       rdx,	[rip+L10727]
    call      strcat
L3220:
    lea       rax,	[rip+mc_decls.pclcount]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	1
    jle       L3229
    mov       rcx,	rdi
    lea       rdx,	[rip+L10728]
    call      strcat
L3229:
    mov       rcx,	rdi
    lea       rdx,	[rip+L10729]
    call      strcat
    lea       rax,	[rip+mc_decls.pclmode]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    lea       r10,	[rip+pc_tables.pstdnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      strcat
    mov       rcx,	rdi
    lea       rdx,	[rip+L10730]
    call      strcat
    cmp       rsi,	[rip+mc_decls.noperands]
    jge       L3231
    mov       rcx,	rdi
    lea       rdx,	[rip+L10731]
    call      strcat
L3231:
    inc       rsi
    cmp       rsi,	[rip+mc_decls.noperands]
    jle       L3210
L3212:
    mov       rcx,	rdi
    lea       rdx,	[rip+L10732]
    call      strcat
    lea       rcx,	[rip+mc_stackmcl.stropndstack.str]
    mov       rdx,	50
    lea       r8,	[rip+L10733]
    call      mlib.ipadstr
    mov       rcx,	rdi
    lea       rdx,	[rip+L10734]
    call      strcat
    mov       r12,	1
L3232:
    lea       rax,	[rip+mc_decls.regset]
    mov       r10,	r12
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3236
    lea       rax,	[rip+L10735]
    jmp       L3235
L3236:
    lea       rax,	[rip+L10736]
L3235:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    inc       r12
    cmp       r12,	10
    jle       L3232
    mov       rcx,	rdi
    lea       rdx,	[rip+L10737]
    call      strcat
    mov       rcx,	rdi
    lea       rdx,	[rip+L10738]
    call      strcat
    mov       r12,	1
    mov       rax,	[rip+mc_decls.xregmax]
    cmp       rax,	1
    jl        L3239
L3237:
    lea       rax,	[rip+mc_decls.xregset]
    mov       r10,	r12
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L3241
    lea       rax,	[rip+L10739]
    jmp       L3240
L3241:
    lea       rax,	[rip+L10740]
L3240:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    inc       r12
    cmp       r12,	[rip+mc_decls.xregmax]
    jle       L3237
L3239:
    mov       rcx,	rdi
    lea       rdx,	[rip+L10741]
    call      strcat
    mov       rcx,	[rip+mc_decls.mstackdepth]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    mov       rcx,	rdi
    lea       rdx,	[rip+L10742]
    call      strcat
    mov       rcx,	[rip+mc_decls.noperands]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    mov       rcx,	rdi
    lea       rdx,	[rip+L10743]
    call      strcat
    mov       rcx,	[rip+mc_decls.ncalldepth]
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rdi
    mov       rdx,	rax
    call      strcat
    mov       rax,	rdi
L3207:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_stackmcl.showopndstack
mc_stackmcl.showopndstack:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rcx,	1
    call      mc_stackmcl.stropndstack
    mov       rcx,	rax
    call      mc_libmcl.mgencomment
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_optim.peephole
mc_optim.peephole:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       al,	[rip+pc_decls.fpeephole]
    test      al,	al
    jz        L3243
L3245:
    mov       rax,	[rip+mc_decls.mccode]
    mov       rdi,	[rax+8]
    jmp       L3249
L3246:
    mov       rbx,	[rdi+8]
    mov       rsi,	[rbx+8]
    movzx     rax,	byte ptr[rdi+33]
    cmp       rax,	8
    jz        L3251
    cmp       rax,	11
    jz        L3252
    cmp       rax,	38
    jz        L3253
    cmp       rax,	40
    jz        L3254
    cmp       rax,	26
    jz        L3255
    jmp       L3256
L3251:
    jmp       L3248
L3252:
    movzx     rax,	byte ptr[rbx+33]
    cmp       rax,	11
    jz        L3258
    cmp       rax,	41
    jz        L3259
    cmp       rax,	42
    jz        L3260
    cmp       rax,	28
    jz        L3261
    cmp       rax,	29
    jz        L3261
    cmp       rax,	52
    jz        L3262
    cmp       rax,	53
    jz        L3262
    cmp       rax,	25
    jz        L3263
    jmp       L3264
L3258:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3266
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+24]
    cmp       rax,	r10
    jnz       L3266
    mov       rcx,	rbx
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3266
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg10
    test      rax,	rax
    jnz       L3267
L3268:
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jnz       L3270
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3269
L3270:
    mov       rax,	[rbx+16]
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3269:
L3267:
    jmp       L3265
L3266:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3271
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+24]
    cmp       rax,	r10
    jnz       L3271
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg10
    test      rax,	rax
    jz        L3271
    movzx     rax,	byte ptr[rsi+33]
    cmp       rax,	21
    jnz       L3271
    mov       rcx,	rsi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3271
    mov       rax,	[rbx+16]
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3271:
L3265:
    jmp       L3257
L3259:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3273
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       r10,	rax
    jnz       L3274
    mov       rax,	[rbx+24]
    cmp       r10,	rax
    jnz       L3274
    mov       rax,	1
    jmp       L3275
L3274:
    xor       eax,	eax
L3275:
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    test      ax,	ax
    jz        L3273
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3273
    mov       rcx,	rsi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3273
    mov       al,	41
    mov       [rdi+33],	al
    mov       rax,	[rdi+24]
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
    mov       rdi,	rax
L3273:
    jmp       L3257
L3260:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3277
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       rax,	r10
    jnz       L3277
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3277
    mov       rcx,	rsi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3277
    mov       al,	42
    mov       [rdi+33],	al
    mov       rax,	[rdi+24]
    mov       [rdi+16],	rax
    mov       rax,	[rbx+24]
    mov       [rdi+24],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3277:
    jmp       L3257
L3261:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3279
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       rax,	r10
    jnz       L3279
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3279
    mov       rax,	[rbx+24]
    mov       rcx,	rax
    call      mc_optim.isconst
    test      rax,	rax
    jz        L3279
    mov       al,	14
    mov       [rdi+33],	al
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte ptr[rbx+33]
    cmp       rax,	28
    jnz       L3281
    mov       rax,	[rbx+24]
    mov       rax,	[rax]
    jmp       L3280
L3281:
    mov       rax,	[rbx+24]
    mov       rax,	[rax]
    neg       rax
L3280:
    mov       r10,	[rdi+24]
    movzx     r10,	byte ptr[r10+10]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       [rdi+24],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3279:
    jmp       L3257
L3262:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3283
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       rax,	r10
    jnz       L3283
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3283
    mov       al,	14
    mov       [rdi+33],	al
    sub       rsp,	8
    push      0
    push      0
    push      0
    movzx     rax,	byte ptr[rbx+33]
    cmp       rax,	52
    jnz       L3285
    mov       rax,	1
    jmp       L3284
L3285:
    mov       rax,	-1
L3284:
    mov       r10,	[rdi+24]
    movzx     r10,	byte ptr[r10+10]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	1
    mov       r9,	rax
    sub       rsp,	32
    call      mc_libmcl.mgenindex
    add       rsp,	64
    mov       [rdi+24],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3283:
    jmp       L3257
L3263:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3287
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3287
    mov       al,	25
    mov       [rdi+33],	al
    mov       rax,	[rdi+24]
    mov       [rdi+16],	rax
    xor       eax,	eax
    mov       [rdi+24],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
L3287:
L3264:
L3257:
    jmp       L3250
L3253:
    movzx     rax,	byte ptr[rbx+33]
    cmp       rax,	41
    jnz       L3289
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3291
    mov       rax,	[rdi+16]
    mov       r10,	[rbx+16]
    cmp       r10,	rax
    jnz       L3292
    mov       rax,	[rbx+24]
    cmp       r10,	rax
    jnz       L3292
    mov       rax,	1
    jmp       L3293
L3292:
    xor       eax,	eax
L3293:
    test      rax,	rax
    setnz     al
    movzx     eax,	al
    test      ax,	ax
    jz        L3291
    mov       rcx,	rsi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3291
    mov       rcx,	rbx
    call      mc_optim.deletemcl
    mov       rdi,	rax
L3291:
L3289:
    jmp       L3250
L3254:
    movzx     rax,	byte ptr[rbx+33]
    cmp       rax,	11
    jnz       L3295
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3297
    mov       rax,	[rdi+16]
    mov       r10,	[rdi+24]
    cmp       rax,	r10
    jnz       L3297
    mov       rax,	[rbx+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3297
    mov       rax,	[rbx+24]
    mov       rcx,	rax
    call      mc_optim.isreg0
    test      rax,	rax
    jz        L3297
    mov       rcx,	rbx
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3297
    mov       rax,	[rbx+16]
    mov       [rdi+24],	rax
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
    mov       rdi,	rax
L3297:
L3295:
    jmp       L3250
L3255:
    movzx     rax,	byte ptr[rbx+33]
    cmp       rax,	25
    jnz       L3299
    movzx     rax,	byte ptr[rsi+33]
    cmp       rax,	9
    jnz       L3299
    mov       rax,	[rdi+16]
    mov       rax,	[rax]
    mov       r10,	[rsi+16]
    mov       r10,	[r10]
    cmp       rax,	r10
    jnz       L3299
    mov       rcx,	rdi
    call      mc_optim.endr0
    test      rax,	rax
    jz        L3299
    movzx     rax,	byte ptr[rdi+34]
    lea       r10,	[rip+mc_decls.asmrevcond]
    mov       r10,	[r10 + rax*8]
    mov       [rdi+34],	r10b
    mov       rax,	[rbx+16]
    mov       [rdi+16],	rax
    mov       rcx,	rbx
    call      mc_optim.deletemcl
    mov       rdi,	rax
L3299:
L3256:
L3250:
    mov       rdi,	[rdi+8]
L3249:
    test      rdi,	rdi
    jnz       L3246
L3248:
L3243:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_optim.isreg
mc_optim.isreg:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    setz      al
    movzx     eax,	al
L3300:
#---------------
    ret       
# End 
# Proc mc_optim.isreg0
mc_optim.isreg0:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    test      rcx,	rcx
    jnz       L3303
    xor       eax,	eax
    jmp       L3301
L3303:
    movzx     rax,	word ptr[rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3305
    movzx     rax,	byte ptr[rcx+10]
    cmp       rax,	1
    jnz       L3305
    mov       rax,	1
    jmp       L3301
L3305:
    xor       eax,	eax
L3301:
#---------------
    ret       
# End 
# Proc mc_optim.isreg10
mc_optim.isreg10:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    test      rcx,	rcx
    jnz       L3308
    xor       eax,	eax
    jmp       L3306
L3308:
    movzx     rax,	word ptr[rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3310
    movzx     rax,	byte ptr[rcx+10]
    cmp       rax,	11
    jnz       L3310
    mov       rax,	1
    jmp       L3306
L3310:
    xor       eax,	eax
L3306:
#---------------
    ret       
# End 
# Proc mc_optim.isreg00
mc_optim.isreg00:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    call      mc_optim.isreg
    test      rax,	rax
    jz        L3313
    mov       rax,	[rdi+16]
    mov       r10,	[rdi+24]
    cmp       rax,	r10
    jnz       L3313
    mov       rax,	1
    jmp       L3311
L3313:
    xor       eax,	eax
L3311:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_optim.isconst
mc_optim.isconst:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    test      rcx,	rcx
    jnz       L3316
    xor       eax,	eax
    jmp       L3314
L3316:
    movzx     rax,	word ptr[rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3318
    movzx     rax,	word ptr[rcx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jnz       L3318
    mov       rax,	1
    jmp       L3314
L3318:
    xor       eax,	eax
L3314:
#---------------
    ret       
# End 
# Proc mc_optim.sameoperand
mc_optim.sameoperand:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	16
    call      memcmp
    movsxd    r10,	eax
    cmp       r10,	0
    setz      r10b
    movzx     r10d,	r10b
    mov       rax,	r10
L3319:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_optim.sameregopnd
mc_optim.sameregopnd:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rcx+8]
    shr       rax,	9
    and       rax,	7
    movzx     r10,	word ptr[rdx+8]
    shr       r10,	9
    and       r10,	7
    cmp       r10,	rax
    jnz       L3323
    cmp       r10,	1
    jz        L3322
L3323:
    xor       eax,	eax
    jmp       L3320
L3322:
    movzx     rax,	byte ptr[rcx+10]
    movzx     r10,	byte ptr[rdx+10]
    cmp       rax,	r10
    setz      al
    movzx     eax,	al
L3320:
#---------------
    ret       
# End 
# Proc mc_optim.deletemcl
mc_optim.deletemcl:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	[rsi]
    mov       rbx,	[rsi+8]
    test      rdi,	rdi
    jz        L3327
    test      rbx,	rbx
    jnz       L3326
L3327:
    lea       rcx,	[rip+L10744]
    lea       rdx,	[rip+L10745]
    call      pc_api.merror
L3326:
    mov       [rdi+8],	rbx
    mov       [rbx],	rdi
    mov       rax,	rbx
L3324:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_optim.endr0
mc_optim.endr0:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rcx+48]
    movzx     rax,	byte ptr[rax]
L3328:
#---------------
    ret       
# End 
# Proc mc_genss.genss
mc_genss.genss:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r14,	rcx
#---------------
#PROC3
#PROC4
    mov       al,	[rip+pc_decls.ssdone]
    test      al,	al
    jnz       L3329
L3331:
    call      mwindows.os_clock
    mov       [rip+pc_decls.sstime],	rax
    mov       rcx,	[rip+pc_api.mlabelno]
    call      mc_genss.initlib
    xor       eax,	eax
    mov       [rip+mc_decls.ss_zdatalen],	rax
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [rip+mc_decls.ss_zdata],	rax
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [rip+mc_decls.ss_idata],	rax
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [rip+mc_decls.ss_code],	rax
    xor       eax,	eax
    mov       [rip+mc_decls.ss_idatarelocs],	rax
    xor       eax,	eax
    mov       [rip+mc_decls.ss_coderelocs],	rax
    xor       eax,	eax
    mov       [rip+mc_decls.ss_nsymbols],	rax
    mov       rcx,	1
    call      mc_genss.switchseg
    mov       rax,	9999
    mov       [rip+mc_decls.aaseqno],	rax
    xor       eax,	eax
    mov       [rip+mc_genss.extraparam],	rax
    mov       rbx,	[rip+mc_decls.mccode]
    xor       rdi,	rdi
    jmp       L3333
L3332:
    inc       rdi
    mov       rax,	rdi
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mc_genss.doinstr
    mov       rbx,	[rbx+8]
L3333:
    test      rbx,	rbx
    jnz       L3332
    xor       ecx,	ecx
    call      mc_genss.switchseg
    mov       rcx,	[rip+mc_decls.ss_zdata]
    call      mc_genss.bufferlength
    test      rax,	rax
    jz        L3336
    lea       rcx,	[rip+L10746]
    call      mc_libmcl.axerror
L3336:
    test      r14,	r14
    jz        L3338
    mov       rcx,	[rip+mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       r12,	rax
    mov       rsi,	[rip+mc_decls.riplist]
    jmp       L3342
L3339:
    mov       eax,	[rsi+8]
    lea       r10,	[r12 + rax]
    mov       r13,	r10
    movsxd    rax,	dword ptr[rsi+12]
    mov       r10,	r13
    sub       [r10],	eax
    mov       rsi,	[rsi]
L3342:
    test      rsi,	rsi
    jnz       L3339
L3338:
    mov       al,	1
    mov       [rip+pc_decls.ssdone],	al
    call      mwindows.os_clock
    sub       rax,	[rip+pc_decls.sstime]
    mov       [rip+pc_decls.sstime],	rax
L3329:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.doinstr
mc_genss.doinstr:
#PROC1
#PROC2
#?>>
    .set mc_genss.doinstr.m, 64
    .set mc_genss.doinstr.index, 72
    .set mc_genss.doinstr.n, -8
    .set mc_genss.doinstr.av_1, -16
    .set mc_genss.doinstr.av_2, -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+64],	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_genss.currdata]
    mov       rax,	[rax+16]
    mov       r10,	[rip+mc_genss.currdata]
    mov       r10,	[r10+8]
    sub       rax,	r10
    cmp       rax,	1024
    jge       L3345
    mov       rcx,	[rip+mc_genss.currdata]
    call      mc_genss.bufferexpand
L3345:
    xor       eax,	eax
    mov       [rip+mc_genss.usesizeb],	al
    mov       [rip+mc_genss.nowmask],	al
    mov       [rip+mc_genss.f3override],	al
    mov       [rip+mc_genss.f2override],	al
    mov       [rip+mc_genss.addroverride],	al
    mov       [rip+mc_genss.sizeoverride],	al
    mov       [rip+mc_genss.rex],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       rbx,	[rax+24]
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       eax,	[rax+36]
    mov       [rip+mc_decls.aaseqno],	rax
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       eax,	[rax+40]
    mov       [rip+mc_decls.aapos],	rax
    xor       eax,	eax
    mov       [rip+mc_genss.ripentry],	rax
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       [rip+mc_genss.currmcl],	rax
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    sub       rax,	1
    cmp       rax,	152
    jae       L3348
    lea       r10,	[rip+L3347]
    jmp       [r10 + rax*8]
    .data
L3347:
    .quad     L3349
    .quad     L3350
    .quad     L3472
    .quad     L3353
    .quad     L3351
    .quad     L3352
    .quad     L3348
    .quad     L3472
    .quad     L3360
    .quad     L3381
    .quad     L3395
    .quad     L3390
    .quad     L3391
    .quad     L3396
    .quad     L3454
    .quad     L3438
    .quad     L3439
    .quad     L3397
    .quad     L3398
    .quad     L3399
    .quad     L3365
    .quad     L3386
    .quad     L3348
    .quad     L3387
    .quad     L3366
    .quad     L3367
    .quad     L3400
    .quad     L3394
    .quad     L3394
    .quad     L3394
    .quad     L3394
    .quad     L3393
    .quad     L3393
    .quad     L3401
    .quad     L3348
    .quad     L3393
    .quad     L3393
    .quad     L3394
    .quad     L3394
    .quad     L3394
    .quad     L3432
    .quad     L3394
    .quad     L3431
    .quad     L3431
    .quad     L3431
    .quad     L3431
    .quad     L3431
    .quad     L3431
    .quad     L3431
    .quad     L3393
    .quad     L3393
    .quad     L3392
    .quad     L3392
    .quad     L3382
    .quad     L3383
    .quad     L3384
    .quad     L3385
    .quad     L3437
    .quad     L3468
    .quad     L3468
    .quad     L3471
    .quad     L3471
    .quad     L3440
    .quad     L3441
    .quad     L3440
    .quad     L3441
    .quad     L3440
    .quad     L3441
    .quad     L3440
    .quad     L3441
    .quad     L3440
    .quad     L3441
    .quad     L3444
    .quad     L3445
    .quad     L3445
    .quad     L3442
    .quad     L3443
    .quad     L3442
    .quad     L3443
    .quad     L3443
    .quad     L3443
    .quad     L3448
    .quad     L3449
    .quad     L3450
    .quad     L3451
    .quad     L3452
    .quad     L3453
    .quad     L3447
    .quad     L3446
    .quad     L3464
    .quad     L3464
    .quad     L3348
    .quad     L3348
    .quad     L3456
    .quad     L3456
    .quad     L3456
    .quad     L3457
    .quad     L3457
    .quad     L3457
    .quad     L3458
    .quad     L3458
    .quad     L3458
    .quad     L3458
    .quad     L3455
    .quad     L3455
    .quad     L3455
    .quad     L3455
    .quad     L3455
    .quad     L3455
    .quad     L3455
    .quad     L3455
    .quad     L3440
    .quad     L3440
    .quad     L3441
    .quad     L3441
    .quad     L3374
    .quad     L3375
    .quad     L3376
    .quad     L3377
    .quad     L3374
    .quad     L3379
    .quad     L3380
    .quad     L3378
    .quad     L3415
    .quad     L3402
    .quad     L3402
    .quad     L3402
    .quad     L3402
    .quad     L3436
    .quad     L3433
    .quad     L3433
    .quad     L3433
    .quad     L3434
    .quad     L3435
    .quad     L3459
    .quad     L3460
    .quad     L3461
    .quad     L3462
    .quad     L3463
    .quad     L3467
    .quad     L3470
    .quad     L3465
    .quad     L3466
    .quad     L3466
    .quad     L3466
    .quad     L3466
    .quad     L3466
    .quad     L3466
    .quad     L3466
    .quad     L3469
    .quad     L3348
    .quad     L3381
    .text
L3349:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    mov       rax,	[rax+16]
    mov       rax,	[rax]
    mov       [rip+mc_decls.currasmproc],	rax
    jmp       L3346
L3350:
    jmp       L3346
L3351:
    jmp       L3346
L3352:
    jmp       L3346
L3353:
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	4
    jz        L3355
    cmp       rax,	5
    jz        L3356
    jmp       L3357
L3355:
    jmp       L3354
L3356:
    mov       rsi,	[rdi]
    mov       al,	2
    mov       [rsi+93],	al
    mov       al,	[rip+mc_genss.currseg]
    mov       [rsi+94],	al
    mov       rcx,	6
    call      mc_genss.getcurrdatalen
    mov       [rsi+76],	eax
    mov       al,	[rsi+81]
    test      al,	al
    jz        L3359
    mov       rcx,	rsi
    call      mc_genss.getstindex
L3359:
    mov       rcx,	rsi
    call      mc_genss.dofwdrefs
L3357:
L3354:
    jmp       L3346
L3360:
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jnz       L3362
    mov       rsi,	[rdi]
    jmp       L3361
L3362:
    mov       rax,	[rdi]
    mov       r10,	[rip+mc_decls.labeldeftable]
    mov       r10,	[r10 + rax*8-8]
    mov       rsi,	r10
L3361:
    mov       al,	2
    mov       [rsi+93],	al
    mov       al,	[rip+mc_genss.currseg]
    mov       [rsi+94],	al
    mov       rcx,	6
    call      mc_genss.getcurrdatalen
    mov       [rsi+76],	eax
    mov       al,	[rsi+81]
    test      al,	al
    jz        L3364
    mov       rcx,	rsi
    call      mc_genss.getstindex
L3364:
    mov       rcx,	rsi
    call      mc_genss.dofwdrefs
    jmp       L3346
L3365:
    mov       rcx,	rdi
    call      mc_genss.do_call
    jmp       L3346
L3366:
    mov       rcx,	rdi
    mov       rdx,	[rbp + mc_genss.doinstr.m]
    call      mc_genss.do_jmp
    jmp       L3346
L3367:
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rsi,	rax
    mov       rcx,	7
    call      mc_genss.getcurrdatalen
    inc       rax
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_genss.getrel32
    mov       r13,	rax
    cmp       r13,	0
    jge       L3369
    cmp       r13,	-126
    jge       L3371
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+34]
    mov       r10,	128
    add       r10,	rax
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword ptr[rax]
    mov       [r11],	r10b
    lea       rax,	[r13-4]
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L3370
L3371:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+34]
    mov       r10,	112
    add       r10,	rax
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword ptr[rax]
    mov       [r11],	r10b
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	r13b
L3370:
    jmp       L3368
L3369:
    mov       rcx,	[rbp + mc_genss.doinstr.m]
    mov       rdx,	rsi
    call      mc_genss.checkshortjump
    mov       r14,	rax
    test      r14,	r14
    jnz       L3373
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+34]
    mov       r10,	128
    add       r10,	rax
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword ptr[rax]
    mov       [r11],	r10b
    mov       rcx,	rdi
    call      mc_genss.genrel32
    jmp       L3372
L3373:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+34]
    mov       r10,	112
    add       r10,	rax
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword ptr[rax]
    mov       [r11],	r10b
    mov       rcx,	rdi
    call      mc_genss.genrel8
L3372:
L3368:
    jmp       L3346
L3374:
    mov       rcx,	rdi
    mov       rdx,	1
    call      mc_genss.genopnd
    jmp       L3346
L3375:
    mov       rcx,	rdi
    mov       rdx,	2
    call      mc_genss.genopnd
    jmp       L3346
L3376:
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3346
L3377:
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_genss.genopnd
    jmp       L3346
L3378:
    mov       rcx,	1
    call      mc_genss.switchseg
    jmp       L3346
L3379:
    mov       rcx,	2
    call      mc_genss.switchseg
    jmp       L3346
L3380:
    mov       rcx,	3
    call      mc_genss.switchseg
    jmp       L3346
L3381:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword ptr[rax]
    mov       [r11],	r10b
    jmp       L3346
L3382:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	152
    mov       [r10],	al
    jmp       L3346
L3383:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	153
    mov       [r10],	al
    jmp       L3346
L3384:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	153
    mov       [r10],	al
    jmp       L3346
L3385:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	72
    mov       [r10],	al
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	153
    mov       [r10],	al
    jmp       L3346
L3386:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	195
    mov       [r10],	al
    jmp       L3346
L3387:
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jz        L3389
    lea       rcx,	[rip+L10747]
    call      mc_libmcl.axerror
L3389:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	194
    mov       [r10],	al
    mov       rcx,	[rdi]
    call      mc_genss.genword
    jmp       L3346
L3390:
    mov       rcx,	rdi
    call      mc_genss.do_push
    jmp       L3346
L3391:
    mov       rcx,	rdi
    call      mc_genss.do_pop
    jmp       L3346
L3392:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mc_genss.do_inc
    jmp       L3346
L3393:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mc_genss.do_neg
    jmp       L3346
L3394:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    call      mc_genss.do_arith
    jmp       L3346
L3395:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_mov
    jmp       L3346
L3396:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_lea
    jmp       L3346
L3397:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	190
    call      mc_genss.do_movsx
    jmp       L3346
L3398:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	182
    call      mc_genss.do_movsx
    jmp       L3346
L3399:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_movsxd
    jmp       L3346
L3400:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_exch
    jmp       L3346
L3401:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_imul2
    jmp       L3346
L3402:
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3404
    mov       rax,	[rdi]
    mov       r10,	[rbp + mc_genss.doinstr.m]
    movzx     r10,	byte ptr[r10+33]
    lea       r11,	[rip+mc_decls.mclcodes]
    movzx     r11,	byte ptr[r11 + r10-1]
    imul      rax,	r11
    mov       [rbp + mc_genss.doinstr.n],	rax
    mov       rax,	[rip+mc_genss.currseg]
    cmp       rax,	1
    jz        L3406
    cmp       rax,	2
    jz        L3407
    jmp       L3408
L3406:
    mov       rax,	[rbp + mc_genss.doinstr.n]
    mov       [rbp + mc_genss.doinstr.av_1],	rax
    mov       rax,	[rbp + mc_genss.doinstr.av_1]
    cmp       rax,	0
    jle       L3411
L3409:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	144
    mov       [r10],	al
    dec       qword ptr[rbp + mc_genss.doinstr.av_1]
    jnz       L3409
L3411:
    jmp       L3405
L3407:
    mov       rax,	[rbp + mc_genss.doinstr.n]
    mov       [rbp + mc_genss.doinstr.av_2],	rax
    mov       rax,	[rbp + mc_genss.doinstr.av_2]
    cmp       rax,	0
    jle       L3414
L3412:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    xor       eax,	eax
    mov       [r10],	al
    dec       qword ptr[rbp + mc_genss.doinstr.av_2]
    jnz       L3412
L3414:
    jmp       L3405
L3408:
    mov       rax,	[rbp + mc_genss.doinstr.n]
    add       [rip+mc_decls.ss_zdatalen],	rax
L3405:
    jmp       L3403
L3404:
    lea       rcx,	[rip+L10748]
    call      mc_libmcl.axerror
L3403:
    jmp       L3346
L3415:
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3417
    mov       r12,	[rdi]
    cmp       r12,	1
    jl        L3420
    cmp       r12,	16384
    jle       L3419
L3420:
    lea       rcx,	[rip+L10749]
    call      mc_libmcl.axerror
L3419:
    mov       rcx,	[rip+mc_genss.currdata]
    mov       rdx,	r12
    call      mc_genss.buffercheck
    mov       rax,	[rip+mc_genss.currseg]
    cmp       rax,	3
    jz        L3422
    jmp       L3424
L3423:
    mov       rax,	[rip+mc_genss.currseg]
    cmp       rax,	1
    jnz       L3427
    mov       rax,	144
    jmp       L3426
L3427:
    xor       eax,	eax
L3426:
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
L3424:
    mov       rcx,	[rip+mc_genss.currdata]
    call      mc_genss.bufferlength
    mov       r10,	r12
    cqo       
    idiv      r10
    xchg      rax,	rdx
    test      rax,	rax
    jnz       L3423
    jmp       L3421
L3422:
    jmp       L3429
L3428:
    inc       qword ptr[rip+mc_decls.ss_zdatalen]
L3429:
    mov       rax,	[rip+mc_decls.ss_zdatalen]
    mov       r10,	r12
    cqo       
    idiv      r10
    xchg      rax,	rdx
    test      rax,	rax
    jnz       L3428
L3421:
    jmp       L3416
L3417:
    lea       rcx,	[rip+L10750]
    call      mc_libmcl.axerror
L3416:
    jmp       L3346
L3431:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    call      mc_genss.do_shift
    jmp       L3346
L3432:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_test
    jmp       L3346
L3433:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mc_genss.do_loop
    jmp       L3346
L3434:
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_genss.do_jcxz
    jmp       L3346
L3435:
    mov       rcx,	rdi
    mov       rdx,	8
    call      mc_genss.do_jcxz
    jmp       L3346
L3436:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	215
    mov       [r10],	al
    jmp       L3346
L3437:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+34]
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mc_genss.do_setcc
    jmp       L3346
L3438:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	4
    call      mc_genss.do_movxmm
    jmp       L3346
L3439:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	8
    call      mc_genss.do_movxmm
    jmp       L3346
L3440:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    mov       r9,	r10
    call      mc_genss.do_arithxmm
    jmp       L3346
L3441:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    mov       r9,	r10
    call      mc_genss.do_arithxmm
    jmp       L3346
L3442:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    mov       r9,	4
    call      mc_genss.do_logicxmm
    jmp       L3346
L3443:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    mov       r9,	8
    call      mc_genss.do_logicxmm
    jmp       L3346
L3444:
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    mov       r9,	47
    call      mc_genss.do_arithxmm
    jmp       L3346
L3445:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	102
    mov       r9,	r10
    call      mc_genss.do_arithxmm
    jmp       L3346
L3446:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    call      mc_genss.do_convertfloat
    jmp       L3346
L3447:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    call      mc_genss.do_convertfloat
    jmp       L3346
L3448:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    mov       r9,	45
    call      mc_genss.do_fix
    jmp       L3346
L3449:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    mov       r9,	45
    call      mc_genss.do_fix
    jmp       L3346
L3450:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    mov       r9,	44
    call      mc_genss.do_fix
    jmp       L3346
L3451:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    mov       r9,	44
    call      mc_genss.do_fix
    jmp       L3346
L3452:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	243
    call      mc_genss.do_float
    jmp       L3346
L3453:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	242
    call      mc_genss.do_float
    jmp       L3346
L3454:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+34]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.do_cmovcc
    jmp       L3346
L3455:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	217
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword ptr[rax]
    mov       [r11],	r10b
    jmp       L3346
L3456:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	1
    mov       r8,	r10
    call      mc_genss.do_fmem
    jmp       L3346
L3457:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	r10
    call      mc_genss.do_fmem
    jmp       L3346
L3458:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	222
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword ptr[rax]
    mov       [r11],	r10b
    jmp       L3346
L3459:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	166
    mov       [r10],	al
    jmp       L3346
L3460:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	167
    mov       [r10],	al
    jmp       L3346
L3461:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	167
    mov       [r10],	al
    jmp       L3346
L3462:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	72
    mov       [r10],	al
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	167
    mov       [r10],	al
    jmp       L3346
L3463:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword ptr[rax]
    mov       [r11],	r10b
    jmp       L3346
L3464:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    call      mc_genss.do_movdqx
    jmp       L3346
L3465:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	219
    mov       [r10],	al
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	227
    mov       [r10],	al
    jmp       L3346
L3466:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	217
    mov       [r10],	al
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    mov       r10b,	[r10 + rax-1]
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r11,	[rax]
    inc       qword ptr[rax]
    mov       [r11],	r10b
    jmp       L3346
L3467:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_popcnt
    jmp       L3346
L3468:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r10
    call      mc_genss.do_bsf
    jmp       L3346
L3469:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	162
    mov       [r10],	al
    jmp       L3346
L3470:
    mov       rcx,	rdi
    call      mc_genss.do_bswap
    jmp       L3346
L3471:
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclcodes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+32]
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rax
    mov       r9,	r10
    call      mc_genss.do_dshift
    jmp       L3346
L3472:
    jmp       L3346
L3348:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10751]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    lea       r10,	[rip+mc_decls.mclnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L10752]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    lea       rcx,	[rip+L10753]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + mc_genss.doinstr.m]
    movzx     rax,	byte ptr[rax+33]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[rip+L10754]
    call      msys.m$print_str_nf
    mov       rcx,	152
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10755]
    call      mc_libmcl.axerror
L3346:
#---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.start
mc_genss.start:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       al,	64
    lea       r10,	[rip+mc_genss.ishighreg]
    mov       [r10+3],	al
    mov       al,	64
    lea       r10,	[rip+mc_genss.ishighreg]
    mov       [r10+5],	al
    mov       al,	64
    lea       r10,	[rip+mc_genss.ishighreg]
    mov       [r10+14],	al
    mov       al,	64
    lea       r10,	[rip+mc_genss.ishighreg]
    mov       [r10+15],	al
#---------------
    ret       
# End 
# Proc mc_genss.genword
mc_genss.genword:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_genss.currdata]
    mov       rdx,	rdi
    call      mc_genss.addword
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genss.gendword
mc_genss.gendword:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_genss.currdata]
    mov       rdx,	rdi
    call      mc_genss.adddword
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genss.genqword
mc_genss.genqword:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_genss.currdata]
    mov       rdx,	rdi
    call      mc_genss.addqword
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genss.genopnd
mc_genss.genopnd:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    movq      rax,	XMM15
    push      rax
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    test      r12,	r12
    jnz       L3479
    movzx     rax,	word ptr[rsi+8]
    and       rax,	31
    mov       r12,	rax
L3479:
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	4
    jz        L3481
    cmp       rax,	7
    jz        L3482
    jmp       L3483
L3481:
    mov       rdi,	[rsi]
    mov       rcx,	rdi
    call      strlen
    mov       rbx,	rax
    cmp       rbx,	100
    jle       L3485
    lea       rax,	[rbx+1]
    mov       r10,	1024
    cmp       r10,	rax
    cmovl     r10,	rax
    mov       rcx,	[rip+mc_genss.currdata]
    mov       rdx,	r10
    call      mc_genss.buffercheck
L3485:
    jmp       L3487
L3486:
    mov       rax,	rdi
    inc       rdi
    mov       al,	[rax]
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
L3487:
    mov       al,	[rdi]
    test      al,	al
    jnz       L3486
    jmp       L3477
L3482:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10756]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3483:
L3480:
    mov       rcx,	rsi
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L3490
    cmp       r12,	2
    jg        L3490
    lea       rcx,	[rip+L10757]
    call      mc_libmcl.axerror
L3490:
    mov       rax,	r12
    cmp       rax,	1
    jz        L3492
    cmp       rax,	2
    jz        L3493
    cmp       rax,	4
    jz        L3494
    cmp       rax,	8
    jz        L3495
    jmp       L3496
L3492:
    mov       rax,	[rsi]
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
    jmp       L3491
L3493:
    mov       rcx,	[rsi]
    call      mc_genss.genword
    jmp       L3491
L3494:
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jz        L3498
    cmp       rax,	2
    jz        L3499
    cmp       rax,	5
    jz        L3500
    cmp       rax,	6
    jz        L3500
    jmp       L3501
L3498:
    mov       rcx,	[rsi]
    call      mc_genss.gendword
    jmp       L3497
L3499:
    movq      XMM4,	[rsi]
    cvtsd2ss  XMM4,	XMM4
    movq      XMM15,	XMM4
    movq      XMM4,	XMM15
    movd      eax,	XMM4
    mov       ecx,	eax
    call      mc_genss.gendword
    jmp       L3497
L3500:
    mov       rcx,	rsi
    call      mc_genss.genabs32
    jmp       L3497
L3501:
    call      msys.m$print_startcon
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	12
    and       rax,	15
    lea       r10,	[rip+mc_decls.valtypenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10758]
    call      mc_libmcl.axerror
L3497:
    jmp       L3491
L3495:
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jz        L3503
    cmp       rax,	2
    jz        L3504
    cmp       rax,	5
    jz        L3505
    cmp       rax,	6
    jz        L3505
    jmp       L3506
L3503:
    mov       rcx,	[rsi]
    call      mc_genss.genqword
    jmp       L3502
L3504:
    movq      XMM4,	[rsi]
    movq      rax,	XMM4
    mov       rcx,	rax
    call      mc_genss.genqword
    jmp       L3502
L3505:
    mov       rcx,	rsi
    call      mc_genss.genabs64
    jmp       L3502
L3506:
    call      msys.m$print_startcon
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	12
    and       rax,	15
    lea       r10,	[rip+mc_decls.valtypenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10759]
    call      mc_libmcl.axerror
L3502:
L3496:
L3491:
L3477:
#---------------
    add       rsp,	48
    pop       rcx
    movq      XMM15,	rcx
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.addrelocitem
mc_genss.addrelocitem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	r13
    call      mc_genss.getstindex
    mov       rbx,	rax
    mov       rsi,	4
    cmp       r12,	1
    jnz       L3509
    mov       rsi,	8
L3509:
    mov       rcx,	32
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rax,	[rip+mc_genss.currrelocs]
    mov       [rdi],	rax
    mov       [rdi+8],	r12
    mov       rcx,	1
    call      mc_genss.getcurrdatalen
    sub       rax,	rsi
    mov       [rdi+16],	rax
    mov       [rdi+24],	rbx
    inc       qword ptr[rip+mc_genss.nrelocs]
    mov       [rip+mc_genss.currrelocs],	rdi
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.getstindex
mc_genss.getstindex:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movsx     rax,	word ptr[rdi+96]
    test      rax,	rax
    jnz       L3512
    mov       rax,	[rip+mc_decls.ss_nsymbols]
    cmp       rax,	[rip+mc_decls.ss_symboltablesize]
    jl        L3514
    call      mc_genss.extendsymboltable
L3514:
    inc       qword ptr[rip+mc_decls.ss_nsymbols]
    mov       rax,	[rip+mc_decls.ss_nsymbols]
    mov       [rdi+96],	ax
    movsx     rax,	word ptr[rdi+96]
    mov       r10,	rdi
    mov       r11,	[rip+mc_decls.ss_symboltable]
    mov       [r11 + rax*8-8],	r10
    movzx     rax,	byte ptr[rdi+94]
    test      rax,	rax
    jnz       L3516
    mov       al,	[rdi+80]
    test      al,	al
    jz        L3518
    mov       al,	1
    mov       [rdi+94],	al
L3518:
L3516:
L3512:
    movsx     rax,	word ptr[rdi+96]
L3510:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genss.genrel32
mc_genss.genrel32:
#PROC1
#PROC2
#?>>
    .set mc_genss.genrel32.$T1, -8
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    xor       edx,	edx
    call      mc_genss.getdef
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L3521
    mov       rcx,	[rbx]
    call      mc_genss.gendword
    jmp       L3519
L3521:
    movzx     rax,	byte ptr[rdi+93]
    cmp       rax,	2
    jz        L3523
    cmp       rax,	1
    jz        L3524
    jmp       L3525
L3523:
    movzx     rax,	byte ptr[rdi+94]
    cmp       rax,	[rip+mc_genss.currseg]
    jz        L3527
    lea       rcx,	[rip+L10760]
    call      mc_libmcl.axerror
L3527:
    movsxd    rax,	dword ptr[rdi+76]
    mov       [rbp + mc_genss.genrel32.$T1],	rax
    mov       rcx,	2
    call      mc_genss.getcurrdatalen
    add       rax,	4
    mov       r10,	[rbp + mc_genss.genrel32.$T1]
    sub       r10,	rax
    movsxd    rax,	dword ptr[rbx+12]
    add       r10,	rax
    mov       rcx,	r10
    call      mc_genss.gendword
    jmp       L3522
L3524:
    mov       rcx,	3
    call      mc_genss.getcurrdatalen
    mov       r10,	[rdi+64]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	4
    xor       r9d,	r9d
    call      mc_genss.addfwdref
    mov       [rdi+64],	rax
    movsxd    rax,	dword ptr[rbx+12]
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L3522
L3525:
    movsxd    rax,	dword ptr[rbx+12]
    mov       rcx,	rax
    call      mc_genss.gendword
    mov       rcx,	4
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3522:
L3519:
#---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.getdef
mc_genss.getdef:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L3531
    cmp       rax,	2
    jnz       L3530
L3531:
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	6
    jz        L3533
    cmp       rax,	5
    jz        L3534
    jmp       L3535
L3533:
    mov       rax,	[rbx]
    mov       r10,	[rip+mc_decls.labeldeftable]
    mov       r10,	[r10 + rax*8-8]
    mov       rax,	r10
    jmp       L3528
L3534:
    mov       rdi,	[rbx]
    movzx     rax,	byte ptr[rdi+93]
    test      rax,	rax
    jnz       L3537
    mov       al,	[rdi+80]
    test      al,	al
    jnz       L3539
    mov       al,	1
    mov       [rdi+93],	al
L3539:
L3537:
    mov       rax,	rdi
    jmp       L3528
L3535:
L3532:
L3530:
    test      rsi,	rsi
    jz        L3541
    call      msys.m$print_startcon
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    lea       r10,	[rip+mc_decls.opndnames_ma]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	12
    and       rax,	15
    lea       r10,	[rip+mc_decls.valtypenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10761]
    call      mc_libmcl.axerror
L3541:
    xor       eax,	eax
L3528:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.genabs32
mc_genss.genabs32:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rdi,	rax
    movzx     rax,	byte ptr[rdi+93]
    cmp       rax,	2
    jz        L3544
    cmp       rax,	1
    jz        L3545
    jmp       L3546
L3544:
    movsxd    rax,	dword ptr[rdi+76]
    movsxd    r10,	dword ptr[rbx+12]
    add       rax,	r10
    mov       rcx,	rax
    call      mc_genss.gendword
    mov       rcx,	2
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
    jmp       L3543
L3545:
    mov       rcx,	4
    call      mc_genss.getcurrdatalen
    mov       r10,	[rdi+64]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	2
    mov       r9,	[rip+mc_genss.currseg]
    call      mc_genss.addfwdref
    mov       [rdi+64],	rax
    movzx     rax,	byte ptr[rdi+72]
    cmp       rax,	4
    jz        L3549
    cmp       rax,	5
    jnz       L3548
L3549:
    movsxd    rax,	dword ptr[rdi+76]
    movsxd    r10,	dword ptr[rbx+12]
    add       rax,	r10
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L3547
L3548:
    movsxd    rax,	dword ptr[rbx+12]
    mov       rcx,	rax
    call      mc_genss.gendword
    mov       rcx,	2
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3547:
    jmp       L3543
L3546:
    movsxd    rax,	dword ptr[rbx+12]
    mov       rcx,	rax
    call      mc_genss.gendword
    mov       rcx,	2
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3543:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.genabs64
mc_genss.genabs64:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rdi,	rax
    movzx     rax,	byte ptr[rdi+93]
    cmp       rax,	2
    jz        L3552
    cmp       rax,	1
    jz        L3553
    jmp       L3554
L3552:
    movsxd    rax,	dword ptr[rdi+76]
    movsxd    r10,	dword ptr[rbx+12]
    add       rax,	r10
    mov       rcx,	rax
    call      mc_genss.genqword
    mov       rcx,	1
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
    jmp       L3551
L3553:
    mov       rcx,	5
    call      mc_genss.getcurrdatalen
    mov       r10,	[rdi+64]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	1
    mov       r9,	[rip+mc_genss.currseg]
    call      mc_genss.addfwdref
    mov       [rdi+64],	rax
    movzx     rax,	byte ptr[rdi+72]
    cmp       rax,	4
    jz        L3557
    cmp       rax,	5
    jnz       L3556
L3557:
    movsxd    rax,	dword ptr[rdi+76]
    movsxd    r10,	dword ptr[rbx+12]
    add       rax,	r10
    mov       rcx,	rax
    call      mc_genss.genqword
    jmp       L3555
L3556:
    movsxd    rax,	dword ptr[rbx+12]
    mov       rcx,	rax
    call      mc_genss.genqword
    mov       rcx,	1
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3555:
    jmp       L3551
L3554:
    movsxd    rax,	dword ptr[rbx+12]
    mov       rcx,	rax
    call      mc_genss.genqword
    mov       rcx,	1
    mov       rdx,	rdi
    call      mc_genss.addrelocitem
L3551:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.getrel32
mc_genss.getrel32:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rdi+93]
    cmp       rax,	2
    jnz       L3560
    movzx     rax,	byte ptr[rdi+94]
    cmp       rax,	[rip+mc_genss.currseg]
    jz        L3562
    lea       rcx,	[rip+L10762]
    call      mc_libmcl.axerror
L3562:
    movsxd    rax,	dword ptr[rdi+76]
    lea       r10,	[rbx+1]
    sub       rax,	r10
    jmp       L3559
L3560:
    mov       rax,	2147483647
L3559:
L3558:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.dofwdrefs
mc_genss.dofwdrefs:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    sub       rsp,	48
    mov       r15,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[r15+64]
    test      rax,	rax
    jz        L3563
L3565:
    mov       rdi,	[r15+64]
    jmp       L3567
L3566:
    movsxd    rax,	dword ptr[rdi+8]
    mov       rbx,	rax
    movsx     rax,	word ptr[rdi+12]
    cmp       rax,	4
    jz        L3570
    cmp       rax,	2
    jz        L3571
    cmp       rax,	1
    jz        L3571
    cmp       rax,	6
    jz        L3572
    jmp       L3573
L3570:
    mov       rcx,	[rip+mc_genss.currdata]
    mov       rdx,	rbx
    call      mc_genss.bufferelemptr
    mov       r12,	rax
    movsxd    rax,	dword ptr[r15+76]
    sub       rax,	rbx
    sub       rax,	4
    mov       [r12],	eax
    jmp       L3569
L3571:
    movsx     rax,	word ptr[rdi+14]
    cmp       rax,	1
    jz        L3575
    cmp       rax,	3
    jz        L3576
    cmp       rax,	2
    jz        L3577
    jmp       L3578
L3575:
    mov       r14,	[rip+mc_decls.ss_code]
    jmp       L3574
L3576:
    lea       rcx,	[rip+L10763]
    call      mc_libmcl.axerror
    jmp       L3574
L3577:
    mov       r14,	[rip+mc_decls.ss_idata]
L3578:
L3574:
    mov       rcx,	r14
    mov       rdx,	rbx
    call      mc_genss.bufferelemptr
    mov       r12,	rax
    movsx     rax,	word ptr[rdi+12]
    cmp       rax,	2
    jnz       L3580
    movsxd    rax,	dword ptr[r12]
    movsxd    r10,	dword ptr[r15+76]
    add       rax,	r10
    mov       [r12],	eax
    jmp       L3579
L3580:
    mov       r13,	r12
    mov       rax,	[r13]
    movsxd    r10,	dword ptr[r15+76]
    add       rax,	r10
    mov       [r13],	rax
L3579:
    jmp       L3569
L3572:
    mov       rcx,	[rip+mc_genss.currdata]
    mov       rdx,	rbx
    call      mc_genss.bufferelemptr
    mov       rsi,	rax
    movsxd    rax,	dword ptr[r15+76]
    sub       rax,	rbx
    dec       rax
    mov       [rsi],	al
    jmp       L3569
L3573:
    call      msys.m$print_startcon
    movsx     rax,	word ptr[rdi+12]
    lea       r10,	[rip+mc_objdecls.relocnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    mov       rcx,	[r15]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10764]
    call      mc_libmcl.axerror
L3569:
    mov       rdi,	[rdi]
L3567:
    test      rdi,	rdi
    jnz       L3566
L3563:
#---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.genrex
mc_genss.genrex:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       al,	[rip+mc_genss.f2override]
    test      al,	al
    jz        L3583
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	242
    mov       [r10],	al
L3583:
    mov       al,	[rip+mc_genss.f3override]
    test      al,	al
    jz        L3585
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	243
    mov       [r10],	al
L3585:
    mov       al,	[rip+mc_genss.sizeoverride]
    test      al,	al
    jz        L3587
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	102
    mov       [r10],	al
L3587:
    mov       al,	[rip+mc_genss.addroverride]
    test      al,	al
    jz        L3589
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	103
    mov       [r10],	al
L3589:
    mov       al,	[rip+mc_genss.nowmask]
    test      al,	al
    jz        L3591
    and       byte ptr[rip+mc_genss.rex],	247
L3591:
    mov       al,	[rip+mc_genss.rex]
    test      al,	al
    jz        L3593
    movzx     rax,	byte ptr[rip+mc_genss.rex]
    and       rax,	15
    add       rax,	64
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
L3593:
#---------------
    ret       
# End 
# Proc mc_genss.isbytesized
mc_genss.isbytesized:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	rcx
    cmp       rax,	-128
    jl        L3595
    cmp       rax,	127
    jg        L3595
    mov       rax,	1
    jmp       L3596
L3595:
    xor       eax,	eax
L3596:
L3594:
#---------------
    ret       
# End 
# Proc mc_genss.isdwordsized
mc_genss.isdwordsized:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	rcx
    cmp       rax,	-2147483648
    jl        L3598
    cmp       rax,	2147483647
    jg        L3598
    mov       rax,	1
    jmp       L3599
L3598:
    xor       eax,	eax
L3599:
L3597:
#---------------
    ret       
# End 
# Proc mc_genss.genamode
mc_genss.genamode:
#PROC1
#PROC2
#?>>
    .set mc_genss.genamode.am, 40
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       rbx,	rcx
    mov       [rbp+40],	rdx
#---------------
#PROC3
#PROC4
    mov       al,	[rbp + mc_genss.genamode.am]
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
    movsx     rax,	byte ptr[rbp + mc_genss.genamode.am+2]
    cmp       rax,	1
    jnz       L3602
    mov       al,	[rbp + mc_genss.genamode.am+1]
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
L3602:
    movzx     rax,	byte ptr[rbp + mc_genss.genamode.am+3]
    test      rax,	rax
    jz        L3604
    cmp       rax,	1
    jz        L3605
    cmp       rax,	4
    jz        L3606
    jmp       L3607
L3604:
    jmp       L3603
L3605:
    mov       eax,	[rbp + mc_genss.genamode.am+4]
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
    jmp       L3603
L3606:
    movsx     rax,	byte ptr[rbp + mc_genss.genamode.am+2]
    cmp       rax,	-1
    jnz       L3609
    mov       rcx,	16
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rax,	[rip+mc_decls.riplist]
    mov       [rdi],	rax
    mov       rax,	[rip+mc_genss.currdata]
    mov       rax,	[rax+8]
    mov       r10,	[rip+mc_genss.currdata]
    mov       r10,	[r10]
    sub       rax,	r10
    mov       [rdi+8],	eax
    mov       rax,	rdi
    mov       [rip+mc_decls.riplist],	rax
    mov       [rip+mc_genss.ripentry],	rax
L3609:
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L3612
L3611:
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L3614
    cmp       rax,	6
    jz        L3614
    test      rax,	rax
    jz        L3615
    cmp       rax,	8
    jz        L3615
    jmp       L3616
L3614:
    mov       rcx,	rbx
    call      mc_genss.genabs32
    jmp       L3613
L3615:
    movsxd    rax,	dword ptr[rbp + mc_genss.genamode.am+4]
    mov       rcx,	rax
    call      mc_genss.gendword
    jmp       L3613
L3616:
    lea       rcx,	[rip+L10765]
    call      mc_libmcl.axerror
L3613:
    jmp       L3610
L3612:
    call      msys.m$print_startcon
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    lea       r10,	[rip+mc_decls.opndnames_ma]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10766]
    call      mc_libmcl.axerror
L3610:
    jmp       L3603
L3607:
    lea       rcx,	[rip+L10767]
    call      mc_libmcl.axerror
L3603:
#---------------
    add       rsp,	32
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.setopsize
mc_genss.setopsize:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3619
    cmp       rax,	4
    jz        L3620
    cmp       rax,	1
    jz        L3621
    cmp       rax,	2
    jz        L3622
    jmp       L3623
L3619:
    mov       al,	8
    or        [rip+mc_genss.rex],	al
    jmp       L3618
L3620:
    jmp       L3618
L3621:
    jmp       L3618
L3622:
    mov       al,	1
    mov       [rip+mc_genss.sizeoverride],	al
    jmp       L3618
L3623:
    lea       rcx,	[rip+L10768]
    call      mc_libmcl.axerror
L3618:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genss.getdispsize
mc_genss.getdispsize:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    xor       edx,	edx
    call      mc_genss.getdef
    mov       rdi,	rax
    mov       eax,	[rbx+12]
    mov       [rsi],	eax
    test      rdi,	rdi
    jz        L3626
    movzx     rax,	byte ptr[rdi+72]
    cmp       rax,	4
    jz        L3629
    cmp       rax,	5
    jnz       L3628
L3629:
    movsxd    rax,	dword ptr[rdi+76]
    mov       r10,	rsi
    add       [r10],	eax
    jmp       L3627
L3628:
    mov       rax,	4
    jmp       L3624
L3627:
L3626:
    mov       eax,	[rsi]
    test      eax,	eax
    jz        L3631
    movsxd    rax,	dword ptr[rsi]
    mov       rcx,	rax
    call      mc_genss.isbytesized
    test      rax,	rax
    jz        L3633
    mov       rax,	1
    jmp       L3632
L3633:
    mov       rax,	4
L3632:
    jmp       L3630
L3631:
    xor       eax,	eax
L3630:
L3624:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.checkhighreg
mc_genss.checkhighreg:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rcx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3636
    movzx     rax,	byte ptr[rcx+10]
    lea       r10,	[rip+mc_genss.ishighreg]
    movzx     r10,	byte ptr[r10 + rax-1]
    or        [rip+mc_genss.rex],	r10b
L3636:
#---------------
    ret       
# End 
# Proc mc_genss.do_loop
mc_genss.do_loop:
#PROC1
#PROC2
#?>>
    .set mc_genss.do_loop.$T1, -8
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	9
    call      mc_genss.getcurrdatalen
    inc       rax
    mov       [rbp + mc_genss.do_loop.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_loop.$T1]
    call      mc_genss.getrel32
    mov       rdi,	rax
    cmp       rdi,	0
    jge       L3639
    cmp       rdi,	-126
    jge       L3641
    lea       rcx,	[rip+L10769]
    call      mc_libmcl.axerror
L3641:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	sil
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	dil
    jmp       L3638
L3639:
    lea       rcx,	[rip+L10770]
    call      mc_libmcl.axerror
L3638:
#---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_jcxz
mc_genss.do_jcxz:
#PROC1
#PROC2
#?>>
    .set mc_genss.do_jcxz.$T1, -8
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	10
    call      mc_genss.getcurrdatalen
    inc       rax
    mov       [rbp + mc_genss.do_jcxz.$T1],	rax
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_genss.do_jcxz.$T1]
    call      mc_genss.getrel32
    mov       rdi,	rax
    cmp       rdi,	0
    jge       L3644
    cmp       rdi,	-126
    jge       L3646
    lea       rcx,	[rip+L10771]
    call      mc_libmcl.axerror
L3646:
    cmp       rsi,	4
    jnz       L3648
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	103
    mov       [r10],	al
L3648:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	227
    mov       [r10],	al
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	dil
    jmp       L3643
L3644:
    lea       rcx,	[rip+L10772]
    call      mc_libmcl.axerror
L3643:
#---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_call
mc_genss.do_call:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3652
L3651:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	232
    mov       [r10],	al
    mov       rcx,	rdi
    call      mc_genss.genrel32
    jmp       L3650
L3652:
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    test      rax,	rax
    jz        L3654
    cmp       rax,	1
    jz        L3655
    cmp       rax,	2
    jz        L3655
    cmp       rax,	4
    jz        L3655
    jmp       L3656
L3654:
    lea       rax,	[rdi+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    jmp       L3653
L3655:
    lea       rcx,	[rip+L10773]
    call      mc_libmcl.axerror
L3656:
L3653:
    mov       rcx,	255
    mov       rdx,	2
    mov       r8,	rdi
    call      mc_genss.genxrm
L3650:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_jmp
mc_genss.do_jmp:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    xor       edx,	edx
    call      mc_genss.getdef
    mov       rsi,	rax
    movzx     rax,	word ptr[r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L3660
L3659:
    mov       rcx,	11
    call      mc_genss.getcurrdatalen
    inc       rax
    mov       rcx,	rsi
    mov       rdx,	rax
    call      mc_genss.getrel32
    mov       rdi,	rax
    cmp       rdi,	0
    jge       L3662
    cmp       rdi,	-126
    jle       L3662
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	235
    mov       [r10],	al
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	dil
    jmp       L3661
L3662:
    xor       rbx,	rbx
    mov       rax,	rdi
    cmp       rax,	0
    jle       L3664
    mov       rcx,	r13
    mov       rdx,	rsi
    call      mc_genss.checkshortjump
    mov       rbx,	rax
L3664:
    test      rbx,	rbx
    jnz       L3666
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	233
    mov       [r10],	al
    mov       rcx,	r12
    call      mc_genss.genrel32
    jmp       L3665
L3666:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	235
    mov       [r10],	al
    mov       rcx,	r12
    call      mc_genss.genrel8
L3665:
L3661:
    jmp       L3658
L3660:
    movzx     rax,	word ptr[r12+8]
    and       rax,	31
    test      rax,	rax
    jz        L3668
    cmp       rax,	1
    jz        L3669
    cmp       rax,	2
    jz        L3669
    cmp       rax,	4
    jz        L3669
    jmp       L3670
L3668:
    lea       rax,	[r12+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
    jmp       L3667
L3669:
    lea       rcx,	[rip+L10774]
    call      mc_libmcl.axerror
L3670:
L3667:
    mov       rcx,	255
    mov       rdx,	4
    mov       r8,	r12
    call      mc_genss.genxrm
L3658:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.getcurrdatalen
mc_genss.getcurrdatalen:
#PROC1
#PROC2
#?>>
    .set mc_genss.getcurrdatalen.id, 16
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_genss.currseg]
    cmp       rax,	3
    jnz       L3673
    mov       rax,	[rip+mc_decls.ss_zdatalen]
    jmp       L3671
L3673:
    mov       rcx,	[rip+mc_genss.currdata]
    call      mc_genss.bufferlength
L3671:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_genss.do_cmovcc
mc_genss.do_cmovcc:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    movzx     r10,	word ptr[rsi+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L3676
    movzx     rax,	word ptr[rsi+8]
    and       rax,	31
    jz        L3676
    lea       rcx,	[rip+L10775]
    call      mc_libmcl.axerror
L3676:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3678
    lea       rcx,	[rip+L10776]
    call      mc_libmcl.axerror
L3678:
    mov       rax,	3904
    add       rax,	rdi
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_genss.genrrm
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_fmem
mc_genss.do_fmem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L3681
    lea       rcx,	[rip+L10777]
    call      mc_libmcl.axerror
L3681:
    test      rsi,	rsi
    jz        L3683
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	4
    jz        L3685
    cmp       rax,	8
    jz        L3686
    cmp       rax,	10
    jz        L3687
    cmp       rax,	16
    jz        L3687
    jmp       L3688
L3685:
    xor       rdi,	rdi
    jmp       L3684
L3686:
    mov       rdi,	2
    jmp       L3684
L3687:
    mov       rdi,	1
    mov       rax,	r12
    test      rax,	rax
    jz        L3690
    cmp       rax,	3
    jz        L3691
    jmp       L3692
L3690:
    mov       r12,	5
    jmp       L3689
L3691:
    mov       r12,	7
    jmp       L3689
L3692:
    lea       rcx,	[rip+L10778]
    call      mc_libmcl.axerror
L3689:
    jmp       L3684
L3688:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10779]
    call      msys.m$print_str_nf
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10780]
    call      mc_libmcl.axerror
L3684:
    jmp       L3682
L3683:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	2
    jz        L3694
    cmp       rax,	4
    jz        L3695
    cmp       rax,	8
    jz        L3696
    jmp       L3697
L3694:
    mov       rdi,	3
    jmp       L3693
L3695:
    mov       rdi,	1
    jmp       L3693
L3696:
    mov       rdi,	3
    mov       rax,	r12
    test      rax,	rax
    jz        L3699
    cmp       rax,	3
    jz        L3700
    jmp       L3701
L3699:
    mov       r12,	5
    jmp       L3698
L3700:
    mov       r12,	7
    jmp       L3698
L3701:
    lea       rcx,	[rip+L10781]
    call      mc_libmcl.axerror
L3698:
    jmp       L3693
L3697:
    lea       rcx,	[rip+L10782]
    call      mc_libmcl.axerror
L3693:
L3682:
    mov       rax,	rdi
    shl       rax,	1
    mov       r10,	217
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	r12
    mov       r8,	rbx
    call      mc_genss.genxrm
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.genrel8
mc_genss.genrel8:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_genss.getdef
    mov       rdi,	rax
    movzx     rax,	byte ptr[rdi+93]
    cmp       rax,	1
    jnz       L3704
    mov       rcx,	3
    call      mc_genss.getcurrdatalen
    mov       r10,	[rdi+64]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	6
    xor       r9d,	r9d
    call      mc_genss.addfwdref
    mov       [rdi+64],	rax
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    xor       eax,	eax
    mov       [r10],	al
    jmp       L3703
L3704:
    lea       rcx,	[rip+L10783]
    call      mc_libmcl.axerror
L3703:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.checkshortjump
mc_genss.checkshortjump:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
#---------------
#PROC3
#PROC4
    xor       rdi,	rdi
    mov       rax,	[rcx+8]
    mov       rcx,	rax
    jmp       L3707
L3706:
    movzx     rax,	byte ptr[rcx+33]
    cmp       rax,	9
    jz        L3710
    cmp       rax,	3
    jz        L3711
    cmp       rax,	8
    jz        L3711
    cmp       rax,	125
    jz        L3712
    jmp       L3713
L3710:
    mov       rbx,	[rcx+16]
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	6
    jz        L3715
    cmp       rax,	5
    jz        L3716
    jmp       L3717
L3715:
    mov       rax,	[rbx]
    movsxd    r10,	dword ptr[rdx+100]
    cmp       rax,	r10
    jnz       L3719
    mov       rax,	1
    jmp       L3705
L3719:
    jmp       L3714
L3716:
    mov       rax,	[rbx]
    cmp       rax,	rdx
    jnz       L3721
    mov       rax,	1
    jmp       L3705
L3721:
L3717:
L3714:
    jmp       L3709
L3711:
    jmp       L3709
L3712:
    xor       eax,	eax
    jmp       L3705
L3713:
    inc       rdi
L3709:
    mov       rax,	[rcx+8]
    mov       rcx,	rax
L3707:
    test      rcx,	rcx
    jz        L3722
    cmp       rdi,	8
    jle       L3706
L3722:
    xor       eax,	eax
L3705:
#---------------
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.addfwdref
mc_genss.addfwdref:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
#---------------
#PROC3
#PROC4
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       [rdi],	rbx
    mov       [rdi+8],	esi
    mov       [rdi+12],	r12w
    mov       [rdi+14],	r13w
    mov       rax,	rdi
L3723:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.switchseg
mc_genss.switchseg:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    cmp       rcx,	[rip+mc_genss.currseg]
    jz        L3724
L3726:
    mov       rax,	[rip+mc_genss.currseg]
    cmp       rax,	1
    jz        L3728
    cmp       rax,	2
    jz        L3729
    jmp       L3730
L3728:
    mov       rax,	[rip+mc_genss.currrelocs]
    mov       [rip+mc_decls.ss_coderelocs],	rax
    mov       rax,	[rip+mc_genss.nrelocs]
    mov       [rip+mc_decls.ss_ncoderelocs],	rax
    jmp       L3727
L3729:
    mov       rax,	[rip+mc_genss.currrelocs]
    mov       [rip+mc_decls.ss_idatarelocs],	rax
    mov       rax,	[rip+mc_genss.nrelocs]
    mov       [rip+mc_decls.ss_nidatarelocs],	rax
L3730:
L3727:
    mov       [rip+mc_genss.currseg],	rcx
    mov       rax,	[rip+mc_genss.currseg]
    cmp       rax,	1
    jz        L3732
    cmp       rax,	2
    jz        L3733
    cmp       rax,	3
    jz        L3734
    jmp       L3735
L3732:
    mov       rax,	[rip+mc_decls.ss_code]
    mov       [rip+mc_genss.currdata],	rax
    mov       rax,	[rip+mc_decls.ss_coderelocs]
    mov       [rip+mc_genss.currrelocs],	rax
    mov       rax,	[rip+mc_decls.ss_ncoderelocs]
    mov       [rip+mc_genss.nrelocs],	rax
    jmp       L3731
L3733:
    mov       rax,	[rip+mc_decls.ss_idata]
    mov       [rip+mc_genss.currdata],	rax
    mov       rax,	[rip+mc_decls.ss_idatarelocs]
    mov       [rip+mc_genss.currrelocs],	rax
    mov       rax,	[rip+mc_decls.ss_nidatarelocs]
    mov       [rip+mc_genss.nrelocs],	rax
    jmp       L3731
L3734:
    mov       rax,	[rip+mc_decls.ss_zdata]
    mov       [rip+mc_genss.currdata],	rax
L3735:
L3731:
L3724:
#---------------
    ret       
# End 
# Proc mc_genss.do_popcnt
mc_genss.do_popcnt:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L3738
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    jnz       L3740
    lea       rax,	[rbx+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3740:
L3738:
    mov       al,	1
    mov       [rip+mc_genss.f3override],	al
    mov       rcx,	4024
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_bsf
mc_genss.do_bsf:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L3743
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    jnz       L3745
    lea       rax,	[rbx+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3745:
L3743:
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    movzx     r10,	word ptr[rbx+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L3747
    lea       rcx,	[rip+L10784]
    call      mc_libmcl.axerror
L3747:
    mov       rax,	3840
    add       rax,	rsi
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.extendsymboltable
mc_genss.extendsymboltable:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rbx,	[rip+mc_decls.ss_symboltablesize]
    mov       rdi,	[rip+mc_decls.ss_symboltable]
    mov       rax,	[rip+mc_decls.ss_symboltablesize]
    shl       rax,	1
    mov       [rip+mc_decls.ss_symboltablesize],	rax
    mov       rax,	8
    mov       r10,	[rip+mc_decls.ss_symboltablesize]
    imul      rax,	r10
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rip+mc_decls.ss_symboltable],	rax
    mov       rsi,	1
    mov       rax,	[rip+mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L3751
L3749:
    mov       rax,	[rdi + rsi*8-8]
    mov       r10,	[rip+mc_decls.ss_symboltable]
    mov       r11,	rsi
    mov       [r10 + r11*8-8],	rax
    inc       rsi
    cmp       rsi,	[rip+mc_decls.ss_nsymbols]
    jle       L3749
L3751:
    mov       rax,	8
    mov       r10,	rbx
    imul      rax,	r10
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.pcm_free
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.initlib
mc_genss.initlib:
#PROC1
#PROC2
#?>>
    .set mc_genss.initlib.str, -256
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	262144
    call      mlib.pcm_alloc
    mov       [rip+mc_decls.ss_symboltable],	rax
    mov       rax,	32768
    mov       [rip+mc_decls.ss_symboltablesize],	rax
    xor       eax,	eax
    mov       [rip+mc_decls.ss_nsymbols],	rax
    mov       rax,	rsi
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rip+mc_decls.labeldeftable],	rax
    mov       rbx,	1
    cmp       rsi,	1
    jl        L3755
L3753:
    mov       rcx,	128
    call      mlib.pcm_allocnfz
    mov       r10,	[rip+mc_decls.labeldeftable]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
    mov       rdi,	rax
    mov       [rdi+100],	ebx
    lea       rcx,	[rbp + mc_genss.initlib.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10785]
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + mc_genss.initlib.str]
    call      mlib.pcm_copyheapstring
    mov       [rdi],	rax
    mov       al,	1
    mov       [rdi+93],	al
    inc       rbx
    cmp       rbx,	rsi
    jle       L3753
L3755:
#---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.buffercreate
mc_genss.buffercreate:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	32
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       [rdi+24],	rbx
    mov       rax,	[rdi+24]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rdi+8],	rax
    mov       [rdi],	rax
    mov       rax,	[rdi]
    mov       r10,	[rdi+24]
    lea       rax,	[rax + r10]
    mov       [rdi+16],	rax
    mov       rax,	rdi
L3756:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.bufferexpand
mc_genss.bufferexpand:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[r12+24]
    shl       rax,	1
    mov       rdi,	rax
    mov       rax,	[r12+8]
    mov       r10,	[r12]
    sub       rax,	r10
    mov       rbx,	rax
    mov       rax,	[r12+24]
    mov       r10,	rbx
    cmp       r10,	rax
    jle       L3759
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10786]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       ecx,	ecx
    call      exit
L3759:
    mov       rcx,	rdi
    call      mlib.pcm_alloc
    mov       rsi,	rax
    mov       rax,	[r12]
    mov       rcx,	rsi
    mov       rdx,	rax
    mov       r8,	rbx
    call      memcpy
    mov       [r12],	rsi
    lea       rax,	[rsi + rbx]
    mov       [r12+8],	rax
    mov       [r12+24],	rdi
    lea       rax,	[rsi + rdi]
    mov       [r12+16],	rax
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.buffercheck
mc_genss.buffercheck:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    jmp       L3762
L3761:
    mov       rcx,	rdi
    call      mc_genss.bufferexpand
L3762:
    mov       rax,	[rdi+16]
    mov       r10,	[rdi+8]
    sub       rax,	r10
    cmp       rax,	rbx
    jl        L3761
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.bufferlength
mc_genss.bufferlength:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rcx+8]
    mov       r10,	[rcx]
    sub       rax,	r10
L3764:
#---------------
    ret       
# End 
# Proc mc_genss.bufferelemptr
mc_genss.bufferelemptr:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rcx]
    mov       r10,	rdx
    lea       rax,	[rax + r10]
L3765:
#---------------
    ret       
# End 
# Proc mc_genss.addword
mc_genss.addword:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rcx+8]
    mov       r10w,	dx
    mov       [rax],	r10w
    lea       rax,	[rcx+8]
    add       qword ptr[rax],	2
#---------------
    ret       
# End 
# Proc mc_genss.adddword
mc_genss.adddword:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rcx+8]
    mov       r10d,	edx
    mov       [rax],	r10d
    lea       rax,	[rcx+8]
    add       qword ptr[rax],	4
#---------------
    ret       
# End 
# Proc mc_genss.addqword
mc_genss.addqword:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rcx+8]
    mov       r10,	rdx
    mov       [rax],	r10
    lea       rax,	[rcx+8]
    add       qword ptr[rax],	8
#---------------
    ret       
# End 
# Proc mc_genss.genxrm
mc_genss.genxrm:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    call      mc_genss.setopsize
    xor       ecx,	ecx
    mov       rdx,	rsi
    mov       r8,	r12
    xor       r9d,	r9d
    call      mc_genss.genrm
    mov       rdi,	rax
    mov       rax,	[rip+mc_genss.currmcl]
    movzx     rax,	byte ptr[rax+33]
    cmp       rax,	12
    jz        L3771
    cmp       rax,	13
    jnz       L3772
L3771:
    and       byte ptr[rip+mc_genss.rex],	247
L3772:
L3770:
    mov       rax,	rbx
    shr       rax,	16
    and       rax,	255
    jz        L3774
    mov       rax,	rbx
    shr       rax,	16
    and       rax,	511
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
L3774:
    call      mc_genss.genrex
    mov       rax,	rbx
    shr       rax,	8
    and       rax,	255
    jz        L3776
    mov       rax,	rbx
    shr       rax,	8
    and       rax,	255
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
L3776:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	bl
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mc_genss.genamode
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.genrrm
mc_genss.genrrm:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L3779
    movzx     rax,	byte ptr[rsi+10]
    lea       r10,	[rip+mc_genss.ishighreg]
    movzx     r10,	byte ptr[r10 + rax-1]
    or        [rip+mc_genss.rex],	r10b
L3779:
    mov       rcx,	rsi
    call      mc_genss.setopsize
    mov       al,	[rip+mc_genss.usesizeb]
    test      al,	al
    jz        L3781
    and       byte ptr[rip+mc_genss.rex],	247
    movzx     rax,	word ptr[r12+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L3783
    mov       al,	8
    or        [rip+mc_genss.rex],	al
L3783:
L3781:
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    setz      al
    movzx     eax,	al
    movzx     r10,	byte ptr[rsi+10]
    mov       rcx,	r10
    xor       edx,	edx
    mov       r8,	r12
    mov       r9,	rax
    call      mc_genss.genrm
    mov       rdi,	rax
    mov       rax,	rbx
    shr       rax,	16
    and       rax,	255
    jz        L3785
    mov       rax,	rbx
    shr       rax,	16
    and       rax,	511
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
L3785:
    call      mc_genss.genrex
    mov       rax,	rbx
    shr       rax,	8
    and       rax,	255
    jz        L3787
    mov       rax,	rbx
    shr       rax,	8
    and       rax,	255
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
L3787:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	bl
    mov       rcx,	r12
    mov       rdx,	rdi
    call      mc_genss.genamode
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.getregcode
mc_genss.getregcode:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    test      r8,	r8
    jnz       L3790
    lea       rax,	[rip+mc_decls.regcodes]
    mov       r10,	rcx
    movzx     rax,	byte ptr[rax + r10]
    mov       rdi,	rax
    jmp       L3789
L3790:
    lea       rax,	[rcx-1]
    mov       rdi,	rax
L3789:
    cmp       rdi,	8
    jl        L3792
    mov       rax,	8
    sub       rdi,	rax
    mov       al,	dl
    or        [rip+mc_genss.rex],	al
L3792:
    mov       rax,	rdi
L3788:
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc mc_genss.checkimmrange
mc_genss.checkimmrange:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	rbx
    cmp       rax,	1
    jz        L3795
    cmp       rax,	2
    jz        L3796
    jmp       L3797
L3795:
    mov       rax,	rdi
    cmp       rax,	-128
    jl        L3800
    cmp       rax,	255
    jle       L3799
L3800:
    lea       rcx,	[rip+L10787]
    call      mc_libmcl.axerror
L3799:
    jmp       L3794
L3796:
    mov       rax,	rdi
    cmp       rax,	-32768
    jl        L3803
    cmp       rax,	65535
    jle       L3802
L3803:
    lea       rcx,	[rip+L10788]
    call      mc_libmcl.axerror
L3802:
    jmp       L3794
L3797:
    mov       rax,	rdi
    cmp       rax,	-2147483648
    jl        L3806
    mov       r10,	4294967295
    cmp       rax,	r10
    jle       L3805
L3806:
    lea       rcx,	[rip+L10789]
    call      mc_libmcl.axerror
L3805:
L3794:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.genrm
mc_genss.genrm:
#PROC1
#PROC2
#?>>
    .set mc_genss.genrm.b, 80
    .set mc_genss.genrm.isxreg, 88
    .set mc_genss.genrm.base, -8
    .set mc_genss.genrm.regix, -16
    .set mc_genss.genrm.ismem, -24
    .set mc_genss.genrm.am, -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
    lea       rax,	[rbp + mc_genss.genrm.am]
    xor       r10d,	r10d
    mov       [rax],	r10
    test      r13,	r13
    jz        L3809
    mov       rcx,	r13
    mov       rdx,	4
    mov       r8,	[rbp + mc_genss.genrm.isxreg]
    call      mc_genss.getregcode
    mov       r14,	rax
L3809:
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word ptr[rax+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3811
    cmp       rax,	5
    jz        L3811
    cmp       rax,	3
    jz        L3812
    jmp       L3813
L3811:
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word ptr[rax+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    setz      al
    movzx     eax,	al
    mov       r10,	[rbp + mc_genss.genrm.b]
    movzx     r10,	byte ptr[r10+10]
    mov       rcx,	r10
    mov       rdx,	1
    mov       r8,	rax
    call      mc_genss.getregcode
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	byte ptr[rax+10]
    lea       r10,	[rip+mc_genss.ishighreg]
    movzx     r10,	byte ptr[r10 + rax-1]
    or        [rip+mc_genss.rex],	r10b
    mov       rax,	r14
    shl       rax,	3
    mov       r10,	192
    add       r10,	rax
    add       r10,	rbx
    mov       [rbp + mc_genss.genrm.am],	r10b
    mov       rax,	[rbp + mc_genss.genrm.am]
    jmp       L3807
L3812:
    mov       rax,	1
    mov       [rbp + mc_genss.genrm.ismem],	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word ptr[rax+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L3815
    cmp       rax,	3
    jz        L3816
    cmp       rax,	6
    jz        L3817
    jmp       L3818
L3815:
    mov       rax,	[rbp + mc_genss.genrm.b]
    mov       rax,	[rax]
    movzx     rax,	byte ptr[rax+72]
    cmp       rax,	3
    jnz       L3820
    mov       rax,	2
    mov       [rbp + mc_genss.genrm.ismem],	rax
L3820:
    jmp       L3814
L3816:
    mov       rax,	2
    mov       [rbp + mc_genss.genrm.ismem],	rax
    jmp       L3814
L3817:
    mov       rax,	2
    mov       [rbp + mc_genss.genrm.ismem],	rax
L3818:
L3814:
    jmp       L3810
L3813:
    lea       rcx,	[rip+L10790]
    call      mc_libmcl.axerror
L3810:
    xor       eax,	eax
    mov       rbx,	rax
    mov       rdi,	rax
    xor       rsi,	rsi
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	byte ptr[rax+10]
    mov       r13,	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	byte ptr[rax+11]
    mov       [rbp + mc_genss.genrm.regix],	rax
    mov       rax,	[rbp + mc_genss.genrm.regix]
    cmp       rax,	r13
    jnz       L3822
    test      rax,	rax
    jnz       L3822
    xor       rdi,	rdi
    mov       rax,	4
    mov       rbx,	rax
    mov       rsi,	1
    mov       r12,	4
    mov       rax,	5
    mov       [rbp + mc_genss.genrm.base],	rax
    mov       al,	4
    mov       [rbp + mc_genss.genrm.am+3],	al
    jmp       L3821
L3822:
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word ptr[rax+8]
    shr       rax,	5
    and       rax,	15
    cmp       rax,	1
    jg        L3823
    mov       rax,	[rbp + mc_genss.genrm.regix]
    test      rax,	rax
    jnz       L3823
#mc_genss.genrm.simple:
L3824:
    lea       rax,	[rbp + mc_genss.genrm.am+4]
    mov       rcx,	[rbp + mc_genss.genrm.b]
    mov       rdx,	rax
    call      mc_genss.getdispsize
    mov       [rbp + mc_genss.genrm.am+3],	al
    mov       al,	[rbp + mc_genss.genrm.am+3]
    test      al,	al
    jz        L3826
    movzx     rax,	byte ptr[rbp + mc_genss.genrm.am+3]
    cmp       rax,	1
    jnz       L3828
    mov       rax,	1
    jmp       L3827
L3828:
    mov       rax,	2
L3827:
    mov       rdi,	rax
L3826:
    mov       rcx,	r13
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.genrm.base],	rax
    mov       rbx,	rax
    cmp       rbx,	4
    jz        L3830
    cmp       rbx,	5
    jnz       L3832
    movzx     rax,	byte ptr[rbp + mc_genss.genrm.am+3]
    test      rax,	rax
    jnz       L3832
    mov       rdi,	1
    mov       al,	1
    mov       [rbp + mc_genss.genrm.am+3],	al
L3832:
    xor       r12,	r12
    jmp       L3829
L3830:
    mov       r12,	4
    mov       rsi,	1
L3829:
    jmp       L3821
L3823:
    mov       rax,	[rbp + mc_genss.genrm.regix]
    test      rax,	rax
    jz        L3833
    test      r13,	r13
    jnz       L3833
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word ptr[rax+8]
    shr       rax,	5
    and       rax,	15
    cmp       rax,	1
    jg        L3835
    mov       rax,	r13
    mov       r10,	[rbp + mc_genss.genrm.regix]
    mov       [rbp + mc_genss.genrm.regix],	rax
    mov       r13,	r10
    jmp       L3824
L3835:
    mov       al,	4
    mov       [rbp + mc_genss.genrm.am+3],	al
    xor       rdi,	rdi
    mov       rax,	4
    mov       rbx,	rax
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word ptr[rax+8]
    shr       rax,	5
    and       rax,	15
    jz        L3837
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word ptr[rax+8]
    shr       rax,	5
    and       rax,	15
    jmp       L3836
L3837:
    mov       rax,	1
L3836:
    mov       rsi,	rax
    mov       rax,	5
    mov       [rbp + mc_genss.genrm.base],	rax
    mov       rcx,	[rbp + mc_genss.genrm.regix]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       r12,	rax
    mov       rax,	[rbp + mc_genss.genrm.regix]
    cmp       rax,	16
    jnz       L3839
    lea       rcx,	[rip+L10791]
    call      mc_libmcl.axerror
L3839:
    jmp       L3821
L3833:
    lea       rax,	[rbp + mc_genss.genrm.am+4]
    mov       rcx,	[rbp + mc_genss.genrm.b]
    mov       rdx,	rax
    call      mc_genss.getdispsize
    mov       [rbp + mc_genss.genrm.am+3],	al
    mov       al,	[rbp + mc_genss.genrm.am+3]
    test      al,	al
    jz        L3841
    movzx     rax,	byte ptr[rbp + mc_genss.genrm.am+3]
    cmp       rax,	1
    jnz       L3843
    mov       rax,	1
    jmp       L3842
L3843:
    mov       rax,	2
L3842:
    mov       rdi,	rax
L3841:
    mov       rbx,	4
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word ptr[rax+8]
    shr       rax,	5
    and       rax,	15
    jz        L3845
    mov       rax,	[rbp + mc_genss.genrm.b]
    movzx     rax,	word ptr[rax+8]
    shr       rax,	5
    and       rax,	15
    jmp       L3844
L3845:
    mov       rax,	1
L3844:
    mov       rsi,	rax
    test      r13,	r13
    jnz       L3847
    mov       rax,	5
    mov       [rbp + mc_genss.genrm.base],	rax
    jmp       L3846
L3847:
    mov       rax,	r13
    cmp       rax,	15
    jz        L3850
    cmp       rax,	8
    jnz       L3849
L3850:
    movzx     rax,	byte ptr[rbp + mc_genss.genrm.am+3]
    test      rax,	rax
    jnz       L3849
    mov       rdi,	1
    mov       al,	1
    mov       [rbp + mc_genss.genrm.am+3],	al
L3849:
    mov       rcx,	r13
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       [rbp + mc_genss.genrm.base],	rax
L3846:
    mov       rax,	[rbp + mc_genss.genrm.regix]
    test      rax,	rax
    jnz       L3852
    mov       r12,	4
    jmp       L3851
L3852:
    mov       rcx,	[rbp + mc_genss.genrm.regix]
    mov       rdx,	2
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       r12,	rax
    test      r13,	r13
    jnz       L3854
    mov       al,	4
    mov       [rbp + mc_genss.genrm.am+3],	al
L3854:
    mov       rax,	[rbp + mc_genss.genrm.regix]
    cmp       rax,	16
    jnz       L3856
    cmp       rsi,	1
    jle       L3856
    lea       rcx,	[rip+L10792]
    call      mc_libmcl.axerror
L3856:
L3851:
L3821:
    test      rsi,	rsi
    jz        L3858
    lea       rax,	[rip+mc_genss.genrm.scaletable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    shl       rax,	6
    mov       r10,	r12
    shl       r10,	3
    add       rax,	r10
    add       rax,	[rbp + mc_genss.genrm.base]
    mov       [rbp + mc_genss.genrm.am+1],	al
    mov       al,	1
    mov       [rbp + mc_genss.genrm.am+2],	al
L3858:
    movzx     rax,	byte ptr[rbp + mc_genss.genrm.am+3]
    cmp       rax,	4
    jnz       L3860
    mov       rax,	[rbp + mc_genss.genrm.ismem]
    test      rax,	rax
    jz        L3860
    test      r13,	r13
    jnz       L3863
    mov       rax,	[rbp + mc_genss.genrm.regix]
    test      rax,	rax
    jz        L3862
L3863:
    movzx     rax,	byte ptr[rip+pc_api.phighmem]
    cmp       rax,	2
    jnz       L3865
    mov       rax,	[rbp + mc_genss.genrm.ismem]
    cmp       rax,	2
    jnz       L3865
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10793]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+mc_decls.aaseqno]
    call      msys.m$print_i64_nf
    mov       rcx,	[rip+mc_genss.currmcl]
    call      mc_writegas.strmclstr
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L3865:
    jmp       L3861
L3862:
    mov       al,	[rip+pc_api.phighmem]
    test      al,	al
    jz        L3866
    mov       al,	-1
    mov       [rbp + mc_genss.genrm.am+2],	al
    xor       rdi,	rdi
    mov       rax,	5
    mov       rbx,	rax
L3866:
L3861:
L3860:
    mov       rax,	rdi
    shl       rax,	6
    mov       r10,	r14
    shl       r10,	3
    add       rax,	r10
    add       rax,	rbx
    mov       [rbp + mc_genss.genrm.am],	al
    mov       rax,	[rbp + mc_genss.genrm.am]
L3807:
#---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_arith
mc_genss.do_arith:
#PROC1
#PROC2
#?>>
    .set mc_genss.do_arith.$T1, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
    mov       r15,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3869
    cmp       rax,	3
    jz        L3870
    jmp       L3871
L3869:
    movzx     rax,	word ptr[r14+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3873
    cmp       rax,	3
    jz        L3873
    cmp       rax,	2
    jz        L3874
    jmp       L3875
L3873:
    mov       rax,	r15
    shl       rax,	3
    mov       [rbp + mc_genss.do_arith.$T1],	rax
    movzx     rax,	word ptr[r13+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3877
    mov       rax,	2
    jmp       L3876
L3877:
    mov       rax,	3
L3876:
    mov       r10,	[rbp + mc_genss.do_arith.$T1]
    or        r10,	rax
    mov       rbx,	r10
    mov       rcx,	rbx
    mov       rdx,	r13
    mov       r8,	r14
    call      mc_genss.genrrm
    jmp       L3872
L3874:
#mc_genss.do_arith.doregimm:
L3878:
    mov       rcx,	r14
    xor       edx,	edx
    call      mc_genss.getdef
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L3880
    movzx     rax,	word ptr[r13+8]
    and       rax,	31
    cmp       rax,	4
    jge       L3882
    lea       rcx,	[rip+L10794]
    call      mc_libmcl.axerror
L3882:
    mov       rcx,	129
    mov       rdx,	r15
    mov       r8,	r13
    call      mc_genss.genxrm
    mov       rcx,	r14
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3867
L3880:
    mov       r12,	[r14]
    mov       rsi,	1
    movzx     rax,	word ptr[r13+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3884
    mov       rbx,	128
    mov       rcx,	r12
    mov       rdx,	1
    call      mc_genss.checkimmrange
    mov       rax,	r12
    cmp       rax,	-128
    jl        L3887
    cmp       rax,	255
    jle       L3886
L3887:
    lea       rcx,	[rip+L10795]
    call      mc_libmcl.axerror
L3886:
    jmp       L3883
L3884:
    mov       rax,	r12
    cmp       rax,	-128
    jl        L3888
    cmp       rax,	127
    jg        L3888
    mov       rbx,	131
    jmp       L3883
L3888:
    mov       rcx,	r12
    mov       rdx,	4
    call      mc_genss.checkimmrange
    mov       rbx,	129
    movzx     rax,	word ptr[r13+8]
    and       rax,	31
    cmp       rax,	2
    jnz       L3890
    mov       rax,	2
    jmp       L3889
L3890:
    mov       rax,	4
L3889:
    mov       rsi,	rax
L3883:
    mov       rcx,	rbx
    mov       rdx,	r15
    mov       r8,	r13
    call      mc_genss.genxrm
    mov       rax,	rsi
    cmp       rax,	1
    jz        L3892
    cmp       rax,	2
    jz        L3893
    cmp       rax,	4
    jz        L3894
    jmp       L3895
L3892:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	r12b
    jmp       L3891
L3893:
    mov       rcx,	r12
    call      mc_genss.genword
    jmp       L3891
L3894:
    mov       rcx,	r12
    call      mc_genss.gendword
L3895:
L3891:
    mov       rcx,	rsi
    call      mc_genss.fixrip
    jmp       L3872
L3875:
    lea       rcx,	[rip+L10796]
    call      mc_libmcl.axerror
L3872:
    jmp       L3868
L3870:
    movzx     rax,	word ptr[r14+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3897
    cmp       rax,	2
    jz        L3898
    jmp       L3899
L3897:
    mov       rax,	r15
    shl       rax,	3
    mov       [rbp + mc_genss.do_arith.$T1],	rax
    movzx     rax,	word ptr[r14+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3901
    xor       eax,	eax
    jmp       L3900
L3901:
    mov       rax,	1
L3900:
    mov       r10,	[rbp + mc_genss.do_arith.$T1]
    or        r10,	rax
    mov       rbx,	r10
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r13
    call      mc_genss.genrrm
    jmp       L3896
L3898:
    jmp       L3878
L3899:
    lea       rcx,	[rip+L10797]
    call      mc_libmcl.axerror
L3896:
    jmp       L3868
L3871:
    call      msys.m$print_startcon
    lea       rax,	[rip+mc_decls.opndnames_ma]
    mov       r10,	r15
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L10798]
    call      msys.m$print_str_nf
    mov       rcx,	r15
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10799]
    call      mc_libmcl.axerror
L3868:
L3867:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_mov
mc_genss.do_mov:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    sub       rsp,	48
    mov       r14,	rcx
    mov       r15,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	r15
    xor       edx,	edx
    call      mc_genss.getdef
    mov       r13,	rax
    movzx     rax,	word ptr[r14+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3904
    cmp       rax,	3
    jz        L3905
    jmp       L3906
L3904:
    movzx     rax,	word ptr[r15+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3908
    cmp       rax,	3
    jz        L3908
    cmp       rax,	2
    jz        L3909
    jmp       L3910
L3908:
    movzx     rax,	word ptr[r14+8]
    and       rax,	31
    movzx     r10,	word ptr[r15+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L3912
    movzx     rax,	word ptr[r15+8]
    and       rax,	31
    jz        L3912
    lea       rcx,	[rip+L10800]
    call      mc_libmcl.axerror
L3912:
    movzx     rax,	word ptr[r14+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3914
    mov       rax,	138
    jmp       L3913
L3914:
    mov       rax,	139
L3913:
    mov       rcx,	rax
    mov       rdx,	r14
    mov       r8,	r15
    call      mc_genss.genrrm
    jmp       L3907
L3909:
    mov       r12,	[r15]
    movzx     rax,	byte ptr[r14+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    mov       rcx,	r14
    call      mc_genss.setopsize
    test      r13,	r13
    jz        L3916
    movzx     rax,	word ptr[r14+8]
    and       rax,	31
    cmp       rax,	2
    jg        L3916
    lea       rcx,	[rip+L10801]
    call      mc_libmcl.axerror
L3916:
    mov       rcx,	r14
    call      mc_genss.checkhighreg
    movzx     rax,	word ptr[r14+8]
    and       rax,	31
    cmp       rax,	1
    jz        L3918
    cmp       rax,	2
    jz        L3919
    cmp       rax,	4
    jz        L3920
    jmp       L3921
L3918:
    mov       rax,	r12
    cmp       rax,	-128
    jl        L3924
    cmp       rax,	255
    jle       L3923
L3924:
    lea       rcx,	[rip+L10802]
    call      mc_libmcl.axerror
L3923:
    call      mc_genss.genrex
    mov       rax,	176
    add       rax,	rdi
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	r12b
    jmp       L3917
L3919:
    mov       rax,	r12
    cmp       rax,	-32768
    jl        L3927
    cmp       rax,	65535
    jle       L3926
L3927:
    lea       rcx,	[rip+L10803]
    call      mc_libmcl.axerror
L3926:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	102
    mov       [r10],	al
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
    mov       rcx,	r12
    call      mc_genss.genword
    jmp       L3917
L3920:
    test      r13,	r13
    jz        L3929
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
    mov       rcx,	r15
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3928
L3929:
    mov       rax,	r12
    cmp       rax,	-2147483648
    jl        L3932
    mov       r10d,	4294967295
    mov       r10d,	r10d
    cmp       rax,	r10
    jle       L3931
L3932:
    call      msys.m$print_startcon
    mov       rcx,	r12
    call      msys.m$print_i64_nf
    mov       rcx,	r12
    call      msys.m$print_ptr_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10804]
    call      mc_libmcl.axerror
L3931:
#mc_genss.do_mov.doreg32:
L3933:
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
    mov       rcx,	r12
    call      mc_genss.gendword
L3928:
    jmp       L3917
L3921:
    test      r13,	r13
    jz        L3935
    mov       al,	8
    or        [rip+mc_genss.rex],	al
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
    mov       rcx,	r15
    mov       rdx,	8
    call      mc_genss.genopnd
    jmp       L3934
L3935:
    cmp       r12,	0
    jl        L3937
    mov       rax,	r12
    mov       r10,	4294967295
    cmp       rax,	r10
    jg        L3937
    and       byte ptr[rip+mc_genss.rex],	247
    jmp       L3933
L3937:
    mov       al,	8
    or        [rip+mc_genss.rex],	al
    call      mc_genss.genrex
    mov       rax,	184
    add       rax,	rdi
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
    mov       rcx,	r12
    call      mc_genss.genqword
L3934:
L3917:
    jmp       L3907
L3910:
    lea       rcx,	[rip+L10805]
    call      mc_libmcl.axerror
L3907:
    jmp       L3903
L3905:
    movzx     rax,	word ptr[r15+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3939
    cmp       rax,	2
    jz        L3940
    jmp       L3941
L3939:
    movzx     rax,	word ptr[r14+8]
    and       rax,	31
    jnz       L3943
    movzx     rax,	word ptr[r15+8]
    and       rax,	31
    lea       r10,	[r14+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L3943:
    movzx     rax,	word ptr[r14+8]
    and       rax,	31
    movzx     r10,	word ptr[r15+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L3945
    movzx     rax,	word ptr[r14+8]
    and       rax,	31
    jz        L3945
    lea       rcx,	[rip+L10806]
    call      mc_libmcl.axerror
L3945:
    movzx     rax,	word ptr[r15+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3947
    mov       rax,	136
    jmp       L3946
L3947:
    mov       rax,	137
L3946:
    mov       rcx,	rax
    mov       rdx,	r15
    mov       r8,	r14
    call      mc_genss.genrrm
    jmp       L3938
L3940:
    mov       r12,	[r15]
    movzx     rax,	word ptr[r14+8]
    and       rax,	31
    jnz       L3949
    lea       rax,	[r14+8]
    mov       r10w,	1
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3949:
    test      r13,	r13
    jz        L3951
    movzx     rax,	word ptr[r14+8]
    and       rax,	31
    cmp       rax,	2
    jg        L3951
    lea       rcx,	[rip+L10807]
    call      mc_libmcl.axerror
L3951:
    mov       rcx,	r14
    call      mc_genss.setopsize
    movzx     rax,	word ptr[r14+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3953
    mov       rax,	198
    jmp       L3952
L3953:
    mov       rax,	199
L3952:
    mov       rbx,	rax
    test      r13,	r13
    jnz       L3955
    movzx     rax,	word ptr[r14+8]
    and       rax,	31
    mov       rcx,	r12
    mov       rdx,	rax
    call      mc_genss.checkimmrange
L3955:
    mov       rcx,	rbx
    xor       edx,	edx
    mov       r8,	r14
    call      mc_genss.genxrm
    mov       r12,	[r15]
    movzx     rax,	word ptr[r14+8]
    and       rax,	31
    mov       rsi,	rax
    movzx     rax,	word ptr[r14+8]
    and       rax,	31
    cmp       rax,	1
    jz        L3957
    cmp       rax,	2
    jz        L3958
    cmp       rax,	4
    jz        L3959
    cmp       rax,	8
    jz        L3959
    jmp       L3960
L3957:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	r12b
    jmp       L3956
L3958:
    mov       rcx,	r12
    call      mc_genss.genword
    jmp       L3956
L3959:
    mov       rcx,	r15
    mov       rdx,	4
    call      mc_genss.genopnd
    mov       rsi,	4
L3960:
L3956:
    mov       rcx,	rsi
    call      mc_genss.fixrip
    jmp       L3938
L3941:
    lea       rcx,	[rip+L10808]
    call      mc_libmcl.axerror
L3938:
    jmp       L3903
L3906:
    lea       rcx,	[rip+L10809]
    call      mc_libmcl.axerror
L3903:
#---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_push
mc_genss.do_push:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    jnz       L3963
    lea       rax,	[rbx+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3963:
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3965
    cmp       rax,	2
    jz        L3966
    cmp       rax,	3
    jz        L3967
    jmp       L3968
L3965:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3970
    lea       rcx,	[rip+L10810]
    call      mc_libmcl.axerror
L3970:
    movzx     rax,	byte ptr[rbx+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    and       byte ptr[rip+mc_genss.rex],	247
    call      mc_genss.genrex
    mov       rax,	80
    add       rax,	rdi
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
    jmp       L3964
L3966:
    mov       rcx,	rbx
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L3972
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	104
    mov       [r10],	al
    mov       rcx,	rbx
    mov       rdx,	4
    call      mc_genss.genopnd
    jmp       L3971
L3972:
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      mc_genss.isbytesized
    test      rax,	rax
    jz        L3973
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	106
    mov       [r10],	al
    mov       rax,	[rbx]
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
    jmp       L3971
L3973:
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      mc_genss.isdwordsized
    test      rax,	rax
    jz        L3974
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	104
    mov       [r10],	al
    mov       rcx,	[rbx]
    call      mc_genss.gendword
    jmp       L3971
L3974:
    lea       rcx,	[rip+L10811]
    call      mc_libmcl.axerror
L3971:
    jmp       L3964
L3967:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3976
    lea       rcx,	[rip+L10812]
    call      mc_libmcl.axerror
L3976:
    mov       rcx,	255
    mov       rdx,	6
    mov       r8,	rbx
    call      mc_genss.genxrm
    jmp       L3964
L3968:
    lea       rcx,	[rip+L10813]
    call      mc_libmcl.axerror
L3964:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_pop
mc_genss.do_pop:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    jnz       L3979
    lea       rax,	[rbx+8]
    mov       r10w,	8
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L3979:
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3981
    cmp       rax,	3
    jz        L3982
    jmp       L3983
L3981:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3985
    lea       rcx,	[rip+L10814]
    call      mc_libmcl.axerror
L3985:
    movzx     rax,	byte ptr[rbx+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    call      mc_genss.genrex
    mov       rax,	88
    add       rax,	rdi
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
    jmp       L3980
L3982:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	8
    jz        L3987
    lea       rcx,	[rip+L10815]
    call      mc_libmcl.axerror
L3987:
    mov       rcx,	143
    xor       edx,	edx
    mov       r8,	rbx
    call      mc_genss.genxrm
    jmp       L3980
L3983:
    lea       rcx,	[rip+L10816]
    call      mc_libmcl.axerror
L3980:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_inc
mc_genss.do_inc:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3990
    cmp       rax,	3
    jnz       L3991
L3990:
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3993
    mov       rax,	254
    jmp       L3992
L3993:
    mov       rax,	255
L3992:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genxrm
    jmp       L3989
L3991:
    lea       rcx,	[rip+L10817]
    call      mc_libmcl.axerror
L3989:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_neg
mc_genss.do_neg:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L3996
    cmp       rax,	3
    jnz       L3997
L3996:
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L3999
    mov       rax,	246
    jmp       L3998
L3999:
    mov       rax,	247
L3998:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genxrm
    jmp       L3995
L3997:
    lea       rcx,	[rip+L10818]
    call      mc_libmcl.axerror
L3995:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_lea
mc_genss.do_lea:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4003
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4002
L4003:
    lea       rcx,	[rip+L10819]
    call      mc_libmcl.axerror
L4002:
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    cmp       rax,	4
    jge       L4005
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10820]
    call      msys.m$print_str_nf
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10821]
    call      mc_libmcl.axerror
L4005:
    mov       rcx,	141
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_movsx
mc_genss.do_movsx:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4008
    lea       rcx,	[rip+L10822]
    call      mc_libmcl.axerror
L4008:
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4010
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	4
    jnz       L4010
    cmp       rsi,	190
    jnz       L4012
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_movsxd
    jmp       L4011
L4012:
    movzx     rax,	byte ptr[rdi+10]
    lea       r10,	[rip+mc_decls.regtable]
    mov       r11,	rax
    shl       r11,	6
    lea       r10,	[r10 + r11-64]
    mov       r10,	[r10+24]
    mov       rdi,	r10
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_genss.do_mov
L4011:
    jmp       L4006
L4010:
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4015
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    movzx     r10,	word ptr[rbx+8]
    and       r10,	31
    cmp       rax,	r10
    ja        L4014
L4015:
    lea       rcx,	[rip+L10823]
    call      mc_libmcl.axerror
L4014:
    cmp       rsi,	182
    jnz       L4017
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	4
    jnz       L4017
    lea       rcx,	[rip+L10824]
    call      mc_libmcl.axerror
L4017:
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4019
    cmp       rax,	3
    jz        L4020
    jmp       L4021
L4019:
    jmp       L4018
L4020:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    jnz       L4023
    lea       rcx,	[rip+L10825]
    call      mc_libmcl.axerror
L4023:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4025
    lea       rcx,	[rip+L10826]
    call      mc_libmcl.axerror
L4025:
    jmp       L4018
L4021:
    lea       rcx,	[rip+L10827]
    call      mc_libmcl.axerror
L4018:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4027
    mov       rax,	rsi
    jmp       L4026
L4027:
    lea       rax,	[rsi+1]
L4026:
    mov       r10,	3840
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
L4006:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_exch
mc_genss.do_exch:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4030
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4030
    movzx     rax,	byte ptr[rbx+10]
    cmp       rax,	1
    jz        L4031
    movzx     rax,	byte ptr[rsi+10]
    cmp       rax,	1
    jnz       L4030
L4031:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4030
    movzx     rax,	byte ptr[rbx+10]
    cmp       rax,	1
    jz        L4033
    mov       rax,	rbx
    mov       r10,	rsi
    mov       rsi,	rax
    mov       rbx,	r10
L4033:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    movzx     r10,	word ptr[rsi+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L4035
    lea       rcx,	[rip+L10828]
    call      mc_libmcl.axerror
L4035:
    mov       rcx,	rbx
    call      mc_genss.setopsize
    movzx     rax,	byte ptr[rsi+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    call      mc_genss.genrex
    mov       rax,	144
    add       rax,	rdi
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
    jmp       L4028
L4030:
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4037
    mov       rax,	rbx
    mov       r10,	rsi
    mov       rsi,	rax
    mov       rbx,	r10
L4037:
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4040
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4039
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4039
L4040:
    lea       rcx,	[rip+L10829]
    call      mc_libmcl.axerror
L4039:
    movzx     rax,	word ptr[rsi+8]
    and       rax,	31
    jnz       L4042
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4042
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    lea       r10,	[rsi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L4042:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    movzx     r10,	word ptr[rsi+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L4044
    lea       rcx,	[rip+L10830]
    call      mc_libmcl.axerror
L4044:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4046
    mov       rax,	134
    jmp       L4045
L4046:
    mov       rax,	135
L4045:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_genss.genrrm
L4028:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_movsxd
mc_genss.do_movsxd:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4049
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    jnz       L4049
    lea       rax,	[rbx+8]
    mov       r10w,	4
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L4049:
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4052
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	4
    jle       L4051
L4052:
    lea       rcx,	[rip+L10831]
    call      mc_libmcl.axerror
L4051:
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4055
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4054
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4054
L4055:
    lea       rcx,	[rip+L10832]
    call      mc_libmcl.axerror
L4054:
    mov       rcx,	99
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_imul2
mc_genss.do_imul2:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4058
    lea       rcx,	[rip+L10833]
    call      mc_libmcl.axerror
L4058:
    movzx     rax,	word ptr[r13+8]
    and       rax,	31
    jnz       L4060
    movzx     rax,	word ptr[r12+8]
    and       rax,	31
    lea       r10,	[r13+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L4060:
    movzx     rax,	word ptr[r12+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4062
    lea       rcx,	[rip+L10834]
    call      mc_libmcl.axerror
L4062:
    movzx     rax,	word ptr[r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4064
    cmp       rax,	3
    jz        L4064
    cmp       rax,	2
    jz        L4065
    jmp       L4066
L4064:
    movzx     rax,	word ptr[r12+8]
    and       rax,	31
    movzx     r10,	word ptr[r13+8]
    and       r10,	31
    cmp       rax,	r10
    jz        L4068
    lea       rcx,	[rip+L10835]
    call      mc_libmcl.axerror
L4068:
    mov       rcx,	4015
    mov       rdx,	r12
    mov       r8,	r13
    call      mc_genss.genrrm
    jmp       L4063
L4065:
    mov       rcx,	r13
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L4070
    lea       rcx,	[rip+L10836]
    call      mc_libmcl.axerror
L4070:
    mov       rsi,	[r13]
    mov       rax,	rsi
    cmp       rax,	-128
    jl        L4072
    cmp       rax,	127
    jg        L4072
    mov       rdi,	107
    jmp       L4071
L4072:
    mov       rdi,	105
L4071:
    mov       rcx,	rdi
    mov       rdx,	r12
    mov       r8,	r12
    call      mc_genss.genrrm
    mov       rax,	rsi
    cmp       rax,	-128
    jl        L4074
    cmp       rax,	127
    jg        L4074
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	sil
    mov       rbx,	1
    jmp       L4073
L4074:
    movzx     rax,	word ptr[r12+8]
    and       rax,	31
    cmp       rax,	2
    jnz       L4075
    mov       rcx,	rsi
    call      mc_genss.genword
    mov       rbx,	2
    jmp       L4073
L4075:
    mov       rcx,	rsi
    call      mc_genss.gendword
    mov       rbx,	4
L4073:
    mov       rcx,	rbx
    call      mc_genss.fixrip
    jmp       L4063
L4066:
    lea       rcx,	[rip+L10837]
    call      mc_libmcl.axerror
L4063:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_shift
mc_genss.do_shift:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4078
    movzx     rax,	word ptr[r12+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4078
    lea       rcx,	[rip+L10838]
    call      mc_libmcl.axerror
L4078:
    mov       rcx,	r13
    xor       edx,	edx
    call      mc_genss.getdef
    test      rax,	rax
    jz        L4080
    lea       rcx,	[rip+L10839]
    call      mc_libmcl.axerror
L4080:
    movzx     rax,	word ptr[r12+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4082
    xor       eax,	eax
    jmp       L4081
L4082:
    mov       rax,	1
L4081:
    mov       rdi,	rax
    xor       rsi,	rsi
    movzx     rax,	word ptr[r13+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jz        L4084
    cmp       rax,	1
    jz        L4085
    jmp       L4086
L4084:
    mov       rax,	[r13]
    cmp       rax,	1
    jnz       L4088
    mov       rax,	208
    add       rax,	rdi
    mov       rbx,	rax
    jmp       L4087
L4088:
    mov       rax,	192
    add       rax,	rdi
    mov       rbx,	rax
    mov       rsi,	1
L4087:
    jmp       L4083
L4085:
    movzx     rax,	byte ptr[r13+10]
    cmp       rax,	11
    jnz       L4091
    movzx     rax,	word ptr[r13+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4090
L4091:
    lea       rcx,	[rip+L10840]
    call      mc_libmcl.axerror
L4090:
    mov       rax,	210
    add       rax,	rdi
    mov       rbx,	rax
    jmp       L4083
L4086:
    lea       rcx,	[rip+L10841]
    call      mc_libmcl.axerror
L4083:
    mov       rcx,	rbx
    mov       rdx,	r14
    mov       r8,	r12
    call      mc_genss.genxrm
    test      rsi,	rsi
    jz        L4093
    mov       rax,	[r13]
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
    mov       rcx,	1
    call      mc_genss.fixrip
L4093:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_test
mc_genss.do_test:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4096
    movzx     rax,	byte ptr[rbx+10]
    cmp       rax,	1
    jnz       L4096
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L4096
    mov       rdi,	[rsi]
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4098
    cmp       rax,	2
    jz        L4099
    cmp       rax,	4
    jz        L4100
    jmp       L4101
L4098:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	168
    mov       [r10],	al
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	dil
    jmp       L4097
L4099:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	102
    mov       [r10],	al
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	169
    mov       [r10],	al
    mov       rcx,	rdi
    call      mc_genss.genword
    jmp       L4097
L4100:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	169
    mov       [r10],	al
    mov       rcx,	rdi
    call      mc_genss.gendword
    jmp       L4097
L4101:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	72
    mov       [r10],	al
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	169
    mov       [r10],	al
    mov       rcx,	rdi
    call      mc_genss.gendword
L4097:
    jmp       L4095
L4096:
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4103
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4102
L4103:
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	2
    jnz       L4102
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4105
    mov       rax,	246
    jmp       L4104
L4105:
    mov       rax,	247
L4104:
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	rbx
    call      mc_genss.genxrm
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	1
    jz        L4107
    cmp       rax,	2
    jz        L4108
    jmp       L4109
L4107:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	dil
    jmp       L4106
L4108:
    mov       rcx,	rdi
    call      mc_genss.genword
    jmp       L4106
L4109:
    mov       rcx,	rdi
    call      mc_genss.gendword
L4106:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    mov       rcx,	rax
    call      mc_genss.fixrip
    jmp       L4095
L4102:
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4111
    cmp       rax,	3
    jnz       L4110
L4111:
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4110
#mc_genss.do_test.domemreg:
L4112:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	1
    jnz       L4114
    mov       rax,	132
    jmp       L4113
L4114:
    mov       rax,	133
L4113:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_genss.genrrm
    jmp       L4095
L4110:
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4115
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4115
    mov       rax,	rbx
    mov       r10,	rsi
    mov       rsi,	rax
    mov       rbx,	r10
    jmp       L4112
L4115:
    lea       rcx,	[rip+L10842]
    call      mc_libmcl.axerror
L4095:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_setcc
mc_genss.do_setcc:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4120
    cmp       rax,	3
    jnz       L4119
L4120:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	1
    jle       L4118
L4119:
    lea       rcx,	[rip+L10843]
    call      mc_libmcl.axerror
L4118:
    mov       rax,	3984
    add       rax,	rdi
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	rbx
    call      mc_genss.genxrm
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.checksize
mc_genss.checksize:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    jnz       L4123
    lea       rcx,	[rip+L10844]
    call      mc_libmcl.axerror
L4123:
    test      rbx,	rbx
    jz        L4125
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    cmp       rax,	rbx
    jz        L4125
    cmp       rax,	rsi
    jz        L4125
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10845]
    call      msys.m$print_str_nf
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10846]
    call      mc_libmcl.axerror
L4125:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_arithxmm
mc_genss.do_arithxmm:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4129
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4128
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4128
L4129:
    lea       rcx,	[rip+L10847]
    call      mc_libmcl.axerror
L4128:
    test      rsi,	rsi
    jz        L4131
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	sil
L4131:
    mov       rax,	3840
    add       rax,	r12
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_logicxmm
mc_genss.do_logicxmm:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4135
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4134
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4134
L4135:
    lea       rcx,	[rip+L10848]
    call      mc_libmcl.axerror
L4134:
    cmp       r12,	8
    jnz       L4137
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	102
    mov       [r10],	al
L4137:
    mov       rax,	3840
    add       rax,	rsi
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_convertfloat
mc_genss.do_convertfloat:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4141
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4140
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4140
L4141:
    lea       rcx,	[rip+L10849]
    call      mc_libmcl.axerror
L4140:
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	sil
    mov       al,	1
    mov       [rip+mc_genss.nowmask],	al
    mov       rcx,	3930
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_fix
mc_genss.do_fix:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r15
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4145
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4144
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4144
L4145:
    lea       rcx,	[rip+L10850]
    call      mc_libmcl.axerror
L4144:
    mov       rcx,	rdi
    mov       rdx,	4
    mov       r8,	8
    call      mc_genss.checksize
    cmp       rsi,	243
    jnz       L4147
    mov       rax,	4
    jmp       L4146
L4147:
    mov       rax,	8
L4146:
    lea       r10,	[rbx+8]
    mov       r15w,	[r10]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	ax
    mov       [r10],	r15w
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	sil
    mov       rax,	3840
    add       rax,	r12
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
#---------------
    add       rsp,	48
    pop       r15
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_float
mc_genss.do_float:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4151
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4150
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jz        L4150
L4151:
    lea       rcx,	[rip+L10851]
    call      mc_libmcl.axerror
L4150:
    mov       rcx,	rbx
    mov       rdx,	4
    mov       r8,	8
    call      mc_genss.checksize
    cmp       rsi,	243
    jnz       L4153
    mov       rax,	4
    jmp       L4152
L4153:
    mov       rax,	8
L4152:
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	sil
    mov       al,	1
    mov       [rip+mc_genss.usesizeb],	al
    mov       rcx,	3882
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_movxmm
mc_genss.do_movxmm:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4156
    cmp       rax,	5
    jz        L4157
    cmp       rax,	3
    jz        L4158
    jmp       L4159
L4156:
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4162
L4161:
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L4164
    lea       rcx,	[rip+L10852]
    call      mc_libmcl.axerror
L4164:
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    lea       r10,	[rbx+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       al,	1
    mov       [rip+mc_genss.sizeoverride],	al
    mov       rcx,	3966
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genrrm
    jmp       L4160
L4162:
    lea       rcx,	[rip+L10853]
    call      mc_libmcl.axerror
L4160:
    jmp       L4155
L4157:
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4166
    cmp       rax,	5
    jz        L4167
    cmp       rax,	3
    jz        L4168
    jmp       L4169
L4166:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L4171
    lea       rcx,	[rip+L10854]
    call      mc_libmcl.axerror
L4171:
    mov       al,	1
    mov       [rip+mc_genss.sizeoverride],	al
    mov       rcx,	3950
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
    jmp       L4165
L4167:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    lea       r10,	[rdi+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
    mov       al,	1
    mov       [rip+mc_genss.f3override],	al
    mov       rcx,	3966
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
    jmp       L4165
L4168:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    jnz       L4173
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    lea       r10,	[rbx+8]
    mov       r9w,	[r10]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	ax
    mov       [r10],	r9w
L4173:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L4175
    lea       rcx,	[rip+L10855]
    call      mc_libmcl.axerror
L4175:
    cmp       rsi,	4
    jnz       L4177
    mov       al,	1
    mov       [rip+mc_genss.sizeoverride],	al
    mov       al,	1
    mov       [rip+mc_genss.nowmask],	al
    mov       rcx,	3950
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
    jmp       L4176
L4177:
    mov       al,	1
    mov       [rip+mc_genss.f3override],	al
    mov       al,	1
    mov       [rip+mc_genss.nowmask],	al
    mov       rcx,	3966
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
L4176:
    jmp       L4165
L4169:
    lea       rcx,	[rip+L10856]
    call      mc_libmcl.axerror
L4165:
    jmp       L4155
L4158:
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4180
L4179:
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    jz        L4182
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    cmp       rax,	rsi
    jz        L4182
    lea       rcx,	[rip+L10857]
    call      mc_libmcl.axerror
L4182:
    mov       al,	1
    mov       [rip+mc_genss.sizeoverride],	al
    cmp       rsi,	4
    jnz       L4184
    mov       rax,	3966
    jmp       L4183
L4184:
    mov       rax,	4054
L4183:
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genrrm
    jmp       L4178
L4180:
    lea       rcx,	[rip+L10858]
    call      mc_libmcl.axerror
L4178:
    jmp       L4155
L4159:
    lea       rcx,	[rip+L10859]
    call      mc_libmcl.axerror
L4155:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.fixrip
mc_genss.fixrip:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_genss.ripentry]
    test      rax,	rax
    jz        L4185
L4187:
    mov       rax,	rdi
    test      rax,	rax
    jz        L4189
    cmp       rax,	1
    jz        L4190
    cmp       rax,	2
    jz        L4190
    cmp       rax,	4
    jz        L4190
    jmp       L4191
L4189:
    jmp       L4185
L4190:
    jmp       L4188
L4191:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10860]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10861]
    call      mc_libmcl.axerror
L4188:
    mov       eax,	edi
    mov       r10,	[rip+mc_genss.ripentry]
    mov       [r10+12],	eax
L4185:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_bswap
mc_genss.do_bswap:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jnz       L4195
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	4
    jge       L4194
L4195:
    lea       rcx,	[rip+L10862]
    call      mc_libmcl.axerror
L4194:
    mov       rcx,	rbx
    call      mc_genss.setopsize
    movzx     rax,	byte ptr[rbx+10]
    mov       rcx,	rax
    mov       rdx,	1
    xor       r8d,	r8d
    call      mc_genss.getregcode
    mov       rdi,	rax
    call      mc_genss.genrex
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       al,	15
    mov       [r10],	al
    mov       rax,	200
    add       rax,	rdi
    mov       r10,	[rip+mc_genss.currdata]
    lea       r10,	[r10+8]
    mov       r11,	[r10]
    inc       qword ptr[r10]
    mov       [r11],	al
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_movdqx
mc_genss.do_movdqx:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    mov       rax,	rsi
    shl       rax,	16
    add       rax,	3840
    mov       rsi,	rax
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    jnz       L4198
    lea       rax,	[rdi+8]
    mov       r10w,	16
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L4198:
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    jnz       L4200
    lea       rax,	[rbx+8]
    mov       r10w,	16
    mov       r9w,	[rax]
    mov       r11,	-32
    and       r9w,	r11w
    or        r9w,	r10w
    mov       [rax],	r9w
L4200:
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4202
    lea       rax,	[rsi+127]
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genrrm
    jmp       L4201
L4202:
    lea       rax,	[rsi+111]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_genss.genrrm
L4201:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_genss.do_dshift
mc_genss.do_dshift:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r15
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
#---------------
#PROC3
#PROC4
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    jnz       L4205
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    lea       r10,	[rdi+8]
    mov       r15w,	[r10]
    mov       r11,	-32
    and       r15w,	r11w
    or        r15w,	ax
    mov       [r10],	r15w
L4205:
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    movzx     r10,	word ptr[rbx+8]
    and       r10,	31
    cmp       rax,	r10
    jnz       L4208
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    cmp       rax,	1
    jg        L4207
L4208:
    lea       rcx,	[rip+L10863]
    call      mc_libmcl.axerror
L4207:
    xor       eax,	eax
    mov       [rip+mc_genss.sizeoverride],	al
    mov       rax,	3840
    add       rax,	r12
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      mc_genss.genrrm
    mov       rax,	[rip+mc_genss.currdata]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	sil
#---------------
    add       rsp,	48
    pop       r15
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_decls.start
mc_decls.start:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
#---------------
#PROC3
#PROC4
    xor       rbx,	rbx
    mov       rax,	13
    mov       rdi,	rax
    cmp       rdi,	0
    jl        L4212
L4210:
    mov       al,	10
    lea       r10,	[rip+mc_decls.ploadop]
    mov       r11,	rbx
    mov       [r10 + r11],	al
    inc       rbx
    cmp       rbx,	rdi
    jle       L4210
L4212:
    mov       al,	19
    lea       r10,	[rip+mc_decls.ploadop]
    mov       [r10+5],	al
    lea       r10,	[rip+mc_decls.ploadop]
    mov       [r10+4],	al
    lea       r10,	[rip+mc_decls.ploadop]
    mov       [r10+3],	al
    mov       al,	18
    lea       r10,	[rip+mc_decls.ploadop]
    mov       [r10+9],	al
    lea       r10,	[rip+mc_decls.ploadop]
    mov       [r10+8],	al
    lea       r10,	[rip+mc_decls.ploadop]
    mov       [r10+7],	al
    mov       al,	16
    lea       r10,	[rip+mc_decls.ploadop]
    mov       [r10+1],	al
    mov       al,	17
    lea       r10,	[rip+mc_decls.ploadop]
    mov       [r10+2],	al
    mov       al,	11
    lea       r10,	[rip+mc_decls.ploadop]
    mov       [r10+10],	al
    lea       r10,	[rip+mc_decls.ploadop]
    mov       [r10+6],	al
#---------------
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writegas.getassemstr
mc_writegas.getassemstr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10864]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L10865]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rip+pc_api.phighmem]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rip+pc_decls.pdest]
    call      mlib.gs_init
    lea       rcx,	[rip+L10866]
    call      mc_writegas.asmstr
    lea       rcx,	[rip+L10867]
    call      mc_writegas.asmstr
    lea       rcx,	[rip+L10868]
    call      mc_writegas.asmstr
    mov       rdi,	[rip+pc_decls.psymboltable]
    jmp       L4217
L4214:
    mov       al,	[rdi+81]
    test      al,	al
    jz        L4219
    lea       rcx,	[rip+L10869]
    call      mc_writegas.asmstr
    mov       rcx,	[rdi]
    call      mc_writegas.asmstr
    lea       rcx,	[rip+L10870]
    call      mc_writegas.asmstr
L4219:
    mov       rdi,	[rdi+8]
L4217:
    test      rdi,	rdi
    jnz       L4214
    lea       rcx,	[rip+L10870]
    call      mc_writegas.asmstr
    mov       rbx,	[rip+mc_decls.mccode]
    mov       rsi,	1
    jmp       L4221
L4220:
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mc_writegas.writemcl
    inc       rsi
    mov       rbx,	[rbx+8]
L4221:
    test      rbx,	rbx
    jnz       L4220
    mov       rax,	[rip+pc_decls.pdest]
L4213:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writegas.writemcl
mc_writegas.writemcl:
#PROC1
#PROC2
#?>>
    .set mc_writegas.writemcl.index, 24
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rdx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rdi+33]
    cmp       rax,	6
    jnz       L4226
L4225:
    jmp       L4224
L4226:
    mov       rcx,	rdi
    call      mc_writegas.strmcl
    mov       rcx,	[rip+pc_decls.pdest]
    call      mlib.gs_line
L4224:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_writegas.start
mc_writegas.start:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    mov       rax,	1297301838
    mov       [rip+pc_decls.assemtype],	rax
    mov       rsi,	1
L4228:
    mov       rax,	rsi
    cmp       rax,	1
    jz        L4233
    cmp       rax,	2
    jz        L4233
    cmp       rax,	4
    jz        L4233
    cmp       rax,	8
    jnz       L4232
L4233:
    mov       r12,	1
L4234:
    xor       dil,	dil
    mov       rax,	1
    mov       r13,	rax
    mov       rbx,	137
    cmp       rbx,	1
    jl        L4239
L4237:
    test      dil,	dil
    jz        L4241
    lea       rax,	[rip+mc_decls.regsizes]
    mov       r10,	r13
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	rsi
    jnz       L4243
    lea       rax,	[rip+mc_decls.regindices]
    mov       r10,	r13
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	r12
    jnz       L4243
    lea       rax,	[rip+mc_decls.dregnames]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    lea       r10,	[rip+mc_writegas.nregnames]
    mov       r11,	rsi
    shl       r11,	7
    lea       r10,	[r10 + r11-128]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
L4243:
    jmp       L4240
L4241:
    lea       rax,	[rip+mc_decls.regsizes]
    mov       r10,	r13
    movzx     rax,	byte ptr[rax + r10-1]
    test      rax,	rax
    jnz       L4244
    mov       dil,	1
L4244:
L4240:
    inc       r13
    cmp       r13,	rbx
    jle       L4237
L4239:
    inc       r12
    cmp       r12,	16
    jle       L4234
L4232:
    inc       rsi
    cmp       rsi,	8
    jle       L4228
#---------------
    add       rsp,	16
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writegas.strmcl
mc_writegas.strmcl:
#PROC1
#PROC2
#?>>
    .set mc_writegas.strmcl.mcl, 72
    .set mc_writegas.strmcl.opcname, -128
    .set mc_writegas.strmcl.$T1, -136
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	168
    mov       [rbp+72],	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + mc_writegas.strmcl.mcl]
    movzx     rax,	byte ptr[rax+33]
    mov       rsi,	rax
    mov       rax,	[rbp + mc_writegas.strmcl.mcl]
    movzx     rax,	byte ptr[rax+34]
    mov       r12,	rax
    mov       rax,	[rbp + mc_writegas.strmcl.mcl]
    mov       rdi,	[rax+16]
    mov       rax,	[rbp + mc_writegas.strmcl.mcl]
    mov       rbx,	[rax+24]
    xor       r14,	r14
    mov       rax,	rsi
    cmp       rax,	1
    jz        L4247
    cmp       rax,	2
    jz        L4248
    cmp       rax,	3
    jz        L4249
    cmp       rax,	4
    jz        L4250
    cmp       rax,	9
    jz        L4251
    cmp       rax,	5
    jz        L4252
    cmp       rax,	123
    jz        L4253
    cmp       rax,	121
    jz        L4254
    cmp       rax,	122
    jz        L4255
    jmp       L4256
L4247:
    lea       rcx,	[rip+L10871]
    call      mc_writegas.asmstr
    mov       rax,	[rdi]
    mov       rcx,	[rax]
    call      mc_writegas.asmstr
    mov       rax,	[rdi]
    mov       [rip+mc_decls.currasmproc],	rax
    jmp       L4245
L4248:
    lea       rcx,	[rip+L10872]
    call      mc_writegas.asmstr
    xor       eax,	eax
    mov       [rip+mc_decls.currasmproc],	rax
    jmp       L4245
L4249:
    mov       rcx,	8227
    call      mc_writegas.asmchar
    mov       rcx,	[rdi]
    call      mc_writegas.asmstr
    jmp       L4245
L4250:
    mov       r15,	[rdi]
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L4258
    cmp       rax,	4
    jz        L4259
    jmp       L4260
L4258:
    mov       rcx,	r15
    call      mc_writegas.getdispname
    mov       rcx,	rax
    call      mc_writegas.asmstr
    jmp       L4257
L4259:
    mov       rcx,	[rdi]
    call      mc_writegas.asmstr
    jmp       L4245
L4260:
    lea       rcx,	[rip+L10873]
    lea       rdx,	[rip+L10874]
    call      pc_api.merror
L4257:
    lea       rcx,	[rip+L10875]
    call      mc_writegas.asmstr
    mov       al,	[r15+81]
    test      al,	al
    jz        L4262
    mov       rax,	[r15]
    mov       [rbp + mc_writegas.strmcl.$T1],	rax
    mov       rax,	[r15]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_writegas.strmcl.$T1]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L4263
L4264:
    lea       rcx,	[rip+L10876]
    call      mc_writegas.asmstr
    mov       rax,	[r15]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       rcx,	rax
    call      mc_writegas.asmstr
    lea       rcx,	[rip+L10877]
    call      mc_writegas.asmstr
L4263:
L4262:
    jmp       L4245
L4251:
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	6
    jnz       L4266
    lea       rcx,	[rip+mc_writegas.strmcl.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10878]
    call      msys.m$print_setfmt
    mov       rcx,	[rdi]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L4265
L4266:
    jmp       L4250
L4265:
    lea       rcx,	[rip+mc_writegas.strmcl.str]
    call      mc_writegas.asmstr
    jmp       L4245
L4252:
    lea       rcx,	[rip+L10879]
    call      mc_writegas.asmstr
    mov       rcx,	[rdi]
    call      mc_writegas.asmstr
    lea       rcx,	[rip+L10880]
    call      mc_writegas.asmstr
    mov       rcx,	rbx
    xor       edx,	edx
    xor       r8d,	r8d
    call      mc_writegas.asmopnd
    jmp       L4245
    jmp       L4246
L4253:
    lea       rcx,	[rip+L10881]
    call      mc_writegas.asmstr
    mov       al,	1
    mov       [rip+mc_writegas.currseg],	al
    jmp       L4245
L4254:
    lea       rcx,	[rip+L10882]
    call      mc_writegas.asmstr
    mov       al,	2
    mov       [rip+mc_writegas.currseg],	al
    jmp       L4245
L4255:
    lea       rcx,	[rip+L10883]
    call      mc_writegas.asmstr
    mov       al,	3
    mov       [rip+mc_writegas.currseg],	al
    jmp       L4245
L4256:
L4246:
    mov       rax,	rsi
    cmp       rax,	26
    jz        L4268
    cmp       rax,	58
    jz        L4269
    cmp       rax,	15
    jz        L4270
    cmp       rax,	38
    jz        L4271
    cmp       rax,	39
    jz        L4272
    cmp       rax,	40
    jz        L4273
    cmp       rax,	51
    jz        L4274
    cmp       rax,	34
    jz        L4275
    cmp       rax,	19
    jz        L4276
    cmp       rax,	18
    jz        L4277
    cmp       rax,	16
    jz        L4278
    cmp       rax,	124
    jz        L4279
    cmp       rax,	125
    jz        L4280
    cmp       rax,	116
    jz        L4281
    cmp       rax,	117
    jz        L4282
    cmp       rax,	118
    jz        L4283
    cmp       rax,	119
    jz        L4284
    cmp       rax,	120
    jz        L4285
    cmp       rax,	8
    jz        L4286
    jmp       L4287
L4268:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10884]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[rip+mc_decls.asmcondnames]
    mov       r10,	r12
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L4267
L4269:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10885]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[rip+mc_decls.asmcondnames]
    mov       r10,	r12
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L4267
L4270:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10886]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[rip+mc_decls.asmcondnames]
    mov       r10,	r12
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L4267
L4271:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    lea       rdx,	[rip+L10887]
    call      strcpy
    jmp       L4267
L4272:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    lea       rdx,	[rip+L10888]
    call      strcpy
    jmp       L4267
L4273:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    lea       rdx,	[rip+L10889]
    call      strcpy
    jmp       L4267
L4274:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    lea       rdx,	[rip+L10890]
    call      strcpy
    jmp       L4267
L4275:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    lea       rdx,	[rip+L10891]
    call      strcpy
    jmp       L4267
L4276:
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4289
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	4
    jnz       L4289
    mov       rcx,	rdi
    mov       rdx,	4
    call      mc_libmcl.changeopndsize
    mov       rdi,	rax
    mov       r10,	[rbp + mc_writegas.strmcl.mcl]
    mov       [r10+16],	rax
    mov       rsi,	11
L4289:
    jmp       L4287
    jmp       L4267
L4277:
    movzx     rax,	word ptr[rdi+8]
    and       rax,	31
    cmp       rax,	8
    jnz       L4291
    movzx     rax,	word ptr[rbx+8]
    and       rax,	31
    cmp       rax,	4
    jnz       L4291
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    lea       rdx,	[rip+L10892]
    call      strcpy
    jmp       L4290
L4291:
    jmp       L4287
L4290:
    jmp       L4267
L4278:
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4293
    movzx     rax,	word ptr[rbx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4293
    mov       rsi,	17
L4293:
    jmp       L4287
    jmp       L4267
L4279:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    lea       rdx,	[rip+L10893]
    call      strcpy
    jmp       L4267
L4280:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    lea       rdx,	[rip+L10894]
    call      strcpy
    jmp       L4267
L4281:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    lea       rdx,	[rip+L10895]
    call      strcpy
    jmp       L4267
L4282:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    lea       rdx,	[rip+L10896]
    call      strcpy
    jmp       L4267
L4283:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    lea       rdx,	[rip+L10897]
    call      strcpy
    jmp       L4267
L4284:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    lea       rdx,	[rip+L10898]
    call      strcpy
    jmp       L4267
L4285:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    lea       rdx,	[rip+L10899]
    call      strcpy
    jmp       L4267
L4286:
    jmp       L4245
L4287:
    cmp       rsi,	152
    jle       L4295
    mov       rcx,	rsi
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    mov       rdx,	rax
    call      strcpy
    jmp       L4294
L4295:
    lea       rax,	[rip+mc_decls.mclnames]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    lea       rax,	[rax+2]
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    mov       rdx,	rax
    call      strcpy
L4294:
L4267:
    lea       rcx,	[rbp + mc_writegas.strmcl.opcname]
    mov       rdx,	10
    lea       r8,	[rip+L10900]
    call      mlib.ipadstr
    lea       rcx,	[rip+mc_writegas.strmcl.str]
    lea       rdx,	[rip+L10901]
    call      strcpy
    lea       rcx,	[rip+mc_writegas.strmcl.str]
    mov       rdx,	4
    lea       r8,	[rip+L10902]
    call      mlib.ipadstr
    lea       rcx,	[rip+mc_writegas.strmcl.str]
    lea       rdx,	[rbp + mc_writegas.strmcl.opcname]
    call      strcat
    lea       rcx,	[rip+mc_writegas.strmcl.str]
    call      mc_writegas.asmstr
    test      rdi,	rdi
    jz        L4297
    test      rbx,	rbx
    jz        L4297
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_writegas.needsizeprefix
    mov       r13,	rax
    mov       rcx,	rdi
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_writegas.asmopnd
    lea       rcx,	[rip+L10903]
    call      mc_writegas.asmstr
    mov       rcx,	rbx
    mov       rdx,	r13
    xor       r8d,	r8d
    call      mc_writegas.asmopnd
    mov       rax,	[rbp + mc_writegas.strmcl.mcl]
    mov       al,	[rax+32]
    test      al,	al
    jz        L4299
    lea       rcx,	[rip+L10904]
    call      mc_writegas.asmstr
    mov       rax,	[rbp + mc_writegas.strmcl.mcl]
    movzx     rax,	byte ptr[rax+32]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    mov       rcx,	rax
    call      mc_writegas.asmstr
L4299:
    jmp       L4296
L4297:
    test      rdi,	rdi
    jz        L4300
    movzx     rax,	word ptr[rdi+8]
    shr       rax,	9
    and       rax,	7
    jz        L4300
    cmp       rsi,	21
    jnz       L4302
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	rsi
    call      mc_writegas.asmopnd
    jmp       L4301
L4302:
    mov       rcx,	rdi
    mov       rdx,	1
    mov       r8,	rsi
    call      mc_writegas.asmopnd
L4301:
L4300:
L4296:
L4245:
#---------------
    add       rsp,	168
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writegas.strmclstr
mc_writegas.strmclstr:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+pc_decls.pdest]
    call      mlib.gs_init
    mov       rcx,	rdi
    call      mc_writegas.strmcl
    mov       rax,	[rip+pc_decls.pdest]
    mov       rax,	[rax]
L4303:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_writegas.mstropnd
mc_writegas.mstropnd:
#PROC1
#PROC2
#?>>
    .set mc_writegas.mstropnd.str2, -128
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	168
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    lea       r10,	[rip+mc_writegas.mstropnd.str]
    mov       [r10],	al
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4306
    cmp       rax,	2
    jz        L4307
    cmp       rax,	3
    jz        L4308
    cmp       rax,	5
    jz        L4309
    jmp       L4310
L4306:
    movzx     rax,	word ptr[rsi+8]
    and       rax,	31
    movzx     r10,	byte ptr[rsi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writegas.strreg
    jmp       L4304
L4307:
    cmp       r13,	119
    jnz       L4312
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	1
    jnz       L4312
    mov       rax,	[rsi]
    cmp       rax,	0
    jl        L4314
    cmp       rax,	9
    jg        L4314
    mov       rax,	[rsi]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4313
L4314:
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    lea       rdx,	[rip+L10905]
    call      strcat
    mov       rax,	[rsi]
    mov       rcx,	rax
    lea       rdx,	[rip+L10906]
    call      msys.strword
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    mov       rdx,	rax
    call      strcat
L4313:
    jmp       L4311
L4312:
    mov       rcx,	rsi
    call      mc_writegas.strvalue
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    mov       rdx,	rax
    call      strcpy
L4311:
    jmp       L4305
L4308:
    movzx     rax,	word ptr[rsi+8]
    and       rax,	31
    mov       rcx,	rax
    mov       rdx,	r12
    call      mc_writegas.getsizeprefix
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    lea       rdx,	[rip+L10907]
    call      strcat
    lea       rax,	[rip+L10908]
    mov       rdi,	rax
    mov       al,	[rsi+10]
    test      al,	al
    jz        L4316
    movzx     rax,	byte ptr[rsi+10]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_writegas.strreg
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[rip+L10909]
    mov       rdi,	rax
L4316:
    mov       al,	[rsi+11]
    test      al,	al
    jz        L4318
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    mov       rdx,	rdi
    call      strcat
    movzx     rax,	byte ptr[rsi+11]
    mov       rcx,	rax
    mov       rdx,	8
    call      mc_writegas.strreg
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[rip+L10909]
    mov       rdi,	rax
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	5
    and       rax,	15
    cmp       rax,	1
    jle       L4320
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    lea       rdx,	[rip+L10910]
    call      strcat
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	5
    and       rax,	15
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    mov       rdx,	rax
    call      strcat
L4320:
L4318:
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L4323
    cmp       rax,	6
    jz        L4323
    cmp       rax,	8
    jnz       L4322
L4323:
    movzx     rax,	byte ptr[rsi+10]
    movzx     r10,	byte ptr[rsi+11]
    cmp       r10,	rax
    jnz       L4325
    test      r10,	r10
    jnz       L4325
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    lea       rdx,	[rip+L10911]
    call      strcat
L4325:
    mov       al,	[rdi]
    test      al,	al
    jz        L4327
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    mov       rdx,	rdi
    call      strcat
L4327:
    mov       rcx,	rsi
    call      mc_writegas.strvalue
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4321
L4322:
    movsxd    rax,	dword ptr[rsi+12]
    mov       rbx,	rax
    test      rax,	rax
    jz        L4328
    lea       rcx,	[rbp + mc_writegas.mstropnd.str2]
    call      msys.m$print_startstr
    mov       rcx,	rbx
    lea       rdx,	[rip+L10912]
    call      msys.m$print_i64
    call      msys.m$print_end
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    lea       rdx,	[rbp + mc_writegas.mstropnd.str2]
    call      strcat
L4328:
L4321:
    lea       rcx,	[rip+mc_writegas.mstropnd.str]
    lea       rdx,	[rip+L10913]
    call      strcat
    jmp       L4305
L4309:
    movzx     rax,	word ptr[rsi+8]
    and       rax,	31
    movzx     r10,	byte ptr[rsi+10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writegas.strxreg
    jmp       L4304
L4310:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10914]
    call      msys.m$print_str_nf
    movzx     rax,	word ptr[rsi+8]
    shr       rax,	9
    and       rax,	7
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[rip+L10915]
    jmp       L4304
L4305:
    lea       rax,	[rip+mc_writegas.mstropnd.str]
L4304:
#---------------
    add       rsp,	168
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writegas.strvalue
mc_writegas.strvalue:
#PROC1
#PROC2
#?>>
    .set mc_writegas.strvalue.str2, -128
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	160
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	[r12]
    mov       rbx,	[r12]
    lea       rcx,	[rip+mc_writegas.strvalue.str]
    lea       rdx,	[rip+L10916]
    call      strcpy
    movzx     rax,	word ptr[r12+8]
    shr       rax,	12
    and       rax,	15
    cmp       rax,	5
    jz        L4331
    cmp       rax,	1
    jz        L4332
    cmp       rax,	2
    jz        L4333
    cmp       rax,	3
    jz        L4334
    cmp       rax,	4
    jz        L4335
    cmp       rax,	7
    jz        L4336
    cmp       rax,	6
    jz        L4337
    cmp       rax,	8
    jz        L4338
    jmp       L4339
L4331:
    mov       rcx,	rdi
    call      mc_writegas.getdispname
    lea       rcx,	[rip+mc_writegas.strvalue.str]
    mov       rdx,	rax
    call      strcat
#mc_writegas.strvalue.addoffset:
L4340:
    movsxd    rax,	dword ptr[r12+12]
    mov       rsi,	rax
    test      rax,	rax
    jz        L4342
    lea       rcx,	[rbp + mc_writegas.strvalue.str2]
    call      msys.m$print_startstr
    cmp       rsi,	0
    jle       L4344
    lea       rax,	[rip+L10917]
    jmp       L4343
L4344:
    lea       rax,	[rip+L10918]
L4343:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rip+mc_writegas.strvalue.str]
    lea       rdx,	[rbp + mc_writegas.strvalue.str2]
    call      strcat
L4342:
    jmp       L4330
L4332:
    mov       rcx,	rbx
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rip+mc_writegas.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4330
L4333:
    lea       rcx,	[rip+mc_writegas.strvalue.str]
    call      msys.m$print_startstr
    movq      XMM4,	[r12]
    movq      XMM0,	XMM4
    lea       rdx,	[rip+L10919]
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L4330
L4334:
    lea       rcx,	[rip+mc_writegas.strvalue.str]
    lea       rdx,	[rip+L10920]
    call      strcat
    movq      XMM4,	[r12]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.strreal
    lea       rcx,	[rip+mc_writegas.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4330
L4335:
    lea       rcx,	[rip+mc_writegas.strvalue.str]
    lea       rdx,	[rip+L10921]
    call      strcat
    mov       rax,	[r12]
    lea       rcx,	[rip+mc_writegas.strvalue.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rip+mc_writegas.strvalue.str]
    lea       rdx,	[rip+L10921]
    call      strcat
    jmp       L4330
L4336:
    mov       rax,	[r12]
    lea       rcx,	[rip+mc_writegas.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4330
L4337:
    lea       rcx,	[rip+mc_writegas.strvalue.str]
    lea       rdx,	[rip+L10922]
    call      strcat
    mov       rax,	[r12]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rip+mc_writegas.strvalue.str]
    mov       rdx,	rax
    call      strcat
    jmp       L4340
L4338:
    mov       rax,	[r12]
    mov       rcx,	[rip+mc_decls.currasmproc]
    mov       rdx,	rax
    call      mc_writegas.gettempname
    jmp       L4329
L4339:
    lea       rcx,	[rip+L10923]
    lea       rdx,	[rip+L10924]
    call      pc_api.merror
L4330:
    lea       rax,	[rip+mc_writegas.strvalue.str]
L4329:
#---------------
    add       rsp,	160
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writegas.asmopnd
mc_writegas.asmopnd:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    call      mc_writegas.mstropnd
    mov       rcx,	rax
    call      mc_writegas.asmstr
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writegas.getxregname
mc_writegas.getxregname:
#PROC1
#PROC2
#?>>
    .set mc_writegas.getxregname.size, 32
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    test      rdi,	rdi
    jnz       L4348
    lea       rax,	[rip+L10925]
    jmp       L4346
L4348:
    lea       rcx,	[rip+mc_writegas.getxregname.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10926]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rax,	[rdi-1]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rax,	[rip+mc_writegas.getxregname.str]
L4346:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_writegas.asmstr
mc_writegas.asmstr:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+pc_decls.pdest]
    mov       rdx,	rdi
    call      mlib.gs_str
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_writegas.asmchar
mc_writegas.asmchar:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+pc_decls.pdest]
    mov       rdx,	rdi
    call      mlib.gs_char
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_writegas.getdispname
mc_writegas.getdispname:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    xor       edx,	edx
    call      pc_api.getfullname
L4351:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_writegas.gettempname
mc_writegas.gettempname:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       al,	[rip+pc_api.fpshortnames]
    test      al,	al
    jz        L4354
    lea       rcx,	[rip+mc_writegas.gettempname.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10927]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L4353
L4354:
    lea       rcx,	[rip+mc_writegas.gettempname.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L10928]
    call      msys.m$print_setfmt
    mov       rcx,	rdi
    call      mc_writegas.getdispname
    mov       rcx,	rax
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L4353:
    lea       rax,	[rip+mc_writegas.gettempname.str]
L4352:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writegas.strreg
mc_writegas.strreg:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_writegas.nregnames]
    mov       r10,	rdx
    shl       r10,	7
    lea       rax,	[rax + r10-128]
    mov       r10,	rcx
    mov       rax,	[rax + r10*8-8]
L4355:
#---------------
    ret       
# End 
# Proc mc_writegas.strxreg
mc_writegas.strxreg:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	1
    call      mc_writegas.checkregvar
    mov       rdi,	rax
    cmp       rsi,	8
    jnz       L4358
    test      rdi,	rdi
    jz        L4358
    mov       rcx,	rdi
    call      mc_writegas.getdispname
    jmp       L4357
L4358:
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      mc_writegas.getxregname
L4357:
L4356:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writegas.needsizeprefix
mc_writegas.needsizeprefix:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	rcx
    cmp       rax,	18
    jz        L4361
    cmp       rax,	19
    jz        L4361
    cmp       rax,	86
    jz        L4361
    cmp       rax,	87
    jz        L4361
    cmp       rax,	82
    jz        L4362
    cmp       rax,	83
    jz        L4362
    cmp       rax,	84
    jz        L4362
    cmp       rax,	85
    jz        L4362
    cmp       rax,	43
    jz        L4363
    cmp       rax,	45
    jz        L4363
    cmp       rax,	44
    jz        L4363
    jmp       L4364
L4361:
    mov       rax,	1
    jmp       L4359
L4362:
    mov       rax,	1
    jmp       L4359
L4363:
    movzx     rax,	word ptr[rdx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	3
    jnz       L4366
    mov       rax,	1
    jmp       L4359
L4366:
    xor       eax,	eax
    jmp       L4359
L4364:
L4360:
    movzx     rax,	word ptr[rdx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4369
    movzx     rax,	word ptr[rdx+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jz        L4369
    movzx     rax,	word ptr[r8+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	1
    jz        L4369
    movzx     rax,	word ptr[r8+8]
    shr       rax,	9
    and       rax,	7
    cmp       rax,	5
    jnz       L4368
L4369:
    xor       eax,	eax
    jmp       L4359
L4368:
    mov       rax,	1
L4359:
#---------------
    ret       
# End 
# Proc mc_writegas.getsizeprefix
mc_writegas.getsizeprefix:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    test      rdx,	rdx
    jnz       L4372
    lea       rax,	[rip+L10929]
    jmp       L4370
L4372:
    mov       rax,	rcx
    cmp       rax,	1
    jz        L4374
    cmp       rax,	2
    jz        L4375
    cmp       rax,	4
    jz        L4376
    cmp       rax,	8
    jz        L4377
    jmp       L4378
L4374:
    lea       rax,	[rip+L10930]
    jmp       L4370
L4375:
    lea       rax,	[rip+L10931]
    jmp       L4370
L4376:
    lea       rax,	[rip+L10932]
    jmp       L4370
L4377:
    lea       rax,	[rip+L10933]
    jmp       L4370
L4378:
L4373:
    lea       rax,	[rip+L10934]
L4370:
#---------------
    ret       
# End 
# Proc mc_writegas.checkregvar
mc_writegas.checkregvar:
#PROC1
#PROC2
#?>>
    .set mc_writegas.checkregvar.reg, 16
    .set mc_writegas.checkregvar.ispfloat, 24
#?]]
#---------------
#PROC3
#PROC4
    xor       eax,	eax
L4379:
#---------------
    ret       
# End 
# Proc mc_writeexe.writeexe
mc_writeexe.writeexe:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    mov       al,	[rip+pc_decls.exedone]
    test      al,	al
    jnz       L4380
L4382:
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	rbx
    call      mc_writeexe.genexe1
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      mc_writeexe.genexe2
    mov       al,	1
    mov       [rip+pc_decls.exedone],	al
L4380:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.genexe1
mc_writeexe.genexe1:
#PROC1
#PROC2
#?>>
    .set mc_writeexe.genexe1.dodll, 80
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
#---------------
#PROC3
#PROC4
    call      mc_writeexe.initsectiontable
    mov       rcx,	r14
    call      mlib.extractfile
    mov       [rip+mc_writeexe.dllfilename],	rax
    mov       rax,	[rbp + mc_writeexe.genexe1.dodll]
    mov       [rip+mc_writeexe.isdll],	rax
    mov       rax,	[rip+mc_writeexe.isdll]
    test      rax,	rax
    jz        L4385
    mov       rax,	268435456
    jmp       L4384
L4385:
    mov       rax,	4194304
L4384:
    mov       [rip+mc_writeexe.imagebase],	rax
    mov       [rip+mc_writeexe.userentrypoint],	r13
    call      mc_writeexe.loadlibs
    call      mc_writeexe.scanst
    call      mc_writeexe.getoffsets
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       rcx,	rax
    call      mc_writeexe.relocdata
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rcx,	rax
    call      mc_writeexe.relocdata
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       rax,	[rax]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rbx,	rax
    mov       al,	[rip+pc_api.phighmem]
    test      al,	al
    jz        L4387
    mov       r12,	[rip+mc_decls.riplist]
    jmp       L4391
L4388:
    mov       eax,	[r12+8]
    lea       r10,	[rbx + rax]
    mov       rsi,	r10
    movsxd    rax,	dword ptr[r12+12]
    mov       r10d,	[rsi]
    sub       r10,	[rip+mc_writeexe.imagebase]
    mov       r11d,	[r12+8]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      mc_writeexe.getripoffset
    mov       rdi,	rax
    mov       [rsi],	edi
    mov       r12,	[r12]
L4391:
    test      r12,	r12
    jnz       L4388
L4387:
#---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.genexe2
mc_writeexe.genexe2:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      mlib.extractfile
    mov       [rip+mc_writeexe.dllfilename],	rax
    mov       [rip+mc_writeexe.isdll],	rsi
    mov       rcx,	[rip+mc_writeexe.filesize]
    call      mlib.pcm_allocz
    mov       [rip+mc_writeexe.dataptr],	rax
    mov       [rip+mc_writeexe.datastart],	rax
    call      mc_writeexe.writedosstub
    call      mc_writeexe.writepesig
    call      mc_writeexe.writefileheader
    call      mc_writeexe.writeoptheader
    mov       rdi,	1
    mov       rax,	[rip+mc_writeexe.nsections]
    cmp       rax,	1
    jl        L4395
L4393:
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	rdi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rcx,	rax
    call      mc_writeexe.writesectionheader
    inc       rdi
    cmp       rdi,	[rip+mc_writeexe.nsections]
    jle       L4393
L4395:
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       rcx,	[rax+32]
    call      mc_writeexe.writepadding
    mov       rdi,	1
    mov       rax,	[rip+mc_writeexe.nsections]
    cmp       rax,	1
    jl        L4398
L4396:
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	rdi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rcx,	rax
    call      mc_writeexe.writesectiondata
    inc       rdi
    cmp       rdi,	[rip+mc_writeexe.nsections]
    jle       L4396
L4398:
    movzx     rax,	byte ptr[rip+pc_decls.pverbose]
    cmp       rax,	2
    jnz       L4400
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10935]
    call      msys.m$print_str_nf
    mov       rax,	[rip+mc_writeexe.dataptr]
    sub       rax,	[rip+mc_writeexe.datastart]
    mov       rcx,	rax
    lea       rdx,	[rip+L10936]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
L4400:
    mov       rax,	[rip+mc_writeexe.dataptr]
    sub       rax,	[rip+mc_writeexe.datastart]
    mov       rcx,	rbx
    mov       rdx,	[rip+mc_writeexe.datastart]
    mov       r8,	rax
    call      mlib.writefile
    test      rax,	rax
    jnz       L4402
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10937]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L4402:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.loadlibs
mc_writeexe.loadlibs:
#PROC1
#PROC2
#?>>
    .set mc_writeexe.loadlibs.filename, -304
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	336
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4406
L4404:
    lea       rax,	[rip+pc_decls.plibfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	36
    jz        L4408
    lea       rax,	[rip+pc_decls.plibfiles]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    call      mwindows.os_getdllinst
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L4410
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10938]
    call      msys.m$print_str_nf
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10939]
    call      mc_libmcl.axerror
L4410:
    mov       rax,	rbx
    lea       r10,	[rip+mc_writeexe.libinsttable]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    lea       rcx,	[rbp + mc_writeexe.loadlibs.filename]
    call      mlib.pcm_copyheapstring
    lea       r10,	[rip+mc_writeexe.libinstnames]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
L4408:
    inc       rdi
    cmp       rdi,	[rip+pc_decls.nplibfiles]
    jle       L4404
L4406:
#---------------
    add       rsp,	336
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.initsectiontable
mc_writeexe.initsectiontable:
#PROC1
#PROC2
#?>>
    .set mc_writeexe.initsectiontable.$T2, -8
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       r10,	[rip+L10940]
    mov       [rax+8],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	1
    mov       [rax+16],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	[rip+mc_decls.ss_code]
    mov       [rax],	r10
    mov       rcx,	[rip+mc_decls.ss_code]
    call      mc_genss.bufferlength
    lea       r10,	[rip+mc_writeexe.sectiontable]
    mov       [r10+40],	rax
    mov       al,	[rip+pc_decls.pverbose]
    test      al,	al
    jz        L4413
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10941]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       rcx,	rax
    lea       rdx,	[rip+L10942]
    call      msys.m$print_i64
    lea       rcx,	[rip+L10943]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    movzx     rax,	byte ptr[rip+pc_decls.pverbose]
    cmp       rax,	2
    jnz       L4415
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10944]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       rcx,	rax
    lea       rdx,	[rip+L10945]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10946]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeexe.initsectiontable.$T2],	rax
    mov       rcx,	[rip+mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       r10,	[rbp + mc_writeexe.initsectiontable.$T2]
    add       r10,	rax
    mov       rcx,	r10
    lea       rdx,	[rip+L10947]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10948]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+mc_decls.ss_zdatalen]
    lea       rdx,	[rip+L10949]
    call      msys.m$print_i64
    call      msys.m$print_newline
    call      msys.m$print_end
L4415:
L4413:
    mov       rcx,	[rip+mc_decls.ss_idata]
    call      mc_genss.bufferlength
    test      rax,	rax
    jnz       L4417
    mov       rcx,	[rip+mc_decls.ss_idata]
    xor       edx,	edx
    call      mc_genss.addqword
L4417:
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    lea       r10,	[rip+L10950]
    mov       [rax+8],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	2
    mov       [rax+16],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	[rip+mc_decls.ss_idata]
    mov       [rax],	r10
    mov       rcx,	[rip+mc_decls.ss_idata]
    call      mc_genss.bufferlength
    lea       r10,	[rip+mc_writeexe.sectiontable]
    lea       r10,	[r10+72]
    mov       [r10+40],	rax
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rax,	[rax+40]
    mov       rcx,	rax
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[rip+mc_writeexe.sectiontable]
    lea       r10,	[r10+72]
    mov       [r10+24],	rax
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	[rip+mc_decls.ss_nidatarelocs]
    mov       [rax+64],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       r10,	[rip+mc_decls.ss_idatarelocs]
    mov       [rax+56],	r10
    mov       rax,	[rip+mc_decls.ss_zdatalen]
    test      rax,	rax
    jnz       L4419
    mov       rax,	16
    mov       [rip+mc_decls.ss_zdatalen],	rax
L4419:
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    lea       r10,	[rip+L10951]
    mov       [rax+8],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       r10,	3
    mov       [rax+16],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       r10,	[rip+mc_decls.ss_zdatalen]
    mov       [rax+40],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       rax,	[rax+40]
    mov       rcx,	rax
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[rip+mc_writeexe.sectiontable]
    mov       [r10+24],	rax
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	[rip+mc_decls.ss_ncoderelocs]
    mov       [rax+64],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	[rip+mc_decls.ss_coderelocs]
    mov       [rax+56],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    lea       r10,	[rip+L10952]
    mov       [rax+8],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       r10,	5
    mov       [rax+16],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    xor       r10d,	r10d
    mov       [rax+40],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    xor       r10d,	r10d
    mov       [rax+24],	r10
    mov       rax,	4
    mov       [rip+mc_writeexe.nsections],	rax
#---------------
    add       rsp,	48
    pop       rbp
    ret       
# End 
# Proc mc_writeexe.extractlibname
mc_writeexe.extractlibname:
#PROC1
#PROC2
#?>>
    .set mc_writeexe.extractlibname.moduleno, 88
    .set mc_writeexe.extractlibname.str, -256
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       r13,	rcx
    mov       r14,	rdx
#---------------
#PROC3
#PROC4
    xor       rbx,	rbx
#mc_writeexe.extractlibname.reenter:
    mov       rdi,	r13
    xor       eax,	eax
    mov       [r14],	rax
    jmp       L4423
L4422:
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	46
    jnz       L4426
    mov       rax,	rdi
    sub       rax,	r13
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    mov       rdx,	r13
    mov       r8,	rax
    call      memcpy
    mov       rax,	rdi
    sub       rax,	r13
    xor       r10d,	r10d
    mov       [rbp + rax + mc_writeexe.extractlibname.str],	r10b
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    lea       rdx,	[rip+L10953]
    call      strcat
    mov       rsi,	1
    mov       rax,	[rip+mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4429
L4427:
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax]
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L4431
    mov       [r14],	rsi
    mov       rax,	[r14]
    lea       r10,	[rip+mc_writeexe.dlltable]
    mov       r11,	rax
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-40]
    inc       qword ptr[r10]
    test      rbx,	rbx
    jz        L4433
    mov       rax,	rbx
    jmp       L4432
L4433:
    lea       rax,	[rdi+1]
L4432:
    jmp       L4420
L4431:
    inc       rsi
    cmp       rsi,	[rip+mc_writeexe.ndlls]
    jle       L4427
L4429:
    mov       rax,	[rip+mc_writeexe.ndlls]
    cmp       rax,	50
    jl        L4435
    lea       rcx,	[rip+L10954]
    call      mc_libmcl.axerror
L4435:
    inc       qword ptr[rip+mc_writeexe.ndlls]
    mov       rax,	[rip+mc_writeexe.ndlls]
    mov       [r14],	rax
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    call      mlib.pcm_copyheapstring
    mov       r10,	[r14]
    lea       r11,	[rip+mc_writeexe.dlltable]
    mov       r15,	r10
    shl       r15,	4
    lea       r15,	[r15 + r15*2]
    lea       r11,	[r11 + r15-48]
    mov       [r11],	rax
    mov       rax,	[r14]
    lea       r10,	[rip+mc_writeexe.dlltable]
    mov       r11,	rax
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-48]
    mov       rax,	1
    mov       [r10+8],	rax
    test      rbx,	rbx
    jz        L4437
    mov       rax,	rbx
    jmp       L4436
L4437:
    lea       rax,	[rdi+1]
L4436:
    jmp       L4420
L4426:
    inc       rdi
L4423:
    mov       al,	[rdi]
    test      al,	al
    jnz       L4422
    mov       rsi,	1
    mov       rax,	[rip+pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4441
L4438:
    lea       rax,	[rip+mc_writeexe.libinsttable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    test      rax,	rax
    jz        L4443
    lea       rax,	[rip+mc_writeexe.libinsttable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	r13
    call      mwindows.os_getdllprocaddr
    test      rax,	rax
    jz        L4445
    mov       r12,	rsi
    jmp       L4440
L4445:
L4443:
    inc       rsi
    cmp       rsi,	[rip+pc_decls.nplibfiles]
    jle       L4438
L4441:
    call      msys.m$print_startcon
    mov       rcx,	r13
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10955]
    call      mc_libmcl.axerror
L4440:
    lea       rax,	[rip+mc_writeexe.libnotable]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    mov       [r14],	rax
    test      rax,	rax
    jz        L4447
    mov       rax,	[r14]
    lea       r10,	[rip+mc_writeexe.dlltable]
    mov       r11,	rax
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-40]
    inc       qword ptr[r10]
    mov       rax,	r13
    jmp       L4420
L4447:
    lea       rax,	[rip+pc_decls.plibfiles]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    lea       rdx,	[rip+L10956]
    call      strcat
    mov       rax,	[rip+mc_writeexe.ndlls]
    cmp       rax,	50
    jl        L4449
    lea       rcx,	[rip+L10957]
    call      mc_libmcl.axerror
L4449:
    inc       qword ptr[rip+mc_writeexe.ndlls]
    mov       rax,	[rip+mc_writeexe.ndlls]
    mov       [r14],	rax
    lea       rcx,	[rbp + mc_writeexe.extractlibname.str]
    call      mlib.pcm_copyheapstring
    mov       r10,	[r14]
    lea       r11,	[rip+mc_writeexe.dlltable]
    mov       r15,	r10
    shl       r15,	4
    lea       r15,	[r15 + r15*2]
    lea       r11,	[r11 + r15-48]
    mov       [r11],	rax
    mov       rax,	[r14]
    lea       r10,	[rip+mc_writeexe.dlltable]
    mov       r11,	rax
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-48]
    mov       rax,	1
    mov       [r10+8],	rax
    mov       rax,	[r14]
    lea       r10,	[rip+mc_writeexe.libnotable]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
    mov       rax,	r13
L4420:
#---------------
    add       rsp,	296
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.scanst
mc_writeexe.scanst:
#PROC1
#PROC2
#?>>
    .set mc_writeexe.scanst.libno, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4453
L4451:
    mov       rax,	[rip+mc_decls.ss_symboltable]
    mov       r10,	rdi
    mov       rbx,	[rax + r10*8-8]
    mov       al,	[rbx+80]
    test      al,	al
    jz        L4455
    mov       rax,	[rip+mc_writeexe.nimports]
    cmp       rax,	3000
    jl        L4457
    lea       rcx,	[rip+L10958]
    call      mc_libmcl.axerror
L4457:
    inc       qword ptr[rip+mc_writeexe.nimports]
    mov       rax,	[rbx]
    mov       rcx,	rax
    lea       rdx,	[rbp + mc_writeexe.scanst.libno]
    mov       r8,	1
    call      mc_writeexe.extractlibname
    mov       rsi,	rax
    lea       rax,	[rip+mc_writeexe.importtable]
    mov       r10,	[rip+mc_writeexe.nimports]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.scanst.libno]
    mov       [rax+8],	r10
    lea       rax,	[rip+mc_writeexe.importtable]
    mov       r10,	[rip+mc_writeexe.nimports]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	rsi
    mov       [rax+16],	r10
    lea       rax,	[rip+mc_writeexe.importtable]
    mov       r10,	[rip+mc_writeexe.nimports]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	rbx
    mov       [rax],	r10
    mov       ax,	[rip+mc_writeexe.nimports]
    mov       [rbx+98],	ax
    jmp       L4454
L4455:
    mov       al,	[rbx+81]
    test      al,	al
    jz        L4458
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       r12,	rax
    mov       rax,	[rip+mc_writeexe.userentrypoint]
    test      rax,	rax
    jz        L4460
    mov       rcx,	r12
    mov       rdx,	[rip+mc_writeexe.userentrypoint]
    call      mlib.eqstring
    test      rax,	rax
    jz        L4462
    mov       [rip+mc_writeexe.stentrypoint],	rbx
L4462:
    jmp       L4459
L4460:
    mov       al,	[rbx+83]
    test      al,	al
    jz        L4464
    mov       rax,	[rip+mc_writeexe.isdll]
    test      rax,	rax
    jnz       L4464
    mov       [rip+mc_writeexe.stentrypoint],	rbx
L4464:
L4459:
    mov       rax,	[rip+mc_writeexe.nexports]
    cmp       rax,	1000
    jl        L4466
    lea       rcx,	[rip+L10959]
    call      mc_libmcl.axerror
L4466:
    inc       qword ptr[rip+mc_writeexe.nexports]
    lea       rax,	[rip+mc_writeexe.exporttable]
    mov       r10,	[rip+mc_writeexe.nexports]
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    mov       r10,	rbx
    mov       [rax],	r10
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      pc_api.getbasename
    lea       r10,	[rip+mc_writeexe.exporttable]
    mov       r11,	[rip+mc_writeexe.nexports]
    shl       r11,	4
    lea       r10,	[r10 + r11-16]
    mov       [r10+8],	rax
L4458:
L4454:
    inc       rdi
    cmp       rdi,	[rip+mc_decls.ss_nsymbols]
    jle       L4451
L4453:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.relocdata
mc_writeexe.relocdata:
#PROC1
#PROC2
#?>>
    .set mc_writeexe.relocdata.s, 72
    .set mc_writeexe.relocdata.thunkoffset, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+72],	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + mc_writeexe.relocdata.s]
    mov       rax,	[rax]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rsi,	rax
    mov       rax,	[rbp + mc_writeexe.relocdata.s]
    mov       rbx,	[rax+56]
    jmp       L4469
L4468:
    mov       rax,	[rbx+24]
    mov       r10,	[rip+mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       r14,	r10
    movsx     rax,	word ptr[r14+98]
    mov       r15,	rax
    lea       rax,	[rip+mc_writeexe.importtable]
    mov       r10,	r15
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+40]
    mov       [rbp + mc_writeexe.relocdata.thunkoffset],	rax
    mov       rax,	[rbx+8]
    cmp       rax,	4
    jz        L4472
    cmp       rax,	2
    jz        L4473
    cmp       rax,	1
    jz        L4473
    jmp       L4474
L4472:
    mov       al,	[r14+80]
    test      al,	al
    jnz       L4476
    lea       rcx,	[rip+L10960]
    call      mc_libmcl.axerror
L4476:
    mov       rax,	[rbx+16]
    mov       r10,	[rbp + mc_writeexe.relocdata.thunkoffset]
    sub       r10,	rax
    sub       r10,	4
    mov       rax,	[rbx+16]
    mov       [rsi + rax],	r10d
    jmp       L4471
L4473:
    mov       al,	[r14+80]
    test      al,	al
    jz        L4478
    mov       rax,	[rip+mc_writeexe.imagebase]
    add       rax,	[rbp + mc_writeexe.relocdata.thunkoffset]
    lea       r10,	[rip+mc_writeexe.sectiontable]
    mov       r10,	[r10+48]
    add       rax,	r10
    mov       r10,	[rbx+16]
    mov       [rsi + r10],	eax
    jmp       L4477
L4478:
    xor       rdi,	rdi
    movzx     rax,	byte ptr[r14+94]
    cmp       rax,	3
    jz        L4480
    cmp       rax,	2
    jz        L4481
    cmp       rax,	1
    jz        L4482
    jmp       L4483
L4480:
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       rdi,	rax
    jmp       L4479
L4481:
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rdi,	rax
    jmp       L4479
L4482:
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       rdi,	rax
    jmp       L4479
L4483:
    call      msys.m$print_startcon
    mov       rcx,	[r14]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[r14+94]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10961]
    call      mc_libmcl.axerror
L4479:
    mov       rax,	[rbx+16]
    lea       r10,	[rsi + rax]
    mov       r12,	r10
    mov       rax,	[rbx+8]
    cmp       rax,	2
    jnz       L4485
    mov       eax,	[r12]
    mov       r10,	[rdi+48]
    add       rax,	r10
    add       rax,	[rip+mc_writeexe.imagebase]
    mov       [r12],	eax
    jmp       L4484
L4485:
    mov       r13,	r12
    mov       rax,	[r13]
    mov       r10,	[rdi+48]
    add       rax,	r10
    add       rax,	[rip+mc_writeexe.imagebase]
    mov       [r13],	rax
L4484:
L4477:
    jmp       L4471
L4474:
    call      msys.m$print_startcon
    mov       rax,	[rbx+8]
    lea       r10,	[rip+mc_objdecls.relocnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10962]
    call      mc_libmcl.axerror
L4471:
    mov       rbx,	[rbx]
L4469:
    test      rbx,	rbx
    jnz       L4468
#---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.getbaserelocs
mc_writeexe.getbaserelocs:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[r12]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rbx,	rax
    mov       rdi,	[r12+56]
    jmp       L4488
L4487:
    mov       rax,	[rdi+24]
    mov       r10,	[rip+mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rsi,	r10
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jz        L4491
    cmp       rax,	1
    jnz       L4492
L4491:
    mov       al,	[rsi+80]
    test      al,	al
    jnz       L4493
L4494:
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jz        L4495
L4496:
    mov       rax,	[rdi+8]
    mov       r10,	[r12+48]
    mov       r11,	[rdi+16]
    add       r10,	r11
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writeexe.newbasereloc
L4495:
L4493:
L4492:
L4490:
    mov       rdi,	[rdi]
L4488:
    test      rdi,	rdi
    jnz       L4487
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.writerecordx
mc_writeexe.writerecordx:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_writeexe.dataptr]
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	rbx
    add       [rip+mc_writeexe.dataptr],	rax
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.writedosstub
mc_writeexe.writedosstub:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+mc_writeexe.writedosstub.stubdata]
    mov       rdx,	128
    call      mc_writeexe.writerecordx
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mc_writeexe.writepesig
mc_writeexe.writepesig:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_writeexe.dataptr]
    inc       qword ptr[rip+mc_writeexe.dataptr]
    mov       r10b,	80
    mov       [rax],	r10b
    mov       rax,	[rip+mc_writeexe.dataptr]
    inc       qword ptr[rip+mc_writeexe.dataptr]
    mov       r10b,	69
    mov       [rax],	r10b
    mov       rax,	[rip+mc_writeexe.dataptr]
    inc       qword ptr[rip+mc_writeexe.dataptr]
    xor       r10d,	r10d
    mov       [rax],	r10b
    mov       rax,	[rip+mc_writeexe.dataptr]
    inc       qword ptr[rip+mc_writeexe.dataptr]
    xor       r10d,	r10d
    mov       [rax],	r10b
#---------------
    ret       
# End 
# Proc mc_writeexe.writepadding
mc_writeexe.writepadding:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_writeexe.datastart]
    mov       r10,	rcx
    lea       rax,	[rax + r10]
    mov       [rip+mc_writeexe.dataptr],	rax
#---------------
    ret       
# End 
# Proc mc_writeexe.writefileheader
mc_writeexe.writefileheader:
#PROC1
#PROC2
#?>>
    .set mc_writeexe.writefileheader.header, -24
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
#---------------
#PROC3
#PROC4
    lea       rax,	[rbp + mc_writeexe.writefileheader.header]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10d
    mov       ax,	34404
    mov       [rbp + mc_writeexe.writefileheader.header],	ax
    mov       ax,	[rip+mc_writeexe.nsections]
    mov       [rbp + mc_writeexe.writefileheader.header+2],	ax
    mov       ax,	240
    mov       [rbp + mc_writeexe.writefileheader.header+16],	ax
    mov       ax,	559
    mov       [rbp + mc_writeexe.writefileheader.header+18],	ax
    mov       rax,	[rip+mc_writeexe.isdll]
    test      rax,	rax
    jz        L4503
    mov       ax,	8750
    mov       [rbp + mc_writeexe.writefileheader.header+18],	ax
L4503:
    lea       rcx,	[rbp + mc_writeexe.writefileheader.header]
    mov       rdx,	20
    call      mc_writeexe.writerecordx
#---------------
    add       rsp,	64
    pop       rbp
    ret       
# End 
# Proc mc_writeexe.writeoptheader
mc_writeexe.writeoptheader:
#PROC1
#PROC2
#?>>
    .set mc_writeexe.writeoptheader.header, -240
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	272
#---------------
#PROC3
#PROC4
    lea       rax,	[rbp + mc_writeexe.writeoptheader.header]
    xor       r10d,	r10d
    mov       r11,	30
L10963:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L10963
    mov       ax,	523
    mov       [rbp + mc_writeexe.writeoptheader.header],	ax
    mov       al,	1
    mov       [rbp + mc_writeexe.writeoptheader.header+2],	al
    xor       eax,	eax
    mov       [rbp + mc_writeexe.writeoptheader.header+3],	al
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       rax,	[rax+24]
    mov       [rbp + mc_writeexe.writeoptheader.header+4],	eax
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rax,	[rax+24]
    lea       r10,	[rip+mc_writeexe.sectiontable]
    lea       r10,	[r10+216]
    mov       r10,	[r10+24]
    add       rax,	r10
    mov       [rbp + mc_writeexe.writeoptheader.header+8],	eax
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+144]
    mov       rax,	[rax+40]
    mov       rcx,	rax
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       [rbp + mc_writeexe.writeoptheader.header+12],	eax
    mov       rax,	[rip+mc_writeexe.stentrypoint]
    test      rax,	rax
    jnz       L4506
    mov       rax,	[rip+mc_writeexe.stentrypoint2]
    mov       [rip+mc_writeexe.stentrypoint],	rax
L4506:
    mov       rax,	[rip+mc_writeexe.stentrypoint]
    test      rax,	rax
    jnz       L4508
    mov       rax,	[rip+mc_writeexe.userentrypoint]
    test      rax,	rax
    jz        L4510
    call      msys.m$print_startcon
    mov       rcx,	[rip+mc_writeexe.userentrypoint]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L10964]
    call      mc_libmcl.axerror
    jmp       L4509
L4510:
    mov       rax,	[rip+mc_writeexe.isdll]
    test      rax,	rax
    jnz       L4512
    lea       rcx,	[rip+L10965]
    call      mc_libmcl.axerror
L4512:
L4509:
    jmp       L4507
L4508:
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       rax,	[rax+48]
    mov       r10,	[rip+mc_writeexe.stentrypoint]
    movsxd    r10,	dword ptr[r10+76]
    add       rax,	r10
    mov       [rbp + mc_writeexe.writeoptheader.header+16],	eax
L4507:
    mov       eax,	4096
    mov       [rbp + mc_writeexe.writeoptheader.header+20],	eax
    mov       rax,	[rip+mc_writeexe.imagebase]
    mov       [rbp + mc_writeexe.writeoptheader.header+24],	rax
    mov       eax,	4096
    mov       [rbp + mc_writeexe.writeoptheader.header+32],	eax
    mov       eax,	512
    mov       [rbp + mc_writeexe.writeoptheader.header+36],	eax
    mov       ax,	4
    mov       [rbp + mc_writeexe.writeoptheader.header+40],	ax
    xor       eax,	eax
    mov       [rbp + mc_writeexe.writeoptheader.header+42],	ax
    mov       ax,	5
    mov       [rbp + mc_writeexe.writeoptheader.header+48],	ax
    mov       ax,	2
    mov       [rbp + mc_writeexe.writeoptheader.header+50],	ax
    mov       eax,	[rip+mc_writeexe.imagesize]
    mov       [rbp + mc_writeexe.writeoptheader.header+56],	eax
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       rax,	[rax+32]
    mov       [rbp + mc_writeexe.writeoptheader.header+60],	eax
    mov       ax,	3
    mov       [rbp + mc_writeexe.writeoptheader.header+68],	ax
    mov       rax,	4194304
    mov       [rbp + mc_writeexe.writeoptheader.header+72],	rax
    mov       rax,	2097152
    mov       [rbp + mc_writeexe.writeoptheader.header+80],	rax
    mov       rax,	1048576
    mov       [rbp + mc_writeexe.writeoptheader.header+88],	rax
    mov       rax,	4096
    mov       [rbp + mc_writeexe.writeoptheader.header+96],	rax
    mov       eax,	16
    mov       [rbp + mc_writeexe.writeoptheader.header+108],	eax
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       rax,	[rax+48]
    mov       [rbp + mc_writeexe.writeoptheader.header+120],	eax
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       rax,	[rax+40]
    sub       rax,	[rip+mc_writeexe.exportdirvirtsize]
    sub       rax,	[rip+mc_writeexe.blockdirvirtsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+124],	eax
    mov       rax,	[rip+mc_writeexe.isdll]
    test      rax,	rax
    jz        L4514
    mov       ax,	64
    mov       [rbp + mc_writeexe.writeoptheader.header+70],	ax
    mov       eax,	[rip+mc_writeexe.exportdirvirtaddr]
    mov       [rbp + mc_writeexe.writeoptheader.header+112],	eax
    mov       eax,	[rip+mc_writeexe.exportdirvirtsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+116],	eax
    mov       eax,	[rip+mc_writeexe.blockdirvirtaddr]
    mov       [rbp + mc_writeexe.writeoptheader.header+152],	eax
    mov       eax,	[rip+mc_writeexe.blockdirvirtsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+156],	eax
L4514:
    mov       eax,	[rip+mc_writeexe.fileiatoffset]
    mov       [rbp + mc_writeexe.writeoptheader.header+208],	eax
    mov       eax,	[rip+mc_writeexe.fileiatsize]
    mov       [rbp + mc_writeexe.writeoptheader.header+212],	eax
    lea       rcx,	[rbp + mc_writeexe.writeoptheader.header]
    mov       rdx,	240
    call      mc_writeexe.writerecordx
#---------------
    add       rsp,	272
    pop       rbp
    ret       
# End 
# Proc mc_writeexe.writesectionheader
mc_writeexe.writesectionheader:
#PROC1
#PROC2
#?>>
    .set mc_writeexe.writesectionheader.sheader, -40
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rbp + mc_writeexe.writesectionheader.sheader]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    mov       rax,	[rbx+8]
    lea       r10,	[rbp + mc_writeexe.writesectionheader.sheader]
    mov       rcx,	r10
    mov       rdx,	rax
    call      strcpy
    mov       rax,	[rbx+40]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+8],	eax
    mov       rax,	[rbx+48]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+12],	eax
    mov       rax,	[rbx+32]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+20],	eax
    mov       rax,	[rbx+24]
    mov       [rbp + mc_writeexe.writesectionheader.sheader+16],	eax
    mov       rax,	[rbx+16]
    cmp       rax,	3
    jz        L4517
    cmp       rax,	2
    jz        L4518
    cmp       rax,	1
    jz        L4519
    cmp       rax,	5
    jz        L4520
    jmp       L4521
L4517:
    mov       rdi,	3226468480
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	edi
    jmp       L4516
L4518:
    mov       rdi,	3226468416
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	edi
    jmp       L4516
L4519:
    mov       rdi,	1615855648
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	edi
    jmp       L4516
L4520:
    mov       rdi,	3224371264
    mov       [rbp + mc_writeexe.writesectionheader.sheader+36],	edi
L4521:
L4516:
    lea       rcx,	[rbp + mc_writeexe.writesectionheader.sheader]
    mov       rdx,	40
    call      mc_writeexe.writerecordx
#---------------
    add       rsp,	80
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.writesectiondata
mc_writeexe.writesectiondata:
#PROC1
#PROC2
#?>>
    .set mc_writeexe.writesectiondata.$T1, -8
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rdi+16]
    cmp       rax,	5
    jz        L4524
    cmp       rax,	3
    jz        L4525
    jmp       L4526
L4524:
    mov       rax,	[rdi+40]
    mov       r10,	[rdi]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mc_writeexe.writerecordx
    mov       rax,	[rdi+24]
    mov       r10,	[rdi+40]
    cmp       rax,	r10
    jle       L4528
    mov       rax,	[rdi+24]
    mov       r10,	[rdi+40]
    sub       rax,	r10
    add       [rip+mc_writeexe.dataptr],	rax
L4528:
    jmp       L4523
L4525:
    jmp       L4523
L4526:
    mov       rax,	[rdi+24]
    mov       [rbp + mc_writeexe.writesectiondata.$T1],	rax
    mov       rax,	[rdi]
    mov       rcx,	rax
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_writeexe.writesectiondata.$T1]
    call      mc_writeexe.writerecordx
L4523:
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.writeexporttable
mc_writeexe.writeexporttable:
#PROC1
#PROC2
#?>>
    .set mc_writeexe.writeexporttable.pstart, 72
    .set mc_writeexe.writeexporttable.sortindex, -16000
    .set mc_writeexe.writeexporttable.nametableoffset, -16008
    .set mc_writeexe.writeexporttable.ordtableoffset, -16016
    .set mc_writeexe.writeexporttable.dllnameoffset, -16024
    .set mc_writeexe.writeexporttable.namesoffset, -16032
    .set mc_writeexe.writeexporttable.virtoffset, -16040
    .set mc_writeexe.writeexporttable.sectionno, -16048
    .set mc_writeexe.writeexporttable.d, -16056
    .set mc_writeexe.writeexporttable.basename, -16064
    .set mc_writeexe.writeexporttable.i, -16072
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16104
    mov       [rbp+72],	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       eax,	1602876664
    mov       [rdi+4],	eax
    mov       eax,	1
    mov       [rdi+16],	eax
    mov       eax,	[rip+mc_writeexe.nexports]
    mov       [rdi+20],	eax
    mov       eax,	[rip+mc_writeexe.nexports]
    mov       [rdi+24],	eax
    mov       r15,	40
    mov       rax,	[rip+mc_writeexe.nexports]
    shl       rax,	2
    mov       r10,	r15
    add       r10,	rax
    mov       [rbp + mc_writeexe.writeexporttable.nametableoffset],	r10
    mov       rax,	[rip+mc_writeexe.nexports]
    shl       rax,	2
    mov       r10,	[rbp + mc_writeexe.writeexporttable.nametableoffset]
    add       r10,	rax
    mov       [rbp + mc_writeexe.writeexporttable.ordtableoffset],	r10
    mov       rax,	[rip+mc_writeexe.nexports]
    shl       rax,	1
    mov       r10,	[rbp + mc_writeexe.writeexporttable.ordtableoffset]
    add       r10,	rax
    mov       [rbp + mc_writeexe.writeexporttable.dllnameoffset],	r10
    mov       rcx,	[rip+mc_writeexe.dllfilename]
    call      strlen
    mov       r10,	[rbp + mc_writeexe.writeexporttable.dllnameoffset]
    add       r10,	rax
    inc       r10
    mov       [rbp + mc_writeexe.writeexporttable.namesoffset],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+216]
    mov       rax,	[rax+48]
    add       rax,	[rip+mc_writeexe.exportdiroffset]
    mov       [rbp + mc_writeexe.writeexporttable.virtoffset],	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	r15
    lea       rax,	[rax + r10]
    mov       rbx,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.nametableoffset]
    lea       rax,	[rax + r10]
    mov       rsi,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.ordtableoffset]
    lea       rax,	[rax + r10]
    mov       r12,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.dllnameoffset]
    lea       rax,	[rax + r10]
    mov       r13,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.pstart]
    mov       r10,	[rbp + mc_writeexe.writeexporttable.namesoffset]
    lea       rax,	[rax + r10]
    mov       r14,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.dllnameoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rdi+12],	eax
    mov       rax,	r15
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rdi+28],	eax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.nametableoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rdi+32],	eax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.ordtableoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rdi+36],	eax
    mov       rcx,	r13
    mov       rdx,	[rip+mc_writeexe.dllfilename]
    call      strcpy
    mov       rax,	[rip+mc_writeexe.nexports]
    cmp       rax,	2000
    jle       L4531
    lea       rcx,	[rip+L10966]
    call      mc_libmcl.axerror
L4531:
    lea       rcx,	[rbp + mc_writeexe.writeexporttable.sortindex]
    call      mc_writeexe.sortexports
    mov       rax,	1
    mov       [rbp + mc_writeexe.writeexporttable.i],	rax
    mov       rax,	[rip+mc_writeexe.nexports]
    cmp       rax,	1
    jl        L4534
L4532:
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    mov       rax,	[rbp + rax*8 + mc_writeexe.writeexporttable.sortindex-8]
    lea       r10,	[rip+mc_writeexe.exporttable]
    lea       r11,	[rax + rax]
    lea       r10,	[r10 + r11*8-16]
    mov       r10,	[r10]
    mov       [rbp + mc_writeexe.writeexporttable.d],	r10
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    mov       rax,	[rbp + rax*8 + mc_writeexe.writeexporttable.sortindex-8]
    lea       r10,	[rip+mc_writeexe.exporttable]
    lea       r11,	[rax + rax]
    lea       r10,	[r10 + r11*8-16]
    mov       r10,	[r10+8]
    mov       [rbp + mc_writeexe.writeexporttable.basename],	r10
    mov       rax,	[rbp + mc_writeexe.writeexporttable.d]
    movzx     rax,	byte ptr[rax+94]
    mov       rcx,	rax
    call      mc_writeexe.getsectionno
    mov       [rbp + mc_writeexe.writeexporttable.sectionno],	rax
    mov       rcx,	r14
    mov       rdx,	[rbp + mc_writeexe.writeexporttable.basename]
    call      strcpy
    mov       rax,	[rbp + mc_writeexe.writeexporttable.namesoffset]
    add       rax,	[rbp + mc_writeexe.writeexporttable.virtoffset]
    mov       [rsi],	eax
    add       rsi,	4
    mov       rcx,	[rbp + mc_writeexe.writeexporttable.basename]
    call      strlen
    inc       rax
    add       [rbp + mc_writeexe.writeexporttable.namesoffset],	rax
    mov       rcx,	[rbp + mc_writeexe.writeexporttable.basename]
    call      strlen
    inc       rax
    add       r14,	rax
    mov       rax,	[rbp + mc_writeexe.writeexporttable.d]
    movsxd    rax,	dword ptr[rax+76]
    lea       r10,	[rip+mc_writeexe.sectiontable]
    mov       r11,	[rbp + mc_writeexe.writeexporttable.sectionno]
    shl       r11,	3
    lea       r11,	[r11 + r11*8]
    lea       r10,	[r10 + r11-72]
    mov       r10,	[r10+48]
    add       rax,	r10
    mov       [rbx],	eax
    add       rbx,	4
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    dec       rax
    mov       [r12],	ax
    add       r12,	2
    mov       rax,	[rbp + mc_writeexe.writeexporttable.i]
    inc       rax
    mov       [rbp + mc_writeexe.writeexporttable.i],	rax
    cmp       rax,	[rip+mc_writeexe.nexports]
    jle       L4532
L4534:
#---------------
    add       rsp,	16104
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.getexporttablesize
mc_writeexe.getexporttablesize:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rdi,	40
    mov       rax,	[rip+mc_writeexe.nexports]
    shl       rax,	2
    add       rdi,	rax
    mov       rax,	[rip+mc_writeexe.nexports]
    shl       rax,	2
    add       rdi,	rax
    mov       rax,	[rip+mc_writeexe.nexports]
    shl       rax,	1
    add       rdi,	rax
    mov       rcx,	[rip+mc_writeexe.dllfilename]
    call      strlen
    inc       rax
    add       rdi,	rax
    mov       rbx,	1
    mov       rax,	[rip+mc_writeexe.nexports]
    cmp       rax,	1
    jl        L4538
L4536:
    lea       rax,	[rip+mc_writeexe.exporttable]
    mov       r10,	rbx
    shl       r10,	4
    lea       rax,	[rax + r10-16]
    mov       rax,	[rax]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      strlen
    inc       rax
    add       rdi,	rax
    inc       rbx
    cmp       rbx,	[rip+mc_writeexe.nexports]
    jle       L4536
L4538:
    mov       rax,	rdi
L4535:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.newbasereloc
mc_writeexe.newbasereloc:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	16
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       [rdi+8],	ebx
    mov       [rdi+12],	esi
    mov       rax,	[rip+mc_writeexe.basereloclist]
    mov       [rdi],	rax
    mov       [rip+mc_writeexe.basereloclist],	rdi
    inc       qword ptr[rip+mc_writeexe.nbaserelocs]
    mov       rax,	rbx
    cmp       [rip+mc_writeexe.maxrelocaddr],	rax
    jge       L10967
    mov       [rip+mc_writeexe.maxrelocaddr],	rax
L10967:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.scanbaserelocs
mc_writeexe.scanbaserelocs:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	4096
    xor       eax,	eax
    mov       [rip+mc_writeexe.nbaseblocks],	rax
L4541:
    lea       rax,	[rdi+4096]
    mov       rsi,	rax
    mov       rax,	[rip+mc_writeexe.nbaseblocks]
    cmp       rax,	500
    jl        L4545
    lea       rcx,	[rip+L10968]
    call      mc_libmcl.axerror
L4545:
    inc       qword ptr[rip+mc_writeexe.nbaseblocks]
    mov       rax,	rdi
    lea       r10,	[rip+mc_writeexe.blockbases]
    mov       r11,	[rip+mc_writeexe.nbaseblocks]
    mov       [r10 + r11*8-8],	rax
    xor       eax,	eax
    lea       r10,	[rip+mc_writeexe.blockcounts]
    mov       r11,	[rip+mc_writeexe.nbaseblocks]
    mov       [r10 + r11*4-4],	eax
    mov       r12,	[rip+mc_writeexe.basereloclist]
    jmp       L4547
L4546:
    mov       eax,	[r12+8]
    mov       rbx,	rax
    cmp       rbx,	rdi
    jl        L4550
    cmp       rbx,	rsi
    jge       L4550
    lea       rax,	[rip+mc_writeexe.blockcounts]
    mov       r10,	[rip+mc_writeexe.nbaseblocks]
    lea       rax,	[rax + r10*4-4]
    inc       dword ptr[rax]
L4550:
    mov       r12,	[r12]
L4547:
    test      r12,	r12
    jnz       L4546
    mov       rdi,	rsi
    cmp       rdi,	[rip+mc_writeexe.maxrelocaddr]
    jle       L4541
    mov       r13,	1
    mov       rax,	[rip+mc_writeexe.nbaseblocks]
    cmp       rax,	1
    jl        L4553
L4551:
    lea       rax,	[rip+mc_writeexe.blockcounts]
    mov       r10,	r13
    mov       eax,	[rax + r10*4-4]
    test      eax,	eax
    jz        L4555
    lea       rax,	[rip+mc_writeexe.blockcounts]
    mov       r10,	r13
    movsxd    rax,	dword ptr[rax + r10*4-4]
    and       eax,	1
    test      rax,	rax
    jz        L4557
    lea       rax,	[rip+mc_writeexe.blockcounts]
    mov       r10,	r13
    lea       rax,	[rax + r10*4-4]
    inc       dword ptr[rax]
    lea       rax,	[rip+mc_writeexe.blockpadding]
    mov       r10,	r13
    lea       rax,	[rax + r10-1]
    inc       byte ptr[rax]
L4557:
    lea       rax,	[rip+mc_writeexe.blockcounts]
    mov       r10,	r13
    movsxd    rax,	dword ptr[rax + r10*4-4]
    shl       rax,	1
    add       rax,	8
    lea       r10,	[rip+mc_writeexe.blockbytes]
    mov       r11,	r13
    mov       [r10 + r11*4-4],	eax
    lea       rax,	[rip+mc_writeexe.blockbytes]
    mov       r10,	r13
    movsxd    rax,	dword ptr[rax + r10*4-4]
    add       [rip+mc_writeexe.basetablesize],	rax
L4555:
    inc       r13
    cmp       r13,	[rip+mc_writeexe.nbaseblocks]
    jle       L4551
L4553:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.writebasereloctable
mc_writeexe.writebasereloctable:
#PROC1
#PROC2
#?>>
    .set mc_writeexe.writebasereloctable.$T1, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	8
#---------------
#PROC3
#PROC4
    mov       rdi,	rcx
    mov       r15,	1
    mov       rax,	[rip+mc_writeexe.nbaseblocks]
    cmp       rax,	1
    jl        L4561
L4559:
    lea       rax,	[rip+mc_writeexe.blockcounts]
    mov       r10,	r15
    mov       eax,	[rax + r10*4-4]
    test      eax,	eax
    jz        L4563
    lea       rax,	[rip+mc_writeexe.blockbases]
    mov       r10,	r15
    mov       rax,	[rax + r10*8-8]
    mov       [rdi],	eax
    add       rdi,	4
    lea       rax,	[rip+mc_writeexe.blockbytes]
    mov       r10,	r15
    mov       eax,	[rax + r10*4-4]
    mov       [rdi],	eax
    add       rdi,	4
    mov       rbx,	rdi
    mov       r14,	[rip+mc_writeexe.basereloclist]
    lea       rax,	[rip+mc_writeexe.blockbases]
    mov       r10,	r15
    mov       rsi,	[rax + r10*8-8]
    lea       rax,	[rsi+4096]
    mov       r13,	rax
    jmp       L4565
L4564:
    mov       eax,	[r14+8]
    mov       r12,	rax
    cmp       r12,	rsi
    jl        L4568
    cmp       r12,	r13
    jge       L4568
    mov       rax,	r12
    sub       rax,	rsi
    mov       [rbp + mc_writeexe.writebasereloctable.$T1],	rax
    movsxd    rax,	dword ptr[r14+12]
    cmp       rax,	2
    jnz       L4570
    mov       rax,	3
    jmp       L4569
L4570:
    mov       rax,	10
L4569:
    shl       rax,	12
    mov       r10,	[rbp + mc_writeexe.writebasereloctable.$T1]
    add       r10,	rax
    mov       [rbx],	r10w
    add       rbx,	2
L4568:
    mov       r14,	[r14]
L4565:
    test      r14,	r14
    jnz       L4564
    lea       rax,	[rip+mc_writeexe.blockpadding]
    mov       r10,	r15
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L4572
    mov       rax,	rbx
    add       rbx,	2
    xor       r10d,	r10d
    mov       [rax],	r10w
L4572:
    mov       rdi,	rbx
L4563:
    inc       r15
    cmp       r15,	[rip+mc_writeexe.nbaseblocks]
    jle       L4559
L4561:
#---------------
    add       rsp,	8
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.sortexports
mc_writeexe.sortexports:
#PROC1
#PROC2
#?>>
    .set mc_writeexe.sortexports.$T1, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r14,	rcx
#---------------
#PROC3
#PROC4
    mov       r13,	1
    mov       rax,	[rip+mc_writeexe.nexports]
    cmp       rax,	1
    jl        L4576
L4574:
    mov       [r14 + r13*8-8],	r13
    inc       r13
    cmp       r13,	[rip+mc_writeexe.nexports]
    jle       L4574
L4576:
L4577:
    xor       rsi,	rsi
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[rip+mc_writeexe.nexports]
    dec       rax
    mov       r12,	rax
    cmp       r12,	1
    jl        L4582
L4580:
    mov       rax,	[r14 + r13*8-8]
    lea       r10,	[rip+mc_writeexe.exporttable]
    lea       r11,	[rax + rax]
    lea       r10,	[r10 + r11*8-16]
    mov       r10,	[r10]
    mov       rdi,	r10
    mov       rax,	[r14 + r13*8]
    lea       r10,	[rip+mc_writeexe.exporttable]
    lea       r11,	[rax + rax]
    lea       r10,	[r10 + r11*8-16]
    mov       r10,	[r10]
    mov       rbx,	r10
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       [rbp + mc_writeexe.sortexports.$T1],	rax
    mov       rax,	[rdi]
    mov       rcx,	rax
    call      pc_api.getbasename
    mov       rcx,	rax
    mov       rdx,	[rbp + mc_writeexe.sortexports.$T1]
    call      strcmp
    movsxd    r10,	eax
    cmp       r10,	0
    jle       L4584
    mov       rsi,	1
    lea       rax,	[r14 + r13*8-8]
    lea       r10,	[r14 + r13*8]
    mov       r11,	[rax]
    mov       r9,	[r10]
    mov       [r10],	r11
    mov       [rax],	r9
L4584:
    inc       r13
    cmp       r13,	r12
    jle       L4580
L4582:
    test      rsi,	rsi
    jnz       L4577
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.getsectionno
mc_writeexe.getsectionno:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	rdi
    cmp       rax,	3
    jz        L4587
    cmp       rax,	2
    jz        L4588
    cmp       rax,	1
    jz        L4589
    jmp       L4590
L4587:
    mov       rax,	3
    jmp       L4586
L4588:
    mov       rax,	2
    jmp       L4586
L4589:
    mov       rax,	1
    jmp       L4586
L4590:
    lea       rcx,	[rip+L10969]
    call      mc_libmcl.axerror
    xor       eax,	eax
L4586:
L4585:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.getoffsets
mc_writeexe.getoffsets:
#PROC1
#PROC2
#?>>
    .set mc_writeexe.getoffsets.j, -8
    .set mc_writeexe.getoffsets.codesize, -16
    .set mc_writeexe.getoffsets.length, -24
    .set mc_writeexe.getoffsets.thunkoffset, -32
    .set mc_writeexe.getoffsets.offset, -40
    .set mc_writeexe.getoffsets.dirstartoffset, -48
    .set mc_writeexe.getoffsets.pcode, -56
    .set mc_writeexe.getoffsets.pimpdir, -64
    .set mc_writeexe.getoffsets.pdir, -72
    .set mc_writeexe.getoffsets.paddr, -80
    .set mc_writeexe.getoffsets.pname, -88
    .set mc_writeexe.getoffsets.iatoffset, -96
    .set mc_writeexe.getoffsets.phint, -104
    .set mc_writeexe.getoffsets.pextra, -112
    .set mc_writeexe.getoffsets.xxx, -120
    .set mc_writeexe.getoffsets.av_1, -128
    .set mc_writeexe.getoffsets.thunkptr, -136
    .set mc_writeexe.getoffsets.codebase, -144
    .set mc_writeexe.getoffsets.thunkaddr, -152
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	192
#---------------
#PROC3
#PROC4
    mov       rdi,	392
    mov       rax,	40
    mov       r10,	[rip+mc_writeexe.nsections]
    imul      rax,	r10
    add       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       rdi,	rax
    mov       rbx,	4096
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       rax,	[rax+40]
    mov       [rbp + mc_writeexe.getoffsets.codesize],	rax
    mov       rcx,	[rip+mc_decls.ss_code]
    mov       rdx,	[rbp + mc_writeexe.getoffsets.codesize]
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.getoffsets.pcode],	rax
    jmp       L4593
L4592:
    mov       rax,	[rbp + mc_writeexe.getoffsets.pcode]
    inc       qword ptr[rbp + mc_writeexe.getoffsets.pcode]
    mov       r10b,	144
    mov       [rax],	r10b
    inc       qword ptr[rbp + mc_writeexe.getoffsets.codesize]
L4593:
    mov       rax,	[rbp + mc_writeexe.getoffsets.codesize]
    and       rax,	7
    jnz       L4592
    mov       rax,	[rbp + mc_writeexe.getoffsets.codesize]
    mov       [rbp + mc_writeexe.getoffsets.thunkoffset],	rax
    mov       rax,	[rip+mc_writeexe.nimports]
    shl       rax,	3
    add       [rbp + mc_writeexe.getoffsets.codesize],	rax
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.codesize]
    mov       [rax+40],	r10
    mov       rcx,	[rbp + mc_writeexe.getoffsets.codesize]
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[rip+mc_writeexe.sectiontable]
    mov       [r10+24],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.codesize]
    sub       rax,	[rbp + mc_writeexe.getoffsets.thunkoffset]
    add       rax,	16
    mov       rcx,	[rip+mc_decls.ss_code]
    mov       rdx,	rax
    call      mc_genss.buffercheck
    mov       rsi,	1
    mov       rax,	[rip+mc_writeexe.nsections]
    cmp       rax,	1
    jl        L4597
L4595:
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+16]
    cmp       rax,	3
    jz        L4599
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	rdi
    mov       [rax+32],	r10
L4599:
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+16]
    cmp       rax,	3
    jz        L4601
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+40]
    mov       r10,	rdi
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       rdi,	rax
L4601:
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	rbx
    mov       [rax+48],	r10
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+16]
    cmp       rax,	5
    jnz       L4603
    mov       r12,	rbx
    mov       r13,	rsi
L4603:
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	rsi
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+40]
    mov       r10,	rbx
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	4096
    call      mlib.roundtoblock
    mov       rbx,	rax
    inc       rsi
    cmp       rsi,	[rip+mc_writeexe.nsections]
    jle       L4595
L4597:
    mov       rax,	[rip+mc_writeexe.isdll]
    test      rax,	rax
    jz        L4605
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       rcx,	rax
    call      mc_writeexe.getbaserelocs
    lea       rax,	[rip+mc_writeexe.sectiontable]
    lea       rax,	[rax+72]
    mov       rcx,	rax
    call      mc_writeexe.getbaserelocs
L4605:
    mov       rax,	[rip+mc_writeexe.ndlls]
    inc       rax
    shl       rax,	2
    lea       rax,	[rax + rax*4]
    add       r12,	rax
    mov       rsi,	1
    mov       rax,	[rip+mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4608
L4606:
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	r12
    mov       [rax+16],	r10
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+8]
    inc       rax
    shl       rax,	3
    add       r12,	rax
    inc       rsi
    cmp       rsi,	[rip+mc_writeexe.ndlls]
    jle       L4606
L4608:
    mov       [rip+mc_writeexe.fileiatoffset],	r12
    mov       rsi,	1
    mov       rax,	[rip+mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4611
L4609:
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	r12
    mov       [rax+24],	r10
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+8]
    inc       rax
    shl       rax,	3
    add       r12,	rax
    inc       rsi
    cmp       rsi,	[rip+mc_writeexe.ndlls]
    jle       L4609
L4611:
    mov       rax,	r12
    sub       rax,	[rip+mc_writeexe.fileiatoffset]
    mov       [rip+mc_writeexe.fileiatsize],	rax
    mov       r14,	r12
    mov       rsi,	1
    mov       rax,	[rip+mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4614
L4612:
    lea       rax,	[rip+mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+16]
    mov       rcx,	rax
    call      strlen
    add       rax,	3
    mov       [rbp + mc_writeexe.getoffsets.length],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    and       rax,	1
    jz        L4616
    inc       qword ptr[rbp + mc_writeexe.getoffsets.length]
L4616:
    lea       rax,	[rip+mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	r12
    mov       [rax+24],	r10
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    add       r12,	rax
    inc       rsi
    cmp       rsi,	[rip+mc_writeexe.nimports]
    jle       L4612
L4614:
    mov       rcx,	r12
    mov       rdx,	4
    call      mlib.roundtoblock
    mov       r12,	rax
    mov       rsi,	1
    mov       rax,	[rip+mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4619
L4617:
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      strlen
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.length],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    and       rax,	1
    jz        L4621
    inc       qword ptr[rbp + mc_writeexe.getoffsets.length]
L4621:
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	r12
    mov       [rax+40],	r10
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+8]
    shl       rax,	2
    add       r12,	rax
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       r10,	r12
    mov       [rax+32],	r10
    mov       rax,	[rbp + mc_writeexe.getoffsets.length]
    add       r12,	rax
    inc       rsi
    cmp       rsi,	[rip+mc_writeexe.ndlls]
    jle       L4617
L4619:
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	r13
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       rax,	[rax+48]
    mov       [rbp + mc_writeexe.getoffsets.dirstartoffset],	rax
    mov       rax,	[rip+mc_writeexe.isdll]
    test      rax,	rax
    jz        L4623
    mov       [rip+mc_writeexe.exportdirvirtaddr],	r12
    mov       rax,	r12
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [rip+mc_writeexe.exportdiroffset],	rax
    call      mc_writeexe.getexporttablesize
    mov       [rip+mc_writeexe.exportdirvirtsize],	rax
    mov       rax,	[rip+mc_writeexe.exportdirvirtsize]
    add       r12,	rax
    call      mc_writeexe.scanbaserelocs
    mov       [rip+mc_writeexe.blockdirvirtaddr],	r12
    mov       rax,	r12
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [rip+mc_writeexe.blockdiroffset],	rax
    mov       rax,	[rip+mc_writeexe.basetablesize]
    mov       [rip+mc_writeexe.blockdirvirtsize],	rax
    mov       rax,	[rip+mc_writeexe.blockdirvirtsize]
    add       r12,	rax
L4623:
    mov       rax,	r12
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [rbp + mc_writeexe.getoffsets.offset],	rax
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       r10,	r13
    shl       r10,	3
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10-72]
    mov       r10,	[rbp + mc_writeexe.getoffsets.offset]
    mov       [rax+40],	r10
    mov       rcx,	[rbp + mc_writeexe.getoffsets.offset]
    mov       rdx,	512
    call      mlib.roundtoblock
    lea       r10,	[rip+mc_writeexe.sectiontable]
    mov       r11,	r13
    shl       r11,	3
    lea       r11,	[r11 + r11*8]
    lea       r10,	[r10 + r11-72]
    mov       [r10+24],	rax
    mov       rax,	rdi
    add       rax,	[rbp + mc_writeexe.getoffsets.offset]
    mov       rcx,	rax
    mov       rdx,	512
    call      mlib.roundtoblock
    mov       [rip+mc_writeexe.filesize],	rax
    mov       rax,	r12
    sub       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       r10,	rbx
    add       r10,	rax
    mov       rcx,	r10
    mov       rdx,	4096
    call      mlib.roundtoblock
    mov       [rip+mc_writeexe.imagesize],	rax
    mov       rcx,	[rbp + mc_writeexe.getoffsets.offset]
    call      mlib.pcm_allocz
    lea       r10,	[rip+mc_writeexe.sectiontable]
    mov       r11,	r13
    shl       r11,	3
    lea       r11,	[r11 + r11*8]
    lea       r10,	[r10 + r11-72]
    mov       [r10],	rax
    mov       [rbp + mc_writeexe.getoffsets.pimpdir],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       [rbp + mc_writeexe.getoffsets.pdir],	rax
    mov       rsi,	1
    mov       rax,	[rip+mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4626
L4624:
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+16]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pdir]
    mov       [r10],	eax
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+24]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pdir]
    mov       [r10+16],	eax
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+32]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pdir]
    mov       [r10+12],	eax
    add       qword ptr[rbp + mc_writeexe.getoffsets.pdir],	20
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+24]
    mov       [rbp + mc_writeexe.getoffsets.iatoffset],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       r10,	[rbp + mc_writeexe.getoffsets.iatoffset]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       rax,	r10
    mov       [rbp + mc_writeexe.getoffsets.paddr],	rax
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+16]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.pname],	r10
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    mov       rax,	[rip+mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4629
L4627:
    lea       rax,	[rip+mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.j]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+8]
    cmp       rax,	rsi
    jnz       L4631
    lea       rax,	[rip+mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.j]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+24]
    mov       r10,	[rbp + mc_writeexe.getoffsets.paddr]
    mov       [r10],	rax
    mov       r10,	[rbp + mc_writeexe.getoffsets.pname]
    mov       [r10],	rax
    lea       rax,	[rip+mc_writeexe.importtable]
    mov       r10,	[rbp + mc_writeexe.getoffsets.j]
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       r10,	[rbp + mc_writeexe.getoffsets.iatoffset]
    mov       [rax+32],	r10
    mov       rax,	8
    add       [rbp + mc_writeexe.getoffsets.iatoffset],	rax
    add       qword ptr[rbp + mc_writeexe.getoffsets.pname],	8
    add       qword ptr[rbp + mc_writeexe.getoffsets.paddr],	8
L4631:
    mov       rax,	[rbp + mc_writeexe.getoffsets.j]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    cmp       rax,	[rip+mc_writeexe.nimports]
    jle       L4627
L4629:
    inc       rsi
    cmp       rsi,	[rip+mc_writeexe.ndlls]
    jle       L4624
L4626:
    mov       rsi,	1
    mov       rax,	[rip+mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4634
L4632:
    lea       rax,	[rip+mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+24]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.phint],	r10
    add       qword ptr[rbp + mc_writeexe.getoffsets.phint],	2
    lea       rax,	[rip+mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+16]
    mov       rcx,	[rbp + mc_writeexe.getoffsets.phint]
    mov       rdx,	rax
    call      strcpy
    inc       rsi
    cmp       rsi,	[rip+mc_writeexe.nimports]
    jle       L4632
L4634:
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    mov       [rbp + mc_writeexe.getoffsets.xxx],	rax
    mov       rsi,	1
    mov       rax,	[rip+mc_writeexe.ndlls]
    cmp       rax,	1
    jl        L4637
L4635:
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+40]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.pextra],	r10
    mov       rax,	1
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+8]
    mov       [rbp + mc_writeexe.getoffsets.av_1],	rax
    mov       rax,	[rbp + mc_writeexe.getoffsets.av_1]
    cmp       rax,	1
    jl        L4640
L4638:
    mov       eax,	[rbp + mc_writeexe.getoffsets.xxx]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pextra]
    mov       [r10],	eax
    add       qword ptr[rbp + mc_writeexe.getoffsets.pextra],	4
    mov       rax,	[rbp + mc_writeexe.getoffsets.j]
    inc       rax
    mov       [rbp + mc_writeexe.getoffsets.j],	rax
    cmp       rax,	[rbp + mc_writeexe.getoffsets.av_1]
    jle       L4638
L4640:
    mov       rax,	20
    add       [rbp + mc_writeexe.getoffsets.xxx],	rax
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax+32]
    mov       r10,	[rbp + mc_writeexe.getoffsets.pimpdir]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + mc_writeexe.getoffsets.dirstartoffset]
    sub       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.phint],	r10
    lea       rax,	[rip+mc_writeexe.dlltable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-48]
    mov       rax,	[rax]
    mov       rcx,	[rbp + mc_writeexe.getoffsets.phint]
    mov       rdx,	rax
    call      strcpy
    inc       rsi
    cmp       rsi,	[rip+mc_writeexe.ndlls]
    jle       L4635
L4637:
    mov       rax,	[rip+mc_writeexe.isdll]
    test      rax,	rax
    jz        L4642
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       r10,	[rip+mc_writeexe.exportdiroffset]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    call      mc_writeexe.writeexporttable
    mov       rax,	[rbp + mc_writeexe.getoffsets.pimpdir]
    mov       r10,	[rip+mc_writeexe.blockdiroffset]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    call      mc_writeexe.writebasereloctable
L4642:
    mov       rcx,	[rip+mc_decls.ss_code]
    mov       rdx,	[rbp + mc_writeexe.getoffsets.thunkoffset]
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.getoffsets.thunkptr],	rax
    mov       rcx,	[rip+mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mc_writeexe.getoffsets.codebase],	rax
    mov       rsi,	1
    mov       rax,	[rip+mc_writeexe.nimports]
    cmp       rax,	1
    jl        L4645
L4643:
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    sub       rax,	[rbp + mc_writeexe.getoffsets.codebase]
    lea       r10,	[rip+mc_writeexe.importtable]
    mov       r11,	rsi
    shl       r11,	4
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11]
    mov       [r10+40],	rax
    movzx     rax,	byte ptr[rip+pc_api.phighmem]
    test      rax,	rax
    jnz       L4647
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	72
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	255
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	36
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	37
    mov       [rax],	r10b
    lea       rax,	[rip+mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+32]
    mov       r10,	[rip+mc_writeexe.imagebase]
    add       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.thunkaddr],	r10
    mov       eax,	[rbp + mc_writeexe.getoffsets.thunkaddr]
    mov       r10,	[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       [r10],	eax
    add       qword ptr[rbp + mc_writeexe.getoffsets.thunkptr],	4
    jmp       L4646
L4647:
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	72
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	255
    mov       [rax],	r10b
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	37
    mov       [rax],	r10b
    lea       rax,	[rip+mc_writeexe.importtable]
    mov       r10,	rsi
    shl       r10,	4
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10]
    mov       rax,	[rax+32]
    mov       r10,	[rip+mc_writeexe.imagebase]
    add       r10,	rax
    mov       [rbp + mc_writeexe.getoffsets.thunkaddr],	r10
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkaddr]
    sub       rax,	[rip+mc_writeexe.imagebase]
    mov       r10,	[rbp + mc_writeexe.getoffsets.thunkptr]
    sub       r10,	[rbp + mc_writeexe.getoffsets.codebase]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      mc_writeexe.getripoffset
    mov       r10,	[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       [r10],	eax
    add       qword ptr[rbp + mc_writeexe.getoffsets.thunkptr],	4
    mov       rax,	[rbp + mc_writeexe.getoffsets.thunkptr]
    inc       qword ptr[rbp + mc_writeexe.getoffsets.thunkptr]
    mov       r10b,	144
    mov       [rax],	r10b
L4646:
    inc       rsi
    cmp       rsi,	[rip+mc_writeexe.nimports]
    jle       L4643
L4645:
#---------------
    add       rsp,	192
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeexe.getripoffset
mc_writeexe.getripoffset:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_writeexe.sectiontable]
    mov       rax,	[rax+48]
    add       rcx,	rax
    lea       rax,	[rcx+4]
    mov       r10,	rdx
    sub       r10,	rax
    sub       r10,	r8
    mov       rax,	r10
L4648:
#---------------
    ret       
# End 
# Proc mc_writeobj.writecoff
mc_writeobj.writecoff:
#PROC1
#PROC2
#?>>
    .set mc_writeobj.writecoff.header, -24
    .set mc_writeobj.writecoff.zsection, -64
    .set mc_writeobj.writecoff.isection, -104
    .set mc_writeobj.writecoff.csection, -144
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	176
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       al,	[rip+pc_decls.objdone]
    test      al,	al
    jnz       L4649
L4651:
    lea       rax,	[rbp + mc_writeobj.writecoff.header]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10d
    lea       rax,	[rbp + mc_writeobj.writecoff.zsection]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    lea       rax,	[rbp + mc_writeobj.writecoff.isection]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    lea       rax,	[rbp + mc_writeobj.writecoff.csection]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    mov       [rax+32],	r10
    mov       ax,	34404
    mov       [rbp + mc_writeobj.writecoff.header],	ax
    mov       ax,	3
    mov       [rbp + mc_writeobj.writecoff.header+2],	ax
    lea       rax,	[rbp + mc_writeobj.writecoff.zsection]
    mov       rcx,	rax
    lea       rdx,	[rip+L10970]
    call      strcpy
    mov       eax,	[rip+mc_decls.ss_zdatalen]
    mov       [rbp + mc_writeobj.writecoff.zsection+16],	eax
    mov       eax,	3225419904
    mov       [rbp + mc_writeobj.writecoff.zsection+36],	eax
    mov       rax,	[rip+mc_decls.ss_nidatarelocs]
    cmp       rax,	65536
    jge       L4654
    mov       rax,	[rip+mc_decls.ss_ncoderelocs]
    cmp       rax,	65536
    jl        L4653
L4654:
    lea       rcx,	[rip+L10971]
    call      mc_libmcl.axerror
L4653:
    lea       rax,	[rbp + mc_writeobj.writecoff.isection]
    mov       rcx,	rax
    lea       rdx,	[rip+L10972]
    call      strcpy
    mov       rcx,	[rip+mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeobj.writecoff.isection+16],	eax
    mov       ax,	[rip+mc_decls.ss_nidatarelocs]
    mov       [rbp + mc_writeobj.writecoff.isection+32],	ax
    mov       eax,	3226468416
    mov       [rbp + mc_writeobj.writecoff.isection+36],	eax
    lea       rax,	[rbp + mc_writeobj.writecoff.csection]
    mov       rcx,	rax
    lea       rdx,	[rip+L10973]
    call      strcpy
    mov       rcx,	[rip+mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeobj.writecoff.csection+16],	eax
    mov       ax,	[rip+mc_decls.ss_ncoderelocs]
    mov       [rbp + mc_writeobj.writecoff.csection+32],	ax
    mov       eax,	1615855648
    mov       [rbp + mc_writeobj.writecoff.csection+36],	eax
    mov       rcx,	rbx
    call      mc_writeobj.initsymboltable
    call      mc_writeobj.convertsymboltable
    mov       rdi,	20
    mov       rax,	120
    add       rdi,	rax
    mov       ax,	[rbp + mc_writeobj.writecoff.isection+32]
    test      ax,	ax
    jz        L4656
    mov       [rbp + mc_writeobj.writecoff.isection+24],	edi
    movzx     rax,	word ptr[rbp + mc_writeobj.writecoff.isection+32]
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rdi,	rax
L4656:
    mov       ax,	[rbp + mc_writeobj.writecoff.csection+32]
    test      ax,	ax
    jz        L4658
    mov       [rbp + mc_writeobj.writecoff.csection+24],	edi
    movzx     rax,	word ptr[rbp + mc_writeobj.writecoff.csection+32]
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rdi,	rax
L4658:
    mov       [rbp + mc_writeobj.writecoff.isection+20],	edi
    mov       eax,	[rbp + mc_writeobj.writecoff.isection+16]
    add       rdi,	rax
    mov       [rbp + mc_writeobj.writecoff.csection+20],	edi
    mov       eax,	[rbp + mc_writeobj.writecoff.csection+16]
    add       rdi,	rax
    mov       [rbp + mc_writeobj.writecoff.header+8],	edi
    mov       rax,	[rip+mc_writeobj.nsymbols]
    shl       rax,	1
    lea       rax,	[rax + rax*8]
    add       rdi,	rax
    mov       eax,	[rip+mc_writeobj.nsymbols]
    mov       [rbp + mc_writeobj.writecoff.header+12],	eax
    mov       rax,	[rip+mc_writeobj.nextstringoffset]
    add       rdi,	rax
    mov       rcx,	rdi
    call      malloc
    mov       [rip+mc_writeobj.dataptr],	rax
    mov       [rip+mc_writeobj.datastart],	rax
    lea       rcx,	[rbp + mc_writeobj.writecoff.header]
    mov       rdx,	20
    call      mc_writeobj.writerecord
    lea       rcx,	[rbp + mc_writeobj.writecoff.zsection]
    mov       rdx,	40
    call      mc_writeobj.writerecord
    lea       rcx,	[rbp + mc_writeobj.writecoff.isection]
    mov       rdx,	40
    call      mc_writeobj.writerecord
    lea       rcx,	[rbp + mc_writeobj.writecoff.csection]
    mov       rdx,	40
    call      mc_writeobj.writerecord
    mov       rcx,	[rip+mc_decls.ss_idatarelocs]
    mov       rdx,	[rip+mc_decls.ss_nidatarelocs]
    call      mc_writeobj.writerelocs
    mov       rcx,	[rip+mc_decls.ss_coderelocs]
    mov       rdx,	[rip+mc_decls.ss_ncoderelocs]
    call      mc_writeobj.writerelocs
    mov       rcx,	[rip+mc_decls.ss_idata]
    call      mc_writeobj.writedata
    mov       rcx,	[rip+mc_decls.ss_code]
    call      mc_writeobj.writedata
    call      mc_writeobj.writesymboltable
    call      mc_writeobj.writestringtable
    mov       al,	[rip+pc_decls.pverbose]
    test      al,	al
    jz        L4660
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10974]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L4660:
    mov       rax,	[rip+mc_writeobj.dataptr]
    sub       rax,	[rip+mc_writeobj.datastart]
    mov       rcx,	rbx
    mov       rdx,	[rip+mc_writeobj.datastart]
    mov       r8,	rax
    call      mlib.writefile
    mov       al,	1
    mov       [rip+pc_decls.objdone],	al
L4649:
#---------------
    add       rsp,	176
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeobj.writerecord
mc_writeobj.writerecord:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_writeobj.dataptr]
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	rbx
    add       [rip+mc_writeobj.dataptr],	rax
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeobj.writerelocs
mc_writeobj.writerelocs:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    test      rsi,	rsi
    jnz       L4664
    jmp       L4662
L4664:
    jmp       L4666
L4665:
    mov       rax,	[rbx+8]
    cmp       rax,	2
    jz        L4669
    cmp       rax,	1
    jnz       L4670
L4669:
    mov       rax,	[rbx+24]
    mov       r10,	[rip+mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rdi,	r10
    movzx     rax,	byte ptr[rdi+94]
    cmp       rax,	3
    jz        L4672
    cmp       rax,	2
    jz        L4673
    cmp       rax,	1
    jz        L4674
    test      rax,	rax
    jz        L4675
    jmp       L4676
L4672:
    mov       eax,	2
    lea       r10,	[rip+mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
    jmp       L4671
L4673:
    mov       eax,	4
    lea       r10,	[rip+mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
    jmp       L4671
L4674:
    mov       eax,	6
    lea       r10,	[rip+mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
    jmp       L4671
L4675:
    mov       rax,	[rbx+24]
    add       rax,	[rip+mc_writeobj.stoffset]
    lea       r10,	[rip+mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
    jmp       L4671
L4676:
    lea       rcx,	[rip+L10975]
    call      mc_libmcl.axerror
L4671:
    jmp       L4668
L4670:
    mov       rax,	[rbx+24]
    add       rax,	[rip+mc_writeobj.stoffset]
    lea       r10,	[rip+mc_writeobj.writerelocs.s]
    mov       [r10+4],	eax
L4668:
    mov       rax,	[rbx+8]
    lea       r10,	[rip+mc_writeobj.writerelocs.s]
    mov       [r10+8],	ax
    movzx     rax,	byte ptr[rip+pc_api.phighmem]
    test      rax,	rax
    jz        L4678
    cmp       rax,	2
    jz        L4679
    jmp       L4680
L4678:
    jmp       L4677
L4679:
    mov       rax,	[rbx+8]
    cmp       rax,	2
    jnz       L4682
    mov       ax,	4
    lea       r10,	[rip+mc_writeobj.writerelocs.s]
    mov       [r10+8],	ax
    mov       rax,	4
    mov       [rbx+8],	rax
L4682:
    jmp       L4677
L4680:
    lea       rcx,	[rip+L10976]
    call      mc_libmcl.axerror
L4677:
    mov       rax,	[rbx+16]
    lea       r10,	[rip+mc_writeobj.writerelocs.s]
    mov       [r10],	eax
    mov       rcx,	[rip+mc_writeobj.dataptr]
    lea       rdx,	[rip+mc_writeobj.writerelocs.s]
    mov       r8,	10
    call      memcpy
    add       qword ptr[rip+mc_writeobj.dataptr],	10
    mov       rbx,	[rbx]
L4666:
    test      rbx,	rbx
    jnz       L4665
L4662:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeobj.writedata
mc_writeobj.writedata:
#PROC1
#PROC2
#?>>
    .set mc_writeobj.writedata.$T1, -8
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      mc_genss.bufferlength
    mov       [rbp + mc_writeobj.writedata.$T1],	rax
    mov       rcx,	rdi
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	[rip+mc_writeobj.dataptr]
    mov       rdx,	rax
    mov       r8,	[rbp + mc_writeobj.writedata.$T1]
    call      memcpy
    mov       rcx,	rdi
    call      mc_genss.bufferlength
    add       [rip+mc_writeobj.dataptr],	rax
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc mc_writeobj.writesymboltable
mc_writeobj.writesymboltable:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+mc_writeobj.nsymbols]
    cmp       rax,	1
    jl        L4687
L4685:
    lea       rax,	[rip+mc_writeobj.symboltable]
    mov       r10,	rdi
    shl       r10,	1
    lea       r10,	[r10 + r10*8]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    mov       rdx,	18
    call      mc_writeobj.writerecord
    inc       rdi
    cmp       rdi,	[rip+mc_writeobj.nsymbols]
    jle       L4685
L4687:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_writeobj.writestringtable
mc_writeobj.writestringtable:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	[rip+mc_writeobj.dataptr]
    mov       eax,	[rip+mc_writeobj.nextstringoffset]
    mov       [rdi],	eax
    add       qword ptr[rip+mc_writeobj.dataptr],	4
    mov       rbx,	1
    mov       rax,	[rip+mc_writeobj.nstrings]
    cmp       rax,	1
    jl        L4691
L4689:
    lea       rax,	[rip+mc_writeobj.stringlengths]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    inc       rax
    mov       rsi,	rax
    lea       rax,	[rip+mc_writeobj.stringtable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	[rip+mc_writeobj.dataptr]
    mov       rdx,	rax
    mov       r8,	rsi
    call      memcpy
    mov       rax,	rsi
    add       [rip+mc_writeobj.dataptr],	rax
    inc       rbx
    cmp       rbx,	[rip+mc_writeobj.nstrings]
    jle       L4689
L4691:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeobj.makesymbol
mc_writeobj.makesymbol:
#PROC1
#PROC2
#?>>
    .set mc_writeobj.makesymbol.storage, 88
    .set mc_writeobj.makesymbol.naux, 96
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      strlen
    mov       rdi,	rax
    cmp       rdi,	8
    jge       L4694
    lea       rax,	[rip+mc_writeobj.makesymbol.r]
    mov       rcx,	rax
    mov       rdx,	rbx
    call      strcpy
    jmp       L4693
L4694:
    cmp       rdi,	8
    jnz       L4695
    lea       rax,	[rip+mc_writeobj.makesymbol.r]
    mov       rcx,	rax
    mov       rdx,	rbx
    mov       r8,	rdi
    call      memcpy
    jmp       L4693
L4695:
    xor       eax,	eax
    lea       r10,	[rip+mc_writeobj.makesymbol.r]
    mov       [r10],	eax
    mov       rcx,	rbx
    mov       rdx,	rdi
    call      mc_writeobj.addstringentry
    lea       r10,	[rip+mc_writeobj.makesymbol.r]
    mov       [r10+4],	eax
L4693:
    mov       eax,	esi
    lea       r10,	[rip+mc_writeobj.makesymbol.r]
    mov       [r10+8],	eax
    mov       ax,	r12w
    lea       r10,	[rip+mc_writeobj.makesymbol.r]
    mov       [r10+12],	ax
    mov       ax,	r13w
    lea       r10,	[rip+mc_writeobj.makesymbol.r]
    mov       [r10+14],	ax
    mov       al,	[rbp + mc_writeobj.makesymbol.storage]
    lea       r10,	[rip+mc_writeobj.makesymbol.r]
    mov       [r10+16],	al
    mov       al,	[rbp + mc_writeobj.makesymbol.naux]
    lea       r10,	[rip+mc_writeobj.makesymbol.r]
    mov       [r10+17],	al
    lea       rax,	[rip+mc_writeobj.makesymbol.r]
L4692:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeobj.addsymbol
mc_writeobj.addsymbol:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_writeobj.nsymbols]
    cmp       rax,	13000
    jl        L4698
    lea       rcx,	[rip+L10977]
    call      mc_libmcl.axerror
L4698:
    inc       qword ptr[rip+mc_writeobj.nsymbols]
    mov       rax,	[rip+mc_writeobj.nsymbols]
    lea       r10,	[rip+mc_writeobj.symboltable]
    mov       r11,	rax
    shl       r11,	1
    lea       r11,	[r11 + r11*8]
    lea       r10,	[r10 + r11]
    mov       rcx,	r10
    mov       rdx,	rdi
    mov       r8,	18
    call      memcpy
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_writeobj.initsymboltable
mc_writeobj.initsymboltable:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rip+mc_writeobj.nsymbols],	rax
    push      1
    push      103
    lea       rcx,	[rip+L10978]
    xor       edx,	edx
    mov       r8,	-2
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    mov       rcx,	rdi
    call      mc_writeobj.strtoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       rcx,	[rip+L10979]
    xor       edx,	edx
    mov       r8,	1
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    xor       ecx,	ecx
    xor       edx,	edx
    call      mc_writeobj.sectiontoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       rcx,	[rip+L10980]
    xor       edx,	edx
    mov       r8,	2
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    mov       rcx,	[rip+mc_decls.ss_idata]
    mov       rdx,	[rip+mc_decls.ss_nidatarelocs]
    call      mc_writeobj.sectiontoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    push      1
    push      3
    lea       rcx,	[rip+L10981]
    xor       edx,	edx
    mov       r8,	3
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    mov       rcx,	[rip+mc_decls.ss_code]
    mov       rdx,	[rip+mc_decls.ss_ncoderelocs]
    call      mc_writeobj.sectiontoaux
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mc_writeobj.strtoaux
mc_writeobj.strtoaux:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_writeobj.strtoaux.r]
    mov       rdi,	rax
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	18
    call      memset
    xor       rbx,	rbx
    jmp       L4702
L4701:
    mov       rax,	rsi
    inc       rsi
    mov       al,	[rax]
    mov       r10,	rdi
    inc       rdi
    mov       [r10],	al
    inc       rbx
L4702:
    movzx     rax,	byte ptr[rsi]
    test      rax,	rax
    jz        L4704
    cmp       rbx,	18
    jl        L4701
L4704:
    lea       rax,	[rip+mc_writeobj.strtoaux.r]
L4700:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeobj.sectiontoaux
mc_writeobj.sectiontoaux:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+mc_writeobj.sectiontoaux.r]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10w
    test      rdi,	rdi
    jnz       L4707
    mov       eax,	[rip+mc_decls.ss_zdatalen]
    lea       r10,	[rip+mc_writeobj.sectiontoaux.r]
    mov       [r10],	eax
    jmp       L4706
L4707:
    mov       rcx,	rdi
    call      mc_genss.bufferlength
    lea       r10,	[rip+mc_writeobj.sectiontoaux.r]
    mov       [r10],	eax
L4706:
    mov       ax,	bx
    lea       r10,	[rip+mc_writeobj.sectiontoaux.r]
    mov       [r10+4],	ax
    lea       rax,	[rip+mc_writeobj.sectiontoaux.r]
L4705:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeobj.addstringentry
mc_writeobj.addstringentry:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rdi,	[rip+mc_writeobj.nextstringoffset]
    mov       rax,	[rip+mc_writeobj.nstrings]
    cmp       rax,	5000
    jle       L4710
    lea       rcx,	[rip+L10982]
    call      mc_libmcl.axerror
L4710:
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    inc       qword ptr[rip+mc_writeobj.nstrings]
    mov       r10,	[rip+mc_writeobj.nstrings]
    lea       r11,	[rip+mc_writeobj.stringtable]
    mov       [r11 + r10*8-8],	rax
    mov       rax,	rsi
    lea       r10,	[rip+mc_writeobj.stringlengths]
    mov       r11,	[rip+mc_writeobj.nstrings]
    mov       [r10 + r11*8-8],	rax
    lea       rax,	[rsi+1]
    add       [rip+mc_writeobj.nextstringoffset],	rax
    mov       rax,	rdi
L4708:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writeobj.convertsymboltable
mc_writeobj.convertsymboltable:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_writeobj.nsymbols]
    dec       rax
    mov       [rip+mc_writeobj.stoffset],	rax
    xor       eax,	eax
    mov       [rip+mc_writeobj.nstrings],	rax
    mov       rax,	4
    mov       [rip+mc_writeobj.nextstringoffset],	rax
    mov       rsi,	1
    mov       rax,	[rip+mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4714
L4712:
    mov       rax,	[rip+mc_decls.ss_symboltable]
    mov       r10,	rsi
    mov       rdi,	[rax + r10*8-8]
    mov       rbx,	[rdi]
    movzx     rax,	byte ptr[rdi+94]
    cmp       rax,	3
    jz        L4716
    cmp       rax,	2
    jz        L4717
    cmp       rax,	1
    jz        L4718
    jmp       L4719
L4716:
    mov       r12,	1
    jmp       L4715
L4717:
    mov       r12,	2
    jmp       L4715
L4718:
    mov       r12,	3
    jmp       L4715
L4719:
    xor       r12,	r12
L4715:
    mov       al,	[rdi+80]
    test      al,	al
    jz        L4721
    xor       r12,	r12
L4721:
    xor       r13,	r13
    mov       al,	[rdi+80]
    test      al,	al
    jnz       L4724
    mov       al,	[rdi+81]
    test      al,	al
    jz        L4723
L4724:
    mov       r13,	2
    jmp       L4722
L4723:
    mov       r13,	3
L4722:
    mov       al,	[rdi+81]
    test      al,	al
    jz        L4726
    mov       rcx,	rbx
    call      pc_api.getbasename
    mov       rbx,	rax
L4726:
    push      0
    mov       rax,	r13
    push      rax
    movsxd    rax,	dword ptr[rdi+76]
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	r12
    xor       r9d,	r9d
    sub       rsp,	32
    call      mc_writeobj.makesymbol
    add       rsp,	48
    mov       rcx,	rax
    call      mc_writeobj.addsymbol
    inc       rsi
    cmp       rsi,	[rip+mc_decls.ss_nsymbols]
    jle       L4712
L4714:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mc_writess_dummy.writessdata
mc_writess_dummy.writessdata:
#PROC1
#PROC2
#?>>
    .set mc_writess_dummy.writessdata.fexe, 16
#?]]
#---------------
#PROC3
#PROC4
    xor       eax,	eax
L4727:
#---------------
    ret       
# End 
# Proc mx_run.writememlib
mx_run.writememlib:
#PROC1
#PROC2
#?>>
    .set mx_run.writememlib.lib, -216
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	256
    mov       r14,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rbp + mx_run.writememlib.lib]
    xor       r10d,	r10d
    mov       r11,	27
L10983:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L10983
    mov       rcx,	[rip+mc_decls.ss_zdatalen]
    mov       rdx,	8
    call      mlib.roundtoblock
    mov       [rip+mc_decls.ss_zdatalen],	rax
    mov       rcx,	[rip+mc_decls.ss_code]
    mov       rdx,	8
    mov       r8,	144
    call      mx_run.roundsegment
    mov       rcx,	[rip+mc_decls.ss_idata]
    mov       rdx,	8
    xor       r8d,	r8d
    call      mx_run.roundsegment
    lea       rax,	[rip+L10984]
    mov       [rbp + mx_run.writememlib.lib],	rax
    mov       [rbp + mx_run.writememlib.lib+184],	r14
    mov       rcx,	r14
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_run.writememlib.lib+192],	rax
    mov       rax,	1
    mov       [rbp + mx_run.writememlib.lib+208],	rax
    call      mx_run.countsymbols
    lea       rcx,	[rbp + mx_run.writememlib.lib]
    call      mx_run.writerelocs
    mov       rax,	[rip+mc_decls.ss_zdatalen]
    mov       [rbp + mx_run.writememlib.lib+24],	rax
    mov       rcx,	[rip+mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       [rbp + mx_run.writememlib.lib+8],	rax
    mov       rcx,	[rip+mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       [rbp + mx_run.writememlib.lib+16],	rax
    mov       rcx,	[rip+mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mx_run.writememlib.lib+72],	rax
    mov       rcx,	[rip+mc_decls.ss_idata]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       [rbp + mx_run.writememlib.lib+80],	rax
    xor       rsi,	rsi
    xor       eax,	eax
    mov       r12,	rax
    mov       r13,	1
    mov       rax,	[rip+pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4731
L4729:
    lea       rax,	[rip+pc_decls.plibfiles]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	36
    jz        L4733
    inc       rsi
L4733:
    inc       r13
    cmp       r13,	[rip+pc_decls.nplibfiles]
    jle       L4729
L4731:
    mov       [rbp + mx_run.writememlib.lib+40],	rsi
    mov       [rbp + mx_run.writememlib.lib+48],	r12
    mov       rax,	8
    mov       r10,	rsi
    imul      rax,	r10
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_run.writememlib.lib+96],	rax
    mov       rax,	8
    mov       r10,	r12
    imul      rax,	r10
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_run.writememlib.lib+104],	rax
    xor       rbx,	rbx
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[rip+pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4736
L4734:
    lea       rax,	[rip+pc_decls.plibfiles]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	36
    jz        L4738
    lea       rax,	[rip+pc_decls.plibfiles]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    mov       r10,	[rbp + mx_run.writememlib.lib+96]
    inc       rbx
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
L4738:
    inc       r13
    cmp       r13,	[rip+pc_decls.nplibfiles]
    jle       L4734
L4736:
    lea       rcx,	[rbp + mx_run.writememlib.lib]
    call      mx_run.addsymbols
    mov       rcx,	216
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rcx,	rdi
    lea       rdx,	[rbp + mx_run.writememlib.lib]
    mov       r8,	216
    call      memcpy
    mov       rax,	rdi
L4728:
#---------------
    add       rsp,	256
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_run.roundsegment
mx_run.roundsegment:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    call      mc_genss.bufferlength
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	r13
    call      mlib.roundtoblock
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	r13
    call      mc_genss.buffercheck
    mov       rax,	rbx
    sub       rax,	rdi
    mov       rsi,	rax
    cmp       rsi,	0
    jle       L4742
L4740:
    lea       rax,	[r12+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	r14b
    dec       rsi
    jnz       L4740
L4742:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_run.writerelocs
mx_run.writerelocs:
#PROC1
#PROC2
#?>>
    .set mx_run.writerelocs.newr, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r14,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mc_decls.ss_nidatarelocs]
    add       rax,	[rip+mc_decls.ss_ncoderelocs]
    mov       [r14+32],	rax
    mov       rax,	[r14+32]
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r14+88],	rax
    xor       rbx,	rbx
    mov       rax,	1
    mov       r13,	rax
L4744:
    cmp       r13,	1
    jnz       L4748
    mov       rax,	[rip+mc_decls.ss_idatarelocs]
    jmp       L4747
L4748:
    mov       rax,	[rip+mc_decls.ss_coderelocs]
L4747:
    mov       rdi,	rax
    jmp       L4752
L4749:
    lea       rax,	[rbp + mx_run.writerelocs.newr]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       rax,	[rdi+16]
    mov       [rbp + mx_run.writerelocs.newr],	eax
    cmp       r13,	1
    jnz       L4754
    mov       rax,	2
    jmp       L4753
L4754:
    mov       rax,	1
L4753:
    mov       [rbp + mx_run.writerelocs.newr+6],	al
    mov       rax,	[rdi+24]
    mov       r10,	[rip+mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       rsi,	r10
    mov       rax,	[rdi+8]
    cmp       rax,	4
    jz        L4756
    cmp       rax,	2
    jz        L4757
    cmp       rax,	1
    jz        L4757
    jmp       L4758
L4756:
    mov       al,	[rsi+80]
    test      al,	al
    jz        L4760
    mov       ax,	[rsi+116]
    mov       [rbp + mx_run.writerelocs.newr+4],	ax
    mov       al,	5
    mov       [rbp + mx_run.writerelocs.newr+7],	al
    jmp       L4759
L4760:
    lea       rcx,	[rip+L10985]
    call      mc_libmcl.axerror
L4759:
    jmp       L4755
L4757:
    mov       al,	[rsi+80]
    test      al,	al
    jz        L4762
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jnz       L4764
    mov       rax,	3
    jmp       L4763
L4764:
    mov       rax,	4
L4763:
    mov       [rbp + mx_run.writerelocs.newr+7],	al
    mov       ax,	[rsi+116]
    mov       [rbp + mx_run.writerelocs.newr+4],	ax
    jmp       L4761
L4762:
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jnz       L4766
    mov       al,	1
    mov       [rbp + mx_run.writerelocs.newr+7],	al
    jmp       L4765
L4766:
    mov       al,	2
    mov       [rbp + mx_run.writerelocs.newr+7],	al
L4765:
    mov       al,	[rsi+94]
    mov       [rbp + mx_run.writerelocs.newr+4],	al
L4761:
    jmp       L4755
L4758:
    lea       rcx,	[rip+L10986]
    call      mc_libmcl.axerror
L4755:
    mov       rax,	[r14+88]
    inc       rbx
    mov       r10,	rbx
    mov       r11,	[rbp + mx_run.writerelocs.newr]
    mov       [rax + r10*8-8],	r11
    mov       rdi,	[rdi]
L4752:
    test      rdi,	rdi
    jnz       L4749
    inc       r13
    cmp       r13,	2
    jle       L4744
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_run.addsymbols
mx_run.addsymbols:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r14,	rcx
#---------------
#PROC3
#PROC4
    xor       rbx,	rbx
    mov       rax,	-1
    mov       rsi,	rax
    mov       rax,	[rip+mx_decls.nsymimports]
    mov       [r14+56],	rax
    mov       rax,	[rip+mx_decls.nsymexports]
    mov       [r14+64],	rax
    mov       rax,	[rip+mx_decls.nsymimports]
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r14+112],	rax
    mov       rax,	[rip+mx_decls.nsymexports]
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r14+120],	rax
    mov       rcx,	[rip+mx_decls.nsymexports]
    call      mlib.pcm_alloc
    mov       [r14+128],	rax
    mov       rax,	[rip+mx_decls.nsymexports]
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [r14+136],	rax
    xor       r12,	r12
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[rip+mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4770
L4768:
    mov       rax,	[rip+mc_decls.ss_symboltable]
    mov       r10,	r13
    mov       rax,	[rax + r10*8-8]
    mov       ax,	[rax+116]
    test      ax,	ax
    jz        L4772
    mov       rax,	[rip+mc_decls.ss_symboltable]
    mov       r10,	r13
    mov       rdi,	[rax + r10*8-8]
    mov       rax,	[rdi]
    mov       r10,	[r14+112]
    inc       r12
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
L4772:
    inc       r13
    cmp       r13,	[rip+mc_decls.ss_nsymbols]
    jle       L4768
L4770:
    xor       r12,	r12
    mov       rax,	1
    mov       r13,	rax
    mov       rax,	[rip+mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4775
L4773:
    mov       rax,	[rip+mc_decls.ss_symboltable]
    mov       r10,	r13
    mov       rdi,	[rax + r10*8-8]
    mov       ax,	[rdi+118]
    test      ax,	ax
    jz        L4777
    mov       al,	[rdi+83]
    test      al,	al
    jz        L4779
    mov       rbx,	rdi
L4779:
    mov       rax,	[rdi]
    mov       r10,	[r14+120]
    inc       r12
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
    mov       al,	[rdi+94]
    mov       r10,	[r14+128]
    mov       r11,	r12
    mov       [r10 + r11-1],	al
    movsxd    rax,	dword ptr[rdi+76]
    mov       r10,	[r14+136]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
L4777:
    inc       r13
    cmp       r13,	[rip+mc_decls.ss_nsymbols]
    jle       L4773
L4775:
    test      rbx,	rbx
    jz        L4781
    movsxd    rax,	dword ptr[rbx+76]
    mov       [r14+144],	rax
    jmp       L4780
L4781:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10987]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	-1
    mov       [r14+144],	rax
L4780:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_run.countsymbols
mx_run.countsymbols:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
#---------------
#PROC3
#PROC4
    mov       rbx,	1
    mov       rax,	[rip+mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L4785
L4783:
    mov       rax,	[rip+mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       al,	[rdi+81]
    test      al,	al
    jz        L4787
    inc       qword ptr[rip+mx_decls.nsymexports]
    mov       rax,	[rip+mx_decls.nsymexports]
    mov       [rdi+118],	ax
L4787:
    mov       al,	[rdi+80]
    test      al,	al
    jz        L4789
    inc       qword ptr[rip+mx_decls.nsymimports]
    mov       rax,	[rip+mx_decls.nsymimports]
    mov       [rdi+116],	ax
L4789:
    inc       rbx
    cmp       rbx,	[rip+mc_decls.ss_nsymbols]
    jle       L4783
L4785:
#---------------
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_run.runlibfile
mx_run.runlibfile:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      mx_run.writememlib
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mx_lib.loadmemmcu
    mov       rcx,	rdi
    call      mx_lib.fixuplib
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      mx_lib.runprogram
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.readlibfile
mx_lib.readlibfile:
#PROC1
#PROC2
#?>>
    .set mx_lib.readlibfile.p, 72
    .set mx_lib.readlibfile.lib, -216
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	256
    mov       r14,	rcx
    mov       [rbp+72],	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rbp + mx_lib.readlibfile.lib]
    xor       r10d,	r10d
    mov       r11,	27
L10988:
    mov       [rax],	r10
    add       rax,	8
    dec       r11
    jnz       L10988
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       rbx,	rax
    cmp       rbx,	441992013
    jz        L4793
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10989]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L4793:
    mov       rcx,	r14
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_lib.readlibfile.lib+184],	rax
    mov       rcx,	r14
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rbp + mx_lib.readlibfile.lib+192],	rax
L4794:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readbyte
    mov       rsi,	rax
    cmp       rax,	14
    jae       L4797
    lea       r10,	[rip+L4796]
    jmp       [r10 + rax*8]
    .data
L4796:
    .quad     L4829
    .quad     L4798
    .quad     L4801
    .quad     L4800
    .quad     L4799
    .quad     L4826
    .quad     L4802
    .quad     L4806
    .quad     L4810
    .quad     L4814
    .quad     L4818
    .quad     L4822
    .quad     L4827
    .quad     L4828
    .text
L4798:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       [rbp + mx_lib.readlibfile.lib],	rax
    jmp       L4794
L4799:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.lib+24],	rax
    jmp       L4794
L4800:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+16],	rax
    mov       rcx,	r12
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+80],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.lib+80]
    mov       rcx,	rax
    mov       rdx,	[rbp + mx_lib.readlibfile.p]
    mov       r8,	r12
    call      memcpy
    mov       rax,	r12
    add       [rbp + mx_lib.readlibfile.p],	rax
    jmp       L4794
L4801:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+8],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.p]
    mov       [rbp + mx_lib.readlibfile.lib+72],	rax
    mov       rax,	r12
    add       [rbp + mx_lib.readlibfile.p],	rax
    jmp       L4794
L4802:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+40],	rax
    mov       rax,	8
    mov       r10,	r12
    imul      rax,	r10
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+96],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4805
L4803:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+96]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4803
L4805:
    jmp       L4794
L4806:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+48],	rax
    mov       rax,	8
    mov       r10,	r12
    imul      rax,	r10
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+104],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4809
L4807:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+104]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4807
L4809:
    jmp       L4794
L4810:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+56],	rax
    mov       rax,	8
    mov       r10,	r12
    imul      rax,	r10
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+112],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4813
L4811:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+112]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4811
L4813:
    jmp       L4794
L4814:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+64],	rax
    mov       rax,	8
    mov       r10,	r12
    imul      rax,	r10
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+120],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4817
L4815:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readstring
    mov       r10,	[rbp + mx_lib.readlibfile.lib+120]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4815
L4817:
    jmp       L4794
L4818:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       rcx,	r12
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+128],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4821
L4819:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readbyte
    mov       r10,	[rbp + mx_lib.readlibfile.lib+128]
    mov       r11,	r13
    mov       [r10 + r11-1],	al
    inc       r13
    cmp       r13,	r12
    jle       L4819
L4821:
    jmp       L4794
L4822:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       rax,	8
    mov       r10,	r12
    imul      rax,	r10
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+136],	rax
    mov       r13,	1
    cmp       r12,	1
    jl        L4825
L4823:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r10,	[rbp + mx_lib.readlibfile.lib+136]
    mov       r11,	r13
    mov       [r10 + r11*8-8],	rax
    inc       r13
    cmp       r13,	r12
    jle       L4823
L4825:
    jmp       L4794
L4826:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       r12,	rax
    mov       [rbp + mx_lib.readlibfile.lib+32],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.lib+32]
    shl       rax,	3
    mov       r12,	rax
    mov       rcx,	r12
    call      mlib.pcm_alloc
    mov       [rbp + mx_lib.readlibfile.lib+88],	rax
    mov       rax,	[rbp + mx_lib.readlibfile.lib+88]
    mov       rcx,	rax
    mov       rdx,	[rbp + mx_lib.readlibfile.p]
    mov       r8,	r12
    call      memcpy
    mov       rax,	r12
    add       [rbp + mx_lib.readlibfile.p],	rax
    jmp       L4794
L4827:
    lea       rcx,	[rbp + mx_lib.readlibfile.p]
    call      mx_lib.readu32
    mov       [rbp + mx_lib.readlibfile.lib+144],	rax
    jmp       L4794
L4828:
    jmp       L4795
L4829:
    jmp       L4794
L4797:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10990]
    call      msys.m$print_str_nf
    lea       rax,	[rip+mx_decls.mcxdirnames]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       ecx,	ecx
    call      exit
    jmp       L4794
L4795:
    mov       rcx,	216
    call      mlib.pcm_allocnfz
    mov       rdi,	rax
    mov       rcx,	rdi
    lea       rdx,	[rbp + mx_lib.readlibfile.lib]
    mov       r8,	216
    call      memcpy
    mov       rax,	rdi
L4791:
#---------------
    add       rsp,	256
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.readbyte
mx_lib.readbyte:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	rcx
    mov       r10,	[rax]
    inc       qword ptr[rax]
    movzx     r10,	byte ptr[r10]
    mov       rax,	r10
L4830:
#---------------
    ret       
# End 
# Proc mx_lib.readu32
mx_lib.readu32:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    mov       rax,	[rcx]
    mov       eax,	[rax]
    mov       rdi,	rax
    mov       rax,	rcx
    add       qword ptr[rax],	4
    mov       rax,	rdi
L4831:
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc mx_lib.readstring
mx_lib.readstring:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rdi,	rax
L4833:
L4834:
    mov       rax,	rbx
    inc       qword ptr[rax]
    mov       rax,	[rax]
    mov       al,	[rax]
    test      al,	al
    jnz       L4833
    mov       rax,	rbx
    inc       qword ptr[rax]
    mov       rax,	rdi
L4832:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.alloclibdata
mx_lib.alloclibdata:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[r12+24]
    mov       rcx,	rax
    call      mlib.pcm_allocz
    mov       [r12+152],	rax
    mov       rax,	[r12+56]
    shl       rax,	4
    mov       rdi,	rax
    mov       rbx,	[r12+8]
    mov       rax,	rbx
    add       rax,	rdi
    mov       rcx,	rax
    call      mwindows.os_allocexecmem
    mov       rsi,	rax
    test      rsi,	rsi
    jnz       L4838
    lea       rcx,	[rip+L10991]
    lea       rdx,	[rip+L10992]
    call      mx_lib.error
L4838:
    mov       rax,	[r12+72]
    mov       rcx,	rsi
    mov       rdx,	rax
    mov       r8,	rbx
    call      memcpy
    lea       rax,	[rsi + rbx]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	rdi
    call      memset
    mov       [r12+72],	rsi
    mov       [r12+160],	rdi
    mov       rax,	[r12+64]
    mov       r10,	8
    imul      r10,	rax
    mov       rcx,	r10
    call      mlib.pcm_alloc
    mov       [r12+168],	rax
    mov       rax,	[r12+56]
    mov       r10,	2
    imul      r10,	rax
    mov       rcx,	r10
    call      mlib.pcm_alloc
    mov       [r12+176],	rax
    mov       rax,	[r12+144]
    mov       r10,	4294967295
    cmp       rax,	r10
    jz        L4840
    mov       rax,	[r12+72]
    mov       r10,	[r12+144]
    lea       rax,	[rax + r10]
    mov       [r12+200],	rax
L4840:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.error
mx_lib.error:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       al,	[rbx]
    test      al,	al
    jz        L4843
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L4842
L4843:
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L4842:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10993]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.loadmemmcu
mx_lib.loadmemmcu:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rbx,	[rsi+192]
    mov       rax,	[rsi+184]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mx_lib.checknew
    mov       rcx,	rbx
    call      mx_lib.mxaddlib
    mov       rdi,	rax
    mov       rax,	rsi
    lea       r10,	[rip+mx_decls.libtable]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    mov       rcx,	rsi
    call      mx_lib.loadimports
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.checknew
mx_lib.checknew:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      mx_lib.findlib
    test      rax,	rax
    jz        L4847
    lea       rcx,	[rip+L10994]
    mov       rdx,	rbx
    call      mx_lib.error
L4847:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.findlib
mx_lib.findlib:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+mx_decls.nlibs]
    cmp       rax,	1
    jl        L4851
L4849:
    lea       rax,	[rip+mx_decls.libnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L4853
    mov       rax,	rdi
    jmp       L4848
L4853:
    inc       rdi
    cmp       rdi,	[rip+mx_decls.nlibs]
    jle       L4849
L4851:
    xor       eax,	eax
L4848:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.mxaddlib
mx_lib.mxaddlib:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+mx_decls.nlibs]
    cmp       rax,	20
    jl        L4856
    lea       rcx,	[rip+L10995]
    lea       rdx,	[rip+L10996]
    call      mx_lib.error
L4856:
    inc       qword ptr[rip+mx_decls.nlibs]
    mov       rax,	[rip+mx_decls.nlibs]
    mov       r10,	rdi
    lea       r11,	[rip+mx_decls.libnametable]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	[rip+mx_decls.nlibs]
L4854:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mx_lib.fixuplib
mx_lib.fixuplib:
#PROC1
#PROC2
#?>>
    .set mx_lib.fixuplib.lib, 16
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      mx_lib.loaddlls
    call      mx_lib.checksymbols
    call      mx_lib.dorelocations
#---------------
    add       rsp,	40
    ret       
# End 
# Proc mx_lib.loaddlls
mx_lib.loaddlls:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rbx,	1
    mov       rax,	[rip+mx_decls.ndlllibs]
    cmp       rax,	1
    jl        L4861
L4859:
    lea       rax,	[rip+mx_decls.dllinsttable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    test      rax,	rax
    jnz       L4863
    lea       rax,	[rip+mx_decls.dllnametable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mwindows.os_getdllinst
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L4865
    lea       rax,	[rip+mx_decls.dllnametable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    lea       rcx,	[rip+L10997]
    mov       rdx,	rax
    call      mx_lib.error
L4865:
    mov       rax,	rdi
    lea       r10,	[rip+mx_decls.dllinsttable]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
L4863:
    inc       rbx
    cmp       rbx,	[rip+mx_decls.ndlllibs]
    jle       L4859
L4861:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.finddllsymbol
mx_lib.finddllsymbol:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [r12],	rax
    mov       rbx,	1
    mov       rax,	[rip+mx_decls.ndlllibs]
    cmp       rax,	1
    jl        L4869
L4867:
    lea       rax,	[rip+mx_decls.dllinsttable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      mwindows.os_getdllprocaddr
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L4871
    mov       [r12],	rbx
    mov       rax,	rdi
    jmp       L4866
L4871:
    inc       rbx
    cmp       rbx,	[rip+mx_decls.ndlllibs]
    jle       L4867
L4869:
    xor       eax,	eax
L4866:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.checksymbols
mx_lib.checksymbols:
#PROC1
#PROC2
#?>>
    .set mx_lib.checksymbols.dllindex, -8
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    xor       rdi,	rdi
    mov       rax,	1
    mov       rsi,	rax
    mov       rax,	[rip+mx_decls.nsymbols]
    cmp       rax,	1
    jl        L4875
L4873:
    lea       rax,	[rip+mx_decls.symboldefined]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L4877
    lea       rax,	[rip+mx_decls.symbolnametable]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    lea       rdx,	[rbp + mx_lib.checksymbols.dllindex]
    call      mx_lib.finddllsymbol
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L4879
    mov       rax,	rbx
    lea       r10,	[rip+mx_decls.symboladdress]
    mov       r11,	rsi
    mov       [r10 + r11*8-8],	rax
    mov       al,	[rbp + mx_lib.checksymbols.dllindex]
    lea       r10,	[rip+mx_decls.symboldllindex]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    mov       al,	1
    lea       r10,	[rip+mx_decls.symboldefined]
    mov       r11,	rsi
    mov       [r10 + r11-1],	al
    jmp       L4878
L4879:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L10998]
    call      msys.m$print_str_nf
    lea       rax,	[rip+mx_decls.symbolnametable]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       rdi
L4878:
L4877:
    inc       rsi
    cmp       rsi,	[rip+mx_decls.nsymbols]
    jle       L4873
L4875:
    test      rdi,	rdi
    jz        L4881
L4881:
#---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.dorelocations
mx_lib.dorelocations:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+mx_decls.nlibs]
    cmp       rax,	1
    jl        L4885
L4883:
    lea       rax,	[rip+mx_decls.librelocated]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L4887
    lea       rax,	[rip+mx_decls.libtable]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8-8]
    call      mx_lib.reloclib
L4887:
    inc       rdi
    cmp       rdi,	[rip+mx_decls.nlibs]
    jle       L4883
L4885:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mx_lib.reloclib
mx_lib.reloclib:
#PROC1
#PROC2
#?>>
    .set mx_lib.reloclib.lib, 72
    .set mx_lib.reloclib.r, -8
    .set mx_lib.reloclib.av_2, -16
    .set mx_lib.reloclib.i, -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       [rbp+72],	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[r10+8]
    lea       rax,	[rax + r10]
    mov       r12,	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+56]
    shl       rax,	3
    lea       r10,	[r12 + rax]
    mov       r14,	r10
    mov       rax,	1
    mov       [rbp + mx_lib.reloclib.i],	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       r15,	[rax+56]
    cmp       r15,	1
    jl        L4891
L4889:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+112]
    mov       r10,	[rbp + mx_lib.reloclib.i]
    mov       rsi,	[rax + r10*8-8]
    mov       rax,	r12
    inc       r12
    mov       r10b,	72
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	255
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	36
    mov       [rax],	r10b
    mov       rax,	r12
    inc       r12
    mov       r10b,	37
    mov       [rax],	r10b
    mov       [r12],	r14d
    add       r12,	4
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+176]
    mov       r10,	[rbp + mx_lib.reloclib.i]
    movsx     rax,	word ptr[rax + r10*2-2]
    mov       rdi,	rax
    lea       rax,	[rip+mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       r10,	r14
    add       r14,	8
    mov       [r10],	rax
    mov       rax,	[rbp + mx_lib.reloclib.i]
    inc       rax
    mov       [rbp + mx_lib.reloclib.i],	rax
    cmp       rax,	r15
    jle       L4889
L4891:
    mov       rax,	1
    mov       [rbp + mx_lib.reloclib.i],	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+32]
    mov       [rbp + mx_lib.reloclib.av_2],	rax
    mov       rax,	[rbp + mx_lib.reloclib.av_2]
    cmp       rax,	1
    jl        L4894
L4892:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+88]
    mov       r10,	[rbp + mx_lib.reloclib.i]
    mov       rax,	[rax + r10*8-8]
    mov       [rbp + mx_lib.reloclib.r],	rax
    movzx     rax,	byte ptr[rbp + mx_lib.reloclib.r+6]
    cmp       rax,	1
    jz        L4896
    cmp       rax,	2
    jz        L4897
    cmp       rax,	3
    jz        L4898
    jmp       L4899
L4896:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10d,	[rbp + mx_lib.reloclib.r]
    lea       rax,	[rax + r10]
    mov       r12,	rax
    jmp       L4895
L4897:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+80]
    mov       r10d,	[rbp + mx_lib.reloclib.r]
    lea       rax,	[rax + r10]
    mov       r12,	rax
    jmp       L4895
L4898:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+152]
    mov       r10d,	[rbp + mx_lib.reloclib.r]
    lea       rax,	[rax + r10]
    mov       r12,	rax
L4899:
L4895:
    movzx     rax,	byte ptr[rbp + mx_lib.reloclib.r+7]
    cmp       rax,	1
    jz        L4901
    cmp       rax,	2
    jz        L4902
    cmp       rax,	4
    jz        L4903
    cmp       rax,	3
    jz        L4904
    cmp       rax,	5
    jz        L4905
    jmp       L4906
L4901:
    mov       eax,	[r12]
    mov       rbx,	rax
    movzx     rax,	byte ptr[rbp + mx_lib.reloclib.r+4]
    cmp       rax,	1
    jz        L4908
    cmp       rax,	2
    jz        L4909
    cmp       rax,	3
    jz        L4910
    jmp       L4911
L4908:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	eax
    jmp       L4907
L4909:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+80]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	eax
    jmp       L4907
L4910:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+152]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	eax
L4911:
L4907:
    jmp       L4900
L4902:
    mov       eax,	[r12]
    mov       rbx,	rax
    movzx     rax,	byte ptr[rbp + mx_lib.reloclib.r+4]
    cmp       rax,	1
    jz        L4913
    cmp       rax,	2
    jz        L4914
    cmp       rax,	3
    jz        L4915
    jmp       L4916
L4913:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	rax
    jmp       L4912
L4914:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+80]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	rax
    jmp       L4912
L4915:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+152]
    mov       r10,	rbx
    lea       rax,	[rax + r10]
    mov       [r12],	rax
L4916:
L4912:
    jmp       L4900
L4903:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+176]
    movzx     r10,	word ptr[rbp + mx_lib.reloclib.r+4]
    movsx     rax,	word ptr[rax + r10*2-2]
    mov       rdi,	rax
    lea       rax,	[rip+mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       r10,	r12
    add       [r10],	rax
    jmp       L4900
L4904:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+176]
    movzx     r10,	word ptr[rbp + mx_lib.reloclib.r+4]
    movsx     rax,	word ptr[rax + r10*2-2]
    mov       rdi,	rax
    lea       rax,	[rip+mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       r10,	r12
    add       [r10],	eax
    jmp       L4900
L4905:
    movzx     rax,	byte ptr[rbp + mx_lib.reloclib.r+6]
    cmp       rax,	1
    jz        L4918
    lea       rcx,	[rip+L10999]
    lea       rdx,	[rip+L11000]
    call      mx_lib.error
L4918:
    movzx     rax,	word ptr[rbp + mx_lib.reloclib.r+4]
    mov       rdi,	rax
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+72]
    mov       r10,	[rbp + mx_lib.reloclib.lib]
    mov       r10,	[r10+8]
    lea       rax,	[rax + r10]
    lea       r10,	[rdi-1]
    shl       r10,	3
    lea       rax,	[rax + r10]
    mov       r13,	rax
    lea       rax,	[r12+4]
    mov       r10,	r13
    sub       r10,	rax
    mov       [r12],	r10d
L4906:
L4900:
    mov       rax,	[rbp + mx_lib.reloclib.i]
    inc       rax
    mov       [rbp + mx_lib.reloclib.i],	rax
    cmp       rax,	[rbp + mx_lib.reloclib.av_2]
    jle       L4892
L4894:
    mov       rax,	[rbp + mx_lib.reloclib.lib]
    mov       rax,	[rax+208]
    mov       r10b,	1
    lea       r11,	[rip+mx_decls.librelocated]
    mov       [r11 + rax-1],	r10b
#---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.loadimports
mx_lib.loadimports:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rbx,	1
    mov       rdi,	[rsi+48]
    cmp       rdi,	1
    jl        L4922
L4920:
    mov       rax,	[rsi+104]
    mov       r10,	rbx
    mov       rcx,	[rax + r10*8-8]
    call      mx_lib.dosublib
    inc       rbx
    cmp       rbx,	rdi
    jle       L4920
L4922:
    mov       rcx,	rsi
    call      mx_lib.alloclibdata
    mov       rcx,	rsi
    call      mx_lib.dosymbols
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.dosublib
mx_lib.dosublib:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rsi
    call      mx_lib.findlib
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L4925
    mov       rcx,	rsi
    call      mx_lib.mxaddlib
    mov       rbx,	rax
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11001]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rsi
    lea       rdx,	[rip+L11002]
    call      mlib.addext
    mov       rcx,	rax
    mov       rdx,	rbx
    call      mx_lib.loadlibfile
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mx_lib.loadimports
L4925:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.loadlibfile
mx_lib.loadlibfile:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rsi
    call      mx_lib.readmxfile
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L4928
    lea       rcx,	[rip+L11003]
    mov       rdx,	rsi
    call      mx_lib.error
L4928:
    mov       rcx,	rsi
    mov       rdx,	rbx
    call      mx_lib.readlibfile
    mov       rdi,	rax
    mov       [rdi+208],	r12
    mov       rax,	rdi
    lea       r10,	[rip+mx_decls.libtable]
    mov       r11,	r12
    mov       [r10 + r11*8-8],	rax
L4926:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.dosymbols
mx_lib.dosymbols:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    sub       rsp,	48
    mov       r15,	rcx
#---------------
#PROC3
#PROC4
    mov       r14,	1
    mov       rsi,	[r15+40]
    cmp       rsi,	1
    jl        L4932
L4930:
    mov       rax,	[r15+96]
    mov       r10,	r14
    mov       rcx,	[rax + r10*8-8]
    call      mx_lib.adddll
    inc       r14
    cmp       r14,	rsi
    jle       L4930
L4932:
    mov       r14,	1
    mov       r12,	[r15+56]
    cmp       r12,	1
    jl        L4935
L4933:
    mov       rax,	[r15+112]
    mov       r10,	r14
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mx_lib.addsymbol
    mov       rdi,	rax
    mov       rax,	[r15+176]
    mov       r10w,	di
    mov       r11,	r14
    mov       [rax + r11*2-2],	r10w
    inc       r14
    cmp       r14,	r12
    jle       L4933
L4935:
    mov       r14,	1
    mov       r13,	[r15+64]
    cmp       r13,	1
    jl        L4938
L4936:
    mov       rax,	[r15+120]
    mov       r10,	r14
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    call      mx_lib.addsymbol
    mov       rdi,	rax
    lea       rax,	[rip+mx_decls.symboldefined]
    mov       r10,	rdi
    mov       al,	[rax + r10-1]
    test      al,	al
    jz        L4940
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11004]
    call      msys.m$print_str_nf
    mov       rax,	[r15+120]
    mov       r10,	r14
    mov       rcx,	[rax + r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L4937
L4940:
    mov       al,	1
    lea       r10,	[rip+mx_decls.symboldefined]
    mov       r11,	rdi
    mov       [r10 + r11-1],	al
    mov       rax,	[r15+128]
    mov       r10,	r14
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	1
    jz        L4942
    cmp       rax,	2
    jz        L4943
    cmp       rax,	3
    jz        L4944
    jmp       L4945
L4942:
    mov       rbx,	[r15+72]
    jmp       L4941
L4943:
    mov       rbx,	[r15+80]
    jmp       L4941
L4944:
    mov       rbx,	[r15+152]
    jmp       L4941
L4945:
    xor       rbx,	rbx
L4941:
    mov       rax,	[r15+136]
    mov       r10,	r14
    mov       rax,	[rax + r10*8-8]
    lea       r10,	[rbx + rax]
    lea       rax,	[rip+mx_decls.symboladdress]
    mov       r11,	rdi
    mov       [rax + r11*8-8],	r10
    mov       rax,	[r15+208]
    lea       r10,	[rip+mx_decls.symbollibindex]
    mov       r11,	rdi
    mov       [r10 + r11*2-2],	ax
L4937:
    inc       r14
    cmp       r14,	r13
    jle       L4936
L4938:
#---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.readmxfile
mx_lib.readmxfile:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      mlib.readfile
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L4948
    xor       eax,	eax
    jmp       L4946
L4948:
    mov       al,	13
    mov       r10,	[rip+mlib.rfsize]
    mov       [rdi + r10],	al
    mov       rax,	rdi
L4946:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.adddll
mx_lib.adddll:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+mx_decls.ndlllibs]
    cmp       rax,	1
    jl        L4952
L4950:
    lea       rax,	[rip+mx_decls.dllnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jnz       L4949
L4954:
    inc       rdi
    cmp       rdi,	[rip+mx_decls.ndlllibs]
    jle       L4950
L4952:
    mov       rax,	[rip+mx_decls.ndlllibs]
    cmp       rax,	20
    jl        L4956
    lea       rcx,	[rip+L11005]
    lea       rdx,	[rip+L11006]
    call      mx_lib.error
L4956:
    inc       qword ptr[rip+mx_decls.ndlllibs]
    mov       rax,	[rip+mx_decls.ndlllibs]
    mov       r10,	rbx
    lea       r11,	[rip+mx_decls.dllnametable]
    mov       [r11 + rax*8-8],	r10
L4949:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.addsymbol
mx_lib.addsymbol:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+mx_decls.nsymbols]
    cmp       rax,	1
    jl        L4960
L4958:
    lea       rax,	[rip+mx_decls.symbolnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L4962
    mov       rax,	rdi
    jmp       L4957
L4962:
    inc       rdi
    cmp       rdi,	[rip+mx_decls.nsymbols]
    jle       L4958
L4960:
    mov       rax,	[rip+mx_decls.nsymbols]
    cmp       rax,	3000
    jl        L4964
    lea       rcx,	[rip+L11007]
    lea       rdx,	[rip+L11008]
    call      mx_lib.error
L4964:
    inc       qword ptr[rip+mx_decls.nsymbols]
    mov       rax,	[rip+mx_decls.nsymbols]
    mov       r10,	rbx
    lea       r11,	[rip+mx_decls.symbolnametable]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	[rip+mx_decls.nsymbols]
L4957:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.setspecialglobals
mx_lib.setspecialglobals:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+mx_decls.nsymbols]
    cmp       rax,	1
    jl        L4968
L4966:
    lea       rax,	[rip+mx_decls.symbolnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    lea       rdx,	[rip+L11009]
    call      mlib.eqstring
    test      rax,	rax
    jnz       L4971
    lea       rax,	[rip+mx_decls.symbolnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    lea       rdx,	[rip+L11010]
    call      mlib.eqstring
    test      rax,	rax
    jz        L4970
L4971:
    lea       rax,	[rip+mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       r10b,	bl
    mov       [rax],	r10b
L4970:
    inc       rdi
    cmp       rdi,	[rip+mx_decls.nsymbols]
    jle       L4966
L4968:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.runprogram
mx_lib.runprogram:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
#---------------
#PROC3
#PROC4
    mov       rbx,	[r12+208]
    mov       rsi,	1
    mov       rax,	[rip+mx_decls.nlibs]
    cmp       rax,	1
    jl        L4975
L4973:
    cmp       rsi,	rbx
    jz        L4977
    lea       rax,	[rip+mx_decls.libinitdone]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    test      al,	al
    jnz       L4977
    lea       rax,	[rip+mx_decls.libtable]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8-8]
    call      mx_lib.calllibinit
L4977:
    inc       rsi
    cmp       rsi,	[rip+mx_decls.nlibs]
    jle       L4973
L4975:
    mov       rax,	[r12+200]
    test      rax,	rax
    jnz       L4979
    lea       rcx,	[rip+L11011]
    lea       rdx,	[rip+L11012]
    call      mx_lib.error
L4979:
    mov       rcx,	r13
    call      mx_lib.setspecialglobals
    mov       rdi,	[r12+200]
    mov       rax,	rdi
    call      rax
    mov       al,	1
    lea       r10,	[rip+mx_decls.libinitdone]
    mov       r11,	rbx
    mov       [r10 + r11-1],	al
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.calllibinit
mx_lib.calllibinit:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rbx,	[rsi+208]
    mov       rax,	[rsi+200]
    test      rax,	rax
    jz        L4982
    mov       rdi,	[rsi+200]
    mov       rax,	rdi
    call      rax
L4982:
    mov       rax,	[rsi+208]
    mov       r10b,	1
    lea       r11,	[rip+mx_decls.libinitdone]
    mov       [r11 + rax-1],	r10b
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.findsymbol
mx_lib.findsymbol:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+mx_decls.nsymbols]
    cmp       rax,	1
    jl        L4986
L4984:
    lea       rax,	[rip+mx_decls.symbolnametable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	rbx
    call      mlib.eqstring
    test      rax,	rax
    jz        L4988
    lea       rax,	[rip+mx_decls.symboladdress]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    jmp       L4983
L4988:
    inc       rdi
    cmp       rdi,	[rip+mx_decls.nsymbols]
    jle       L4984
L4986:
    xor       eax,	eax
L4983:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.loadmx
mx_lib.loadmx:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.convlcstring
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rsi,	rax
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mx_lib.checknew
    mov       rcx,	rsi
    call      mx_lib.mxaddlib
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	rbx
    call      mx_lib.loadlibfile
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mx_lib.loadimports
    mov       rax,	rdi
L4989:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_lib.loadmemmcb
mx_lib.loadmemmcb:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.convlcstring
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rsi,	rax
    mov       rcx,	rsi
    mov       rdx,	r12
    call      mx_lib.checknew
    mov       rcx,	rsi
    call      mx_lib.mxaddlib
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	r13
    call      mx_lib.readlibfile
    mov       rdi,	rax
    mov       [rdi+208],	rbx
    mov       rax,	rdi
    lea       r10,	[rip+mx_decls.libtable]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
    mov       rcx,	rdi
    call      mx_lib.loadimports
    mov       rax,	rdi
L4990:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_write.writemcx
mx_write.writemcx:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mc_decls.ss_zdatalen]
    mov       rdx,	8
    call      mlib.roundtoblock
    mov       [rip+mc_decls.ss_zdatalen],	rax
    mov       rcx,	[rip+mc_decls.ss_code]
    mov       rdx,	8
    mov       r8,	144
    call      mx_write.roundsegment
    mov       rcx,	[rip+mc_decls.ss_idata]
    mov       rdx,	8
    xor       r8d,	r8d
    call      mx_write.roundsegment
    mov       rcx,	1024
    call      mc_genss.buffercreate
    mov       [rip+mx_write.dest],	rax
    mov       rcx,	441992013
    call      mx_write.genu32
    mov       rcx,	1
    call      mx_write.genbyte
    lea       rcx,	[rip+L11013]
    call      mx_write.genstring
    call      mx_run.countsymbols
    call      mx_write.writerelocs
    mov       rcx,	4
    call      mx_write.genbyte
    mov       rcx,	[rip+mc_decls.ss_zdatalen]
    call      mx_write.genu32
    mov       rcx,	2
    call      mx_write.genbyte
    mov       rcx,	[rip+mc_decls.ss_code]
    call      mc_genss.bufferlength
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rax
    call      mx_write.genu32
    mov       rcx,	[rip+mc_decls.ss_code]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mx_write.genblock
    mov       rcx,	3
    call      mx_write.genbyte
    mov       rcx,	[rip+mc_decls.ss_idata]
    call      mc_genss.bufferlength
    mov       r10,	rax
    mov       rdi,	r10
    mov       rcx,	rax
    call      mx_write.genu32
    mov       rcx,	[rip+mc_decls.ss_idata]
    xor       edx,	edx
    call      mc_genss.bufferelemptr
    mov       rcx,	rax
    mov       rdx,	rdi
    call      mx_write.genblock
    xor       rbx,	rbx
    xor       eax,	eax
    mov       rsi,	rax
    mov       r12,	1
    mov       rax,	[rip+pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4994
L4992:
    lea       rax,	[rip+pc_decls.plibfiles]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	36
    jz        L4996
    inc       rbx
L4996:
    inc       r12
    cmp       r12,	[rip+pc_decls.nplibfiles]
    jle       L4992
L4994:
    mov       rcx,	6
    call      mx_write.genbyte
    mov       rcx,	rbx
    call      mx_write.genu32
    mov       r12,	1
    mov       rax,	[rip+pc_decls.nplibfiles]
    cmp       rax,	1
    jl        L4999
L4997:
    lea       rax,	[rip+pc_decls.plibfiles]
    mov       r10,	r12
    mov       rax,	[rax + r10*8-8]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	36
    jz        L5001
    lea       rax,	[rip+pc_decls.plibfiles]
    mov       r10,	r12
    mov       rcx,	[rax + r10*8-8]
    call      mx_write.genstring
L5001:
    inc       r12
    cmp       r12,	[rip+pc_decls.nplibfiles]
    jle       L4997
L4999:
    call      mx_write.writesymbols
    mov       rcx,	13
    call      mx_write.genbyte
    mov       rax,	[rip+mx_write.dest]
    mov       rax,	[rax+8]
    mov       r10,	[rip+mx_write.dest]
    mov       r10,	[r10]
    sub       rax,	r10
    mov       r10,	[rip+mx_write.dest]
    mov       r10,	[r10]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    call      mlib.writefile
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_write.writerelocs
mx_write.writerelocs:
#PROC1
#PROC2
#?>>
    .set mx_write.writerelocs.newr, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rcx,	5
    call      mx_write.genbyte
    mov       rax,	[rip+mc_decls.ss_nidatarelocs]
    add       rax,	[rip+mc_decls.ss_ncoderelocs]
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	rax
    call      mx_write.genu32
    xor       rsi,	rsi
    mov       rax,	1
    mov       r14,	rax
L5003:
    cmp       r14,	1
    jnz       L5007
    mov       rax,	[rip+mc_decls.ss_idatarelocs]
    jmp       L5006
L5007:
    mov       rax,	[rip+mc_decls.ss_coderelocs]
L5006:
    mov       rdi,	rax
    jmp       L5011
L5008:
    inc       rsi
    lea       rax,	[rbp + mx_write.writerelocs.newr]
    xor       r10d,	r10d
    mov       [rax],	r10
    mov       rax,	[rdi+16]
    mov       [rbp + mx_write.writerelocs.newr],	eax
    cmp       r14,	1
    jnz       L5013
    mov       rax,	2
    jmp       L5012
L5013:
    mov       rax,	1
L5012:
    mov       [rbp + mx_write.writerelocs.newr+6],	al
    mov       rax,	[rdi+24]
    mov       r10,	[rip+mc_decls.ss_symboltable]
    mov       r10,	[r10 + rax*8-8]
    mov       r12,	r10
    mov       rax,	[rdi+8]
    cmp       rax,	4
    jz        L5015
    cmp       rax,	2
    jz        L5016
    cmp       rax,	1
    jz        L5016
    jmp       L5017
L5015:
    mov       al,	[r12+80]
    test      al,	al
    jz        L5019
    mov       ax,	[r12+116]
    mov       [rbp + mx_write.writerelocs.newr+4],	ax
    mov       al,	5
    mov       [rbp + mx_write.writerelocs.newr+7],	al
    jmp       L5018
L5019:
    lea       rcx,	[rip+L11014]
    call      mc_libmcl.axerror
L5018:
    jmp       L5014
L5016:
    mov       al,	[r12+80]
    test      al,	al
    jz        L5021
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jnz       L5023
    mov       rax,	3
    jmp       L5022
L5023:
    mov       rax,	4
L5022:
    mov       [rbp + mx_write.writerelocs.newr+7],	al
    mov       ax,	[r12+116]
    mov       [rbp + mx_write.writerelocs.newr+4],	ax
    jmp       L5020
L5021:
    mov       rax,	[rdi+8]
    cmp       rax,	2
    jnz       L5025
    mov       al,	1
    mov       [rbp + mx_write.writerelocs.newr+7],	al
    jmp       L5024
L5025:
    mov       al,	2
    mov       [rbp + mx_write.writerelocs.newr+7],	al
L5024:
    mov       al,	[r12+94]
    mov       [rbp + mx_write.writerelocs.newr+4],	al
L5020:
    jmp       L5014
L5017:
    lea       rcx,	[rip+L11015]
    call      mc_libmcl.axerror
L5014:
    lea       rcx,	[rbp + mx_write.writerelocs.newr]
    mov       rdx,	8
    call      mx_write.genblock
    mov       rdi,	[rdi]
L5011:
    test      rdi,	rdi
    jnz       L5008
    inc       r14
    cmp       r14,	2
    jle       L5003
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_write.writesymbols
mx_write.writesymbols:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rcx,	8
    call      mx_write.genbyte
    mov       rcx,	[rip+mx_decls.nsymimports]
    call      mx_write.genu32
    mov       rbx,	1
    mov       rax,	[rip+mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L5029
L5027:
    mov       rax,	[rip+mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       ax,	[rax+116]
    test      ax,	ax
    jz        L5031
    mov       rax,	[rip+mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       rcx,	[rdi]
    call      mx_write.genstring
L5031:
    inc       rbx
    cmp       rbx,	[rip+mc_decls.ss_nsymbols]
    jle       L5027
L5029:
    mov       rcx,	9
    call      mx_write.genbyte
    mov       rcx,	[rip+mx_decls.nsymexports]
    call      mx_write.genu32
    mov       rbx,	1
    mov       rax,	[rip+mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L5034
L5032:
    mov       rax,	[rip+mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       ax,	[rdi+118]
    test      ax,	ax
    jz        L5036
    mov       al,	[rdi+83]
    test      al,	al
    jz        L5038
    mov       [rip+mx_write.entrypoint],	rdi
L5038:
    mov       rcx,	[rdi]
    call      mx_write.genstring
L5036:
    inc       rbx
    cmp       rbx,	[rip+mc_decls.ss_nsymbols]
    jle       L5032
L5034:
    mov       rcx,	10
    call      mx_write.genbyte
    mov       rcx,	[rip+mx_decls.nsymexports]
    call      mx_write.genu32
    mov       rbx,	1
    mov       rax,	[rip+mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L5041
L5039:
    mov       rax,	[rip+mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       ax,	[rdi+118]
    test      ax,	ax
    jz        L5043
    movzx     rax,	byte ptr[rdi+94]
    mov       rcx,	rax
    call      mx_write.genbyte
L5043:
    inc       rbx
    cmp       rbx,	[rip+mc_decls.ss_nsymbols]
    jle       L5039
L5041:
    mov       rcx,	11
    call      mx_write.genbyte
    mov       rcx,	[rip+mx_decls.nsymexports]
    call      mx_write.genu32
    mov       rbx,	1
    mov       rax,	[rip+mc_decls.ss_nsymbols]
    cmp       rax,	1
    jl        L5046
L5044:
    mov       rax,	[rip+mc_decls.ss_symboltable]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8-8]
    mov       ax,	[rdi+118]
    test      ax,	ax
    jz        L5048
    movsxd    rax,	dword ptr[rdi+76]
    mov       rcx,	rax
    call      mx_write.genu32
L5048:
    inc       rbx
    cmp       rbx,	[rip+mc_decls.ss_nsymbols]
    jle       L5044
L5046:
    mov       rcx,	12
    call      mx_write.genbyte
    mov       rax,	[rip+mx_write.entrypoint]
    test      rax,	rax
    jz        L5050
    mov       rax,	[rip+mx_write.entrypoint]
    movsxd    rax,	dword ptr[rax+76]
    mov       rcx,	rax
    call      mx_write.genu32
    jmp       L5049
L5050:
    mov       rcx,	4294967295
    call      mx_write.genu32
L5049:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_write.roundsegment
mx_write.roundsegment:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    call      mc_genss.bufferlength
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	r13
    call      mlib.roundtoblock
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	r13
    call      mc_genss.buffercheck
    mov       rax,	rbx
    sub       rax,	rdi
    mov       rsi,	rax
    cmp       rsi,	0
    jle       L5054
L5052:
    lea       rax,	[r12+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	r14b
    dec       rsi
    jnz       L5052
L5054:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc mx_write.genbyte
mx_write.genbyte:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mx_write.dest]
    mov       rdx,	1
    call      mc_genss.buffercheck
    mov       rax,	[rip+mx_write.dest]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    inc       qword ptr[rax]
    mov       [r10],	dil
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mx_write.genu32
mx_write.genu32:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mx_write.dest]
    mov       rdx,	4
    call      mc_genss.buffercheck
    mov       rax,	[rip+mx_write.dest]
    lea       rax,	[rax+8]
    mov       r10,	[rax]
    add       qword ptr[rax],	4
    mov       [r10],	edi
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mx_write.genstring
mx_write.genstring:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      strlen
    inc       rax
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mx_write.genblock
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc mx_write.genblock
mx_write.genblock:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+mx_write.dest]
    mov       rdx,	rbx
    call      mc_genss.buffercheck
    mov       rax,	[rip+mx_write.dest]
    mov       rax,	[rax+8]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
    mov       rax,	[rip+mx_write.dest]
    lea       rax,	[rax+8]
    mov       r10,	rbx
    add       [rax],	r10
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_cli.main
cc_cli.main:
main:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      msyswin.start
    call      pcl.start
    call      mwindows.os_clock
    mov       [rip+cc_cli.startclock],	rax
    mov       rax,	[rip+cc_cli.startclock]
    mov       [rip+pc_decls.pstartclock],	rax
    call      cc_cli.starttiming
    call      cc_cli.initdata
    call      cc_cli.getinputoptions
    call      cc_cli.initsearchdirs
    movzx     rax,	byte ptr[rip+cc_cli.fverbose]
    cmp       rax,	3
    jnz       L5061
    call      cc_cli.showsearchdirs
L5061:
    call      cc_cli.initlogfile
    call      cc_cli.gettiming
    mov       [rip+cc_cli.inittime],	rax
    mov       al,	[rip+cc_cli.fverbose]
    test      al,	al
    jz        L5063
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11016]
    call      msys.m$print_setfmt
    mov       rcx,	[rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+cc_cli.outfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5063:
    mov       rcx,	[rip+cc_decls.inputfile]
    call      mlib.extractbasefile
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rip+pc_decls.$pmodulename],	rax
    call      cc_cli.do_loadmodule
    call      cc_cli.do_preprocess
    call      cc_cli.do_parsemodule
    call      cc_cli.do_genpcl
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	6
    jz        L5065
    cmp       rax,	7
    jz        L5066
    cmp       rax,	8
    jz        L5067
    cmp       rax,	10
    jz        L5068
    cmp       rax,	11
    jz        L5069
    cmp       rax,	12
    jz        L5070
    cmp       rax,	9
    jz        L5071
    cmp       rax,	13
    jz        L5072
    jmp       L5073
L5065:
    call      pc_run.pcl_runpcl
    jmp       L5064
L5066:
    call      cc_cli.do_genmcl
    jmp       L5064
L5067:
    call      cc_cli.do_asm
    jmp       L5064
L5068:
    call      cc_cli.do_obj
    jmp       L5064
L5069:
    call      cc_cli.do_dll
    jmp       L5064
L5070:
    call      cc_cli.do_exe
    jmp       L5064
L5071:
    call      cc_cli.do_mx
    jmp       L5064
L5072:
    call      cc_cli.do_run
    jmp       L5064
L5073:
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	7
    jl        L5075
    call      msys.m$print_startcon
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    lea       r10,	[rip+cc_cli.passnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11017]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5075:
L5064:
    movzx     rax,	byte ptr[rip+cc_cli.fverbose]
    cmp       rax,	2
    jl        L5077
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11018]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5077:
    mov       al,	[rip+cc_cli.fshowtiming]
    test      al,	al
    jz        L5079
    call      cc_cli.showtiming
L5079:
    call      cc_cli.closelogfile
    xor       ecx,	ecx
    call      exit
    xor       ecx,	ecx
    call      exit
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.do_preprocess
cc_cli.do_preprocess:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	2
    jnz       L5082
    movzx     rax,	byte ptr[rip+cc_cli.fstdout]
    mov       rcx,	[rip+cc_decls.inputfile]
    mov       rdx,	[rip+cc_cli.outfile]
    mov       r8,	rax
    call      cc_lex.lex_preprocess_only
    xor       ecx,	ecx
    call      exit
L5082:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.do_loadmodule
cc_cli.do_loadmodule:
#PROC1
#PROC2
#?>>
    .set cc_cli.do_loadmodule.path, -304
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	336
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+cc_cli.fverbose]
    cmp       rax,	3
    jnz       L5085
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11019]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5085:
    call      cc_cli.starttiming
    lea       rax,	[rip+L11020]
    lea       r10,	[rip+cc_decls.sourcefilenames]
    mov       [r10],	rax
    lea       rax,	[rip+L11021]
    lea       r10,	[rip+cc_decls.sourcefilepaths]
    mov       [r10],	rax
    lea       rax,	[rip+L11022]
    lea       r10,	[rip+cc_decls.sourcefiletext]
    mov       [r10],	rax
    lea       rax,	[rip+cc_decls.sourcefiletext]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      strlen
    lea       r10,	[rip+cc_decls.sourcefilesizes]
    mov       [r10],	eax
    lea       rcx,	[rip+L11023]
    call      cc_lex.addnamestr
    xor       ecx,	ecx
    mov       rdx,	rax
    mov       r8,	2
    call      cc_lib.createdupldef
    mov       [rip+cc_decls.stprogram],	rax
    mov       rcx,	[rip+cc_decls.inputfile]
    call      mlib.checkfile
    test      rax,	rax
    jnz       L5087
    lea       rcx,	[rip+L11024]
    mov       rdx,	[rip+cc_decls.inputfile]
    call      cc_support.loaderror
L5087:
    mov       rcx,	[rip+cc_decls.inputfile]
    mov       rdx,	[rip+cc_decls.inputfile]
    call      cc_support.loadsourcefile
    mov       [rip+cc_decls.mainfileno],	rax
    mov       rcx,	[rip+cc_decls.inputfile]
    call      mlib.extractbasefile
    mov       rdi,	rax
    mov       rcx,	rdi
    call      cc_lex.addnamestr
    mov       rcx,	[rip+cc_decls.stprogram]
    mov       rdx,	rax
    mov       r8,	3
    call      cc_lib.createdupldef
    mov       [rip+cc_decls.stmodule],	rax
    mov       rcx,	[rip+cc_decls.inputfile]
    call      mlib.extractpath
    lea       rcx,	[rbp + cc_cli.do_loadmodule.path]
    mov       rdx,	rax
    call      strcpy
    mov       al,	[rbp + cc_cli.do_loadmodule.path]
    test      al,	al
    jz        L5089
    inc       qword ptr[rip+cc_decls.nsearchdirs]
    mov       rbx,	[rip+cc_decls.nsearchdirs]
    cmp       rbx,	2
    jl        L5092
L5090:
    lea       rax,	[rip+cc_decls.searchdirs]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-16]
    lea       r10,	[rip+cc_decls.searchdirs]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
    dec       rbx
    cmp       rbx,	2
    jge       L5090
L5092:
    lea       rcx,	[rbp + cc_cli.do_loadmodule.path]
    call      mlib.pcm_copyheapstring
    lea       r10,	[rip+cc_decls.searchdirs]
    mov       [r10],	rax
L5089:
    call      cc_cli.gettiming
    mov       [rip+cc_cli.loadtime],	rax
#---------------
    add       rsp,	336
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_cli.do_parsemodule
cc_cli.do_parsemodule:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_cli.starttiming
    call      cc_parse.parsemodule
    call      cc_cli.gettiming
    mov       rdi,	rax
    mov       [rip+cc_cli.parsetime],	rax
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_cli.do_genpcl
cc_cli.do_genpcl:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	5
    jl        L5094
L5096:
    call      cc_cli.starttiming
    call      cc_genpcl.codegen_pcl
    call      cc_cli.gettiming
    mov       [rip+cc_cli.pcltime],	rax
    mov       al,	[rip+pc_decls.fregoptim]
    test      al,	al
    jnz       L5099
    mov       al,	[rip+pc_decls.fpeephole]
    test      al,	al
    jz        L5098
L5099:
    call      pc_reduce.pcl_reducetest
L5098:
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	5
    jnz       L5101
    mov       rcx,	[rip+cc_cli.outfile]
    call      pc_api.pcl_writepcl
L5101:
L5094:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.do_genmcl
cc_cli.do_genmcl:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	7
    jl        L5102
L5104:
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	7
    jnz       L5106
    mov       rcx,	[rip+cc_cli.outfile]
    mov       rdx,	16705
    call      pc_api.pcl_writeasm
L5106:
L5102:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.do_asm
cc_cli.do_asm:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	8
    jl        L5107
L5109:
    mov       rcx,	[rip+cc_cli.outfile]
    mov       rdx,	16705
    call      pc_api.pcl_writeasm
L5107:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.do_obj
cc_cli.do_obj:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	10
    jnz       L5110
L5112:
    mov       rcx,	[rip+cc_cli.outfile]
    call      pc_api.pcl_writeobj
L5110:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.do_dll
cc_cli.do_dll:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	11
    jnz       L5113
L5115:
    mov       rcx,	[rip+cc_cli.outfile]
    call      pc_api.pcl_writedll
L5113:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.do_exe
cc_cli.do_exe:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	12
    jnz       L5116
L5118:
    mov       rcx,	[rip+cc_cli.outfile]
    call      pc_api.pcl_writeexe
L5116:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.do_mx
cc_cli.do_mx:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	9
    jnz       L5119
L5121:
    mov       rcx,	[rip+cc_cli.outfile]
    call      pc_api.pcl_writemx
L5119:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.do_run
cc_cli.do_run:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	13
    jnz       L5122
L5124:
    call      pc_api.pcl_exec
L5122:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.initlogfile
cc_cli.initlogfile:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+cc_cli.debugmode]
    cmp       rax,	2
    jl        L5127
    lea       rcx,	[rip+L11025]
    call      remove
    lea       rcx,	[rip+L11025]
    lea       rdx,	[rip+L11026]
    call      fopen
    mov       [rip+cc_decls.logdev],	rax
L5127:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.closelogfile
cc_cli.closelogfile:
#PROC1
#PROC2
#?>>
    .set cc_cli.closelogfile.str, -104
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	144
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+cc_cli.debugmode]
    cmp       rax,	2
    jl        L5128
L5130:
    mov       al,	[rip+cc_cli.fshowmcl]
    test      al,	al
    jz        L5132
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	7
    jl        L5132
    mov       rcx,	[rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11027]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rip+cc_decls.logdev]
    call      msys.m$print_startfile
    xor       ecx,	ecx
    mov       rdx,	16705
    call      pc_api.pcl_writeasm
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5132:
    mov       al,	[rip+cc_cli.fshowpcl]
    test      al,	al
    jz        L5134
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	5
    jl        L5134
    mov       rcx,	[rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11028]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rip+cc_decls.logdev]
    call      msys.m$print_startfile
    xor       ecx,	ecx
    call      pc_api.pcl_writepcl
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       al,	[rip+cc_cli.fshowpst]
    test      al,	al
    jz        L5136
    lea       rcx,	[rip+L11029]
    call      pc_api.pcl_writepst
    lea       rcx,	[rip+L11029]
    mov       rdx,	[rip+cc_decls.logdev]
    call      cc_lib.addtolog
L5136:
L5134:
    call      cc_cli.showast
    mov       al,	[rip+cc_cli.fshowst]
    test      al,	al
    jz        L5138
    lea       rcx,	[rip+L11030]
    call      cc_cli.showst
L5138:
    mov       al,	[rip+cc_cli.fshowstflat]
    test      al,	al
    jz        L5140
    lea       rcx,	[rip+L11031]
    call      cc_cli.showstflat
L5140:
    mov       al,	[rip+cc_cli.fshowtypes]
    test      al,	al
    jz        L5142
    mov       rcx,	[rip+cc_decls.logdev]
    call      cc_show.printmodelist
L5142:
    mov       rcx,	[rip+cc_decls.logdev]
    call      fclose
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11032]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      mwindows.os_getch
    cmp       rax,	27
    jnz       L5144
    xor       ecx,	ecx
    call      exit
L5144:
    lea       rcx,	[rbp + cc_cli.closelogfile.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L11033]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11034]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rip+L11035]
    call      mlib.checkfile
    test      rax,	rax
    jz        L5146
    lea       rcx,	[rbp + cc_cli.closelogfile.str]
    xor       edx,	edx
    xor       r8d,	r8d
    call      mwindows.os_execwait
    jmp       L5145
L5146:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11036]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11037]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5145:
L5128:
#---------------
    add       rsp,	144
    pop       rbp
    ret       
# End 
# Proc cc_cli.initdata
cc_cli.initdata:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      mlib.pcm_init
    call      cc_lex.lexsetup
    call      cc_lib.inittypetables
    call      cc_lib.initcclib
    xor       eax,	eax
    mov       [rip+cc_decls.nlibfiles],	rax
    inc       qword ptr[rip+cc_decls.nlibfiles]
    mov       rax,	[rip+cc_decls.nlibfiles]
    lea       r10,	[rip+L11038]
    lea       r11,	[rip+cc_decls.libfiles]
    mov       [r11 + rax*8],	r10
    inc       qword ptr[rip+cc_decls.nlibfiles]
    mov       rax,	[rip+cc_decls.nlibfiles]
    lea       r10,	[rip+L11039]
    lea       r11,	[rip+cc_decls.libfiles]
    mov       [r11 + rax*8],	r10
    inc       qword ptr[rip+cc_decls.nlibfiles]
    mov       rax,	[rip+cc_decls.nlibfiles]
    lea       r10,	[rip+L11040]
    lea       r11,	[rip+cc_decls.libfiles]
    mov       [r11 + rax*8],	r10
    inc       qword ptr[rip+cc_decls.nlibfiles]
    mov       rax,	[rip+cc_decls.nlibfiles]
    lea       r10,	[rip+L11041]
    lea       r11,	[rip+cc_decls.libfiles]
    mov       [r11 + rax*8],	r10
    lea       rax,	[rip+cc_cli.cgetsourceinfo]
    mov       [rip+pc_decls.igetmsourceinfo],	rax
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.cgetsourceinfo
cc_cli.cgetsourceinfo:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	rcx
    shr       rax,	24
    and       rax,	511
    lea       r10,	[rip+cc_decls.sourcefilenames]
    mov       r10,	[r10 + rax*8]
    mov       [rdx],	r10
    lea       rax,	[rip+L11042]
    mov       [r8],	rax
    mov       rax,	rcx
    and       rax,	16777215
L5148:
#---------------
    ret       
# End 
# Proc cc_cli.initsearchdirs
cc_cli.initsearchdirs:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    inc       qword ptr[rip+cc_decls.nsearchdirs]
    mov       rax,	[rip+cc_decls.nsearchdirs]
    lea       r10,	[rip+L11043]
    lea       r11,	[rip+cc_decls.searchdirs]
    mov       [r11 + rax*8-8],	r10
    inc       qword ptr[rip+cc_decls.nsearchdirs]
    mov       rax,	[rip+cc_decls.nsearchdirs]
    lea       r10,	[rip+L11044]
    lea       r11,	[rip+cc_decls.searchdirs]
    mov       [r11 + rax*8-8],	r10
    call      mwindows.os_gethostname
    mov       rcx,	rax
    call      mlib.extractpath
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    inc       qword ptr[rip+cc_decls.nsearchdirs]
    mov       r10,	[rip+cc_decls.nsearchdirs]
    lea       r11,	[rip+cc_decls.searchdirs]
    mov       [r11 + r10*8-8],	rax
    mov       rdi,	1
    mov       rax,	[rip+cc_decls.nincludepaths]
    cmp       rax,	1
    jl        L5152
L5150:
    lea       rax,	[rip+cc_decls.includepaths]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       al,	[rax]
    test      al,	al
    jz        L5154
    lea       rax,	[rip+cc_decls.includepaths]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    inc       qword ptr[rip+cc_decls.nsearchdirs]
    mov       r10,	[rip+cc_decls.nsearchdirs]
    lea       r11,	[rip+cc_decls.searchdirs]
    mov       [r11 + r10*8-8],	rax
L5154:
    inc       rdi
    cmp       rdi,	[rip+cc_decls.nincludepaths]
    jle       L5150
L5152:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_cli.showsearchdirs
cc_cli.showsearchdirs:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11045]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       al,	[rip+cc_cli.dointheaders]
    test      al,	al
    jz        L5157
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11046]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5157:
    mov       rdi,	1
    mov       rax,	[rip+cc_decls.nsearchdirs]
    cmp       rax,	1
    jl        L5160
L5158:
    lea       rax,	[rip+cc_decls.searchdirs]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       al,	[rax]
    test      al,	al
    jz        L5162
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11047]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.searchdirs]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L5161
L5162:
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11048]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5161:
    inc       rdi
    cmp       rdi,	[rip+cc_decls.nsearchdirs]
    jle       L5158
L5160:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_cli.showast
cc_cli.showast:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       al,	[rip+cc_cli.fshowast]
    test      al,	al
    jz        L5165
    mov       rcx,	[rip+cc_decls.logdev]
    lea       rdx,	[rip+L11049]
    call      cc_show.printcode
    mov       rcx,	[rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L5165:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.showstflat
cc_cli.showstflat:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11050]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rip+cc_decls.logdev]
    call      cc_show.printstflat
    mov       rcx,	[rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_cli.showst
cc_cli.showst:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+cc_decls.logdev]
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11050]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	[rip+cc_decls.logdev]
    mov       rdx,	[rip+cc_decls.stmodule]
    xor       r8d,	r8d
    call      cc_show.printst
    mov       rcx,	[rip+cc_decls.logdev]
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_cli.showfiles
cc_cli.showfiles:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11051]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	1
    mov       rax,	[rip+cc_decls.nsourcefiles]
    cmp       rax,	1
    jl        L5171
L5169:
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    lea       rcx,	[rip+L11052]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.sourcefilepaths]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.sourcefilenames]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11053]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.sourcefilesizes]
    mov       r10,	rdi
    movsxd    rax,	dword ptr[rax + r10*4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       rdi
    cmp       rdi,	[rip+cc_decls.nsourcefiles]
    jle       L5169
L5171:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_cli.showtime
cc_cli.showtime:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11054]
    call      msys.m$print_setfmt
    mov       rcx,	rdi
    lea       rdx,	[rip+L11055]
    call      msys.m$print_str
    mov       rcx,	rbx
    lea       rdx,	[rip+L11056]
    call      msys.m$print_i64
    mov       rax,	rbx
    cvtsi2sd  XMM4,	rax
    mulsd     XMM4,	[rip+L11057]
    mov       rax,	[rip+cc_cli.compiletime]
    cvtsi2sd  XMM5,	rax
    divsd     XMM4,	XMM5
    movq      XMM0,	XMM4
    lea       rdx,	[rip+L11058]
    call      msys.m$print_r64
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_cli.showtiming
cc_cli.showtiming:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      mwindows.os_clock
    sub       rax,	[rip+cc_cli.startclock]
    mov       [rip+cc_cli.compiletime],	rax
    lea       rcx,	[rip+L11059]
    mov       rdx,	[rip+cc_cli.inittime]
    call      cc_cli.showtime
    lea       rcx,	[rip+L11060]
    mov       rdx,	[rip+cc_cli.loadtime]
    call      cc_cli.showtime
    lea       rcx,	[rip+L11061]
    mov       rdx,	[rip+cc_cli.parsetime]
    call      cc_cli.showtime
    lea       rcx,	[rip+L11062]
    mov       rdx,	[rip+cc_cli.pcltime]
    call      cc_cli.showtime
    lea       rcx,	[rip+L11063]
    mov       rdx,	[rip+pc_decls.mcltime]
    call      cc_cli.showtime
    lea       rcx,	[rip+L11064]
    mov       rdx,	[rip+pc_decls.sstime]
    call      cc_cli.showtime
    lea       rcx,	[rip+L11065]
    mov       rdx,	[rip+pc_decls.exetime]
    call      cc_cli.showtime
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11066]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11067]
    mov       rdx,	[rip+cc_cli.compiletime]
    call      cc_cli.showtime
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.getinputoptions
cc_cli.getinputoptions:
#PROC1
#PROC2
#?>>
    .set cc_cli.getinputoptions.paramno, -8
    .set cc_cli.getinputoptions.name, -16
    .set cc_cli.getinputoptions.value, -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
#---------------
#PROC3
#PROC4
    mov       rax,	1
    mov       [rbp + cc_cli.getinputoptions.paramno],	rax
    xor       rsi,	rsi
    mov       al,	[rip+pcl.pc_userunpcl]
    test      al,	al
    jz        L5176
    mov       al,	6
    mov       [rip+cc_cli.cc_pass],	al
    xor       eax,	eax
    mov       [rip+cc_cli.fverbose],	al
L5176:
    call      mwindows.os_gethostname
    mov       rcx,	rax
    call      mlib.extractfile
    mov       rcx,	rax
    lea       rdx,	[rip+L11068]
    call      mlib.eqstring
    test      rax,	rax
    jz        L5178
    xor       eax,	eax
    mov       [rip+cc_cli.fverbose],	al
    mov       rcx,	17
    lea       rdx,	[rip+L11069]
    call      cc_cli.do_option
L5178:
L5179:
    lea       rcx,	[rbp + cc_cli.getinputoptions.paramno]
    lea       rdx,	[rbp + cc_cli.getinputoptions.name]
    lea       r8,	[rbp + cc_cli.getinputoptions.value]
    lea       r9,	[rip+L11070]
    call      mlib.nextcmdparamnew
    mov       rdi,	rax
    mov       rax,	rdi
    cmp       rax,	1
    jz        L5182
    cmp       rax,	2
    jz        L5183
    cmp       rax,	3
    jz        L5184
    test      rax,	rax
    jz        L5185
    jmp       L5186
L5182:
    mov       rcx,	[rbp + cc_cli.getinputoptions.name]
    call      mlib.convlcstring
    mov       rbx,	1
    mov       r12,	49
    cmp       r12,	1
    jl        L5190
L5187:
    lea       rax,	[rip+cc_cli.optionnames]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	[rbp + cc_cli.getinputoptions.name]
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L5192
    mov       rcx,	rbx
    mov       rdx,	[rbp + cc_cli.getinputoptions.value]
    call      cc_cli.do_option
    jmp       L5189
L5192:
    inc       rbx
    cmp       rbx,	r12
    jle       L5187
L5190:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11071]
    call      msys.m$print_str_nf
    mov       rcx,	[rbp + cc_cli.getinputoptions.name]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L5189:
    jmp       L5181
L5183:
    mov       rax,	[rip+cc_decls.inputfile]
    test      rax,	rax
    jz        L5194
    lea       rcx,	[rip+L11072]
    lea       rdx,	[rip+L11073]
    call      cc_support.loaderror
L5194:
    mov       rcx,	[rbp + cc_cli.getinputoptions.name]
    call      mlib.pcm_copyheapstring
    mov       [rip+cc_decls.inputfile],	rax
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	13
    jz        L5197
    cmp       rax,	6
    jnz       L5196
L5197:
    mov       rax,	[rbp + cc_cli.getinputoptions.paramno]
    dec       rax
    add       rax,	[rip+msys.$cmdskip]
    mov       [rip+cc_cli.cmdskip],	rax
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	6
    setz      al
    movzx     eax,	al
    mov       [rip+cc_decls.pci_target],	al
    jmp       L5180
L5196:
    jmp       L5181
L5184:
    mov       rax,	[rip+cc_decls.nlibfiles]
    cmp       rax,	200
    jl        L5199
    lea       rcx,	[rip+L11074]
    lea       rdx,	[rip+L11075]
    call      cc_support.loaderror
L5199:
    mov       rcx,	[rbp + cc_cli.getinputoptions.name]
    call      mlib.pcm_copyheapstring
    inc       qword ptr[rip+cc_decls.nlibfiles]
    mov       r10,	[rip+cc_decls.nlibfiles]
    lea       r11,	[rip+cc_decls.libfiles]
    mov       [r11 + r10*8],	rax
    jmp       L5181
L5185:
    jmp       L5180
L5186:
L5181:
    jmp       L5179
L5180:
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    test      rax,	rax
    jnz       L5201
    mov       al,	12
    mov       [rip+cc_cli.cc_pass],	al
L5201:
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	11
    jz        L5204
    cmp       rax,	10
    jnz       L5203
L5204:
    mov       al,	2
    mov       [rip+cc_cli.highmem],	al
    jmp       L5202
L5203:
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	9
    jz        L5206
    cmp       rax,	13
    jnz       L5205
L5206:
    xor       eax,	eax
    mov       [rip+cc_cli.highmem],	al
L5205:
L5202:
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    lea       r10,	[rip+cc_cli.extnames]
    mov       r10,	[r10 + rax*8-8]
    mov       [rip+cc_cli.outext],	r10
    movzx     rax,	byte ptr[rip+cc_cli.cc_pass]
    cmp       rax,	7
    jz        L5209
    cmp       rax,	8
    jnz       L5208
L5209:
    mov       rax,	[rip+mc_writegas.asmext]
    mov       [rip+cc_cli.outext],	rax
L5208:
    mov       rax,	[rip+cc_decls.inputfile]
    test      rax,	rax
    jnz       L5211
    mov       al,	[rip+cc_cli.fwriteheaders]
    test      al,	al
    jnz       L5211
    call      cc_cli.showcaption
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11076]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11077]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rax,	[rip+msys.cmdparams]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11078]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11079]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rax,	[rip+msys.cmdparams]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11080]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11081]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rax,	[rip+msys.cmdparams]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11082]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11083]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rax,	[rip+msys.cmdparams]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11084]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
L5211:
    mov       al,	[rip+cc_cli.fwriteheaders]
    test      al,	al
    jz        L5213
    call      cc_headers.writeheaders
    mov       rcx,	20
    call      exit
L5213:
    mov       rax,	[rip+cc_cli.outfile]
    test      rax,	rax
    jnz       L5215
    mov       rcx,	[rip+cc_decls.inputfile]
    mov       rdx,	[rip+cc_cli.outext]
    call      mlib.changeext
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rip+cc_cli.outfile],	rax
L5215:
    movzx     rax,	byte ptr[rip+cc_cli.fshortnames]
    movzx     r10,	byte ptr[rip+cc_cli.highmem]
    mov       rcx,	r10
    mov       rdx,	-1
    mov       r8,	rax
    call      pc_api.pcl_setflags
    mov       rcx,	[rip+cc_cli.cmdskip]
    xor       edx,	edx
    call      pc_api.pcl_cmdskip
#---------------
    add       rsp,	64
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_cli.do_option
cc_cli.do_option:
#PROC1
#PROC2
#?>>
    .set cc_cli.do_option.str, -304
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	336
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_cli.optvars]
    mov       r10,	rsi
    mov       rbx,	[rax + r10*8-8]
    test      rbx,	rbx
    jz        L5218
    lea       rax,	[rip+cc_cli.optvalues]
    mov       r10,	rsi
    mov       al,	[rax + r10-1]
    mov       [rbx],	al
    mov       rax,	rsi
    cmp       rax,	1
    jl        L5220
    cmp       rax,	9
    jg        L5220
    mov       al,	1
    or        [rip+cc_cli.debugmode],	al
L5220:
    mov       rax,	rsi
    cmp       rax,	25
    jl        L5222
    cmp       rax,	33
    jg        L5222
    mov       al,	2
    or        [rip+cc_cli.debugmode],	al
L5222:
    cmp       rsi,	8
    jnz       L5224
    mov       rax,	[rip+cc_decls.inputfile]
    test      rax,	rax
    jz        L5224
    lea       rcx,	[rip+L11085]
    lea       rdx,	[rip+L11086]
    call      cc_support.loaderror
L5224:
    mov       rax,	rsi
    cmp       rax,	3
    jz        L5227
    cmp       rax,	7
    jnz       L5226
L5227:
    mov       al,	1
    mov       [rip+cc_decls.pci_target],	al
L5226:
    jmp       L5216
L5218:
    mov       rax,	rsi
    cmp       rax,	23
    jz        L5229
    cmp       rax,	41
    jz        L5230
    cmp       rax,	42
    jz        L5230
    cmp       rax,	45
    jz        L5231
    cmp       rax,	20
    jz        L5232
    jmp       L5233
L5229:
    mov       rax,	[rip+cc_decls.nincludepaths]
    cmp       rax,	20
    jle       L5235
    lea       rcx,	[rip+L11087]
    lea       rdx,	[rip+L11088]
    call      cc_support.loaderror
L5235:
    mov       rcx,	r12
    call      strlen
    mov       rdi,	rax
    lea       rax,	[r12 + rdi]
    sub       rax,	1
    movzx     rax,	byte ptr[rax]
    cmp       rax,	92
    jz        L5237
    cmp       rax,	47
    jnz       L5238
L5237:
    jmp       L5236
L5238:
    lea       rcx,	[rbp + cc_cli.do_option.str]
    mov       rdx,	r12
    call      strcpy
    lea       rcx,	[rbp + cc_cli.do_option.str]
    lea       rdx,	[rip+L11089]
    call      strcat
    lea       rax,	[rbp + cc_cli.do_option.str]
    mov       r12,	rax
L5236:
    mov       rcx,	r12
    call      mlib.pcm_copyheapstring
    inc       qword ptr[rip+cc_decls.nincludepaths]
    mov       r10,	[rip+cc_decls.nincludepaths]
    lea       r11,	[rip+cc_decls.includepaths]
    mov       [r11 + r10*8-8],	rax
    jmp       L5228
L5230:
    call      cc_cli.showhelp
    jmp       L5228
L5231:
    mov       rcx,	r12
    mov       rdx,	[rip+cc_cli.outext]
    call      mlib.addext
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       [rip+cc_cli.outfile],	rax
    jmp       L5228
L5232:
    xor       eax,	eax
    mov       [rip+pc_decls.fpeephole],	al
    mov       [rip+pc_decls.fregoptim],	al
L5233:
L5228:
L5216:
#---------------
    add       rsp,	336
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_cli.showincludepaths
cc_cli.showincludepaths:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11090]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+cc_decls.nincludepaths]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	1
    mov       rax,	[rip+cc_decls.nincludepaths]
    cmp       rax,	1
    jl        L5242
L5240:
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    lea       rax,	[rip+cc_decls.includepaths]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       rdi
    cmp       rdi,	[rip+cc_decls.nincludepaths]
    jle       L5240
L5242:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_cli.showhelp
cc_cli.showhelp:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_cli.showcaption
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11091]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	23
    call      exit
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.showextrainfo
cc_cli.showextrainfo:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    mov       rcx,	[rip+cc_cli.showextrainfo.infotext]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	24
    call      exit
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.showcaption
cc_cli.showcaption:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11092]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11093]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11094]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.starttiming
cc_cli.starttiming:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      mwindows.os_clock
    mov       [rip+cc_cli.ttt],	rax
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_cli.gettiming
cc_cli.gettiming:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      mwindows.os_clock
    sub       rax,	[rip+cc_cli.ttt]
L5247:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_lex.lex_preprocess_only
cc_lex.lex_preprocess_only:
#PROC1
#PROC2
#?>>
    .set cc_lex.lex_preprocess_only.outfile, 80
    .set cc_lex.lex_preprocess_only.toconsole, 88
    .set cc_lex.lex_preprocess_only.hashtot, -8
    .set cc_lex.lex_preprocess_only.symtot, -16
    .set cc_lex.lex_preprocess_only.f, -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
#---------------
#PROC3
#PROC4
    mov       rax,	1
    mov       [rip+cc_lex.dowhitespace],	rax
    mov       rcx,	r15
    mov       rdx,	r15
    call      cc_support.loadsourcefile
    mov       r12,	rax
    lea       rax,	[rip+cc_decls.sourcefiletext]
    mov       r10,	r12
    mov       rdi,	[rax + r10*8]
    lea       rax,	[rip+cc_decls.sourcefilesizes]
    mov       r10,	r12
    movsxd    rax,	dword ptr[rax + r10*4]
    mov       r13,	rax
    xor       eax,	eax
    mov       rbx,	rax
    mov       rsi,	rax
    xor       eax,	eax
    mov       [rbp + cc_lex.lex_preprocess_only.symtot],	rax
    mov       [rbp + cc_lex.lex_preprocess_only.hashtot],	rax
    call      mwindows.os_clock
    mov       r14,	rax
    mov       rax,	[rip+cc_lex.lex_preprocess_only.dest]
    mov       [rip+cc_lex.destcopy],	rax
    mov       rcx,	[rip+cc_lex.lex_preprocess_only.dest]
    call      mlib.gs_init
    mov       [rip+cc_lex.lxsptr],	rdi
    mov       rax,	[rip+cc_lex.lxsptr]
    mov       [rip+cc_lex.lxstart],	rax
    mov       eax,	1
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+16],	eax
    mov       rcx,	1
    call      cc_lex.setfileno
    xor       eax,	eax
    mov       [rip+cc_lex.ifcondlevel],	rax
    lea       rcx,	[rip+L11095]
    mov       rdx,	1
    call      cc_lex.stacksourcefile
    mov       al,	56
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5249:
    call      cc_lex.lexm
    inc       rbx
    lea       rcx,	[rip+cc_decls.nextlx]
    mov       rdx,	[rip+cc_lex.lex_preprocess_only.dest]
    xor       r8d,	r8d
    call      cc_lex.emittoken
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	57
    jnz       L5249
    mov       rax,	[rip+cc_lex.ifcondlevel]
    test      rax,	rax
    jz        L5253
    lea       rcx,	[rip+L11096]
    call      cc_lex.lxerror
L5253:
    lea       rax,	[rip+cc_lex.showtokens]
    test      rax,	rax
    jz        L5255
    mov       rax,	[rbp + cc_lex.lex_preprocess_only.toconsole]
    test      rax,	rax
    jz        L5257
    mov       rcx,	[rip+cc_lex.lex_preprocess_only.dest]
    xor       edx,	edx
    call      mlib.gs_println
    jmp       L5256
L5257:
    mov       rcx,	[rbp + cc_lex.lex_preprocess_only.outfile]
    lea       rdx,	[rip+L11097]
    call      fopen
    mov       [rbp + cc_lex.lex_preprocess_only.f],	rax
    mov       rcx,	[rip+cc_lex.lex_preprocess_only.dest]
    mov       rdx,	[rbp + cc_lex.lex_preprocess_only.f]
    call      mlib.gs_println
    mov       rcx,	[rbp + cc_lex.lex_preprocess_only.f]
    call      fclose
L5256:
L5255:
#---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.lexreadtoken
cc_lex.lexreadtoken:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    xor       eax,	eax
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+23],	al
    jmp       L5260
L5259:
    inc       qword ptr[rip+cc_lex.lxsptr]
L5260:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	32
    jz        L5259
    cmp       rax,	9
    jz        L5259
L5262:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	240
    jae       L5265
    lea       r10,	[rip+L5264]
    jmp       [r10 + rax*8]
    .data
L5264:
    .quad     L5399
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5384
    .quad     L5385
    .quad     L5265
    .quad     L5403
    .quad     L5393
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5384
    .quad     L5394
    .quad     L5383
    .quad     L5292
    .quad     L5266
    .quad     L5356
    .quad     L5377
    .quad     L5382
    .quad     L5322
    .quad     L5323
    .quad     L5347
    .quad     L5336
    .quad     L5316
    .quad     L5341
    .quad     L5308
    .quad     L5350
    .quad     L5283
    .quad     L5279
    .quad     L5279
    .quad     L5279
    .quad     L5279
    .quad     L5279
    .quad     L5279
    .quad     L5279
    .quad     L5279
    .quad     L5279
    .quad     L5318
    .quad     L5317
    .quad     L5363
    .quad     L5359
    .quad     L5370
    .quad     L5334
    .quad     L5398
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5324
    .quad     L5296
    .quad     L5325
    .quad     L5331
    .quad     L5266
    .quad     L5265
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5266
    .quad     L5306
    .quad     L5326
    .quad     L5307
    .quad     L5335
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5265
    .quad     L5404
    .text
L5266:
#cc_lex.lexreadtoken.doname:
L5267:
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	1
    mov       [rip+cc_lex.lxsvalue],	rax
    mov       rax,	[rip+cc_lex.lxsvalue]
    movzx     rax,	byte ptr[rax]
    mov       rbx,	rax
    jmp       L5269
L5268:
    mov       rax,	rbx
    shl       rax,	4
    sub       rax,	rbx
    add       rax,	rdi
    mov       rbx,	rax
L5269:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    mov       rdi,	rax
    lea       r10,	[rip+cc_lex.alphamap]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L5268
    dec       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	67
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	[rip+cc_lex.lxsvalue]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
    mov       rax,	rdi
    cmp       rax,	39
    jz        L5272
    cmp       rax,	34
    jnz       L5273
L5272:
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+24]
    cmp       rax,	1
    jnz       L5275
    mov       rax,	[rip+cc_lex.lxsvalue]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	108
    jz        L5277
    cmp       rax,	76
    jz        L5277
    cmp       rax,	117
    jz        L5277
    cmp       rax,	85
    jnz       L5278
L5277:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       rcx,	rdi
    mov       rdx,	1
    call      cc_lex.lxreadstring
    jmp       L5258
L5278:
L5276:
L5275:
L5273:
L5271:
    mov       rax,	rbx
    shl       rax,	5
    sub       rax,	rbx
    mov       [rip+cc_lex.lxhashvalue],	rax
    call      cc_lex.lookup
    jmp       L5258
L5279:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	32
    jz        L5281
    cmp       rax,	41
    jz        L5281
    cmp       rax,	13
    jz        L5281
    cmp       rax,	44
    jz        L5281
    cmp       rax,	59
    jnz       L5282
L5281:
    mov       al,	59
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    mov       al,	3
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	1
    movzx     rax,	byte ptr[rax]
    sub       rax,	48
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10],	rax
    mov       eax,	1
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	1
    sub       rax,	[rip+cc_lex.lxstart]
    mov       rcx,	rax
    call      cc_lex.setnumberoffset
    jmp       L5280
L5282:
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	1
    mov       rcx,	rax
    call      cc_lex.readdecimal
L5280:
    jmp       L5258
L5283:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    sub       rax,	10
    cmp       rax,	116
    jae       L5286
    lea       r10,	[rip+L5285]
    jmp       [r10 + rax*8]
    .data
L5285:
    .quad     L5291
    .quad     L5286
    .quad     L5286
    .quad     L5291
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5291
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5291
    .quad     L5286
    .quad     L5286
    .quad     L5291
    .quad     L5286
    .quad     L5286
    .quad     L5291
    .quad     L5286
    .quad     L5289
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5291
    .quad     L5291
    .quad     L5286
    .quad     L5291
    .quad     L5286
    .quad     L5291
    .quad     L5286
    .quad     L5286
    .quad     L5288
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5290
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5290
    .quad     L5286
    .quad     L5286
    .quad     L5287
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5291
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5288
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5290
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5290
    .quad     L5286
    .quad     L5286
    .quad     L5287
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5286
    .quad     L5291
    .text
L5287:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	2
    mov       rcx,	rax
    call      cc_lex.readhex
    jmp       L5258
L5288:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	2
    mov       rcx,	rax
    call      cc_lex.readbinary
    jmp       L5258
L5289:
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	1
    mov       r10,	[rip+cc_lex.lxsptr]
    sub       r10,	1
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	1
    mov       r9,	10
    call      cc_lex.readrealnumber
    jmp       L5258
L5290:
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	1
    mov       rcx,	rax
    call      cc_lex.readdecimal
    jmp       L5258
L5291:
    mov       al,	59
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    mov       al,	3
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    xor       eax,	eax
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10],	rax
    mov       eax,	1
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	1
    sub       rax,	[rip+cc_lex.lxstart]
    mov       rcx,	rax
    call      cc_lex.setnumberoffset
    jmp       L5258
L5286:
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	1
    mov       rcx,	rax
    call      cc_lex.readoctal
    jmp       L5258
L5284:
    jmp       L5262
L5292:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	56
    jnz       L5294
    mov       al,	4
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5294:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	35
    jnz       L5295
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	7
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5295:
    mov       al,	5
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5293:
    jmp       L5262
L5296:
L5297:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	13
    jz        L5299
    cmp       rax,	10
    jz        L5299
    cmp       rax,	32
    jz        L5300
    cmp       rax,	9
    jz        L5300
    jmp       L5301
L5299:
    jmp       L5298
L5300:
    inc       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5297
L5301:
    mov       al,	22
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5298:
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	1
    mov       r10b,	32
    mov       [rax],	r10b
    lea       rax,	[rip+cc_decls.nextlx]
    lea       rax,	[rax+16]
    inc       dword ptr[rax]
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	13
    jz        L5303
    cmp       rax,	10
    jz        L5304
    jmp       L5305
L5303:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       r10b,	32
    mov       [rax],	r10b
    jmp       L5302
L5304:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       r10b,	32
    mov       [rax],	r10b
L5305:
L5302:
    jmp       L5262
L5306:
    mov       al,	17
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5307:
    mov       al,	18
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5308:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    sub       rax,	46
    cmp       rax,	12
    jae       L5311
    lea       r10,	[rip+L5310]
    jmp       [r10 + rax*8]
    .data
L5310:
    .quad     L5312
    .quad     L5311
    .quad     L5315
    .quad     L5315
    .quad     L5315
    .quad     L5315
    .quad     L5315
    .quad     L5315
    .quad     L5315
    .quad     L5315
    .quad     L5315
    .quad     L5315
    .text
L5312:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	46
    jnz       L5314
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	21
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5313
L5314:
    dec       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	2
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5313:
    jmp       L5258
L5315:
    dec       qword ptr[rip+cc_lex.lxsptr]
    mov       rcx,	[rip+cc_lex.lxsptr]
    mov       rdx,	[rip+cc_lex.lxsptr]
    xor       r8d,	r8d
    mov       r9,	10
    call      cc_lex.readrealnumber
    jmp       L5258
L5311:
    mov       al,	2
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5309:
    jmp       L5262
L5316:
    mov       al,	8
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5317:
    mov       al,	9
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5318:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	61
    jnz       L5321
L5320:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	11
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5319
L5321:
    mov       al,	10
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5319:
    jmp       L5258
L5322:
    mov       al,	13
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5323:
    mov       al,	14
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5324:
    mov       al,	15
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5325:
    mov       al,	16
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5326:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	124
    jz        L5328
    cmp       rax,	61
    jz        L5329
    jmp       L5330
L5328:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	31
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5327
L5329:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	51
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5327
L5330:
    mov       al,	28
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5327:
    jmp       L5258
L5331:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	61
    jnz       L5333
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	53
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5332
L5333:
    mov       al,	30
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5332:
    jmp       L5258
L5334:
    mov       al,	19
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5335:
    mov       al,	35
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5336:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	43
    jz        L5338
    cmp       rax,	61
    jz        L5339
    jmp       L5340
L5338:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	37
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5337
L5339:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	46
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5337
L5340:
    mov       al,	23
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5337:
    jmp       L5258
L5341:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	45
    jz        L5343
    cmp       rax,	62
    jz        L5344
    cmp       rax,	61
    jz        L5345
    jmp       L5346
L5343:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	38
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5342
L5344:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	3
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5342
L5345:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	47
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5342
L5346:
    mov       al,	24
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5342:
    jmp       L5258
L5347:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	61
    jnz       L5349
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	48
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5348
L5349:
    mov       al,	25
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5348:
    jmp       L5258
L5350:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	47
    jz        L5352
    cmp       rax,	42
    jz        L5353
    cmp       rax,	61
    jz        L5354
    jmp       L5355
L5352:
    call      cc_lex.readlinecomment
    mov       al,	56
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    xor       eax,	eax
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
    jmp       L5258
L5353:
    call      cc_lex.readblockcomment
    jmp       L5351
L5354:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	49
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5355:
    mov       al,	26
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5351:
    jmp       L5262
L5356:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	61
    jnz       L5358
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	50
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5357
L5358:
    mov       al,	27
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5357:
    jmp       L5258
L5359:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	61
    jnz       L5362
L5361:
    mov       al,	40
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    inc       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5360
L5362:
    mov       al,	11
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5360:
    jmp       L5258
L5363:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	61
    jz        L5365
    cmp       rax,	60
    jz        L5366
    jmp       L5367
L5365:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	43
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5364
L5366:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	61
    jnz       L5369
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	54
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5368
L5369:
    mov       al,	33
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5368:
    jmp       L5364
L5367:
    mov       al,	42
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5364:
    jmp       L5258
L5370:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	61
    jz        L5372
    cmp       rax,	62
    jz        L5373
    jmp       L5374
L5372:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	44
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5371
L5373:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	61
    jnz       L5376
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	55
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5375
L5376:
    mov       al,	34
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5375:
    jmp       L5371
L5374:
    mov       al,	45
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5371:
    jmp       L5258
L5377:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	38
    jz        L5379
    cmp       rax,	61
    jz        L5380
    jmp       L5381
L5379:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	32
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5378
L5380:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       al,	52
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5378
L5381:
    mov       al,	29
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5378:
    jmp       L5258
L5382:
    mov       rcx,	39
    xor       edx,	edx
    call      cc_lex.lxreadstring
    jmp       L5258
L5383:
    mov       rcx,	34
    xor       edx,	edx
    call      cc_lex.lxreadstring
    jmp       L5258
L5384:
    jmp       L5262
L5385:
    lea       rax,	[rip+cc_decls.nextlx]
    lea       rax,	[rax+16]
    inc       dword ptr[rax]
    mov       al,	56
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    xor       eax,	eax
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
    mov       rax,	[rip+cc_lex.dowhitespace]
    test      rax,	rax
    jz        L5387
    mov       rax,	[rip+cc_lex.lxsptr]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10],	rax
L5388:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    sub       rax,	9
    cmp       rax,	24
    jae       L5391
    lea       r10,	[rip+L5390]
    jmp       [r10 + rax*8]
    .data
L5390:
    .quad     L5392
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5391
    .quad     L5392
    .text
L5392:
    jmp       L5388
L5391:
    dec       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5389
L5389:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    mov       r10,	[rip+cc_lex.lxsptr]
    sub       r10,	rax
    lea       rax,	[rip+cc_decls.nextlx]
    mov       [rax+24],	r10d
L5387:
    jmp       L5258
L5393:
    jmp       L5262
L5394:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	61
    jnz       L5397
L5396:
    mov       al,	41
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    inc       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5395
L5397:
    mov       al,	36
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5395:
    jmp       L5258
L5398:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11098]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.nextlx]
    mov       eax,	[rax+16]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+20]
    lea       r10,	[rip+cc_decls.sourcefilenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    mov       rcx,	[rip+cc_lex.lx_stackindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L5262
L5399:
#cc_lex.lexreadtoken.doeof:
    dec       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lx_stackindex]
    test      rax,	rax
    jz        L5402
    call      cc_lex.unstacksourcefile
    mov       al,	56
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5401
L5402:
    mov       al,	57
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5401:
    jmp       L5258
L5403:
    jmp       L5262
L5404:
    add       qword ptr[rip+cc_lex.lxsptr],	2
    jmp       L5262
L5265:
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	1
    movzx     rax,	byte ptr[rax]
    cmp       rax,	128
    jl        L5406
    cmp       rax,	255
    jle       L5267
L5406:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11099]
    call      msys.m$print_str_nf
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	1
    movzx     rax,	byte ptr[rax]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_c8
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	1
    movzx     rax,	byte ptr[rax]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    mov       rcx,	[rip+cc_lex.lx_stackindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11099]
    call      cc_lex.lxerror
    mov       al,	1
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5258
L5258:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.readrealnumber
cc_lex.readrealnumber:
#PROC1
#PROC2
#?>>
    .set cc_lex.readrealnumber.intlen, 104
    .set cc_lex.readrealnumber.base, 112
    .set cc_lex.readrealnumber.badexpon, -8
    .set cc_lex.readrealnumber.realstr, -520
    .set cc_lex.readrealnumber.rs, -528
    .set cc_lex.readrealnumber.expstr, -560
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    movq      rax,	XMM13
    push      rax
    movq      rax,	XMM14
    push      rax
    movq      rax,	XMM15
    push      rax
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	600
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+104],	r8
    mov       [rbp+112],	r9
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + cc_lex.readrealnumber.base]
    cmp       rax,	10
    jz        L5409
    mov       rcx,	r13
    mov       rdx,	r14
    mov       r8,	[rbp + cc_lex.readrealnumber.intlen]
    mov       r9,	[rbp + cc_lex.readrealnumber.base]
    call      cc_lex.old_readrealnumber
    jmp       L5407
L5409:
    xor       rdi,	rdi
    xor       eax,	eax
    mov       rbx,	rax
    xor       rsi,	rsi
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	46
    jnz       L5411
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       rdi,	[rip+cc_lex.lxsptr]
    mov       rcx,	[rbp + cc_lex.readrealnumber.base]
    call      cc_lex.scannumber
    sub       rax,	rdi
    mov       rbx,	rax
L5411:
    xor       eax,	eax
    mov       [rbp + cc_lex.readrealnumber.badexpon],	rax
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	101
    jz        L5413
    cmp       rax,	69
    jz        L5413
    cmp       rax,	112
    jz        L5414
    cmp       rax,	80
    jz        L5414
    jmp       L5415
L5413:
    mov       rax,	[rbp + cc_lex.readrealnumber.base]
    cmp       rax,	16
    jz        L5417
    inc       qword ptr[rip+cc_lex.lxsptr]
    lea       rcx,	[rbp + cc_lex.readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       rsi,	rax
L5417:
    jmp       L5412
L5414:
    mov       rax,	[rbp + cc_lex.readrealnumber.base]
    cmp       rax,	16
    jnz       L5419
    inc       qword ptr[rip+cc_lex.lxsptr]
    lea       rcx,	[rbp + cc_lex.readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       rsi,	rax
L5419:
L5415:
L5412:
    mov       rax,	[rbp + cc_lex.readrealnumber.badexpon]
    test      rax,	rax
    jz        L5421
    dec       qword ptr[rip+cc_lex.lxsptr]
    mov       rcx,	r13
    call      cc_lex.readalphanumeric
    jmp       L5407
L5421:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	102
    jz        L5423
    cmp       rax,	70
    jz        L5423
    cmp       rax,	108
    jz        L5423
    cmp       rax,	76
    jnz       L5424
L5423:
    inc       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5422
L5424:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    lea       r10,	[rip+cc_lex.alphamap]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L5426
    mov       rcx,	r13
    call      cc_lex.readalphanumeric
    jmp       L5407
L5426:
L5422:
    mov       rax,	[rbp + cc_lex.readrealnumber.base]
    cmp       rax,	16
    jnz       L5428
    mov       al,	48
    mov       [rbp + cc_lex.readrealnumber.realstr],	al
    mov       al,	120
    mov       [rbp + cc_lex.readrealnumber.realstr+1],	al
    lea       rax,	[rbp + cc_lex.readrealnumber.realstr+2]
    mov       [rbp + cc_lex.readrealnumber.rs],	rax
    mov       r12,	2
    jmp       L5427
L5428:
    lea       rax,	[rbp + cc_lex.readrealnumber.realstr]
    mov       [rbp + cc_lex.readrealnumber.rs],	rax
    xor       r12,	r12
L5427:
    mov       rax,	[rbp + cc_lex.readrealnumber.intlen]
    add       rax,	rbx
    cmp       rax,	500
    jle       L5430
    lea       rcx,	[rip+L11100]
    call      cc_lex.lxerror
L5430:
    mov       rax,	[rbp + cc_lex.readrealnumber.intlen]
    test      rax,	rax
    jz        L5432
    mov       rcx,	[rbp + cc_lex.readrealnumber.rs]
    mov       rdx,	r14
    mov       r8,	[rbp + cc_lex.readrealnumber.intlen]
    call      memcpy
L5432:
    test      rbx,	rbx
    jz        L5434
    mov       rax,	[rbp + cc_lex.readrealnumber.rs]
    mov       r10,	[rbp + cc_lex.readrealnumber.intlen]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
L5434:
    mov       rax,	[rbp + cc_lex.readrealnumber.base]
    cvtsi2sd  XMM4,	rax
    movq      XMM15,	XMM4
    movq      XMM13,	XMM4
    mov       rax,	[rbp + cc_lex.readrealnumber.base]
    cmp       rax,	10
    jnz       L5436
    mov       rax,	rbx
    sub       rsi,	rax
    jmp       L5435
L5436:
    mov       rax,	rbx
    shl       rax,	2
    sub       rsi,	rax
    movq      XMM4,	[rip+L11101]
    movq      XMM13,	XMM4
L5435:
    mov       rax,	r12
    add       rax,	[rbp + cc_lex.readrealnumber.intlen]
    add       rax,	rbx
    xor       r10d,	r10d
    mov       [rbp + rax + cc_lex.readrealnumber.realstr],	r10b
    lea       rcx,	[rbp + cc_lex.readrealnumber.expstr]
    call      msys.m$print_startstr
    mov       rax,	[rbp + cc_lex.readrealnumber.base]
    cmp       rax,	10
    jnz       L5438
    lea       rax,	[rip+L11102]
    jmp       L5437
L5438:
    lea       rax,	[rip+L11103]
L5437:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + cc_lex.readrealnumber.realstr]
    lea       rdx,	[rbp + cc_lex.readrealnumber.expstr]
    call      strcat
    mov       rax,	[rbp + cc_lex.readrealnumber.base]
    cmp       rax,	10
    jz        L5440
    lea       rcx,	[rip+L11104]
    call      cc_lex.lxerror
L5440:
    lea       rcx,	[rbp + cc_lex.readrealnumber.realstr]
    xor       edx,	edx
    call      strtod
    movq      XMM14,	XMM0
    mov       al,	60
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    mov       al,	11
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    movq      XMM4,	XMM14
    lea       rax,	[rip+cc_decls.nextlx]
    movq      [rax],	XMM4
    mov       rax,	r14
    sub       rax,	[rip+cc_lex.lxstart]
    mov       rcx,	rax
    call      cc_lex.setnumberoffset
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	r14
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
L5407:
#---------------
    add       rsp,	600
    pop       rbp
    pop       rcx
    movq      XMM15,	rcx
    pop       rcx
    movq      XMM14,	rcx
    pop       rcx
    movq      XMM13,	rcx
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.readexponent
cc_lex.readexponent:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    sub       rsp,	48
    mov       r15,	rcx
#---------------
#PROC3
#PROC4
    xor       rsi,	rsi
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	43
    jz        L5443
    cmp       rax,	45
    jz        L5444
    jmp       L5445
L5443:
    inc       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5442
L5444:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       rsi,	1
L5445:
L5442:
    mov       rdi,	[rip+cc_lex.lxsptr]
    mov       rcx,	10
    call      cc_lex.scannumber
    sub       rax,	rdi
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L5447
    mov       rax,	1
    mov       [r15],	rax
    xor       eax,	eax
    jmp       L5441
L5447:
    xor       r13,	r13
    mov       rax,	rbx
    mov       r14,	rax
    cmp       r14,	0
    jle       L5450
L5448:
    mov       rax,	rdi
    inc       rdi
    movzx     rax,	byte ptr[rax]
    mov       r12,	rax
    mov       rax,	r13
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    add       rax,	r12
    sub       rax,	48
    mov       r13,	rax
    dec       r14
    jnz       L5448
L5450:
    test      rsi,	rsi
    jz        L5452
    mov       rax,	r13
    neg       rax
    jmp       L5451
L5452:
    mov       rax,	r13
L5451:
L5441:
#---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.lxerror
cc_lex.lxerror:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11105]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11106]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    call      cc_lex.getfileno
    lea       r10,	[rip+cc_decls.sourcefilepaths]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11107]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.nextlx]
    mov       eax,	[rax+16]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	11
    call      exit
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lex.printsymbol
cc_lex.printsymbol:
#PROC1
#PROC2
#?>>
    .set cc_lex.printsymbol.l, -32
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	72
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	rdi
    lea       r10,	[rbp + cc_lex.printsymbol.l]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
    movzx     rax,	byte ptr[rbp + cc_lex.printsymbol.l+21]
    lea       r10,	[rip+cc_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    lea       rcx,	[rip+L11108]
    mov       rdx,	r10
    call      printf
    movzx     rax,	byte ptr[rbp + cc_lex.printsymbol.l+21]
    cmp       rax,	67
    jz        L5456
    cmp       rax,	59
    jz        L5457
    cmp       rax,	60
    jz        L5458
    cmp       rax,	63
    jz        L5459
    cmp       rax,	61
    jz        L5460
    jmp       L5461
L5456:
    mov       rax,	[rbp + cc_lex.printsymbol.l]
    movzx     rax,	byte ptr[rax+106]
    mov       r10,	[rbp + cc_lex.printsymbol.l]
    mov       r10,	[r10]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      cc_lex.printstrn
    jmp       L5455
L5457:
    call      msys.m$print_startcon
    mov       rcx,	[rbp + cc_lex.printsymbol.l]
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11109]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	rdi
    xor       edx,	edx
    call      cc_lex.shownumberstr
    jmp       L5455
L5458:
    call      msys.m$print_startcon
    movq      XMM4,	[rbp + cc_lex.printsymbol.l]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.m$print_r64
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11109]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	rdi
    xor       edx,	edx
    call      cc_lex.shownumberstr
    jmp       L5455
L5459:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11110]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    rax,	dword ptr[rbp + cc_lex.printsymbol.l+24]
    mov       r10,	[rbp + cc_lex.printsymbol.l]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11110]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L5455
L5460:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11111]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    rax,	dword ptr[rbp + cc_lex.printsymbol.l+24]
    mov       r10,	[rbp + cc_lex.printsymbol.l]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11111]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L5455
L5461:
    mov       al,	[rbp + cc_lex.printsymbol.l+22]
    test      al,	al
    jz        L5463
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11112]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rbp + cc_lex.printsymbol.l+22]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L5463:
L5455:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       rsp,	72
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc cc_lex.lexsetup
cc_lex.lexsetup:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_lex.inithashtable
    call      cc_lex.fillhashtable
    xor       rdi,	rdi
L5465:
    lea       rax,	[rdi-36]
    cmp       rax,	220
    jae       L5470
    lea       r10,	[rip+L5469]
    jmp       [r10 + rax*8]
    .data
L5469:
    .quad     L5471
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5471
    .quad     L5470
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5470
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .quad     L5471
    .text
L5471:
    mov       al,	1
    lea       r10,	[rip+cc_lex.alphamap]
    mov       r11,	rdi
    mov       [r10 + r11],	al
L5470:
L5468:
    lea       rax,	[rdi-48]
    cmp       rax,	10
    jae       L5474
    lea       r10,	[rip+L5473]
    jmp       [r10 + rax*8]
    .data
L5473:
    .quad     L5475
    .quad     L5475
    .quad     L5475
    .quad     L5475
    .quad     L5475
    .quad     L5475
    .quad     L5475
    .quad     L5475
    .quad     L5475
    .quad     L5475
    .text
L5475:
    mov       al,	1
    lea       r10,	[rip+cc_lex.digitmap]
    mov       r11,	rdi
    mov       [r10 + r11],	al
L5474:
L5472:
    mov       al,	1
    lea       r10,	[rip+cc_lex.commentmap]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       al,	1
    lea       r10,	[rip+cc_lex.linecommentmap]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    xor       eax,	eax
    lea       r10,	[rip+cc_lex.spacemap]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    inc       rdi
    cmp       rdi,	255
    jle       L5465
    xor       eax,	eax
    lea       r10,	[rip+cc_lex.commentmap]
    mov       [r10+42],	al
    xor       eax,	eax
    lea       r10,	[rip+cc_lex.commentmap]
    mov       [r10],	al
    xor       eax,	eax
    lea       r10,	[rip+cc_lex.commentmap]
    mov       [r10+10],	al
    xor       eax,	eax
    lea       r10,	[rip+cc_lex.linecommentmap]
    mov       [r10],	al
    xor       eax,	eax
    lea       r10,	[rip+cc_lex.linecommentmap]
    mov       [r10+92],	al
    xor       eax,	eax
    lea       r10,	[rip+cc_lex.linecommentmap]
    mov       [r10+10],	al
    mov       al,	1
    lea       r10,	[rip+cc_lex.spacemap]
    mov       [r10+32],	al
    mov       al,	1
    lea       r10,	[rip+cc_lex.spacemap]
    mov       [r10+9],	al
    mov       al,	56
    lea       r10,	[rip+cc_lex.normaltkx]
    mov       [r10+21],	al
    xor       eax,	eax
    mov       [rip+cc_lex.npastedtokens],	rax
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lex.printstrn
cc_lex.printstrn:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    test      rbx,	rbx
    jz        L5478
    test      rsi,	rsi
    jnz       L5480
    call      msys.m$print_startcon
    mov       rcx,	rbx
    lea       rdx,	[rip+L11113]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       rcx,	rdi
    lea       rdx,	[rip+L11114]
    call      msys.m$print_str
    call      msys.m$print_end
    jmp       L5479
L5480:
    mov       rcx,	rsi
    call      msys.m$print_startfile
    mov       rcx,	rbx
    lea       rdx,	[rip+L11115]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       rcx,	rdi
    lea       rdx,	[rip+L11116]
    call      msys.m$print_str
    call      msys.m$print_end
L5479:
L5478:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.scannumber
cc_lex.scannumber:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	[rip+cc_lex.lxsptr]
L5482:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    mov       rbx,	rax
    sub       rax,	39
    cmp       rax,	64
    jae       L5485
    lea       r10,	[rip+L5484]
    jmp       [r10 + rax*8]
    .data
L5484:
    .quad     L5492
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5486
    .quad     L5486
    .quad     L5486
    .quad     L5486
    .quad     L5486
    .quad     L5486
    .quad     L5486
    .quad     L5486
    .quad     L5486
    .quad     L5486
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5489
    .quad     L5489
    .quad     L5489
    .quad     L5489
    .quad     L5489
    .quad     L5489
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5485
    .quad     L5492
    .quad     L5492
    .quad     L5489
    .quad     L5489
    .quad     L5489
    .quad     L5489
    .quad     L5489
    .quad     L5489
    .text
L5486:
    mov       rax,	rdi
    inc       rdi
    mov       r10b,	bl
    mov       [rax],	r10b
    mov       rax,	48
    add       rax,	rsi
    mov       r10,	rbx
    cmp       r10,	rax
    jl        L5488
    lea       rcx,	[rip+L11117]
    call      cc_lex.lxerror
L5488:
    jmp       L5482
L5489:
    cmp       rsi,	16
    jnz       L5491
    mov       rax,	rdi
    inc       rdi
    mov       r10b,	bl
    mov       [rax],	r10b
    jmp       L5490
L5491:
    dec       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5483
L5490:
    jmp       L5482
L5492:
    jmp       L5482
L5485:
    dec       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5483
L5483:
    mov       rax,	rdi
L5481:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.lookup
cc_lex.lookup:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
#cc_lex.lookup.retry:
L5494:
    mov       rax,	[rip+cc_lex.lxhashvalue]
    and       rax,	[rip+cc_decls.hstmask]
    mov       rdi,	rax
    xor       rbx,	rbx
L5495:
    mov       rax,	[rip+cc_decls.hashtable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10],	rax
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    movzx     rax,	byte ptr[rax+106]
    mov       rsi,	rax
    test      rsi,	rsi
    jnz       L5498
    jmp       L5496
L5498:
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+24]
    mov       r10,	rsi
    cmp       r10,	rax
    jnz       L5500
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    mov       rax,	[rax]
    mov       rcx,	rax
    mov       rdx,	[rip+cc_lex.lxsvalue]
    mov       r8,	rsi
    call      memcmp
    movsxd    r10,	eax
    test      r10,	r10
    jnz       L5502
    mov       rax,	1
    jmp       L5493
L5502:
L5500:
    inc       rdi
    cmp       rdi,	[rip+cc_decls.hstsize]
    jl        L5504
    test      rbx,	rbx
    jz        L5506
    lea       rcx,	[rip+L11118]
    call      mlib.abortprogram
L5506:
    mov       rbx,	1
    xor       rdi,	rdi
L5504:
    jmp       L5495
L5496:
    mov       rax,	[rip+cc_lex.nhstsymbols]
    cmp       rax,	[rip+cc_lex.hstthreshold]
    jl        L5508
    call      cc_lex.newhashtable
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+24]
    mov       rcx,	[rip+cc_lex.lxsvalue]
    mov       rdx,	rax
    call      cc_lex.gethashvalue
    mov       [rip+cc_lex.lxhashvalue],	rax
    jmp       L5494
L5508:
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+24]
    mov       rcx,	[rip+cc_lex.lxsvalue]
    mov       rdx,	rax
    call      mlib.pcm_copyheapstringn
    lea       r10,	[rip+cc_decls.nextlx]
    mov       r10,	[r10]
    mov       [r10],	rax
    lea       rax,	[rip+cc_decls.nextlx]
    mov       eax,	[rax+24]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       r10,	[r10]
    mov       [r10+106],	al
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    mov       r10b,	67
    mov       [rax+107],	r10b
    inc       qword ptr[rip+cc_lex.nhstsymbols]
    xor       eax,	eax
L5493:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.gethashvalue
cc_lex.gethashvalue:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    cmp       r12,	-1
    jnz       L5511
    mov       rcx,	rsi
    call      strlen
    mov       r12,	rax
L5511:
    xor       rdi,	rdi
    mov       rax,	r12
    mov       rbx,	rax
    cmp       rbx,	0
    jle       L5514
L5512:
    mov       rax,	rdi
    shl       rax,	4
    sub       rax,	rdi
    mov       r10,	rsi
    inc       rsi
    movzx     r10,	byte ptr[r10]
    add       rax,	r10
    mov       rdi,	rax
    dec       rbx
    jnz       L5512
L5514:
    mov       rax,	rdi
    shl       rax,	5
    sub       rax,	rdi
L5509:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.inithashtable
cc_lex.inithashtable:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_decls.hstsize]
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rip+cc_decls.hashtable],	rax
    mov       rax,	[rip+cc_decls.hstsize]
    dec       rax
    mov       [rip+cc_decls.hstmask],	rax
    xor       rdi,	rdi
    mov       rax,	[rip+cc_decls.hstmask]
    cmp       rax,	0
    jl        L5518
L5516:
    mov       rcx,	128
    call      mlib.pcm_allocz
    mov       r10,	[rip+cc_decls.hashtable]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    inc       rdi
    cmp       rdi,	[rip+cc_decls.hstmask]
    jle       L5516
L5518:
    xor       eax,	eax
    mov       [rip+cc_lex.nhstsymbols],	rax
    mov       rax,	6
    mov       r10,	[rip+cc_decls.hstsize]
    imul      rax,	r10
    mov       r10,	10
    cqo       
    idiv      r10
    mov       [rip+cc_lex.hstthreshold],	rax
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lex.fillhashtable
cc_lex.fillhashtable:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rbx,	63
    cmp       rbx,	1
    jl        L5522
L5520:
    lea       rax,	[rip+cc_tables.stnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       [rip+cc_lex.lxsvalue],	rax
    lea       rax,	[rip+cc_tables.stsymbols]
    mov       r10,	rdi
    movsxd    rax,	dword ptr[rax + r10*4-4]
    cmp       rax,	68
    jnz       L5524
    mov       rcx,	[rip+cc_lex.lxsvalue]
    call      mlib.pcm_copyheapstring
    mov       [rip+cc_lex.lxsvalue],	rax
L5524:
    mov       rcx,	[rip+cc_lex.lxsvalue]
    call      strlen
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+24]
    mov       rcx,	[rip+cc_lex.lxsvalue]
    mov       rdx,	rax
    call      cc_lex.gethashvalue
    mov       [rip+cc_lex.lxhashvalue],	rax
    call      cc_lex.lookup
    test      rax,	rax
    jz        L5526
    call      msys.m$print_startcon
    lea       rax,	[rip+cc_tables.stnames]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11119]
    call      mlib.abortprogram
L5526:
    lea       rax,	[rip+cc_tables.stsymbols]
    mov       r10,	rdi
    mov       eax,	[rax + r10*4-4]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       r10,	[r10]
    mov       [r10+107],	al
    lea       rax,	[rip+cc_tables.stsubcodes]
    mov       r10,	rdi
    mov       eax,	[rax + r10*4-4]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       r10,	[r10]
    mov       [r10+100],	ax
    inc       rdi
    cmp       rdi,	rbx
    jle       L5520
L5522:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.dolexdirective
cc_lex.dolexdirective:
#PROC1
#PROC2
#?>>
    .set cc_lex.dolexdirective.dir, -8
    .set cc_lex.dolexdirective.length, -16
    .set cc_lex.dolexdirective.allowmacros, -24
    .set cc_lex.dolexdirective.filename, -328
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	360
#---------------
#PROC3
#PROC4
    mov       rsi,	[rip+cc_lex.lxsptr]
    call      cc_lex.getlexdirective
    mov       [rbp + cc_lex.dolexdirective.dir],	rax
    mov       rax,	[rbp + cc_lex.dolexdirective.dir]
    test      rax,	rax
    jnz       L5529
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	rsi
    mov       rcx,	rsi
    mov       rdx,	rax
    xor       r8d,	r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11120]
    call      cc_lex.lxerror
L5529:
    mov       rax,	[rbp + cc_lex.dolexdirective.dir]
    cmp       rax,	7
    jz        L5531
    cmp       rax,	1
    jz        L5532
    cmp       rax,	10
    jz        L5533
    cmp       rax,	8
    jz        L5534
    cmp       rax,	9
    jz        L5535
    cmp       rax,	3
    jz        L5536
    cmp       rax,	4
    jz        L5537
    cmp       rax,	5
    jz        L5537
    cmp       rax,	6
    jz        L5538
    cmp       rax,	13
    jz        L5539
    cmp       rax,	14
    jz        L5540
    cmp       rax,	11
    jz        L5541
    cmp       rax,	15
    jz        L5542
    jmp       L5543
L5531:
    mov       rax,	1
    mov       [rip+cc_lex.isincludefile],	rax
    jmp       L5545
L5544:
    inc       qword ptr[rip+cc_lex.lxsptr]
L5545:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	32
    jz        L5544
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	9
    jz        L5544
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	60
    setnz     al
    movzx     eax,	al
    mov       [rbp + cc_lex.dolexdirective.allowmacros],	rax
    call      cc_lex.lexm
    xor       eax,	eax
    mov       [rip+cc_lex.isincludefile],	rax
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	42
    jnz       L5548
    mov       r15,	1
    lea       rax,	[rbp + cc_lex.dolexdirective.filename]
    mov       rbx,	rax
    mov       rax,	[rbp + cc_lex.dolexdirective.allowmacros]
    test      rax,	rax
    jz        L5550
L5551:
    call      cc_lex.lexm
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	57
    jz        L5554
    cmp       rax,	56
    jz        L5554
    cmp       rax,	45
    jz        L5555
    jmp       L5556
L5554:
    lea       rcx,	[rip+L11121]
    call      cc_lex.lxerror
    jmp       L5553
L5555:
    jmp       L5552
L5556:
    lea       rcx,	[rip+cc_decls.nextlx]
    lea       rdx,	[rbp + cc_lex.dolexdirective.length]
    call      cc_lex.strtoken
    mov       r12,	rax
    mov       rcx,	rbx
    mov       rdx,	r12
    mov       r8,	[rbp + cc_lex.dolexdirective.length]
    call      memcpy
    mov       rax,	[rbp + cc_lex.dolexdirective.length]
    add       rbx,	rax
L5553:
    jmp       L5551
L5552:
    jmp       L5549
L5550:
L5557:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    mov       r14,	rax
    mov       rax,	r14
    cmp       rax,	62
    jz        L5560
    cmp       rax,	10
    jz        L5561
    test      rax,	rax
    jz        L5561
    jmp       L5562
L5560:
    jmp       L5558
L5561:
    lea       rcx,	[rip+L11122]
    call      cc_lex.lxerror
    jmp       L5559
L5562:
    mov       rax,	rbx
    inc       rbx
    mov       r10b,	r14b
    mov       [rax],	r10b
L5559:
    jmp       L5557
L5558:
L5549:
    xor       eax,	eax
    mov       [rbx],	al
    jmp       L5547
L5548:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	63
    jnz       L5563
    xor       r15,	r15
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    lea       rcx,	[rbp + cc_lex.dolexdirective.filename]
    mov       rdx,	rax
    call      strcpy
    jmp       L5547
L5563:
    lea       rcx,	[rip+L11123]
    call      cc_lex.lxerror
L5547:
    call      cc_lex.lexm
    mov       al,	[rip+cc_cli.fshowincludes]
    test      al,	al
    jz        L5565
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11124]
    call      msys.m$print_str_nf
    lea       rcx,	[rbp + cc_lex.dolexdirective.filename]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11125]
    call      msys.m$print_str_nf
    call      cc_lex.getfileno
    lea       r10,	[rip+cc_decls.sourcefilepaths]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.nextlx]
    mov       eax,	[rax+16]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[rip+L11126]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+cc_decls.nsourcefiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L5565:
    inc       qword ptr[rip+cc_lex.nincludes]
    lea       rcx,	[rbp + cc_lex.dolexdirective.filename]
    mov       rdx,	r15
    call      cc_lex.stacksourcefile
    jmp       L5530
L5532:
    call      cc_lex.dodefine
    jmp       L5530
L5533:
    call      cc_lex.lexreadtoken
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L5567
    lea       rcx,	[rip+L11127]
    call      cc_lex.lxerror
L5567:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rdi,	[rax]
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	1
    jnz       L5568
L5569:
    xor       eax,	eax
    mov       [rdi+109],	al
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    mov       al,	[rax+88]
    mov       [rdi+107],	al
    xor       eax,	eax
    mov       [rdi+80],	rax
    lea       rax,	[rdi+108]
    and       byte ptr[rax],	251
L5568:
    jmp       L5530
L5534:
    call      cc_lex.getifdef
    mov       r13,	rax
    jmp       L5570
L5535:
    call      cc_lex.getifdef
    test      rax,	rax
    setz      al
    movzx     eax,	al
    mov       r13,	rax
    jmp       L5570
L5536:
    call      cc_lex.getifexpr
    mov       r13,	rax
#cc_lex.dolexdirective.doif:
L5570:
    inc       qword ptr[rip+cc_lex.ifcondlevel]
    test      r13,	r13
    jz        L5572
    xor       eax,	eax
    jmp       L5527
L5572:
#cc_lex.dolexdirective.doskipcode:
L5573:
    call      cc_lex.skipcode
    mov       [rbp + cc_lex.dolexdirective.dir],	rax
    mov       rax,	[rbp + cc_lex.dolexdirective.dir]
    cmp       rax,	4
    jz        L5575
    cmp       rax,	5
    jz        L5576
    cmp       rax,	6
    jz        L5577
    jmp       L5578
L5575:
    call      cc_lex.getifexpr
    mov       r13,	rax
    test      r13,	r13
    jz        L5580
    xor       eax,	eax
    jmp       L5527
L5580:
    jmp       L5573
L5576:
    jmp       L5574
L5577:
    dec       qword ptr[rip+cc_lex.ifcondlevel]
L5578:
L5574:
L5571:
    jmp       L5530
L5537:
    mov       rax,	[rip+cc_lex.ifcondlevel]
    test      rax,	rax
    jnz       L5582
    lea       rcx,	[rip+L11128]
    call      cc_lex.lxerror
L5582:
L5583:
    call      cc_lex.skipcode
    mov       [rbp + cc_lex.dolexdirective.dir],	rax
    mov       rax,	[rbp + cc_lex.dolexdirective.dir]
    cmp       rax,	6
    jnz       L5583
    dec       qword ptr[rip+cc_lex.ifcondlevel]
    jmp       L5530
L5538:
    mov       rax,	[rip+cc_lex.ifcondlevel]
    test      rax,	rax
    jnz       L5587
    lea       rcx,	[rip+L11129]
    call      cc_lex.lxerror
L5587:
    dec       qword ptr[rip+cc_lex.ifcondlevel]
    jmp       L5530
L5539:
    jmp       L5530
L5540:
L5588:
    call      cc_lex.lexreadtoken
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	56
    jnz       L5588
    jmp       L5530
L5541:
    call      cc_lex.lexm
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11130]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rip+cc_decls.nextlx]
    call      cc_lex.showtoken
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11131]
    call      cc_lex.lxerror
    jmp       L5530
L5542:
    call      cc_lex.dopragmadir
    jmp       L5530
L5543:
#cc_lex.dolexdirective.skip:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11132]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_tables.sourcedirnames]
    mov       r10,	[rbp + cc_lex.dolexdirective.dir]
    mov       rcx,	[rax + r10*8-8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       [rip+cc_lex.lxsptr],	rsi
    mov       al,	4
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    mov       rax,	1
    jmp       L5527
    lea       rcx,	[rip+L11133]
    call      cc_lex.lxerror
L5530:
    xor       eax,	eax
L5527:
#---------------
    add       rsp,	360
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.getlexdirective
cc_lex.getlexdirective:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_lex.lexreadtoken
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L5594
    cmp       rax,	56
    jz        L5595
    cmp       rax,	59
    jz        L5596
    jmp       L5597
L5594:
    jmp       L5593
L5595:
    mov       rax,	13
    jmp       L5592
L5596:
L5598:
    call      cc_lex.lexreadtoken
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	56
    jz        L5601
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	57
    jnz       L5598
L5601:
    mov       rax,	13
    jmp       L5592
L5597:
    xor       eax,	eax
    jmp       L5592
L5593:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    movzx     rax,	byte ptr[rax+107]
    cmp       rax,	68
    jz        L5603
    cmp       rax,	71
    jz        L5604
    cmp       rax,	72
    jz        L5605
    cmp       rax,	56
    jz        L5606
    jmp       L5607
L5603:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    movsx     rax,	word ptr[rax+100]
    jmp       L5592
L5604:
    mov       rax,	3
    jmp       L5592
L5605:
    mov       rax,	5
    jmp       L5592
L5606:
    mov       rax,	13
    jmp       L5592
L5607:
L5602:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rdi,	[rax]
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	1
    jnz       L5609
    movzx     rax,	byte ptr[rdi+88]
    cmp       rax,	68
    jnz       L5611
    movsx     rax,	word ptr[rdi+100]
    jmp       L5592
L5611:
L5609:
    xor       eax,	eax
L5592:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lex.startlex
cc_lex.startlex:
#PROC1
#PROC2
#?>>
    .set cc_lex.startlex.caption, 24
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rdx
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rip+cc_lex.ifcondlevel],	rax
    xor       eax,	eax
    mov       [rip+cc_lex.lx_stackindex],	rax
    xor       eax,	eax
    mov       [rip+cc_lex.noexpand],	rax
    lea       rax,	[rip+cc_lex.normaltkx]
    mov       [rip+cc_lex.normaltk],	rax
    xor       eax,	eax
    mov       [rip+cc_lex.lx_stackindex],	rax
    xor       eax,	eax
    mov       [rip+cc_lex.ifcondlevel],	rax
    mov       rax,	1
    mov       [rip+cc_lex.firstsymbol],	rax
    xor       eax,	eax
    mov       [rip+cc_lex.npastedtokens],	rax
    xor       eax,	eax
    mov       [rip+cc_lex.isincludefile],	rax
    xor       eax,	eax
    mov       [rip+cc_lex.tkptr],	rax
    lea       rax,	[rip+cc_decls.sourcefiletext]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       [rip+cc_lex.lxsptr],	rax
    mov       [rip+cc_lex.lxstart],	rax
    mov       rcx,	rdi
    call      cc_lex.setfileno
    mov       eax,	1
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+16],	eax
    xor       eax,	eax
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+28],	eax
    mov       al,	56
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    xor       eax,	eax
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    call      cc_lex.lex
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lex.endlex
cc_lex.endlex:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_lex.ifcondlevel]
    test      rax,	rax
    jz        L5615
    call      msys.m$print_startcon
    mov       rcx,	[rip+cc_lex.ifcondlevel]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11134]
    call      cc_lex.lxerror
L5615:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_lex.ps
cc_lex.ps:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11135]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rip+cc_decls.lx]
    call      cc_lex.printsymbol
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lex.psnext
cc_lex.psnext:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11136]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rip+cc_decls.nextlx]
    call      cc_lex.printsymbol
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lex.gethashtablesize
cc_lex.gethashtablesize:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
#---------------
#PROC3
#PROC4
    xor       rbx,	rbx
    xor       eax,	eax
    mov       rdi,	rax
    mov       rax,	[rip+cc_decls.hstmask]
    cmp       rax,	0
    jl        L5621
L5619:
    mov       rax,	[rip+cc_decls.hashtable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax]
    test      rax,	rax
    jz        L5623
    inc       rbx
L5623:
    inc       rdi
    cmp       rdi,	[rip+cc_decls.hstmask]
    jle       L5619
L5621:
    mov       rax,	rbx
L5618:
#---------------
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.readlinecomment
cc_lex.readlinecomment:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
L5625:
L5627:
L5628:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    lea       r10,	[rip+cc_lex.linecommentmap]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L5627
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	10
    jz        L5631
    test      rax,	rax
    jz        L5632
    cmp       rax,	92
    jz        L5633
    jmp       L5634
L5631:
    inc       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5626
L5632:
    jmp       L5626
L5633:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	13
    jz        L5636
    cmp       rax,	10
    jz        L5637
    jmp       L5638
L5636:
    add       qword ptr[rip+cc_lex.lxsptr],	2
    lea       rax,	[rip+cc_decls.nextlx]
    lea       rax,	[rax+16]
    inc       dword ptr[rax]
    jmp       L5635
L5637:
    inc       qword ptr[rip+cc_lex.lxsptr]
    lea       rax,	[rip+cc_decls.nextlx]
    lea       rax,	[rax+16]
    inc       dword ptr[rax]
L5638:
L5635:
L5634:
L5630:
    jmp       L5625
L5626:
    lea       rax,	[rip+cc_decls.nextlx]
    lea       rax,	[rax+16]
    inc       dword ptr[rax]
#---------------
    ret       
# End 
# Proc cc_lex.readblockcomment
cc_lex.readblockcomment:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
L5640:
L5642:
L5643:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    lea       r10,	[rip+cc_lex.commentmap]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L5642
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	10
    jz        L5646
    test      rax,	rax
    jz        L5647
    cmp       rax,	42
    jz        L5648
    jmp       L5649
L5646:
    lea       rax,	[rip+cc_decls.nextlx]
    lea       rax,	[rax+16]
    inc       dword ptr[rax]
    jmp       L5645
L5647:
    lea       rcx,	[rip+L11137]
    call      cc_lex.lxerror
    jmp       L5645
L5648:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax+1]
    cmp       rax,	47
    jnz       L5651
    add       qword ptr[rip+cc_lex.lxsptr],	2
    jmp       L5641
L5651:
L5649:
L5645:
    jmp       L5640
L5641:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_lex.readhex
cc_lex.readhex:
#PROC1
#PROC2
#?>>
    .set cc_lex.readhex.pstart, 64
    .set cc_lex.readhex.p, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+64],	rcx
#---------------
#PROC3
#PROC4
    xor       rdi,	rdi
    mov       rax,	[rip+cc_lex.lxsptr]
    mov       [rbp + cc_lex.readhex.p],	rax
    mov       r12,	1
    xor       eax,	eax
    mov       r14,	rax
    mov       r13,	rax
    xor       rsi,	rsi
L5653:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    mov       rbx,	rax
    sub       rax,	46
    cmp       rax,	72
    jae       L5656
    lea       r10,	[rip+L5655]
    jmp       [r10 + rax*8]
    .data
L5655:
    .quad     L5663
    .quad     L5656
    .quad     L5658
    .quad     L5657
    .quad     L5657
    .quad     L5657
    .quad     L5657
    .quad     L5657
    .quad     L5657
    .quad     L5657
    .quad     L5657
    .quad     L5657
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5661
    .quad     L5661
    .quad     L5661
    .quad     L5661
    .quad     L5661
    .quad     L5661
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5664
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5663
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5667
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5662
    .quad     L5662
    .quad     L5662
    .quad     L5662
    .quad     L5662
    .quad     L5662
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5664
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5663
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5656
    .quad     L5667
    .text
L5657:
    xor       r12,	r12
    mov       rax,	rdi
    shl       rax,	4
    lea       r10,	[rbx-48]
    add       rax,	r10
    mov       rdi,	rax
    inc       rsi
    jmp       L5653
L5658:
    test      r12,	r12
    jz        L5660
    inc       qword ptr[rbp + cc_lex.readhex.p]
    jmp       L5659
L5660:
    inc       rsi
    mov       rax,	rdi
    shl       rax,	4
    mov       rdi,	rax
L5659:
    jmp       L5653
L5661:
    xor       r12,	r12
    inc       rsi
    mov       rax,	rdi
    shl       rax,	4
    lea       r10,	[rbx-65]
    add       r10,	10
    add       rax,	r10
    mov       rdi,	rax
    jmp       L5653
L5662:
    xor       r12,	r12
    inc       rsi
    mov       rax,	rdi
    shl       rax,	4
    lea       r10,	[rbx-97]
    add       r10,	10
    add       rax,	r10
    mov       rdi,	rax
    jmp       L5653
L5663:
    dec       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	[rbp + cc_lex.readhex.p]
    mov       rcx,	[rbp + cc_lex.readhex.pstart]
    mov       rdx,	[rbp + cc_lex.readhex.p]
    mov       r8,	rax
    mov       r9,	16
    call      cc_lex.readrealnumber
    jmp       L5652
L5664:
    inc       r13
    cmp       r13,	2
    jle       L5666
    lea       rcx,	[rip+L11138]
    call      cc_lex.lxerror
L5666:
    jmp       L5653
L5667:
    test      r14,	r14
    jz        L5669
    lea       rcx,	[rip+L11139]
    call      cc_lex.lxerror
L5669:
    mov       r14,	1
    jmp       L5653
L5656:
    dec       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5654
L5654:
    mov       rax,	[rbp + cc_lex.readhex.pstart]
    sub       rax,	[rip+cc_lex.lxstart]
    mov       rcx,	rax
    call      cc_lex.setnumberoffset
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	[rbp + cc_lex.readhex.pstart]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
    cmp       rsi,	16
    jle       L5671
    lea       rcx,	[rip+L11140]
    call      cc_lex.lxerror
L5671:
    mov       al,	59
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    mov       rax,	rdi
    mov       r10,	9223372036854775807
    cmp       rax,	r10
    jbe       L5673
    mov       al,	9
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    jmp       L5672
L5673:
    mov       rax,	rdi
    mov       r10,	4294967295
    cmp       rax,	r10
    jbe       L5674
    mov       al,	4
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    jmp       L5672
L5674:
    cmp       rdi,	2147483647
    jbe       L5675
    mov       al,	8
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    jmp       L5672
L5675:
    mov       al,	3
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
L5672:
    mov       rax,	rdi
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10],	rax
    call      cc_lex.checknumbersuffix
L5652:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.readbinary
cc_lex.readbinary:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    sub       rsp,	48
    mov       r15,	rcx
#---------------
#PROC3
#PROC4
    xor       rdi,	rdi
    mov       rax,	[rip+cc_lex.lxsptr]
    mov       r13,	rax
    mov       r12,	1
L5677:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    mov       rbx,	rax
    sub       rax,	46
    cmp       rax,	12
    jae       L5680
    lea       r10,	[rip+L5679]
    jmp       [r10 + rax*8]
    .data
L5679:
    .quad     L5686
    .quad     L5680
    .quad     L5682
    .quad     L5681
    .quad     L5685
    .quad     L5685
    .quad     L5685
    .quad     L5685
    .quad     L5685
    .quad     L5685
    .quad     L5685
    .quad     L5685
    .text
L5681:
    xor       r12,	r12
    jmp       L5677
L5682:
    test      r12,	r12
    jz        L5684
    inc       r13
L5684:
    jmp       L5677
L5685:
    lea       rcx,	[rip+L11141]
    call      cc_lex.lxerror
    jmp       L5677
L5686:
    lea       rcx,	[rip+L11142]
    call      cc_lex.lxerror
    jmp       L5677
L5680:
    dec       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5678
L5678:
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	r13
    mov       rsi,	rax
    mov       rax,	r15
    sub       rax,	[rip+cc_lex.lxstart]
    mov       rcx,	rax
    call      cc_lex.setnumberoffset
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	r15
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
    cmp       rsi,	64
    jle       L5688
    lea       rcx,	[rip+L11143]
    call      cc_lex.lxerror
L5688:
    mov       r14,	rsi
    cmp       r14,	0
    jle       L5691
L5689:
    mov       rax,	rdi
    shl       rax,	1
    mov       r10,	r13
    inc       r13
    movzx     r10,	byte ptr[r10]
    add       rax,	r10
    sub       rax,	48
    mov       rdi,	rax
    dec       r14
    jnz       L5689
L5691:
    mov       al,	59
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    mov       al,	3
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    cmp       rdi,	2147483647
    jb        L5693
    mov       al,	4
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
L5693:
    mov       rax,	rdi
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10],	rax
    call      cc_lex.checknumbersuffix
#---------------
    add       rsp,	48
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.readoctal
cc_lex.readoctal:
#PROC1
#PROC2
#?>>
    .set cc_lex.readoctal.pstart, 64
    .set cc_lex.readoctal.usigned, -8
    .set cc_lex.readoctal.p, -16
    .set cc_lex.readoctal.av_1, -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+64],	rcx
#---------------
#PROC3
#PROC4
    xor       rdi,	rdi
    mov       rax,	[rip+cc_lex.lxsptr]
    mov       [rbp + cc_lex.readoctal.p],	rax
    mov       r13,	1
    xor       eax,	eax
    mov       [rbp + cc_lex.readoctal.usigned],	rax
    mov       r14,	rax
    xor       rsi,	rsi
L5695:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    mov       rbx,	rax
    sub       rax,	46
    cmp       rax,	72
    jae       L5698
    lea       r10,	[rip+L5697]
    jmp       [r10 + rax*8]
    .data
L5697:
    .quad     L5703
    .quad     L5698
    .quad     L5700
    .quad     L5699
    .quad     L5699
    .quad     L5699
    .quad     L5699
    .quad     L5699
    .quad     L5699
    .quad     L5699
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5704
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5707
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5704
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5698
    .quad     L5707
    .text
L5699:
    xor       r13,	r13
    inc       rsi
    jmp       L5695
L5700:
    test      r13,	r13
    jz        L5702
    inc       qword ptr[rbp + cc_lex.readoctal.p]
    jmp       L5701
L5702:
    inc       rsi
L5701:
    jmp       L5695
L5703:
    dec       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	[rbp + cc_lex.readoctal.p]
    mov       rcx,	[rbp + cc_lex.readoctal.pstart]
    mov       rdx,	[rbp + cc_lex.readoctal.p]
    mov       r8,	rax
    mov       r9,	10
    call      cc_lex.readrealnumber
    jmp       L5694
L5704:
    inc       r14
    cmp       r14,	2
    jle       L5706
    lea       rcx,	[rip+L11144]
    call      cc_lex.lxerror
L5706:
    jmp       L5695
L5707:
    mov       rax,	[rbp + cc_lex.readoctal.usigned]
    test      rax,	rax
    jz        L5709
    lea       rcx,	[rip+L11145]
    call      cc_lex.lxerror
L5709:
    mov       rax,	1
    mov       [rbp + cc_lex.readoctal.usigned],	rax
    jmp       L5695
L5698:
    lea       rax,	[rip+cc_lex.alphamap]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L5711
#cc_lex.readoctal.doalpha:
    mov       rcx,	[rbp + cc_lex.readoctal.pstart]
    call      cc_lex.readalphanumeric
    jmp       L5694
L5711:
    dec       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5696
L5696:
    mov       rax,	[rbp + cc_lex.readoctal.pstart]
    sub       rax,	[rip+cc_lex.lxstart]
    mov       rcx,	rax
    call      cc_lex.setnumberoffset
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	[rbp + cc_lex.readoctal.pstart]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
    cmp       rsi,	22
    jg        L5715
    cmp       rsi,	22
    jnz       L5714
    mov       rcx,	[rbp + cc_lex.readoctal.p]
    lea       rdx,	[rip+L11146]
    mov       r8,	22
    call      mlib.cmpstringn
    mov       r12,	rax
    cmp       rax,	0
    jle       L5714
L5715:
    lea       rcx,	[rip+L11147]
    call      cc_lex.lxerror
L5714:
    mov       [rbp + cc_lex.readoctal.av_1],	rsi
    mov       rax,	[rbp + cc_lex.readoctal.av_1]
    cmp       rax,	0
    jle       L5718
L5716:
    mov       rax,	rdi
    shl       rax,	3
    mov       r10,	[rbp + cc_lex.readoctal.p]
    inc       qword ptr[rbp + cc_lex.readoctal.p]
    movzx     r10,	byte ptr[r10]
    add       rax,	r10
    sub       rax,	48
    mov       rdi,	rax
    dec       qword ptr[rbp + cc_lex.readoctal.av_1]
    jnz       L5716
L5718:
    mov       al,	59
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    mov       al,	3
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    cmp       rdi,	2147483647
    jb        L5720
    mov       al,	4
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
L5720:
    mov       rax,	rdi
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10],	rax
    call      cc_lex.checknumbersuffix
L5694:
#---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.readdecimal
cc_lex.readdecimal:
#PROC1
#PROC2
#?>>
    .set cc_lex.readdecimal.pstart, 64
    .set cc_lex.readdecimal.p, -8
    .set cc_lex.readdecimal.av_1, -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       [rbp+64],	rcx
#---------------
#PROC3
#PROC4
    xor       rdi,	rdi
    xor       eax,	eax
    mov       r14b,	al
    mov       r13b,	al
    dec       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lxsptr]
    mov       [rbp + cc_lex.readdecimal.p],	rax
L5722:
L5723:
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    lea       r10,	[rip+cc_lex.digitmap]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L5722
    jmp       L5726
L5725:
    inc       qword ptr[rbp + cc_lex.readdecimal.p]
L5726:
    mov       rax,	[rbp + cc_lex.readdecimal.p]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	48
    jz        L5725
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	[rbp + cc_lex.readdecimal.p]
    mov       rsi,	rax
L5728:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    mov       rbx,	rax
    sub       rax,	46
    cmp       rax,	72
    jae       L5731
    lea       r10,	[rip+L5730]
    jmp       [r10 + rax*8]
    .data
L5730:
    .quad     L5732
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5732
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5733
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5736
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5732
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5733
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5731
    .quad     L5736
    .text
L5732:
    dec       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	[rbp + cc_lex.readdecimal.p]
    mov       rcx,	[rbp + cc_lex.readdecimal.pstart]
    mov       rdx,	[rbp + cc_lex.readdecimal.p]
    mov       r8,	rax
    mov       r9,	10
    call      cc_lex.readrealnumber
    jmp       L5721
L5733:
    inc       r13b
    movzx     rax,	r13b
    cmp       rax,	2
    jle       L5735
    lea       rcx,	[rip+L11148]
    call      cc_lex.lxerror
L5735:
    jmp       L5728
L5736:
    test      r14b,	r14b
    jz        L5738
    lea       rcx,	[rip+L11149]
    call      cc_lex.lxerror
L5738:
    mov       r14b,	1
    jmp       L5728
L5731:
    lea       rax,	[rip+cc_lex.alphamap]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L5740
    mov       rcx,	[rbp + cc_lex.readdecimal.pstart]
    call      cc_lex.readalphanumeric
    jmp       L5721
L5740:
    dec       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5729
L5729:
    mov       rax,	[rbp + cc_lex.readdecimal.pstart]
    sub       rax,	[rip+cc_lex.lxstart]
    mov       rcx,	rax
    call      cc_lex.setnumberoffset
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	[rbp + cc_lex.readdecimal.pstart]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
    cmp       rsi,	20
    jg        L5743
    cmp       rsi,	20
    jnz       L5742
    mov       rcx,	[rbp + cc_lex.readdecimal.p]
    lea       rdx,	[rip+L11150]
    mov       r8,	20
    call      mlib.cmpstringn
    mov       r12,	rax
    cmp       rax,	0
    jle       L5742
L5743:
    lea       rcx,	[rip+L11151]
    call      cc_lex.lxerror
L5742:
    mov       [rbp + cc_lex.readdecimal.av_1],	rsi
    mov       rax,	[rbp + cc_lex.readdecimal.av_1]
    cmp       rax,	0
    jle       L5746
L5744:
    mov       rax,	rdi
    shl       rax,	1
    lea       rax,	[rax + rax*4]
    mov       r10,	[rbp + cc_lex.readdecimal.p]
    inc       qword ptr[rbp + cc_lex.readdecimal.p]
    movzx     r10,	byte ptr[r10]
    sub       r10,	48
    add       rax,	r10
    mov       rdi,	rax
    dec       qword ptr[rbp + cc_lex.readdecimal.av_1]
    jnz       L5744
L5746:
    mov       al,	59
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    movzx     rax,	r13b
    test      rax,	rax
    jz        L5748
    cmp       rax,	1
    jz        L5749
    cmp       rax,	2
    jz        L5750
    jmp       L5751
L5748:
    cmp       rdi,	2147483647
    jl        L5753
    mov       al,	4
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    jmp       L5752
L5753:
    mov       al,	3
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
L5752:
    test      r14b,	r14b
    jz        L5755
    mov       rax,	rdi
    mov       r10,	4294967295
    cmp       rax,	r10
    jb        L5757
    mov       al,	9
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    jmp       L5756
L5757:
    mov       al,	8
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
L5756:
    jmp       L5754
L5755:
    cmp       rdi,	2147483647
    jb        L5759
    mov       al,	4
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
L5759:
L5754:
    jmp       L5747
L5749:
    test      r14b,	r14b
    jz        L5761
    mov       rax,	rdi
    mov       r10,	4294967295
    cmp       rax,	r10
    jb        L5763
    mov       al,	9
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    jmp       L5762
L5763:
    mov       al,	8
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
L5762:
    jmp       L5760
L5761:
    cmp       rdi,	2147483647
    jb        L5765
    mov       al,	4
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
L5765:
L5760:
    jmp       L5747
L5750:
    test      r14b,	r14b
    jz        L5767
    mov       al,	9
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    jmp       L5766
L5767:
    mov       al,	4
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
L5766:
L5751:
L5747:
    mov       rax,	rdi
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10],	rax
L5721:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.checknumbersuffix
cc_lex.checknumbersuffix:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
L5769:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    mov       dil,	al
    sub       rax,	76
    cmp       rax,	42
    jae       L5772
    lea       r10,	[rip+L5771]
    jmp       [r10 + rax*8]
    .data
L5771:
    .quad     L5773
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5773
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5773
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5772
    .quad     L5773
    .text
L5773:
    jmp       L5769
L5772:
    movzx     rax,	dil
    lea       r10,	[rip+cc_lex.alphamap]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L5775
L5775:
    dec       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5770
L5770:
    mov       rax,	3
L5768:
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc cc_lex.stacksourcefile
cc_lex.stacksourcefile:
#PROC1
#PROC2
#?>>
    .set cc_lex.stacksourcefile.info, -24
    .set cc_lex.stacksourcefile.fullpath, -528
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	568
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      cc_lex.getsourcefile
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L5778
    call      msys.m$print_startcon
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      strlen
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11152]
    call      cc_lex.lxerror
L5778:
    mov       rax,	[rip+cc_lex.lx_stackindex]
    cmp       rax,	20
    jl        L5780
    lea       rcx,	[rip+L11153]
    call      cc_lex.lxerror
L5780:
    inc       qword ptr[rip+cc_lex.lx_stackindex]
    xor       eax,	eax
    mov       [rbp + cc_lex.stacksourcefile.fullpath],	al
    mov       rax,	[rip+cc_lex.lx_stackindex]
    cmp       rax,	1
    jle       L5782
    lea       rax,	[rip+cc_lex.headerpathlist]
    mov       r10,	[rip+cc_lex.lx_stackindex]
    mov       rax,	[rax + r10*8-16]
    lea       rcx,	[rbp + cc_lex.stacksourcefile.fullpath]
    mov       rdx,	rax
    call      strcpy
L5782:
    lea       rax,	[rip+cc_lex.headerpath]
    mov       al,	[rax]
    test      al,	al
    jz        L5784
    lea       rcx,	[rip+cc_lex.headerpath]
    call      mlib.pcm_copyheapstring
    lea       rcx,	[rbp + cc_lex.stacksourcefile.fullpath]
    mov       rdx,	rax
    call      strcat
L5784:
    lea       rcx,	[rbp + cc_lex.stacksourcefile.fullpath]
    call      mlib.pcm_copyheapstring
    lea       r10,	[rip+cc_lex.headerpathlist]
    mov       r11,	[rip+cc_lex.lx_stackindex]
    mov       [r10 + r11*8-8],	rax
    mov       rax,	[rip+cc_lex.lxstart]
    mov       [rbp + cc_lex.stacksourcefile.info],	rax
    mov       rax,	[rip+cc_lex.lxsptr]
    mov       [rbp + cc_lex.stacksourcefile.info+8],	rax
    lea       rax,	[rip+cc_decls.nextlx]
    mov       eax,	[rax+16]
    mov       [rbp + cc_lex.stacksourcefile.info+16],	eax
    call      cc_lex.getfileno
    mov       [rbp + cc_lex.stacksourcefile.info+20],	eax
    lea       rax,	[rbp + cc_lex.stacksourcefile.info]
    lea       r10,	[rip+cc_lex.lx_stack]
    mov       r11,	[rip+cc_lex.lx_stackindex]
    shl       r11,	3
    lea       r11,	[r11 + r11*2]
    mov       r8,	[rax]
    mov       [r10 + r11-24],	r8
    mov       r8,	[rax+8]
    mov       [r10 + r11-16],	r8
    mov       r8,	[rax+16]
    mov       [r10 + r11-8],	r8
    lea       rax,	[rip+cc_decls.sourcefiletext]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       [rip+cc_lex.lxsptr],	rax
    mov       [rip+cc_lex.lxstart],	rax
    mov       rcx,	rdi
    call      cc_lex.setfileno
    mov       eax,	1
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+16],	eax
#---------------
    add       rsp,	568
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.unstacksourcefile
cc_lex.unstacksourcefile:
#PROC1
#PROC2
#?>>
    .set cc_lex.unstacksourcefile.info, -24
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_lex.headerpathlist]
    mov       r10,	[rip+cc_lex.lx_stackindex]
    mov       rdi,	[rax + r10*8-8]
    mov       rcx,	rdi
    call      strlen
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.pcm_free
    mov       rax,	[rip+cc_lex.lx_stackindex]
    dec       qword ptr[rip+cc_lex.lx_stackindex]
    lea       r10,	[rip+cc_lex.lx_stack]
    mov       r11,	rax
    shl       r11,	3
    lea       r11,	[r11 + r11*2]
    lea       r10,	[r10 + r11-24]
    lea       rax,	[rbp + cc_lex.unstacksourcefile.info]
    mov       r11,	[r10]
    mov       [rax],	r11
    mov       r11,	[r10+8]
    mov       [rax+8],	r11
    mov       r11,	[r10+16]
    mov       [rax+16],	r11
    mov       rax,	[rbp + cc_lex.unstacksourcefile.info]
    mov       [rip+cc_lex.lxstart],	rax
    mov       rax,	[rbp + cc_lex.unstacksourcefile.info+8]
    mov       [rip+cc_lex.lxsptr],	rax
    mov       eax,	[rbp + cc_lex.unstacksourcefile.info+16]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+16],	eax
    movsxd    rax,	dword ptr[rbp + cc_lex.unstacksourcefile.info+20]
    mov       rcx,	rax
    call      cc_lex.setfileno
#---------------
    add       rsp,	56
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc cc_lex.getsourcefile
cc_lex.getsourcefile:
#PROC1
#PROC2
#?>>
    .set cc_lex.getsourcefile.syshdr, 48
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    lea       r10,	[rip+cc_lex.headerpath]
    mov       [r10],	al
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    mov       rdx,	rsi
    call      strcpy
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    call      mlib.convlcstring
    mov       rbx,	1
    mov       rax,	[rip+cc_decls.nsourcefiles]
    cmp       rax,	1
    jl        L5789
L5787:
    lea       rax,	[rip+cc_decls.sourcefilenames]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L5791
    mov       rax,	rbx
    jmp       L5786
L5791:
    inc       rbx
    cmp       rbx,	[rip+cc_decls.nsourcefiles]
    jle       L5787
L5789:
    mov       al,	[rip+cc_cli.dointheaders]
    test      al,	al
    jz        L5793
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    call      cc_headers.findheader
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L5795
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    mov       rdx,	rdi
    call      cc_support.loadbuiltin
    jmp       L5786
L5795:
L5793:
    mov       rcx,	rsi
    lea       rdx,	[rip+L11154]
    call      mlib.eqstring
    test      rax,	rax
    jz        L5797
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    lea       rdx,	[rip+L11155]
    call      cc_support.loadbuiltin
    jmp       L5786
L5797:
    mov       rcx,	rsi
    call      mlib.extractpath
    lea       rcx,	[rip+cc_lex.headerpath]
    mov       rdx,	rax
    call      strcpy
    lea       rax,	[rip+cc_lex.headerpath]
    mov       al,	[rax]
    test      al,	al
    jz        L5799
    lea       rax,	[rip+cc_lex.headerpath]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	47
    jz        L5802
    lea       rax,	[rip+cc_lex.headerpath]
    movzx     rax,	byte ptr[rax+1]
    cmp       rax,	58
    jnz       L5801
    lea       rax,	[rip+cc_lex.headerpath]
    movzx     rax,	byte ptr[rax+2]
    cmp       rax,	47
    jnz       L5801
L5802:
    mov       rcx,	rsi
    call      mlib.checkfile
    test      rax,	rax
    jz        L5804
    mov       rcx,	rsi
    mov       rdx,	rsi
    call      cc_support.loadsourcefile
    jmp       L5786
L5804:
    xor       eax,	eax
    jmp       L5786
L5801:
L5799:
    mov       rbx,	[rip+cc_lex.lx_stackindex]
    cmp       rbx,	1
    jl        L5807
L5805:
    lea       rax,	[rip+cc_lex.headerpathlist]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    mov       rdx,	rsi
    call      strcat
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    call      mlib.checkfile
    test      rax,	rax
    jz        L5809
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    mov       rdx,	rsi
    call      cc_support.loadsourcefile
    jmp       L5786
L5809:
    dec       rbx
    cmp       rbx,	1
    jge       L5805
L5807:
    mov       rbx,	1
    mov       rax,	[rip+cc_decls.nsearchdirs]
    cmp       rax,	1
    jl        L5812
L5810:
    lea       rax,	[rip+cc_decls.searchdirs]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    mov       rdx,	rsi
    call      strcat
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    call      mlib.checkfile
    test      rax,	rax
    jz        L5814
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    call      mlib.extractpath
    lea       rcx,	[rip+cc_lex.headerpath]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rip+cc_lex.getsourcefile.filespec]
    mov       rdx,	rsi
    call      cc_support.loadsourcefile
    jmp       L5786
L5814:
    inc       rbx
    cmp       rbx,	[rip+cc_decls.nsearchdirs]
    jle       L5810
L5812:
    xor       eax,	eax
L5786:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.lex
cc_lex.lex:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
#cc_lex.lex.reenter:
    lea       rax,	[rip+cc_decls.nextlx]
    lea       r10,	[rip+cc_decls.lx]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
    call      cc_lex.lexm
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jnz       L5818
    mov       rax,	[rip+cc_lex.lx_stackindex]
    test      rax,	rax
    jnz       L5818
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       rax,	[rax]
    lea       r10,	[rip+cc_decls.lx]
    movsxd    r10,	dword ptr[r10+24]
    xor       r11d,	r11d
    mov       [rax + r10],	r11b
L5818:
L5819:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L5821
    cmp       rax,	56
    jz        L5822
    jmp       L5823
L5821:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    mov       al,	[rax+107]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	68
    jnz       L5825
    mov       al,	67
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5825:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    mov       ax,	[rax+100]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    jmp       L5815
L5822:
    call      cc_lex.lexm
    jmp       L5819
L5823:
    jmp       L5815
L5815:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_lex.shownumberstr
cc_lex.shownumberstr:
#PROC1
#PROC2
#?>>
    .set cc_lex.shownumberstr.$T1, -8
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      cc_lex.getfilenox
    test      rax,	rax
    jz        L5828
    mov       rcx,	rbx
    call      cc_lex.getfilenox
    lea       r10,	[rip+cc_decls.sourcefiletext]
    mov       r10,	[r10 + rax*8]
    mov       [rbp + cc_lex.shownumberstr.$T1],	r10
    mov       rcx,	rbx
    call      cc_lex.getnumberoffsetx
    mov       r10,	[rbp + cc_lex.shownumberstr.$T1]
    lea       r10,	[r10 + rax]
    mov       rdi,	r10
    jmp       L5827
L5828:
    movsx     rax,	word ptr[rbx+28]
    lea       r10,	[rip+cc_lex.pastedtokenlist]
    mov       r10,	[r10 + rax*8-8]
    mov       rdi,	r10
L5827:
    movsxd    rax,	dword ptr[rbx+24]
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	rsi
    call      cc_lex.printstrn
#---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.addnamestr
cc_lex.addnamestr:
#PROC1
#PROC2
#?>>
    .set cc_lex.addnamestr.oldlx, -32
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.nextlx]
    lea       r10,	[rbp + cc_lex.addnamestr.oldlx]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
    mov       rcx,	rbx
    call      strlen
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+24]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      cc_lex.gethashvalue
    mov       [rip+cc_lex.lxhashvalue],	rax
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+24]
    inc       rax
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rip+cc_lex.lxsvalue],	rax
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+24]
    inc       rax
    mov       rcx,	[rip+cc_lex.lxsvalue]
    mov       rdx,	rbx
    mov       r8,	rax
    call      memcpy
    call      cc_lex.lookup
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rdi,	[rax]
    lea       rax,	[rbp + cc_lex.addnamestr.oldlx]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
    mov       rax,	rdi
L5829:
#---------------
    add       rsp,	64
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.lxreadstring
cc_lex.lxreadstring:
#PROC1
#PROC2
#?>>
    .set cc_lex.lxreadstring.termchar, 72
    .set cc_lex.lxreadstring.fwide, 80
    .set cc_lex.lxreadstring.str, -2048
    .set cc_lex.lxreadstring.useheap, -2056
    .set cc_lex.lxreadstring.av_1, -2064
    .set cc_lex.lxreadstring.av_2, -2072
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2104
    mov       [rbp+72],	rcx
    mov       [rbp+80],	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + cc_lex.lxreadstring.termchar]
    cmp       rax,	34
    jnz       L5832
    mov       rax,	[rbp + cc_lex.lxreadstring.fwide]
    test      rax,	rax
    jz        L5834
    mov       rax,	64
    jmp       L5833
L5834:
    mov       rax,	63
L5833:
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5831
L5832:
    mov       al,	61
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
L5831:
    mov       rax,	[rip+cc_lex.lxsptr]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10],	rax
    mov       rax,	[rip+cc_lex.lx_stackindex]
    test      rax,	rax
    jnz       L5836
    mov       rax,	[rbp + cc_lex.lxreadstring.fwide]
    test      rax,	rax
    jnz       L5836
    mov       rdi,	[rip+cc_lex.lxsptr]
    mov       rbx,	rdi
    xor       eax,	eax
    mov       [rbp + cc_lex.lxreadstring.useheap],	rax
    jmp       L5835
L5836:
    lea       rax,	[rbp + cc_lex.lxreadstring.str]
    mov       rdi,	rax
    mov       rbx,	rdi
    mov       rax,	1
    mov       [rbp + cc_lex.lxreadstring.useheap],	rax
L5835:
    xor       r15,	r15
L5837:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    mov       r13,	rax
    cmp       rax,	92
    jz        L5840
    cmp       rax,	34
    jz        L5841
    cmp       rax,	39
    jz        L5841
    test      rax,	rax
    jz        L5842
    jmp       L5843
L5840:
    mov       rax,	[rip+cc_lex.isincludefile]
    test      rax,	rax
    jz        L5845
    mov       r13,	47
    jmp       L5846
L5845:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    mov       r13,	rax
#cc_lex.lxreadstring.reenter:
    lea       rax,	[r13-10]
    cmp       rax,	111
    jae       L5850
    lea       r10,	[rip+L5849]
    jmp       [r10 + rax*8]
    .data
L5849:
    .quad     L5880
    .quad     L5850
    .quad     L5850
    .quad     L5877
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5874
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5876
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5867
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5875
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5851
    .quad     L5852
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5853
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5854
    .quad     L5850
    .quad     L5850
    .quad     L5850
    .quad     L5855
    .quad     L5850
    .quad     L5856
    .quad     L5850
    .quad     L5857
    .quad     L5850
    .quad     L5858
    .text
L5851:
    mov       r13,	7
    jmp       L5848
L5852:
    mov       r13,	8
    jmp       L5848
L5853:
    mov       r13,	12
    jmp       L5848
L5854:
    mov       r13,	10
    jmp       L5848
L5855:
    mov       r13,	13
    jmp       L5848
L5856:
    mov       r13,	9
    jmp       L5848
L5857:
    mov       r13,	11
    jmp       L5848
L5858:
    xor       r13,	r13
L5859:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    mov       r14,	rax
    sub       rax,	48
    cmp       rax,	55
    jae       L5863
    lea       r10,	[rip+L5862]
    jmp       [r10 + rax*8]
    .data
L5862:
    .quad     L5866
    .quad     L5866
    .quad     L5866
    .quad     L5866
    .quad     L5866
    .quad     L5866
    .quad     L5866
    .quad     L5866
    .quad     L5866
    .quad     L5866
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5864
    .quad     L5864
    .quad     L5864
    .quad     L5864
    .quad     L5864
    .quad     L5864
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5863
    .quad     L5865
    .quad     L5865
    .quad     L5865
    .quad     L5865
    .quad     L5865
    .quad     L5865
    .text
L5864:
    mov       rax,	r13
    shl       rax,	4
    add       rax,	r14
    sub       rax,	65
    add       rax,	10
    mov       r13,	rax
    jmp       L5861
L5865:
    mov       rax,	r13
    shl       rax,	4
    add       rax,	r14
    sub       rax,	97
    add       rax,	10
    mov       r13,	rax
    jmp       L5861
L5866:
    mov       rax,	r13
    shl       rax,	4
    add       rax,	r14
    sub       rax,	48
    mov       r13,	rax
    jmp       L5861
L5863:
    dec       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5860
L5861:
    jmp       L5859
L5860:
    jmp       L5848
L5867:
    mov       rax,	48
    sub       r13,	rax
    mov       rax,	2
    mov       [rbp + cc_lex.lxreadstring.av_1],	rax
L5868:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    mov       r14,	rax
    cmp       rax,	48
    jz        L5872
    cmp       rax,	49
    jz        L5872
    cmp       rax,	50
    jz        L5872
    cmp       rax,	51
    jz        L5872
    cmp       rax,	52
    jz        L5872
    cmp       rax,	53
    jz        L5872
    cmp       rax,	54
    jz        L5872
    cmp       rax,	55
    jnz       L5873
L5872:
    mov       rax,	r13
    shl       rax,	3
    add       rax,	r14
    sub       rax,	48
    mov       r13,	rax
    jmp       L5871
L5873:
    dec       qword ptr[rip+cc_lex.lxsptr]
    jmp       L5870
L5871:
    dec       qword ptr[rbp + cc_lex.lxreadstring.av_1]
    jnz       L5868
L5870:
    jmp       L5848
L5874:
    mov       r13,	34
    jmp       L5848
L5875:
    mov       r13,	92
    jmp       L5848
L5876:
    mov       r13,	39
    jmp       L5848
L5877:
    lea       rax,	[rip+cc_decls.nextlx]
    lea       rax,	[rax+16]
    inc       dword ptr[rax]
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	10
    jnz       L5879
    inc       qword ptr[rip+cc_lex.lxsptr]
L5879:
    jmp       L5837
L5880:
    lea       rax,	[rip+cc_decls.nextlx]
    lea       rax,	[rax+16]
    inc       dword ptr[rax]
    jmp       L5837
L5850:
L5848:
    jmp       L5839
L5841:
    cmp       r13,	[rbp + cc_lex.lxreadstring.termchar]
    jz        L5838
L5882:
    jmp       L5839
L5842:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11156]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.nextlx]
    mov       eax,	[rax+16]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11157]
    call      cc_lex.lxerror
L5843:
L5839:
#cc_lex.lxreadstring.normalchar:
L5846:
    mov       rax,	[rbp + cc_lex.lxreadstring.useheap]
    test      rax,	rax
    jnz       L5884
    mov       rax,	rdi
    inc       rdi
    mov       r10b,	r13b
    mov       [rax],	r10b
    jmp       L5883
L5884:
    inc       r15
    cmp       r15,	2048
    jge       L5885
    mov       rax,	rdi
    inc       rdi
    mov       r10b,	r13b
    mov       [rax],	r10b
    jmp       L5883
L5885:
    lea       rcx,	[rip+L11158]
    call      cc_lex.lxerror
L5883:
    jmp       L5837
L5838:
    xor       eax,	eax
    mov       [rdi],	al
    mov       rax,	[rbp + cc_lex.lxreadstring.fwide]
    test      rax,	rax
    jz        L5887
    mov       rax,	r15
    shl       rax,	1
    add       rax,	2
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rsi,	rax
    mov       r12,	rax
    mov       [rbp + cc_lex.lxreadstring.av_2],	r15
    mov       rax,	[rbp + cc_lex.lxreadstring.av_2]
    cmp       rax,	0
    jle       L5890
L5888:
    mov       rax,	rbx
    inc       rbx
    movzx     rax,	byte ptr[rax]
    mov       r10,	rsi
    add       rsi,	2
    mov       [r10],	ax
    dec       qword ptr[rbp + cc_lex.lxreadstring.av_2]
    jnz       L5888
L5890:
    xor       eax,	eax
    mov       [rsi],	ax
    mov       rax,	r12
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10],	rax
    jmp       L5886
L5887:
    mov       rax,	[rbp + cc_lex.lxreadstring.useheap]
    test      rax,	rax
    jz        L5891
    mov       eax,	r15d
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
    lea       rax,	[r15+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10],	rax
    lea       rax,	[r15+1]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       r10,	[r10]
    mov       rcx,	r10
    lea       rdx,	[rbp + cc_lex.lxreadstring.str]
    mov       r8,	rax
    call      memcpy
    jmp       L5886
L5891:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    mov       r10,	rdi
    sub       r10,	rax
    lea       rax,	[rip+cc_decls.nextlx]
    mov       [rax+24],	r10d
L5886:
#---------------
    add       rsp,	2104
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.addlisttoken
cc_lex.addlisttoken:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rcx]
    test      rax,	rax
    jnz       L5894
    mov       rax,	r8
    mov       [rdx],	rax
    mov       [rcx],	rax
    jmp       L5893
L5894:
    mov       rax,	[rdx]
    mov       r10,	r8
    mov       [rax+8],	r10
L5893:
    xor       eax,	eax
    mov       [r8+8],	rax
    mov       [rdx],	r8
#---------------
    ret       
# End 
# Proc cc_lex.addlisttoken_copy
cc_lex.addlisttoken_copy:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    call      cc_lex.alloctoken
    mov       rdi,	rax
    mov       rax,	r12
    mov       r10,	[rax]
    mov       [rdi],	r10
    mov       r10,	[rax+8]
    mov       [rdi+8],	r10
    mov       r10,	[rax+16]
    mov       [rdi+16],	r10
    mov       r10,	[rax+24]
    mov       [rdi+24],	r10
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       rax,	[rbx]
    test      rax,	rax
    jnz       L5897
    mov       rax,	rdi
    mov       [rsi],	rax
    mov       [rbx],	rax
    jmp       L5896
L5897:
    mov       rax,	[rsi]
    mov       r10,	rdi
    mov       [rax+8],	r10
L5896:
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       [rsi],	rdi
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.addlist_nextlx
cc_lex.addlist_nextlx:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    call      cc_lex.alloctoken
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.nextlx]
    mov       r10,	[rax]
    mov       [rdi],	r10
    mov       r10,	[rax+8]
    mov       [rdi+8],	r10
    mov       r10,	[rax+16]
    mov       [rdi+16],	r10
    mov       r10,	[rax+24]
    mov       [rdi+24],	r10
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       rax,	[rbx]
    test      rax,	rax
    jnz       L5900
    mov       rax,	rdi
    mov       [rsi],	rax
    mov       [rbx],	rax
    jmp       L5899
L5900:
    mov       rax,	[rsi]
    mov       r10,	rdi
    mov       [rax+8],	r10
L5899:
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       [rsi],	rdi
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.addlisttoken_seq
cc_lex.addlisttoken_seq:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    jmp       L5903
L5902:
    call      cc_lex.alloctoken
    mov       rdi,	rax
    mov       rax,	r12
    mov       r10,	[rax]
    mov       [rdi],	r10
    mov       r10,	[rax+8]
    mov       [rdi+8],	r10
    mov       r10,	[rax+16]
    mov       [rdi+16],	r10
    mov       r10,	[rax+24]
    mov       [rdi+24],	r10
    mov       rax,	[rbx]
    test      rax,	rax
    jnz       L5906
    mov       rax,	rdi
    mov       [rsi],	rax
    mov       [rbx],	rax
    jmp       L5905
L5906:
    mov       rax,	[rsi]
    mov       r10,	rdi
    mov       [rax+8],	r10
L5905:
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       [rsi],	rdi
    mov       r12,	[r12+8]
L5903:
    test      r12,	r12
    jnz       L5902
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.addlistmparam
cc_lex.addlistmparam:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rcx]
    test      rax,	rax
    jnz       L5909
    mov       rax,	r8
    mov       [rdx],	rax
    mov       [rcx],	rax
    jmp       L5908
L5909:
    mov       rax,	[rdx]
    mov       r10,	r8
    mov       [rax+8],	r10
L5908:
    mov       [rdx],	r8
#---------------
    ret       
# End 
# Proc cc_lex.dodefine
cc_lex.dodefine:
#PROC1
#PROC2
#?>>
    .set cc_lex.dodefine.stlist, -8
    .set cc_lex.dodefine.stlistx, -16
    .set cc_lex.dodefine.tklist, -24
    .set cc_lex.dodefine.tklistx, -32
    .set cc_lex.dodefine.ntokens, -40
    .set cc_lex.dodefine.paramno, -48
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
#---------------
#PROC3
#PROC4
    call      cc_lex.lexreadtoken
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L5912
    lea       rcx,	[rip+L11159]
    call      cc_lex.lxerror
L5912:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rsi,	[rax]
    lea       rax,	[rip+cc_decls.nextlx]
    mov       eax,	[rax+16]
    mov       [rsi+92],	eax
    lea       rax,	[rip+cc_decls.nextlx]
    mov       al,	[rax+20]
    mov       [rsi+113],	al
    mov       al,	[rsi+107]
    mov       [rsi+88],	al
    mov       al,	67
    mov       [rsi+107],	al
    mov       al,	1
    mov       [rsi+109],	al
    xor       r14,	r14
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	40
    jnz       L5914
    inc       qword ptr[rip+cc_lex.lxsptr]
    xor       eax,	eax
    mov       [rbp + cc_lex.dodefine.stlistx],	rax
    mov       [rbp + cc_lex.dodefine.stlist],	rax
    lea       rax,	[rsi+108]
    or        byte ptr[rax],	4
    call      cc_lex.lexreadtoken
L5915:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L5918
    cmp       rax,	14
    jz        L5919
    cmp       rax,	21
    jz        L5920
    jmp       L5921
L5918:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       r12,	[rax]
    mov       rdi,	[rbp + cc_lex.dodefine.stlist]
    jmp       L5923
L5922:
    mov       rax,	[rdi]
    cmp       rax,	r12
    jnz       L5926
    lea       rcx,	[rip+L11160]
    call      cc_lex.lxerror
L5926:
    mov       rdi,	[rdi+8]
L5923:
    test      rdi,	rdi
    jnz       L5922
    mov       rcx,	16
    call      mlib.pcm_alloc
    mov       rbx,	rax
    mov       [rbx],	r12
    xor       eax,	eax
    mov       [rbx+8],	rax
    lea       rcx,	[rbp + cc_lex.dodefine.stlist]
    lea       rdx,	[rbp + cc_lex.dodefine.stlistx]
    mov       r8,	rbx
    call      cc_lex.addlistmparam
    inc       r14
    call      cc_lex.lexreadtoken
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jnz       L5928
    call      cc_lex.lexreadtoken
L5928:
    jmp       L5917
L5919:
    jmp       L5916
L5920:
    lea       rcx,	[rip+L11161]
    call      cc_lex.addnamestr
    mov       r12,	rax
    lea       rax,	[rsi+108]
    or        byte ptr[rax],	2
    call      cc_lex.lexreadtoken
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	14
    jz        L5930
    lea       rcx,	[rip+L11162]
    call      cc_lex.lxerror
L5930:
    mov       rcx,	16
    call      mlib.pcm_alloc
    mov       rbx,	rax
    mov       [rbx],	r12
    xor       eax,	eax
    mov       [rbx+8],	rax
    lea       rcx,	[rbp + cc_lex.dodefine.stlist]
    lea       rdx,	[rbp + cc_lex.dodefine.stlistx]
    mov       r8,	rbx
    call      cc_lex.addlistmparam
    inc       r14
    jmp       L5916
L5921:
    lea       rcx,	[rip+L11163]
    call      cc_lex.lxerror
L5917:
    jmp       L5915
L5916:
    mov       rax,	[rbp + cc_lex.dodefine.stlist]
    mov       [rsi+80],	rax
L5914:
    xor       eax,	eax
    mov       [rbp + cc_lex.dodefine.tklistx],	rax
    mov       [rbp + cc_lex.dodefine.tklist],	rax
    xor       eax,	eax
    mov       [rbp + cc_lex.dodefine.ntokens],	rax
L5931:
    call      cc_lex.lexreadtoken
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	56
    jz        L5934
    cmp       rax,	57
    jz        L5934
    cmp       rax,	67
    jz        L5935
    jmp       L5936
L5934:
    jmp       L5932
L5935:
    mov       rdi,	[rsi+80]
    mov       rax,	1
    mov       [rbp + cc_lex.dodefine.paramno],	rax
    jmp       L5938
L5937:
    mov       rax,	[rdi]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       r10,	[r10]
    cmp       rax,	r10
    jnz       L5941
    lea       rax,	[rip+cc_decls.nextlx]
    lea       rax,	[rax+23]
    mov       r10b,	2
    or        [rax],	r10b
    mov       ax,	[rbp + cc_lex.dodefine.paramno]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+28],	ax
    jmp       L5939
L5941:
    mov       rdi,	[rdi+8]
    inc       qword ptr[rbp + cc_lex.dodefine.paramno]
L5938:
    test      rdi,	rdi
    jnz       L5937
L5939:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    cmp       rax,	rsi
    jnz       L5943
    lea       rax,	[rip+cc_decls.nextlx]
    lea       rax,	[rax+23]
    mov       r10b,	1
    or        [rax],	r10b
L5943:
L5936:
L5933:
    inc       qword ptr[rbp + cc_lex.dodefine.ntokens]
    call      cc_lex.alloctoken
    mov       r13,	rax
    lea       rax,	[rip+cc_decls.nextlx]
    mov       r10,	[rax]
    mov       [r13],	r10
    mov       r10,	[rax+8]
    mov       [r13+8],	r10
    mov       r10,	[rax+16]
    mov       [r13+16],	r10
    mov       r10,	[rax+24]
    mov       [r13+24],	r10
    lea       rcx,	[rbp + cc_lex.dodefine.tklist]
    lea       rdx,	[rbp + cc_lex.dodefine.tklistx]
    mov       r8,	r13
    call      cc_lex.addlisttoken
    jmp       L5931
L5932:
    mov       rax,	[rbp + cc_lex.dodefine.tklist]
    mov       [rsi+72],	rax
    mov       [rsi+111],	r14b
#---------------
    add       rsp,	80
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.readalphanumeric
cc_lex.readalphanumeric:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
L5945:
L5946:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    lea       r10,	[rip+cc_lex.alphamap]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L5945
    dec       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	rcx
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10],	rax
    mov       al,	58
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	rcx
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
#---------------
    ret       
# End 
# Proc cc_lex.inmacrostack
cc_lex.inmacrostack:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    jmp       L5950
L5949:
    mov       rax,	[rdx]
    cmp       rax,	rcx
    jnz       L5953
    mov       rax,	1
    jmp       L5948
L5953:
    mov       rdx,	[rdx+8]
L5950:
    test      rdx,	rdx
    jnz       L5949
    xor       eax,	eax
L5948:
#---------------
    ret       
# End 
# Proc cc_lex.showtokens
cc_lex.showtokens:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11164]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L5956
L5955:
    mov       rcx,	rbx
    call      cc_lex.showtoken
    mov       rbx,	[rbx+8]
L5956:
    test      rbx,	rbx
    jnz       L5955
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11165]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.lexa
cc_lex.lexa:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rdi]
    cmp       rax,	[rip+cc_lex.normaltk]
    jnz       L5960
    call      cc_lex.lexreadtoken
    jmp       L5958
L5960:
    mov       rax,	[rdi]
    test      rax,	rax
    jnz       L5962
    mov       al,	57
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L5958
L5962:
    mov       rax,	[rdi]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
    mov       rax,	[rdi]
    mov       rax,	[rax+8]
    mov       [rdi],	rax
L5958:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lex.lexm
cc_lex.lexm:
#PROC1
#PROC2
#?>>
    .set cc_lex.lexm.newlineno, -8
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
#---------------
#PROC3
#PROC4
L5964:
    mov       rax,	[rip+cc_lex.tkptr]
    test      rax,	rax
    jz        L5967
    mov       rax,	[rip+cc_lex.tkptr]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
    mov       rax,	[rip+cc_lex.tkptr]
    mov       rax,	[rax+8]
    mov       [rip+cc_lex.tkptr],	rax
    mov       rax,	[rip+cc_lex.tkptr]
    test      rax,	rax
    jnz       L5969
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jnz       L5971
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	1
    jnz       L5971
    call      cc_lex.peeklb
    test      rax,	rax
    jz        L5971
    mov       rcx,	[rip+cc_decls.sfileno]
    call      cc_lex.setfileno
    mov       eax,	[rip+cc_decls.slineno]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+16],	eax
    xor       eax,	eax
    mov       [rip+cc_lex.lexm.doreset],	rax
    jmp       L5972
L5971:
    mov       rax,	1
    mov       [rip+cc_lex.lexm.doreset],	rax
L5969:
    jmp       L5963
L5967:
    mov       rax,	[rip+cc_lex.lexm.doreset]
    test      rax,	rax
    jz        L5974
    mov       rcx,	[rip+cc_decls.sfileno]
    call      cc_lex.setfileno
    mov       eax,	[rip+cc_decls.slineno]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+16],	eax
    xor       eax,	eax
    mov       [rip+cc_lex.lexm.doreset],	rax
L5974:
    mov       rax,	[rip+cc_lex.firstsymbol]
    test      rax,	rax
    jz        L5976
    xor       eax,	eax
    mov       [rip+cc_lex.firstsymbol],	rax
    call      cc_lex.dospecialinclude
L5976:
    call      cc_lex.lexreadtoken
#cc_lex.lexm.test1:
L5972:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	4
    jz        L5978
    cmp       rax,	67
    jz        L5979
    jmp       L5980
L5978:
    call      cc_lex.dolexdirective
    test      rax,	rax
    jnz       L5963
L5982:
    jmp       L5964
L5979:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rdi,	[rax]
    movzx     rax,	byte ptr[rdi+107]
    cmp       rax,	69
    jnz       L5985
L5984:
    call      cc_lex.getfileno
    mov       [rip+cc_decls.sfileno],	rax
    lea       rax,	[rip+cc_decls.nextlx]
    mov       eax,	[rax+16]
    mov       [rip+cc_decls.slineno],	rax
    movsx     rax,	word ptr[rdi+100]
    mov       rcx,	rax
    lea       rdx,	[rip+cc_decls.nextlx]
    mov       r8,	[rip+cc_decls.slineno]
    call      cc_lex.expandpredefmacro
    mov       rax,	1
    mov       [rip+cc_lex.lexm.doreset],	rax
    jmp       L5963
L5985:
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	1
    jnz       L5988
    mov       rax,	[rip+cc_lex.noexpand]
    test      rax,	rax
    jz        L5987
L5988:
    jmp       L5963
L5987:
L5983:
    jmp       L5977
L5980:
    jmp       L5963
L5977:
    call      cc_lex.getfileno
    mov       [rip+cc_decls.sfileno],	rax
    lea       rax,	[rip+cc_decls.nextlx]
    mov       eax,	[rax+16]
    mov       [rip+cc_decls.slineno],	rax
    movzx     rax,	byte ptr[rdi+108]
    shr       eax,	2
    and       eax,	1
    test      rax,	rax
    jz        L5990
    call      cc_lex.peeklb
    test      rax,	rax
    jz        L5963
L5992:
    sub       rsp,	8
    lea       rax,	[rbp + cc_lex.lexm.newlineno]
    push      rax
    mov       rcx,	rdi
    xor       edx,	edx
    lea       r8,	[rip+cc_lex.normaltk]
    mov       r9,	1
    sub       rsp,	32
    call      cc_lex.expandfnmacro
    add       rsp,	48
    mov       [rip+cc_lex.tkptr],	rax
    mov       rax,	[rbp + cc_lex.lexm.newlineno]
    mov       [rip+cc_decls.slineno],	rax
    jmp       L5989
L5990:
    mov       rcx,	rdi
    xor       edx,	edx
    lea       r8,	[rip+cc_lex.normaltk]
    mov       r9,	1
    call      cc_lex.expandobjmacro
    mov       [rip+cc_lex.tkptr],	rax
L5989:
    mov       rax,	[rip+cc_lex.tkptr]
    test      rax,	rax
    jnz       L5994
    mov       rax,	1
    mov       [rip+cc_lex.lexm.doreset],	rax
L5994:
    jmp       L5964
L5963:
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc cc_lex.peeklb
cc_lex.peeklb:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	40
    jz        L5998
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	32
    jnz       L5997
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax+1]
    cmp       rax,	40
    jnz       L5997
L5998:
    mov       rax,	1
    jmp       L5995
L5997:
    xor       eax,	eax
L5995:
#---------------
    ret       
# End 
# Proc cc_lex.peektk
cc_lex.peektk:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rcx+8]
    mov       rcx,	rax
    test      rcx,	rcx
    jnz       L6001
    xor       eax,	eax
    jmp       L5999
L6001:
    movzx     rax,	byte ptr[rcx+21]
    cmp       rax,	13
    jnz       L6003
    mov       rax,	1
    jmp       L5999
L6003:
    xor       eax,	eax
L5999:
#---------------
    ret       
# End 
# Proc cc_lex.expandobjmacro
cc_lex.expandobjmacro:
#PROC1
#PROC2
#?>>
    .set cc_lex.expandobjmacro.m, 64
    .set cc_lex.expandobjmacro.macrostack, 72
    .set cc_lex.expandobjmacro.tksource, 80
    .set cc_lex.expandobjmacro.frombaselevel, 88
    .set cc_lex.expandobjmacro.newmacro, -32
    .set cc_lex.expandobjmacro.expanded, -40
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       [rbp+64],	rcx
    mov       [rbp+72],	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + cc_lex.expandobjmacro.m]
    mov       rax,	[rax+72]
    mov       rdi,	rax
    mov       rbx,	rax
    xor       eax,	eax
    mov       r13,	rax
    mov       r12,	rax
    jmp       L6006
L6005:
    movzx     rax,	byte ptr[rbx+21]
    cmp       rax,	67
    jnz       L6009
    mov       r14,	[rbx]
    movzx     rax,	byte ptr[r14+109]
    cmp       rax,	1
    jz        L6012
    movzx     rax,	byte ptr[r14+107]
    cmp       rax,	69
    jnz       L6011
L6012:
    mov       r12,	1
    jmp       L6007
L6011:
    jmp       L6008
L6009:
    movzx     rax,	byte ptr[rbx+21]
    cmp       rax,	7
    jnz       L6013
    mov       rax,	1
    mov       r13,	rax
    mov       r12,	rax
    jmp       L6007
L6013:
L6008:
    mov       rbx,	[rbx+8]
L6006:
    test      rbx,	rbx
    jnz       L6005
L6007:
    test      r12,	r12
    jnz       L6015
    mov       rax,	rdi
    jmp       L6004
L6015:
    mov       rax,	[rbp + cc_lex.expandobjmacro.m]
    mov       [rbp + cc_lex.expandobjmacro.newmacro],	rax
    mov       rax,	[rbp + cc_lex.expandobjmacro.macrostack]
    mov       [rbp + cc_lex.expandobjmacro.newmacro+8],	rax
    test      r13,	r13
    jz        L6017
    sub       rsp,	8
    push      0
    mov       rcx,	[rbp + cc_lex.expandobjmacro.m]
    xor       edx,	edx
    xor       r8d,	r8d
    xor       r9d,	r9d
    sub       rsp,	32
    call      cc_lex.substituteargs
    add       rsp,	48
    mov       rsi,	rax
    jmp       L6016
L6017:
    mov       rax,	[rbp + cc_lex.expandobjmacro.m]
    mov       rsi,	[rax+72]
L6016:
    mov       rcx,	rsi
    lea       rdx,	[rbp + cc_lex.expandobjmacro.newmacro]
    lea       r8,	[rbp + cc_lex.expandobjmacro.expanded]
    call      cc_lex.scantokenseq
    mov       rdi,	rax
    mov       rax,	rdi
L6004:
#---------------
    add       rsp,	80
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.expandfnmacro
cc_lex.expandfnmacro:
#PROC1
#PROC2
#?>>
    .set cc_lex.expandfnmacro.frombaselevel, 88
    .set cc_lex.expandfnmacro.endlineno, 96
    .set cc_lex.expandfnmacro.args, -1600
    .set cc_lex.expandfnmacro.expargs, -3200
    .set cc_lex.expandfnmacro.newmacro, -3232
    .set cc_lex.expandfnmacro.expanded, -3240
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	3280
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    lea       rdx,	[rbp + cc_lex.expandfnmacro.args]
    mov       r8,	r14
    call      cc_lex.readmacrocall
    mov       rbx,	rax
    mov       rax,	[rbp + cc_lex.expandfnmacro.frombaselevel]
    test      rax,	rax
    jz        L6020
    lea       rax,	[rip+cc_decls.nextlx]
    mov       eax,	[rax+16]
    mov       r10,	[rbp + cc_lex.expandfnmacro.endlineno]
    mov       [r10],	rax
L6020:
    mov       rsi,	1
    cmp       rbx,	1
    jl        L6023
L6021:
    xor       eax,	eax
    mov       [rbp + rsi*8 + cc_lex.expandfnmacro.expargs-8],	rax
    inc       rsi
    cmp       rsi,	rbx
    jle       L6021
L6023:
    sub       rsp,	8
    mov       rax,	r13
    push      rax
    mov       rcx,	r12
    lea       rdx,	[rbp + cc_lex.expandfnmacro.args]
    lea       r8,	[rbp + cc_lex.expandfnmacro.expargs]
    mov       r9,	rbx
    sub       rsp,	32
    call      cc_lex.substituteargs
    add       rsp,	48
    mov       rdi,	rax
    mov       [rbp + cc_lex.expandfnmacro.newmacro],	r12
    mov       [rbp + cc_lex.expandfnmacro.newmacro+8],	r13
    mov       rcx,	rdi
    lea       rdx,	[rbp + cc_lex.expandfnmacro.newmacro]
    lea       r8,	[rbp + cc_lex.expandfnmacro.expanded]
    call      cc_lex.scantokenseq
    mov       rdi,	rax
    mov       rax,	rdi
L6018:
#---------------
    add       rsp,	3280
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.scantokenseq
cc_lex.scantokenseq:
#PROC1
#PROC2
#?>>
    .set cc_lex.scantokenseq.tk, 64
    .set cc_lex.scantokenseq.expanded, 80
    .set cc_lex.scantokenseq.newtk, -8
    .set cc_lex.scantokenseq.newtkx, -16
    .set cc_lex.scantokenseq.dummy, -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+64],	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
#---------------
#PROC3
#PROC4
#cc_lex.scantokenseq.reenter:
L6025:
    xor       eax,	eax
    mov       r10,	[rbp + cc_lex.scantokenseq.expanded]
    mov       [r10],	rax
    xor       eax,	eax
    mov       [rbp + cc_lex.scantokenseq.newtkx],	rax
    mov       [rbp + cc_lex.scantokenseq.newtk],	rax
    xor       r12,	r12
    mov       rax,	1
    mov       r13,	rax
    mov       rbx,	[rbp + cc_lex.scantokenseq.tk]
    jmp       L6027
L6026:
    mov       rax,	[rbp + cc_lex.scantokenseq.tk]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jnz       L6031
L6030:
    mov       rax,	[rbp + cc_lex.scantokenseq.tk]
    mov       rax,	[rax]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	1
    jz        L6034
    mov       rax,	[rbp + cc_lex.scantokenseq.tk]
    mov       rax,	[rax]
    movzx     rax,	byte ptr[rax+107]
    cmp       rax,	69
    jnz       L6033
L6034:
    xor       r13,	r13
    jmp       L6028
L6033:
L6031:
L6029:
    mov       rax,	[rbp + cc_lex.scantokenseq.tk]
    test      rax,	rax
    jz        L6028
L6036:
    mov       rax,	[rbp + cc_lex.scantokenseq.tk]
    mov       rax,	[rax+8]
    mov       [rbp + cc_lex.scantokenseq.tk],	rax
L6027:
    mov       rax,	[rbp + cc_lex.scantokenseq.tk]
    test      rax,	rax
    jnz       L6026
L6028:
    test      r13,	r13
    jz        L6038
    mov       rax,	rbx
    jmp       L6024
L6038:
    mov       [rbp + cc_lex.scantokenseq.tk],	rbx
    jmp       L6040
L6039:
    mov       rax,	[rbp + cc_lex.scantokenseq.tk]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jnz       L6044
L6043:
    mov       rax,	[rbp + cc_lex.scantokenseq.tk]
    mov       rsi,	[rax]
    movzx     rax,	byte ptr[rsi+109]
    cmp       rax,	1
    jnz       L6046
    test      r12,	r12
    jnz       L6046
    mov       rax,	[rbp + cc_lex.scantokenseq.tk]
    movzx     rax,	byte ptr[rax+23]
    and       rax,	4
    jnz       L6049
    mov       rax,	[rip+cc_lex.noexpand]
    test      rax,	rax
    jz        L6048
L6049:
    jmp       L6050
L6048:
    mov       rcx,	rsi
    mov       rdx,	r14
    call      cc_lex.inmacrostack
    test      rax,	rax
    jz        L6052
    lea       rcx,	[rbp + cc_lex.scantokenseq.newtk]
    lea       rdx,	[rbp + cc_lex.scantokenseq.newtkx]
    mov       r8,	[rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.addlisttoken_copy
    mov       rax,	[rbp + cc_lex.scantokenseq.newtkx]
    lea       rax,	[rax+23]
    mov       r10b,	4
    or        [rax],	r10b
    jmp       L6053
L6052:
    xor       r13,	r13
    movzx     rax,	byte ptr[rsi+108]
    shr       eax,	2
    and       eax,	1
    test      rax,	rax
    jz        L6055
    mov       rcx,	[rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.peektk
    test      rax,	rax
    jz        L6050
L6057:
    lea       rcx,	[rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.lexa
    sub       rsp,	8
    lea       rax,	[rbp + cc_lex.scantokenseq.dummy]
    push      rax
    mov       rcx,	rsi
    mov       rdx,	r14
    lea       r8,	[rbp + cc_lex.scantokenseq.tk]
    mov       r9,	1
    sub       rsp,	32
    call      cc_lex.expandfnmacro
    add       rsp,	48
    mov       rdi,	rax
    lea       rcx,	[rbp + cc_lex.scantokenseq.newtk]
    lea       rdx,	[rbp + cc_lex.scantokenseq.newtkx]
    mov       r8,	rdi
    call      cc_lex.addlisttoken_seq
    mov       rax,	1
    mov       r10,	[rbp + cc_lex.scantokenseq.expanded]
    mov       [r10],	rax
    jmp       L6040
L6055:
    mov       rcx,	rsi
    mov       rdx,	r14
    lea       r8,	[rbp + cc_lex.scantokenseq.tk]
    xor       r9d,	r9d
    call      cc_lex.expandobjmacro
    mov       rdi,	rax
    mov       rax,	1
    mov       r10,	[rbp + cc_lex.scantokenseq.expanded]
    mov       [r10],	rax
    lea       rcx,	[rbp + cc_lex.scantokenseq.newtk]
    lea       rdx,	[rbp + cc_lex.scantokenseq.newtkx]
    mov       r8,	rdi
    call      cc_lex.addlisttoken_seq
L6054:
    jmp       L6045
L6046:
    movzx     rax,	byte ptr[rsi+107]
    cmp       rax,	92
    jnz       L6058
    mov       r12,	1
    jmp       L6050
L6058:
    movzx     rax,	byte ptr[rsi+107]
    cmp       rax,	69
    jnz       L6059
    call      cc_lex.alloctokenz
    mov       rdi,	rax
    movsx     rax,	word ptr[rsi+100]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	[rip+cc_decls.slineno]
    call      cc_lex.expandpredefmacro
    lea       rcx,	[rbp + cc_lex.scantokenseq.newtk]
    lea       rdx,	[rbp + cc_lex.scantokenseq.newtkx]
    mov       r8,	rdi
    call      cc_lex.addlisttoken_copy
    jmp       L6060
L6059:
    xor       r12,	r12
    jmp       L6050
L6045:
    jmp       L6042
L6044:
#cc_lex.scantokenseq.simpletoken:
L6050:
    lea       rcx,	[rbp + cc_lex.scantokenseq.newtk]
    lea       rdx,	[rbp + cc_lex.scantokenseq.newtkx]
    mov       r8,	[rbp + cc_lex.scantokenseq.tk]
    call      cc_lex.addlisttoken_copy
L6042:
#cc_lex.scantokenseq.skip:
L6053:
    mov       rax,	[rbp + cc_lex.scantokenseq.tk]
    test      rax,	rax
    jz        L6041
L6062:
#cc_lex.scantokenseq.skip2:
L6060:
    mov       rax,	[rbp + cc_lex.scantokenseq.tk]
    mov       rax,	[rax+8]
    mov       [rbp + cc_lex.scantokenseq.tk],	rax
L6040:
    mov       rax,	[rbp + cc_lex.scantokenseq.tk]
    test      rax,	rax
    jnz       L6039
L6041:
    mov       rax,	[rbp + cc_lex.scantokenseq.expanded]
    mov       rax,	[rax]
    test      rax,	rax
    jz        L6064
    mov       rax,	[rbp + cc_lex.scantokenseq.newtk]
    mov       [rbp + cc_lex.scantokenseq.tk],	rax
    jmp       L6025
L6064:
    mov       rax,	[rbp + cc_lex.scantokenseq.newtk]
L6024:
#---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.readmacrocall
cc_lex.readmacrocall:
#PROC1
#PROC2
#?>>
    .set cc_lex.readmacrocall.args, 80
    .set cc_lex.readmacrocall.tksource, 88
    .set cc_lex.readmacrocall.tklist, -8
    .set cc_lex.readmacrocall.tklistx, -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	[rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	13
    jz        L6067
    lea       rcx,	[rip+L11166]
    call      cc_lex.lxerror
L6067:
    movzx     rax,	byte ptr[r15+111]
    mov       rdi,	rax
    xor       r12,	r12
    mov       rax,	rdi
    test      rax,	rax
    jnz       L6069
    mov       rcx,	[rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	14
    jz        L6071
    lea       rcx,	[rip+L11167]
    call      cc_lex.lxerror
L6071:
    xor       eax,	eax
    jmp       L6065
L6069:
    mov       rsi,	1
    mov       rbx,	1
    xor       eax,	eax
    mov       [rbp + cc_lex.readmacrocall.tklistx],	rax
    mov       [rbp + cc_lex.readmacrocall.tklist],	rax
    movzx     rax,	byte ptr[r15+108]
    shr       eax,	1
    and       eax,	1
    mov       r13,	rax
    xor       r14,	r14
L6072:
    cmp       rsi,	rdi
    jnz       L6075
    test      r13,	r13
    jz        L6075
    mov       r14,	1
L6075:
    mov       rcx,	[rbp + cc_lex.readmacrocall.tksource]
    call      cc_lex.lexa
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jz        L6077
    cmp       rax,	57
    jz        L6078
    cmp       rax,	13
    jz        L6079
    cmp       rax,	14
    jz        L6080
    jmp       L6081
L6077:
    cmp       rbx,	1
    jnz       L6083
    test      r14,	r14
    jnz       L6083
    mov       rax,	[rbp + cc_lex.readmacrocall.tklist]
    test      rax,	rax
    jnz       L6085
    call      cc_lex.alloctokenz
    mov       [rbp + cc_lex.readmacrocall.tklist],	rax
    call      cc_lex.getfileno
    mov       rcx,	[rbp + cc_lex.readmacrocall.tklist]
    mov       rdx,	rax
    call      cc_lex.setfilenox
    mov       al,	66
    mov       r10,	[rbp + cc_lex.readmacrocall.tklist]
    mov       [r10+21],	al
L6085:
    mov       rax,	[rbp + cc_lex.readmacrocall.tklist]
    mov       r10,	[rbp + cc_lex.readmacrocall.args]
    mov       r11,	rsi
    mov       [r10 + r11*8-8],	rax
    xor       eax,	eax
    mov       [rbp + cc_lex.readmacrocall.tklistx],	rax
    mov       [rbp + cc_lex.readmacrocall.tklist],	rax
    inc       rsi
    jmp       L6082
L6083:
    jmp       L6086
L6082:
    jmp       L6076
L6078:
    lea       rcx,	[rip+L11168]
    call      cc_lex.lxerror
    jmp       L6076
L6079:
    inc       rbx
    jmp       L6086
L6080:
    cmp       rbx,	1
    jle       L6088
    dec       rbx
    lea       rcx,	[rbp + cc_lex.readmacrocall.tklist]
    lea       rdx,	[rbp + cc_lex.readmacrocall.tklistx]
    call      cc_lex.addlist_nextlx
    jmp       L6087
L6088:
    mov       rax,	[rbp + cc_lex.readmacrocall.tklist]
    test      rax,	rax
    jnz       L6090
    call      cc_lex.alloctokenz
    mov       [rbp + cc_lex.readmacrocall.tklist],	rax
    call      cc_lex.getfileno
    mov       rcx,	[rbp + cc_lex.readmacrocall.tklist]
    mov       rdx,	rax
    call      cc_lex.setfilenox
    mov       al,	66
    mov       r10,	[rbp + cc_lex.readmacrocall.tklist]
    mov       [r10+21],	al
L6090:
    mov       rax,	[rbp + cc_lex.readmacrocall.tklist]
    mov       r10,	[rbp + cc_lex.readmacrocall.args]
    mov       r11,	rsi
    mov       [r10 + r11*8-8],	rax
    jmp       L6073
L6087:
    jmp       L6076
L6081:
#cc_lex.readmacrocall.addtoken:
L6086:
    lea       rcx,	[rbp + cc_lex.readmacrocall.tklist]
    lea       rdx,	[rbp + cc_lex.readmacrocall.tklistx]
    call      cc_lex.addlist_nextlx
L6076:
    jmp       L6072
L6073:
    cmp       rsi,	rdi
    jz        L6092
    lea       rax,	[rsi+1]
    cmp       rax,	rdi
    jnz       L6094
    test      r13,	r13
    jz        L6094
    xor       eax,	eax
    mov       r10,	[rbp + cc_lex.readmacrocall.args]
    mov       r11,	rdi
    mov       [r10 + r11*8-8],	rax
    jmp       L6093
L6094:
    lea       rcx,	[rip+L11169]
    call      cc_lex.lxerror
L6093:
L6092:
    mov       rax,	rdi
L6065:
#---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.substituteargs
cc_lex.substituteargs:
#PROC1
#PROC2
#?>>
    .set cc_lex.substituteargs.expargs, 80
    .set cc_lex.substituteargs.nargs, 88
    .set cc_lex.substituteargs.macrostack, 96
    .set cc_lex.substituteargs.newtk, -8
    .set cc_lex.substituteargs.newtkx, -16
    .set cc_lex.substituteargs.niltk, -24
    .set cc_lex.substituteargs.tkexp, -32
    .set cc_lex.substituteargs.tk, -64
    .set cc_lex.substituteargs.n, -72
    .set cc_lex.substituteargs.i, -80
    .set cc_lex.substituteargs.expanded, -88
    .set cc_lex.substituteargs.hhpoints, -2088
    .set cc_lex.substituteargs.nhashhash, -2096
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	2128
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
    mov       rdi,	[r13+80]
    mov       rax,	[r13+72]
    mov       rsi,	rax
    mov       rbx,	rax
    xor       eax,	eax
    mov       [rbp + cc_lex.substituteargs.newtkx],	rax
    mov       [rbp + cc_lex.substituteargs.newtk],	rax
    xor       eax,	eax
    mov       [rbp + cc_lex.substituteargs.nhashhash],	rax
    xor       r12,	r12
    jmp       L6097
L6096:
    movzx     rax,	byte ptr[rbx+21]
    cmp       rax,	5
    jz        L6100
    cmp       rax,	7
    jz        L6101
    jmp       L6102
L6100:
    mov       rax,	[rbp + cc_lex.substituteargs.nargs]
    test      rax,	rax
    jz        L6104
    mov       rbx,	[rbx+8]
    test      rbx,	rbx
    jnz       L6106
    lea       rcx,	[rip+L11170]
    call      cc_lex.lxerror
L6106:
    movzx     rax,	byte ptr[rbx+23]
    and       rax,	2
    jnz       L6108
    lea       rcx,	[rip+L11171]
    call      cc_lex.lxerror
L6108:
    movsx     rax,	word ptr[rbx+28]
    mov       [rbp + cc_lex.substituteargs.n],	rax
    mov       rax,	[rbp + cc_lex.substituteargs.n]
    mov       rax,	[r14 + rax*8-8]
    mov       rcx,	rax
    lea       rdx,	[rbp + cc_lex.substituteargs.tk]
    call      cc_lex.stringify
    lea       rcx,	[rbp + cc_lex.substituteargs.newtk]
    lea       rdx,	[rbp + cc_lex.substituteargs.newtkx]
    lea       r8,	[rbp + cc_lex.substituteargs.tk]
    call      cc_lex.addlisttoken_copy
    jmp       L6103
L6104:
    lea       rcx,	[rbp + cc_lex.substituteargs.newtk]
    lea       rdx,	[rbp + cc_lex.substituteargs.newtkx]
    mov       r8,	rbx
    call      cc_lex.addlisttoken
    mov       al,	6
    mov       r10,	[rbp + cc_lex.substituteargs.newtkx]
    mov       [r10+21],	al
L6103:
    jmp       L6099
L6101:
    cmp       rbx,	rsi
    jnz       L6110
    lea       rcx,	[rip+L11172]
    call      cc_lex.lxerror
L6110:
    mov       rax,	[rbp + cc_lex.substituteargs.nhashhash]
    cmp       rax,	250
    jl        L6112
    lea       rcx,	[rip+L11173]
    call      cc_lex.lxerror
L6112:
    inc       qword ptr[rbp + cc_lex.substituteargs.nhashhash]
    mov       rax,	[rbp + cc_lex.substituteargs.nhashhash]
    mov       r10,	[rbp + cc_lex.substituteargs.newtkx]
    mov       [rbp + rax*8 + cc_lex.substituteargs.hhpoints-8],	r10
    jmp       L6099
L6102:
    movzx     rax,	byte ptr[rbx+21]
    cmp       rax,	67
    jnz       L6114
    movzx     rax,	byte ptr[rbx+23]
    and       rax,	2
    jz        L6114
    mov       rax,	[rbp + cc_lex.substituteargs.nargs]
    test      rax,	rax
    jz        L6114
    movsx     rax,	word ptr[rbx+28]
    mov       [rbp + cc_lex.substituteargs.n],	rax
    mov       rax,	[rbx+8]
    test      rax,	rax
    jz        L6118
    mov       rax,	[rbx+8]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	7
    jz        L6117
L6118:
    test      r12,	r12
    jz        L6116
    movzx     rax,	byte ptr[r12+21]
    cmp       rax,	7
    jnz       L6116
L6117:
    mov       rax,	[rbp + cc_lex.substituteargs.n]
    mov       rax,	[r14 + rax*8-8]
    lea       rcx,	[rbp + cc_lex.substituteargs.newtk]
    lea       rdx,	[rbp + cc_lex.substituteargs.newtkx]
    mov       r8,	rax
    call      cc_lex.addlisttoken_seq
    jmp       L6115
L6116:
    mov       rax,	[rbp + cc_lex.substituteargs.expargs]
    mov       r10,	[rbp + cc_lex.substituteargs.n]
    mov       rax,	[rax + r10*8-8]
    mov       [rbp + cc_lex.substituteargs.tkexp],	rax
    mov       rax,	[rbp + cc_lex.substituteargs.tkexp]
    test      rax,	rax
    jnz       L6120
    mov       rax,	[rbp + cc_lex.substituteargs.n]
    mov       rax,	[r14 + rax*8-8]
    mov       rcx,	rax
    mov       rdx,	[rbp + cc_lex.substituteargs.macrostack]
    lea       r8,	[rbp + cc_lex.substituteargs.expanded]
    call      cc_lex.scantokenseq
    mov       r10,	[rbp + cc_lex.substituteargs.expargs]
    mov       r11,	[rbp + cc_lex.substituteargs.n]
    mov       [r10 + r11*8-8],	rax
    mov       [rbp + cc_lex.substituteargs.tkexp],	rax
L6120:
    lea       rcx,	[rbp + cc_lex.substituteargs.newtk]
    lea       rdx,	[rbp + cc_lex.substituteargs.newtkx]
    mov       r8,	[rbp + cc_lex.substituteargs.tkexp]
    call      cc_lex.addlisttoken_seq
L6115:
    jmp       L6113
L6114:
#cc_lex.substituteargs.doother:
    lea       rcx,	[rbp + cc_lex.substituteargs.newtk]
    lea       rdx,	[rbp + cc_lex.substituteargs.newtkx]
    mov       r8,	rbx
    call      cc_lex.addlisttoken_copy
L6113:
L6099:
    mov       r12,	rbx
    mov       rbx,	[rbx+8]
L6097:
    test      rbx,	rbx
    jnz       L6096
    mov       rax,	[rbp + cc_lex.substituteargs.nhashhash]
    test      rax,	rax
    jz        L6123
    xor       eax,	eax
    mov       [rbp + cc_lex.substituteargs.niltk],	rax
    mov       rax,	1
    mov       [rbp + cc_lex.substituteargs.i],	rax
    mov       rax,	[rbp + cc_lex.substituteargs.nhashhash]
    cmp       rax,	1
    jl        L6126
L6124:
    mov       rax,	[rbp + cc_lex.substituteargs.i]
    cmp       rax,	[rbp + cc_lex.substituteargs.nhashhash]
    jge       L6128
    mov       rax,	[rbp + cc_lex.substituteargs.i]
    lea       r10,	[rbp + rax*8 + cc_lex.substituteargs.hhpoints]
    mov       rax,	r10
    jmp       L6127
L6128:
    lea       rax,	[rbp + cc_lex.substituteargs.niltk]
L6127:
    mov       r10,	[rbp + cc_lex.substituteargs.i]
    mov       r10,	[rbp + r10*8 + cc_lex.substituteargs.hhpoints-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      cc_lex.pastetokens
    mov       rax,	[rbp + cc_lex.substituteargs.i]
    inc       rax
    mov       [rbp + cc_lex.substituteargs.i],	rax
    cmp       rax,	[rbp + cc_lex.substituteargs.nhashhash]
    jle       L6124
L6126:
L6123:
    mov       rax,	[rbp + cc_lex.substituteargs.newtk]
L6095:
#---------------
    add       rsp,	2128
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.strtoken
cc_lex.strtoken:
#PROC1
#PROC2
#?>>
    .set cc_lex.strtoken.l, -32
    .set cc_lex.strtoken.$T1, -40
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	rsi
    lea       r10,	[rbp + cc_lex.strtoken.l]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
    movzx     rax,	byte ptr[rbp + cc_lex.strtoken.l+21]
    cmp       rax,	67
    jz        L6131
    cmp       rax,	59
    jz        L6132
    cmp       rax,	60
    jz        L6132
    cmp       rax,	58
    jz        L6133
    cmp       rax,	63
    jz        L6134
    cmp       rax,	64
    jz        L6134
    cmp       rax,	61
    jz        L6135
    cmp       rax,	56
    jz        L6136
    cmp       rax,	57
    jz        L6137
    cmp       rax,	70
    jz        L6138
    cmp       rax,	86
    jz        L6138
    cmp       rax,	85
    jz        L6138
    cmp       rax,	88
    jz        L6138
    jmp       L6139
L6131:
#cc_lex.strtoken.doname:
L6140:
    mov       rax,	[rbp + cc_lex.strtoken.l]
    movzx     rax,	byte ptr[rax+106]
    mov       [r12],	rax
    mov       rax,	[rbp + cc_lex.strtoken.l]
    mov       rax,	[rax]
    jmp       L6129
L6132:
    movsxd    rax,	dword ptr[rbp + cc_lex.strtoken.l+24]
    mov       [r12],	rax
    lea       rcx,	[rbp + cc_lex.strtoken.l]
    call      cc_lex.getfilenox
    test      rax,	rax
    jz        L6142
    lea       rcx,	[rbp + cc_lex.strtoken.l]
    call      cc_lex.getfilenox
    lea       r10,	[rip+cc_decls.sourcefiletext]
    mov       r10,	[r10 + rax*8]
    mov       [rbp + cc_lex.strtoken.$T1],	r10
    lea       rcx,	[rbp + cc_lex.strtoken.l]
    call      cc_lex.getnumberoffsetx
    mov       r10,	[rbp + cc_lex.strtoken.$T1]
    lea       r10,	[r10 + rax]
    mov       rax,	r10
    jmp       L6129
L6142:
    movsx     rax,	word ptr[rbp + cc_lex.strtoken.l+28]
    lea       r10,	[rip+cc_lex.pastedtokenlist]
    mov       r10,	[r10 + rax*8-8]
    mov       rax,	r10
    jmp       L6129
L6141:
    jmp       L6130
L6133:
    movsxd    rax,	dword ptr[rbp + cc_lex.strtoken.l+24]
    mov       [r12],	rax
    mov       rax,	[rbp + cc_lex.strtoken.l]
    jmp       L6129
L6134:
    movsxd    rax,	dword ptr[rbp + cc_lex.strtoken.l+24]
    mov       r10,	[rbp + cc_lex.strtoken.l]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	r12
    mov       r9,	34
    call      cc_lex.strstring
    mov       rbx,	rax
    mov       rax,	rbx
    jmp       L6129
L6135:
    movsxd    rax,	dword ptr[rbp + cc_lex.strtoken.l+24]
    mov       r10,	[rbp + cc_lex.strtoken.l]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	r12
    mov       r9,	39
    call      cc_lex.strstring
    mov       rbx,	rax
    mov       rax,	rbx
    jmp       L6129
L6136:
    mov       rax,	[rip+cc_lex.dowhitespace]
    test      rax,	rax
    jz        L6144
    movsxd    rax,	dword ptr[rbp + cc_lex.strtoken.l+24]
    inc       rax
    mov       [r12],	rax
    mov       rax,	[r12]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rbx,	rax
    mov       al,	10
    mov       [rbx],	al
    movsxd    rax,	dword ptr[rbp + cc_lex.strtoken.l+24]
    mov       r10,	[rbp + cc_lex.strtoken.l]
    lea       r11,	[rbx+1]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      memcpy
    jmp       L6143
L6144:
    mov       rax,	1
    mov       [r12],	rax
    lea       rax,	[rip+L11174]
    jmp       L6129
L6143:
    mov       rax,	rbx
    jmp       L6129
L6137:
    xor       eax,	eax
    mov       [r12],	rax
    lea       rax,	[rip+L11175]
    jmp       L6129
L6138:
    jmp       L6140
L6139:
    movzx     rax,	byte ptr[rbp + cc_lex.strtoken.l+21]
    lea       r10,	[rip+cc_tables.shortsymbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rdi,	r10
    mov       rcx,	rdi
    call      strlen
    mov       [r12],	rax
    test      rax,	rax
    jz        L6146
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	107
    jz        L6148
    mov       rax,	rdi
    jmp       L6129
L6148:
    movzx     rax,	byte ptr[rbp + cc_lex.strtoken.l+21]
    lea       r10,	[rip+cc_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    lea       r10,	[r10+1]
    mov       rcx,	r10
    call      strlen
    mov       [r12],	rax
    movzx     rax,	byte ptr[rbp + cc_lex.strtoken.l+21]
    lea       r10,	[rip+cc_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    lea       r10,	[r10+1]
    mov       rax,	r10
    jmp       L6129
L6147:
    jmp       L6145
L6146:
    lea       rax,	[rip+L11175]
    jmp       L6129
L6145:
L6130:
    lea       rax,	[rip+L11175]
L6129:
#---------------
    add       rsp,	80
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.strstring
cc_lex.strstring:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
#---------------
#PROC3
#PROC4
    mov       rax,	r12
    shl       rax,	1
    add       rax,	4
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rbx,	rax
    mov       rdi,	rax
    test      r14,	r14
    jz        L6151
    mov       [rbx],	r14b
    inc       rbx
L6151:
    mov       rcx,	rsi
    mov       rdx,	rbx
    mov       r8,	r12
    call      cc_lib.convertstringc
    mov       rcx,	rdi
    call      strlen
    mov       [r13],	rax
    test      r14,	r14
    jz        L6153
    mov       rax,	[r13]
    mov       r10b,	r14b
    mov       [rdi + rax],	r10b
    mov       rax,	r13
    inc       qword ptr[rax]
L6153:
    mov       rax,	rdi
L6149:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.emittoken
cc_lex.emittoken:
#PROC1
#PROC2
#?>>
    .set cc_lex.emittoken.length, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rbx+21]
    cmp       rax,	56
    jnz       L6156
    mov       rax,	[rip+cc_lex.lasttoken]
    cmp       rax,	56
    jz        L6154
L6156:
    mov       rcx,	rbx
    lea       rdx,	[rbp + cc_lex.emittoken.length]
    call      cc_lex.strtoken
    mov       rdi,	rax
    test      r12,	r12
    jnz       L6159
    movzx     rax,	byte ptr[rbx+21]
    mov       rcx,	[rip+cc_lex.lasttoken]
    mov       rdx,	rax
    call      cc_lex.needspace
    test      rax,	rax
    jz        L6158
L6159:
    mov       rcx,	rsi
    mov       rdx,	32
    call      mlib.gs_char
L6158:
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	[rbp + cc_lex.emittoken.length]
    call      mlib.gs_strn
    movzx     rax,	byte ptr[rbx+21]
    mov       [rip+cc_lex.lasttoken],	rax
L6154:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.showtoken
cc_lex.showtoken:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+cc_lex.showtoken.dest]
    call      mlib.gs_init
    mov       rcx,	rdi
    mov       rdx,	[rip+cc_lex.showtoken.dest]
    xor       r8d,	r8d
    call      cc_lex.emittoken
    call      msys.m$print_startcon
    mov       rax,	[rip+cc_lex.showtoken.dest]
    movsxd    rax,	dword ptr[rax+8]
    mov       rcx,	rax
    lea       rdx,	[rip+L11176]
    call      msys.m$print_i64
    call      msys.m$print_nogap
    mov       rax,	[rip+cc_lex.showtoken.dest]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[rip+L11177]
    call      msys.m$print_str
    call      msys.m$print_end
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lex.stringify
cc_lex.stringify:
#PROC1
#PROC2
#?>>
    .set cc_lex.stringify.length, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    mov       al,	63
    mov       [r12+21],	al
    xor       eax,	eax
    mov       [r12+8],	rax
    mov       rax,	[rsi+8]
    test      rax,	rax
    jnz       L6163
    mov       rcx,	rsi
    lea       rdx,	[rbp + cc_lex.stringify.length]
    call      cc_lex.strtoken
    mov       rdi,	rax
    mov       eax,	[rbp + cc_lex.stringify.length]
    mov       [r12+24],	eax
    mov       [r12],	rdi
    jmp       L6161
L6163:
    mov       rcx,	[rip+cc_lex.stringify.deststr]
    call      mlib.gs_init
    xor       eax,	eax
    mov       [rip+cc_lex.lasttoken],	rax
    xor       rbx,	rbx
    jmp       L6165
L6164:
    mov       rcx,	rsi
    mov       rdx,	[rip+cc_lex.stringify.deststr]
    mov       r8,	rbx
    call      cc_lex.emittoken
    mov       rbx,	1
    mov       rsi,	[rsi+8]
L6165:
    test      rsi,	rsi
    jnz       L6164
    mov       eax,	[rbp + cc_lex.stringify.length]
    mov       [r12+24],	eax
    mov       rax,	[rip+cc_lex.stringify.deststr]
    mov       rax,	[rax]
    mov       [r12],	rax
    mov       rax,	[rip+cc_lex.stringify.deststr]
    mov       eax,	[rax+8]
    mov       [r12+24],	eax
L6161:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.pastetokens
cc_lex.pastetokens:
#PROC1
#PROC2
#?>>
    .set cc_lex.pastetokens.tk, 64
    .set cc_lex.pastetokens.tknext, 72
    .set cc_lex.pastetokens.length1, -8
    .set cc_lex.pastetokens.length2, -16
    .set cc_lex.pastetokens.oldtoken, -48
    .set cc_lex.pastetokens.token, -80
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	112
    mov       [rbp+64],	rcx
    mov       [rbp+72],	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + cc_lex.pastetokens.tk]
    mov       rdi,	[rax+8]
    mov       rax,	[rbp + cc_lex.pastetokens.tknext]
    mov       rax,	[rax]
    mov       r10,	rdi
    cmp       r10,	rax
    jnz       L6169
    mov       rax,	[rbp + cc_lex.pastetokens.tk]
    mov       r10,	[rbp + cc_lex.pastetokens.tknext]
    mov       [r10],	rax
L6169:
    mov       rax,	[rdi+8]
    mov       r10,	[rbp + cc_lex.pastetokens.tk]
    mov       [r10+8],	rax
    mov       rax,	[rbp + cc_lex.pastetokens.tk]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	66
    jnz       L6171
    movzx     rax,	byte ptr[rdi+21]
    cmp       rax,	66
    jz        L6172
L6173:
    mov       rax,	rdi
    mov       r10,	[rbp + cc_lex.pastetokens.tk]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
L6172:
    jmp       L6170
L6171:
    movzx     rax,	byte ptr[rdi+21]
    cmp       rax,	66
    jz        L6170
L6174:
    mov       rcx,	[rbp + cc_lex.pastetokens.tk]
    lea       rdx,	[rbp + cc_lex.pastetokens.length1]
    call      cc_lex.strtoken
    mov       rbx,	rax
    mov       rcx,	rdi
    lea       rdx,	[rbp + cc_lex.pastetokens.length2]
    call      cc_lex.strtoken
    mov       rsi,	rax
    mov       rax,	[rbp + cc_lex.pastetokens.length1]
    add       rax,	[rbp + cc_lex.pastetokens.length2]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       r12,	rax
    mov       rcx,	r12
    mov       rdx,	rbx
    mov       r8,	[rbp + cc_lex.pastetokens.length1]
    call      memcpy
    mov       rax,	[rbp + cc_lex.pastetokens.length1]
    lea       r10,	[r12 + rax]
    mov       rcx,	r10
    mov       rdx,	rsi
    mov       r8,	[rbp + cc_lex.pastetokens.length2]
    call      memcpy
    mov       rax,	[rbp + cc_lex.pastetokens.length1]
    lea       r10,	[r12 + rax]
    xor       eax,	eax
    mov       r11,	[rbp + cc_lex.pastetokens.length2]
    mov       [r10 + r11],	al
    mov       rax,	[rip+cc_lex.npastedtokens]
    cmp       rax,	87000
    jl        L6176
    lea       rcx,	[rip+L11178]
    call      cc_lex.lxerror
L6176:
    inc       qword ptr[rip+cc_lex.npastedtokens]
    mov       rax,	[rip+cc_lex.npastedtokens]
    mov       r10,	r12
    lea       r11,	[rip+cc_lex.pastedtokenlist]
    mov       [r11 + rax*8-8],	r10
    lea       rax,	[rip+cc_decls.nextlx]
    lea       r10,	[rbp + cc_lex.pastetokens.oldtoken]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
    mov       r13,	[rip+cc_lex.lxsptr]
    mov       r14,	[rip+cc_lex.lx_stackindex]
    mov       [rip+cc_lex.lxsptr],	r12
    xor       eax,	eax
    mov       [rip+cc_lex.lx_stackindex],	rax
    xor       ecx,	ecx
    call      cc_lex.setfileno
    xor       eax,	eax
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+16],	eax
    call      cc_lex.lexreadtoken
    lea       rax,	[rip+cc_decls.nextlx]
    lea       r10,	[rbp + cc_lex.pastetokens.token]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
    call      cc_lex.lexreadtoken
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	57
    jz        L6178
L6178:
    lea       rax,	[rbp + cc_lex.pastetokens.oldtoken]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
    mov       [rip+cc_lex.lxsptr],	r13
    mov       [rip+cc_lex.lx_stackindex],	r14
    mov       rax,	[rbp + cc_lex.pastetokens.tk]
    mov       rax,	[rax+8]
    mov       [rbp + cc_lex.pastetokens.token+8],	rax
    lea       rcx,	[rbp + cc_lex.pastetokens.token]
    xor       edx,	edx
    call      cc_lex.setfilenox
    mov       ax,	[rip+cc_lex.npastedtokens]
    mov       [rbp + cc_lex.pastetokens.token+28],	ax
    lea       rax,	[rbp + cc_lex.pastetokens.token+23]
    mov       r10b,	8
    or        [rax],	r10b
    lea       rax,	[rbp + cc_lex.pastetokens.token]
    mov       r10,	[rbp + cc_lex.pastetokens.tk]
    mov       r11,	[rax]
    mov       [r10],	r11
    mov       r11,	[rax+8]
    mov       [r10+8],	r11
    mov       r11,	[rax+16]
    mov       [r10+16],	r11
    mov       r11,	[rax+24]
    mov       [r10+24],	r11
L6170:
#---------------
    add       rsp,	112
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.getifexpr
cc_lex.getifexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.getifexpr.sx, -8
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_lex.lexm
    lea       rcx,	[rbp + cc_lex.getifexpr.sx]
    call      cc_lex.evalcondexpr
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	56
    jz        L6181
    lea       rcx,	[rip+L11179]
    call      cc_lex.lxerror
L6181:
    mov       rax,	rdi
    cmp       rax,	0
    setnz     al
    movzx     eax,	al
L6179:
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc cc_lex.evalcondexpr
cc_lex.evalcondexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evalcondexpr.sy, -8
    .set cc_lex.evalcondexpr.sz, -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    call      cc_lex.evalorexpr
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	19
    jnz       L6184
    call      cc_lex.lexm
    lea       rcx,	[rbp + cc_lex.evalcondexpr.sy]
    call      cc_lex.evalcondexpr
    mov       rbx,	rax
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	10
    jz        L6186
    lea       rcx,	[rip+L11180]
    call      cc_lex.lxerror
L6186:
    call      cc_lex.lexm
    lea       rcx,	[rbp + cc_lex.evalcondexpr.sz]
    call      cc_lex.evalcondexpr
    mov       rsi,	rax
    test      rdi,	rdi
    jz        L6188
    mov       rax,	[rbp + cc_lex.evalcondexpr.sy]
    mov       [r12],	rax
    mov       rdi,	rbx
    jmp       L6187
L6188:
    mov       rax,	[rbp + cc_lex.evalcondexpr.sz]
    mov       [r12],	rax
    mov       rdi,	rsi
L6187:
L6184:
    mov       rax,	rdi
L6182:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.evalorexpr
cc_lex.evalorexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evalorexpr.sy, -8
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rsi
    call      cc_lex.evalandexpr
    mov       rdi,	rax
    jmp       L6191
L6190:
    call      cc_lex.lexm
    lea       rcx,	[rbp + cc_lex.evalorexpr.sy]
    call      cc_lex.evalandexpr
    mov       rbx,	rax
    test      rdi,	rdi
    jnz       L6195
    test      rbx,	rbx
    jz        L6194
L6195:
    mov       rax,	1
    jmp       L6193
L6194:
    xor       eax,	eax
L6193:
    mov       rdi,	rax
L6191:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	31
    jz        L6190
    mov       rax,	rdi
L6189:
#---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.evalandexpr
cc_lex.evalandexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evalandexpr.sy, -8
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rsi
    call      cc_lex.evaliorexpr
    mov       rdi,	rax
    jmp       L6198
L6197:
    call      cc_lex.lexm
    lea       rcx,	[rbp + cc_lex.evalandexpr.sy]
    call      cc_lex.evaliorexpr
    mov       rbx,	rax
    test      rdi,	rdi
    jz        L6201
    test      rbx,	rbx
    jz        L6201
    mov       rax,	1
    jmp       L6200
L6201:
    xor       eax,	eax
L6200:
    mov       rdi,	rax
L6198:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	32
    jz        L6197
    mov       rax,	rdi
L6196:
#---------------
    add       rsp,	40
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.evaliorexpr
cc_lex.evaliorexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evaliorexpr.sy, -8
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      cc_lex.evalixorexpr
    mov       rdi,	rax
    jmp       L6204
L6203:
    call      cc_lex.lexm
    lea       rcx,	[rbp + cc_lex.evaliorexpr.sy]
    call      cc_lex.evalixorexpr
    or        rdi,	rax
L6204:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	28
    jz        L6203
    mov       rax,	rdi
L6202:
#---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.evalixorexpr
cc_lex.evalixorexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evalixorexpr.sy, -8
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      cc_lex.evaliandexpr
    mov       rdi,	rax
    jmp       L6208
L6207:
    call      cc_lex.lexm
    lea       rcx,	[rbp + cc_lex.evalixorexpr.sy]
    call      cc_lex.evaliandexpr
    xor       rdi,	rax
L6208:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	30
    jz        L6207
    mov       rax,	rdi
L6206:
#---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.evaliandexpr
cc_lex.evaliandexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evaliandexpr.sy, -8
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      cc_lex.evaleqexpr
    mov       rdi,	rax
    jmp       L6212
L6211:
    call      cc_lex.lexm
    lea       rcx,	[rbp + cc_lex.evaliandexpr.sy]
    call      cc_lex.evaleqexpr
    and       rdi,	rax
L6212:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	29
    jz        L6211
    mov       rax,	rdi
L6210:
#---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.evaleqexpr
cc_lex.evaleqexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evaleqexpr.sy, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    call      cc_lex.evalcmpexpr
    mov       rdi,	rax
    jmp       L6216
L6215:
    call      cc_lex.lexm
    lea       rcx,	[rbp + cc_lex.evaleqexpr.sy]
    call      cc_lex.evalcmpexpr
    mov       rbx,	rax
    mov       rax,	rsi
    cmp       rax,	40
    jz        L6219
    cmp       rax,	41
    jz        L6220
    jmp       L6221
L6219:
    mov       rax,	rdi
    cmp       rax,	rbx
    setz      al
    movzx     eax,	al
    mov       rdi,	rax
    jmp       L6218
L6220:
    mov       rax,	rdi
    cmp       rax,	rbx
    setnz     al
    movzx     eax,	al
    mov       rdi,	rax
L6221:
L6218:
L6216:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    mov       rsi,	rax
    cmp       rax,	40
    jz        L6215
    cmp       rsi,	41
    jz        L6215
    mov       rax,	rdi
L6214:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.evalcmpexpr
cc_lex.evalcmpexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evalcmpexpr.sy, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    call      cc_lex.evalshiftexpr
    mov       rdi,	rax
    jmp       L6224
L6223:
    call      cc_lex.lexm
    lea       rcx,	[rbp + cc_lex.evalcmpexpr.sy]
    call      cc_lex.evalshiftexpr
    mov       rbx,	rax
    mov       rax,	rsi
    cmp       rax,	42
    jz        L6227
    cmp       rax,	43
    jz        L6228
    cmp       rax,	44
    jz        L6229
    cmp       rax,	45
    jz        L6230
    jmp       L6231
L6227:
    mov       rax,	rdi
    cmp       rax,	rbx
    setl      al
    movzx     eax,	al
    mov       rdi,	rax
    jmp       L6226
L6228:
    mov       rax,	rdi
    cmp       rax,	rbx
    setle     al
    movzx     eax,	al
    mov       rdi,	rax
    jmp       L6226
L6229:
    mov       rax,	rdi
    cmp       rax,	rbx
    setge     al
    movzx     eax,	al
    mov       rdi,	rax
    jmp       L6226
L6230:
    mov       rax,	rdi
    cmp       rax,	rbx
    setg      al
    movzx     eax,	al
    mov       rdi,	rax
L6231:
L6226:
L6224:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    mov       rsi,	rax
    cmp       rax,	42
    jz        L6223
    cmp       rsi,	43
    jz        L6223
    cmp       rsi,	44
    jz        L6223
    cmp       rsi,	45
    jz        L6223
    mov       rax,	rdi
L6222:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.evalshiftexpr
cc_lex.evalshiftexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evalshiftexpr.sy, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    call      cc_lex.evaladdexpr
    mov       rdi,	rax
    jmp       L6234
L6233:
    call      cc_lex.lexm
    lea       rcx,	[rbp + cc_lex.evalshiftexpr.sy]
    call      cc_lex.evaladdexpr
    mov       rbx,	rax
    mov       rax,	rsi
    cmp       rax,	34
    jz        L6237
    cmp       rax,	33
    jz        L6238
    jmp       L6239
L6237:
    mov       rax,	rdi
    mov       cl,	bl
    sar       rax,	cl
    mov       rdi,	rax
    jmp       L6236
L6238:
    mov       rax,	rdi
    mov       cl,	bl
    shl       rax,	cl
    mov       rdi,	rax
L6239:
L6236:
L6234:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    mov       rsi,	rax
    cmp       rax,	33
    jz        L6233
    cmp       rsi,	34
    jz        L6233
    mov       rax,	rdi
L6232:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.evaladdexpr
cc_lex.evaladdexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evaladdexpr.sy, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    call      cc_lex.evalmulexpr
    mov       rdi,	rax
    jmp       L6242
L6241:
    call      cc_lex.lexm
    lea       rcx,	[rbp + cc_lex.evaladdexpr.sy]
    call      cc_lex.evalmulexpr
    mov       rbx,	rax
    mov       rax,	rsi
    cmp       rax,	23
    jz        L6245
    cmp       rax,	24
    jz        L6246
    jmp       L6247
L6245:
    mov       rax,	rbx
    add       rdi,	rax
    jmp       L6244
L6246:
    mov       rax,	rbx
    sub       rdi,	rax
L6247:
L6244:
L6242:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    mov       rsi,	rax
    cmp       rax,	23
    jz        L6241
    cmp       rsi,	24
    jz        L6241
    mov       rax,	rdi
L6240:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.evalmulexpr
cc_lex.evalmulexpr:
#PROC1
#PROC2
#?>>
    .set cc_lex.evalmulexpr.sy, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    call      cc_lex.evalunaryexpr
    mov       rdi,	rax
    jmp       L6250
L6249:
    call      cc_lex.lexm
    lea       rcx,	[rbp + cc_lex.evalmulexpr.sy]
    call      cc_lex.evalunaryexpr
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L6253
    cmp       rsi,	25
    jz        L6253
    lea       rcx,	[rip+L11181]
    call      cc_lex.lxerror
L6253:
    mov       rax,	rsi
    cmp       rax,	25
    jz        L6255
    cmp       rax,	26
    jz        L6256
    cmp       rax,	27
    jz        L6257
    jmp       L6258
L6255:
    mov       rax,	rdi
    imul      rax,	rbx
    mov       rdi,	rax
    jmp       L6254
L6256:
    mov       rax,	rdi
    mov       r10,	rbx
    cqo       
    idiv      r10
    mov       rdi,	rax
    jmp       L6254
L6257:
    mov       rax,	rdi
    mov       r10,	rbx
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       rdi,	rax
L6258:
L6254:
L6250:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    mov       rsi,	rax
    cmp       rax,	25
    jz        L6249
    cmp       rsi,	26
    jz        L6249
    cmp       rsi,	27
    jz        L6249
    mov       rax,	rdi
L6248:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.evalunaryexpr
cc_lex.evalunaryexpr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	23
    jz        L6261
    cmp       rax,	24
    jz        L6261
    cmp       rax,	36
    jz        L6261
    cmp       rax,	35
    jnz       L6262
L6261:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    mov       rbx,	rax
    call      cc_lex.lexm
    mov       rcx,	rsi
    call      cc_lex.evalunaryexpr
    mov       rdi,	rax
    mov       rax,	rbx
    cmp       rax,	23
    jz        L6264
    cmp       rax,	24
    jz        L6265
    cmp       rax,	36
    jz        L6266
    cmp       rax,	35
    jz        L6267
    jmp       L6268
L6264:
    mov       rax,	rdi
    jmp       L6259
L6265:
    mov       rax,	rdi
    neg       rax
    jmp       L6259
L6266:
    mov       rax,	rdi
    test      rax,	rax
    setz      al
    movzx     eax,	al
    jmp       L6259
L6267:
    mov       rax,	rdi
    not       rax
    jmp       L6259
L6268:
L6263:
L6262:
L6260:
    mov       rcx,	rsi
    call      cc_lex.evalterm
L6259:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.evalterm
cc_lex.evalterm:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	1
    mov       [rsi],	rax
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L6271
    cmp       rax,	59
    jz        L6272
    cmp       rax,	61
    jz        L6273
    cmp       rax,	13
    jz        L6274
    jmp       L6275
L6271:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    movzx     rax,	byte ptr[rax+107]
    cmp       rax,	92
    jz        L6277
    cmp       rax,	91
    jz        L6278
    jmp       L6279
L6277:
    mov       rax,	1
    mov       [rip+cc_lex.noexpand],	rax
    xor       rbx,	rbx
    call      cc_lex.lexm
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	13
    jnz       L6281
    mov       rbx,	1
    call      cc_lex.lexm
L6281:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L6283
    lea       rcx,	[rip+L11182]
    call      cc_lex.lxerror
L6283:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	1
    setz      al
    movzx     eax,	al
    mov       rdi,	rax
    call      cc_lex.lexm
    test      rbx,	rbx
    jz        L6285
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	14
    jz        L6287
    lea       rcx,	[rip+L11183]
    call      cc_lex.lxerror
L6287:
    call      cc_lex.lexm
L6285:
    xor       eax,	eax
    mov       [rip+cc_lex.noexpand],	rax
    jmp       L6276
L6278:
    call      cc_lex.lexm
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	13
    jz        L6289
    lea       rcx,	[rip+L11184]
    call      cc_lex.lxerror
L6289:
    call      cc_lex.lexm
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L6291
    lea       rcx,	[rip+L11185]
    call      cc_lex.lxerror
L6291:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    movzx     rax,	byte ptr[rax+107]
    cmp       rax,	70
    jnz       L6294
L6293:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    movsx     rax,	word ptr[rax+100]
    lea       r10,	[rip+cc_tables.typespecsizes]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       rdi,	r10
    jmp       L6292
L6294:
    lea       rcx,	[rip+L11186]
    call      cc_lex.lxerror
L6292:
    call      cc_lex.lexm
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	14
    jz        L6296
    lea       rcx,	[rip+L11187]
    call      cc_lex.lxerror
L6296:
    call      cc_lex.lexm
    jmp       L6276
L6279:
    call      cc_lex.lexm
    xor       eax,	eax
    jmp       L6269
L6276:
    jmp       L6270
L6272:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rdi,	[rax]
    call      cc_lex.lexm
    jmp       L6270
L6273:
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+24]
    test      rax,	rax
    jnz       L6298
    xor       rdi,	rdi
    jmp       L6297
L6298:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    movzx     rax,	byte ptr[rax]
    mov       rdi,	rax
L6297:
    call      cc_lex.lexm
    jmp       L6270
L6274:
    call      cc_lex.lexm
    mov       rcx,	rsi
    call      cc_lex.evalcondexpr
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	14
    jz        L6300
    lea       rcx,	[rip+L11188]
    call      cc_lex.lxerror
L6300:
    call      cc_lex.lexm
    jmp       L6270
L6275:
    lea       rcx,	[rip+cc_decls.nextlx]
    call      cc_lex.printsymbol
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+24]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       r10,	[r10]
    mov       rcx,	r10
    mov       rdx,	rax
    xor       r8d,	r8d
    call      cc_lex.printstrn
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11189]
    call      cc_lex.lxerror
L6270:
    mov       rax,	rdi
L6269:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.getifdef
cc_lex.getifdef:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rax,	1
    mov       [rip+cc_lex.noexpand],	rax
    call      cc_lex.lexreadtoken
    xor       eax,	eax
    mov       [rip+cc_lex.noexpand],	rax
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L6303
    lea       rcx,	[rip+L11190]
    call      cc_lex.lxerror
L6303:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rbx,	[rax]
    xor       rdi,	rdi
    movzx     rax,	byte ptr[rbx+109]
    cmp       rax,	1
    jnz       L6305
    mov       rdi,	1
    jmp       L6304
L6305:
    movzx     rax,	byte ptr[rbx+107]
    cmp       rax,	69
    jnz       L6306
    mov       rdi,	1
L6306:
L6304:
    call      cc_lex.lexreadtoken
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	56
    jz        L6308
    lea       rcx,	[rip+L11191]
    call      cc_lex.lxerror
L6308:
    mov       rax,	rdi
L6301:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.skipcode
cc_lex.skipcode:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    xor       rdi,	rdi
L6310:
    call      cc_lex.fastreadtoken
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	4
    jz        L6313
    cmp       rax,	57
    jz        L6314
    jmp       L6315
L6313:
    call      cc_lex.getlexdirective
    mov       rbx,	rax
    mov       rax,	rbx
    cmp       rax,	3
    jz        L6317
    cmp       rax,	8
    jz        L6317
    cmp       rax,	9
    jz        L6317
    cmp       rax,	4
    jz        L6318
    cmp       rax,	5
    jz        L6318
    cmp       rax,	6
    jz        L6319
    jmp       L6320
L6317:
    inc       rdi
    jmp       L6316
L6318:
    test      rdi,	rdi
    jnz       L6322
    mov       rax,	rbx
    jmp       L6309
L6322:
    jmp       L6316
L6319:
    test      rdi,	rdi
    jnz       L6324
    mov       rax,	rbx
    jmp       L6309
L6324:
    dec       rdi
L6320:
L6316:
    jmp       L6312
L6314:
    lea       rcx,	[rip+L11192]
    call      cc_lex.lxerror
L6315:
L6312:
    jmp       L6310
    xor       eax,	eax
L6309:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.freetokens
cc_lex.freetokens:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    jmp       L6327
L6326:
    mov       rdi,	[rcx+8]
    mov       rax,	rdi
    mov       rcx,	rax
L6327:
    test      rcx,	rcx
    jnz       L6326
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc cc_lex.fastreadtoken
cc_lex.fastreadtoken:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
L6330:
    mov       rax,	[rip+cc_lex.lxsptr]
    inc       qword ptr[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    mov       rdi,	rax
    cmp       rax,	48
    jae       L6333
    lea       r10,	[rip+L6332]
    jmp       [r10 + rax*8]
    .data
L6332:
    .quad     L6355
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6354
    .quad     L6333
    .quad     L6358
    .quad     L6353
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6352
    .quad     L6334
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6351
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6333
    .quad     L6346
    .text
L6334:
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	2
    mov       rsi,	rax
    xor       rbx,	rbx
    jmp       L6336
L6335:
    movzx     rax,	byte ptr[rsi]
    cmp       rax,	10
    jz        L6339
    cmp       rax,	9
    jz        L6340
    cmp       rax,	32
    jz        L6340
    jmp       L6341
L6339:
    mov       rbx,	1
    jmp       L6337
L6340:
    jmp       L6338
L6341:
    jmp       L6337
L6338:
    dec       rsi
L6336:
    cmp       rsi,	[rip+cc_lex.lxstart]
    jae       L6335
L6337:
    test      rbx,	rbx
    jnz       L6344
    cmp       rsi,	[rip+cc_lex.lxstart]
    jae       L6343
L6344:
    mov       al,	4
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L6329
L6343:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	35
    jnz       L6345
    inc       qword ptr[rip+cc_lex.lxsptr]
L6345:
L6342:
    jmp       L6330
L6346:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	47
    jz        L6348
    cmp       rax,	42
    jz        L6349
    jmp       L6350
L6348:
    call      cc_lex.readlinecomment
    jmp       L6347
L6349:
    call      cc_lex.readblockcomment
L6350:
L6347:
    jmp       L6330
L6351:
    mov       rcx,	39
    xor       edx,	edx
    call      cc_lex.lxreadstring
    jmp       L6330
L6352:
    mov       rcx,	34
    xor       edx,	edx
    call      cc_lex.lxreadstring
    jmp       L6330
L6353:
    lea       rax,	[rip+cc_decls.nextlx]
    lea       rax,	[rax+16]
    inc       dword ptr[rax]
    mov       al,	56
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    xor       eax,	eax
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
    inc       qword ptr[rip+cc_lex.lxsptr]
    jmp       L6330
L6354:
    lea       rax,	[rip+cc_decls.nextlx]
    lea       rax,	[rax+16]
    inc       dword ptr[rax]
    mov       al,	56
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    xor       eax,	eax
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
    jmp       L6330
L6355:
    dec       qword ptr[rip+cc_lex.lxsptr]
    mov       rax,	[rip+cc_lex.lx_stackindex]
    test      rax,	rax
    jz        L6357
    call      cc_lex.unstacksourcefile
    jmp       L6356
L6357:
    mov       al,	57
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    jmp       L6329
L6356:
    jmp       L6330
L6358:
    jmp       L6330
L6333:
    jmp       L6330
L6329:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.alloctoken
cc_lex.alloctoken:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rcx,	32
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rax,	rdi
L6359:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lex.alloctokenz
cc_lex.alloctokenz:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rcx,	32
    call      mlib.pcm_alloc
    mov       rdi,	rax
    xor       eax,	eax
    mov       [rdi+8],	rax
    mov       rax,	rdi
L6360:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lex.expandpredefmacro
cc_lex.expandpredefmacro:
#PROC1
#PROC2
#?>>
    .set cc_lex.expandpredefmacro.str, -256
    .set cc_lex.expandpredefmacro.tm, -272
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	312
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_lex.noexpand]
    test      rax,	rax
    jnz       L6361
L6363:
    mov       rax,	rsi
    cmp       rax,	1
    jz        L6365
    cmp       rax,	2
    jz        L6366
    cmp       rax,	3
    jz        L6367
    cmp       rax,	5
    jz        L6368
    cmp       rax,	4
    jz        L6369
    cmp       rax,	9
    jz        L6370
    cmp       rax,	7
    jz        L6371
    cmp       rax,	8
    jz        L6372
    jmp       L6373
L6365:
    lea       rcx,	[rbp + cc_lex.expandpredefmacro.tm]
    call      mwindows.os_getsystime
    lea       rcx,	[rbp + cc_lex.expandpredefmacro.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L11193]
    call      msys.m$print_setfmt
    movzx     rax,	word ptr[rbp + cc_lex.expandpredefmacro.tm+6]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    movzx     rax,	word ptr[rbp + cc_lex.expandpredefmacro.tm+2]
    lea       r10,	[rip+cc_lex.expandpredefmacro.monthnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	word ptr[rbp + cc_lex.expandpredefmacro.tm]
    mov       rcx,	rax
    lea       rdx,	[rip+L11194]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       al,	63
    mov       [r12+21],	al
    lea       rcx,	[rbp + cc_lex.expandpredefmacro.str]
    call      mlib.pcm_copyheapstring
    mov       [r12],	rax
    jmp       L6364
L6366:
    lea       rcx,	[rbp + cc_lex.expandpredefmacro.tm]
    call      mwindows.os_getsystime
    lea       rcx,	[rbp + cc_lex.expandpredefmacro.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L11195]
    call      msys.m$print_setfmt
    movzx     rax,	word ptr[rbp + cc_lex.expandpredefmacro.tm+8]
    mov       rcx,	rax
    lea       rdx,	[rip+L11196]
    call      msys.m$print_i64
    movzx     rax,	word ptr[rbp + cc_lex.expandpredefmacro.tm+10]
    mov       rcx,	rax
    lea       rdx,	[rip+L11197]
    call      msys.m$print_i64
    movzx     rax,	word ptr[rbp + cc_lex.expandpredefmacro.tm+12]
    mov       rcx,	rax
    lea       rdx,	[rip+L11197]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       al,	63
    mov       [r12+21],	al
    lea       rcx,	[rbp + cc_lex.expandpredefmacro.str]
    call      mlib.pcm_copyheapstring
    mov       [r12],	rax
    jmp       L6364
L6367:
    mov       al,	63
    mov       [r12+21],	al
    mov       rcx,	r12
    call      cc_lex.getfilenox
    mov       rbx,	rax
    test      rbx,	rbx
    jnz       L6375
    mov       rbx,	[rip+cc_decls.sfileno]
L6375:
    mov       rax,	[rip+cc_decls.sfileno]
    test      rax,	rax
    jz        L6377
    lea       rax,	[rip+cc_decls.sourcefilenames]
    mov       r10,	[rip+cc_decls.sfileno]
    mov       rax,	[rax + r10*8]
    mov       [r12],	rax
    jmp       L6376
L6377:
    lea       rax,	[rip+L11198]
    mov       [r12],	rax
L6376:
    jmp       L6364
L6368:
    mov       al,	63
    mov       [r12+21],	al
    mov       rax,	[rip+cc_decls.currproc]
    test      rax,	rax
    jz        L6379
    mov       rax,	[rip+cc_decls.currproc]
    mov       rax,	[rax]
    mov       [r12],	rax
    jmp       L6378
L6379:
    lea       rax,	[rip+L11199]
    mov       [r12],	rax
L6378:
    jmp       L6364
L6369:
    mov       al,	59
    mov       [r12+21],	al
    mov       [r12],	r13
    jmp       L6364
L6370:
    mov       al,	59
    mov       [r12+21],	al
    mov       rax,	1
    mov       [r12],	rax
    jmp       L6364
L6371:
    mov       al,	59
    mov       [r12+21],	al
    mov       rax,	1
    mov       [r12],	rax
    jmp       L6364
L6372:
    mov       al,	59
    mov       [r12+21],	al
    movzx     rax,	byte ptr[rip+cc_decls.pci_target]
    mov       [r12],	rax
    jmp       L6364
L6373:
    call      msys.m$print_startcon
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11200]
    call      cc_lex.lxerror
L6364:
    movzx     rax,	byte ptr[r12+21]
    cmp       rax,	63
    jnz       L6381
    mov       rax,	[r12]
    mov       rcx,	rax
    call      strlen
    mov       [r12+24],	eax
    mov       al,	[rip+cc_decls.trefchar]
    mov       [r12+22],	al
    jmp       L6380
L6381:
    mov       al,	3
    mov       [r12+22],	al
    mov       rcx,	16
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rax,	[r12]
    mov       rcx,	rax
    mov       rdx,	rdi
    call      msys.getstrint
    mov       rcx,	rdi
    call      strlen
    mov       [r12+24],	eax
    mov       rax,	[rip+cc_lex.npastedtokens]
    cmp       rax,	87000
    jl        L6383
    lea       rcx,	[rip+L11201]
    call      cc_lex.lxerror
L6383:
    inc       qword ptr[rip+cc_lex.npastedtokens]
    mov       rax,	[rip+cc_lex.npastedtokens]
    mov       r10,	rdi
    lea       r11,	[rip+cc_lex.pastedtokenlist]
    mov       [r11 + rax*8-8],	r10
    mov       rcx,	r12
    xor       edx,	edx
    call      cc_lex.setfilenox
    mov       ax,	[rip+cc_lex.npastedtokens]
    mov       [r12+28],	ax
L6380:
L6361:
#---------------
    add       rsp,	312
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.dopragmadir
cc_lex.dopragmadir:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_lex.lexm
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jnz       L6386
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[rip+L11202]
    mov       r8,	4
    call      memcmp
    movsxd    r10,	eax
    test      r10,	r10
    jnz       L6388
    call      cc_lex.lexm
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	13
    jz        L6390
    lea       rcx,	[rip+L11203]
    call      cc_lex.lxerror
L6390:
    call      cc_lex.lexm
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	59
    jnz       L6392
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    cmp       rax,	1
    jnz       L6395
L6394:
    xor       eax,	eax
    mov       [rip+cc_decls.structpadding],	rax
    jmp       L6393
L6395:
    jmp       L6396
    lea       rcx,	[rip+L11204]
    call      cc_lex.lxerror
L6393:
    call      cc_lex.lexm
    jmp       L6391
L6392:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	14
    jnz       L6397
    mov       rax,	1
    mov       [rip+cc_decls.structpadding],	rax
L6397:
L6391:
    jmp       L6387
L6388:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[rip+L11205]
    mov       r8,	6
    call      memcmp
    movsxd    r10,	eax
    test      r10,	r10
    jnz       L6398
    mov       rcx,	77
    call      cc_lex.addbuildinfo
    jmp       L6387
L6398:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[rip+L11206]
    mov       r8,	6
    call      memcmp
    movsxd    r10,	eax
    test      r10,	r10
    jnz       L6399
    mov       rcx,	72
    call      cc_lex.addbuildinfo
    jmp       L6387
L6399:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[rip+L11207]
    mov       r8,	4
    call      memcmp
    movsxd    r10,	eax
    test      r10,	r10
    jnz       L6400
    mov       rcx,	76
    call      cc_lex.addbuildinfo
L6400:
L6387:
L6386:
#cc_lex.dopragmadir.finish:
L6396:
    jmp       L6402
L6401:
    call      cc_lex.lexm
L6402:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	56
    jz        L6404
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	57
    jnz       L6401
L6404:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_lex.addbuildinfo
cc_lex.addbuildinfo:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      cc_lex.lexm
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	63
    jz        L6407
    lea       rcx,	[rip+L11208]
    call      cc_lex.lxerror
L6407:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      mlib.pcm_copyheapstring
    mov       rdi,	rax
    mov       rax,	rbx
    cmp       rax,	77
    jz        L6409
    cmp       rax,	72
    jz        L6410
    cmp       rax,	76
    jz        L6411
    jmp       L6412
L6409:
    mov       rax,	[rip+cc_decls.npmodules]
    cmp       rax,	199
    jl        L6414
    lea       rcx,	[rip+L11209]
    call      cc_lex.lxerror
L6414:
    inc       qword ptr[rip+cc_decls.npmodules]
    mov       rax,	[rip+cc_decls.npmodules]
    mov       r10,	rdi
    lea       r11,	[rip+cc_decls.pmodulelist]
    mov       [r11 + rax*8-8],	r10
    jmp       L6408
L6410:
    mov       rax,	[rip+cc_decls.npheaders]
    cmp       rax,	100
    jl        L6416
    lea       rcx,	[rip+L11210]
    call      cc_lex.lxerror
L6416:
    inc       qword ptr[rip+cc_decls.npheaders]
    mov       rax,	[rip+cc_decls.npheaders]
    mov       r10,	rdi
    lea       r11,	[rip+cc_decls.pheaderlist]
    mov       [r11 + rax*8-8],	r10
    jmp       L6408
L6411:
    mov       rax,	[rip+cc_decls.nplibs]
    cmp       rax,	100
    jl        L6418
    lea       rcx,	[rip+L11211]
    call      cc_lex.lxerror
L6418:
    inc       qword ptr[rip+cc_decls.nplibs]
    mov       rax,	[rip+cc_decls.nplibs]
    mov       r10,	rdi
    lea       r11,	[rip+cc_decls.pliblist]
    mov       [r11 + rax*8-8],	r10
L6412:
L6408:
    call      cc_lex.lexm
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.needspace
cc_lex.needspace:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
#---------------
#PROC3
#PROC4
    test      rcx,	rcx
    jnz       L6421
    xor       eax,	eax
    jmp       L6419
L6421:
    lea       rax,	[rip+cc_tables.shortsymbolnames]
    mov       r10,	rcx
    mov       rdi,	[rax + r10*8-8]
    lea       rax,	[rip+cc_tables.shortsymbolnames]
    mov       r10,	rdx
    mov       rbx,	[rax + r10*8-8]
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	110
    jz        L6423
    cmp       rax,	107
    jz        L6423
    cmp       rax,	45
    jz        L6424
    cmp       rax,	43
    jz        L6424
    jmp       L6425
L6423:
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	110
    jz        L6427
    cmp       rax,	107
    jnz       L6428
L6427:
    mov       rax,	1
    jmp       L6419
L6428:
L6426:
    jmp       L6422
L6424:
    movzx     rax,	byte ptr[rdi]
    cmp       rax,	45
    jz        L6430
    cmp       rax,	43
    jnz       L6431
L6430:
    mov       rax,	1
    jmp       L6419
L6431:
L6429:
L6425:
L6422:
    xor       eax,	eax
L6419:
#---------------
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.dospecialinclude
cc_lex.dospecialinclude:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+L11212]
    mov       rdx,	1
    call      cc_lex.stacksourcefile
    mov       rax,	[rip+cc_decls.dheaderfile]
    test      rax,	rax
    jz        L6434
    mov       rcx,	[rip+cc_decls.dheaderfile]
    mov       rdx,	1
    call      cc_lex.stacksourcefile
L6434:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_lex.setnumberoffset
cc_lex.setnumberoffset:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+28]
    mov       r10,	4278190080
    and       rax,	r10
    mov       r10,	rcx
    and       r10,	16777215
    or        rax,	r10
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+28],	eax
#---------------
    ret       
# End 
# Proc cc_lex.setfileno
cc_lex.setfileno:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	rcx
    and       rax,	255
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+20],	al
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+28]
    and       rax,	16777215
    mov       r10,	rcx
    and       r10,	65280
    shl       r10,	16
    or        rax,	r10
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+28],	eax
#---------------
    ret       
# End 
# Proc cc_lex.setfilenox
cc_lex.setfilenox:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	rdx
    and       rax,	255
    mov       [rcx+20],	al
    movsxd    rax,	dword ptr[rcx+28]
    and       rax,	16777215
    mov       r10,	rdx
    and       r10,	65280
    shl       r10,	16
    or        rax,	r10
    mov       [rcx+28],	eax
#---------------
    ret       
# End 
# Proc cc_lex.getfileno
cc_lex.getfileno:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+28]
    sar       rax,	24
    shl       rax,	8
    lea       r10,	[rip+cc_decls.nextlx]
    movzx     r10,	byte ptr[r10+20]
    or        rax,	r10
L6438:
#---------------
    ret       
# End 
# Proc cc_lex.getfilenox
cc_lex.getfilenox:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rcx+28]
    sar       rax,	24
    shl       rax,	8
    movzx     r10,	byte ptr[rcx+20]
    or        rax,	r10
L6439:
#---------------
    ret       
# End 
# Proc cc_lex.getnumberoffsetx
cc_lex.getnumberoffsetx:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rcx+28]
    and       rax,	16777215
L6440:
#---------------
    ret       
# End 
# Proc cc_lex.freehashtable
cc_lex.freehashtable:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    xor       r12,	r12
    mov       rax,	[rip+cc_decls.hstmask]
    cmp       rax,	0
    jl        L6444
L6442:
    mov       rax,	[rip+cc_decls.hashtable]
    mov       r10,	r12
    mov       rdi,	[rax + r10*8]
    mov       rax,	[rdi]
    test      rax,	rax
    jz        L6446
    movzx     rax,	byte ptr[rdi+107]
    cmp       rax,	67
    jnz       L6446
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	1
    jnz       L6448
    mov       rcx,	[rdi+72]
    call      cc_lex.freetokens
L6448:
    mov       rsi,	[rdi+40]
    jmp       L6450
L6449:
    mov       rbx,	[rsi+40]
    mov       rcx,	rsi
    mov       rdx,	128
    call      mlib.pcm_free
    mov       rsi,	rbx
L6450:
    test      rsi,	rsi
    jnz       L6449
    mov       rax,	[rip+cc_decls.hashtable]
    mov       r10,	r12
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    mov       rdx,	128
    call      mlib.pcm_clearmem
    jmp       L6445
L6446:
    mov       rax,	[rdi]
    test      rax,	rax
    jz        L6452
    xor       eax,	eax
    mov       [rdi+40],	rax
L6452:
L6445:
    inc       r12
    cmp       r12,	[rip+cc_decls.hstmask]
    jle       L6442
L6444:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.regenlookup
cc_lex.regenlookup:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[r13+106]
    mov       r10,	[r13]
    mov       rcx,	r10
    mov       rdx,	rax
    call      cc_lex.gethashvalue
    and       rax,	[rip+cc_decls.hstmask]
    mov       rdi,	rax
    xor       rbx,	rbx
L6454:
    mov       rax,	[rip+cc_decls.hashtable]
    mov       r10,	rdi
    mov       r12,	[rax + r10*8]
    movzx     rax,	byte ptr[r12+106]
    mov       rsi,	rax
    test      rsi,	rsi
    jnz       L6457
    mov       rax,	[rip+cc_decls.hashtable]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    mov       rdx,	128
    call      mlib.pcm_free
    mov       rax,	r13
    mov       r10,	[rip+cc_decls.hashtable]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    inc       qword ptr[rip+cc_lex.nhstsymbols]
    jmp       L6453
L6457:
    movzx     rax,	byte ptr[r13+106]
    mov       r10,	rsi
    cmp       r10,	rax
    jnz       L6459
    mov       rax,	[r13]
    mov       r10,	[r12]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	rsi
    call      memcmp
    movsxd    r10,	eax
    test      r10,	r10
    jnz       L6461
    lea       rcx,	[rip+L11213]
    call      cc_lex.lxerror
L6461:
L6459:
    inc       rdi
    cmp       rdi,	[rip+cc_decls.hstsize]
    jl        L6463
    test      rbx,	rbx
    jz        L6465
    lea       rcx,	[rip+L11214]
    call      mlib.abortprogram
L6465:
    mov       rbx,	1
    xor       rdi,	rdi
L6463:
    jmp       L6454
L6453:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.newhashtable
cc_lex.newhashtable:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	[rip+cc_decls.hashtable]
    mov       rbx,	[rip+cc_decls.hstsize]
    mov       rax,	[rip+cc_decls.hstsize]
    shl       rax,	1
    mov       [rip+cc_decls.hstsize],	rax
    mov       rax,	[rip+cc_decls.hstsize]
    dec       rax
    mov       [rip+cc_decls.hstmask],	rax
    xor       eax,	eax
    mov       [rip+cc_lex.nhstsymbols],	rax
    mov       rax,	6
    mov       r10,	[rip+cc_decls.hstsize]
    imul      rax,	r10
    mov       r10,	10
    cqo       
    idiv      r10
    mov       [rip+cc_lex.hstthreshold],	rax
    mov       rax,	[rip+cc_decls.hstsize]
    shl       rax,	3
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rip+cc_decls.hashtable],	rax
    xor       r13,	r13
    mov       rax,	[rip+cc_decls.hstmask]
    cmp       rax,	0
    jl        L6469
L6467:
    mov       rcx,	128
    call      mlib.pcm_allocz
    mov       r10,	[rip+cc_decls.hashtable]
    mov       r11,	r13
    mov       [r10 + r11*8],	rax
    inc       r13
    cmp       r13,	[rip+cc_decls.hstmask]
    jle       L6467
L6469:
    xor       r13,	r13
    mov       rax,	rbx
    dec       rax
    mov       r12,	rax
    cmp       r12,	0
    jl        L6472
L6470:
    mov       rsi,	[rdi + r13*8]
    mov       rax,	[rsi]
    test      rax,	rax
    jz        L6474
    mov       rcx,	rsi
    call      cc_lex.regenlookup
L6474:
    inc       r13
    cmp       r13,	r12
    jle       L6470
L6472:
    mov       rax,	rbx
    shl       rax,	3
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.pcm_free
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.old_readrealnumber
cc_lex.old_readrealnumber:
#PROC1
#PROC2
#?>>
    .set cc_lex.old_readrealnumber.intlen, 104
    .set cc_lex.old_readrealnumber.base, 112
    .set cc_lex.old_readrealnumber.c, -8
    .set cc_lex.old_readrealnumber.badexpon, -16
    .set cc_lex.old_readrealnumber.realstr, -520
    .set cc_lex.old_readrealnumber.av_1, -528
    .set cc_lex.old_readrealnumber.av_2, -536
    .set cc_lex.old_readrealnumber.av_3, -544
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    movq      rax,	XMM13
    push      rax
    movq      rax,	XMM14
    push      rax
    movq      rax,	XMM15
    push      rax
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	584
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+104],	r8
    mov       [rbp+112],	r9
#---------------
#PROC3
#PROC4
    xor       rdi,	rdi
    xor       eax,	eax
    mov       rbx,	rax
    xor       rsi,	rsi
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	46
    jnz       L6477
    inc       qword ptr[rip+cc_lex.lxsptr]
    mov       rdi,	[rip+cc_lex.lxsptr]
    mov       rcx,	[rbp + cc_lex.old_readrealnumber.base]
    call      cc_lex.scannumber
    sub       rax,	rdi
    mov       rbx,	rax
L6477:
    xor       eax,	eax
    mov       [rbp + cc_lex.old_readrealnumber.badexpon],	rax
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	101
    jz        L6479
    cmp       rax,	69
    jz        L6479
    cmp       rax,	112
    jz        L6480
    cmp       rax,	80
    jz        L6480
    jmp       L6481
L6479:
    mov       rax,	[rbp + cc_lex.old_readrealnumber.base]
    cmp       rax,	16
    jz        L6483
    inc       qword ptr[rip+cc_lex.lxsptr]
    lea       rcx,	[rbp + cc_lex.old_readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       rsi,	rax
L6483:
    jmp       L6478
L6480:
    mov       rax,	[rbp + cc_lex.old_readrealnumber.base]
    cmp       rax,	16
    jnz       L6485
    inc       qword ptr[rip+cc_lex.lxsptr]
    lea       rcx,	[rbp + cc_lex.old_readrealnumber.badexpon]
    call      cc_lex.readexponent
    mov       rsi,	rax
L6485:
L6481:
L6478:
    mov       rax,	[rbp + cc_lex.old_readrealnumber.badexpon]
    test      rax,	rax
    jz        L6487
    dec       qword ptr[rip+cc_lex.lxsptr]
    mov       rcx,	r13
    call      cc_lex.readalphanumeric
    jmp       L6475
L6487:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	102
    jz        L6489
    cmp       rax,	70
    jz        L6489
    cmp       rax,	108
    jz        L6489
    cmp       rax,	76
    jnz       L6490
L6489:
    inc       qword ptr[rip+cc_lex.lxsptr]
    jmp       L6488
L6490:
    mov       rax,	[rip+cc_lex.lxsptr]
    movzx     rax,	byte ptr[rax]
    lea       r10,	[rip+cc_lex.alphamap]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L6492
    mov       rcx,	r13
    call      cc_lex.readalphanumeric
    jmp       L6475
L6492:
L6488:
    mov       rax,	[rbp + cc_lex.old_readrealnumber.intlen]
    add       rax,	rbx
    cmp       rax,	500
    jle       L6494
    lea       rcx,	[rip+L11215]
    call      cc_lex.lxerror
L6494:
    mov       rax,	[rbp + cc_lex.old_readrealnumber.intlen]
    test      rax,	rax
    jz        L6496
    lea       rcx,	[rbp + cc_lex.old_readrealnumber.realstr]
    mov       rdx,	r14
    mov       r8,	[rbp + cc_lex.old_readrealnumber.intlen]
    call      memcpy
L6496:
    test      rbx,	rbx
    jz        L6498
    lea       rax,	[rbp + cc_lex.old_readrealnumber.realstr]
    mov       r10,	[rbp + cc_lex.old_readrealnumber.intlen]
    lea       rax,	[rax + r10]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
L6498:
    mov       rax,	[rbp + cc_lex.old_readrealnumber.base]
    cvtsi2sd  XMM4,	rax
    movq      XMM15,	XMM4
    movq      XMM13,	XMM4
    mov       rax,	[rbp + cc_lex.old_readrealnumber.base]
    cmp       rax,	10
    jnz       L6500
    mov       rax,	rbx
    sub       rsi,	rax
    jmp       L6499
L6500:
    mov       rax,	rbx
    shl       rax,	2
    sub       rsi,	rax
    movq      XMM4,	[rip+L11216]
    movq      XMM13,	XMM4
L6499:
    movq      XMM4,	[rip+L11217]
    movq      XMM14,	XMM4
    mov       r12,	1
    mov       rax,	[rbp + cc_lex.old_readrealnumber.intlen]
    add       rax,	rbx
    mov       [rbp + cc_lex.old_readrealnumber.av_1],	rax
    mov       rax,	[rbp + cc_lex.old_readrealnumber.av_1]
    cmp       rax,	1
    jl        L6503
L6501:
    movzx     rax,	byte ptr[rbp + r12 + cc_lex.old_readrealnumber.realstr-1]
    mov       [rbp + cc_lex.old_readrealnumber.c],	rax
    mov       rax,	[rbp + cc_lex.old_readrealnumber.c]
    cmp       rax,	48
    jl        L6505
    mov       rax,	[rbp + cc_lex.old_readrealnumber.c]
    cmp       rax,	57
    jg        L6505
    movq      XMM4,	XMM14
    mulsd     XMM4,	XMM15
    mov       rax,	[rbp + cc_lex.old_readrealnumber.c]
    sub       rax,	48
    cvtsi2sd  XMM5,	rax
    addsd     XMM4,	XMM5
    movq      XMM14,	XMM4
    jmp       L6504
L6505:
    mov       rax,	[rbp + cc_lex.old_readrealnumber.c]
    cmp       rax,	97
    jle       L6506
    movq      XMM4,	XMM14
    mulsd     XMM4,	XMM15
    mov       rax,	[rbp + cc_lex.old_readrealnumber.c]
    cvtsi2sd  XMM5,	rax
    addsd     XMM4,	XMM5
    mov       rax,	97
    cmp       rax,	0
    jl        L11218
    cvtsi2sd  XMM5,	rax
    jmp       L11219
L11218:
    and       rax,	[rip+L10554]
    cvtsi2sd  XMM5,	rax
    addsd     XMM5,	[rip+L10555]
L11219:
    subsd     XMM4,	XMM5
    addsd     XMM4,	[rip+L11220]
    movq      XMM14,	XMM4
    jmp       L6504
L6506:
    movq      XMM4,	XMM14
    mulsd     XMM4,	XMM15
    mov       rax,	[rbp + cc_lex.old_readrealnumber.c]
    cvtsi2sd  XMM5,	rax
    addsd     XMM4,	XMM5
    mov       rax,	65
    cmp       rax,	0
    jl        L11221
    cvtsi2sd  XMM5,	rax
    jmp       L11222
L11221:
    and       rax,	[rip+L10554]
    cvtsi2sd  XMM5,	rax
    addsd     XMM5,	[rip+L10555]
L11222:
    subsd     XMM4,	XMM5
    addsd     XMM4,	[rip+L11223]
    movq      XMM14,	XMM4
L6504:
    inc       r12
    cmp       r12,	[rbp + cc_lex.old_readrealnumber.av_1]
    jle       L6501
L6503:
    cmp       rsi,	0
    jl        L6508
    mov       [rbp + cc_lex.old_readrealnumber.av_2],	rsi
    mov       rax,	[rbp + cc_lex.old_readrealnumber.av_2]
    cmp       rax,	0
    jle       L6511
L6509:
    movq      XMM4,	XMM14
    mulsd     XMM4,	XMM13
    movq      XMM14,	XMM4
    dec       qword ptr[rbp + cc_lex.old_readrealnumber.av_2]
    jnz       L6509
L6511:
    jmp       L6507
L6508:
    mov       rax,	rsi
    neg       rax
    mov       [rbp + cc_lex.old_readrealnumber.av_3],	rax
    mov       rax,	[rbp + cc_lex.old_readrealnumber.av_3]
    cmp       rax,	0
    jle       L6514
L6512:
    movq      XMM4,	XMM14
    divsd     XMM4,	XMM13
    movq      XMM14,	XMM4
    dec       qword ptr[rbp + cc_lex.old_readrealnumber.av_3]
    jnz       L6512
L6514:
L6507:
    mov       al,	60
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+21],	al
    mov       al,	11
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+22],	al
    movq      XMM4,	XMM14
    lea       rax,	[rip+cc_decls.nextlx]
    movq      [rax],	XMM4
    mov       rax,	r14
    sub       rax,	[rip+cc_lex.lxstart]
    mov       rcx,	rax
    call      cc_lex.setnumberoffset
    mov       rax,	[rip+cc_lex.lxsptr]
    sub       rax,	r14
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10+24],	eax
L6475:
#---------------
    add       rsp,	584
    pop       rbp
    pop       rcx
    movq      XMM15,	rcx
    pop       rcx
    movq      XMM14,	rcx
    pop       rcx
    movq      XMM13,	rcx
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lex.issimpleconstmacro
cc_lex.issimpleconstmacro:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rsi,	1
    mov       rbx,	3
    cmp       rbx,	1
    jl        L6518
L6516:
    mov       rax,	[r12]
    lea       r10,	[rip+cc_lex.issimpleconstmacro.specialnames]
    mov       r11,	rsi
    mov       r10,	[r10 + r11*8-8]
    mov       rcx,	r10
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L6520
    mov       rax,	2
    jmp       L6515
L6520:
    inc       rsi
    cmp       rsi,	rbx
    jle       L6516
L6518:
    mov       rdi,	[r12+72]
    test      rdi,	rdi
    jz        L6522
    mov       rax,	[rdi+8]
    test      rax,	rax
    jnz       L6522
    movzx     rax,	byte ptr[rdi+21]
    cmp       rax,	59
    jz        L6525
    movzx     rax,	byte ptr[rdi+21]
    cmp       rax,	60
    jnz       L6524
L6525:
    mov       rax,	1
    jmp       L6515
L6524:
L6522:
    xor       eax,	eax
L6515:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readmodule
cc_parse.readmodule:
#PROC1
#PROC2
#?>>
    .set cc_parse.readmodule.linkage, -8
    .set cc_parse.readmodule.wasdef, -16
    .set cc_parse.readmodule.d, -24
    .set cc_parse.readmodule.pm, -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	72
#---------------
#PROC3
#PROC4
    jmp       L6528
L6527:
    xor       r12,	r12
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	9
    jnz       L6532
L6531:
    lea       rcx,	[rip+L11224]
    call      cc_support.serror
L6532:
L6530:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    mov       r13,	rax
    mov       rcx,	[rip+cc_decls.stmodule]
    lea       rdx,	[rbp + cc_parse.readmodule.linkage]
    call      cc_parse.readdeclspec
    mov       rbx,	rax
    xor       rsi,	rsi
L6533:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L6535
    cmp       rax,	25
    jz        L6535
    cmp       rax,	13
    jnz       L6536
L6535:
    inc       r12
    mov       rcx,	[rip+cc_decls.stmodule]
    lea       rdx,	[rbp + cc_parse.readmodule.d]
    mov       r8,	rbx
    lea       r9,	[rbp + cc_parse.readmodule.pm]
    call      cc_parse.readtype
    mov       rdi,	rax
    mov       rax,	[rbp + cc_parse.readmodule.d]
    test      rax,	rax
    jnz       L6538
    lea       rcx,	[rip+L11225]
    call      cc_support.serror
L6538:
    mov       rax,	[rbp + cc_parse.readmodule.linkage]
    cmp       rax,	5
    jnz       L6540
    mov       rax,	[rbp + cc_parse.readmodule.pm]
    test      rax,	rax
    jz        L6542
    mov       rcx,	rdi
    mov       rdx,	[rbp + cc_parse.readmodule.pm]
    call      cc_lib.createprocmode
    mov       rdi,	rax
L6542:
    mov       rcx,	[rip+cc_decls.stmodule]
    mov       rdx,	[rbp + cc_parse.readmodule.d]
    mov       r8,	rdi
    call      cc_parse.createtypedef
    mov       [rbp + cc_parse.readmodule.d],	rax
    jmp       L6539
L6540:
    mov       rax,	[rbp + cc_parse.readmodule.pm]
    test      rax,	rax
    jz        L6543
#cc_parse.readmodule.readfn:
L6544:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	17
    jnz       L6546
    test      rsi,	rsi
    jz        L6546
    lea       rcx,	[rip+L11226]
    call      cc_support.serror
L6546:
    sub       rsp,	8
    lea       rax,	[rbp + cc_parse.readmodule.wasdef]
    push      rax
    mov       rcx,	[rbp + cc_parse.readmodule.d]
    mov       rdx,	rdi
    mov       r8,	[rbp + cc_parse.readmodule.linkage]
    mov       r9,	[rbp + cc_parse.readmodule.pm]
    sub       rsp,	32
    call      cc_parse.readfunction
    add       rsp,	48
    mov       [rbp + cc_parse.readmodule.d],	rax
    mov       rax,	[rbp + cc_parse.readmodule.wasdef]
    test      rax,	rax
    jnz       L6534
L6548:
    jmp       L6539
L6543:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	14
    jnz       L6549
    lea       rax,	[rip+cc_decls.ttparams]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       [rbp + cc_parse.readmodule.pm],	rax
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    mov       rdi,	rax
    jmp       L6544
L6549:
    mov       rcx,	[rbp + cc_parse.readmodule.d]
    mov       rdx,	rdi
    mov       r8,	[rbp + cc_parse.readmodule.linkage]
    call      cc_parse.readmodulevar
    mov       [rbp + cc_parse.readmodule.d],	rax
L6539:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jnz       L6552
L6551:
    mov       rsi,	1
    call      cc_lex.lex
    jmp       L6550
L6552:
    mov       rcx,	9
    call      cc_lib.skipsymbol
    jmp       L6534
L6550:
    jmp       L6533
L6536:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	12
    jz        L6554
    cmp       rax,	18
    jz        L6554
    cmp       rax,	19
    jz        L6554
    cmp       rax,	3
    jz        L6555
    jmp       L6556
L6554:
    mov       rcx,	9
    call      cc_lib.skipsymbol
    jmp       L6534
L6555:
    mov       rcx,	9
    call      cc_lib.skipsymbol
    jmp       L6534
L6556:
    mov       rcx,	rbx
    call      cc_lib.typename
    lea       rcx,	[rip+L11227]
    mov       rdx,	rax
    call      cc_support.serror_s
L6553:
    jmp       L6533
L6534:
L6528:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	57
    jnz       L6527
#---------------
    add       rsp,	72
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.parsemodule
cc_parse.parsemodule:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+cc_cli.fverbose]
    cmp       rax,	3
    jnz       L6559
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11228]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L6559:
    xor       eax,	eax
    mov       [rip+cc_parse.ingeneric],	al
    mov       [rip+cc_parse.loopindex],	rax
    xor       eax,	eax
    mov       [rip+cc_parse.ist_symptr],	rax
    lea       rcx,	[rip+cc_parse.casevaluestack]
    xor       edx,	edx
    mov       r8,	512
    call      memset
    lea       rcx,	[rip+L11229]
    mov       rdx,	[rip+cc_decls.mainfileno]
    call      cc_lex.startlex
    mov       rdi,	[rip+cc_decls.stmodule]
    xor       eax,	eax
    mov       [rip+cc_decls.currproc],	rax
    xor       eax,	eax
    mov       [rip+cc_parse.loopindex],	rax
    call      cc_lex.lex
    call      cc_parse.readmodule
    call      cc_lex.endlex
    mov       rax,	1
L6557:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_parse.readdeclspec
cc_parse.readdeclspec:
#PROC1
#PROC2
#?>>
    .set cc_parse.readdeclspec.d, -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + cc_parse.readdeclspec.d]
    xor       edx,	edx
    mov       r8,	15
    call      memset
    mov       eax,	20
    mov       [rbp + cc_parse.readdeclspec.d],	eax
    xor       eax,	eax
    mov       rbx,	rax
    mov       r12,	rax
L6561:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    sub       rax,	67
    cmp       rax,	24
    jae       L6564
    lea       r10,	[rip+L6563]
    jmp       [r10 + rax*8]
    .data
L6563:
    .quad     L6612
    .quad     L6564
    .quad     L6564
    .quad     L6566
    .quad     L6564
    .quad     L6564
    .quad     L6564
    .quad     L6564
    .quad     L6564
    .quad     L6564
    .quad     L6564
    .quad     L6564
    .quad     L6564
    .quad     L6564
    .quad     L6564
    .quad     L6564
    .quad     L6606
    .quad     L6606
    .quad     L6599
    .quad     L6593
    .quad     L6565
    .quad     L6602
    .quad     L6564
    .quad     L6609
    .text
L6565:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+22]
    mov       [rbp + cc_parse.readdeclspec.d],	eax
    call      cc_lex.lex
    jmp       L6561
L6566:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+22]
    sub       rax,	1
    cmp       rax,	10
    jae       L6569
    lea       r10,	[rip+L6568]
    jmp       [r10 + rax*8]
    .data
L6568:
    .quad     L6570
    .quad     L6570
    .quad     L6576
    .quad     L6580
    .quad     L6570
    .quad     L6570
    .quad     L6570
    .quad     L6585
    .quad     L6589
    .quad     L6570
    .text
L6570:
    movsxd    rax,	dword ptr[rbp + cc_parse.readdeclspec.d]
    cmp       rax,	20
    jz        L6572
    test      r12,	r12
    jz        L6574
    mov       rcx,	9
    call      cc_lib.checksymbol
    jmp       L6573
L6574:
    jmp       L6575
L6573:
L6572:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+22]
    lea       r10,	[rip+cc_tables.typespectypes]
    mov       r10d,	[r10 + rax*4-4]
    mov       [rbp + cc_parse.readdeclspec.d],	r10d
    jmp       L6567
L6576:
    mov       al,	[rbp + cc_parse.readdeclspec.d+9]
    test      al,	al
    jnz       L6579
    mov       al,	[rbp + cc_parse.readdeclspec.d+10]
    test      al,	al
    jnz       L6579
    mov       al,	[rbp + cc_parse.readdeclspec.d+11]
    test      al,	al
    jz        L6578
L6579:
    jmp       L6575
L6578:
    mov       rax,	1
    mov       rbx,	rax
    mov       [rbp + cc_parse.readdeclspec.d+9],	al
    jmp       L6567
L6580:
    mov       al,	[rbp + cc_parse.readdeclspec.d+11]
    test      al,	al
    jnz       L6583
    mov       al,	[rbp + cc_parse.readdeclspec.d+9]
    test      al,	al
    jz        L6582
L6583:
    jmp       L6575
L6582:
    mov       al,	[rbp + cc_parse.readdeclspec.d+10]
    test      al,	al
    jz        L6584
    xor       eax,	eax
    mov       [rbp + cc_parse.readdeclspec.d+10],	al
    mov       al,	1
    mov       [rbp + cc_parse.readdeclspec.d+11],	al
    jmp       L6581
L6584:
    mov       al,	1
    mov       [rbp + cc_parse.readdeclspec.d+10],	al
L6581:
    mov       rbx,	1
    jmp       L6567
L6585:
    mov       al,	[rbp + cc_parse.readdeclspec.d+12]
    test      al,	al
    jnz       L6588
    mov       al,	[rbp + cc_parse.readdeclspec.d+13]
    test      al,	al
    jz        L6587
L6588:
    jmp       L6575
L6587:
    mov       rax,	1
    mov       rbx,	rax
    mov       [rbp + cc_parse.readdeclspec.d+12],	al
    jmp       L6567
L6589:
    mov       al,	[rbp + cc_parse.readdeclspec.d+12]
    test      al,	al
    jnz       L6592
    mov       al,	[rbp + cc_parse.readdeclspec.d+13]
    test      al,	al
    jz        L6591
L6592:
    jmp       L6575
L6591:
    mov       rax,	1
    mov       rbx,	rax
    mov       [rbp + cc_parse.readdeclspec.d+13],	al
    jmp       L6567
L6569:
#cc_parse.readdeclspec.tserror:
L6575:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+22]
    lea       r10,	[rip+cc_tables.typespecnames]
    mov       r10,	[r10 + rax*8-8]
    lea       rcx,	[rip+L11230]
    mov       rdx,	r10
    call      cc_support.serror_s
L6567:
    call      cc_lex.lex
    jmp       L6561
L6593:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+22]
    cmp       rax,	1
    jz        L6595
    cmp       rax,	2
    jz        L6596
    cmp       rax,	3
    jz        L6597
    jmp       L6598
L6595:
    mov       al,	1
    mov       [rbp + cc_parse.readdeclspec.d+4],	al
    jmp       L6594
L6596:
    mov       al,	1
    mov       [rbp + cc_parse.readdeclspec.d+5],	al
    jmp       L6594
L6597:
    mov       al,	1
    mov       [rbp + cc_parse.readdeclspec.d+6],	al
L6598:
L6594:
    call      cc_lex.lex
    jmp       L6561
L6599:
    mov       al,	[rbp + cc_parse.readdeclspec.d+7]
    test      al,	al
    jz        L6601
    lea       rcx,	[rip+L11231]
    call      cc_support.serror
L6601:
    lea       rax,	[rip+cc_decls.lx]
    mov       al,	[rax+22]
    mov       [rbp + cc_parse.readdeclspec.d+7],	al
    call      cc_lex.lex
    jmp       L6561
L6602:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+22]
    cmp       rax,	1
    jnz       L6605
L6604:
    mov       al,	1
    mov       [rbp + cc_parse.readdeclspec.d+8],	al
L6605:
L6603:
    call      cc_lex.lex
    jmp       L6561
L6606:
    movsxd    rax,	dword ptr[rbp + cc_parse.readdeclspec.d]
    cmp       rax,	20
    jz        L6608
    lea       rcx,	[rip+L11232]
    call      cc_support.serror
L6608:
    mov       rcx,	r13
    call      cc_parse.readstructdecl
    mov       [rbp + cc_parse.readdeclspec.d],	eax
    mov       al,	1
    mov       [rbp + cc_parse.readdeclspec.d+14],	al
    mov       r12,	1
    jmp       L6561
L6609:
    movsxd    rax,	dword ptr[rbp + cc_parse.readdeclspec.d]
    cmp       rax,	20
    jz        L6611
    lea       rcx,	[rip+L11233]
    call      cc_support.serror
L6611:
    mov       rcx,	r13
    call      cc_parse.readenumdecl
    mov       eax,	3
    mov       [rbp + cc_parse.readdeclspec.d],	eax
    mov       al,	1
    mov       [rbp + cc_parse.readdeclspec.d+14],	al
    jmp       L6561
L6612:
    movsxd    rax,	dword ptr[rbp + cc_parse.readdeclspec.d]
    cmp       rax,	20
    jnz       L6614
    mov       rcx,	r13
    call      cc_parse.isusertype
    mov       rsi,	rax
    cmp       rax,	20
    jz        L6614
    test      rbx,	rbx
    jz        L6616
    mov       eax,	3
    mov       [rbp + cc_parse.readdeclspec.d],	eax
    jmp       L6562
L6616:
    mov       [rbp + cc_parse.readdeclspec.d],	esi
    mov       al,	1
    mov       [rbp + cc_parse.readdeclspec.d+14],	al
    call      cc_lex.lex
    jmp       L6613
L6614:
    movsxd    rax,	dword ptr[rbp + cc_parse.readdeclspec.d]
    cmp       rax,	20
    jnz       L6618
    test      rbx,	rbx
    jnz       L6618
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       rax,	[rax]
    lea       rcx,	[rip+L11234]
    mov       rdx,	rax
    call      cc_support.serror_s
L6618:
    movsxd    rax,	dword ptr[rbp + cc_parse.readdeclspec.d]
    cmp       rax,	20
    jnz       L6620
    mov       eax,	3
    mov       [rbp + cc_parse.readdeclspec.d],	eax
L6620:
    jmp       L6562
L6613:
    jmp       L6561
L6564:
    jmp       L6562
L6562:
    movsxd    rax,	dword ptr[rbp + cc_parse.readdeclspec.d]
    cmp       rax,	20
    jz        L6622
    movsxd    rax,	dword ptr[rbp + cc_parse.readdeclspec.d]
    jmp       L6621
L6622:
    mov       rax,	3
L6621:
    mov       rdi,	rax
    mov       al,	[rbp + cc_parse.readdeclspec.d+14]
    test      al,	al
    jnz       L6624
    mov       rax,	rdi
    cmp       rax,	3
    jz        L6626
    cmp       rax,	1
    jz        L6627
    cmp       rax,	11
    jz        L6628
    jmp       L6629
L6626:
    mov       al,	[rbp + cc_parse.readdeclspec.d+9]
    test      al,	al
    jz        L6631
    mov       al,	[rbp + cc_parse.readdeclspec.d+13]
    test      al,	al
    jz        L6633
    mov       rax,	7
    jmp       L6632
L6633:
    mov       rax,	2
L6632:
    mov       rdi,	rax
    jmp       L6630
L6631:
    mov       al,	[rbp + cc_parse.readdeclspec.d+10]
    test      al,	al
    jz        L6634
    mov       al,	[rbp + cc_parse.readdeclspec.d+13]
    test      al,	al
    jz        L6636
    mov       rax,	8
    jmp       L6635
L6636:
    mov       rax,	3
L6635:
    mov       rdi,	rax
    jmp       L6630
L6634:
    mov       al,	[rbp + cc_parse.readdeclspec.d+11]
    test      al,	al
    jz        L6637
    mov       al,	[rbp + cc_parse.readdeclspec.d+13]
    test      al,	al
    jz        L6639
    mov       rax,	9
    jmp       L6638
L6639:
    mov       rax,	4
L6638:
    mov       rdi,	rax
    jmp       L6630
L6637:
    mov       al,	[rbp + cc_parse.readdeclspec.d+13]
    test      al,	al
    jz        L6640
    mov       rdi,	8
L6640:
L6630:
    jmp       L6625
L6627:
    mov       al,	[rbp + cc_parse.readdeclspec.d+9]
    test      al,	al
    jnz       L6643
    mov       al,	[rbp + cc_parse.readdeclspec.d+10]
    test      al,	al
    jnz       L6643
    mov       al,	[rbp + cc_parse.readdeclspec.d+11]
    test      al,	al
    jz        L6642
L6643:
    lea       rcx,	[rip+L11235]
    call      cc_support.serror
L6642:
    mov       al,	[rbp + cc_parse.readdeclspec.d+13]
    test      al,	al
    jz        L6645
    mov       rax,	6
    jmp       L6644
L6645:
    mov       rax,	1
L6644:
    mov       rdi,	rax
    jmp       L6625
L6628:
    mov       al,	[rbp + cc_parse.readdeclspec.d+9]
    test      al,	al
    jnz       L6648
    mov       al,	[rbp + cc_parse.readdeclspec.d+11]
    test      al,	al
    jnz       L6648
    mov       al,	[rbp + cc_parse.readdeclspec.d+12]
    test      al,	al
    jnz       L6648
    mov       al,	[rbp + cc_parse.readdeclspec.d+13]
    test      al,	al
    jz        L6647
L6648:
    lea       rcx,	[rip+L11236]
    call      cc_support.serror
L6647:
    jmp       L6625
L6629:
    test      rbx,	rbx
    jz        L6650
    lea       rcx,	[rip+L11237]
    call      cc_support.serror
L6650:
L6625:
L6624:
    mov       al,	[rbp + cc_parse.readdeclspec.d+4]
    test      al,	al
    jz        L6652
    mov       rcx,	rdi
    call      cc_lib.createconstmode
    mov       rdi,	rax
L6652:
    movzx     rax,	byte ptr[rbp + cc_parse.readdeclspec.d+7]
    mov       [r14],	rax
    mov       rax,	rdi
L6560:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.istypestarter
cc_parse.istypestarter:
#PROC1
#PROC2
#?>>
    .set cc_parse.istypestarter.$T3, -8
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	70
    jz        L6655
    cmp       rax,	87
    jz        L6655
    cmp       rax,	86
    jz        L6656
    cmp       rax,	67
    jz        L6657
    cmp       rax,	83
    jz        L6658
    cmp       rax,	84
    jz        L6658
    cmp       rax,	90
    jz        L6658
    jmp       L6659
L6655:
    mov       rax,	1
    jmp       L6653
L6656:
    mov       rax,	1
    jmp       L6653
L6657:
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       [rbp + cc_parse.istypestarter.$T3],	rax
    mov       rax,	[rip+cc_decls.currproc]
    test      rax,	rax
    jz        L6661
    mov       rax,	[rip+cc_decls.currproc]
    jmp       L6660
L6661:
    mov       rax,	[rip+cc_decls.stmodule]
L6660:
    mov       rcx,	rax
    mov       rdx,	[rbp + cc_parse.istypestarter.$T3]
    mov       r8,	1
    mov       r9,	[rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L6663
    mov       rax,	rdi
    lea       r10,	[rip+cc_decls.lx]
    mov       [r10],	rax
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	5
    setz      al
    movzx     eax,	al
    jmp       L6653
L6663:
    jmp       L6654
L6658:
    mov       rax,	1
    jmp       L6653
L6659:
L6654:
    xor       eax,	eax
L6653:
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc cc_parse.istypestarter_next
cc_parse.istypestarter_next:
#PROC1
#PROC2
#?>>
    .set cc_parse.istypestarter_next.$T3, -8
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	70
    jz        L6666
    cmp       rax,	87
    jz        L6666
    cmp       rax,	86
    jz        L6667
    cmp       rax,	67
    jz        L6668
    cmp       rax,	83
    jz        L6669
    cmp       rax,	84
    jz        L6669
    cmp       rax,	90
    jz        L6669
    jmp       L6670
L6666:
    mov       rax,	1
    jmp       L6664
L6667:
    mov       rax,	1
    jmp       L6664
L6668:
    lea       rax,	[rip+cc_decls.nextlx]
    mov       rax,	[rax]
    mov       [rbp + cc_parse.istypestarter_next.$T3],	rax
    mov       rax,	[rip+cc_decls.currproc]
    test      rax,	rax
    jz        L6672
    mov       rax,	[rip+cc_decls.currproc]
    jmp       L6671
L6672:
    mov       rax,	[rip+cc_decls.stmodule]
L6671:
    mov       rcx,	rax
    mov       rdx,	[rbp + cc_parse.istypestarter_next.$T3]
    mov       r8,	1
    mov       r9,	[rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L6674
    mov       rax,	rdi
    lea       r10,	[rip+cc_decls.nextlx]
    mov       [r10],	rax
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	5
    setz      al
    movzx     eax,	al
    jmp       L6664
L6674:
    jmp       L6665
L6669:
    mov       rax,	1
    jmp       L6664
L6670:
L6665:
    xor       eax,	eax
L6664:
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc cc_parse.readexpression
cc_parse.readexpression:
#PROC1
#PROC2
#?>>
    .set cc_parse.readexpression.ulist, -8
    .set cc_parse.readexpression.ulistx, -16
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	9
    jz        L6677
    cmp       rax,	14
    jnz       L6678
L6677:
    call      cc_parse.readterm
    jmp       L6675
L6678:
L6676:
    call      cc_parse.readassignexpr
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jnz       L6680
    xor       eax,	eax
    mov       [rbp + cc_parse.readexpression.ulistx],	rax
    mov       [rbp + cc_parse.readexpression.ulist],	rax
L6681:
    lea       rcx,	[rbp + cc_parse.readexpression.ulist]
    lea       rdx,	[rbp + cc_parse.readexpression.ulistx]
    mov       r8,	rdi
    call      cc_lib.addlistunit
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jnz       L6682
L6684:
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       rdi,	rax
    jmp       L6681
L6682:
    mov       rcx,	29
    mov       rdx,	[rbp + cc_parse.readexpression.ulist]
    call      cc_lib.createunit1
    mov       rdi,	rax
    mov       rax,	[rbp + cc_parse.readexpression.ulistx]
    test      rax,	rax
    jz        L6686
    mov       rax,	[rbp + cc_parse.readexpression.ulistx]
    mov       eax,	[rax+52]
    mov       [rdi+52],	eax
L6686:
    mov       rax,	rdi
    jmp       L6675
L6680:
    mov       rax,	rdi
L6675:
#---------------
    add       rsp,	56
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc cc_parse.readassignexpr
cc_parse.readassignexpr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jz        L6689
    cmp       rax,	9
    jz        L6689
    cmp       rax,	14
    jz        L6689
    cmp       rax,	11
    jz        L6690
    jmp       L6691
L6689:
    call      cc_parse.readterm
    jmp       L6687
L6690:
    call      cc_parse.readterm
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    mov       r12,	rax
    jmp       L6692
L6691:
L6688:
    call      cc_parse.readcondexpr
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    mov       r12,	rax
    sub       rax,	11
    cmp       rax,	45
    jae       L6695
    lea       r10,	[rip+L6694]
    jmp       [r10 + rax*8]
    .data
L6694:
    .quad     L6696
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6695
    .quad     L6696
    .quad     L6696
    .quad     L6696
    .quad     L6696
    .quad     L6696
    .quad     L6696
    .quad     L6696
    .quad     L6696
    .quad     L6696
    .quad     L6696
    .text
L6696:
#cc_parse.readassignexpr.gotp:
L6692:
    call      cc_lex.lex
    movsxd    rax,	dword ptr[rdi+52]
    mov       r13,	rax
    mov       rcx,	rdi
    mov       rdx,	1
    call      cc_parse.checklvalue
    call      cc_parse.readassignexpr
    mov       rbx,	rax
    movsxd    rax,	dword ptr[rdi+52]
    lea       r10,	[rip+cc_decls.ttisref]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L6698
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	rbx
    call      cc_parse.createassignopref
    jmp       L6687
L6698:
    mov       rcx,	rbx
    mov       rdx,	r13
    call      cc_parse.coercemode
    mov       rbx,	rax
    lea       rax,	[rip+cc_decls.ttconst]
    mov       r10,	r13
    mov       al,	[rax + r10]
    test      al,	al
    jz        L6700
    lea       rcx,	[rip+L11238]
    call      cc_support.terror
L6700:
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	52
    jnz       L6702
    mov       rax,	[rdi+16]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L6702
    lea       rcx,	[rip+L11239]
    call      cc_support.terror
L6702:
    lea       rax,	[rip+cc_tables.symboltojtag]
    mov       r10,	r12
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      cc_lib.createunit2
    mov       rsi,	rax
    mov       [rsi+52],	r13d
    mov       rax,	rsi
    jmp       L6687
L6695:
L6693:
    mov       rax,	rdi
L6687:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readcondexpr
cc_parse.readcondexpr:
#PROC1
#PROC2
#?>>
    .set cc_parse.readcondexpr.u, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_parse.readorlexpr
    mov       rsi,	rax
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	19
    jnz       L6705
    mov       rcx,	rsi
    call      cc_parse.coercecond
    call      cc_lex.lex
    call      cc_parse.readexpression
    mov       rdi,	rax
    mov       rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readcondexpr
    mov       rbx,	rax
    movsxd    rax,	dword ptr[rdi+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       r12,	r10
    lea       rax,	[rip+cc_tables.dominantmode]
    mov       r11,	r10
    shl       r11,	5
    lea       rax,	[rax + r11]
    movsxd    r10,	dword ptr[rbx+52]
    lea       r11,	[rip+cc_decls.ttbasetype]
    movsx     r11,	word ptr[r11 + r10*2]
    mov       r13,	r11
    movzx     rax,	byte ptr[rax + r11]
    mov       [rbp + cc_parse.readcondexpr.u],	rax
    test      rax,	rax
    jz        L6707
    mov       rcx,	rdi
    mov       rdx,	[rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	[rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    mov       rbx,	rax
    movsxd    rax,	dword ptr[rsi+40]
    cmp       rax,	1
    jnz       L6709
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	1
    jnz       L6709
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L6709
    mov       rax,	[rsi]
    test      rax,	rax
    jz        L6711
    mov       rax,	rdi
    jmp       L6710
L6711:
    mov       rax,	rbx
L6710:
    jmp       L6703
L6709:
    jmp       L6706
L6707:
    cmp       r12,	13
    jnz       L6712
    cmp       r13,	13
    jnz       L6712
    movsxd    rax,	dword ptr[rdi+52]
    mov       [rbp + cc_parse.readcondexpr.u],	rax
    jmp       L6706
L6712:
    cmp       r12,	13
    jnz       L6713
    cmp       r13,	3
    jnz       L6713
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L6713
    mov       rax,	[rbx]
    test      rax,	rax
    jnz       L6713
    movsxd    rax,	dword ptr[rdi+52]
    mov       [rbp + cc_parse.readcondexpr.u],	rax
    mov       rcx,	rbx
    mov       rdx,	[rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    jmp       L6706
L6713:
    cmp       r12,	3
    jnz       L6714
    cmp       r13,	13
    jnz       L6714
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	1
    jnz       L6714
    mov       rax,	[rdi]
    test      rax,	rax
    jnz       L6714
    movsxd    rax,	dword ptr[rbx+52]
    mov       [rbp + cc_parse.readcondexpr.u],	rax
    mov       rcx,	rdi
    mov       rdx,	[rbp + cc_parse.readcondexpr.u]
    call      cc_parse.coercemode
    jmp       L6706
L6714:
    cmp       r12,	18
    jnz       L6715
    cmp       r13,	18
    jnz       L6715
    movsxd    rax,	dword ptr[rdi+52]
    mov       [rbp + cc_parse.readcondexpr.u],	rax
    jmp       L6706
L6715:
    cmp       r12,	19
    jnz       L6716
    cmp       r13,	19
    jnz       L6716
    movsxd    rax,	dword ptr[rdi+52]
    mov       [rbp + cc_parse.readcondexpr.u],	rax
    jmp       L6706
L6716:
    mov       rax,	r13
    cmp       rax,	r12
    jnz       L6717
    test      rax,	rax
    jnz       L6717
    xor       eax,	eax
    mov       [rbp + cc_parse.readcondexpr.u],	rax
    jmp       L6706
L6717:
    call      msys.m$print_startcon
    movsxd    rax,	dword ptr[rdi+52]
    mov       rcx,	rax
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    movsxd    rax,	dword ptr[rbx+52]
    mov       rcx,	rax
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11240]
    call      cc_support.terror
L6706:
    mov       rcx,	31
    mov       rdx,	rsi
    mov       r8,	rdi
    mov       r9,	rbx
    call      cc_lib.createunit3
    mov       rsi,	rax
    mov       eax,	[rbp + cc_parse.readcondexpr.u]
    mov       [rsi+52],	eax
L6705:
    mov       rax,	rsi
L6703:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readorlexpr
cc_parse.readorlexpr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_parse.readandlexpr
    mov       rdi,	rax
    jmp       L6720
L6719:
    call      cc_lex.lex
    call      cc_parse.readandlexpr
    mov       rbx,	rax
    mov       rcx,	rdi
    call      cc_parse.coercecond
    mov       rcx,	rbx
    call      cc_parse.coercecond
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	1
    jnz       L6723
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L6723
    mov       rax,	[rdi]
    test      rax,	rax
    jnz       L6726
    mov       rax,	[rbx]
    test      rax,	rax
    jz        L6725
L6726:
    mov       rax,	1
    jmp       L6724
L6725:
    xor       eax,	eax
L6724:
    mov       [rdi],	rax
    jmp       L6720
L6723:
    mov       rcx,	25
    mov       rdx,	rdi
    mov       r8,	rbx
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       eax,	3
    mov       [rdi+52],	eax
L6720:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	31
    jz        L6719
    mov       rax,	rdi
L6718:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readandlexpr
cc_parse.readandlexpr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_parse.readiorexpr
    mov       rdi,	rax
    jmp       L6729
L6728:
    call      cc_lex.lex
    call      cc_parse.readiorexpr
    mov       rbx,	rax
    mov       rcx,	rdi
    call      cc_parse.coercecond
    mov       rcx,	rbx
    call      cc_parse.coercecond
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	1
    jnz       L6732
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L6732
    mov       rax,	[rdi]
    test      rax,	rax
    jz        L6734
    mov       rax,	[rbx]
    test      rax,	rax
    jz        L6734
    mov       rax,	1
    jmp       L6733
L6734:
    xor       eax,	eax
L6733:
    mov       [rdi],	rax
    jmp       L6729
L6732:
    mov       rcx,	24
    mov       rdx,	rdi
    mov       r8,	rbx
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       eax,	3
    mov       [rdi+52],	eax
L6729:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	32
    jz        L6728
    mov       rax,	rdi
L6727:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readiorexpr
cc_parse.readiorexpr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_parse.readixorexpr
    mov       rdi,	rax
    jmp       L6737
L6736:
    call      cc_lex.lex
    call      cc_parse.readixorexpr
    mov       rbx,	rax
    movsxd    rax,	dword ptr[rdi+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    lea       rax,	[rip+cc_tables.dominantmode]
    mov       r11,	r10
    shl       r11,	5
    lea       rax,	[rax + r11]
    movsxd    r10,	dword ptr[rbx+52]
    lea       r11,	[rip+cc_decls.ttbasetype]
    movsx     r11,	word ptr[r11 + r10*2]
    movzx     rax,	byte ptr[rax + r11]
    mov       rsi,	rax
    test      rax,	rax
    jz        L6740
    cmp       rsi,	10
    jl        L6742
    lea       rcx,	[rip+L11241]
    call      cc_support.terror
L6742:
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      cc_parse.coercemode
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      cc_parse.coercemode
    mov       rbx,	rax
    jmp       L6739
L6740:
    lea       rcx,	[rip+L11242]
    call      cc_support.terror
L6739:
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	1
    jnz       L6744
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L6744
    mov       rax,	rsi
    cmp       rax,	3
    jz        L6746
    cmp       rax,	4
    jz        L6746
    cmp       rax,	8
    jz        L6746
    cmp       rax,	9
    jnz       L6747
L6746:
    mov       rax,	[rbx]
    mov       r10,	rdi
    or        [r10],	rax
    jmp       L6737
L6747:
L6745:
L6744:
    mov       rcx,	45
    mov       rdx,	rdi
    mov       r8,	rbx
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	esi
L6737:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	28
    jz        L6736
    mov       rax,	rdi
L6735:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readixorexpr
cc_parse.readixorexpr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_parse.readiandexpr
    mov       rdi,	rax
    jmp       L6750
L6749:
    call      cc_lex.lex
    call      cc_parse.readiandexpr
    mov       rbx,	rax
    movsxd    rax,	dword ptr[rdi+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    lea       rax,	[rip+cc_tables.dominantmode]
    mov       r11,	r10
    shl       r11,	5
    lea       rax,	[rax + r11]
    movsxd    r10,	dword ptr[rbx+52]
    lea       r11,	[rip+cc_decls.ttbasetype]
    movsx     r11,	word ptr[r11 + r10*2]
    movzx     rax,	byte ptr[rax + r11]
    mov       rsi,	rax
    test      rax,	rax
    jz        L6753
    cmp       rsi,	10
    jl        L6755
    lea       rcx,	[rip+L11243]
    call      cc_support.terror
L6755:
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      cc_parse.coercemode
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      cc_parse.coercemode
    mov       rbx,	rax
    jmp       L6752
L6753:
    lea       rcx,	[rip+L11244]
    call      cc_support.terror
L6752:
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	1
    jnz       L6757
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L6757
    mov       rax,	rsi
    cmp       rax,	3
    jz        L6759
    cmp       rax,	4
    jz        L6759
    cmp       rax,	8
    jz        L6759
    cmp       rax,	9
    jnz       L6760
L6759:
    mov       rax,	[rbx]
    mov       r10,	rdi
    xor       [r10],	rax
    jmp       L6750
L6760:
L6758:
L6757:
    mov       rcx,	46
    mov       rdx,	rdi
    mov       r8,	rbx
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	esi
L6750:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	30
    jz        L6749
    mov       rax,	rdi
L6748:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readiandexpr
cc_parse.readiandexpr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_parse.readeqexpr
    mov       rdi,	rax
    jmp       L6763
L6762:
    call      cc_lex.lex
    call      cc_parse.readeqexpr
    mov       rbx,	rax
    movsxd    rax,	dword ptr[rdi+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    lea       rax,	[rip+cc_tables.dominantmode]
    mov       r11,	r10
    shl       r11,	5
    lea       rax,	[rax + r11]
    movsxd    r10,	dword ptr[rbx+52]
    lea       r11,	[rip+cc_decls.ttbasetype]
    movsx     r11,	word ptr[r11 + r10*2]
    movzx     rax,	byte ptr[rax + r11]
    mov       rsi,	rax
    test      rax,	rax
    jz        L6766
    cmp       rsi,	10
    jl        L6768
    lea       rcx,	[rip+L11245]
    call      cc_support.terror
L6768:
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      cc_parse.coercemode
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      cc_parse.coercemode
    mov       rbx,	rax
    jmp       L6765
L6766:
    call      msys.m$print_startcon
    movsxd    rax,	dword ptr[rdi+52]
    mov       rcx,	rax
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    movsxd    rax,	dword ptr[rbx+52]
    mov       rcx,	rax
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11246]
    call      cc_support.terror
L6765:
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	1
    jnz       L6770
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L6770
    mov       rax,	rsi
    cmp       rax,	3
    jz        L6772
    cmp       rax,	4
    jz        L6772
    cmp       rax,	8
    jz        L6772
    cmp       rax,	9
    jnz       L6773
L6772:
    mov       rax,	[rbx]
    mov       r10,	rdi
    and       [r10],	rax
    jmp       L6763
L6773:
L6771:
L6770:
    mov       rcx,	44
    mov       rdx,	rdi
    mov       r8,	rbx
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	esi
L6763:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	29
    jz        L6762
    mov       rax,	rdi
L6761:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readeqexpr
cc_parse.readeqexpr:
#PROC1
#PROC2
#?>>
    .set cc_parse.readeqexpr.ss, -8
    .set cc_parse.readeqexpr.tt, -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_parse.readrelexpr
    mov       rdi,	rax
    jmp       L6776
L6775:
    call      cc_lex.lex
    call      cc_parse.readrelexpr
    mov       rbx,	rax
    movsxd    rax,	dword ptr[rdi+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       r12,	r10
    lea       rax,	[rip+cc_tables.dominantmode]
    mov       r11,	r10
    shl       r11,	5
    lea       rax,	[rax + r11]
    movsxd    r10,	dword ptr[rbx+52]
    lea       r11,	[rip+cc_decls.ttbasetype]
    movsx     r11,	word ptr[r11 + r10*2]
    mov       r13,	r11
    movzx     rax,	byte ptr[rax + r11]
    mov       r14,	rax
    test      rax,	rax
    jz        L6779
    mov       rcx,	rdi
    mov       rdx,	r14
    call      cc_parse.coercemode
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	r14
    call      cc_parse.coercemode
    mov       rbx,	rax
    jmp       L6778
L6779:
    cmp       r12,	13
    jnz       L6780
    cmp       r13,	13
    jnz       L6780
    movsxd    rax,	dword ptr[rdi+52]
    lea       r10,	[rip+cc_decls.tttarget]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       [rbp + cc_parse.readeqexpr.ss],	r10
    movsxd    rax,	dword ptr[rbx+52]
    lea       r11,	[rip+cc_decls.tttarget]
    movsx     r11,	word ptr[r11 + rax*2]
    mov       [rbp + cc_parse.readeqexpr.tt],	r11
    cmp       r10,	r11
    jz        L6782
    mov       rax,	[rbp + cc_parse.readeqexpr.ss]
    test      rax,	rax
    jz        L6784
    mov       rax,	[rbp + cc_parse.readeqexpr.tt]
    test      rax,	rax
    jz        L6784
    movsxd    rax,	dword ptr[rbx+52]
    movsxd    r10,	dword ptr[rdi+52]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	1
    call      cc_parse.checkpointertypes
    test      rax,	rax
    jnz       L6786
    lea       rcx,	[rip+L11247]
    call      cc_support.terror
L6786:
L6784:
L6782:
    jmp       L6778
L6780:
    cmp       r12,	13
    jnz       L6787
    cmp       r13,	3
    jnz       L6787
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L6790
    mov       rax,	[rbx]
    test      rax,	rax
    jz        L6789
L6790:
    lea       rcx,	[rip+L11248]
    call      cc_support.terror
L6789:
    jmp       L6778
L6787:
    cmp       r12,	3
    jnz       L6791
    cmp       r13,	13
    jnz       L6791
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	1
    jnz       L6794
    mov       rax,	[rdi]
    test      rax,	rax
    jz        L6793
L6794:
    lea       rcx,	[rip+L11249]
    call      cc_support.terror
L6793:
    jmp       L6778
L6791:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11250]
    call      msys.m$print_str_nf
    mov       rcx,	r14
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11251]
    call      cc_support.terror
L6778:
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	1
    jnz       L6796
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L6796
    mov       rax,	r14
    cmp       rax,	3
    jz        L6798
    cmp       rax,	4
    jz        L6798
    cmp       rax,	8
    jz        L6798
    cmp       rax,	9
    jz        L6798
    test      rax,	rax
    jnz       L6799
L6798:
    cmp       rsi,	40
    jnz       L6801
    mov       rax,	[rdi]
    mov       r10,	[rbx]
    cmp       rax,	r10
    setz      al
    movzx     eax,	al
    mov       [rdi],	rax
    jmp       L6800
L6801:
    mov       rax,	[rdi]
    mov       r10,	[rbx]
    cmp       rax,	r10
    setnz     al
    movzx     eax,	al
    mov       [rdi],	rax
L6800:
    jmp       L6776
L6799:
L6797:
L6796:
    lea       rax,	[rip+cc_tables.symboltojtag]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       eax,	3
    mov       [rdi+52],	eax
L6776:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    mov       rsi,	rax
    cmp       rax,	40
    jz        L6775
    cmp       rsi,	41
    jz        L6775
    mov       rax,	rdi
L6774:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readrelexpr
cc_parse.readrelexpr:
#PROC1
#PROC2
#?>>
    .set cc_parse.readrelexpr.a, -8
    .set cc_parse.readrelexpr.b, -16
    .set cc_parse.readrelexpr.c, -24
    .set cc_parse.readrelexpr.aa, -32
    .set cc_parse.readrelexpr.bb, -40
    .set cc_parse.readrelexpr.cc, -48
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	80
#---------------
#PROC3
#PROC4
    call      cc_parse.readshiftexpr
    mov       rdi,	rax
    jmp       L6804
L6803:
    call      cc_lex.lex
    call      cc_parse.readshiftexpr
    mov       rbx,	rax
    movsxd    rax,	dword ptr[rdi+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       r12,	r10
    lea       rax,	[rip+cc_tables.dominantmode]
    mov       r11,	r10
    shl       r11,	5
    lea       rax,	[rax + r11]
    movsxd    r10,	dword ptr[rbx+52]
    lea       r11,	[rip+cc_decls.ttbasetype]
    movsx     r11,	word ptr[r11 + r10*2]
    mov       r13,	r11
    movzx     rax,	byte ptr[rax + r11]
    mov       r14,	rax
    test      rax,	rax
    jz        L6807
    mov       rcx,	rdi
    mov       rdx,	r14
    call      cc_parse.coercemode
    mov       rdi,	rax
    mov       rcx,	rbx
    mov       rdx,	r14
    call      cc_parse.coercemode
    mov       rbx,	rax
    jmp       L6806
L6807:
    cmp       r12,	13
    jnz       L6808
    cmp       r13,	13
    jnz       L6808
    movsxd    rax,	dword ptr[rbx+52]
    movsxd    r10,	dword ptr[rdi+52]
    mov       rcx,	r10
    mov       rdx,	rax
    mov       r8,	1
    call      cc_parse.checkpointertypes
    test      rax,	rax
    jnz       L6810
    lea       rcx,	[rip+L11252]
    call      cc_support.terror
L6810:
    jmp       L6806
L6808:
    lea       rcx,	[rip+L11253]
    call      cc_support.terror
L6806:
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	1
    jnz       L6812
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L6812
    mov       rax,	[rdi]
    mov       [rbp + cc_parse.readrelexpr.a],	rax
    mov       rax,	[rbx]
    mov       [rbp + cc_parse.readrelexpr.b],	rax
    mov       rax,	r14
    cmp       rax,	3
    jz        L6814
    cmp       rax,	4
    jz        L6814
    cmp       rax,	8
    jz        L6815
    cmp       rax,	9
    jz        L6815
    jmp       L6816
L6814:
    mov       rax,	rsi
    cmp       rax,	42
    jz        L6818
    cmp       rax,	43
    jz        L6819
    cmp       rax,	44
    jz        L6820
    jmp       L6821
L6818:
    mov       rax,	[rbp + cc_parse.readrelexpr.a]
    cmp       rax,	[rbp + cc_parse.readrelexpr.b]
    setl      al
    movzx     eax,	al
    mov       [rbp + cc_parse.readrelexpr.c],	rax
    jmp       L6817
L6819:
    mov       rax,	[rbp + cc_parse.readrelexpr.a]
    cmp       rax,	[rbp + cc_parse.readrelexpr.b]
    setle     al
    movzx     eax,	al
    mov       [rbp + cc_parse.readrelexpr.c],	rax
    jmp       L6817
L6820:
    mov       rax,	[rbp + cc_parse.readrelexpr.a]
    cmp       rax,	[rbp + cc_parse.readrelexpr.b]
    setge     al
    movzx     eax,	al
    mov       [rbp + cc_parse.readrelexpr.c],	rax
    jmp       L6817
L6821:
    mov       rax,	[rbp + cc_parse.readrelexpr.a]
    cmp       rax,	[rbp + cc_parse.readrelexpr.b]
    setg      al
    movzx     eax,	al
    mov       [rbp + cc_parse.readrelexpr.c],	rax
L6817:
    mov       rax,	[rbp + cc_parse.readrelexpr.c]
    mov       [rdi],	rax
    jmp       L6804
L6815:
    mov       rax,	[rdi]
    mov       [rbp + cc_parse.readrelexpr.aa],	rax
    mov       rax,	[rbx]
    mov       [rbp + cc_parse.readrelexpr.bb],	rax
    mov       rax,	rsi
    cmp       rax,	42
    jz        L6823
    cmp       rax,	43
    jz        L6824
    cmp       rax,	44
    jz        L6825
    jmp       L6826
L6823:
    mov       rax,	[rbp + cc_parse.readrelexpr.aa]
    cmp       rax,	[rbp + cc_parse.readrelexpr.bb]
    setb      al
    movzx     eax,	al
    mov       [rbp + cc_parse.readrelexpr.cc],	rax
    jmp       L6822
L6824:
    mov       rax,	[rbp + cc_parse.readrelexpr.aa]
    cmp       rax,	[rbp + cc_parse.readrelexpr.bb]
    setbe     al
    movzx     eax,	al
    mov       [rbp + cc_parse.readrelexpr.cc],	rax
    jmp       L6822
L6825:
    mov       rax,	[rbp + cc_parse.readrelexpr.aa]
    cmp       rax,	[rbp + cc_parse.readrelexpr.bb]
    setae     al
    movzx     eax,	al
    mov       [rbp + cc_parse.readrelexpr.cc],	rax
    jmp       L6822
L6826:
    mov       rax,	[rbp + cc_parse.readrelexpr.aa]
    cmp       rax,	[rbp + cc_parse.readrelexpr.bb]
    seta      al
    movzx     eax,	al
    mov       [rbp + cc_parse.readrelexpr.cc],	rax
L6822:
    mov       rax,	[rbp + cc_parse.readrelexpr.cc]
    mov       [rdi],	rax
    jmp       L6804
L6816:
L6813:
L6812:
    lea       rax,	[rip+cc_tables.symboltojtag]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       eax,	3
    mov       [rdi+52],	eax
L6804:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    mov       rsi,	rax
    cmp       rax,	42
    jz        L6803
    cmp       rsi,	43
    jz        L6803
    cmp       rsi,	44
    jz        L6803
    cmp       rsi,	45
    jz        L6803
    mov       rax,	rdi
L6802:
#---------------
    add       rsp,	80
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readshiftexpr
cc_parse.readshiftexpr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_parse.readaddexpr
    mov       rdi,	rax
    jmp       L6829
L6828:
    call      cc_lex.lex
    call      cc_parse.readaddexpr
    mov       rbx,	rax
    mov       rcx,	rdi
    call      cc_parse.coercebasetype
    movsxd    rax,	dword ptr[rdi+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       r12,	r10
    cmp       r10,	1
    jl        L6833
    cmp       r12,	9
    jle       L6832
L6833:
    lea       rcx,	[rip+L11254]
    call      cc_support.terror
L6832:
    mov       rcx,	rbx
    mov       rdx,	3
    call      cc_parse.coercemode
    mov       rbx,	rax
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	1
    jnz       L6835
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L6835
    mov       rax,	r12
    cmp       rax,	3
    jz        L6837
    cmp       rax,	4
    jz        L6837
    cmp       rax,	8
    jz        L6838
    cmp       rax,	9
    jz        L6838
    jmp       L6839
L6837:
    cmp       rsi,	33
    jnz       L6841
    mov       rax,	[rdi]
    mov       r10,	[rbx]
    mov       cl,	r10b
    shl       rax,	cl
    mov       [rdi],	rax
    jmp       L6840
L6841:
    mov       rax,	[rdi]
    mov       r10,	[rbx]
    mov       cl,	r10b
    sar       rax,	cl
    mov       [rdi],	rax
L6840:
    jmp       L6829
L6838:
    cmp       rsi,	33
    jnz       L6843
    mov       rax,	[rdi]
    mov       r10,	[rbx]
    mov       cl,	r10b
    shl       rax,	cl
    mov       [rdi],	rax
    jmp       L6842
L6843:
    mov       rax,	[rdi]
    mov       r10,	[rbx]
    mov       cl,	r10b
    shr       rax,	cl
    mov       [rdi],	rax
L6842:
    jmp       L6829
L6839:
L6836:
L6835:
    cmp       rsi,	33
    jnz       L6845
    mov       rax,	47
    jmp       L6844
L6845:
    mov       rax,	48
L6844:
    mov       rcx,	rax
    mov       rdx,	rdi
    mov       r8,	rbx
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	r12d
L6829:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    mov       rsi,	rax
    cmp       rax,	33
    jz        L6828
    cmp       rsi,	34
    jz        L6828
    mov       rax,	rdi
L6827:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readaddexpr
cc_parse.readaddexpr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_parse.readmulexpr
    mov       rdi,	rax
    jmp       L6848
L6847:
    call      cc_lex.lex
    call      cc_parse.readmulexpr
    mov       rbx,	rax
    cmp       rsi,	23
    jnz       L6851
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      cc_parse.createaddop
    mov       rdi,	rax
    jmp       L6850
L6851:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      cc_parse.createsubop
    mov       rdi,	rax
L6850:
L6848:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    mov       rsi,	rax
    cmp       rax,	23
    jz        L6847
    cmp       rsi,	24
    jz        L6847
    mov       rax,	rdi
L6846:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readmulexpr
cc_parse.readmulexpr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_parse.readterm
    mov       rdi,	rax
    jmp       L6854
L6853:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       rbx,	rax
    mov       rax,	rsi
    cmp       rax,	25
    jz        L6857
    cmp       rax,	26
    jz        L6858
    cmp       rax,	27
    jz        L6859
    jmp       L6860
L6857:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      cc_parse.createmulop
    mov       rdi,	rax
    jmp       L6856
L6858:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      cc_parse.createdivop
    mov       rdi,	rax
    jmp       L6856
L6859:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      cc_parse.createremop
    mov       rdi,	rax
L6860:
L6856:
L6854:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    mov       rsi,	rax
    cmp       rax,	25
    jz        L6853
    cmp       rsi,	26
    jz        L6853
    cmp       rsi,	27
    jz        L6853
    mov       rax,	rdi
L6852:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readterm
cc_parse.readterm:
#PROC1
#PROC2
#?>>
    .set cc_parse.readterm.slength, -8
    .set cc_parse.readterm.fwide, -16
    .set cc_parse.readterm.tag, -24
    .set cc_parse.readterm.pbyte, -32
    .set cc_parse.readterm.a, -40
    .set cc_parse.readterm.d, -48
    .set cc_parse.readterm.ss, -56
    .set cc_parse.readterm.s, -64
    .set cc_parse.readterm.pm, -72
    .set cc_parse.readterm.av_1, -80
    .set cc_parse.readterm.$T3, -88
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	120
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    sub       rax,	13
    cmp       rax,	83
    jae       L6864
    lea       r10,	[rip+L6863]
    jmp       [r10 + rax*8]
    .data
L6863:
    .quad     L6911
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6898
    .quad     L6899
    .quad     L6908
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6904
    .quad     L6864
    .quad     L6864
    .quad     L6907
    .quad     L6864
    .quad     L6864
    .quad     L6903
    .quad     L6900
    .quad     L6909
    .quad     L6909
    .quad     L6910
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6865
    .quad     L6865
    .quad     L6890
    .quad     L6864
    .quad     L6884
    .quad     L6884
    .quad     L6864
    .quad     L6864
    .quad     L6866
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6864
    .quad     L6916
    .quad     L6864
    .quad     L6927
    .quad     L6928
    .quad     L6929
    .text
L6865:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+22]
    lea       r10,	[rip+cc_decls.lx]
    mov       r10,	[r10]
    mov       rcx,	r10
    mov       rdx,	rax
    call      cc_lib.createconstunit
    mov       rdi,	rax
    call      cc_lex.lex
    jmp       L6862
L6866:
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	1
    jg        L6868
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       [rbp + cc_parse.readterm.$T3],	rax
    mov       rax,	[rip+cc_decls.currproc]
    test      rax,	rax
    jz        L6870
    mov       rax,	[rip+cc_decls.currproc]
    jmp       L6869
L6870:
    mov       rax,	[rip+cc_decls.stmodule]
L6869:
    mov       rcx,	rax
    mov       rdx,	[rbp + cc_parse.readterm.$T3]
    mov       r8,	1
    mov       r9,	[rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       [rbp + cc_parse.readterm.d],	rax
    mov       rax,	[rbp + cc_parse.readterm.d]
    test      rax,	rax
    jnz       L6872
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      cc_lib.getstname
    lea       rcx,	[rip+L11255]
    mov       rdx,	rax
    call      cc_support.serror_s
L6872:
    jmp       L6867
L6868:
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       [rbp + cc_parse.readterm.d],	rax
L6867:
    mov       rax,	[rbp + cc_parse.readterm.d]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	11
    jz        L6874
    cmp       rax,	6
    jz        L6875
    jmp       L6876
L6874:
    mov       rax,	[rbp + cc_parse.readterm.d]
    movsxd    rax,	dword ptr[rax+88]
    mov       rcx,	rax
    mov       rdx,	3
    call      cc_lib.createconstunit
    mov       rdi,	rax
    jmp       L6873
L6875:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	13
    jz        L6878
    mov       rcx,	5
    call      cc_lib.createunit0
    mov       rdi,	rax
    mov       rax,	[rbp + cc_parse.readterm.d]
    mov       [rdi],	rax
    mov       rax,	[rbp + cc_parse.readterm.d]
    mov       rax,	[rax+80]
    mov       r10,	[rbp + cc_parse.readterm.d]
    movzx     r10,	word ptr[r10+102]
    mov       rcx,	r10
    mov       rdx,	rax
    call      cc_lib.createprocmode
    mov       rcx,	rax
    call      cc_lib.createrefmode
    mov       [rdi+52],	eax
    jmp       L6877
L6878:
    jmp       L6879
L6877:
    jmp       L6873
L6876:
#cc_parse.readterm.doname:
L6879:
    mov       rcx,	[rbp + cc_parse.readterm.d]
    call      cc_lib.createname
    mov       rdi,	rax
    mov       rax,	[rbp + cc_parse.readterm.d]
    movzx     rax,	word ptr[rax+102]
    mov       rsi,	rax
    mov       [rdi+52],	eax
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rsi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jnz       L6881
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    mov       [rdi+48],	eax
    mov       rcx,	rdi
    call      cc_parse.createaddrofop
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	rsi
    movsx     rax,	word ptr[rax + r10*2]
    mov       rcx,	rax
    call      cc_lib.createrefmode
    mov       [rdi+52],	eax
    jmp       L6880
L6881:
    mov       rax,	[rbp + cc_parse.readterm.d]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	6
    jz        L6882
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    cmp       rax,	4
    jge       L6882
    mov       rcx,	rdi
    call      cc_parse.fixmemopnd
    jmp       L6880
L6882:
    mov       rax,	[rbp + cc_parse.readterm.d]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	9
    jnz       L6883
L6883:
L6880:
L6873:
    lea       rax,	[rip+cc_decls.lx]
    mov       eax,	[rax+16]
    mov       [rdi+44],	eax
    call      cc_lex.lex
    jmp       L6862
L6884:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	64
    setz      al
    movzx     eax,	al
    mov       [rbp + cc_parse.readterm.fwide],	rax
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       [rbp + cc_parse.readterm.s],	rax
    lea       rax,	[rip+cc_decls.lx]
    movsxd    rax,	dword ptr[rax+24]
    mov       [rbp + cc_parse.readterm.slength],	rax
    jmp       L6886
L6885:
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+24]
    mov       r10,	[rbp + cc_parse.readterm.slength]
    add       r10,	rax
    mov       r14,	r10
    lea       rax,	[r14+1]
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       [rbp + cc_parse.readterm.ss],	rax
    mov       rcx,	[rbp + cc_parse.readterm.ss]
    mov       rdx,	[rbp + cc_parse.readterm.s]
    mov       r8,	[rbp + cc_parse.readterm.slength]
    call      memcpy
    lea       rax,	[rip+cc_decls.nextlx]
    movsxd    rax,	dword ptr[rax+24]
    lea       r10,	[rip+cc_decls.nextlx]
    mov       r10,	[r10]
    mov       r11,	[rbp + cc_parse.readterm.ss]
    mov       r15,	[rbp + cc_parse.readterm.slength]
    lea       r11,	[r11 + r15]
    mov       rcx,	r11
    mov       rdx,	r10
    mov       r8,	rax
    call      memcpy
    xor       eax,	eax
    mov       r10,	[rbp + cc_parse.readterm.ss]
    mov       r11,	r14
    mov       [r10 + r11],	al
    mov       rax,	[rbp + cc_parse.readterm.ss]
    mov       [rbp + cc_parse.readterm.s],	rax
    mov       [rbp + cc_parse.readterm.slength],	r14
    call      cc_lex.lex
L6886:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	63
    jz        L6885
    mov       rax,	[rbp + cc_parse.readterm.fwide]
    test      rax,	rax
    jz        L6889
    mov       rcx,	[rbp + cc_parse.readterm.s]
    mov       rdx,	[rbp + cc_parse.readterm.slength]
    call      cc_lib.createwstringconstunit
    mov       rdi,	rax
    mov       eax,	[rbp + cc_parse.readterm.slength]
    mov       [rdi+48],	eax
    mov       eax,	[rip+cc_decls.trefwchar]
    mov       [rdi+52],	eax
    jmp       L6888
L6889:
    mov       rcx,	[rbp + cc_parse.readterm.s]
    mov       rdx,	[rbp + cc_parse.readterm.slength]
    call      cc_lib.createstringconstunit
    mov       rdi,	rax
    mov       eax,	[rbp + cc_parse.readterm.slength]
    mov       [rdi+48],	eax
    mov       eax,	[rip+cc_decls.trefchar]
    mov       [rdi+52],	eax
L6888:
    call      cc_lex.lex
    jmp       L6862
L6890:
    xor       eax,	eax
    mov       [rbp + cc_parse.readterm.a],	rax
    xor       r13,	r13
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       [rbp + cc_parse.readterm.pbyte],	rax
    lea       rax,	[rip+cc_decls.lx]
    movsxd    rax,	dword ptr[rax+24]
    cmp       rax,	8
    jle       L6892
    lea       rcx,	[rip+L11256]
    call      cc_support.serror
L6892:
    lea       rax,	[rip+cc_decls.lx]
    movsxd    rax,	dword ptr[rax+24]
    mov       [rbp + cc_parse.readterm.av_1],	rax
    mov       rax,	[rbp + cc_parse.readterm.av_1]
    cmp       rax,	0
    jle       L6895
L6893:
    mov       rax,	[rbp + cc_parse.readterm.pbyte]
    movzx     rax,	byte ptr[rax]
    mov       cl,	r13b
    shl       rax,	cl
    mov       r10,	[rbp + cc_parse.readterm.a]
    or        r10,	rax
    mov       [rbp + cc_parse.readterm.a],	r10
    mov       rax,	8
    add       r13,	rax
    inc       qword ptr[rbp + cc_parse.readterm.pbyte]
    dec       qword ptr[rbp + cc_parse.readterm.av_1]
    jnz       L6893
L6895:
    lea       rax,	[rip+cc_decls.lx]
    movsxd    rax,	dword ptr[rax+24]
    cmp       rax,	4
    jg        L6897
    mov       rax,	3
    jmp       L6896
L6897:
    mov       rax,	4
L6896:
    mov       rcx,	[rbp + cc_parse.readterm.a]
    mov       rdx,	rax
    call      cc_lib.createconstunit
    mov       rdi,	rax
    call      cc_lex.lex
    jmp       L6862
L6898:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       rdi,	rax
    jmp       L6862
L6899:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       rcx,	rax
    call      cc_parse.createnegop
    mov       rdi,	rax
    jmp       L6862
L6900:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       rdi,	rax
    mov       rcx,	rdi
    call      cc_parse.coercecond
    mov       rcx,	26
    mov       rdx,	rdi
    call      cc_lib.createunit1
    mov       rdi,	rax
    mov       eax,	3
    mov       [rdi+52],	eax
    mov       rax,	[rdi+16]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	26
    jnz       L6902
    mov       rax,	[rdi+16]
    mov       rax,	[rax+16]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	26
    jnz       L6902
    mov       rax,	[rdi+16]
    mov       rax,	[rax+16]
    mov       rax,	[rax+16]
    mov       [rdi+16],	rax
L6902:
    jmp       L6862
L6903:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       rcx,	rax
    call      cc_parse.createinotop
    mov       rdi,	rax
    jmp       L6862
L6904:
    call      cc_lex.lex
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	25
    jnz       L6906
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       rdi,	rax
    jmp       L6905
L6906:
    call      cc_parse.readterm
    mov       rcx,	rax
    call      cc_parse.createaddrofop
    mov       rdi,	rax
L6905:
    jmp       L6862
L6907:
    lea       rcx,	[rip+L11257]
    call      cc_support.serror
    jmp       L6862
L6908:
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       rcx,	rax
    call      cc_parse.createptrop
    mov       rdi,	rax
    jmp       L6862
L6909:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    lea       r10,	[rip+cc_tables.symboltojtag]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       r12,	r10
    call      cc_lex.lex
    call      cc_parse.readterm
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_parse.createincrop
    mov       rdi,	rax
    jmp       L6862
L6910:
    call      cc_lex.lex
    mov       rcx,	13
    call      cc_lib.skipsymbol
    call      cc_parse.readexpression
    mov       rcx,	rax
    call      cc_parse.createabsop
    mov       rdi,	rax
    mov       rcx,	14
    call      cc_lib.skipsymbol
    jmp       L6862
L6911:
    call      cc_lex.lex
    call      cc_parse.istypestarter
    test      rax,	rax
    jz        L6913
    sub       rsp,	8
    push      0
    lea       rcx,	[rbp + cc_parse.readterm.d]
    xor       edx,	edx
    lea       r8,	[rbp + cc_parse.readterm.pm]
    xor       r9d,	r9d
    sub       rsp,	32
    call      cc_parse.readcasttype
    add       rsp,	48
    mov       rsi,	rax
    mov       rcx,	14
    call      cc_lib.skipsymbol
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	17
    jnz       L6915
    lea       rcx,	[rip+L11258]
    call      cc_support.serror
    jmp       L6914
L6915:
    call      cc_parse.readterm
    mov       rcx,	rax
    mov       rdx,	rsi
    mov       r8,	1
    xor       r9d,	r9d
    call      cc_parse.docast
    mov       rdi,	rax
L6914:
    jmp       L6912
L6913:
    call      cc_parse.readexpression
    mov       rdi,	rax
    mov       rcx,	14
    call      cc_lib.skipsymbol
L6912:
    jmp       L6862
L6916:
    lea       rax,	[rip+cc_decls.lx]
    mov       al,	[rax+22]
    test      al,	al
    jz        L6918
    call      cc_lex.lex
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	13
    jnz       L6920
    call      cc_lex.lex
    call      cc_parse.istypestarter
    test      rax,	rax
    jz        L6922
    sub       rsp,	8
    push      0
    lea       rcx,	[rbp + cc_parse.readterm.d]
    xor       edx,	edx
    lea       r8,	[rbp + cc_parse.readterm.pm]
    xor       r9d,	r9d
    sub       rsp,	32
    call      cc_parse.readcasttype
    add       rsp,	48
    mov       rsi,	rax
    mov       rcx,	14
    call      cc_lib.skipsymbol
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    mov       rdx,	9
    call      cc_lib.createconstunit
    mov       rdi,	rax
    jmp       L6921
L6922:
    call      cc_parse.readexpression
    mov       rdi,	rax
    mov       rcx,	14
    call      cc_lib.skipsymbol
    mov       rcx,	rdi
    mov       rdx,	1
    call      cc_parse.createsizeofop
    mov       rdi,	rax
L6921:
    jmp       L6919
L6920:
    call      cc_parse.readterm
    mov       rcx,	rax
    mov       rdx,	1
    call      cc_parse.createsizeofop
    mov       rdi,	rax
L6919:
    jmp       L6917
L6918:
    call      cc_lex.lex
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	13
    jnz       L6924
    call      cc_parse.istypestarter_next
    test      rax,	rax
    jz        L6926
    call      cc_lex.lex
    sub       rsp,	8
    push      0
    lea       rcx,	[rbp + cc_parse.readterm.d]
    xor       edx,	edx
    lea       r8,	[rbp + cc_parse.readterm.pm]
    xor       r9d,	r9d
    sub       rsp,	32
    call      cc_parse.readcasttype
    add       rsp,	48
    mov       rsi,	rax
    mov       rcx,	14
    call      cc_lib.skipsymbol
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    mov       rdx,	9
    call      cc_lib.createconstunit
    mov       rdi,	rax
    jmp       L6925
L6926:
    call      cc_parse.readterm
    mov       rdi,	rax
    mov       rcx,	rdi
    xor       edx,	edx
    call      cc_parse.createsizeofop
    mov       rdi,	rax
L6925:
    jmp       L6923
L6924:
    call      cc_parse.readterm
    mov       rcx,	rax
    xor       edx,	edx
    call      cc_parse.createsizeofop
    mov       rdi,	rax
L6923:
L6917:
    jmp       L6862
L6927:
    call      cc_parse.readgeneric
    mov       rdi,	rax
    jmp       L6862
L6928:
    lea       rcx,	[rip+L11259]
    call      cc_support.serror
    jmp       L6862
L6929:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+22]
    mov       [rbp + cc_parse.readterm.tag],	rax
    call      cc_lex.lex
    mov       rcx,	13
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       rdi,	rax
    mov       rax,	[rbp + cc_parse.readterm.tag]
    cmp       rax,	76
    jnz       L6931
    mov       rcx,	8
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       rbx,	rax
    jmp       L6930
L6931:
    xor       rbx,	rbx
L6930:
    mov       rcx,	[rbp + cc_parse.readterm.tag]
    mov       rdx,	rdi
    mov       r8,	rbx
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       eax,	3
    mov       [rdi+52],	eax
    mov       rcx,	14
    call      cc_lib.checksymbol
    call      cc_lex.lex
    jmp       L6862
L6864:
    lea       rcx,	[rip+L11260]
    call      cc_lex.ps
    lea       rcx,	[rip+L11261]
    call      cc_support.serror
L6862:
L6932:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    sub       rax,	2
    cmp       rax,	37
    jae       L6935
    lea       r10,	[rip+L6934]
    jmp       [r10 + rax*8]
    .data
L6934:
    .quad     L6937
    .quad     L6937
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6938
    .quad     L6935
    .quad     L6936
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6935
    .quad     L6941
    .quad     L6942
    .text
L6936:
    call      cc_lex.lex
    call      cc_parse.readexpression
    mov       rbx,	rax
    mov       rcx,	16
    call      cc_lib.skipsymbol
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      cc_parse.createindexop
    mov       rdi,	rax
    jmp       L6932
L6937:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    lea       r10,	[rip+cc_tables.symboltojtag]
    movzx     r10,	byte ptr[r10 + rax-1]
    mov       r12,	r10
    call      cc_lex.lex
    mov       rcx,	67
    call      cc_lib.checksymbol
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       [rbp + cc_parse.readterm.d],	rax
    call      cc_lex.lex
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	[rbp + cc_parse.readterm.d]
    call      cc_parse.createdotop
    mov       rdi,	rax
    jmp       L6932
L6938:
    call      cc_lex.lex
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	14
    jnz       L6940
    xor       rbx,	rbx
    call      cc_lex.lex
    jmp       L6939
L6940:
    xor       ecx,	ecx
    call      cc_parse.readexprlist
    mov       rbx,	rax
    mov       rcx,	14
    call      cc_lib.skipsymbol
L6939:
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      cc_parse.createcall
    mov       rdi,	rax
    jmp       L6932
L6941:
    call      cc_lex.lex
    mov       rcx,	73
    mov       rdx,	rdi
    call      cc_parse.createincrop
    mov       rdi,	rax
    jmp       L6932
L6942:
    call      cc_lex.lex
    mov       rcx,	74
    mov       rdx,	rdi
    call      cc_parse.createincrop
    mov       rdi,	rax
    jmp       L6932
L6935:
    jmp       L6933
L6933:
    mov       rax,	rdi
L6861:
#---------------
    add       rsp,	120
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readexprlist
cc_parse.readexprlist:
#PROC1
#PROC2
#?>>
    .set cc_parse.readexprlist.ulist, -8
    .set cc_parse.readexprlist.ulistx, -16
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	rdi
    mov       [rbp + cc_parse.readexprlist.ulistx],	rax
    mov       [rbp + cc_parse.readexprlist.ulist],	rax
L6944:
    call      cc_parse.readassignexpr
    mov       rdi,	rax
    lea       rcx,	[rbp + cc_parse.readexprlist.ulist]
    lea       rdx,	[rbp + cc_parse.readexprlist.ulistx]
    mov       r8,	rdi
    call      cc_lib.addlistunit
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jnz       L6945
L6947:
    call      cc_lex.lex
    jmp       L6944
L6945:
    mov       rax,	[rbp + cc_parse.readexprlist.ulist]
L6943:
#---------------
    add       rsp,	56
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc cc_parse.readmodulevar
cc_parse.readmodulevar:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+cc_decls.stmodule]
    mov       rdx,	r12
    mov       r8,	1
    xor       r9d,	r9d
    call      cc_lib.checkdupl
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L6950
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	7
    jz        L6952
    movzx     rax,	byte ptr[rdi+109]
    lea       r10,	[rip+cc_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rax,	[rdi]
    lea       rcx,	[rip+L11262]
    mov       rdx,	rax
    mov       r8,	r10
    call      cc_support.serror_ss
L6952:
    movzx     rax,	word ptr[rdi+102]
    mov       rsi,	rax
    cmp       rsi,	r13
    jz        L6954
    mov       rcx,	rsi
    mov       rdx,	r13
    call      cc_parse.comparemode
    test      rax,	rax
    jnz       L6956
#cc_parse.readmodulevar.redef:
L6957:
    mov       rax,	[rdi]
    lea       rcx,	[rip+L11263]
    mov       rdx,	rax
    call      cc_support.serror_s
L6956:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rsi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jnz       L6960
L6959:
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jnz       L6962
    mov       [rdi+102],	r13w
    jmp       L6961
L6962:
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	r13
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L6963
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    lea       r10,	[rip+cc_decls.ttlength]
    mov       r11,	r13
    mov       r10,	[r10 + r11*8]
    cmp       rax,	r10
    jnz       L6957
L6963:
L6961:
L6960:
L6958:
L6954:
    mov       r12,	rdi
    movzx     rax,	byte ptr[r12+110]
    mov       rbx,	rax
    cmp       rbx,	2
    jnz       L6967
    test      r14,	r14
    jz        L6966
L6967:
    cmp       rbx,	4
    jnz       L6968
    cmp       r14,	1
    jz        L6966
L6968:
    cmp       rbx,	3
    jnz       L6965
    cmp       r14,	1
    jnz       L6965
L6966:
    jmp       L6964
L6965:
    cmp       rbx,	3
    jnz       L6969
    test      r14,	r14
    jnz       L6969
    mov       rbx,	4
L6969:
L6964:
    jmp       L6949
L6950:
    mov       rcx,	[rip+cc_decls.stmodule]
    mov       rdx,	r12
    mov       r8,	7
    call      cc_lib.createdupldef
    mov       r12,	rax
    mov       [r12+102],	r13w
    mov       rax,	r14
    cmp       rax,	1
    jz        L6971
    cmp       rax,	4
    jz        L6972
    jmp       L6973
L6971:
    mov       rbx,	2
    jmp       L6970
L6972:
    mov       rbx,	3
    jmp       L6970
L6973:
    mov       rbx,	4
L6970:
L6949:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	11
    jnz       L6975
    mov       rax,	[r12+72]
    test      rax,	rax
    jz        L6977
    mov       rax,	[r12]
    lea       rcx,	[rip+L11264]
    mov       rdx,	rax
    call      cc_support.serror_s
L6977:
    cmp       rbx,	3
    jnz       L6979
    mov       rax,	[r12]
    lea       rcx,	[rip+L11265]
    mov       rdx,	rax
    call      cc_support.serror_s
L6979:
    call      cc_lex.lex
    movzx     rax,	word ptr[r12+102]
    mov       rcx,	[rip+cc_decls.stmodule]
    mov       rdx,	rax
    call      cc_parse.readinitexpr
    mov       [r12+72],	rax
L6975:
    mov       [r12+110],	bl
    mov       rax,	r12
L6948:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readframevar
cc_parse.readframevar:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+cc_decls.currproc]
    mov       rdx,	r12
    mov       r8,	1
    mov       r9,	[rip+cc_decls.currblockno]
    call      cc_lib.checkdupl_inproc
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L6982
    mov       rax,	[rdi]
    lea       rcx,	[rip+L11266]
    mov       rdx,	rax
    call      cc_support.serror_s
    mov       r12,	rdi
    movzx     rax,	byte ptr[r12+110]
    mov       rbx,	rax
    cmp       rbx,	2
    jnz       L6986
    test      r14,	r14
    jz        L6985
L6986:
    cmp       rbx,	4
    jnz       L6987
    cmp       r14,	1
    jz        L6985
L6987:
    cmp       rbx,	3
    jnz       L6984
    cmp       r14,	1
    jnz       L6984
L6985:
    jmp       L6983
L6984:
    cmp       rbx,	3
    jnz       L6988
    test      r14,	r14
    jnz       L6988
    mov       rbx,	4
L6988:
L6983:
    jmp       L6981
L6982:
    mov       rsi,	8
    mov       rbx,	1
    mov       rax,	r14
    cmp       rax,	1
    jz        L6990
    cmp       rax,	4
    jz        L6991
    jmp       L6992
L6990:
    mov       rsi,	7
    jmp       L6989
L6991:
    mov       rbx,	3
    mov       rsi,	7
L6992:
L6989:
    mov       rcx,	[rip+cc_decls.currproc]
    mov       rdx,	r12
    mov       r8,	rsi
    call      cc_lib.createdupldef
    mov       r12,	rax
    mov       [r12+102],	r13w
    mov       ax,	[rip+cc_decls.currblockno]
    mov       [r12+96],	ax
    mov       eax,	1
    lea       r10,	[rip+cc_decls.blockcounts]
    mov       r11,	[rip+cc_decls.currblockno]
    mov       [r10 + r11*4],	eax
L6981:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	11
    jnz       L6994
    mov       rax,	[r12+72]
    test      rax,	rax
    jz        L6996
    mov       rax,	[r12]
    lea       rcx,	[rip+L11267]
    mov       rdx,	rax
    call      cc_support.serror_s
L6996:
    cmp       rbx,	3
    jnz       L6998
    mov       rax,	[r12]
    lea       rcx,	[rip+L11268]
    mov       rdx,	rax
    call      cc_support.serror_s
L6998:
    call      cc_lex.lex
    movzx     rax,	word ptr[r12+102]
    mov       rcx,	[rip+cc_decls.currproc]
    mov       rdx,	rax
    call      cc_parse.readinitexpr
    mov       [r12+72],	rax
L6994:
    mov       [r12+110],	bl
    mov       rax,	r12
L6980:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readtype
cc_parse.readtype:
#PROC1
#PROC2
#?>>
    .set cc_parse.readtype.modtype, -256
    .set cc_parse.readtype.modvalue, -512
    .set cc_parse.readtype.nmodifiers, -520
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	560
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rbp + cc_parse.readtype.nmodifiers],	rax
    xor       eax,	eax
    mov       [r14],	rax
    sub       rsp,	8
    lea       rax,	[rbp + cc_parse.readtype.nmodifiers]
    push      rax
    mov       rcx,	rsi
    mov       rdx,	r12
    lea       r8,	[rbp + cc_parse.readtype.modtype]
    lea       r9,	[rbp + cc_parse.readtype.modvalue]
    sub       rsp,	32
    call      cc_parse.readnamedtype
    add       rsp,	48
    mov       rbx,	[rbp + cc_parse.readtype.nmodifiers]
    cmp       rbx,	1
    jl        L7002
L7000:
    mov       rax,	[rbp + rbx*8 + cc_parse.readtype.modtype-8]
    cmp       rax,	65
    jz        L7004
    cmp       rax,	82
    jz        L7005
    cmp       rax,	67
    jz        L7006
    cmp       rax,	70
    jz        L7007
    jmp       L7008
L7004:
    mov       rax,	[rbp + rbx*8 + cc_parse.readtype.modvalue-8]
    mov       rcx,	r13
    mov       rdx,	rax
    call      cc_lib.createarraymode
    mov       r13,	rax
    jmp       L7003
L7005:
    mov       rcx,	r13
    call      cc_lib.createrefmode
    mov       r13,	rax
    jmp       L7003
L7006:
    mov       rcx,	r13
    call      cc_lib.createconstmode
    mov       r13,	rax
    jmp       L7003
L7007:
    mov       rdi,	[rbp + rbx*8 + cc_parse.readtype.modvalue-8]
    cmp       rbx,	1
    jnz       L7010
    mov       [r14],	rdi
    jmp       L7009
L7010:
    mov       rcx,	r13
    mov       rdx,	rdi
    call      cc_lib.createprocmode
    mov       r13,	rax
L7009:
L7008:
L7003:
    dec       rbx
    cmp       rbx,	1
    jge       L7000
L7002:
    mov       rax,	r13
L6999:
#---------------
    add       rsp,	560
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readnamedtype
cc_parse.readnamedtype:
#PROC1
#PROC2
#?>>
    .set cc_parse.readnamedtype.modvalue, 88
    .set cc_parse.readnamedtype.nmodifiers, 96
    .set cc_parse.readnamedtype.fconst, -256
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [r13],	rax
    xor       rbx,	rbx
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	88
    jnz       L7013
    call      cc_lex.lex
L7013:
    jmp       L7015
L7014:
    inc       rbx
    xor       eax,	eax
    mov       [rbp + rbx*8 + cc_parse.readnamedtype.fconst-8],	rax
    call      cc_lex.lex
    jmp       L7018
L7017:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+22]
    cmp       rax,	1
    jz        L7021
    cmp       rax,	2
    jz        L7022
    cmp       rax,	3
    jz        L7022
    jmp       L7023
L7021:
    mov       rax,	1
    mov       [rbp + rbx*8 + cc_parse.readnamedtype.fconst-8],	rax
    jmp       L7020
L7022:
    jmp       L7020
L7023:
    lea       rcx,	[rip+L11269]
    call      cc_support.serror
L7020:
    call      cc_lex.lex
L7018:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	86
    jz        L7017
L7015:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	25
    jz        L7014
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L7025
    cmp       rax,	13
    jz        L7026
    jmp       L7027
L7025:
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       [r13],	rax
    call      cc_lex.lex
    jmp       L7024
L7026:
    call      cc_lex.lex
    sub       rsp,	8
    push      qword ptr[rbp + cc_parse.readnamedtype.nmodifiers]
    mov       rcx,	r12
    mov       rdx,	r13
    mov       r8,	r14
    mov       r9,	[rbp + cc_parse.readnamedtype.modvalue]
    sub       rsp,	32
    call      cc_parse.readnamedtype
    add       rsp,	48
    mov       rcx,	14
    call      cc_lib.skipsymbol
L7027:
L7024:
L7028:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	15
    jz        L7030
    cmp       rax,	13
    jz        L7031
    jmp       L7032
L7030:
    call      cc_lex.lex
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	16
    jnz       L7034
    xor       rdi,	rdi
    jmp       L7033
L7034:
    call      cc_parse.readassignexpr
    mov       rsi,	rax
    movsxd    rax,	dword ptr[rsi+40]
    cmp       rax,	1
    jnz       L7036
    mov       rdi,	[rsi]
    jmp       L7035
L7036:
    lea       rcx,	[rip+L11270]
    call      cc_support.serror
L7035:
    mov       rcx,	16
    call      cc_lib.checksymbol
    test      rdi,	rdi
    jnz       L7038
    lea       rcx,	[rip+L11271]
    call      cc_support.serror
L7038:
L7033:
    cmp       rdi,	0
    jge       L7040
    lea       rcx,	[rip+L11272]
    call      cc_support.terror
L7040:
    call      cc_lex.lex
    mov       rax,	[rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[rax]
    mov       rax,	[rax]
    mov       r10,	65
    mov       [r14 + rax*8-8],	r10
    mov       rax,	[rbp + cc_parse.readnamedtype.nmodifiers]
    mov       rax,	[rax]
    mov       r10,	rdi
    mov       r11,	[rbp + cc_parse.readnamedtype.modvalue]
    mov       [r11 + rax*8-8],	r10
    jmp       L7028
L7031:
    call      cc_lex.lex
    mov       rax,	[rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[rax]
    mov       rax,	[rax]
    mov       r10,	70
    mov       [r14 + rax*8-8],	r10
    mov       rcx,	r12
    call      cc_parse.readparams
    mov       r10,	[rbp + cc_parse.readnamedtype.nmodifiers]
    mov       r10,	[r10]
    mov       r11,	[rbp + cc_parse.readnamedtype.modvalue]
    mov       [r11 + r10*8-8],	rax
    jmp       L7028
L7032:
    jmp       L7029
L7029:
    jmp       L7042
L7041:
    mov       rax,	[rbp + rbx*8 + cc_parse.readnamedtype.fconst-8]
    test      rax,	rax
    jz        L7045
    mov       rax,	[rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[rax]
    mov       rax,	[rax]
    mov       r10,	67
    mov       [r14 + rax*8-8],	r10
L7045:
    mov       rax,	[rbp + cc_parse.readnamedtype.nmodifiers]
    inc       qword ptr[rax]
    mov       rax,	[rax]
    mov       r10,	82
    mov       [r14 + rax*8-8],	r10
    dec       rbx
L7042:
    test      rbx,	rbx
    jnz       L7041
#---------------
    add       rsp,	288
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readconstintexpr
cc_parse.readconstintexpr:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_parse.readassignexpr
    mov       rdi,	rax
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	1
    jnz       L7049
L7048:
    mov       rax,	[rdi]
    jmp       L7046
L7049:
    movsxd    rax,	dword ptr[rdi+40]
    lea       r10,	[rip+cc_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rip+L11273]
    mov       rdx,	r10
    call      cc_support.serror_s
L7047:
    xor       eax,	eax
L7046:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_parse.readinitexpr
cc_parse.readinitexpr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	1
    call      cc_parse.readinitexpr2
    mov       rdi,	rax
    mov       rax,	rdi
L7050:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readinitexpr2
cc_parse.readinitexpr2:
#PROC1
#PROC2
#?>>
    .set cc_parse.readinitexpr2.m, 80
    .set cc_parse.readinitexpr2.istop, 88
    .set cc_parse.readinitexpr2.ulist, -8
    .set cc_parse.readinitexpr2.ulistx, -16
    .set cc_parse.readinitexpr2.d, -24
    .set cc_parse.readinitexpr2.e, -32
    .set cc_parse.readinitexpr2.braces, -40
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	72
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	[rbp + cc_parse.readinitexpr2.m]
    movsx     rax,	word ptr[rax + r10*2]
    mov       rbx,	rax
    xor       r14,	r14
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	17
    jnz       L7053
    call      cc_lex.lex
    xor       r14,	r14
    mov       rax,	rbx
    cmp       rax,	17
    jz        L7055
    cmp       rax,	18
    jz        L7056
    cmp       rax,	19
    jz        L7056
    jmp       L7057
L7055:
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	[rbp + cc_parse.readinitexpr2.m]
    mov       r13,	[rax + r10*8]
    mov       rax,	[rbp + cc_parse.readinitexpr2.istop]
    test      rax,	rax
    jnz       L7059
    test      r13,	r13
    jnz       L7059
    lea       rcx,	[rip+L11274]
    call      cc_support.terror
L7059:
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	[rbp + cc_parse.readinitexpr2.m]
    movsx     rax,	word ptr[rax + r10*2]
    mov       rsi,	rax
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rsi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	1
    jnz       L7061
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	63
    jnz       L7061
    mov       rax,	1
    mov       [rbp + cc_parse.readinitexpr2.braces],	rax
    jmp       L7062
L7061:
    jmp       L7054
L7056:
    lea       rax,	[rip+cc_decls.ttnamedef]
    mov       r10,	[rbp + cc_parse.readinitexpr2.m]
    mov       rax,	[rax + r10*8]
    mov       [rbp + cc_parse.readinitexpr2.d],	rax
    mov       rax,	[rbp + cc_parse.readinitexpr2.d]
    mov       rax,	[rax+16]
    mov       [rbp + cc_parse.readinitexpr2.e],	rax
    mov       rax,	[rbp + cc_parse.readinitexpr2.e]
    test      rax,	rax
    jnz       L7064
    lea       rcx,	[rip+L11275]
    call      cc_support.terror
L7064:
    mov       rax,	[rbp + cc_parse.readinitexpr2.e]
    movzx     rax,	word ptr[rax+102]
    mov       rsi,	rax
    jmp       L7054
L7057:
    call      cc_parse.readassignexpr
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	[rbp + cc_parse.readinitexpr2.m]
    call      cc_parse.coercemode
    mov       rdi,	rax
    mov       rcx,	18
    call      cc_lib.skipsymbol
    mov       rax,	rdi
    jmp       L7051
L7054:
    xor       eax,	eax
    mov       [rbp + cc_parse.readinitexpr2.ulistx],	rax
    mov       [rbp + cc_parse.readinitexpr2.ulist],	rax
L7065:
    mov       rcx,	r15
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      cc_parse.readinitexpr2
    mov       rdi,	rax
    inc       r14
    mov       rax,	rbx
    cmp       rax,	17
    jz        L7068
    cmp       rax,	18
    jz        L7069
    cmp       rax,	19
    jz        L7070
    jmp       L7071
L7068:
    test      r13,	r13
    jz        L7073
    cmp       r14,	r13
    jle       L7073
    lea       rcx,	[rip+L11276]
    call      cc_support.terror
L7073:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rsi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jnz       L7075
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	rsi
    movsx     rax,	word ptr[rax + r10*2]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    cmp       r10,	1
    jnz       L7075
    movsxd    rax,	dword ptr[rdi+52]
    cmp       rax,	[rip+cc_decls.trefchar]
    jz        L7074
L7075:
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      cc_parse.coercemode
    mov       rdi,	rax
L7074:
    jmp       L7067
L7069:
    mov       rax,	[rbp + cc_parse.readinitexpr2.e]
    movzx     rax,	word ptr[rax+102]
    mov       r12,	rax
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	r12
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jnz       L7077
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	r12
    movsx     rax,	word ptr[rax + r10*2]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    cmp       r10,	6
    jnz       L7077
    movsxd    rax,	dword ptr[rdi+52]
    cmp       rax,	[rip+cc_decls.trefchar]
    jz        L7076
L7077:
    mov       rcx,	rdi
    mov       rdx,	r12
    call      cc_parse.coercemode
    mov       rdi,	rax
L7076:
    mov       rax,	[rbp + cc_parse.readinitexpr2.e]
    mov       rax,	[rax+32]
    mov       [rbp + cc_parse.readinitexpr2.e],	rax
    mov       rax,	[rbp + cc_parse.readinitexpr2.e]
    test      rax,	rax
    jnz       L7079
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jnz       L7081
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	18
    jz        L7081
    lea       rcx,	[rip+L11277]
    call      cc_support.terror
L7081:
    jmp       L7078
L7079:
    mov       rax,	[rbp + cc_parse.readinitexpr2.e]
    movzx     rax,	word ptr[rax+102]
    mov       rsi,	rax
L7078:
    jmp       L7067
L7070:
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      cc_parse.coercemode
    mov       rdi,	rax
    mov       rax,	rdi
    mov       [rbp + cc_parse.readinitexpr2.ulistx],	rax
    mov       [rbp + cc_parse.readinitexpr2.ulist],	rax
    jmp       L7082
L7071:
L7067:
    lea       rcx,	[rbp + cc_parse.readinitexpr2.ulist]
    lea       rdx,	[rbp + cc_parse.readinitexpr2.ulistx]
    mov       r8,	rdi
    call      cc_lib.addlistunit
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jnz       L7066
L7084:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	18
    jnz       L7086
    call      cc_lex.lex
    jmp       L7066
L7086:
    call      cc_lex.lex
    jmp       L7065
L7066:
    cmp       rbx,	17
    jnz       L7088
    test      r13,	r13
    jnz       L7088
    mov       rax,	r14
    lea       r10,	[rip+cc_decls.ttlength]
    mov       r11,	[rbp + cc_parse.readinitexpr2.m]
    mov       [r10 + r11*8],	rax
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    mov       r10,	r14
    imul      r10,	rax
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r11,	[rbp + cc_parse.readinitexpr2.m]
    mov       [rax + r11*8],	r10
L7088:
#cc_parse.readinitexpr2.donestruct:
L7082:
    mov       rcx,	18
    call      cc_lib.skipsymbol
    mov       rcx,	28
    mov       rdx,	[rbp + cc_parse.readinitexpr2.ulist]
    call      cc_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+48],	r14d
    mov       eax,	[rbp + cc_parse.readinitexpr2.m]
    mov       [rdi+52],	eax
    jmp       L7052
L7053:
    xor       eax,	eax
    mov       [rbp + cc_parse.readinitexpr2.braces],	rax
    cmp       rbx,	17
    jnz       L7091
L7090:
#cc_parse.readinitexpr2.doarraystring:
L7062:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	63
    jz        L7093
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	64
    jz        L7093
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	[rbp + cc_parse.readinitexpr2.m]
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	1
    jz        L7093
    lea       rcx,	[rip+L11278]
    call      cc_support.terror
L7093:
    call      cc_parse.readassignexpr
    mov       rdi,	rax
    movsxd    rax,	dword ptr[rdi+52]
    cmp       rax,	[rip+cc_decls.trefchar]
    jz        L7095
    cmp       rax,	[rip+cc_decls.trefwchar]
    jz        L7096
    jmp       L7097
L7095:
    jmp       L7094
L7096:
    jmp       L7094
L7097:
    lea       rcx,	[rip+L11279]
    call      cc_support.terror
L7094:
    mov       eax,	[rbp + cc_parse.readinitexpr2.m]
    mov       [rdi+52],	eax
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	[rbp + cc_parse.readinitexpr2.m]
    mov       rax,	[rax + r10*8]
    mov       r13,	rax
    test      rax,	rax
    jnz       L7099
    movsxd    rax,	dword ptr[rdi+48]
    inc       rax
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r11,	[rbp + cc_parse.readinitexpr2.m]
    mov       [r10 + r11*8],	rax
    lea       r10,	[rip+cc_decls.ttlength]
    mov       r11,	[rbp + cc_parse.readinitexpr2.m]
    mov       [r10 + r11*8],	rax
    jmp       L7098
L7099:
    movsxd    rax,	dword ptr[rdi+48]
    cmp       rax,	r13
    jle       L7101
    lea       rcx,	[rip+L11280]
    call      cc_support.terror
L7101:
L7098:
    mov       rax,	[rbp + cc_parse.readinitexpr2.braces]
    test      rax,	rax
    jz        L7103
    mov       rcx,	18
    call      cc_lib.skipsymbol
L7103:
    mov       rax,	rdi
    jmp       L7051
L7091:
L7089:
    call      cc_parse.readassignexpr
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	[rbp + cc_parse.readinitexpr2.m]
    call      cc_parse.coercemode
    mov       rdi,	rax
L7052:
    mov       rax,	rdi
L7051:
#---------------
    add       rsp,	72
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.pushblock
cc_parse.pushblock:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_decls.blocklevel]
    cmp       rax,	100
    jl        L7106
    lea       rcx,	[rip+L11281]
    call      cc_support.serror
L7106:
    mov       rax,	[rip+cc_decls.nextblockno]
    cmp       rax,	2100
    jl        L7108
    lea       rcx,	[rip+L11282]
    call      cc_support.serror
L7108:
    inc       qword ptr[rip+cc_decls.blocklevel]
    inc       qword ptr[rip+cc_decls.nextblockno]
    mov       rdi,	[rip+cc_decls.currblockno]
    mov       rbx,	[rip+cc_decls.blocklevel]
    jmp       L7110
L7109:
    dec       rbx
    lea       rax,	[rip+cc_decls.blockstack]
    mov       r10,	rbx
    movsxd    rax,	dword ptr[rax + r10*4]
    mov       rdi,	rax
L7110:
    test      rbx,	rbx
    jz        L7112
    lea       rax,	[rip+cc_decls.blockstack]
    mov       r10,	rbx
    movsxd    rax,	dword ptr[rax + r10*4]
    lea       r10,	[rip+cc_decls.blockcounts]
    movsxd    r10,	dword ptr[r10 + rax*4]
    test      r10,	r10
    jz        L7109
L7112:
    mov       eax,	edi
    lea       r10,	[rip+cc_decls.blockowner]
    mov       r11,	[rip+cc_decls.nextblockno]
    mov       [r10 + r11*4],	eax
    mov       eax,	[rip+cc_decls.nextblockno]
    lea       r10,	[rip+cc_decls.blockstack]
    mov       r11,	[rip+cc_decls.blocklevel]
    mov       [r10 + r11*4],	eax
    mov       [rip+cc_decls.currblockno],	rax
    xor       eax,	eax
    lea       r10,	[rip+cc_decls.blockcounts]
    mov       r11,	[rip+cc_decls.currblockno]
    mov       [r10 + r11*4],	eax
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.popblock
cc_parse.popblock:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    dec       qword ptr[rip+cc_decls.blocklevel]
    mov       rax,	[rip+cc_decls.blocklevel]
    lea       r10,	[rip+cc_decls.blockstack]
    movsxd    r10,	dword ptr[r10 + rax*4]
    mov       [rip+cc_decls.currblockno],	r10
#---------------
    ret       
# End 
# Proc cc_parse.readcompoundstmt
cc_parse.readcompoundstmt:
#PROC1
#PROC2
#?>>
    .set cc_parse.readcompoundstmt.ulist, -8
    .set cc_parse.readcompoundstmt.ulistx, -16
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rbp + cc_parse.readcompoundstmt.ulistx],	rax
    mov       [rbp + cc_parse.readcompoundstmt.ulist],	rax
    call      cc_lex.lex
    call      cc_parse.pushblock
    test      rsi,	rsi
    jz        L7116
    mov       eax,	1
    lea       r10,	[rip+cc_decls.blockcounts]
    mov       [r10+4],	eax
L7116:
    jmp       L7118
L7117:
    call      cc_parse.readstatement
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L7121
    jmp       L7118
L7121:
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	7
    jnz       L7123
L7124:
    mov       rbx,	[rdi+8]
    mov       rax,	[rdi]
    mov       rax,	[rax+72]
    test      rax,	rax
    jz        L7128
    mov       rax,	[rdi]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	7
    jz        L7128
    mov       eax,	8
    mov       [rdi+40],	eax
    xor       eax,	eax
    mov       [rdi+8],	rax
    lea       rcx,	[rbp + cc_parse.readcompoundstmt.ulist]
    lea       rdx,	[rbp + cc_parse.readcompoundstmt.ulistx]
    mov       r8,	rdi
    call      cc_lib.addlistunit
L7128:
    mov       rdi,	rbx
    test      rdi,	rdi
    jnz       L7124
    jmp       L7122
L7123:
    lea       rcx,	[rbp + cc_parse.readcompoundstmt.ulist]
    lea       rdx,	[rbp + cc_parse.readcompoundstmt.ulistx]
    mov       r8,	rdi
    call      cc_lib.addlistunit
L7122:
L7118:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	18
    jnz       L7117
    call      cc_lex.lex
    call      cc_parse.popblock
    mov       rcx,	6
    mov       rdx,	[rbp + cc_parse.readcompoundstmt.ulist]
    xor       r8d,	r8d
    mov       r9,	[rbp + cc_parse.readcompoundstmt.ulistx]
    call      cc_lib.createunit3
L7114:
#---------------
    add       rsp,	56
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readblock
cc_parse.readblock:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    call      cc_parse.readstatement
    jmp       L7129
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	71
    jnz       L7131
    test      rdi,	rdi
    jz        L7131
    call      cc_parse.readstatement
    jmp       L7129
L7131:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	17
    jz        L7133
    lea       rcx,	[rip+L11283]
    call      cc_support.serror
L7133:
    xor       ecx,	ecx
    call      cc_parse.readcompoundstmt
L7129:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_parse.readstatement
cc_parse.readstatement:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    sub       rax,	9
    cmp       rax,	82
    jae       L7137
    lea       r10,	[rip+L7136]
    jmp       [r10 + rax*8]
    .data
L7136:
    .quad     L7160
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7144
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7137
    .quad     L7161
    .quad     L7137
    .quad     L7137
    .quad     L7177
    .quad     L7138
    .quad     L7137
    .quad     L7158
    .quad     L7159
    .quad     L7139
    .quad     L7140
    .quad     L7141
    .quad     L7142
    .quad     L7146
    .quad     L7151
    .quad     L7145
    .quad     L7143
    .quad     L7177
    .quad     L7177
    .quad     L7177
    .quad     L7177
    .quad     L7177
    .quad     L7177
    .quad     L7137
    .quad     L7177
    .text
L7138:
    call      cc_parse.readifstmt
    jmp       L7134
L7139:
    call      cc_parse.readforstmt
    jmp       L7134
L7140:
    call      cc_parse.readwhilestmt
    jmp       L7134
L7141:
    call      cc_parse.readdostmt
    jmp       L7134
L7142:
    call      cc_parse.readreturnstmt
    jmp       L7134
L7143:
    call      cc_parse.readswitchstmt
    jmp       L7134
L7144:
    xor       ecx,	ecx
    call      cc_parse.readcompoundstmt
    jmp       L7134
L7145:
    call      cc_parse.readgotostmt
    jmp       L7134
L7146:
    mov       rax,	[rip+cc_parse.loopindex]
    test      rax,	rax
    jz        L7148
    lea       rax,	[rip+cc_parse.looptypestack]
    mov       r10,	[rip+cc_parse.loopindex]
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	76
    jnz       L7150
    mov       rcx,	20
    call      cc_lib.createunit0
    mov       rdi,	rax
    call      cc_lex.lex
    jmp       L7149
L7150:
    mov       rcx,	23
    call      cc_lib.createunit0
    mov       rdi,	rax
    call      cc_lex.lex
L7149:
    jmp       L7147
L7148:
    lea       rcx,	[rip+L11284]
    call      cc_support.serror
L7147:
    jmp       L7135
L7151:
    mov       rsi,	[rip+cc_parse.loopindex]
    jmp       L7153
L7152:
    dec       rsi
L7153:
    test      rsi,	rsi
    jz        L7155
    lea       rax,	[rip+cc_parse.looptypestack]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	76
    jnz       L7152
L7155:
    test      rsi,	rsi
    jnz       L7157
    lea       rcx,	[rip+L11285]
    call      cc_support.serror
L7157:
    mov       rcx,	21
    call      cc_lib.createunit0
    mov       rdi,	rax
    call      cc_lex.lex
    jmp       L7135
L7158:
    call      cc_parse.readcaselabel
    jmp       L7134
L7159:
    call      cc_lex.lex
    mov       rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readstatement
    mov       rcx,	19
    mov       rdx,	rax
    call      cc_lib.createunit1
    jmp       L7134
L7160:
    call      cc_lex.lex
    xor       eax,	eax
    jmp       L7134
L7161:
    lea       rax,	[rip+cc_decls.nextlx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	10
    jnz       L7163
    mov       rcx,	17
    xor       edx,	edx
    call      cc_lib.createunit1
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       rcx,	[rip+cc_decls.currproc]
    mov       rdx,	rax
    mov       r8,	3
    xor       r9d,	r9d
    call      cc_lib.resolvename
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L7165
    movsxd    rax,	dword ptr[rbx+88]
    cmp       rax,	-1
    jnz       L7167
    call      msys.m$print_startcon
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11286]
    call      cc_support.terror
L7167:
    jmp       L7164
L7165:
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       rcx,	[rip+cc_decls.currproc]
    mov       rdx,	rax
    mov       r8,	14
    call      cc_lib.createdupldef
    mov       rbx,	rax
    xor       eax,	eax
    mov       [rbx+102],	ax
L7164:
    mov       eax,	4294967295
    mov       [rbx+88],	eax
    mov       [rdi],	rbx
    call      cc_lex.lex
    call      cc_lex.lex
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	18
    jz        L7168
L7169:
    call      cc_parse.istypestarter
    test      rax,	rax
    jnz       L7171
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	85
    jnz       L7170
L7171:
    jmp       L7168
L7170:
    call      cc_parse.readstatement
    mov       [rdi+16],	rax
L7168:
    mov       rax,	rdi
    jmp       L7134
L7163:
    xor       eax,	eax
    mov       [rip+cc_parse.ist_symptr],	rax
    mov       rcx,	[rip+cc_decls.currproc]
    call      cc_parse.isusertype
    cmp       rax,	20
    jnz       L7174
L7173:
    mov       rax,	[rip+cc_parse.ist_symptr]
    test      rax,	rax
    jz        L7176
    mov       rax,	[rip+cc_parse.ist_symptr]
    lea       r10,	[rip+cc_decls.lx]
    mov       [r10],	rax
L7176:
    call      cc_parse.readexpression
    mov       rdi,	rax
L7162:
    jmp       L7135
L7177:
#cc_parse.readstatement.doreaddecl:
L7174:
    call      cc_parse.readlocaldecl
    jmp       L7134
L7137:
    call      cc_parse.readexpression
    mov       rdi,	rax
L7135:
    mov       rcx,	9
    call      cc_lib.skipsymbol
    mov       rax,	rdi
L7134:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readifstmt
cc_parse.readifstmt:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    lea       rax,	[rip+cc_decls.lx]
    mov       eax,	[rax+16]
    mov       r13,	rax
    call      cc_parse.readcond
    mov       rbx,	rax
    mov       rcx,	rbx
    call      cc_parse.coercecond
    xor       ecx,	ecx
    call      cc_parse.readblock
    mov       rsi,	rax
    xor       r12,	r12
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	72
    jnz       L7180
    call      cc_lex.lex
    mov       rcx,	1
    call      cc_parse.readblock
    mov       r12,	rax
L7180:
    mov       rcx,	12
    mov       rdx,	rbx
    mov       r8,	rsi
    mov       r9,	r12
    call      cc_lib.createunit3
    mov       rdi,	rax
    mov       [rdi+44],	r13d
    mov       rcx,	rbx
    call      cc_parse.iscondtrue
    test      rax,	rax
    jz        L7182
    test      rsi,	rsi
    jnz       L7184
    mov       rcx,	6
    call      cc_lib.createunit0
    mov       rsi,	rax
L7184:
    mov       rcx,	rdi
    mov       rdx,	rsi
    call      cc_parse.deleteunit
    jmp       L7181
L7182:
    mov       rcx,	rbx
    call      cc_parse.iscondfalse
    test      rax,	rax
    jz        L7185
    test      r12,	r12
    jnz       L7187
    mov       rcx,	6
    call      cc_lib.createunit0
    mov       r12,	rax
L7187:
    mov       rcx,	rdi
    mov       rdx,	r12
    call      cc_parse.deleteunit
L7185:
L7181:
    mov       rax,	rdi
L7178:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.iscondtrue
cc_parse.iscondtrue:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rcx+40]
    cmp       rax,	1
    jnz       L7189
    mov       rax,	[rcx]
    test      rax,	rax
    jz        L7189
    mov       rax,	1
    jmp       L7190
L7189:
    xor       eax,	eax
L7190:
L7188:
#---------------
    ret       
# End 
# Proc cc_parse.iscondfalse
cc_parse.iscondfalse:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rcx+40]
    cmp       rax,	1
    jnz       L7192
    mov       rax,	[rcx]
    test      rax,	rax
    jnz       L7192
    mov       rax,	1
    jmp       L7193
L7192:
    xor       eax,	eax
L7193:
L7191:
#---------------
    ret       
# End 
# Proc cc_parse.deleteunit
cc_parse.deleteunit:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    mov       rdi,	[rcx+8]
    mov       rax,	rdx
    push      rcx
    mov       r11,	8
L11287:
    mov       r10,	[rax]
    mov       [rcx],	r10
    add       rcx,	8
    add       rax,	8
    dec       r11
    jnz       L11287
    pop       rcx
    mov       [rcx+8],	rdi
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc cc_parse.readforstmt
cc_parse.readforstmt:
#PROC1
#PROC2
#?>>
    .set cc_parse.readforstmt.ulist, -8
    .set cc_parse.readforstmt.ulistx, -16
    .set cc_parse.readforstmt.linkage, -24
    .set cc_parse.readforstmt.m, -32
    .set cc_parse.readforstmt.mbase, -40
    .set cc_parse.readforstmt.pm, -48
    .set cc_parse.readforstmt.d, -56
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    mov       rcx,	13
    call      cc_lib.skipsymbol
    xor       r14,	r14
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	9
    jz        L7197
    call      cc_parse.istypestarter
    test      rax,	rax
    jz        L7199
    mov       r14,	1
    call      cc_parse.pushblock
    mov       rcx,	[rip+cc_decls.currproc]
    lea       rdx,	[rbp + cc_parse.readforstmt.linkage]
    call      cc_parse.readdeclspec
    mov       [rbp + cc_parse.readforstmt.mbase],	rax
    xor       eax,	eax
    mov       [rbp + cc_parse.readforstmt.ulistx],	rax
    mov       [rbp + cc_parse.readforstmt.ulist],	rax
L7200:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L7202
    cmp       rax,	25
    jz        L7202
    cmp       rax,	13
    jnz       L7203
L7202:
    mov       rcx,	[rip+cc_decls.currproc]
    lea       rdx,	[rbp + cc_parse.readforstmt.d]
    mov       r8,	[rbp + cc_parse.readforstmt.mbase]
    lea       r9,	[rbp + cc_parse.readforstmt.pm]
    call      cc_parse.readtype
    mov       [rbp + cc_parse.readforstmt.m],	rax
    mov       rax,	[rbp + cc_parse.readforstmt.d]
    test      rax,	rax
    jnz       L7205
    lea       rcx,	[rip+L11288]
    call      cc_support.serror
L7205:
    mov       rax,	[rbp + cc_parse.readforstmt.linkage]
    cmp       rax,	5
    jz        L7208
    mov       rax,	[rbp + cc_parse.readforstmt.pm]
    test      rax,	rax
    jz        L7207
L7208:
    lea       rcx,	[rip+L11289]
    call      cc_support.serror
L7207:
    mov       rcx,	[rbp + cc_parse.readforstmt.d]
    mov       rdx,	[rbp + cc_parse.readforstmt.m]
    mov       r8,	[rbp + cc_parse.readforstmt.linkage]
    call      cc_parse.readframevar
    mov       [rbp + cc_parse.readforstmt.d],	rax
    mov       rax,	[rbp + cc_parse.readforstmt.d]
    mov       rax,	[rax+72]
    test      rax,	rax
    jz        L7210
    mov       rcx,	8
    call      cc_lib.createunit0
    mov       r13,	rax
    mov       rax,	[rbp + cc_parse.readforstmt.d]
    mov       [r13],	rax
    lea       rcx,	[rbp + cc_parse.readforstmt.ulist]
    lea       rdx,	[rbp + cc_parse.readforstmt.ulistx]
    mov       r8,	r13
    call      cc_lib.addlistunit
L7210:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jnz       L7213
L7212:
    call      cc_lex.lex
    jmp       L7211
L7213:
    jmp       L7201
L7211:
    jmp       L7200
L7203:
    lea       rcx,	[rip+L11290]
    call      cc_support.serror
    jmp       L7200
L7201:
    mov       rcx,	6
    mov       rdx,	[rbp + cc_parse.readforstmt.ulist]
    xor       r8d,	r8d
    mov       r9,	[rbp + cc_parse.readforstmt.ulistx]
    call      cc_lib.createunit3
    mov       rdi,	rax
    jmp       L7198
L7199:
    call      cc_parse.readexpression
    mov       rdi,	rax
L7198:
    jmp       L7196
L7197:
    mov       rcx,	2
    call      cc_lib.createunit0
    mov       rdi,	rax
L7196:
    mov       rcx,	9
    call      cc_lib.skipsymbol
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	9
    jz        L7215
    call      cc_parse.readexpression
    mov       rbx,	rax
    mov       rcx,	rbx
    call      cc_parse.coercecond
    jmp       L7214
L7215:
    mov       rcx,	2
    call      cc_lib.createunit0
    mov       rbx,	rax
L7214:
    mov       rcx,	9
    call      cc_lib.skipsymbol
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	14
    jz        L7217
    call      cc_parse.readexprstmt
    mov       rsi,	rax
    jmp       L7216
L7217:
    xor       rsi,	rsi
L7216:
    mov       rcx,	14
    call      cc_lib.skipsymbol
    mov       rcx,	76
    call      cc_parse.pushloop
    xor       ecx,	ecx
    call      cc_parse.readblock
    mov       r12,	rax
    call      cc_parse.poploop
    test      r14,	r14
    jz        L7219
    call      cc_parse.popblock
L7219:
    mov       [rdi+8],	rbx
    mov       [rbx+8],	rsi
    mov       rcx,	13
    mov       rdx,	rdi
    mov       r8,	r12
    call      cc_lib.createunit2
L7195:
#---------------
    add       rsp,	96
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readwhilestmt
cc_parse.readwhilestmt:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    call      cc_parse.readcond
    mov       rdi,	rax
    mov       rcx,	rdi
    call      cc_parse.coercecond
    mov       rcx,	76
    call      cc_parse.pushloop
    xor       ecx,	ecx
    call      cc_parse.readblock
    mov       rbx,	rax
    call      cc_parse.poploop
    mov       rcx,	14
    mov       rdx,	rdi
    mov       r8,	rbx
    call      cc_lib.createunit2
L7220:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readdostmt
cc_parse.readdostmt:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    mov       rcx,	76
    call      cc_parse.pushloop
    xor       ecx,	ecx
    call      cc_parse.readblock
    mov       rdi,	rax
    call      cc_parse.poploop
    mov       rcx,	76
    call      cc_lib.skipsymbol
    call      cc_parse.readcond
    mov       rbx,	rax
    mov       rcx,	rbx
    call      cc_parse.coercecond
    mov       rcx,	9
    call      cc_lib.skipsymbol
    mov       rcx,	15
    mov       rdx,	rdi
    mov       r8,	rbx
    call      cc_lib.createunit2
L7221:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readreturnstmt
cc_parse.readreturnstmt:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    xor       rdi,	rdi
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	9
    jz        L7224
    mov       rax,	[rip+cc_decls.currproc]
    movzx     rax,	word ptr[rax+102]
    test      rax,	rax
    jnz       L7226
    lea       rcx,	[rip+L11291]
    call      cc_support.terror
L7226:
    call      cc_parse.readexpression
    mov       rdi,	rax
    mov       rax,	[rip+cc_decls.currproc]
    movzx     rax,	word ptr[rax+102]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      cc_parse.coercemode
    mov       rdi,	rax
    mov       rcx,	9
    call      cc_lib.checksymbol
    jmp       L7223
L7224:
    mov       rax,	[rip+cc_decls.currproc]
    movzx     rax,	word ptr[rax+102]
    test      rax,	rax
    jz        L7227
    lea       rcx,	[rip+L11292]
    call      cc_support.terror
L7227:
L7223:
    call      cc_lex.lex
    mov       rcx,	9
    mov       rdx,	rdi
    call      cc_lib.createunit1
L7222:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_parse.readgotostmt
cc_parse.readgotostmt:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    mov       rcx,	67
    call      cc_lib.checksymbol
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       rcx,	[rip+cc_decls.currproc]
    mov       rdx,	rax
    mov       r8,	3
    xor       r9d,	r9d
    call      cc_lib.resolvename
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L7230
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       rcx,	[rip+cc_decls.currproc]
    mov       rdx,	rax
    mov       r8,	14
    call      cc_lib.createdupldef
    mov       rdi,	rax
    xor       eax,	eax
    mov       [rdi+102],	ax
L7230:
    mov       rcx,	16
    xor       edx,	edx
    call      cc_lib.createunit1
    mov       rbx,	rax
    mov       [rbx],	rdi
    call      cc_lex.lex
    mov       rcx,	9
    call      cc_lib.skipsymbol
    mov       rax,	rbx
L7228:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readswitchstmt
cc_parse.readswitchstmt:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    call      cc_parse.readcond
    mov       rdi,	rax
    mov       rcx,	rdi
    mov       rdx,	3
    call      cc_parse.coercemode
    mov       rcx,	83
    call      cc_parse.pushloop
    xor       ecx,	ecx
    call      cc_parse.readblock
    mov       rbx,	rax
    mov       rcx,	22
    mov       rdx,	rdi
    mov       r8,	rbx
    call      cc_lib.createunit2
    mov       rsi,	rax
    lea       rax,	[rip+cc_parse.casevaluestack]
    mov       r10,	[rip+cc_parse.loopindex]
    mov       rax,	[rax + r10*8-8]
    mov       [rsi],	rax
    call      cc_parse.poploop
    mov       rax,	rsi
L7231:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readcaselabel
cc_parse.readcaselabel:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    call      cc_parse.readconstintexpr
    mov       rbx,	rax
    mov       rcx,	10
    call      cc_lib.skipsymbol
    call      cc_parse.readstatement
    mov       rcx,	18
    mov       rdx,	rax
    call      cc_lib.createunit1
    mov       rdi,	rax
    mov       [rdi],	rbx
    mov       rcx,	rbx
    call      cc_parse.addcasevalue
    mov       rax,	rdi
L7232:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readexprstmt
cc_parse.readexprstmt:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      cc_parse.readexpression
L7233:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_parse.readcond
cc_parse.readcond:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rcx,	13
    call      cc_lib.skipsymbol
    call      cc_parse.readexpression
    mov       rdi,	rax
    mov       rcx,	14
    call      cc_lib.skipsymbol
    mov       rax,	rdi
L7234:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_parse.isusertype
cc_parse.isusertype:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       rcx,	rbx
    mov       rdx,	rax
    mov       r8,	1
    mov       r9,	[rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L7237
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	5
    jnz       L7239
    movzx     rax,	word ptr[rdi+102]
    jmp       L7235
L7239:
    mov       [rip+cc_parse.ist_symptr],	rdi
L7237:
    mov       rax,	20
L7235:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readlocaldecl
cc_parse.readlocaldecl:
#PROC1
#PROC2
#?>>
    .set cc_parse.readlocaldecl.linkage, -8
    .set cc_parse.readlocaldecl.wasdef, -16
    .set cc_parse.readlocaldecl.d, -24
    .set cc_parse.readlocaldecl.ulist, -32
    .set cc_parse.readlocaldecl.ulistx, -40
    .set cc_parse.readlocaldecl.pm, -48
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	88
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rbp + cc_parse.readlocaldecl.ulistx],	rax
    mov       [rbp + cc_parse.readlocaldecl.ulist],	rax
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    mov       r12,	rax
    mov       rcx,	[rip+cc_decls.currproc]
    lea       rdx,	[rbp + cc_parse.readlocaldecl.linkage]
    call      cc_parse.readdeclspec
    mov       rbx,	rax
    xor       rsi,	rsi
L7241:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L7243
    cmp       rax,	25
    jz        L7243
    cmp       rax,	13
    jnz       L7244
L7243:
    inc       rsi
    mov       rcx,	[rip+cc_decls.currproc]
    lea       rdx,	[rbp + cc_parse.readlocaldecl.d]
    mov       r8,	rbx
    lea       r9,	[rbp + cc_parse.readlocaldecl.pm]
    call      cc_parse.readtype
    mov       rdi,	rax
    mov       rax,	[rbp + cc_parse.readlocaldecl.d]
    test      rax,	rax
    jnz       L7246
    lea       rcx,	[rip+L11293]
    call      cc_support.serror
L7246:
    mov       rax,	[rbp + cc_parse.readlocaldecl.linkage]
    cmp       rax,	5
    jnz       L7248
    mov       rcx,	[rip+cc_decls.currproc]
    mov       rdx,	[rbp + cc_parse.readlocaldecl.d]
    mov       r8,	rdi
    call      cc_parse.createtypedef
    mov       [rbp + cc_parse.readlocaldecl.d],	rax
    jmp       L7247
L7248:
    mov       rax,	[rbp + cc_parse.readlocaldecl.pm]
    test      rax,	rax
    jz        L7249
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	17
    jnz       L7251
    lea       rcx,	[rip+L11294]
    call      cc_support.serror
L7251:
    sub       rsp,	8
    lea       rax,	[rbp + cc_parse.readlocaldecl.wasdef]
    push      rax
    mov       rcx,	[rbp + cc_parse.readlocaldecl.d]
    mov       rdx,	rdi
    mov       r8,	[rbp + cc_parse.readlocaldecl.linkage]
    mov       r9,	[rbp + cc_parse.readlocaldecl.pm]
    sub       rsp,	32
    call      cc_parse.readfunction
    add       rsp,	48
    mov       [rbp + cc_parse.readlocaldecl.d],	rax
    jmp       L7247
L7249:
    mov       rcx,	[rbp + cc_parse.readlocaldecl.d]
    mov       rdx,	rdi
    mov       r8,	[rbp + cc_parse.readlocaldecl.linkage]
    call      cc_parse.readframevar
    mov       [rbp + cc_parse.readlocaldecl.d],	rax
    mov       rcx,	7
    call      cc_lib.createunit0
    mov       r13,	rax
    mov       rax,	[rbp + cc_parse.readlocaldecl.d]
    mov       [r13],	rax
    lea       rcx,	[rbp + cc_parse.readlocaldecl.ulist]
    lea       rdx,	[rbp + cc_parse.readlocaldecl.ulistx]
    mov       r8,	r13
    call      cc_lib.addlistunit
L7247:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jnz       L7254
L7253:
    call      cc_lex.lex
    jmp       L7252
L7254:
    mov       rcx,	9
    call      cc_lib.skipsymbol
    jmp       L7242
L7252:
    jmp       L7241
L7244:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	12
    jz        L7256
    cmp       rax,	18
    jz        L7256
    cmp       rax,	19
    jz        L7256
    cmp       rax,	3
    jz        L7257
    jmp       L7258
L7256:
    mov       rcx,	9
    call      cc_lib.skipsymbol
    jmp       L7242
L7257:
    mov       rcx,	9
    call      cc_lib.skipsymbol
    jmp       L7242
L7258:
    mov       rcx,	rdi
    call      cc_lib.typename
    lea       rcx,	[rip+L11295]
    mov       rdx,	rax
    call      cc_support.serror_s
L7255:
    jmp       L7241
L7242:
    mov       rax,	[rbp + cc_parse.readlocaldecl.ulist]
L7240:
#---------------
    add       rsp,	88
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createtypedef
cc_parse.createtypedef:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	1
    mov       r9,	[rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L7261
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	5
    jz        L7263
    mov       rax,	[rdi]
    lea       rcx,	[rip+L11296]
    mov       rdx,	rax
    call      cc_support.serror_s
L7263:
    movzx     rax,	word ptr[rdi+102]
    cmp       rax,	r12
    jz        L7265
    movzx     rax,	word ptr[rdi+102]
    mov       rcx,	rax
    mov       rdx,	r12
    call      cc_parse.comparemode
    test      rax,	rax
    jnz       L7267
    mov       rax,	[rdi]
    lea       rcx,	[rip+L11297]
    mov       rdx,	rax
    call      cc_support.serror_s
L7267:
L7265:
    mov       rax,	rdi
    jmp       L7259
L7261:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	5
    call      cc_lib.createdupldef
    mov       rdi,	rax
    mov       [rdi+102],	r12w
    mov       rax,	rdi
    lea       r10,	[rip+cc_decls.tttypedef]
    mov       r11,	r12
    mov       [r10 + r11*8],	rax
    mov       ax,	[rip+cc_decls.currblockno]
    mov       [rdi+96],	ax
    mov       eax,	1
    lea       r10,	[rip+cc_decls.blockcounts]
    mov       r11,	[rip+cc_decls.currblockno]
    mov       [r10 + r11*4],	eax
    mov       rax,	rdi
L7259:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readparams
cc_parse.readparams:
#PROC1
#PROC2
#?>>
    .set cc_parse.readparams.owner, 64
    .set cc_parse.readparams.ulist, -8
    .set cc_parse.readparams.ulistx, -16
    .set cc_parse.readparams.pm, -24
    .set cc_parse.readparams.lastbasetype, -32
    .set cc_parse.readparams.d, -40
    .set cc_parse.readparams.names, -48
    .set cc_parse.readparams.nonames, -56
    .set cc_parse.readparams.reported, -64
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	96
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rbp + cc_parse.readparams.d],	rax
    xor       eax,	eax
    mov       [rbp + cc_parse.readparams.ulistx],	rax
    mov       [rbp + cc_parse.readparams.ulist],	rax
    xor       eax,	eax
    mov       r14,	rax
    mov       rsi,	rax
    mov       r12,	rax
    xor       eax,	eax
    mov       [rbp + cc_parse.readparams.lastbasetype],	rax
    xor       eax,	eax
    mov       [rbp + cc_parse.readparams.names],	rax
    xor       eax,	eax
    mov       [rbp + cc_parse.readparams.nonames],	rax
    xor       eax,	eax
    mov       [rbp + cc_parse.readparams.reported],	rax
    jmp       L7270
L7269:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	21
    jnz       L7273
    mov       r12,	1
    call      cc_lex.lex
    jmp       L7271
L7273:
    call      cc_parse.istypestarter
    test      rax,	rax
    jz        L7275
    sub       rsp,	8
    lea       rax,	[rbp + cc_parse.readparams.lastbasetype]
    push      rax
    lea       rcx,	[rbp + cc_parse.readparams.d]
    mov       rdx,	1
    lea       r8,	[rbp + cc_parse.readparams.pm]
    xor       r9d,	r9d
    sub       rsp,	32
    call      cc_parse.readcasttype
    add       rsp,	48
    mov       rbx,	rax
    mov       rax,	[rbp + cc_parse.readparams.pm]
    test      rax,	rax
    jz        L7277
    mov       rcx,	rbx
    mov       rdx,	[rbp + cc_parse.readparams.pm]
    call      cc_lib.createprocmode
    mov       rcx,	rax
    call      cc_lib.createrefmode
    mov       rbx,	rax
L7277:
    jmp       L7274
L7275:
    mov       rax,	[rbp + cc_parse.readparams.lastbasetype]
    test      rax,	rax
    jnz       L7279
    lea       rcx,	[rip+L11298]
    call      cc_support.serror
L7279:
    sub       rsp,	8
    push      0
    lea       rcx,	[rbp + cc_parse.readparams.d]
    mov       rdx,	1
    lea       r8,	[rbp + cc_parse.readparams.pm]
    mov       r9,	[rbp + cc_parse.readparams.lastbasetype]
    sub       rsp,	32
    call      cc_parse.readcasttype
    add       rsp,	48
    mov       rbx,	rax
L7274:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jz        L7281
    cmp       rax,	14
    jz        L7282
    jmp       L7283
L7281:
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    mov       rcx,	rax
    call      cc_lib.createrefmode
    mov       rbx,	rax
    jmp       L7280
L7282:
    lea       rax,	[rip+cc_decls.ttparams]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      cc_lib.createprocmode
    mov       rcx,	rax
    call      cc_lib.createrefmode
    mov       rbx,	rax
L7283:
L7280:
    mov       rcx,	24
    call      mlib.pcm_allocz
    mov       [rbp + cc_parse.readparams.pm],	rax
    mov       rax,	[rbp + cc_parse.readparams.d]
    mov       r10,	[rbp + cc_parse.readparams.pm]
    mov       [r10],	rax
    mov       eax,	ebx
    mov       r10,	[rbp + cc_parse.readparams.pm]
    mov       [r10+16],	eax
    inc       rsi
    mov       rax,	[rbp + cc_parse.readparams.d]
    test      rax,	rax
    jz        L7285
    mov       rax,	1
    mov       [rbp + cc_parse.readparams.names],	rax
    jmp       L7284
L7285:
    mov       rax,	1
    mov       [rbp + cc_parse.readparams.nonames],	rax
L7284:
    mov       rax,	[rbp + cc_parse.readparams.names]
    test      rax,	rax
    jz        L7287
    mov       rax,	[rbp + cc_parse.readparams.nonames]
    test      rax,	rax
    jz        L7287
    mov       rax,	[rbp + cc_parse.readparams.reported]
    test      rax,	rax
    jnz       L7287
    mov       rax,	1
    mov       [rbp + cc_parse.readparams.reported],	rax
L7287:
    mov       rax,	[rbp + cc_parse.readparams.d]
    test      rax,	rax
    jz        L7289
    inc       r14
    mov       rdi,	[rbp + cc_parse.readparams.ulist]
    jmp       L7291
L7290:
    mov       rax,	[rdi]
    cmp       rax,	[rbp + cc_parse.readparams.d]
    jnz       L7294
    mov       rax,	[rbp + cc_parse.readparams.d]
    movzx     rax,	byte ptr[rax+109]
    lea       r10,	[rip+cc_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rax,	[rbp + cc_parse.readparams.d]
    mov       rax,	[rax]
    lea       rcx,	[rip+L11299]
    mov       rdx,	rax
    mov       r8,	r10
    call      cc_support.serror_ss
L7294:
    mov       rdi,	[rdi+8]
L7291:
    test      rdi,	rdi
    jnz       L7290
L7289:
    lea       rcx,	[rbp + cc_parse.readparams.ulist]
    lea       rdx,	[rbp + cc_parse.readparams.ulistx]
    mov       r8,	[rbp + cc_parse.readparams.pm]
    call      cc_lib.addlistparam
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jz        L7296
    cmp       rax,	21
    jz        L7297
    cmp       rax,	14
    jz        L7297
    jmp       L7298
L7296:
    call      cc_lex.lex
    jmp       L7295
L7297:
    jmp       L7295
L7298:
    lea       rcx,	[rip+L11300]
    call      cc_support.serror
L7295:
L7270:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	14
    jnz       L7269
L7271:
    xor       r13,	r13
    mov       rcx,	14
    call      cc_lib.skipsymbol
    test      r12,	r12
    jz        L7300
    mov       r13,	3
    jmp       L7299
L7300:
    test      rsi,	rsi
    jnz       L7301
    mov       r13,	1
    jmp       L7299
L7301:
    cmp       rsi,	1
    jnz       L7302
    test      rbx,	rbx
    jnz       L7302
    mov       r13,	2
    xor       rsi,	rsi
    xor       eax,	eax
    mov       r10,	[rbp + cc_parse.readparams.ulist]
    mov       [r10+16],	eax
L7302:
L7299:
    mov       rax,	[rbp + cc_parse.readparams.ulist]
    test      rax,	rax
    jnz       L7304
    mov       rcx,	24
    call      mlib.pcm_allocz
    mov       [rbp + cc_parse.readparams.ulist],	rax
L7304:
    mov       ax,	si
    mov       r10,	[rbp + cc_parse.readparams.ulist]
    mov       [r10+20],	ax
    mov       ax,	r13w
    mov       r10,	[rbp + cc_parse.readparams.ulist]
    mov       [r10+22],	ax
    mov       rax,	[rbp + cc_parse.readparams.ulist]
L7268:
#---------------
    add       rsp,	96
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readcasttype
cc_parse.readcasttype:
#PROC1
#PROC2
#?>>
    .set cc_parse.readcasttype.mbase, 88
    .set cc_parse.readcasttype.linkage, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_decls.currproc]
    test      rax,	rax
    jz        L7307
    mov       rax,	[rip+cc_decls.currproc]
    jmp       L7306
L7307:
    mov       rax,	[rip+cc_decls.stmodule]
L7306:
    mov       rdi,	rax
    xor       eax,	eax
    mov       [rbp + cc_parse.readcasttype.linkage],	rax
    xor       eax,	eax
    mov       [rbx],	rax
    test      r13,	r13
    jnz       L7309
    mov       rcx,	rdi
    lea       rdx,	[rbp + cc_parse.readcasttype.linkage]
    call      cc_parse.readdeclspec
    mov       r13,	rax
    mov       rax,	[rbp + cc_parse.readcasttype.mbase]
    test      rax,	rax
    jz        L7311
    mov       rax,	r13
    mov       r10,	[rbp + cc_parse.readcasttype.mbase]
    mov       [r10],	rax
L7311:
L7309:
    xor       eax,	eax
    mov       [r12],	rax
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L7313
    cmp       rax,	25
    jz        L7313
    cmp       rax,	13
    jz        L7313
    cmp       rax,	15
    jnz       L7314
L7313:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	r13
    mov       r9,	r12
    call      cc_parse.readtype
    mov       r13,	rax
    mov       rax,	[rbx]
    test      rax,	rax
    jz        L7316
    test      rsi,	rsi
    jnz       L7316
    mov       rax,	[rbx]
    mov       rax,	[rax]
    lea       rcx,	[rip+L11301]
    mov       rdx,	rax
    call      cc_support.serror_s
L7316:
L7314:
L7312:
    mov       rax,	r13
L7305:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readfunction
cc_parse.readfunction:
#PROC1
#PROC2
#?>>
    .set cc_parse.readfunction.pm, 88
    .set cc_parse.readfunction.wasdef, 96
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
    mov       rbx,	[rip+cc_decls.stmodule]
    xor       eax,	eax
    mov       r10,	[rbp + cc_parse.readfunction.wasdef]
    mov       [r10],	rax
    mov       rcx,	rbx
    mov       rdx,	r12
    mov       r8,	1
    xor       r9d,	r9d
    call      cc_lib.checkdupl
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L7319
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	6
    jz        L7321
    mov       rax,	[r12]
    lea       rcx,	[rip+L11302]
    mov       rdx,	rax
    call      cc_support.serror_s
L7321:
    mov       r12,	rdi
    movzx     rax,	byte ptr[r12+110]
    mov       rsi,	rax
    cmp       rsi,	3
    jnz       L7323
    test      r14,	r14
    jnz       L7323
    mov       rsi,	4
    jmp       L7322
L7323:
    cmp       r14,	1
    jnz       L7324
    mov       rsi,	2
L7324:
L7322:
    jmp       L7318
L7319:
    mov       rcx,	rbx
    mov       rdx,	r12
    mov       r8,	6
    call      cc_lib.createdupldef
    mov       r12,	rax
    mov       [r12+102],	r13w
    mov       rax,	r14
    cmp       rax,	1
    jz        L7326
    cmp       rax,	4
    jz        L7327
    jmp       L7328
L7326:
    mov       rsi,	2
    jmp       L7325
L7327:
    mov       rsi,	3
    jmp       L7325
L7328:
    mov       rsi,	4
L7325:
L7318:
    mov       rax,	[rbp + cc_parse.readfunction.pm]
    mov       [r12+80],	rax
    mov       [r12+110],	sil
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	17
    jnz       L7330
    mov       rax,	1
    mov       r10,	[rbp + cc_parse.readfunction.wasdef]
    mov       [r10],	rax
    mov       rax,	[r12+72]
    test      rax,	rax
    jz        L7332
    mov       rax,	[r12]
    lea       rcx,	[rip+L11303]
    mov       rdx,	rax
    call      cc_support.serror_s
L7332:
    cmp       rsi,	3
    jnz       L7334
    mov       al,	4
    mov       [r12+110],	al
L7334:
    mov       rcx,	r12
    call      cc_parse.readfunctionbody
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	9
    jnz       L7336
    lea       rcx,	[rip+L11304]
    call      cc_support.serror
L7336:
L7330:
    mov       rax,	r12
L7317:
#---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readfunctionbody
cc_parse.readfunctionbody:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r14,	rcx
#---------------
#PROC3
#PROC4
    mov       [rip+cc_decls.currproc],	r14
    xor       eax,	eax
    mov       [rip+cc_decls.currblockno],	rax
    mov       [rip+cc_decls.nextblockno],	rax
    xor       r12,	r12
    mov       rax,	[r14+80]
    mov       rsi,	rax
    movsx     rax,	word ptr[rsi+20]
    mov       r13,	rax
    cmp       r13,	0
    jle       L7340
L7338:
    mov       rax,	[rsi]
    test      rax,	rax
    jz        L7341
L7342:
    mov       rax,	[rsi]
    mov       rcx,	r14
    mov       rdx,	rax
    mov       r8,	9
    call      cc_lib.createdupldef
    mov       rdi,	rax
    mov       rax,	[rdi]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	36
    jnz       L7344
    mov       al,	1
    mov       [rdi+122],	al
L7344:
    mov       ax,	1
    mov       [rdi+96],	ax
    mov       eax,	[rsi+16]
    mov       [rdi+102],	ax
L7341:
    mov       rsi,	[rsi+8]
    mov       r12,	1
    dec       r13
    jnz       L7338
L7340:
    mov       rcx,	r12
    call      cc_parse.readcompoundstmt
    mov       rbx,	rax
    mov       rax,	rbx
    mov       r10,	[rip+cc_decls.currproc]
    mov       [r10+72],	rax
    xor       eax,	eax
    mov       [rip+cc_decls.currproc],	rax
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createnegop
cc_parse.createnegop:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rsi+52]
    mov       rbx,	rax
    movsxd    rax,	dword ptr[rsi+40]
    cmp       rax,	1
    jnz       L7347
    mov       rax,	rbx
    cmp       rax,	3
    jz        L7349
    cmp       rax,	4
    jz        L7349
    cmp       rax,	9
    jz        L7349
    cmp       rax,	8
    jz        L7350
    cmp       rax,	11
    jz        L7351
    jmp       L7352
L7349:
    mov       rax,	[rsi]
    neg       rax
    mov       [rsi],	rax
    mov       rax,	rsi
    jmp       L7345
L7350:
    mov       rax,	[rsi]
    neg       rax
    mov       r10,	4294967295
    and       rax,	r10
    mov       [rsi],	rax
    mov       rax,	rsi
    jmp       L7345
L7351:
    movq      XMM4,	[rsi]
    xorpd     XMM4,	[rip+L10545]
    movq      [rsi],	XMM4
    mov       rax,	rsi
    jmp       L7345
L7352:
L7348:
L7347:
#cc_parse.createnegop.retry:
L7353:
    cmp       rbx,	1
    jl        L7355
    cmp       rbx,	11
    jg        L7355
    mov       rcx,	rsi
    call      cc_parse.coercebasetype
    mov       rcx,	58
    mov       rdx,	rsi
    call      cc_lib.createunit1
    mov       rdi,	rax
    jmp       L7354
L7355:
    lea       rax,	[rip+cc_decls.ttconst]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7356
    lea       rax,	[rip+cc_decls.ttconsttype]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    mov       rbx,	rax
    jmp       L7353
L7356:
    call      msys.m$print_startcon
    mov       rcx,	rbx
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11305]
    call      cc_support.terror
L7354:
    mov       eax,	[rsi+52]
    mov       [rdi+52],	eax
    mov       rax,	rdi
L7345:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createabsop
cc_parse.createabsop:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rsi+52]
    mov       rbx,	rax
    movsxd    rax,	dword ptr[rsi+40]
    cmp       rax,	1
    jnz       L7359
    mov       rax,	rbx
    cmp       rax,	3
    jz        L7361
    cmp       rax,	4
    jnz       L7362
L7361:
    mov       rax,	[rsi]
    cmp       rax,	0
    jge       L11306
    neg       rax
L11306:
    mov       [rsi],	rax
    mov       rax,	rsi
    jmp       L7357
L7362:
L7360:
L7359:
    mov       rcx,	rbx
    call      cc_lib.isintcc
    test      rax,	rax
    jz        L7364
    mov       rcx,	rsi
    call      cc_parse.coercebasetype
    mov       rcx,	59
    mov       rdx,	rsi
    call      cc_lib.createunit1
    mov       rdi,	rax
    jmp       L7363
L7364:
    lea       rcx,	[rip+L11307]
    call      cc_support.terror
L7363:
    mov       eax,	[rsi+52]
    mov       [rdi+52],	eax
    mov       rax,	rdi
L7357:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createinotop
cc_parse.createinotop:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rsi+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rbx,	r10
    movsxd    rax,	dword ptr[rsi+40]
    cmp       rax,	1
    jnz       L7367
    mov       rax,	rbx
    cmp       rax,	3
    jz        L7369
    cmp       rax,	4
    jz        L7369
    cmp       rax,	8
    jz        L7369
    cmp       rax,	9
    jnz       L7370
L7369:
    mov       rax,	[rsi]
    not       rax
    mov       [rsi],	rax
    mov       rax,	rsi
    jmp       L7365
L7370:
L7368:
L7367:
    mov       rcx,	rbx
    call      cc_lib.isintcc
    test      rax,	rax
    jz        L7372
    mov       rcx,	rsi
    call      cc_parse.coercebasetype
    mov       rcx,	60
    mov       rdx,	rsi
    call      cc_lib.createunit1
    mov       rdi,	rax
    jmp       L7371
L7372:
    call      msys.m$print_startcon
    mov       rcx,	rbx
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11308]
    call      cc_support.terror
L7371:
    mov       eax,	[rsi+52]
    mov       [rdi+52],	eax
    mov       rax,	rdi
L7365:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createptrop
cc_parse.createptrop:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r12+52]
    mov       rbx,	rax
    lea       r10,	[rip+cc_decls.ttisref]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L7375
    xor       ecx,	ecx
    mov       rdx,	r12
    xor       r8d,	r8d
    lea       r9,	[rip+L11309]
    call      cc_show.printunit
    lea       rcx,	[rip+L11310]
    call      cc_support.terror
L7375:
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    mov       rsi,	rax
    movsxd    rax,	dword ptr[r12+40]
    cmp       rax,	55
    jnz       L7378
L7377:
    mov       rdi,	[r12+16]
    movsxd    rax,	dword ptr[r12+52]
    lea       r10,	[rip+cc_decls.tttarget]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       [rdi+52],	r10d
    mov       rcx,	rdi
    call      cc_parse.fixmemopnd
    mov       rax,	rdi
    jmp       L7373
L7378:
L7376:
    mov       rcx,	52
    mov       rdx,	r12
    call      cc_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+52],	esi
    mov       rcx,	rdi
    call      cc_parse.arraytopointer
    mov       rdi,	rax
    mov       rcx,	rdi
    call      cc_parse.fixmemopnd
    mov       rax,	rdi
L7373:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createincrop
cc_parse.createincrop:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r12+52]
    mov       rbx,	rax
    mov       rcx,	r12
    mov       rdx,	1
    call      cc_parse.checklvalue
    mov       rcx,	rbx
    call      cc_lib.isintcc
    test      rax,	rax
    jz        L7382
    cmp       rbx,	5
    jnz       L7381
L7382:
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L7381
    lea       rcx,	[rip+L11311]
    call      cc_support.terror
L7381:
    mov       rcx,	rsi
    mov       rdx,	r12
    call      cc_lib.createunit1
    mov       rdi,	rax
    mov       eax,	[r12+52]
    mov       [rdi+52],	eax
    mov       rax,	rdi
L7379:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createaddrofop
cc_parse.createaddrofop:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    xor       rsi,	rsi
#cc_parse.createaddrofop.restartx:
L7384:
    movsxd    rax,	dword ptr[r12+52]
    mov       rbx,	rax
    mov       ax,	[r12+56]
    test      ax,	ax
    jz        L7386
    movsx     rax,	word ptr[r12+56]
    mov       rbx,	rax
L7386:
    movsxd    rax,	dword ptr[r12+40]
    cmp       rax,	3
    jz        L7388
    cmp       rax,	55
    jz        L7389
    cmp       rax,	49
    jz        L7390
    cmp       rax,	53
    jz        L7391
    cmp       rax,	4
    jz        L7392
    cmp       rax,	5
    jz        L7393
    jmp       L7394
L7388:
    mov       rax,	[r12]
    lea       rax,	[rax+108]
    or        byte ptr[rax],	1
    mov       eax,	[r12+48]
    test      eax,	eax
    jz        L7396
    mov       rax,	[r12]
    movzx     rax,	word ptr[rax+102]
    mov       rbx,	rax
    movsxd    rax,	dword ptr[r12+48]
    mov       rsi,	rax
L7396:
    jmp       L7387
L7389:
    mov       rax,	[r12+16]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	3
    jnz       L7398
    mov       rax,	[r12+16]
    mov       eax,	[rax+48]
    test      eax,	eax
    jz        L7398
    mov       rax,	[r12+16]
    mov       rax,	[rax]
    movzx     rax,	word ptr[rax+102]
    mov       rcx,	rax
    call      cc_lib.createrefmode
    mov       [r12+52],	eax
    mov       rax,	[r12+16]
    mov       eax,	[rax+48]
    mov       [r12+48],	eax
    mov       rax,	r12
    jmp       L7383
L7398:
    jmp       L7387
L7390:
    mov       rdi,	[r12+16]
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	52
    jnz       L7400
    mov       rax,	[rdi+16]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7400
    movsxd    rax,	dword ptr[r12]
    mov       r10,	[rdi+16]
    mov       r10,	[r10]
    add       rax,	r10
    mov       rcx,	rax
    mov       rdx,	3
    call      cc_lib.createconstunit
    mov       r12,	rax
    mov       rax,	r12
    jmp       L7383
L7400:
    jmp       L7401
L7391:
    mov       eax,	[r12+48]
    test      eax,	eax
    jz        L7403
    movsxd    rax,	dword ptr[r12+48]
    movsxd    r10,	dword ptr[r12+52]
    lea       r11,	[rip+cc_decls.tttarget]
    movsx     r11,	word ptr[r11 + r10*2]
    mov       rcx,	r11
    mov       rdx,	rax
    call      cc_lib.createarraymode
    mov       rcx,	rax
    call      cc_lib.createrefmode
    mov       [r12+52],	eax
    mov       rax,	r12
    jmp       L7383
L7403:
    jmp       L7387
L7392:
    mov       r12,	[r12+16]
    jmp       L7384
L7393:
    mov       rax,	r12
    jmp       L7383
L7394:
#cc_parse.createaddrofop.cad1:
L7401:
    mov       rcx,	r12
    xor       edx,	edx
    call      cc_parse.checklvalue
L7387:
    mov       rcx,	55
    mov       rdx,	r12
    call      cc_lib.createunit1
    mov       r12,	rax
    mov       rcx,	rbx
    call      cc_lib.createrefmode
    mov       [r12+52],	eax
    mov       [r12+48],	esi
    mov       rax,	r12
L7383:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createaddop
cc_parse.createaddop:
#PROC1
#PROC2
#?>>
    .set cc_parse.createaddop.x, 56
    .set cc_parse.createaddop.y, 64
    .set cc_parse.createaddop.elemsize, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+56],	rcx
    mov       [rbp+64],	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rbp + cc_parse.createaddop.x]
    call      cc_parse.getmemmode
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rbx,	r10
    mov       rcx,	[rbp + cc_parse.createaddop.y]
    call      cc_parse.getmemmode
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rsi,	r10
    mov       r13,	39
    lea       rax,	[rip+cc_tables.dominantmode]
    mov       r10,	rbx
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10]
    mov       r12,	rax
    test      rax,	rax
    jz        L7406
    mov       rcx,	[rbp + cc_parse.createaddop.x]
    mov       rdx,	r12
    call      cc_parse.coercemode
    mov       [rbp + cc_parse.createaddop.x],	rax
    mov       rcx,	[rbp + cc_parse.createaddop.y]
    mov       rdx,	r12
    call      cc_parse.coercemode
    mov       [rbp + cc_parse.createaddop.y],	rax
    jmp       L7405
L7406:
    cmp       rbx,	13
    jnz       L7407
#cc_parse.createaddop.doaddref:
L7408:
    mov       rax,	[rbp + cc_parse.createaddop.x]
    movsxd    rax,	dword ptr[rax+52]
    mov       r12,	rax
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	r12
    movsx     rax,	word ptr[rax + r10*2]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r10,	[r10 + rax*8]
    mov       [rbp + cc_parse.createaddop.elemsize],	r10
    mov       rax,	[rbp + cc_parse.createaddop.x]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7410
    mov       rax,	[rbp + cc_parse.createaddop.y]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7410
    mov       rax,	[rbp + cc_parse.createaddop.y]
    mov       rax,	[rax]
    mov       r10,	[rbp + cc_parse.createaddop.elemsize]
    imul      rax,	r10
    mov       r10,	[rbp + cc_parse.createaddop.x]
    add       [r10],	rax
    mov       rax,	[rbp + cc_parse.createaddop.x]
    jmp       L7404
L7410:
    mov       rcx,	[rbp + cc_parse.createaddop.y]
    mov       rdx,	4
    call      cc_parse.coercemode
    mov       [rbp + cc_parse.createaddop.y],	rax
    mov       rcx,	53
    mov       rdx,	[rbp + cc_parse.createaddop.x]
    mov       r8,	[rbp + cc_parse.createaddop.y]
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	r12d
    mov       eax,	[rbp + cc_parse.createaddop.elemsize]
    mov       [rdi],	eax
    mov       rax,	rdi
    jmp       L7404
L7407:
    cmp       rsi,	13
    jnz       L7411
    mov       rax,	[rbp + cc_parse.createaddop.x]
    mov       r10,	[rbp + cc_parse.createaddop.y]
    mov       [rbp + cc_parse.createaddop.y],	rax
    mov       [rbp + cc_parse.createaddop.x],	r10
    jmp       L7408
    lea       rcx,	[rip+L11312]
    call      cc_support.terror
L7411:
L7405:
    mov       rax,	[rbp + cc_parse.createaddop.x]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7413
    mov       rax,	[rbp + cc_parse.createaddop.y]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7415
    mov       rcx,	r13
    mov       rdx,	[rbp + cc_parse.createaddop.x]
    mov       r8,	[rbp + cc_parse.createaddop.y]
    mov       r9,	r12
    call      cc_parse.eval_add
    jmp       L7404
L7415:
    mov       rax,	[rbp + cc_parse.createaddop.x]
    mov       r10,	[rbp + cc_parse.createaddop.y]
    mov       [rbp + cc_parse.createaddop.y],	rax
    mov       [rbp + cc_parse.createaddop.x],	r10
L7414:
    mov       rax,	[rbp + cc_parse.createaddop.y]
    mov       rax,	[rax]
    test      rax,	rax
    jnz       L7417
    mov       rax,	[rbp + cc_parse.createaddop.x]
    jmp       L7404
L7417:
L7413:
    mov       rcx,	r13
    mov       rdx,	[rbp + cc_parse.createaddop.x]
    mov       r8,	[rbp + cc_parse.createaddop.y]
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	r12d
    mov       rax,	rdi
L7404:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createsubop
cc_parse.createsubop:
#PROC1
#PROC2
#?>>
    .set cc_parse.createsubop.x, 56
    .set cc_parse.createsubop.y, 64
    .set cc_parse.createsubop.elemsize, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+56],	rcx
    mov       [rbp+64],	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rbp + cc_parse.createsubop.x]
    call      cc_parse.getmemmode
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rbx,	r10
    mov       rcx,	[rbp + cc_parse.createsubop.y]
    call      cc_parse.getmemmode
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rsi,	r10
    mov       r13,	40
    lea       rax,	[rip+cc_tables.dominantmode]
    mov       r10,	rbx
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10]
    mov       r12,	rax
    test      rax,	rax
    jz        L7420
    mov       rcx,	[rbp + cc_parse.createsubop.x]
    mov       rdx,	r12
    call      cc_parse.coercemode
    mov       [rbp + cc_parse.createsubop.x],	rax
    mov       rcx,	[rbp + cc_parse.createsubop.y]
    mov       rdx,	r12
    call      cc_parse.coercemode
    mov       [rbp + cc_parse.createsubop.y],	rax
    jmp       L7419
L7420:
    cmp       rbx,	13
    jnz       L7421
    cmp       rsi,	13
    jz        L7423
    mov       rax,	[rbp + cc_parse.createsubop.x]
    movsxd    rax,	dword ptr[rax+52]
    mov       r12,	rax
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	r12
    movsx     rax,	word ptr[rax + r10*2]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r10,	[r10 + rax*8]
    mov       [rbp + cc_parse.createsubop.elemsize],	r10
    mov       rcx,	[rbp + cc_parse.createsubop.y]
    mov       rdx,	4
    call      cc_parse.coercemode
    mov       [rbp + cc_parse.createsubop.y],	rax
    mov       rcx,	54
    mov       rdx,	[rbp + cc_parse.createsubop.x]
    mov       r8,	[rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	r12d
    mov       eax,	[rbp + cc_parse.createsubop.elemsize]
    mov       [rdi],	eax
    mov       rax,	rdi
    jmp       L7418
L7423:
    mov       rax,	[rbp + cc_parse.createsubop.x]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7425
    mov       rax,	[rbp + cc_parse.createsubop.y]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7425
    mov       rax,	[rbp + cc_parse.createsubop.y]
    mov       rax,	[rax]
    mov       r10,	[rbp + cc_parse.createsubop.x]
    movsxd    r10,	dword ptr[r10+52]
    lea       r11,	[rip+cc_decls.tttarget]
    movsx     r11,	word ptr[r11 + r10*2]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r10,	[r10 + r11*8]
    cqo       
    idiv      r10
    mov       r10,	[rbp + cc_parse.createsubop.x]
    sub       [r10],	rax
    mov       eax,	3
    mov       r10,	[rbp + cc_parse.createsubop.x]
    mov       [r10+52],	eax
    mov       rax,	[rbp + cc_parse.createsubop.x]
    jmp       L7418
L7425:
    mov       rcx,	r13
    mov       rdx,	[rbp + cc_parse.createsubop.x]
    mov       r8,	[rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       eax,	4
    mov       [rdi+52],	eax
    mov       rax,	[rbp + cc_parse.createsubop.x]
    movsxd    rax,	dword ptr[rax+52]
    lea       r10,	[rip+cc_decls.tttarget]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      cc_parse.divunit
    mov       rdi,	rax
    mov       eax,	4
    mov       [rdi+52],	eax
    mov       rax,	rdi
    jmp       L7418
L7424:
L7422:
    mov       rax,	[rbp + cc_parse.createsubop.x]
    movsxd    rax,	dword ptr[rax+52]
    lea       r10,	[rip+cc_decls.tttarget]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rcx,	[rbp + cc_parse.createsubop.y]
    mov       rdx,	r10
    call      cc_parse.mulunit
    mov       [rbp + cc_parse.createsubop.y],	rax
    jmp       L7419
L7421:
    lea       rcx,	[rip+L11312]
    call      cc_support.terror
L7419:
    mov       rax,	[rbp + cc_parse.createsubop.x]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7427
    mov       rax,	[rbp + cc_parse.createsubop.y]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7427
    mov       rcx,	r13
    mov       rdx,	[rbp + cc_parse.createsubop.x]
    mov       r8,	[rbp + cc_parse.createsubop.y]
    mov       r9,	r12
    call      cc_parse.eval_sub
    jmp       L7418
L7427:
    mov       rax,	[rbp + cc_parse.createsubop.y]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7429
    mov       rax,	[rbp + cc_parse.createsubop.y]
    mov       rax,	[rax]
    test      rax,	rax
    jnz       L7429
L7429:
    mov       rcx,	r13
    mov       rdx,	[rbp + cc_parse.createsubop.x]
    mov       r8,	[rbp + cc_parse.createsubop.y]
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	r12d
    mov       rax,	rdi
L7418:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createmulop
cc_parse.createmulop:
#PROC1
#PROC2
#?>>
    .set cc_parse.createmulop.x, 56
    .set cc_parse.createmulop.y, 64
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+56],	rcx
    mov       [rbp+64],	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rbp + cc_parse.createmulop.x]
    call      cc_parse.getmemmode
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rbx,	r10
    mov       rcx,	[rbp + cc_parse.createmulop.y]
    call      cc_parse.getmemmode
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rsi,	r10
    mov       r13,	41
    lea       rax,	[rip+cc_tables.dominantmode]
    mov       r10,	rbx
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10]
    mov       r12,	rax
    test      rax,	rax
    jz        L7432
    mov       rcx,	[rbp + cc_parse.createmulop.x]
    mov       rdx,	r12
    call      cc_parse.coercemode
    mov       [rbp + cc_parse.createmulop.x],	rax
    mov       rcx,	[rbp + cc_parse.createmulop.y]
    mov       rdx,	r12
    call      cc_parse.coercemode
    mov       [rbp + cc_parse.createmulop.y],	rax
    jmp       L7431
L7432:
    lea       rcx,	[rip+L11313]
    call      cc_support.terror
L7431:
    mov       rax,	[rbp + cc_parse.createmulop.x]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7434
    mov       rax,	[rbp + cc_parse.createmulop.y]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7436
    mov       rcx,	r13
    mov       rdx,	[rbp + cc_parse.createmulop.x]
    mov       r8,	[rbp + cc_parse.createmulop.y]
    mov       r9,	r12
    call      cc_parse.eval_mul
    jmp       L7430
L7436:
    mov       rax,	[rbp + cc_parse.createmulop.x]
    mov       r10,	[rbp + cc_parse.createmulop.y]
    mov       [rbp + cc_parse.createmulop.y],	rax
    mov       [rbp + cc_parse.createmulop.x],	r10
L7435:
L7434:
    mov       rcx,	r13
    mov       rdx,	[rbp + cc_parse.createmulop.x]
    mov       r8,	[rbp + cc_parse.createmulop.y]
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	r12d
    mov       rax,	rdi
L7430:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createdivop
cc_parse.createdivop:
#PROC1
#PROC2
#?>>
    .set cc_parse.createdivop.x, 56
    .set cc_parse.createdivop.y, 64
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+56],	rcx
    mov       [rbp+64],	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rbp + cc_parse.createdivop.x]
    call      cc_parse.getmemmode
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rbx,	r10
    mov       rcx,	[rbp + cc_parse.createdivop.y]
    call      cc_parse.getmemmode
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rsi,	r10
    mov       r13,	42
    lea       rax,	[rip+cc_tables.dominantmode]
    mov       r10,	rbx
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10]
    mov       r12,	rax
    test      rax,	rax
    jz        L7439
    mov       rcx,	[rbp + cc_parse.createdivop.x]
    mov       rdx,	r12
    call      cc_parse.coercemode
    mov       [rbp + cc_parse.createdivop.x],	rax
    mov       rcx,	[rbp + cc_parse.createdivop.y]
    mov       rdx,	r12
    call      cc_parse.coercemode
    mov       [rbp + cc_parse.createdivop.y],	rax
    jmp       L7438
L7439:
    lea       rcx,	[rip+L11314]
    call      cc_support.terror
L7438:
    mov       rax,	[rbp + cc_parse.createdivop.x]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7441
    mov       rax,	[rbp + cc_parse.createdivop.y]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7441
    mov       rcx,	r13
    mov       rdx,	[rbp + cc_parse.createdivop.x]
    mov       r8,	[rbp + cc_parse.createdivop.y]
    mov       r9,	r12
    call      cc_parse.eval_div
    jmp       L7437
L7441:
    mov       rax,	[rbp + cc_parse.createdivop.y]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7442
    cmp       r12,	11
    jnz       L7442
    mov       r13,	41
    mov       rax,	[rbp + cc_parse.createdivop.y]
    movq      XMM4,	[rax]
    movq      XMM5,	[rip+L11315]
    divsd     XMM5,	XMM4
    mov       rax,	[rbp + cc_parse.createdivop.y]
    movq      [rax],	XMM5
L7442:
L7440:
    mov       rcx,	r13
    mov       rdx,	[rbp + cc_parse.createdivop.x]
    mov       r8,	[rbp + cc_parse.createdivop.y]
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	r12d
    mov       rax,	rdi
L7437:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createremop
cc_parse.createremop:
#PROC1
#PROC2
#?>>
    .set cc_parse.createremop.x, 56
    .set cc_parse.createremop.y, 64
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       [rbp+56],	rcx
    mov       [rbp+64],	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + cc_parse.createremop.x]
    movsxd    rax,	dword ptr[rax+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rbx,	r10
    mov       rax,	[rbp + cc_parse.createremop.y]
    movsxd    rax,	dword ptr[rax+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rsi,	r10
    mov       r13,	43
    lea       rax,	[rip+cc_tables.dominantmode]
    mov       r10,	rbx
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       r10,	rsi
    movzx     rax,	byte ptr[rax + r10]
    mov       r12,	rax
    test      rax,	rax
    jz        L7445
    cmp       r12,	11
    jz        L7448
    cmp       r12,	10
    jnz       L7447
L7448:
    mov       r12,	3
L7447:
    mov       rcx,	[rbp + cc_parse.createremop.x]
    mov       rdx,	r12
    call      cc_parse.coercemode
    mov       [rbp + cc_parse.createremop.x],	rax
    mov       rcx,	[rbp + cc_parse.createremop.y]
    mov       rdx,	r12
    call      cc_parse.coercemode
    mov       [rbp + cc_parse.createremop.y],	rax
    jmp       L7444
L7445:
    lea       rcx,	[rip+L11316]
    call      cc_support.terror
L7444:
    mov       rax,	[rbp + cc_parse.createremop.x]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7450
    mov       rax,	[rbp + cc_parse.createremop.y]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7450
    mov       rcx,	r13
    mov       rdx,	[rbp + cc_parse.createremop.x]
    mov       r8,	[rbp + cc_parse.createremop.y]
    mov       r9,	r12
    call      cc_parse.eval_rem
    jmp       L7443
L7450:
    mov       rcx,	r13
    mov       rdx,	[rbp + cc_parse.createremop.x]
    mov       r8,	[rbp + cc_parse.createremop.y]
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	r12d
    mov       rax,	rdi
L7443:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.insertunit
cc_parse.insertunit:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    xor       ecx,	ecx
    call      cc_lib.createunit0
    mov       rdi,	rax
    mov       rax,	rbx
    push      rdi
    mov       r11,	8
L11317:
    mov       r10,	[rax]
    mov       [rdi],	r10
    add       rdi,	8
    add       rax,	8
    dec       r11
    jnz       L11317
    pop       rdi
    mov       [rbx+40],	esi
    mov       [rbx+16],	rdi
    xor       eax,	eax
    mov       [rbx+32],	rax
    mov       [rbx+24],	rax
    mov       eax,	[rdi+44]
    mov       [rbx+44],	eax
    mov       rax,	[rdi+8]
    mov       [rbx+8],	rax
    xor       eax,	eax
    mov       [rbx+56],	ax
    xor       eax,	eax
    mov       [rdi+8],	rax
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.eval_add
cc_parse.eval_add:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
#---------------
#PROC3
#PROC4
    mov       rax,	r13
    cmp       rax,	3
    jz        L7454
    cmp       rax,	4
    jz        L7454
    cmp       rax,	8
    jz        L7454
    cmp       rax,	9
    jz        L7454
    cmp       rax,	11
    jz        L7455
    jmp       L7456
L7454:
    mov       rax,	[r12]
    mov       r10,	rsi
    add       [r10],	rax
    mov       rax,	rsi
    jmp       L7452
L7455:
    movq      XMM4,	[r12]
    mov       rax,	rsi
    movq      XMM5,	[rax]
    addsd     XMM5,	XMM4
    movq      [rax],	XMM5
    mov       rax,	rsi
    jmp       L7452
L7456:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	r13
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	13
    jnz       L7458
    mov       rax,	[r12]
    lea       r10,	[rip+cc_decls.tttarget]
    mov       r11,	r13
    movsx     r10,	word ptr[r10 + r11*2]
    lea       r11,	[rip+cc_decls.ttsize]
    mov       r11,	[r11 + r10*8]
    imul      rax,	r11
    mov       r10,	rsi
    add       [r10],	rax
    mov       rax,	rsi
    jmp       L7452
L7458:
L7453:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	r13d
    mov       rax,	rdi
L7452:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.eval_sub
cc_parse.eval_sub:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
#---------------
#PROC3
#PROC4
    mov       rax,	r13
    cmp       rax,	3
    jz        L7461
    cmp       rax,	4
    jz        L7461
    cmp       rax,	8
    jz        L7461
    cmp       rax,	9
    jz        L7461
    cmp       rax,	11
    jz        L7462
    jmp       L7463
L7461:
    mov       rax,	[r12]
    mov       r10,	rsi
    sub       [r10],	rax
    mov       rax,	rsi
    jmp       L7459
L7462:
    movq      XMM4,	[r12]
    mov       rax,	rsi
    movq      XMM5,	[rax]
    subsd     XMM5,	XMM4
    movq      [rax],	XMM5
    mov       rax,	rsi
    jmp       L7459
L7463:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	r13
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	13
    jnz       L7465
    movsxd    rax,	dword ptr[r12+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    cmp       r10,	13
    jnz       L7467
    lea       rcx,	[rip+L11318]
    call      cc_support.terror
L7467:
    mov       rax,	rsi
    jmp       L7459
L7465:
L7460:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	r13d
    mov       rax,	rdi
L7459:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.eval_mul
cc_parse.eval_mul:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
#---------------
#PROC3
#PROC4
    mov       rax,	r13
    cmp       rax,	3
    jz        L7470
    cmp       rax,	4
    jz        L7470
    cmp       rax,	2
    jz        L7470
    cmp       rax,	1
    jz        L7470
    cmp       rax,	8
    jz        L7471
    cmp       rax,	9
    jz        L7471
    cmp       rax,	7
    jz        L7471
    cmp       rax,	6
    jz        L7471
    cmp       rax,	11
    jz        L7472
    jmp       L7473
L7470:
    mov       rax,	[r12]
    mov       r11,	rsi
    mov       r10,	[r11]
    imul      r10,	rax
    mov       [r11],	r10
    mov       rax,	rsi
    jmp       L7468
L7471:
    mov       rax,	[rsi]
    mov       r10,	[r12]
    imul      rax,	r10
    mov       [rsi],	rax
    mov       rax,	rsi
    jmp       L7468
L7472:
    movq      XMM4,	[r12]
    mov       rax,	rsi
    movq      XMM5,	[rax]
    mulsd     XMM5,	XMM4
    movq      [rax],	XMM5
    mov       rax,	rsi
    jmp       L7468
L7473:
L7469:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	r13d
    mov       rax,	rdi
L7468:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.eval_div
cc_parse.eval_div:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
#---------------
#PROC3
#PROC4
    mov       rax,	r13
    cmp       rax,	3
    jz        L7476
    cmp       rax,	4
    jz        L7476
    cmp       rax,	8
    jz        L7477
    cmp       rax,	9
    jz        L7477
    cmp       rax,	11
    jz        L7478
    jmp       L7479
L7476:
    mov       rax,	[r12]
    test      rax,	rax
    jnz       L7481
    lea       rcx,	[rip+L11319]
    call      cc_support.serror
L7481:
    mov       rax,	[rsi]
    mov       r10,	[r12]
    cqo       
    idiv      r10
    mov       [rsi],	rax
    mov       rax,	rsi
    jmp       L7474
L7477:
    mov       rax,	[r12]
    test      rax,	rax
    jnz       L7483
    lea       rcx,	[rip+L11319]
    call      cc_support.serror
L7483:
    mov       rax,	[rsi]
    mov       r10,	[r12]
    xor       edx,	edx
    div       r10
    mov       [rsi],	rax
    mov       rax,	rsi
    jmp       L7474
L7478:
    movq      XMM4,	[r12]
    mov       rax,	rsi
    movq      XMM5,	[rax]
    divsd     XMM5,	XMM4
    movq      [rax],	XMM5
    mov       rax,	rsi
    jmp       L7474
L7479:
L7475:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	r13d
    mov       rax,	rdi
L7474:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.eval_rem
cc_parse.eval_rem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
#---------------
#PROC3
#PROC4
    mov       rax,	r13
    cmp       rax,	3
    jz        L7486
    cmp       rax,	4
    jnz       L7487
L7486:
    mov       rax,	[r12]
    test      rax,	rax
    jnz       L7489
    lea       rcx,	[rip+L11320]
    call      cc_support.serror
L7489:
    mov       rax,	[rsi]
    mov       r10,	[r12]
    cqo       
    idiv      r10
    xchg      rax,	rdx
    mov       [rsi],	rax
    mov       rax,	rsi
    jmp       L7484
L7487:
L7485:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       [rdi+52],	r13d
    mov       rax,	rdi
L7484:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.eval_convert
cc_parse.eval_convert:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    cmp       r8,	1
    jnz       L7492
#cc_parse.eval_convert.dosoft:
L7493:
    mov       [rcx+52],	edx
    mov       rax,	1
    jmp       L7490
L7492:
    movsxd    rax,	dword ptr[rcx+52]
    mov       rdi,	rax
    cmp       rdi,	rdx
    jnz       L7495
    mov       rax,	1
    jmp       L7490
L7495:
    mov       rax,	rdi
    cmp       rax,	3
    jz        L7497
    cmp       rax,	2
    jz        L7497
    cmp       rax,	1
    jz        L7497
    cmp       rax,	4
    jz        L7497
    cmp       rax,	8
    jz        L7498
    cmp       rax,	6
    jz        L7498
    cmp       rax,	7
    jz        L7498
    cmp       rax,	9
    jz        L7498
    cmp       rax,	11
    jz        L7499
    jmp       L7500
L7497:
    mov       rax,	rdx
    cmp       rax,	11
    jz        L7502
    cmp       rax,	10
    jz        L7502
    cmp       rax,	9
    jz        L7503
    cmp       rax,	4
    jz        L7503
    cmp       rax,	8
    jz        L7503
    cmp       rax,	3
    jz        L7503
    cmp       rax,	2
    jz        L7503
    cmp       rax,	1
    jz        L7503
    cmp       rax,	6
    jz        L7503
    cmp       rax,	7
    jz        L7503
    jmp       L7504
L7502:
    mov       rax,	[rcx]
    cvtsi2sd  XMM4,	rax
    movq      [rcx],	XMM4
    mov       [rcx+52],	edx
    mov       rax,	1
    jmp       L7490
L7503:
#cc_parse.eval_convert.dotrunc:
L7505:
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rdx
    mov       rax,	[rax + r10*8]
    cmp       rax,	1
    jz        L7507
    cmp       rax,	2
    jz        L7508
    cmp       rax,	4
    jz        L7509
    jmp       L7510
L7507:
    mov       rax,	rcx
    mov       r10,	255
    and       [rax],	r10
    lea       rax,	[rip+cc_tables.stdsigned]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7512
    mov       rax,	[rcx]
    movsx     rax,	al
    mov       [rcx],	rax
L7512:
    jmp       L7506
L7508:
    mov       rax,	rcx
    mov       r10,	65535
    and       [rax],	r10
    lea       rax,	[rip+cc_tables.stdsigned]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7514
    mov       rax,	[rcx]
    movsx     rax,	ax
    mov       [rcx],	rax
L7514:
    jmp       L7506
L7509:
    mov       rax,	[rcx]
    mov       r10,	4294967295
    and       rax,	r10
    mov       [rcx],	rax
    lea       rax,	[rip+cc_tables.stdsigned]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7516
    mov       rax,	[rcx]
    movsxd    rax,	eax
    mov       [rcx],	rax
L7516:
L7510:
L7506:
    jmp       L7493
L7504:
L7501:
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7518
    mov       [rcx+52],	edx
    mov       rax,	1
    jmp       L7490
L7518:
    jmp       L7496
L7498:
    mov       rax,	rdx
    cmp       rax,	11
    jz        L7520
    cmp       rax,	10
    jz        L7520
    cmp       rax,	9
    jz        L7521
    cmp       rax,	4
    jz        L7521
    cmp       rax,	3
    jz        L7521
    cmp       rax,	8
    jz        L7521
    cmp       rax,	9
    jz        L7521
    cmp       rax,	7
    jz        L7521
    cmp       rax,	1
    jz        L7521
    cmp       rax,	6
    jz        L7521
    cmp       rax,	2
    jz        L7521
    jmp       L7522
L7520:
    xor       eax,	eax
    jmp       L7490
    mov       [rcx+52],	edx
    mov       rax,	1
    jmp       L7490
L7521:
    jmp       L7505
L7522:
L7519:
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	rdx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7524
    mov       [rcx+52],	edx
    mov       rax,	1
    jmp       L7490
L7524:
    jmp       L7496
L7499:
    mov       rax,	rdx
    cmp       rax,	3
    jz        L7526
    cmp       rax,	4
    jz        L7526
    cmp       rax,	8
    jz        L7527
    cmp       rax,	9
    jz        L7527
    cmp       rax,	10
    jz        L7528
    jmp       L7529
L7526:
    movq      XMM4,	[rcx]
    cvttsd2si rax,	XMM4
    mov       [rcx],	rax
    mov       [rcx+52],	edx
    mov       rax,	1
    jmp       L7490
L7527:
    movq      XMM4,	[rcx]
    cvttsd2si rax,	XMM4
    mov       [rcx],	rax
    mov       [rcx+52],	edx
    mov       rax,	1
    jmp       L7490
L7528:
    mov       eax,	10
    mov       [rcx+52],	eax
    mov       rax,	1
    jmp       L7490
L7529:
L7525:
    jmp       L7496
L7500:
    movsxd    rax,	dword ptr[rcx+52]
    lea       r10,	[rip+cc_decls.ttisref]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L7531
    mov       al,	[rcx+61]
    test      al,	al
    jnz       L7533
    mov       rax,	rdx
    cmp       rax,	3
    jz        L7535
    cmp       rax,	4
    jz        L7535
    cmp       rax,	8
    jz        L7535
    cmp       rax,	9
    jnz       L7536
L7535:
    mov       [rcx+52],	edx
    mov       rax,	1
    jmp       L7490
L7536:
L7534:
L7533:
L7531:
L7496:
    xor       eax,	eax
L7490:
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc cc_parse.coercecond
cc_parse.coercecond:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rbx+52]
    mov       rdi,	rax
    cmp       rax,	3
    jz        L7537
L7539:
#cc_parse.coercecond.retry:
L7540:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	10
    jz        L7542
    cmp       rax,	11
    jz        L7542
    cmp       rax,	13
    jnz       L7543
L7542:
    jmp       L7544
L7543:
    mov       rcx,	rdi
    call      cc_lib.isintcc
    test      rax,	rax
    jz        L7546
#cc_parse.coercecond.doint:
L7544:
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L7548
    mov       rax,	[rbx]
    test      rax,	rax
    jz        L7548
    mov       rax,	1
    mov       [rbx],	rax
    jmp       L7547
L7548:
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L7549
    mov       rax,	[rbx]
    test      rax,	rax
    jnz       L7549
    xor       eax,	eax
    mov       [rbx],	rax
    jmp       L7547
L7549:
    mov       rcx,	rbx
    mov       rdx,	27
    call      cc_parse.insertunit
L7547:
    jmp       L7545
L7546:
    lea       rax,	[rip+cc_decls.ttconst]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7550
    lea       rax,	[rip+cc_decls.ttconsttype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    mov       rdi,	rax
    jmp       L7540
L7550:
    mov       rcx,	rdi
    mov       rdx,	1
    call      cc_lib.strmode
    lea       rcx,	[rip+L11321]
    mov       rdx,	rax
    call      cc_support.serror_s
L7545:
L7541:
    mov       eax,	3
    mov       [rbx+52],	eax
L7537:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.coercebasetype
cc_parse.coercebasetype:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rbx+52]
    mov       rdi,	rax
    cmp       rax,	1
    jl        L7553
    cmp       rdi,	2
    jg        L7553
    mov       rcx,	rbx
    mov       rdx,	3
    call      cc_parse.coercemode
    mov       rbx,	rax
    jmp       L7552
L7553:
    cmp       rdi,	5
    jl        L7554
    cmp       rdi,	7
    jg        L7554
    mov       rcx,	rbx
    mov       rdx,	8
    call      cc_parse.coercemode
    mov       rbx,	rax
L7554:
L7552:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.checklvalue
cc_parse.checklvalue:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	3
    jz        L7557
    cmp       rax,	52
    jz        L7558
    cmp       rax,	5
    jz        L7559
    cmp       rax,	4
    jz        L7560
    cmp       rax,	49
    jz        L7561
    cmp       rax,	1
    jz        L7562
    cmp       rax,	56
    jz        L7563
    jmp       L7564
L7557:
    jmp       L7556
L7558:
    jmp       L7556
L7559:
    test      rbx,	rbx
    jz        L7566
    jmp       L7567
L7566:
    jmp       L7556
L7560:
    mov       rax,	[rdi+16]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	3
    jz        L7569
    cmp       rax,	52
    jz        L7569
    cmp       rax,	49
    jnz       L7570
L7569:
    mov       rax,	[rdi+16]
    push      rdi
    mov       r11,	8
L11322:
    mov       r10,	[rax]
    mov       [rdi],	r10
    add       rdi,	8
    add       rax,	8
    dec       r11
    jnz       L11322
    pop       rdi
    jmp       L7568
L7570:
    lea       rcx,	[rip+L11323]
    call      cc_support.terror
L7568:
    jmp       L7556
L7561:
    jmp       L7556
L7562:
    movsxd    rax,	dword ptr[rdi+52]
    lea       r10,	[rip+cc_decls.ttisref]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jnz       L7572
    jmp       L7567
L7572:
    jmp       L7556
L7563:
    test      rbx,	rbx
    jz        L7574
    jmp       L7567
L7574:
    jmp       L7556
L7564:
#cc_parse.checklvalue.notlv:
L7567:
    xor       ecx,	ecx
    mov       rdx,	rdi
    xor       r8d,	r8d
    lea       r9,	[rip+L11324]
    call      cc_show.printunit
    movsxd    rax,	dword ptr[rdi+40]
    lea       r10,	[rip+cc_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rip+L11325]
    mov       rdx,	r10
    call      cc_support.terror_s
L7556:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createcall
cc_parse.createcall:
#PROC1
#PROC2
#?>>
    .set cc_parse.createcall.p, 64
    .set cc_parse.createcall.q, 72
    .set cc_parse.createcall.aparams, -8
    .set cc_parse.createcall.retmode, -16
    .set cc_parse.createcall.mproc, -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       [rbp+64],	rcx
    mov       [rbp+72],	rdx
#---------------
#PROC3
#PROC4
    xor       rsi,	rsi
    mov       rax,	[rbp + cc_parse.createcall.p]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	52
    jz        L7577
    cmp       rax,	3
    jz        L7578
    cmp       rax,	5
    jz        L7578
    cmp       rax,	49
    jz        L7579
    cmp       rax,	30
    jz        L7579
    cmp       rax,	31
    jz        L7579
    cmp       rax,	56
    jz        L7579
    cmp       rax,	29
    jz        L7579
    jmp       L7580
L7577:
#cc_parse.createcall.doptr:
L7581:
    mov       rax,	[rbp + cc_parse.createcall.p]
    movsxd    rax,	dword ptr[rax+52]
    mov       [rbp + cc_parse.createcall.mproc],	rax
    jmp       L7583
L7582:
    mov       rcx,	52
    mov       rdx,	[rbp + cc_parse.createcall.p]
    call      cc_lib.createunit1
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	[rbp + cc_parse.createcall.mproc]
    movsx     rax,	word ptr[rax + r10*2]
    mov       [rbp + cc_parse.createcall.mproc],	rax
    mov       eax,	[rbp + cc_parse.createcall.mproc]
    mov       [rdi+52],	eax
    mov       [rbp + cc_parse.createcall.p],	rdi
L7583:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	[rbp + cc_parse.createcall.mproc]
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	13
    jz        L7582
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	[rbp + cc_parse.createcall.mproc]
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	14
    jz        L7586
    mov       rcx,	[rbp + cc_parse.createcall.mproc]
    call      cc_lib.typename
    lea       rcx,	[rip+L11326]
    mov       rdx,	rax
    call      cc_support.serror_s
L7586:
    lea       rax,	[rip+cc_decls.ttparams]
    mov       r10,	[rbp + cc_parse.createcall.mproc]
    mov       r12,	[rax + r10*8]
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	[rbp + cc_parse.createcall.mproc]
    movsx     rax,	word ptr[rax + r10*2]
    mov       [rbp + cc_parse.createcall.retmode],	rax
    jmp       L7576
L7578:
    mov       rax,	[rbp + cc_parse.createcall.p]
    mov       rsi,	[rax]
    movzx     rax,	byte ptr[rsi+109]
    cmp       rax,	6
    jnz       L7588
    mov       r12,	[rsi+80]
    movzx     rax,	word ptr[rsi+102]
    mov       [rbp + cc_parse.createcall.retmode],	rax
    jmp       L7587
L7588:
    jmp       L7581
L7587:
    jmp       L7576
L7579:
    mov       rcx,	52
    mov       rdx,	[rbp + cc_parse.createcall.p]
    call      cc_lib.createunit1
    mov       rdi,	rax
    mov       rax,	[rbp + cc_parse.createcall.p]
    movsxd    rax,	dword ptr[rax+52]
    lea       r10,	[rip+cc_decls.tttarget]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       [rdi+52],	r10d
    mov       [rbp + cc_parse.createcall.p],	rdi
    jmp       L7581
L7580:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11327]
    call      msys.m$print_str_nf
    mov       rax,	[rbp + cc_parse.createcall.p]
    movsxd    rax,	dword ptr[rax+40]
    lea       r10,	[rip+cc_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       ecx,	ecx
    mov       rdx,	[rbp + cc_parse.createcall.p]
    xor       r8d,	r8d
    lea       r9,	[rip+L11328]
    call      cc_show.printunit
    lea       rcx,	[rip+L11329]
    call      cc_support.serror
L7576:
    movsx     rax,	word ptr[r12+20]
    mov       r14,	rax
    xor       eax,	eax
    mov       [rbp + cc_parse.createcall.aparams],	rax
    mov       rbx,	[rbp + cc_parse.createcall.q]
    jmp       L7590
L7589:
    inc       qword ptr[rbp + cc_parse.createcall.aparams]
    mov       rbx,	[rbx+8]
L7590:
    test      rbx,	rbx
    jnz       L7589
    mov       rax,	[rbp + cc_parse.createcall.aparams]
    cmp       rax,	r14
    jge       L7593
    lea       rcx,	[rip+L11330]
    call      cc_support.terror
    jmp       L7592
L7593:
    mov       rax,	[rbp + cc_parse.createcall.aparams]
    cmp       rax,	r14
    jle       L7594
    movsx     rax,	word ptr[r12+22]
    cmp       rax,	3
    jz        L7594
    movsx     rax,	word ptr[r12+22]
    cmp       rax,	1
    jz        L7594
    movsx     rax,	word ptr[r12+22]
    cmp       rax,	1
    jz        L7596
    call      msys.m$print_startcon
    mov       rcx,	[rbp + cc_parse.createcall.aparams]
    call      msys.m$print_i64_nf
    mov       rcx,	r14
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11331]
    call      cc_support.terror
L7596:
L7594:
L7592:
    mov       rbx,	[rbp + cc_parse.createcall.q]
    mov       r13,	1
    mov       rax,	[rbp + cc_parse.createcall.aparams]
    cmp       rax,	1
    jl        L7599
L7597:
    cmp       r13,	r14
    jg        L7601
    movsxd    rax,	dword ptr[r12+16]
    mov       rcx,	rbx
    mov       rdx,	rax
    call      cc_parse.coercemode_inplace
    mov       r12,	[r12+8]
    jmp       L7600
L7601:
    movsxd    rax,	dword ptr[rbx+52]
    test      rax,	rax
    jnz       L7603
    lea       rcx,	[rip+L11332]
    call      cc_support.terror
L7603:
    mov       rcx,	rbx
    call      cc_parse.coercebasetype
L7600:
    mov       rbx,	[rbx+8]
    inc       r13
    cmp       r13,	[rbp + cc_parse.createcall.aparams]
    jle       L7597
L7599:
    mov       rcx,	30
    mov       rdx,	[rbp + cc_parse.createcall.p]
    mov       r8,	[rbp + cc_parse.createcall.q]
    call      cc_lib.createunit2
    mov       rdi,	rax
    mov       eax,	[rbp + cc_parse.createcall.retmode]
    mov       [rdi+52],	eax
    mov       rcx,	rdi
    call      cc_parse.fixmemopnd
    mov       eax,	[rbp + cc_parse.createcall.aparams]
    mov       [rdi+48],	eax
    mov       rax,	rdi
L7575:
#---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.arraytopointer
cc_parse.arraytopointer:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r14,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r14+52]
    mov       rsi,	rax
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	rsi
    movsx     rax,	word ptr[rax + r10*2]
    mov       r12,	rax
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rsi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jnz       L7606
    mov       rcx,	r12
    call      cc_lib.createrefmode
    mov       r13,	rax
    movsxd    rax,	dword ptr[r14+40]
    cmp       rax,	52
    jz        L7608
    cmp       rax,	49
    jz        L7609
    jmp       L7610
L7608:
    mov       r14,	[r14+16]
    jmp       L7607
L7609:
    movsxd    rax,	dword ptr[r14]
    mov       rbx,	rax
    mov       eax,	53
    mov       [r14+40],	eax
    mov       eax,	1
    mov       [r14],	eax
    mov       rax,	[r14+16]
    mov       rcx,	55
    mov       rdx,	rax
    call      cc_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+52],	r13d
    mov       [r14+16],	rdi
    mov       rcx,	rbx
    mov       rdx,	3
    call      cc_lib.createconstunit
    mov       [r14+24],	rax
    jmp       L7607
L7610:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11333]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       ecx,	ecx
    mov       rdx,	r14
    xor       r8d,	r8d
    lea       r9,	[rip+L11334]
    call      cc_show.printunit
    lea       rcx,	[rip+L11335]
    call      cc_support.terror
L7607:
    mov       [r14+52],	r13d
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    mov       [r14+48],	eax
L7606:
    mov       rax,	r14
L7604:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createindexop
cc_parse.createindexop:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      cc_parse.createaddop
    mov       rdi,	rax
    mov       rcx,	rdi
    call      cc_parse.createptrop
L7611:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readstructdecl
cc_parse.readstructdecl:
#PROC1
#PROC2
#?>>
    .set cc_parse.readstructdecl.owner, 64
    .set cc_parse.readstructdecl.d, -8
    .set cc_parse.readstructdecl.ulist, -16
    .set cc_parse.readstructdecl.ulistx, -24
    .set cc_parse.readstructdecl.linkage, -32
    .set cc_parse.readstructdecl.offset, -40
    .set cc_parse.readstructdecl.recsize, -48
    .set cc_parse.readstructdecl.maxsize, -56
    .set cc_parse.readstructdecl.maxalignment, -64
    .set cc_parse.readstructdecl.alignment, -72
    .set cc_parse.readstructdecl.size, -80
    .set cc_parse.readstructdecl.pm, -88
    .set cc_parse.readstructdecl.fieldlist, -96
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	128
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	84
    setz      al
    movzx     eax,	al
    mov       r12,	rax
    call      cc_lex.lex
    mov       rax,	[rip+cc_decls.currproc]
    test      rax,	rax
    jz        L7614
    mov       rax,	[rip+cc_decls.currproc]
    jmp       L7613
L7614:
    mov       rax,	[rip+cc_decls.stmodule]
L7613:
    mov       rsi,	rax
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	17
    jnz       L7616
    call      cc_lib.nextautotype
    mov       rcx,	rax
    call      cc_lex.addnamestr
    mov       [rbp + cc_parse.readstructdecl.d],	rax
    jmp       L7615
L7616:
    mov       rcx,	67
    call      cc_lib.checksymbol
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       [rbp + cc_parse.readstructdecl.d],	rax
    call      cc_lex.lex
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	17
    jz        L7618
    mov       rcx,	rsi
    mov       rdx,	[rbp + cc_parse.readstructdecl.d]
    mov       r8,	2
    mov       r9,	[rip+cc_decls.currblockno]
    call      cc_lib.resolvename
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L7620
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	13
    jz        L7622
    mov       rax,	[rdi]
    lea       rcx,	[rip+L11336]
    mov       rdx,	rax
    call      cc_support.serror_s
L7622:
    movzx     rax,	word ptr[rdi+102]
    jmp       L7612
L7620:
    mov       rcx,	rsi
    mov       rdx,	[rbp + cc_parse.readstructdecl.d]
    mov       r8,	13
    call      cc_lib.createdupldef
    mov       rdi,	rax
    test      r12,	r12
    jz        L7624
    mov       rax,	19
    jmp       L7623
L7624:
    mov       rax,	18
L7623:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      cc_lib.createstructmode
    mov       [rdi+102],	ax
    mov       ax,	[rip+cc_decls.currblockno]
    mov       [rdi+96],	ax
    mov       eax,	1
    lea       r10,	[rip+cc_decls.blockcounts]
    mov       r11,	[rip+cc_decls.currblockno]
    mov       [r10 + r11*4],	eax
    movzx     rax,	word ptr[rdi+102]
    jmp       L7612
L7618:
L7615:
    mov       rcx,	rsi
    mov       rdx,	[rbp + cc_parse.readstructdecl.d]
    mov       r8,	2
    mov       r9,	[rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L7626
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	13
    jz        L7628
    mov       rax,	[rdi]
    lea       rcx,	[rip+L11336]
    mov       rdx,	rax
    call      cc_support.serror_s
L7628:
    mov       rax,	[rdi+16]
    test      rax,	rax
    jz        L7630
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11337]
    call      msys.m$print_str_nf
    mov       eax,	[rdi+92]
    and       rax,	1677215
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    mov       eax,	[rdi+92]
    sar       rax,	24
    lea       r10,	[rip+cc_decls.sourcefilenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    mov       eax,	[rdi+92]
    sar       rax,	24
    lea       r10,	[rip+cc_decls.sourcefilepaths]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rdi]
    lea       rcx,	[rip+L11338]
    mov       rdx,	rax
    call      cc_support.serror_s
L7630:
    jmp       L7625
L7626:
    mov       rcx,	rsi
    mov       rdx,	[rbp + cc_parse.readstructdecl.d]
    mov       r8,	13
    call      cc_lib.createdupldef
    mov       rdi,	rax
    test      r12,	r12
    jz        L7632
    mov       rax,	19
    jmp       L7631
L7632:
    mov       rax,	18
L7631:
    mov       rcx,	rdi
    mov       rdx,	rax
    call      cc_lib.createstructmode
    mov       [rdi+102],	ax
    mov       ax,	[rip+cc_decls.currblockno]
    mov       [rdi+96],	ax
    mov       eax,	1
    lea       r10,	[rip+cc_decls.blockcounts]
    mov       r11,	[rip+cc_decls.currblockno]
    mov       [r10 + r11*4],	eax
L7625:
    call      cc_lex.lex
    mov       rbx,	rdi
    xor       eax,	eax
    mov       [rbp + cc_parse.readstructdecl.ulistx],	rax
    mov       [rbp + cc_parse.readstructdecl.ulist],	rax
    xor       eax,	eax
    mov       [rbp + cc_parse.readstructdecl.recsize],	rax
    mov       [rbp + cc_parse.readstructdecl.maxsize],	rax
    mov       [rbp + cc_parse.readstructdecl.offset],	rax
    mov       rax,	1
    mov       [rbp + cc_parse.readstructdecl.maxalignment],	rax
    xor       eax,	eax
    mov       [rbp + cc_parse.readstructdecl.fieldlist],	rax
    mov       r14,	-1
    jmp       L7634
L7633:
    mov       rcx,	rbx
    lea       rdx,	[rbp + cc_parse.readstructdecl.linkage]
    call      cc_parse.readdeclspec
    mov       r13,	rax
L7636:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L7638
    cmp       rax,	25
    jz        L7638
    cmp       rax,	13
    jz        L7638
    cmp       rax,	10
    jz        L7639
    jmp       L7640
L7638:
    mov       rcx,	rbx
    lea       rdx,	[rbp + cc_parse.readstructdecl.d]
    mov       r8,	r13
    lea       r9,	[rbp + cc_parse.readstructdecl.pm]
    call      cc_parse.readtype
    mov       r14,	rax
    mov       rax,	[rbp + cc_parse.readstructdecl.d]
    test      rax,	rax
    jnz       L7642
    lea       rcx,	[rip+L11339]
    call      cc_support.serror
L7642:
    mov       rax,	[rbp + cc_parse.readstructdecl.linkage]
    cmp       rax,	5
    jz        L7645
    mov       rax,	[rbp + cc_parse.readstructdecl.pm]
    test      rax,	rax
    jz        L7644
L7645:
    lea       rcx,	[rip+L11340]
    call      cc_support.serror
L7644:
    mov       rcx,	rbx
    mov       rdx,	[rbp + cc_parse.readstructdecl.d]
    mov       r8,	4
    xor       r9d,	r9d
    call      cc_lib.checkdupl
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L7647
    mov       rax,	[rdi]
    lea       rcx,	[rip+L11341]
    mov       rdx,	rax
    call      cc_support.serror_s
L7647:
    mov       rax,	[rbp + cc_parse.readstructdecl.linkage]
    test      rax,	rax
    jz        L7649
    lea       rcx,	[rip+L11342]
    call      cc_support.serror
L7649:
#cc_parse.readstructdecl.addanonfield:
L7650:
    xor       ecx,	ecx
    mov       rdx,	[rbp + cc_parse.readstructdecl.d]
    mov       r8,	10
    call      cc_lib.createdupldef
    mov       [rbp + cc_parse.readstructdecl.d],	rax
    mov       ax,	r14w
    mov       r10,	[rbp + cc_parse.readstructdecl.d]
    mov       [r10+102],	ax
    lea       rcx,	[rbp + cc_parse.readstructdecl.ulist]
    lea       rdx,	[rbp + cc_parse.readstructdecl.ulistx]
    mov       r8,	[rbp + cc_parse.readstructdecl.d]
    call      cc_lib.addlistdef
    mov       rax,	[rbp + cc_parse.readstructdecl.ulist]
    mov       [rbx+16],	rax
    mov       rax,	[rbp + cc_parse.readstructdecl.ulistx]
    mov       [rbx+24],	rax
    mov       rax,	rbx
    mov       r10,	[rbp + cc_parse.readstructdecl.d]
    mov       [r10+8],	rax
    mov       rcx,	r14
    call      cc_lib.getalignment
    mov       [rbp + cc_parse.readstructdecl.alignment],	rax
    mov       rax,	[rbp + cc_parse.readstructdecl.alignment]
    cmp       rax,	[rbp + cc_parse.readstructdecl.maxalignment]
    jle       L7652
    mov       rax,	[rbp + cc_parse.readstructdecl.alignment]
    mov       [rbp + cc_parse.readstructdecl.maxalignment],	rax
L7652:
    mov       rcx,	[rbp + cc_parse.readstructdecl.offset]
    mov       rdx,	[rbp + cc_parse.readstructdecl.alignment]
    call      cc_parse.roundoffset
    mov       r10,	[rbp + cc_parse.readstructdecl.d]
    mov       [r10+88],	eax
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	r14
    mov       rax,	[rax + r10*8]
    mov       [rbp + cc_parse.readstructdecl.size],	rax
    mov       rax,	[rbp + cc_parse.readstructdecl.d]
    movsxd    rax,	dword ptr[rax+88]
    sub       rax,	[rbp + cc_parse.readstructdecl.offset]
    add       [rbp + cc_parse.readstructdecl.recsize],	rax
    mov       rax,	[rbp + cc_parse.readstructdecl.d]
    movsxd    rax,	dword ptr[rax+88]
    mov       [rbp + cc_parse.readstructdecl.offset],	rax
    lea       rcx,	[rbp + cc_parse.readstructdecl.fieldlist]
    mov       rdx,	[rbp + cc_parse.readstructdecl.d]
    mov       r8,	[rbp + cc_parse.readstructdecl.offset]
    call      cc_parse.addnewfield
    test      r12,	r12
    jz        L7654
    mov       rax,	[rbp + cc_parse.readstructdecl.maxsize]
    mov       r10,	[rbp + cc_parse.readstructdecl.size]
    cmp       rax,	r10
    cmovl     rax,	r10
    mov       [rbp + cc_parse.readstructdecl.maxsize],	rax
    jmp       L7653
L7654:
    mov       rax,	[rbp + cc_parse.readstructdecl.size]
    add       [rbp + cc_parse.readstructdecl.offset],	rax
    mov       rax,	[rbp + cc_parse.readstructdecl.size]
    add       [rbp + cc_parse.readstructdecl.recsize],	rax
L7653:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	10
    jnz       L7656
    call      cc_lex.lex
    call      cc_parse.readassignexpr
L7656:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jnz       L7659
L7658:
    call      cc_lex.lex
    jmp       L7657
L7659:
    mov       rcx,	9
    call      cc_lib.skipsymbol
    jmp       L7637
L7657:
    jmp       L7636
L7639:
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       rcx,	9
    call      cc_lib.skipsymbol
    jmp       L7637
L7640:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	r13
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	18
    jz        L7661
    cmp       rax,	19
    jnz       L7662
L7661:
    call      cc_lib.getautofieldname
    mov       [rbp + cc_parse.readstructdecl.d],	rax
    mov       r14,	r13
    jmp       L7650
L7662:
    cmp       r14,	-1
    jnz       L7664
    lea       rcx,	[rip+L11343]
    call      cc_support.serror
    jmp       L7663
L7664:
    mov       rcx,	r14
    call      cc_lib.typename
    lea       rcx,	[rip+L11344]
    mov       rdx,	rax
    call      cc_support.serror_s
L7663:
L7660:
    jmp       L7636
L7637:
L7634:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	18
    jnz       L7633
    mov       rcx,	18
    call      cc_lib.skipsymbol
    mov       rax,	[rbp + cc_parse.readstructdecl.fieldlist]
    mov       [rbx+64],	rax
    test      r12,	r12
    jz        L7666
    mov       rax,	[rbp + cc_parse.readstructdecl.maxsize]
    jmp       L7665
L7666:
    mov       rax,	[rbp + cc_parse.readstructdecl.recsize]
L7665:
    mov       rcx,	rax
    mov       rdx,	[rbp + cc_parse.readstructdecl.maxalignment]
    call      cc_parse.roundoffset
    movzx     r10,	word ptr[rbx+102]
    lea       r11,	[rip+cc_decls.ttsize]
    mov       [r11 + r10*8],	rax
    mov       al,	[rbp + cc_parse.readstructdecl.maxalignment]
    mov       [rbx+112],	al
    movzx     rax,	word ptr[rbx+102]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r10,	[r10 + rax*8]
    cmp       r10,	1
    jz        L7669
    cmp       r10,	2
    jz        L7669
    cmp       r10,	4
    jz        L7669
    cmp       r10,	8
    jnz       L7668
L7669:
    movzx     rax,	word ptr[rbx+102]
    xor       r10d,	r10d
    lea       r11,	[rip+cc_decls.ttisblock]
    mov       [r11 + rax],	r10b
L7668:
    movzx     rax,	word ptr[rbx+102]
L7612:
#---------------
    add       rsp,	128
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.checkpointertypes
cc_parse.checkpointertypes:
#PROC1
#PROC2
#?>>
    .set cc_parse.checkpointertypes.t, 80
    .set cc_parse.checkpointertypes.hard, 88
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	r15
    movsx     rax,	word ptr[rax + r10*2]
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	[rbp + cc_parse.checkpointertypes.t]
    movsx     rax,	word ptr[rax + r10*2]
    mov       rbx,	rax
    xor       r13,	r13
    xor       eax,	eax
    mov       r14,	rax
    lea       rax,	[rip+cc_decls.ttconst]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7672
    lea       rax,	[rip+cc_decls.ttconsttype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    mov       rdi,	rax
    mov       r13,	1
L7672:
    lea       rax,	[rip+cc_decls.ttconst]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7674
    lea       rax,	[rip+cc_decls.ttconsttype]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    mov       rbx,	rax
    mov       r14,	1
L7674:
    mov       rax,	[rbp + cc_parse.checkpointertypes.hard]
    test      rax,	rax
    jnz       L7676
    test      r13,	r13
    jz        L7676
    test      r14,	r14
    jnz       L7676
    call      msys.m$print_startcon
    mov       rcx,	r15
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    mov       rcx,	[rbp + cc_parse.checkpointertypes.t]
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11345]
    call      cc_support.terror
L7676:
    cmp       rdi,	rbx
    jnz       L7678
    mov       rax,	1
    jmp       L7670
L7678:
    mov       r15,	rdi
    mov       [rbp + cc_parse.checkpointertypes.t],	rbx
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	r15
    movsx     rax,	word ptr[rax + r10*2]
    mov       rsi,	rax
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	[rbp + cc_parse.checkpointertypes.t]
    movsx     rax,	word ptr[rax + r10*2]
    mov       r12,	rax
    mov       rax,	rsi
    cmp       rax,	1
    jl        L7680
    cmp       rax,	9
    jg        L7680
    mov       rax,	r12
    cmp       rax,	1
    jl        L7680
    cmp       rax,	9
    jg        L7680
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r11,	r12
    mov       r10,	[r10 + r11*8]
    cmp       rax,	r10
    jnz       L7682
    mov       rax,	1
    jmp       L7670
L7682:
L7680:
    test      rsi,	rsi
    jz        L7685
    test      r12,	r12
    jnz       L7684
L7685:
    mov       rax,	1
    jmp       L7670
L7684:
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	r15
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7687
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	[rbp + cc_parse.checkpointertypes.t]
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7687
    mov       rcx,	r15
    mov       rdx,	[rbp + cc_parse.checkpointertypes.t]
    mov       r8,	[rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L7670
L7687:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	r15
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jnz       L7688
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	[rbp + cc_parse.checkpointertypes.t]
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jnz       L7688
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	r15
    mov       rax,	[rax + r10*8]
    lea       r10,	[rip+cc_decls.ttlength]
    mov       r11,	[rbp + cc_parse.checkpointertypes.t]
    mov       r10,	[r10 + r11*8]
    cmp       rax,	r10
    jz        L7690
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	r15
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L7692
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	[rbp + cc_parse.checkpointertypes.t]
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L7692
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11346]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	1
    jmp       L7670
    xor       eax,	eax
    jmp       L7670
L7692:
L7690:
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	r15
    movsx     rax,	word ptr[rax + r10*2]
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	[rbp + cc_parse.checkpointertypes.t]
    movsx     rax,	word ptr[rax + r10*2]
    mov       rbx,	rax
    cmp       rdi,	rbx
    jnz       L7694
    mov       rax,	1
    jmp       L7670
L7694:
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7696
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7696
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	[rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L7670
L7696:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jnz       L7698
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jnz       L7698
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	[rbp + cc_parse.checkpointertypes.hard]
    call      cc_parse.checkpointertypes
    jmp       L7670
L7698:
    jmp       L7686
L7688:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	r15
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	14
    jnz       L7699
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	[rbp + cc_parse.checkpointertypes.t]
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	14
    jnz       L7699
    mov       rax,	1
    jmp       L7670
L7699:
L7686:
    xor       eax,	eax
L7670:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.comparemode
cc_parse.comparemode:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    cmp       rdi,	rbx
    jnz       L7702
    mov       rax,	1
    jmp       L7700
L7702:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jnz       L7704
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jnz       L7704
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    lea       r10,	[rip+cc_decls.tttarget]
    mov       r11,	rdi
    movsx     r10,	word ptr[r10 + r11*2]
    mov       rcx,	r10
    mov       rdx,	rax
    call      cc_parse.comparemode
    test      rax,	rax
    jnz       L7706
    xor       eax,	eax
    jmp       L7700
L7706:
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L7709
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L7709
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       r10,	[rip+cc_decls.ttlength]
    mov       r11,	rbx
    mov       r10,	[r10 + r11*8]
    cmp       rax,	r10
    jnz       L7708
L7709:
    mov       rax,	1
    jmp       L7700
L7708:
L7704:
    xor       eax,	eax
L7700:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readenumdecl
cc_parse.readenumdecl:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	17
    jnz       L7712
    mov       rcx,	rsi
    call      cc_parse.readenumnames
    mov       rax,	12
    jmp       L7710
L7712:
    mov       rcx,	67
    call      cc_lib.checksymbol
    lea       rax,	[rip+cc_decls.lx]
    mov       rdi,	[rax]
    call      cc_lex.lex
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	17
    jz        L7714
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	2
    mov       r9,	[rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L7716
    movzx     rax,	byte ptr[rbx+109]
    cmp       rax,	12
    jz        L7718
    mov       rax,	[rbx]
    lea       rcx,	[rip+L11347]
    mov       rdx,	rax
    call      cc_support.serror_s
L7718:
L7716:
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	12
    call      cc_lib.createdupldef
    mov       rbx,	rax
    mov       rcx,	rbx
    call      cc_lib.createenummode
    mov       [rbx+102],	ax
    mov       ax,	[rip+cc_decls.currblockno]
    mov       [rbx+96],	ax
    mov       eax,	1
    lea       r10,	[rip+cc_decls.blockcounts]
    mov       r11,	[rip+cc_decls.currblockno]
    mov       [r10 + r11*4],	eax
    movzx     rax,	word ptr[rbx+102]
    jmp       L7710
L7714:
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	2
    mov       r9,	[rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L7720
    movzx     rax,	byte ptr[rbx+109]
    cmp       rax,	12
    jz        L7722
    mov       rax,	[rbx]
    lea       rcx,	[rip+L11347]
    mov       rdx,	rax
    call      cc_support.serror_s
L7722:
    mov       rax,	[rbx+16]
    test      rax,	rax
    jz        L7724
    mov       rax,	[rbx]
    lea       rcx,	[rip+L11348]
    mov       rdx,	rax
    call      cc_support.serror_s
L7724:
    jmp       L7719
L7720:
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	12
    call      cc_lib.createdupldef
    mov       rbx,	rax
    mov       rcx,	rbx
    call      cc_lib.createenummode
    mov       [rbx+102],	ax
    mov       ax,	[rip+cc_decls.currblockno]
    mov       [rbx+96],	ax
    mov       eax,	1
    lea       r10,	[rip+cc_decls.blockcounts]
    mov       r11,	[rip+cc_decls.currblockno]
    mov       [r10 + r11*4],	eax
L7719:
    mov       rcx,	rsi
    call      cc_parse.readenumnames
    movzx     rax,	word ptr[rbx+102]
    mov       r10,	rbx
    lea       r11,	[rip+cc_decls.ttnamedef]
    mov       [r11 + rax*8],	r10
    movzx     rax,	word ptr[rbx+102]
L7710:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readenumnames
cc_parse.readenumnames:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       rsi,	rax
    mov       rbx,	rax
    xor       r12,	r12
    call      cc_lex.lex
    movzx     rax,	byte ptr[r13+109]
    cmp       rax,	6
    jz        L7727
    cmp       rax,	3
    jnz       L7728
L7727:
    jmp       L7726
L7728:
    mov       rax,	[rip+cc_decls.currproc]
    test      rax,	rax
    jz        L7730
    mov       rax,	[rip+cc_decls.currproc]
    jmp       L7729
L7730:
    mov       rax,	[rip+cc_decls.stmodule]
L7729:
    mov       r13,	rax
L7726:
    jmp       L7732
L7731:
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	1
    mov       r9,	[rip+cc_decls.currblockno]
    call      cc_lib.checkdupl
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L7735
    mov       rax,	[rdi]
    lea       rcx,	[rip+L11349]
    mov       rdx,	rax
    call      cc_support.serror_s
L7735:
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       rcx,	r13
    mov       rdx,	rax
    mov       r8,	11
    call      cc_lib.createdupldef
    mov       rdi,	rax
    call      cc_lex.lex
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	11
    jnz       L7737
    call      cc_lex.lex
    call      cc_parse.readconstintexpr
    mov       r12,	rax
L7737:
    mov       [rdi+88],	r12d
    mov       ax,	[rip+cc_decls.currblockno]
    mov       [rdi+96],	ax
    mov       eax,	1
    lea       r10,	[rip+cc_decls.blockcounts]
    mov       r11,	[rip+cc_decls.currblockno]
    mov       [r10 + r11*4],	eax
    inc       r12
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jnz       L7739
    call      cc_lex.lex
L7739:
L7732:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jz        L7731
    mov       rcx,	18
    call      cc_lib.skipsymbol
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createdotop
cc_parse.createdotop:
#PROC1
#PROC2
#?>>
    .set cc_parse.createdotop.p, 80
    .set cc_parse.createdotop.d, 88
    .set cc_parse.createdotop.fl, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + cc_parse.createdotop.p]
    movsxd    rax,	dword ptr[rax+52]
    mov       r13,	rax
    cmp       r15,	50
    jnz       L7742
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	r13
    mov       al,	[rax + r10]
    test      al,	al
    jnz       L7744
    lea       rcx,	[rip+L11350]
    call      cc_support.serror
L7744:
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	r13
    movsx     rax,	word ptr[rax + r10*2]
    mov       r13,	rax
L7742:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	r13
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	18
    jz        L7746
    cmp       rax,	19
    jnz       L7747
L7746:
    jmp       L7745
L7747:
    lea       rcx,	[rip+L11351]
    call      cc_support.serror
L7745:
    lea       rax,	[rip+cc_decls.ttnamedef]
    mov       r10,	r13
    mov       rsi,	[rax + r10*8]
    mov       rbx,	[rbp + cc_parse.createdotop.d]
    jmp       L7749
L7748:
    mov       rax,	[rbx+8]
    cmp       rax,	rsi
    jnz       L7752
    movsxd    rax,	dword ptr[rbx+88]
    mov       r14,	rax
    jmp       L7750
L7752:
L7749:
    mov       rax,	[rbx+40]
    mov       rbx,	rax
    test      rax,	rax
    jnz       L7748
L7750:
    test      rbx,	rbx
    jnz       L7754
    mov       r12,	[rbp + cc_parse.createdotop.d]
    jmp       L7756
L7755:
    mov       r12,	[r12+48]
L7756:
    mov       rax,	[r12+48]
    test      rax,	rax
    jnz       L7755
    mov       rax,	[rsi+64]
    mov       [rbp + cc_parse.createdotop.fl],	rax
    jmp       L7759
L7758:
    mov       rax,	[rbp + cc_parse.createdotop.fl]
    mov       rax,	[rax+8]
    cmp       rax,	r12
    jnz       L7762
    mov       rax,	[rbp + cc_parse.createdotop.fl]
    mov       rbx,	[rax]
    mov       rax,	[rbp + cc_parse.createdotop.fl]
    mov       r14,	[rax+24]
    jmp       L7760
L7762:
    mov       rax,	[rbp + cc_parse.createdotop.fl]
    mov       rax,	[rax+16]
    mov       [rbp + cc_parse.createdotop.fl],	rax
L7759:
    mov       rax,	[rbp + cc_parse.createdotop.fl]
    test      rax,	rax
    jnz       L7758
L7760:
L7754:
    test      rbx,	rbx
    jnz       L7764
    mov       rcx,	r13
    mov       rdx,	1
    call      cc_lib.strmode
    mov       r10,	[rbp + cc_parse.createdotop.d]
    mov       r10,	[r10]
    lea       rcx,	[rip+L11352]
    mov       rdx,	r10
    mov       r8,	rax
    call      cc_support.terror_ss
L7764:
    mov       rcx,	r14
    mov       rdx,	3
    call      cc_lib.createconstunit
    mov       rdi,	rax
    cmp       r15,	50
    jnz       L7766
    mov       rcx,	[rbp + cc_parse.createdotop.p]
    call      cc_parse.createptrop
    mov       [rbp + cc_parse.createdotop.p],	rax
L7766:
    mov       rcx,	49
    mov       rdx,	[rbp + cc_parse.createdotop.p]
    call      cc_lib.createunit1
    mov       [rbp + cc_parse.createdotop.p],	rax
    mov       eax,	r14d
    mov       r10,	[rbp + cc_parse.createdotop.p]
    mov       [r10],	eax
    movzx     rax,	word ptr[rbx+102]
    mov       r10,	[rbp + cc_parse.createdotop.p]
    mov       [r10+52],	eax
    mov       rcx,	[rbp + cc_parse.createdotop.p]
    call      cc_parse.arraytopointer
    mov       [rbp + cc_parse.createdotop.p],	rax
    mov       rcx,	[rbp + cc_parse.createdotop.p]
    call      cc_parse.fixmemopnd
    mov       rax,	[rbp + cc_parse.createdotop.p]
L7740:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.mulunit
cc_parse.mulunit:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    mov       rdi,	rax
    cmp       rax,	1
    jz        L7769
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L7771
    mov       rax,	[rbx]
    mov       r10,	rdi
    imul      rax,	r10
    mov       [rbx],	rax
    jmp       L7770
L7771:
    mov       rcx,	57
    mov       rdx,	rbx
    call      cc_lib.createunit1
    mov       rbx,	rax
    mov       [rbx+48],	edi
    mov       eax,	4
    mov       [rbx+52],	eax
L7770:
L7769:
    mov       rax,	rbx
L7767:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.divunit
cc_parse.divunit:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8]
    mov       rdi,	rax
    cmp       rax,	1
    jz        L7774
    movsxd    rax,	dword ptr[rbx+40]
    cmp       rax,	1
    jnz       L7776
    mov       rax,	[rbx]
    mov       r10,	rdi
    cqo       
    idiv      r10
    mov       [rbx],	rax
    jmp       L7775
L7776:
    mov       rcx,	57
    mov       rdx,	rbx
    call      cc_lib.createunit1
    mov       rbx,	rax
    mov       rax,	rdi
    neg       rax
    mov       [rbx+48],	eax
    mov       eax,	4
    mov       [rbx+52],	eax
L7775:
L7774:
    mov       rax,	rbx
L7772:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createassignopref
cc_parse.createassignopref:
#PROC1
#PROC2
#?>>
    .set cc_parse.createassignopref.q, 88
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r14,	rcx
    mov       r15,	rdx
    mov       [rbp+88],	r8
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r15+52]
    mov       rsi,	rax
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    mov       r12,	rax
    mov       rax,	[rbp + cc_parse.createassignopref.q]
    movsxd    rax,	dword ptr[rax+52]
    mov       rbx,	rax
    mov       rax,	r14
    cmp       rax,	11
    jz        L7779
    cmp       rax,	46
    jz        L7780
    cmp       rax,	47
    jz        L7781
    jmp       L7782
L7779:
    mov       rcx,	[rbp + cc_parse.createassignopref.q]
    mov       rdx,	rdi
    call      cc_parse.coercemode
    mov       [rbp + cc_parse.createassignopref.q],	rax
    mov       rcx,	11
    mov       rdx,	r15
    mov       r8,	[rbp + cc_parse.createassignopref.q]
    call      cc_lib.createunit2
    mov       r13,	rax
    jmp       L7778
L7780:
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7784
    lea       rcx,	[rip+L11353]
    call      cc_support.serror
L7784:
    mov       rcx,	[rbp + cc_parse.createassignopref.q]
    mov       rdx,	4
    call      cc_parse.coercemode
    mov       [rbp + cc_parse.createassignopref.q],	rax
    mov       rcx,	[rbp + cc_parse.createassignopref.q]
    mov       rdx,	r12
    call      cc_parse.mulunit
    mov       rcx,	61
    mov       rdx,	r15
    mov       r8,	rax
    call      cc_lib.createunit2
    mov       r13,	rax
    jmp       L7778
L7781:
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7786
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      cc_parse.comparemode
    test      rax,	rax
    jnz       L7788
    lea       rcx,	[rip+L11354]
    call      cc_support.serror
L7788:
    mov       rcx,	40
    mov       rdx,	r15
    mov       r8,	[rbp + cc_parse.createassignopref.q]
    call      cc_lib.createunit2
    mov       rcx,	rax
    mov       rdx,	r12
    call      cc_parse.divunit
    mov       r13,	rax
    mov       rsi,	3
    jmp       L7785
L7786:
    mov       rcx,	[rbp + cc_parse.createassignopref.q]
    mov       rdx,	r12
    call      cc_parse.mulunit
    mov       rcx,	62
    mov       rdx,	r15
    mov       r8,	rax
    call      cc_lib.createunit2
    mov       r13,	rax
L7785:
    jmp       L7778
L7782:
    lea       rcx,	[rip+L11355]
    call      cc_support.serror
L7778:
    mov       [r13+52],	esi
    mov       rax,	r13
L7777:
#---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.addnewfield
cc_parse.addnewfield:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    mov       rax,	[r12]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	36
    jz        L7791
    mov       rcx,	32
    call      mlib.pcm_allocz
    mov       rbx,	rax
    mov       [rbx],	r12
    jmp       L7793
L7792:
    mov       r12,	[r12+48]
L7793:
    mov       rax,	[r12+48]
    test      rax,	rax
    jnz       L7792
    mov       [rbx+8],	r12
    mov       [rbx+24],	r13
    mov       rax,	[rsi]
    mov       [rbx+16],	rax
    mov       [rsi],	rbx
    jmp       L7790
L7791:
    movzx     rax,	word ptr[r12+102]
    lea       r10,	[rip+cc_decls.ttnamedef]
    mov       r10,	[r10 + rax*8]
    mov       r10,	[r10+16]
    mov       rdi,	r10
    jmp       L7796
L7795:
    movsxd    rax,	dword ptr[rdi+88]
    mov       r10,	r13
    add       r10,	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    mov       r8,	r10
    call      cc_parse.addnewfield
    mov       rdi,	[rdi+32]
L7796:
    test      rdi,	rdi
    jnz       L7795
L7790:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.pushloop
cc_parse.pushloop:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_parse.loopindex]
    cmp       rax,	64
    jl        L7800
    lea       rcx,	[rip+L11356]
    call      cc_support.serror
L7800:
    inc       qword ptr[rip+cc_parse.loopindex]
    mov       al,	dil
    lea       r10,	[rip+cc_parse.looptypestack]
    mov       r11,	[rip+cc_parse.loopindex]
    mov       [r10 + r11-1],	al
    xor       eax,	eax
    lea       r10,	[rip+cc_parse.casevaluestack]
    mov       r11,	[rip+cc_parse.loopindex]
    mov       [r10 + r11*8-8],	rax
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_parse.poploop
cc_parse.poploop:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_parse.loopindex]
    test      rax,	rax
    jz        L7803
    dec       qword ptr[rip+cc_parse.loopindex]
    jmp       L7802
L7803:
    lea       rcx,	[rip+L11357]
    call      cc_support.serror
L7802:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_parse.addcasevalue
cc_parse.addcasevalue:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rbx,	[rip+cc_parse.loopindex]
    jmp       L7806
L7805:
    dec       rbx
L7806:
    test      rbx,	rbx
    jz        L7808
    lea       rax,	[rip+cc_parse.looptypestack]
    mov       r10,	rbx
    movzx     rax,	byte ptr[rax + r10-1]
    cmp       rax,	83
    jnz       L7805
L7808:
    test      rbx,	rbx
    jnz       L7810
    lea       rcx,	[rip+L11358]
    call      cc_support.serror
L7810:
    mov       rcx,	16
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       [rdi+8],	rsi
    lea       rax,	[rip+cc_parse.casevaluestack]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       [rdi],	rax
    mov       rax,	rdi
    lea       r10,	[rip+cc_parse.casevaluestack]
    mov       r11,	rbx
    mov       [r10 + r11*8-8],	rax
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.roundoffset
cc_parse.roundoffset:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_decls.structpadding]
    test      rax,	rax
    jz        L7813
    cmp       rdx,	1
    jnz       L7815
    mov       rax,	rcx
    jmp       L7811
L7815:
    lea       rax,	[rdx-1]
    mov       rdi,	rax
    jmp       L7817
L7816:
    inc       rcx
L7817:
    mov       rax,	rcx
    and       rax,	rdi
    jnz       L7816
L7813:
    mov       rax,	rcx
L7811:
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc cc_parse.fixmemopnd
cc_parse.fixmemopnd:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    mov       al,	[rip+cc_parse.ingeneric]
    test      al,	al
    jnz       L7819
L7821:
    movsxd    rax,	dword ptr[rcx+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rdi,	r10
    cmp       r10,	1
    jz        L7823
    cmp       r10,	2
    jz        L7823
    cmp       r10,	6
    jz        L7823
    cmp       r10,	7
    jz        L7823
    cmp       r10,	5
    jz        L7823
    jmp       L7824
L7823:
    mov       [rcx+56],	di
    mov       eax,	3
    mov       [rcx+52],	eax
L7824:
L7822:
L7819:
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc cc_parse.docast
cc_parse.docast:
#PROC1
#PROC2
#?>>
    .set cc_parse.docast.inplace, 88
    .set cc_parse.docast.$T1, -8
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r12+52]
    mov       rbx,	rax
#cc_parse.docast.retry:
L7826:
    cmp       rbx,	r13
    jnz       L7828
    mov       rax,	r12
    jmp       L7825
L7828:
    xor       rsi,	rsi
    mov       rax,	rbx
    cmp       rax,	16
    jge       L7830
    cmp       r13,	16
    jge       L7830
    lea       rax,	[rip+cc_tables.conversionops]
    mov       r10,	rbx
    shl       r10,	4
    lea       rax,	[rax + r10]
    mov       r10,	r13
    movzx     rax,	byte ptr[rax + r10]
    mov       rsi,	rax
    jmp       L7829
L7830:
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7831
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	r13
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7831
    mov       rcx,	rbx
    mov       rdx,	r13
    mov       r8,	r14
    call      cc_parse.checkpointertypes
    test      rax,	rax
    jz        L7833
    mov       [r12+52],	r13d
    mov       rax,	r12
    jmp       L7825
L7833:
    jmp       L7829
L7831:
    lea       rax,	[rip+cc_decls.ttconst]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7834
    lea       rax,	[rip+cc_decls.ttconsttype]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    mov       rbx,	rax
    jmp       L7826
L7834:
    lea       rax,	[rip+cc_decls.ttconst]
    mov       r10,	r13
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7835
    lea       rax,	[rip+cc_decls.ttconsttype]
    mov       r10,	r13
    movsx     rax,	word ptr[rax + r10*2]
    mov       r13,	rax
    jmp       L7826
L7835:
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	r13
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7836
    mov       rcx,	rbx
    call      cc_lib.isintcc
    test      rax,	rax
    jz        L7836
    movsxd    rax,	dword ptr[r12+40]
    cmp       rax,	1
    jnz       L7836
    mov       rax,	[r12]
    test      rax,	rax
    jnz       L7836
    mov       rsi,	1
L7836:
L7829:
    test      rsi,	rsi
    jnz       L7838
    test      r14,	r14
    jnz       L7840
    call      msys.m$print_startcon
    mov       rcx,	rbx
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    mov       rcx,	r13
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       ecx,	ecx
    mov       rdx,	r12
    xor       r8d,	r8d
    lea       r9,	[rip+L11359]
    call      cc_show.printunit
    mov       rcx,	r13
    call      cc_lib.typename
    mov       [rbp + cc_parse.docast.$T1],	rax
    mov       rcx,	rbx
    call      cc_lib.typename
    lea       rcx,	[rip+L11360]
    mov       rdx,	rax
    mov       r8,	[rbp + cc_parse.docast.$T1]
    call      cc_support.terror_ss
L7840:
    mov       rsi,	2
L7838:
    movsxd    rax,	dword ptr[r12+40]
    cmp       rax,	1
    jz        L7842
    cmp       rax,	5
    jz        L7843
    cmp       rax,	39
    jz        L7844
    jmp       L7845
L7842:
    mov       rcx,	r12
    mov       rdx,	r13
    mov       r8,	rsi
    call      cc_parse.eval_convert
    test      rax,	rax
    jz        L7847
    mov       rax,	r12
    jmp       L7825
L7847:
    jmp       L7841
L7843:
    mov       [r12+52],	r13d
    mov       rax,	r12
    jmp       L7825
L7844:
    mov       rax,	[r12+16]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7849
    mov       rax,	[r12+24]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7849
    mov       rax,	[r12+16]
    mov       rax,	[rax]
    mov       r10,	[r12+24]
    mov       r10,	[r10]
    add       rax,	r10
    mov       [r12],	rax
    mov       [r12+52],	r13d
    mov       eax,	1
    mov       [r12+40],	eax
    mov       rax,	r12
    jmp       L7825
L7849:
L7845:
L7841:
    mov       rax,	[rbp + cc_parse.docast.inplace]
    test      rax,	rax
    jz        L7851
    mov       rcx,	r12
    mov       rdx,	56
    call      cc_parse.insertunit
    mov       [r12+58],	r13w
    mov       rcx,	r13
    call      cc_parse.getpromotedtype
    mov       [r12+52],	eax
    mov       [r12+48],	esi
    xor       eax,	eax
    jmp       L7825
L7851:
    mov       rcx,	56
    mov       rdx,	r12
    call      cc_lib.createunit1
    mov       rdi,	rax
    mov       [rdi+48],	esi
    mov       [rdi+58],	r13w
    mov       rcx,	r13
    call      cc_parse.getpromotedtype
    mov       [rdi+52],	eax
L7850:
    mov       rax,	rdi
L7825:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.coercemode
cc_parse.coercemode:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rdi+52]
    cmp       rax,	rbx
    jnz       L7854
    mov       rax,	rdi
    jmp       L7852
L7854:
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    mov       r9,	1
    call      cc_parse.docast
    mov       rax,	rdi
L7852:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.coercemode_inplace
cc_parse.coercemode_inplace:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rdi+52]
    cmp       rax,	rbx
    jz        L7855
L7857:
    mov       rcx,	rdi
    mov       rdx,	rbx
    xor       r8d,	r8d
    mov       r9,	1
    call      cc_parse.docast
L7855:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.createsizeofop
cc_parse.createsizeofop:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
#---------------
#PROC3
#PROC4
    test      r13,	r13
    jz        L7860
    movsxd    rax,	dword ptr[r12+40]
    cmp       rax,	53
    jz        L7860
    cmp       rax,	55
    jz        L7860
    xor       ecx,	ecx
    mov       rdx,	r12
    xor       r8d,	r8d
    lea       r9,	[rip+L11361]
    call      cc_show.printunit
    lea       rcx,	[rip+L11362]
    call      cc_support.serror
L7860:
    mov       rcx,	r12
    call      cc_parse.getmemmode
    mov       rbx,	rax
    movsxd    rax,	dword ptr[r12+40]
    cmp       rax,	3
    jz        L7862
    cmp       rax,	1
    jz        L7863
    cmp       rax,	52
    jz        L7864
    cmp       rax,	53
    jz        L7865
    cmp       rax,	55
    jz        L7866
    cmp       rax,	4
    jz        L7867
    jmp       L7868
L7862:
    mov       eax,	[r12+48]
    test      eax,	eax
    jz        L7870
    mov       rax,	[r12]
    movzx     rax,	word ptr[rax+102]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r10,	[r10 + rax*8]
    movsxd    rax,	dword ptr[r12+48]
    xchg      r10,	rax
    cqo       
    idiv      r10
    mov       rsi,	rax
    jmp       L7869
L7870:
    mov       rax,	[r12]
    movzx     rax,	word ptr[rax+102]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r10,	[r10 + rax*8]
    mov       rsi,	r10
L7869:
    jmp       L7861
L7863:
    mov       rax,	rbx
    cmp       rax,	[rip+cc_decls.trefchar]
    jz        L7872
    cmp       rax,	[rip+cc_decls.trefwchar]
    jz        L7873
    jmp       L7874
L7872:
    movsxd    rax,	dword ptr[r12+48]
    inc       rax
    mov       rsi,	rax
    jmp       L7871
L7873:
    movsxd    rax,	dword ptr[r12+48]
    inc       rax
    shl       rax,	1
    mov       rsi,	rax
    jmp       L7871
L7874:
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rbx
    mov       rsi,	[rax + r10*8]
L7871:
    jmp       L7861
L7864:
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L7876
    mov       eax,	[r12+48]
    test      eax,	eax
    jz        L7876
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r10,	[r10 + rax*8]
    movsxd    rax,	dword ptr[r12+48]
    imul      r10,	rax
    mov       rsi,	r10
    jmp       L7875
L7876:
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rbx
    mov       rsi,	[rax + r10*8]
L7875:
    jmp       L7861
L7865:
    mov       eax,	[r12+48]
    test      eax,	eax
    jz        L7878
    test      r13,	r13
    jz        L7880
    movsxd    rax,	dword ptr[r12+48]
    mov       rsi,	rax
    jmp       L7879
L7880:
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r10,	[r10 + rax*8]
    movsxd    rax,	dword ptr[r12+48]
    imul      r10,	rax
    mov       rsi,	r10
L7879:
    jmp       L7877
L7878:
    jmp       L7881
L7877:
    jmp       L7861
L7866:
    mov       rax,	[r12+16]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	3
    jnz       L7883
    mov       rax,	[r12+16]
    mov       eax,	[rax+48]
    test      eax,	eax
    jz        L7883
    test      r13,	r13
    jz        L7885
    mov       rax,	[r12+16]
    movsxd    rax,	dword ptr[rax+48]
    mov       rsi,	rax
    jmp       L7884
L7885:
    mov       rax,	[r12+16]
    mov       rax,	[rax]
    movzx     rax,	word ptr[rax+102]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r10,	[r10 + rax*8]
    mov       rsi,	r10
L7884:
    jmp       L7882
L7883:
    mov       rsi,	8
L7882:
    jmp       L7861
L7867:
    mov       rax,	[r12+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      cc_parse.createsizeofop
    jmp       L7858
L7868:
#cc_parse.createsizeofop.cad1:
L7881:
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rbx
    mov       rsi,	[rax + r10*8]
L7861:
    mov       rcx,	rsi
    mov       rdx,	9
    call      cc_lib.createconstunit
    mov       rdi,	rax
    mov       rax,	rdi
L7858:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.readgeneric
cc_parse.readgeneric:
#PROC1
#PROC2
#?>>
    .set cc_parse.readgeneric.pm, -8
    .set cc_parse.readgeneric.oldingeneric, -16
    .set cc_parse.readgeneric.count, -24
    .set cc_parse.readgeneric.d, -32
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
#---------------
#PROC3
#PROC4
    call      cc_lex.lex
    mov       rcx,	13
    call      cc_lib.checksymbol
    call      cc_lex.lex
    movzx     rax,	byte ptr[rip+cc_parse.ingeneric]
    mov       [rbp + cc_parse.readgeneric.oldingeneric],	rax
    mov       al,	1
    mov       [rip+cc_parse.ingeneric],	al
    call      cc_parse.readassignexpr
    mov       rdi,	rax
    mov       al,	[rbp + cc_parse.readgeneric.oldingeneric]
    mov       [rip+cc_parse.ingeneric],	al
    movsxd    rax,	dword ptr[rdi+52]
    mov       r12,	rax
    xor       rbx,	rbx
    xor       eax,	eax
    mov       r14,	rax
    xor       eax,	eax
    mov       [rbp + cc_parse.readgeneric.count],	rax
    mov       rcx,	8
    call      cc_lib.checksymbol
L7887:
    call      cc_lex.lex
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	74
    jnz       L7891
    test      r14,	r14
    jz        L7893
    lea       rcx,	[rip+L11363]
    call      cc_support.serror
L7893:
    mov       r14,	1
    mov       rax,	[rbp + cc_parse.readgeneric.count]
    test      rax,	rax
    jnz       L7895
    mov       r13,	-1
    jmp       L7894
L7895:
    mov       r13,	-2
L7894:
    call      cc_lex.lex
    jmp       L7890
L7891:
    sub       rsp,	8
    push      0
    lea       rcx,	[rbp + cc_parse.readgeneric.d]
    xor       edx,	edx
    lea       r8,	[rbp + cc_parse.readgeneric.pm]
    xor       r9d,	r9d
    sub       rsp,	32
    call      cc_parse.readcasttype
    add       rsp,	48
    mov       r13,	rax
L7890:
    mov       rcx,	10
    call      cc_lib.checksymbol
    call      cc_lex.lex
    call      cc_parse.readassignexpr
    mov       rsi,	rax
    cmp       r13,	-1
    jz        L7898
    cmp       r13,	r12
    jnz       L7897
L7898:
    mov       rbx,	rsi
    inc       qword ptr[rbp + cc_parse.readgeneric.count]
L7897:
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	8
    jz        L7887
    mov       rcx,	14
    call      cc_lib.checksymbol
    call      cc_lex.lex
    test      rbx,	rbx
    jnz       L7900
    lea       rcx,	[rip+L11364]
    call      cc_support.serror
L7900:
    mov       rax,	[rbp + cc_parse.readgeneric.count]
    cmp       rax,	1
    jle       L7902
    lea       rcx,	[rip+L11365]
    call      cc_support.serror
L7902:
    mov       rax,	rbx
L7886:
#---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_parse.getmemmode
cc_parse.getmemmode:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       ax,	[rcx+56]
    test      ax,	ax
    jz        L7905
    movsx     rax,	word ptr[rcx+56]
    jmp       L7904
L7905:
    movsxd    rax,	dword ptr[rcx+52]
L7904:
L7903:
#---------------
    ret       
# End 
# Proc cc_parse.getpromotedtype
cc_parse.getpromotedtype:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    test      rcx,	rcx
    jnz       L7908
    xor       eax,	eax
    jmp       L7906
L7908:
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rcx
    mov       rax,	[rax + r10*8]
    cmp       rax,	4
    jge       L7910
    mov       rax,	3
    jmp       L7906
L7910:
    mov       rax,	rcx
L7906:
#---------------
    ret       
# End 
# Proc cc_genpcl.codegen_pcl
cc_genpcl.codegen_pcl:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rip+cc_cli.fverbose]
    cmp       rax,	3
    jnz       L7913
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11366]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L7913:
    xor       ecx,	ecx
    mov       rdx,	[rip+cc_decls.nunits]
    call      pc_api.pcl_start
    call      cc_genpcl.dolibs
    lea       rcx,	[rip+L11367]
    call      pc_api.gencomment
    mov       rax,	[rip+cc_decls.stmodule]
    mov       rdi,	[rax+16]
    jmp       L7915
L7914:
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	7
    jz        L7918
    cmp       rax,	6
    jz        L7919
    jmp       L7920
L7918:
    mov       rcx,	rdi
    call      cc_genpcl.dostaticvar
    jmp       L7917
L7919:
    movzx     rax,	byte ptr[rdi+110]
    cmp       rax,	4
    jz        L7922
    cmp       rax,	2
    jz        L7923
    jmp       L7924
L7922:
    mov       rax,	[rdi+72]
    test      rax,	rax
    jnz       L7926
    mov       al,	3
    mov       [rdi+110],	al
L7926:
    jmp       L7921
L7923:
    mov       rax,	[rdi+72]
    test      rax,	rax
    jnz       L7928
    mov       rax,	[rdi]
    lea       rcx,	[rip+L11368]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      cc_support.gerror_s
L7928:
L7924:
L7921:
    mov       rbx,	[rdi+16]
    jmp       L7930
L7929:
    movzx     rax,	byte ptr[rbx+109]
    cmp       rax,	7
    jz        L7933
    cmp       rax,	8
    jz        L7934
    jmp       L7935
L7933:
    mov       rcx,	rbx
    call      cc_genpcl.dostaticvar
    jmp       L7932
L7934:
    mov       rax,	[rbx+72]
    test      rax,	rax
    jz        L7937
    mov       rax,	[rbx+72]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	28
    jz        L7940
    movzx     rax,	word ptr[rbx+102]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    cmp       r10,	17
    jnz       L7939
    mov       rax,	[rbx+72]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L7939
L7940:
    mov       rcx,	rbx
    call      cc_genpcl.dostaticvar
L7939:
L7937:
L7935:
L7932:
    mov       rbx,	[rbx+32]
L7930:
    test      rbx,	rbx
    jnz       L7929
L7920:
L7917:
    mov       rdi,	[rdi+32]
L7915:
    test      rdi,	rdi
    jnz       L7914
    lea       rcx,	[rip+L11369]
    call      pc_api.gencomment
    mov       rax,	[rip+cc_decls.stmodule]
    mov       rdi,	[rax+16]
    jmp       L7942
L7941:
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	6
    jnz       L7946
L7945:
    mov       rax,	[rdi+72]
    test      rax,	rax
    jz        L7948
    mov       rcx,	rdi
    call      cc_genpcl.genprocdef
L7948:
L7946:
L7944:
    mov       rdi,	[rdi+32]
L7942:
    test      rdi,	rdi
    jnz       L7941
    call      pc_api.pcl_end
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_genpcl.genprocdef
cc_genpcl.genprocdef:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    xor       rsi,	rsi
    mov       rax,	[r12]
    mov       rcx,	rax
    lea       rdx,	[rip+L11370]
    call      mlib.eqstring
    test      rax,	rax
    jz        L7951
    mov       rsi,	1
    lea       rax,	[r12+108]
    or        byte ptr[rax],	8
L7951:
    mov       [rip+cc_decls.currproc],	r12
    mov       rcx,	r12
    call      cc_libpcl.getpsymbol
    mov       r10,	rax
    mov       rbx,	r10
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	rsi
    xor       r9d,	r9d
    call      pc_api.pc_defproc
    mov       rax,	[r12+80]
    movsx     rax,	word ptr[rax+22]
    cmp       rax,	3
    setz      al
    movzx     eax,	al
    mov       [rbx+113],	al
    mov       rdi,	[r12+16]
    jmp       L7955
L7952:
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	9
    jz        L7957
    cmp       rax,	8
    jz        L7958
    jmp       L7959
L7957:
    mov       rcx,	rdi
    call      cc_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.pc_addparam
    jmp       L7956
L7958:
    mov       rcx,	rdi
    call      cc_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.pc_addlocal
L7959:
L7956:
    mov       rdi,	[rdi+32]
L7955:
    test      rdi,	rdi
    jnz       L7952
    call      cc_libpcl.createfwdlabel
    mov       [rip+cc_genpcl.retindex],	rax
    lea       rcx,	[rip+L11371]
    call      pc_api.gencomment
    mov       rcx,	[r12+72]
    call      cc_blockpcl.do_stmt
    lea       rcx,	[rip+L11371]
    call      pc_api.gencomment
    mov       rcx,	[rip+cc_genpcl.retindex]
    call      cc_libpcl.definefwdlabel
    test      rsi,	rsi
    jz        L7961
    xor       ecx,	ecx
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      cc_libpcl.setmode
    mov       rcx,	32
    xor       edx,	edx
    call      pc_api.pc_gen
L7961:
    movzx     rax,	word ptr[r12+102]
    test      rax,	rax
    jz        L7963
    mov       rax,	23
    jmp       L7962
L7963:
    mov       rax,	20
L7962:
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    movzx     rax,	word ptr[r12+102]
    mov       rcx,	rax
    call      cc_libpcl.setmode
    call      pc_api.pc_endproc
    lea       rcx,	[rip+L11372]
    call      pc_api.gencomment
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_genpcl.dostaticvar
cc_genpcl.dostaticvar:
#PROC1
#PROC2
#?>>
    .set cc_genpcl.dostaticvar.str, -256
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[r12+110]
    cmp       rax,	3
    jz        L7964
L7966:
    movzx     rax,	word ptr[r12+102]
    mov       rcx,	rax
    call      cc_lib.getalignment
    mov       rdi,	rax
    mov       rax,	[r12+72]
    test      rax,	rax
    jz        L7968
    movzx     rax,	byte ptr[r12+109]
    cmp       rax,	8
    jnz       L7970
    lea       rcx,	[rbp + cc_genpcl.dostaticvar.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L11373]
    call      msys.m$print_setfmt
    mov       rax,	[r12+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    mov       rcx,	[r12]
    call      msys.m$print_str_nf
    movzx     rax,	word ptr[r12+96]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + cc_genpcl.dostaticvar.str]
    call      cc_lex.addnamestr
    xor       ecx,	ecx
    mov       rdx,	rax
    mov       r8,	7
    call      cc_lib.createdupldef
    mov       rbx,	rax
    mov       rcx,	rbx
    call      cc_libpcl.getpsymbol
    mov       rsi,	rax
    mov       [r12+114],	rsi
    mov       rcx,	rsi
    call      pc_api.genmem
    mov       rcx,	123
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L7969
L7970:
    mov       rcx,	r12
    call      cc_libpcl.genmem_d
    mov       rcx,	123
    mov       rdx,	rax
    call      pc_api.pc_gen
L7969:
    movzx     rax,	word ptr[r12+102]
    mov       rcx,	rax
    call      cc_libpcl.setmode
    mov       rcx,	rdi
    call      pc_api.pc_setalign
    mov       rax,	[r12+72]
    mov       rcx,	rax
    mov       rdx,	1
    mov       r8,	1
    xor       r9d,	r9d
    call      cc_genpcl.genidata
    jmp       L7967
L7968:
    mov       rcx,	r12
    call      cc_libpcl.genmem_d
    mov       rcx,	124
    mov       rdx,	rax
    call      pc_api.pc_gen
    movzx     rax,	word ptr[r12+102]
    mov       rcx,	rax
    call      cc_libpcl.setmode
    mov       rcx,	rdi
    call      pc_api.pc_setalign
L7967:
L7964:
#---------------
    add       rsp,	288
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_genpcl.genidata
cc_genpcl.genidata:
#PROC1
#PROC2
#?>>
    .set cc_genpcl.genidata.p, 64
    .set cc_genpcl.genidata.doterm, 72
    .set cc_genpcl.genidata.am, 80
    .set cc_genpcl.genidata.offset, 88
    .set cc_genpcl.genidata.size, -8
    .set cc_genpcl.genidata.padding, -16
    .set cc_genpcl.genidata.isunion, -24
    .set cc_genpcl.genidata.q, -32
    .set cc_genpcl.genidata.a, -40
    .set cc_genpcl.genidata.b, -48
    .set cc_genpcl.genidata.d, -56
    .set cc_genpcl.genidata.sx, -64
    .set cc_genpcl.genidata.str, -320
    .set cc_genpcl.genidata.str2, -336
    .set cc_genpcl.genidata.av_1, -344
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	384
    mov       [rbp+64],	rcx
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    movsxd    rax,	dword ptr[rax+52]
    mov       rdi,	rax
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    mov       rax,	[rax+16]
    mov       [rbp + cc_genpcl.genidata.a],	rax
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    mov       rax,	[rax+24]
    mov       [rbp + cc_genpcl.genidata.b],	rax
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	28
    jz        L7973
    cmp       rax,	1
    jz        L7974
    cmp       rax,	3
    jz        L7975
    cmp       rax,	5
    jz        L7975
    cmp       rax,	39
    jz        L7976
    cmp       rax,	55
    jz        L7977
    cmp       rax,	53
    jz        L7978
    cmp       rax,	54
    jz        L7978
    cmp       rax,	56
    jz        L7979
    jmp       L7980
L7973:
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    movsxd    rax,	dword ptr[rax+48]
    mov       rsi,	rax
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jnz       L7982
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	rdi
    mov       rbx,	[rax + r10*8]
    mov       rax,	[rbp + cc_genpcl.genidata.a]
    mov       [rbp + cc_genpcl.genidata.q],	rax
    mov       r12,	1
    cmp       rsi,	1
    jl        L7985
L7983:
    mov       rcx,	[rbp + cc_genpcl.genidata.q]
    mov       rdx,	1
    mov       r8,	1
    xor       r9d,	r9d
    call      cc_genpcl.genidata
    mov       rax,	[rbp + cc_genpcl.genidata.q]
    mov       rax,	[rax+8]
    mov       [rbp + cc_genpcl.genidata.q],	rax
    inc       r12
    cmp       r12,	rsi
    jle       L7983
L7985:
    cmp       rsi,	rbx
    jge       L7987
    mov       rax,	rbx
    sub       rax,	rsi
    lea       r10,	[rip+cc_decls.tttarget]
    mov       r11,	rdi
    movsx     r10,	word ptr[r10 + r11*2]
    lea       r11,	[rip+cc_decls.ttsize]
    mov       r11,	[r11 + r10*8]
    imul      rax,	r11
    mov       rcx,	rax
    call      cc_genpcl.doresb
L7987:
    jmp       L7981
L7982:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	19
    setz      al
    movzx     eax,	al
    mov       [rbp + cc_genpcl.genidata.isunion],	rax
    lea       rax,	[rip+cc_decls.ttnamedef]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax+16]
    mov       [rbp + cc_genpcl.genidata.d],	rax
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       [rbp + cc_genpcl.genidata.size],	rax
    xor       eax,	eax
    mov       r14,	rax
    mov       r13,	rax
    mov       rax,	[rbp + cc_genpcl.genidata.a]
    mov       [rbp + cc_genpcl.genidata.q],	rax
    mov       r12,	1
    cmp       rsi,	1
    jl        L7990
L7988:
    mov       rcx,	[rbp + cc_genpcl.genidata.q]
    xor       edx,	edx
    mov       r8,	1
    xor       r9d,	r9d
    call      cc_genpcl.genidata
    mov       rax,	[rbp + cc_genpcl.genidata.q]
    movsxd    rax,	dword ptr[rax+52]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r10,	[r10 + rax*8]
    add       r13,	r10
    mov       rax,	[rbp + cc_genpcl.genidata.d]
    mov       rax,	[rax+32]
    mov       [rbp + cc_genpcl.genidata.d],	rax
    mov       rax,	[rbp + cc_genpcl.genidata.d]
    test      rax,	rax
    jz        L7992
    mov       rax,	[rbp + cc_genpcl.genidata.isunion]
    test      rax,	rax
    jnz       L7992
    mov       rax,	[rbp + cc_genpcl.genidata.d]
    movsxd    rax,	dword ptr[rax+88]
    mov       r14,	rax
    jmp       L7991
L7992:
    mov       r14,	[rbp + cc_genpcl.genidata.size]
L7991:
    mov       rax,	r14
    sub       rax,	r13
    mov       [rbp + cc_genpcl.genidata.padding],	rax
    mov       rax,	[rbp + cc_genpcl.genidata.padding]
    cmp       rax,	0
    jle       L7994
    mov       rax,	r14
    sub       rax,	r13
    mov       rcx,	rax
    call      cc_genpcl.doresb
    mov       r13,	r14
L7994:
    mov       rax,	[rbp + cc_genpcl.genidata.q]
    mov       rax,	[rax+8]
    mov       [rbp + cc_genpcl.genidata.q],	rax
    inc       r12
    cmp       r12,	rsi
    jle       L7988
L7990:
    cmp       r14,	[rbp + cc_genpcl.genidata.size]
    jge       L7996
    mov       rax,	[rbp + cc_genpcl.genidata.size]
    sub       rax,	r14
    mov       rcx,	rax
    call      cc_genpcl.doresb
L7996:
L7981:
    jmp       L7971
L7974:
    mov       rcx,	rdi
    call      cc_lib.isintcc
    test      rax,	rax
    jnz       L7999
    mov       rcx,	rdi
    call      cc_lib.isrealcc
    test      rax,	rax
    jz        L7998
L7999:
    cmp       rdi,	10
    jnz       L8001
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    movq      XMM4,	[rax]
    cvtsd2ss  XMM4,	XMM4
    movd      [rbp + cc_genpcl.genidata.sx],	XMM4
    mov       eax,	[rbp + cc_genpcl.genidata.sx]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L8000
L8001:
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
L8000:
    mov       rcx,	rdi
    call      cc_libpcl.setmode
    jmp       L7997
L7998:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	13
    jnz       L8002
    xor       eax,	eax
    mov       [rbp + cc_genpcl.genidata.padding],	rax
#cc_genpcl.genidata.doref:
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    mov       rax,	[rax]
    test      rax,	rax
    jnz       L8005
    xor       ecx,	ecx
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L8004
L8005:
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    mov       al,	[rax+61]
    test      al,	al
    jz        L8006
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      pc_api.genstring
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L8004
L8006:
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    mov       al,	[rax+62]
    test      al,	al
    jz        L8007
    lea       rcx,	[rip+L11374]
    xor       edx,	edx
    call      cc_support.gerror
    mov       rcx,	[rbp + cc_genpcl.genidata.padding]
    call      cc_genpcl.doresb
    jmp       L8004
L8007:
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
L8004:
    mov       rcx,	rdi
    call      cc_libpcl.setmode
    jmp       L7997
L8002:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jnz       L8008
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       r10,	[rbp + cc_genpcl.genidata.p]
    movsxd    r10,	dword ptr[r10+48]
    sub       rax,	r10
    lea       r10,	[rip+cc_decls.tttarget]
    mov       r11,	rdi
    movsx     r10,	word ptr[r10 + r11*2]
    lea       r11,	[rip+cc_decls.ttsize]
    mov       r11,	[r11 + r10*8]
    imul      rax,	r11
    mov       [rbp + cc_genpcl.genidata.padding],	rax
    mov       r12,	1
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    movsxd    rax,	dword ptr[rax+48]
    mov       [rbp + cc_genpcl.genidata.av_1],	rax
    mov       rax,	[rbp + cc_genpcl.genidata.av_1]
    cmp       rax,	1
    jl        L8011
L8009:
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    mov       rax,	[rax]
    mov       r10,	r12
    lea       rax,	[rax + r10]
    sub       rax,	1
    movzx     rax,	byte ptr[rax]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	6
    call      cc_libpcl.setmode
    inc       r12
    cmp       r12,	[rbp + cc_genpcl.genidata.av_1]
    jle       L8009
L8011:
    mov       rcx,	[rbp + cc_genpcl.genidata.padding]
    call      cc_genpcl.doresb
    jmp       L7997
L8008:
    call      msys.m$print_startcon
    mov       rcx,	rdi
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11375]
    xor       edx,	edx
    call      cc_support.gerror
L7997:
    jmp       L7971
L7975:
    mov       rax,	[rbp + cc_genpcl.genidata.p]
    mov       rax,	[rax]
    mov       [rbp + cc_genpcl.genidata.d],	rax
    mov       rax,	[rbp + cc_genpcl.genidata.d]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	7
    jz        L8013
    cmp       rax,	6
    jnz       L8014
L8013:
    mov       rcx,	[rbp + cc_genpcl.genidata.d]
    call      cc_libpcl.genmemaddr_d
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	9
    call      cc_libpcl.setmode
    jmp       L8012
L8014:
    lea       rcx,	[rip+L11376]
    mov       rdx,	[rbp + cc_genpcl.genidata.p]
    call      cc_support.gerror
L8012:
    jmp       L7971
L7976:
    mov       rax,	[rbp + cc_genpcl.genidata.a]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	3
    jnz       L8016
    mov       rax,	[rbp + cc_genpcl.genidata.b]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L8016
    mov       rax,	[rbp + cc_genpcl.genidata.a]
    mov       rax,	[rax]
    mov       [rbp + cc_genpcl.genidata.d],	rax
    mov       rax,	[rbp + cc_genpcl.genidata.d]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	7
    jnz       L8019
L8018:
    lea       rcx,	[rbp + cc_genpcl.genidata.str]
    lea       rdx,	[rip+L11377]
    call      strcpy
    mov       rax,	[rbp + cc_genpcl.genidata.d]
    movzx     rax,	byte ptr[rax+110]
    cmp       rax,	1
    jnz       L8021
    mov       rax,	[rip+cc_decls.currproc]
    mov       rax,	[rax]
    lea       rcx,	[rbp + cc_genpcl.genidata.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rbp + cc_genpcl.genidata.str]
    lea       rdx,	[rip+L11378]
    call      strcat
L8021:
    mov       rax,	[rbp + cc_genpcl.genidata.d]
    mov       rax,	[rax]
    lea       rcx,	[rbp + cc_genpcl.genidata.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rbp + cc_genpcl.genidata.str]
    lea       rdx,	[rip+L11379]
    call      strcat
    mov       rax,	[rbp + cc_genpcl.genidata.b]
    mov       rax,	[rax]
    mov       rcx,	rax
    lea       rdx,	[rbp + cc_genpcl.genidata.str2]
    call      msys.getstrint
    lea       rcx,	[rbp + cc_genpcl.genidata.str]
    lea       rdx,	[rbp + cc_genpcl.genidata.str2]
    call      strcat
    lea       rcx,	[rbp + cc_genpcl.genidata.str]
    call      pc_api.genname
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L8017
L8019:
    lea       rcx,	[rip+L11380]
    xor       edx,	edx
    call      cc_support.gerror
L8017:
    jmp       L8015
L8016:
    mov       rax,	[rbp + cc_genpcl.genidata.a]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L8022
    mov       rax,	[rbp + cc_genpcl.genidata.b]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jnz       L8022
    mov       rax,	[rbp + cc_genpcl.genidata.a]
    movsxd    rax,	dword ptr[rax+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    cmp       r10,	13
    jnz       L8022
    lea       rcx,	[rbp + cc_genpcl.genidata.str]
    call      msys.m$print_startstr
    mov       rax,	[rbp + cc_genpcl.genidata.a]
    mov       rcx,	[rax]
    call      msys.m$print_i64_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11381]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rax,	[rbp + cc_genpcl.genidata.b]
    mov       rcx,	[rax]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + cc_genpcl.genidata.str]
    call      pc_api.genname
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L8015
L8022:
    lea       rcx,	[rip+L11382]
    xor       edx,	edx
    call      cc_support.gerror
L8015:
    jmp       L7971
L7977:
    mov       rax,	[rbp + cc_genpcl.genidata.a]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	52
    jnz       L8024
    mov       rax,	[rbp + cc_genpcl.genidata.a]
    mov       rax,	[rax+16]
    mov       rcx,	rax
    mov       rdx,	1
    mov       r8,	1
    mov       r9,	[rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
    jmp       L8023
L8024:
    mov       rcx,	[rbp + cc_genpcl.genidata.a]
    mov       rdx,	1
    xor       r8d,	r8d
    mov       r9,	[rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
L8023:
    jmp       L7972
L7978:
    mov       rax,	[rbp + cc_genpcl.genidata.b]
    movsxd    rax,	dword ptr[rax+40]
    cmp       rax,	1
    jz        L8026
    lea       rcx,	[rip+L11383]
    xor       edx,	edx
    call      cc_support.gerror
L8026:
    mov       rax,	[rbp + cc_genpcl.genidata.b]
    mov       rax,	[rax]
    mov       r10,	[rbp + cc_genpcl.genidata.p]
    movsxd    r10,	dword ptr[r10]
    imul      rax,	r10
    add       rax,	[rbp + cc_genpcl.genidata.offset]
    mov       rcx,	[rbp + cc_genpcl.genidata.a]
    mov       rdx,	1
    mov       r8,	1
    mov       r9,	rax
    call      cc_genpcl.genidata
    jmp       L7972
L7979:
    mov       rcx,	[rbp + cc_genpcl.genidata.a]
    mov       rdx,	1
    mov       r8,	1
    mov       r9,	[rbp + cc_genpcl.genidata.offset]
    call      cc_genpcl.genidata
    jmp       L7972
L7980:
    xor       ecx,	ecx
    mov       rdx,	[rbp + cc_genpcl.genidata.p]
    xor       r8d,	r8d
    lea       r9,	[rip+L11384]
    call      cc_show.printunit
    lea       rcx,	[rip+L11385]
    mov       rdx,	[rbp + cc_genpcl.genidata.p]
    call      cc_support.gerror
L7972:
L7971:
#---------------
    add       rsp,	384
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_genpcl.doresb
cc_genpcl.doresb:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    jmp       L8029
L8028:
    xor       ecx,	ecx
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rax,	8
    sub       rbx,	rax
    mov       rcx,	9
    call      cc_libpcl.setmode
L8029:
    cmp       rbx,	8
    jge       L8028
    mov       rdi,	rbx
    cmp       rdi,	0
    jle       L8033
L8031:
    xor       ecx,	ecx
    call      pc_api.genint
    mov       rcx,	125
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	6
    call      cc_libpcl.setmode
    dec       rdi
    jnz       L8031
L8033:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_genpcl.pushint
cc_genpcl.pushint:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_genpcl.dolibs
cc_genpcl.dolibs:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    mov       rax,	[rip+cc_decls.nlibfiles]
    cmp       rax,	1
    jl        L8038
L8036:
    lea       rax,	[rip+cc_decls.libfiles]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8]
    call      pc_api.pc_addplib
    inc       rdi
    cmp       rdi,	[rip+cc_decls.nlibfiles]
    jle       L8036
L8038:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.do_stmt
cc_blockpcl.do_stmt:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    test      r12,	r12
    jnz       L8041
    jmp       L8039
L8041:
    mov       rdi,	[rip+cc_decls.clineno]
    mov       eax,	[r12+44]
    mov       [rip+cc_decls.clineno],	rax
    movzx     rax,	byte ptr[r12+60]
    mov       [rip+cc_decls.cfileno],	rax
    mov       rax,	[rip+cc_decls.cfileno]
    shl       rax,	24
    add       rax,	[rip+cc_decls.clineno]
    mov       [rip+pc_decls.mmpos],	rax
    mov       rbx,	[r12+16]
    mov       rsi,	[r12+24]
    movsxd    rax,	dword ptr[r12+40]
    sub       rax,	6
    cmp       rax,	69
    jae       L8044
    lea       r10,	[rip+L8043]
    jmp       [r10 + rax*8]
    .data
L8043:
    .quad     L8045
    .quad     L8044
    .quad     L8049
    .quad     L8051
    .quad     L8044
    .quad     L8052
    .quad     L8053
    .quad     L8054
    .quad     L8055
    .quad     L8056
    .quad     L8057
    .quad     L8058
    .quad     L8059
    .quad     L8060
    .quad     L8062
    .quad     L8063
    .quad     L8064
    .quad     L8061
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8079
    .quad     L8050
    .quad     L8053
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8044
    .quad     L8065
    .quad     L8066
    .quad     L8067
    .quad     L8068
    .quad     L8071
    .quad     L8072
    .quad     L8073
    .quad     L8074
    .quad     L8075
    .quad     L8076
    .quad     L8077
    .quad     L8078
    .quad     L8077
    .quad     L8078
    .text
L8045:
    jmp       L8047
L8046:
    mov       rcx,	rbx
    call      cc_blockpcl.do_stmt
    mov       rbx,	[rbx+8]
L8047:
    test      rbx,	rbx
    jnz       L8046
    jmp       L8042
L8049:
    mov       rcx,	[r12]
    call      cc_blockpcl.do_decl
    jmp       L8042
L8050:
    mov       rcx,	r12
    mov       rdx,	rbx
    mov       r8,	rsi
    xor       r9d,	r9d
    call      cc_blockpcl.dx_call
    jmp       L8042
L8051:
    mov       rcx,	r12
    mov       rdx,	rbx
    call      cc_blockpcl.do_return
    jmp       L8042
L8052:
    mov       rcx,	rbx
    mov       rdx,	rsi
    xor       r8d,	r8d
    call      cc_blockpcl.do_assign
    jmp       L8042
L8053:
    mov       rax,	[r12+32]
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	rax
    call      cc_blockpcl.do_if
    jmp       L8042
L8054:
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      cc_blockpcl.do_for
    jmp       L8042
L8055:
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      cc_blockpcl.do_while
    jmp       L8042
L8056:
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      cc_blockpcl.do_dowhile
    jmp       L8042
L8057:
    mov       rcx,	[r12]
    call      cc_blockpcl.do_goto
    jmp       L8042
L8058:
    mov       rcx,	[r12]
    call      cc_blockpcl.do_labeldef
    mov       rcx,	rbx
    call      cc_blockpcl.do_stmt
    jmp       L8042
L8059:
    mov       rcx,	r12
    mov       rdx,	rbx
    call      cc_blockpcl.do_casestmt
    jmp       L8042
L8060:
    mov       al,	1
    mov       [rip+cc_blockpcl.sw_defaultseen],	al
    mov       rcx,	[rip+cc_blockpcl.sw_defaultlabel]
    call      pc_api.genlabel
    mov       rcx,	127
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      cc_blockpcl.do_stmt
    jmp       L8042
L8061:
    mov       rcx,	[rip+cc_blockpcl.sw_breaklabel]
    call      cc_blockpcl.genjumpl
    jmp       L8042
L8062:
    lea       rax,	[rip+cc_blockpcl.breakstack]
    mov       r10,	[rip+cc_blockpcl.loopindex]
    mov       rcx,	[rax + r10*8-8]
    call      cc_blockpcl.genjumpl
    jmp       L8042
L8063:
    lea       rax,	[rip+cc_blockpcl.continuestack]
    mov       r10,	[rip+cc_blockpcl.loopindex]
    mov       rcx,	[rax + r10*8-8]
    call      cc_blockpcl.genjumpl
    jmp       L8042
L8064:
    mov       rcx,	r12
    mov       rdx,	rbx
    mov       r8,	rsi
    call      cc_blockpcl.do_switch
    jmp       L8042
L8065:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	90
    xor       r9d,	r9d
    call      cc_blockpcl.dx_binto
    jmp       L8042
L8066:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	91
    xor       r9d,	r9d
    call      cc_blockpcl.dx_binto
    jmp       L8042
L8067:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	92
    xor       r9d,	r9d
    call      cc_blockpcl.dx_binto
    jmp       L8042
L8068:
    movsxd    rax,	dword ptr[rbx+52]
    mov       rcx,	rax
    call      cc_lib.isrealcc
    test      rax,	rax
    jz        L8070
    mov       rax,	93
    jmp       L8069
L8070:
    mov       rax,	94
L8069:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	rax
    xor       r9d,	r9d
    call      cc_blockpcl.dx_binto
    jmp       L8042
L8071:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	95
    xor       r9d,	r9d
    call      cc_blockpcl.dx_binto
    jmp       L8042
L8072:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	96
    xor       r9d,	r9d
    call      cc_blockpcl.dx_binto
    jmp       L8042
L8073:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	97
    xor       r9d,	r9d
    call      cc_blockpcl.dx_binto
    jmp       L8042
L8074:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	98
    xor       r9d,	r9d
    call      cc_blockpcl.dx_binto
    jmp       L8042
L8075:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	99
    xor       r9d,	r9d
    call      cc_blockpcl.dx_binto
    jmp       L8042
L8076:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	100
    xor       r9d,	r9d
    call      cc_blockpcl.dx_binto
    jmp       L8042
L8077:
    mov       rcx,	rbx
    mov       rdx,	84
    call      cc_blockpcl.do_preincr
    jmp       L8042
L8078:
    mov       rcx,	rbx
    mov       rdx,	85
    call      cc_blockpcl.do_preincr
    jmp       L8042
L8079:
    jmp       L8081
L8080:
    mov       rcx,	rbx
    call      cc_blockpcl.do_stmt
    mov       rbx,	[rbx+8]
L8081:
    test      rbx,	rbx
    jnz       L8080
    jmp       L8042
L8044:
    mov       rcx,	r12
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	11
    xor       edx,	edx
    call      pc_api.pc_gen
    test      rbx,	rbx
    jz        L8084
    mov       rax,	rbx
    jmp       L8083
L8084:
    mov       rax,	r12
L8083:
    mov       rcx,	rax
    call      cc_libpcl.setmode_u
L8042:
L8039:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_expr
cc_blockpcl.dx_expr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r13,	rcx
    mov       r14,	rdx
#---------------
#PROC3
#PROC4
    test      r13,	r13
    jnz       L8087
    jmp       L8085
L8087:
    mov       rdi,	[rip+cc_decls.clineno]
    mov       eax,	[r13+44]
    mov       [rip+cc_decls.clineno],	rax
    movzx     rax,	byte ptr[r13+60]
    mov       [rip+cc_decls.cfileno],	rax
    mov       rsi,	[r13+16]
    mov       r12,	[r13+24]
    movsxd    rax,	dword ptr[r13+52]
    mov       rbx,	rax
    movsxd    rax,	dword ptr[r13+40]
    sub       rax,	1
    cmp       rax,	76
    jae       L8090
    lea       r10,	[rip+L8089]
    jmp       [r10 + rax*8]
    .data
L8089:
    .quad     L8091
    .quad     L8090
    .quad     L8092
    .quad     L8093
    .quad     L8094
    .quad     L8090
    .quad     L8090
    .quad     L8090
    .quad     L8090
    .quad     L8090
    .quad     L8095
    .quad     L8090
    .quad     L8090
    .quad     L8090
    .quad     L8090
    .quad     L8090
    .quad     L8090
    .quad     L8090
    .quad     L8090
    .quad     L8090
    .quad     L8090
    .quad     L8090
    .quad     L8090
    .quad     L8096
    .quad     L8096
    .quad     L8097
    .quad     L8100
    .quad     L8090
    .quad     L8101
    .quad     L8112
    .quad     L8113
    .quad     L8090
    .quad     L8114
    .quad     L8114
    .quad     L8114
    .quad     L8114
    .quad     L8114
    .quad     L8114
    .quad     L8115
    .quad     L8118
    .quad     L8119
    .quad     L8120
    .quad     L8123
    .quad     L8124
    .quad     L8125
    .quad     L8126
    .quad     L8127
    .quad     L8128
    .quad     L8151
    .quad     L8090
    .quad     L8090
    .quad     L8129
    .quad     L8130
    .quad     L8131
    .quad     L8150
    .quad     L8132
    .quad     L8135
    .quad     L8136
    .quad     L8090
    .quad     L8137
    .quad     L8140
    .quad     L8141
    .quad     L8142
    .quad     L8143
    .quad     L8144
    .quad     L8145
    .quad     L8146
    .quad     L8147
    .quad     L8148
    .quad     L8149
    .quad     L8138
    .quad     L8138
    .quad     L8139
    .quad     L8139
    .quad     L8152
    .quad     L8153
    .text
L8091:
    mov       rcx,	r13
    call      cc_blockpcl.dx_const
    jmp       L8088
L8092:
    mov       rcx,	r13
    mov       rdx,	r14
    call      cc_blockpcl.dx_name
    jmp       L8088
L8093:
    mov       rcx,	rsi
    mov       rdx,	r14
    call      cc_blockpcl.dx_expr
    jmp       L8088
L8094:
    mov       rax,	[r13]
    mov       rcx,	rax
    call      cc_libpcl.genmemaddr_d
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	9
    call      cc_libpcl.setmode
    jmp       L8088
L8095:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	1
    call      cc_blockpcl.do_assign
    jmp       L8088
L8096:
    mov       rcx,	r13
    call      cc_blockpcl.dx_andorl
    jmp       L8088
L8097:
    movsxd    rax,	dword ptr[rsi+40]
    cmp       rax,	26
    jnz       L8099
    mov       rax,	[rsi+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	64
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	8
    call      cc_libpcl.setmode
    mov       rax,	[rsi+16]
    movsxd    rax,	dword ptr[rax+52]
    mov       rcx,	rax
    call      cc_libpcl.setmode2
    jmp       L8098
L8099:
    mov       rcx,	rsi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	63
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rsi
    call      cc_libpcl.setmode_u
L8098:
    jmp       L8088
L8100:
    mov       rcx,	rsi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	64
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	8
    call      cc_libpcl.setmode
    movsxd    rax,	dword ptr[rsi+52]
    mov       rcx,	rax
    call      cc_libpcl.setmode2
    jmp       L8088
L8101:
    jmp       L8105
L8102:
    mov       r12,	[rsi+8]
    test      r12,	r12
    jz        L8107
    movsxd    rax,	dword ptr[rsi+40]
    cmp       rax,	11
    jz        L8108
    cmp       rax,	56
    jz        L8108
    cmp       rax,	31
    jnz       L8107
L8108:
    mov       rcx,	rsi
    call      cc_blockpcl.do_stmt
    jmp       L8106
L8107:
    mov       rcx,	rsi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    test      r12,	r12
    jz        L8110
    movsxd    rax,	dword ptr[rsi+52]
    test      rax,	rax
    jnz       L8111
    movsxd    rax,	dword ptr[rsi+40]
    cmp       rax,	56
    jnz       L8110
L8111:
    mov       rcx,	134
    xor       edx,	edx
    call      pc_api.pc_gen
L8110:
L8106:
    mov       rsi,	r12
L8105:
    test      rsi,	rsi
    jnz       L8102
    jmp       L8088
L8112:
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	r12
    mov       r9,	1
    call      cc_blockpcl.dx_call
    jmp       L8088
L8113:
    mov       rax,	[r13+32]
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	r12
    mov       r9,	rax
    call      cc_blockpcl.dx_ifx
    jmp       L8088
L8114:
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	r12
    call      cc_blockpcl.dx_eq
    jmp       L8088
L8115:
    movsxd    rax,	dword ptr[rsi+52]
    lea       r10,	[rip+cc_decls.ttisref]
    mov       r10b,	[r10 + rax]
    test      r10b,	r10b
    jz        L8117
    movsxd    rax,	dword ptr[r12+52]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r10,	[r10 + rax*8]
    cmp       r10,	4
    jg        L8117
    mov       eax,	9
    mov       [r12+52],	eax
L8117:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	43
    call      cc_blockpcl.dx_bin
    jmp       L8088
L8118:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	44
    call      cc_blockpcl.dx_bin
    jmp       L8088
L8119:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	45
    call      cc_blockpcl.dx_bin
    jmp       L8088
L8120:
    movsxd    rax,	dword ptr[rsi+52]
    mov       rcx,	rax
    call      cc_lib.isrealcc
    test      rax,	rax
    jz        L8122
    mov       rax,	46
    jmp       L8121
L8122:
    mov       rax,	47
L8121:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	rax
    call      cc_blockpcl.dx_bin
    jmp       L8088
L8123:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	48
    call      cc_blockpcl.dx_bin
    jmp       L8088
L8124:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	50
    call      cc_blockpcl.dx_bin
    jmp       L8088
L8125:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	51
    call      cc_blockpcl.dx_bin
    jmp       L8088
L8126:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	52
    call      cc_blockpcl.dx_bin
    jmp       L8088
L8127:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	53
    call      cc_blockpcl.dx_bin
    jmp       L8088
L8128:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	54
    call      cc_blockpcl.dx_bin
    jmp       L8088
L8129:
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	r14
    call      cc_blockpcl.dx_ptr
    jmp       L8088
L8130:
    sub       rsp,	8
    mov       rax,	r14
    push      rax
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	r12
    mov       r9,	57
    sub       rsp,	32
    call      cc_blockpcl.dx_addptr
    add       rsp,	48
    jmp       L8088
L8131:
    sub       rsp,	8
    mov       rax,	r14
    push      rax
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	r12
    mov       r9,	58
    sub       rsp,	32
    call      cc_blockpcl.dx_addptr
    add       rsp,	48
    jmp       L8088
L8132:
    movsx     rax,	word ptr[r13+58]
    test      rax,	rax
    jnz       L8134
    mov       rcx,	rsi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    jmp       L8133
L8134:
    movsxd    rax,	dword ptr[r13+48]
    movsx     r10,	word ptr[r13+58]
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	r10
    mov       r9,	rax
    call      cc_blockpcl.dx_convert
L8133:
    jmp       L8088
L8135:
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	r12
    call      cc_blockpcl.dx_scale
    jmp       L8088
L8136:
    mov       rcx,	rsi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	60
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rsi
    call      cc_libpcl.setmode_u
    jmp       L8088
L8137:
    mov       rcx,	rsi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	62
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rsi
    call      cc_libpcl.setmode_u
    jmp       L8088
L8138:
    mov       rcx,	r13
    mov       rdx,	rsi
    call      cc_blockpcl.dx_preincrx
    jmp       L8088
L8139:
    mov       rcx,	r13
    mov       rdx,	rsi
    call      cc_blockpcl.dx_postincrx
    jmp       L8088
L8140:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	90
    mov       r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8088
L8141:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	91
    mov       r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8088
L8142:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	92
    mov       r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8088
L8143:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	93
    mov       r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8088
L8144:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	95
    mov       r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8088
L8145:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	96
    mov       r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8088
L8146:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	97
    mov       r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8088
L8147:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	98
    mov       r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8088
L8148:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	99
    mov       r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8088
L8149:
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	100
    mov       r9,	1
    call      cc_blockpcl.dx_binto
    jmp       L8088
L8150:
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	r14
    call      cc_blockpcl.dx_addrof
    jmp       L8088
L8151:
    mov       rcx,	r13
    mov       rdx,	rsi
    mov       r8,	r12
    mov       r9,	r14
    call      cc_blockpcl.dx_dot
    jmp       L8088
L8152:
    mov       rcx,	rsi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	129
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L8088
L8153:
    mov       rcx,	rsi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	r12
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	130
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L8088
L8090:
    movsxd    rax,	dword ptr[r13+40]
    lea       r10,	[rip+cc_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rip+L11386]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      cc_support.gerror_s
L8088:
    mov       [rip+cc_decls.clineno],	rdi
L8085:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_const
cc_blockpcl.dx_const:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rbx+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    mov       rdi,	r10
    mov       rax,	rdi
    cmp       rax,	1
    jl        L8156
    cmp       rax,	9
    jg        L8156
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L8155
L8156:
    mov       rax,	rdi
    cmp       rax,	10
    jz        L8158
    cmp       rax,	11
    jz        L8159
    jmp       L8160
L8158:
    movq      XMM4,	[rbx]
    movq      XMM0,	XMM4
    mov       rdx,	1
    call      pc_api.genreal
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L8157
L8159:
    movq      XMM4,	[rbx]
    movq      XMM0,	XMM4
    mov       rdx,	2
    call      pc_api.genreal
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L8157
L8160:
    cmp       rdi,	10
    jl        L8162
    cmp       rdi,	11
    jg        L8162
    movq      XMM4,	[rbx]
    movq      XMM0,	XMM4
    mov       rdx,	2
    call      pc_api.genreal
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L8161
L8162:
    cmp       rdi,	13
    jnz       L8163
    mov       al,	[rbx+61]
    test      al,	al
    jz        L8165
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      pc_api.genstring
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L8164
L8165:
    mov       al,	[rbx+62]
    test      al,	al
    jz        L8166
    lea       rcx,	[rip+L11387]
    xor       edx,	edx
    call      cc_support.gerror
    jmp       L8164
L8166:
    mov       rax,	[rbx]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
L8164:
    jmp       L8161
L8163:
    lea       rcx,	[rip+L11388]
    xor       edx,	edx
    call      cc_support.gerror
L8161:
L8157:
L8155:
    movsxd    rax,	dword ptr[rbx+52]
    mov       rcx,	rax
    call      cc_libpcl.setmode
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_name
cc_blockpcl.dx_name:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rdi,	[rbx]
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	7
    jz        L8169
    cmp       rax,	8
    jz        L8169
    cmp       rax,	9
    jnz       L8170
L8169:
    test      rsi,	rsi
    jz        L8172
    mov       rcx,	rdi
    call      cc_libpcl.genmemaddr_d
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	9
    call      cc_libpcl.setmode
    jmp       L8171
L8172:
    mov       rcx,	rdi
    call      cc_libpcl.genmem_d
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rbx
    call      cc_blockpcl.widen
L8171:
    jmp       L8168
L8170:
    lea       rcx,	[rip+L11389]
    xor       edx,	edx
    call      cc_support.gerror
L8168:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_bin
cc_blockpcl.dx_bin:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	rbx
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	rsi
    xor       edx,	edx
    call      pc_api.pc_gen
    movsxd    rax,	dword ptr[rdi+52]
    mov       rcx,	rax
    call      cc_libpcl.setmode
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_binto
cc_blockpcl.dx_binto:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	rdi
    mov       rdx,	1
    call      cc_blockpcl.dx_expr
    test      r12,	r12
    jnz       L8176
    mov       rax,	rsi
    cmp       rax,	94
    jz        L8176
    cmp       rax,	95
    jz        L8176
    call      cc_blockpcl.do_setinplace
L8176:
    test      r12,	r12
    jz        L8178
    mov       rcx,	8
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	10
    mov       rdx,	2
    mov       r8,	3
    xor       r9d,	r9d
    call      pc_api.pc_genxy
L8178:
    mov       rcx,	rsi
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      cc_parse.getmemmode
    mov       rcx,	rax
    call      cc_libpcl.setmode
    test      r12,	r12
    jz        L8180
    mov       rcx,	2
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      cc_parse.getmemmode
    mov       rcx,	rax
    call      cc_libpcl.setmode
L8180:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.do_assign
cc_blockpcl.do_assign:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      cc_blockpcl.do_fixwiden
    mov       rcx,	rbx
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    test      rsi,	rsi
    jz        L8183
    mov       rcx,	9
    xor       edx,	edx
    call      pc_api.pc_gen
L8183:
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	3
    jz        L8185
    cmp       rax,	52
    jz        L8186
    cmp       rax,	49
    jz        L8187
    jmp       L8188
L8185:
    mov       rax,	[rdi]
    mov       rcx,	rax
    call      cc_libpcl.genmem_d
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      cc_parse.getmemmode
    mov       rcx,	rax
    call      cc_libpcl.setmode
    jmp       L8184
L8186:
    mov       rcx,	rdi
    mov       rdx,	1
    call      cc_blockpcl.dx_expr
    mov       rcx,	5
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	rdi
    call      cc_parse.getmemmode
    mov       rcx,	rax
    call      cc_libpcl.setmode
    jmp       L8184
L8187:
    mov       rax,	[rdi+16]
    mov       rcx,	rax
    mov       rdx,	1
    call      cc_blockpcl.dx_expr
    movsxd    rax,	dword ptr[rdi]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	9
    call      cc_libpcl.setmode
    mov       rcx,	57
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	1
    xor       edx,	edx
    call      pc_api.pc_setscaleoff
    mov       rcx,	rdi
    call      cc_parse.getmemmode
    mov       rcx,	rax
    call      cc_libpcl.setmode
    mov       rcx,	5
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	1
    xor       edx,	edx
    call      pc_api.pc_setscaleoff
    mov       rcx,	rdi
    call      cc_parse.getmemmode
    mov       rcx,	rax
    call      cc_libpcl.setmode
    jmp       L8184
L8188:
    movsxd    rax,	dword ptr[rdi+40]
    lea       r10,	[rip+cc_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    lea       rcx,	[rip+L11390]
    mov       rdx,	r10
    xor       r8d,	r8d
    call      cc_support.gerror_s
L8184:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_ptr
cc_blockpcl.dx_ptr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    test      rsi,	rsi
    jnz       L8191
    mov       rcx,	2
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	rdi
    call      cc_blockpcl.widen
L8191:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_addptr
cc_blockpcl.dx_addptr:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.dx_addptr.am, 80
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	rsi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	r12
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    movsxd    rax,	dword ptr[rdi]
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_setscaleoff
    movsxd    rax,	dword ptr[rbx+52]
    mov       rcx,	rax
    call      cc_libpcl.setmode
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_addrof
cc_blockpcl.dx_addrof:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.dx_addrof.p, 24
    .set cc_blockpcl.dx_addrof.am, 40
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	1
    call      cc_blockpcl.dx_expr
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_convert
cc_blockpcl.dx_convert:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.dx_convert.p, 64
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r12+52]
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rdi
    mov       rbx,	[rax + r10*8]
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	r13
    mov       rsi,	[rax + r10*8]
    mov       rcx,	r12
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rax,	r14
    cmp       rax,	1
    jz        L8196
    cmp       rax,	2
    jz        L8197
    cmp       rax,	3
    jz        L8198
    cmp       rax,	4
    jz        L8198
    cmp       rax,	5
    jz        L8199
    cmp       rax,	6
    jz        L8199
    cmp       rax,	7
    jz        L8200
    cmp       rax,	8
    jz        L8200
    cmp       rax,	9
    jz        L8201
    cmp       rax,	10
    jz        L8202
    cmp       rax,	11
    jz        L8203
    cmp       rax,	12
    jz        L8203
    jmp       L8204
L8196:
    jmp       L8194
L8197:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	10
    jz        L8207
    cmp       rax,	11
    jnz       L8206
L8207:
    lea       rcx,	[rip+L11391]
    xor       edx,	edx
    call      cc_support.gerror
L8206:
    cmp       rsi,	rbx
    jle       L8209
    mov       rcx,	114
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L8208
L8209:
    cmp       rsi,	rbx
    jl        L8211
L8210:
L8208:
    jmp       L8195
L8198:
    cmp       rbx,	rsi
    jz        L8194
L8213:
    mov       rcx,	114
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L8195
L8199:
    mov       rcx,	111
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L8195
L8200:
    mov       rcx,	112
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L8195
L8201:
    mov       rcx,	115
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L8195
L8202:
    mov       rcx,	116
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L8195
L8203:
#cc_blockpcl.dx_convert.dotruncate:
L8211:
    mov       rcx,	113
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	3
    call      cc_libpcl.setmode
    mov       rcx,	r13
    call      cc_libpcl.setmode2
    jmp       L8194
L8204:
    lea       rax,	[rip+cc_tables.convnames]
    mov       r10,	r14
    mov       rax,	[rax + r10*8]
    lea       rcx,	[rip+L11392]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      cc_support.gerror_s
L8195:
    mov       rcx,	r13
    call      cc_libpcl.setmode
    mov       rcx,	rdi
    call      cc_libpcl.setmode2
L8194:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.do_if
cc_blockpcl.do_if:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    call      cc_libpcl.createfwdlabel
    mov       rdi,	rax
    mov       rcx,	28
    mov       rdx,	rsi
    mov       r8,	rdi
    call      cc_blockpcl.genjumpcond
    mov       rcx,	r12
    call      cc_blockpcl.do_stmt
    test      r13,	r13
    jz        L8216
    call      cc_libpcl.createfwdlabel
    mov       rbx,	rax
    mov       rcx,	rbx
    call      cc_blockpcl.genjumpl
    mov       rcx,	rdi
    call      cc_libpcl.definefwdlabel
    mov       rcx,	r13
    call      cc_blockpcl.do_stmt
    mov       rcx,	rbx
    call      cc_libpcl.definefwdlabel
    jmp       L8215
L8216:
    mov       rcx,	rdi
    call      cc_libpcl.definefwdlabel
L8215:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.genjumpcond
cc_blockpcl.genjumpcond:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
#---------------
#PROC3
#PROC4
    mov       rdi,	[r13+16]
    mov       rbx,	[r13+24]
    movsxd    rax,	dword ptr[r13+40]
    sub       rax,	24
    cmp       rax,	15
    jae       L8220
    lea       r10,	[rip+L8219]
    jmp       [r10 + rax*8]
    .data
L8219:
    .quad     L8221
    .quad     L8226
    .quad     L8231
    .quad     L8236
    .quad     L8220
    .quad     L8238
    .quad     L8220
    .quad     L8220
    .quad     L8220
    .quad     L8237
    .quad     L8237
    .quad     L8237
    .quad     L8237
    .quad     L8237
    .quad     L8237
    .text
L8221:
    mov       rax,	r12
    cmp       rax,	28
    jz        L8223
    cmp       rax,	27
    jz        L8224
    jmp       L8225
L8223:
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	r14
    call      cc_blockpcl.genjumpcond
    mov       rcx,	28
    mov       rdx,	rbx
    mov       r8,	r14
    call      cc_blockpcl.genjumpcond
    jmp       L8222
L8224:
    call      cc_libpcl.createfwdlabel
    mov       rsi,	rax
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	rsi
    call      cc_blockpcl.genjumpcond
    mov       rcx,	27
    mov       rdx,	rbx
    mov       r8,	r14
    call      cc_blockpcl.genjumpcond
    mov       rcx,	rsi
    call      cc_libpcl.definefwdlabel
L8225:
L8222:
    jmp       L8218
L8226:
    mov       rax,	r12
    cmp       rax,	28
    jz        L8228
    cmp       rax,	27
    jz        L8229
    jmp       L8230
L8228:
    call      cc_libpcl.createfwdlabel
    mov       rsi,	rax
    mov       rcx,	27
    mov       rdx,	rdi
    mov       r8,	rsi
    call      cc_blockpcl.genjumpcond
    mov       rcx,	28
    mov       rdx,	rbx
    mov       r8,	r14
    call      cc_blockpcl.genjumpcond
    mov       rcx,	rsi
    call      cc_libpcl.definefwdlabel
    jmp       L8227
L8229:
    mov       rcx,	27
    mov       rdx,	rdi
    mov       r8,	r14
    call      cc_blockpcl.genjumpcond
    mov       rcx,	27
    mov       rdx,	rbx
    mov       r8,	r14
    call      cc_blockpcl.genjumpcond
L8230:
L8227:
    jmp       L8218
L8231:
    mov       rax,	r12
    cmp       rax,	28
    jz        L8233
    cmp       rax,	27
    jz        L8234
    jmp       L8235
L8233:
    mov       rcx,	27
    mov       rdx,	rdi
    mov       r8,	r14
    call      cc_blockpcl.genjumpcond
    jmp       L8232
L8234:
    mov       rcx,	28
    mov       rdx,	rdi
    mov       r8,	r14
    call      cc_blockpcl.genjumpcond
L8235:
L8232:
    jmp       L8218
L8236:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	r14
    call      cc_blockpcl.genjumpcond
    jmp       L8218
L8237:
    sub       rsp,	8
    mov       rax,	r14
    push      rax
    mov       rcx,	r12
    mov       rdx,	r13
    mov       r8,	rdi
    mov       r9,	rbx
    sub       rsp,	32
    call      cc_blockpcl.gcomparejump
    add       rsp,	48
    jmp       L8218
L8238:
    jmp       L8240
L8239:
    mov       rcx,	rdi
    call      cc_blockpcl.do_stmt
    mov       rdi,	rbx
L8240:
    test      rdi,	rdi
    jz        L8242
    mov       rax,	[rdi+8]
    mov       rbx,	rax
    test      rax,	rax
    jnz       L8239
L8242:
    mov       rcx,	r12
    mov       rdx,	rdi
    mov       r8,	r14
    call      cc_blockpcl.genjumpcond
    jmp       L8218
L8220:
    mov       rcx,	r13
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	r14
    call      pc_api.genlabel
    mov       rcx,	r12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      cc_libpcl.setmode_u
L8218:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.gcomparejump
cc_blockpcl.gcomparejump:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.gcomparejump.lab, 88
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rsi+40]
    mov       rcx,	rax
    call      cc_blockpcl.getpclcond
    mov       rdi,	rax
    cmp       rbx,	28
    jnz       L8245
    mov       rcx,	rdi
    call      cc_blockpcl.reversecond
    mov       rdi,	rax
L8245:
    mov       rcx,	r12
    mov       rdx,	r13
    call      cc_blockpcl.do_fixwiden
    mov       rcx,	r12
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	r13
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	[rbp + cc_blockpcl.gcomparejump.lab]
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       al,	dil
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+2],	al
    mov       rcx,	r12
    call      cc_libpcl.setmode_u
#---------------
    add       rsp,	40
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.getpclcond
cc_blockpcl.getpclcond:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	rcx
    cmp       rax,	33
    jz        L8248
    cmp       rax,	34
    jz        L8249
    cmp       rax,	35
    jz        L8250
    cmp       rax,	36
    jz        L8251
    cmp       rax,	38
    jz        L8252
    cmp       rax,	37
    jz        L8253
    jmp       L8254
L8248:
    mov       rax,	1
    jmp       L8246
L8249:
    mov       rax,	2
    jmp       L8246
L8250:
    mov       rax,	3
    jmp       L8246
L8251:
    mov       rax,	4
    jmp       L8246
L8252:
    mov       rax,	5
    jmp       L8246
L8253:
    mov       rax,	6
    jmp       L8246
L8254:
L8247:
    xor       eax,	eax
L8246:
#---------------
    ret       
# End 
# Proc cc_blockpcl.reversecond
cc_blockpcl.reversecond:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	rcx
    cmp       rax,	1
    jz        L8257
    cmp       rax,	2
    jz        L8258
    cmp       rax,	3
    jz        L8259
    cmp       rax,	4
    jz        L8260
    cmp       rax,	5
    jz        L8261
    cmp       rax,	6
    jz        L8262
    jmp       L8263
L8257:
    mov       rax,	2
    mov       rcx,	rax
    jmp       L8256
L8258:
    mov       rax,	1
    mov       rcx,	rax
    jmp       L8256
L8259:
    mov       rax,	5
    mov       rcx,	rax
    jmp       L8256
L8260:
    mov       rax,	6
    mov       rcx,	rax
    jmp       L8256
L8261:
    mov       rax,	3
    mov       rcx,	rax
    jmp       L8256
L8262:
    mov       rax,	4
    mov       rcx,	rax
L8263:
L8256:
    mov       rax,	rcx
L8255:
#---------------
    ret       
# End 
# Proc cc_blockpcl.genjumpl
cc_blockpcl.genjumpl:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      pc_api.genlabel
    mov       rcx,	24
    mov       rdx,	rax
    call      pc_api.pc_gen
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.do_while
cc_blockpcl.do_while:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r12+40]
    cmp       rax,	1
    jnz       L8267
    mov       rax,	[r12]
    test      rax,	rax
    jz        L8267
    mov       rcx,	r13
    call      cc_blockpcl.do_while1
    jmp       L8265
L8267:
    call      cc_libpcl.createfwdlabel
    mov       rbx,	rax
    call      cc_libpcl.createfwdlabel
    mov       rsi,	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      cc_blockpcl.stacklooplabels
    mov       rcx,	rbx
    call      cc_blockpcl.genjumpl
    call      cc_libpcl.definelabel
    mov       rdi,	rax
    mov       rcx,	r13
    call      cc_blockpcl.do_stmt
    mov       rcx,	rbx
    call      cc_libpcl.definefwdlabel
    mov       rcx,	27
    mov       rdx,	r12
    mov       r8,	rdi
    call      cc_blockpcl.genjumpcond
    mov       rcx,	rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[rip+cc_blockpcl.loopindex]
L8265:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.do_while1
cc_blockpcl.do_while1:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    call      cc_libpcl.createfwdlabel
    mov       rbx,	rax
    call      cc_libpcl.createfwdlabel
    mov       rsi,	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       rdi,	rax
    mov       rcx,	r12
    call      cc_blockpcl.do_stmt
    mov       rcx,	rbx
    call      cc_libpcl.definefwdlabel
    mov       rcx,	rdi
    call      cc_blockpcl.genjumpl
    mov       rcx,	rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[rip+cc_blockpcl.loopindex]
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.do_dowhile
cc_blockpcl.do_dowhile:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
#---------------
#PROC3
#PROC4
    call      cc_libpcl.createfwdlabel
    mov       rbx,	rax
    call      cc_libpcl.createfwdlabel
    mov       rsi,	rax
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       rdi,	rax
    mov       rcx,	r12
    call      cc_blockpcl.do_stmt
    mov       rcx,	rbx
    call      cc_libpcl.definefwdlabel
    mov       rcx,	r13
    call      cc_parse.iscondfalse
    test      rax,	rax
    jnz       L8271
    mov       rcx,	27
    mov       rdx,	r13
    mov       r8,	rdi
    call      cc_blockpcl.genjumpcond
L8271:
    mov       rcx,	rsi
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[rip+cc_blockpcl.loopindex]
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.stacklooplabels
cc_blockpcl.stacklooplabels:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    inc       qword ptr[rip+cc_blockpcl.loopindex]
    mov       rax,	[rip+cc_blockpcl.loopindex]
    mov       r10,	rcx
    lea       r11,	[rip+cc_blockpcl.continuestack]
    mov       [r11 + rax*8-8],	r10
    mov       rax,	rdx
    lea       r10,	[rip+cc_blockpcl.breakstack]
    mov       r11,	[rip+cc_blockpcl.loopindex]
    mov       [r10 + r11*8-8],	rax
#---------------
    ret       
# End 
# Proc cc_blockpcl.do_return
cc_blockpcl.do_return:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.do_return.p, 24
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rdx
#---------------
#PROC3
#PROC4
    test      rdi,	rdi
    jz        L8275
    mov       rax,	[rip+cc_decls.currproc]
    movzx     rax,	byte ptr[rax+108]
    shr       eax,	3
    and       eax,	1
    test      rax,	rax
    jz        L8277
    mov       rcx,	rdi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	32
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L8276
L8277:
    mov       rcx,	rdi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	[rip+cc_genpcl.retindex]
    call      pc_api.genlabel
    mov       rcx,	29
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      cc_libpcl.setmode_u
L8276:
    jmp       L8274
L8275:
    mov       rcx,	[rip+cc_genpcl.retindex]
    call      cc_blockpcl.genjumpl
L8274:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_call
cc_blockpcl.dx_call:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.dx_call.b, 88
    .set cc_blockpcl.dx_call.res, 96
    .set cc_blockpcl.dx_call.retmode, -8
    .set cc_blockpcl.dx_call.m, -16
    .set cc_blockpcl.dx_call.nvariadics, -24
    .set cc_blockpcl.dx_call.nfixedparams, -32
    .set cc_blockpcl.dx_call.isfn, -40
    .set cc_blockpcl.dx_call.paramlist, -552
    .set cc_blockpcl.dx_call.paramconst, -616
    .set cc_blockpcl.dx_call.argattr, -680
    .set cc_blockpcl.dx_call.iparams, -688
    .set cc_blockpcl.dx_call.fparams, -696
    .set cc_blockpcl.dx_call.q, -704
    .set cc_blockpcl.dx_call.i, -712
    .set cc_blockpcl.dx_call.$T1, -720
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	760
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+88],	r8
    mov       [rbp+96],	r9
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r13+52]
    mov       [rbp + cc_blockpcl.dx_call.retmode],	rax
    mov       rax,	[rbp + cc_blockpcl.dx_call.retmode]
    test      rax,	rax
    jnz       L8280
    mov       rax,	3
    mov       [rbp + cc_blockpcl.dx_call.retmode],	rax
L8280:
    xor       eax,	eax
    mov       [rbp + cc_blockpcl.dx_call.isfn],	rax
    movsxd    rax,	dword ptr[r14+40]
    cmp       rax,	52
    jnz       L8283
L8282:
    movsxd    rax,	dword ptr[r14+52]
    mov       [rbp + cc_blockpcl.dx_call.m],	rax
    jmp       L8285
L8284:
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	[rbp + cc_blockpcl.dx_call.m]
    movsx     rax,	word ptr[rax + r10*2]
    mov       [rbp + cc_blockpcl.dx_call.m],	rax
L8285:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	[rbp + cc_blockpcl.dx_call.m]
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	13
    jz        L8284
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	[rbp + cc_blockpcl.dx_call.m]
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	0
    setnz     al
    movzx     eax,	al
    mov       [rbp + cc_blockpcl.dx_call.isfn],	rax
    lea       rax,	[rip+cc_decls.ttparams]
    mov       r10,	[rbp + cc_blockpcl.dx_call.m]
    mov       rdi,	[rax + r10*8]
    mov       rbx,	1
    jmp       L8281
L8283:
    mov       rax,	[r14]
    mov       rdi,	[rax+80]
    xor       rbx,	rbx
    mov       rax,	[r14]
    movzx     rax,	word ptr[rax+102]
    cmp       rax,	0
    setnz     al
    movzx     eax,	al
    mov       [rbp + cc_blockpcl.dx_call.isfn],	rax
L8281:
    movsx     rax,	word ptr[rdi+22]
    cmp       rax,	3
    setz      al
    movzx     eax,	al
    mov       rsi,	rax
    movsx     rax,	word ptr[rdi+20]
    mov       [rbp + cc_blockpcl.dx_call.nfixedparams],	rax
    xor       eax,	eax
    mov       [rbp + cc_blockpcl.dx_call.nvariadics],	rax
    mov       r12,	rax
    mov       rax,	[rbp + cc_blockpcl.dx_call.b]
    mov       [rbp + cc_blockpcl.dx_call.q],	rax
    jmp       L8290
L8287:
    cmp       r12,	64
    jl        L8292
    lea       rcx,	[rip+L11393]
    xor       edx,	edx
    call      cc_support.gerror
L8292:
    inc       r12
    mov       rax,	r12
    mov       r10,	[rbp + cc_blockpcl.dx_call.q]
    mov       [rbp + rax*8 + cc_blockpcl.dx_call.paramlist-8],	r10
    xor       eax,	eax
    mov       [rbp + r12 + cc_blockpcl.dx_call.paramconst-1],	al
    test      rsi,	rsi
    jz        L8294
    cmp       r12,	[rbp + cc_blockpcl.dx_call.nfixedparams]
    jle       L8294
    cmp       r12,	4
    jg        L8294
    mov       rax,	[rbp + cc_blockpcl.dx_call.nvariadics]
    test      rax,	rax
    jnz       L8294
    mov       [rbp + cc_blockpcl.dx_call.nvariadics],	r12
L8294:
    cmp       r12,	[rbp + cc_blockpcl.dx_call.nfixedparams]
    jg        L8296
    movsxd    rax,	dword ptr[rdi+16]
    lea       r10,	[rip+cc_decls.ttconst]
    mov       r10b,	[r10 + rax]
    mov       [rbp + r12 + cc_blockpcl.dx_call.paramconst-1],	r10b
    mov       rdi,	[rdi+8]
L8296:
    mov       rax,	[rbp + cc_blockpcl.dx_call.q]
    mov       rax,	[rax+8]
    mov       [rbp + cc_blockpcl.dx_call.q],	rax
L8290:
    mov       rax,	[rbp + cc_blockpcl.dx_call.q]
    test      rax,	rax
    jnz       L8287
    mov       rcx,	131
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      cc_libpcl.setmode_u
    mov       eax,	r12d
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+16],	eax
    xor       eax,	eax
    mov       [rbp + cc_blockpcl.dx_call.fparams],	rax
    mov       [rbp + cc_blockpcl.dx_call.iparams],	rax
    mov       rax,	1
    mov       [rbp + cc_blockpcl.dx_call.i],	rax
    cmp       r12,	1
    jl        L8299
L8297:
    mov       rax,	[rbp + cc_blockpcl.dx_call.i]
    mov       rax,	[rbp + rax*8 + cc_blockpcl.dx_call.paramlist-8]
    mov       [rbp + cc_blockpcl.dx_call.q],	rax
    mov       rax,	[rbp + cc_blockpcl.dx_call.q]
    movsxd    rax,	dword ptr[rax+52]
    cmp       rax,	10
    jz        L8302
    cmp       rax,	11
    jnz       L8301
L8302:
    inc       qword ptr[rbp + cc_blockpcl.dx_call.fparams]
    mov       rax,	[rbp + cc_blockpcl.dx_call.fparams]
    neg       rax
    mov       r10,	[rbp + cc_blockpcl.dx_call.i]
    mov       [rbp + r10 + cc_blockpcl.dx_call.argattr-1],	al
    jmp       L8300
L8301:
    inc       qword ptr[rbp + cc_blockpcl.dx_call.iparams]
    mov       rax,	[rbp + cc_blockpcl.dx_call.iparams]
    mov       r10,	[rbp + cc_blockpcl.dx_call.i]
    mov       [rbp + r10 + cc_blockpcl.dx_call.argattr-1],	al
L8300:
    mov       rax,	[rbp + cc_blockpcl.dx_call.i]
    inc       rax
    mov       [rbp + cc_blockpcl.dx_call.i],	rax
    cmp       rax,	r12
    jle       L8297
L8299:
    mov       [rbp + cc_blockpcl.dx_call.i],	r12
    mov       rax,	[rbp + cc_blockpcl.dx_call.i]
    cmp       rax,	1
    jl        L8305
L8303:
    mov       rax,	[rbp + cc_blockpcl.dx_call.i]
    mov       rax,	[rbp + rax*8 + cc_blockpcl.dx_call.paramlist-8]
    mov       [rbp + cc_blockpcl.dx_call.q],	rax
    mov       rcx,	[rbp + cc_blockpcl.dx_call.q]
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rax,	[rbp + cc_blockpcl.dx_call.nvariadics]
    test      rax,	rax
    jz        L8307
    mov       rax,	[rbp + cc_blockpcl.dx_call.i]
    cmp       rax,	[rbp + cc_blockpcl.dx_call.nvariadics]
    jl        L8307
    mov       rax,	[rip+pc_api.pccurr]
    movzx     rax,	byte ptr[rax+3]
    cmp       rax,	1
    jnz       L8307
    mov       rcx,	115
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       al,	2
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+3],	al
    mov       rax,	[rip+pc_api.pccurr]
    lea       rax,	[rax+28]
    mov       r10d,	1
    mov       r15d,	[rax]
    mov       r11,	-256
    and       r15d,	r11d
    or        r15d,	r10d
    mov       [rax],	r15d
L8307:
    mov       rcx,	132
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	[rbp + cc_blockpcl.dx_call.q]
    call      cc_libpcl.setmode_u
    mov       eax,	[rbp + cc_blockpcl.dx_call.i]
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+16],	eax
    mov       rax,	[rbp + cc_blockpcl.dx_call.i]
    movsx     rax,	byte ptr[rbp + rax + cc_blockpcl.dx_call.argattr-1]
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+20],	eax
    mov       rax,	[rbp + cc_blockpcl.dx_call.i]
    dec       rax
    mov       [rbp + cc_blockpcl.dx_call.i],	rax
    cmp       rax,	1
    jge       L8303
L8305:
    test      rbx,	rbx
    jnz       L8309
    mov       rax,	[r14]
    mov       rcx,	rax
    call      cc_libpcl.genmemaddr_d
    mov       [rbp + cc_blockpcl.dx_call.$T1],	rax
    mov       rax,	[rbp + cc_blockpcl.dx_call.isfn]
    test      rax,	rax
    jz        L8311
    mov       rax,	21
    jmp       L8310
L8311:
    mov       rax,	18
L8310:
    mov       rcx,	rax
    mov       rdx,	[rbp + cc_blockpcl.dx_call.$T1]
    call      pc_api.pc_gen
    jmp       L8308
L8309:
    mov       rax,	[r14+16]
    mov       rcx,	rax
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rax,	[rbp + cc_blockpcl.dx_call.isfn]
    test      rax,	rax
    jz        L8313
    mov       rax,	22
    jmp       L8312
L8313:
    mov       rax,	19
L8312:
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
L8308:
    mov       eax,	r12d
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+16],	eax
    mov       eax,	[rbp + cc_blockpcl.dx_call.nvariadics]
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+20],	eax
    mov       rax,	[rbp + cc_blockpcl.dx_call.isfn]
    test      rax,	rax
    jz        L8315
    mov       rcx,	r13
    call      cc_parse.getmemmode
    mov       rcx,	rax
    call      cc_libpcl.setmode
    mov       rax,	[rbp + cc_blockpcl.dx_call.res]
    test      rax,	rax
    jnz       L8317
    mov       rcx,	11
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r13
    call      cc_parse.getmemmode
    mov       rcx,	rax
    call      cc_libpcl.setmode
    jmp       L8316
L8317:
    mov       rcx,	r13
    call      cc_blockpcl.widen
L8316:
L8315:
#---------------
    add       rsp,	760
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.do_decl
cc_blockpcl.do_decl:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rdi,	[rbx+72]
    mov       al,	1
    mov       [rbx+122],	al
    mov       rax,	[rbx+56]
    test      rax,	rax
    jz        L8320
    mov       rax,	[rbx+56]
    mov       r10b,	1
    mov       [rax+92],	r10b
L8320:
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	28
    jz        L8322
    movzx     rax,	word ptr[rbx+102]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    cmp       r10,	17
    jnz       L8324
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	1
    jz        L8325
L8324:
    mov       rcx,	rdi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	rbx
    call      cc_libpcl.genmem_d
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    movsxd    rax,	dword ptr[rdi+52]
    mov       rcx,	rax
    call      cc_libpcl.setmode
    jmp       L8318
L8322:
#cc_blockpcl.do_decl.copyl:
L8325:
    mov       rax,	[rbx+114]
    mov       rcx,	rax
    call      pc_api.genmem
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    movzx     rax,	word ptr[rbx+102]
    mov       rcx,	rax
    call      cc_libpcl.setmode
    mov       rcx,	rbx
    call      cc_libpcl.genmem_d
    mov       rcx,	4
    mov       rdx,	rax
    call      pc_api.pc_gen
    movzx     rax,	word ptr[rbx+102]
    mov       rcx,	rax
    call      cc_libpcl.setmode
L8318:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.do_for
cc_blockpcl.do_for:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.do_for.pbody, 80
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       r15,	rcx
    mov       [rbp+80],	rdx
#---------------
#PROC3
#PROC4
    mov       rdi,	[r15+8]
    mov       rbx,	[rdi+8]
    call      cc_libpcl.createfwdlabel
    mov       r12,	rax
    call      cc_libpcl.createfwdlabel
    mov       r13,	rax
    call      cc_libpcl.createfwdlabel
    mov       r14,	rax
    movsxd    rax,	dword ptr[r15+40]
    cmp       rax,	2
    jz        L8328
    mov       rcx,	r15
    call      cc_blockpcl.do_stmt
L8328:
    mov       rcx,	r14
    call      cc_blockpcl.genjumpl
    mov       rcx,	r12
    mov       rdx,	r13
    call      cc_blockpcl.stacklooplabels
    call      cc_libpcl.definelabel
    mov       rsi,	rax
    mov       rcx,	[rbp + cc_blockpcl.do_for.pbody]
    call      cc_blockpcl.do_stmt
    mov       rcx,	r12
    call      cc_libpcl.definefwdlabel
    mov       rcx,	rbx
    call      cc_blockpcl.do_stmt
    mov       rcx,	r14
    call      cc_libpcl.definefwdlabel
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	2
    jz        L8330
    mov       rcx,	27
    mov       rdx,	rdi
    mov       r8,	rsi
    call      cc_blockpcl.genjumpcond
    jmp       L8329
L8330:
    mov       rcx,	rsi
    call      cc_blockpcl.genjumpl
L8329:
    mov       rcx,	r13
    call      cc_libpcl.definefwdlabel
    dec       qword ptr[rip+cc_blockpcl.loopindex]
#---------------
    add       rsp,	40
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.do_preincr
cc_blockpcl.do_preincr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    mov       rcx,	rbx
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	rdi
    call      cc_parse.getmemmode
    mov       rcx,	rax
    call      cc_libpcl.setmode
    movsxd    rax,	dword ptr[rdi+52]
    mov       rcx,	rax
    call      cc_blockpcl.setincrstep
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.setincrstep
cc_blockpcl.setincrstep:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	1
    call      pc_api.pc_setincr
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    test      al,	al
    jz        L8334
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      pc_api.pc_setincr
L8334:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_preincrx
cc_blockpcl.dx_preincrx:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	71
    jnz       L8337
    mov       rax,	86
    jmp       L8336
L8337:
    mov       rax,	87
L8336:
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    movsxd    rax,	dword ptr[rbx+52]
    mov       rcx,	rax
    call      cc_blockpcl.setincrstep
    mov       rcx,	rbx
    call      cc_blockpcl.widen
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_postincrx
cc_blockpcl.dx_postincrx:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	1
    call      cc_blockpcl.dx_expr
    call      cc_blockpcl.do_setinplace
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	73
    jnz       L8340
    mov       rax,	88
    jmp       L8339
L8340:
    mov       rax,	89
L8339:
    mov       rcx,	rax
    xor       edx,	edx
    call      pc_api.pc_gen
    movsxd    rax,	dword ptr[rbx+52]
    mov       rcx,	rax
    call      cc_blockpcl.setincrstep
    mov       rcx,	rbx
    call      cc_blockpcl.widen
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_dot
cc_blockpcl.dx_dot:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.dx_dot.b, 56
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r9
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	1
    call      cc_blockpcl.dx_expr
    movsxd    rax,	dword ptr[rdi]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	9
    call      cc_libpcl.setmode
    test      rsi,	rsi
    jnz       L8343
    mov       rcx,	57
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	rdi
    call      cc_parse.getmemmode
    mov       rcx,	rax
    call      cc_libpcl.setmode
    mov       rcx,	1
    xor       edx,	edx
    call      pc_api.pc_setscaleoff
    mov       rcx,	2
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	rdi
    call      cc_blockpcl.widen
    jmp       L8342
L8343:
    mov       rcx,	57
    mov       rdx,	1
    xor       r8d,	r8d
    call      pc_api.pc_genix
    mov       rcx,	rdi
    call      cc_parse.getmemmode
    mov       rcx,	rax
    call      cc_libpcl.setmode
    mov       rcx,	1
    xor       edx,	edx
    call      pc_api.pc_setscaleoff
L8342:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_eq
cc_blockpcl.dx_eq:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	rsi
    call      cc_blockpcl.do_fixwiden
    mov       rcx,	rbx
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	rsi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	31
    xor       edx,	edx
    call      pc_api.pc_gen
    movsxd    rax,	dword ptr[rdi+40]
    mov       rcx,	rax
    call      cc_blockpcl.getpclcond
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+2],	al
    mov       rcx,	rbx
    call      cc_libpcl.setmode_u
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.do_labeldef
cc_blockpcl.do_labeldef:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rdi+88]
    cmp       rax,	0
    jg        L8347
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rax,	[rip+pc_api.mlabelno]
    mov       [rdi+88],	eax
L8347:
    mov       rcx,	[rdi]
    call      pc_api.gencomment
    movsxd    rax,	dword ptr[rdi+88]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	127
    mov       rdx,	rax
    call      pc_api.pc_gen
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.do_goto
cc_blockpcl.do_goto:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rdi+88]
    test      rax,	rax
    jnz       L8350
    mov       rax,	[rdi]
    lea       rcx,	[rip+L11394]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      cc_support.gerror_s
    jmp       L8349
L8350:
    movsxd    rax,	dword ptr[rdi+88]
    cmp       rax,	0
    jge       L8351
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rax,	[rip+pc_api.mlabelno]
    mov       [rdi+88],	eax
L8351:
L8349:
    movsxd    rax,	dword ptr[rdi+88]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	24
    mov       rdx,	rax
    call      pc_api.pc_gen
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_ifx
cc_blockpcl.dx_ifx:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.dx_ifx.c, 88
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	32
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r12+52]
    cmp       rax,	0
    setnz     al
    movzx     eax,	al
    mov       rsi,	rax
    call      cc_libpcl.createfwdlabel
    mov       rdi,	rax
    call      cc_libpcl.createfwdlabel
    mov       rbx,	rax
    test      rsi,	rsi
    jz        L8354
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
L8354:
    mov       rcx,	28
    mov       rdx,	r13
    mov       r8,	rdi
    call      cc_blockpcl.genjumpcond
    mov       rcx,	r14
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    test      rsi,	rsi
    jz        L8356
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r12
    call      cc_libpcl.setmode_u
L8356:
    mov       rcx,	rbx
    call      cc_blockpcl.genjumpl
    mov       rcx,	rdi
    call      cc_libpcl.definefwdlabel
    mov       rcx,	[rbp + cc_blockpcl.dx_ifx.c]
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    test      rsi,	rsi
    jz        L8358
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	r12
    call      cc_libpcl.setmode_u
L8358:
    mov       rcx,	rbx
    call      cc_libpcl.definefwdlabel
#---------------
    add       rsp,	32
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.do_casestmt
cc_blockpcl.do_casestmt:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_blockpcl.sw_ncases]
    test      rax,	rax
    jnz       L8361
    mov       rax,	[rsi]
    sub       rax,	[rip+cc_blockpcl.sw_lower]
    mov       r10,	[rip+cc_blockpcl.sw_labeltable]
    movsxd    r10,	dword ptr[r10 + rax*4]
    mov       rcx,	r10
    call      pc_api.genlabel
    mov       rcx,	127
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L8360
L8361:
    mov       rdi,	[rsi]
    mov       rbx,	1
    mov       rax,	[rip+cc_blockpcl.sw_ncases]
    cmp       rax,	1
    jl        L8365
L8362:
    mov       rax,	[rip+cc_blockpcl.sw_valuetable]
    mov       r10,	rbx
    movsxd    rax,	dword ptr[rax + r10*4-4]
    cmp       rax,	rdi
    jnz       L8367
    mov       rax,	[rip+cc_blockpcl.sw_labeltable]
    mov       r10,	rbx
    movsxd    rax,	dword ptr[rax + r10*4-4]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	127
    mov       rdx,	rax
    call      pc_api.pc_gen
    jmp       L8364
L8367:
    inc       rbx
    cmp       rbx,	[rip+cc_blockpcl.sw_ncases]
    jle       L8362
L8365:
    lea       rcx,	[rip+L11395]
    xor       edx,	edx
    call      cc_support.gerror
L8364:
L8360:
    mov       rcx,	r12
    call      cc_blockpcl.do_stmt
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.do_switch
cc_blockpcl.do_switch:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.do_switch.a, 80
    .set cc_blockpcl.do_switch.b, 88
    .set cc_blockpcl.do_switch.labeltable, -2000
    .set cc_blockpcl.do_switch.valuetable, -4000
    .set cc_blockpcl.do_switch.flags, -4504
    .set cc_blockpcl.do_switch.value, -4512
    .set cc_blockpcl.do_switch.ncases, -4520
    .set cc_blockpcl.do_switch.serialsw, -4528
    .set cc_blockpcl.do_switch.i, -4536
    .set cc_blockpcl.do_switch.index, -4544
    .set cc_blockpcl.do_switch.pcase, -4552
    .set cc_blockpcl.do_switch.old_labeltable, -4560
    .set cc_blockpcl.do_switch.old_valuetable, -4568
    .set cc_blockpcl.do_switch.old_ncases, -4576
    .set cc_blockpcl.do_switch.old_lower, -4584
    .set cc_blockpcl.do_switch.old_defaultseen, -4592
    .set cc_blockpcl.do_switch.old_defaultlabel, -4600
    .set cc_blockpcl.do_switch.old_breaklabel, -4608
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	4648
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
#---------------
#PROC3
#PROC4
    mov       rax,	[r15]
    mov       [rbp + cc_blockpcl.do_switch.pcase],	rax
    xor       eax,	eax
    mov       r14,	rax
    mov       [rbp + cc_blockpcl.do_switch.ncases],	rax
    jmp       L8370
L8369:
    inc       qword ptr[rbp + cc_blockpcl.do_switch.ncases]
    mov       rax,	[rbp + cc_blockpcl.do_switch.ncases]
    cmp       rax,	500
    jle       L8373
    lea       rcx,	[rip+L11396]
    xor       edx,	edx
    call      cc_support.gerror
L8373:
    mov       rax,	[rbp + cc_blockpcl.do_switch.pcase]
    mov       rax,	[rax+8]
    mov       [rbp + cc_blockpcl.do_switch.value],	rax
    mov       r10,	[rbp + cc_blockpcl.do_switch.ncases]
    mov       [rbp + r10*4 + cc_blockpcl.do_switch.valuetable-4],	eax
    mov       rax,	[rbp + cc_blockpcl.do_switch.ncases]
    cmp       rax,	1
    jnz       L8375
    mov       rax,	[rbp + cc_blockpcl.do_switch.value]
    mov       r13,	rax
    mov       r12,	rax
    jmp       L8374
L8375:
    mov       rax,	r12
    mov       r10,	[rbp + cc_blockpcl.do_switch.value]
    cmp       rax,	r10
    cmovg     rax,	r10
    mov       r12,	rax
    mov       rax,	r13
    mov       r10,	[rbp + cc_blockpcl.do_switch.value]
    cmp       rax,	r10
    cmovl     rax,	r10
    mov       r13,	rax
L8374:
    mov       rax,	[rbp + cc_blockpcl.do_switch.pcase]
    mov       rax,	[rax]
    mov       [rbp + cc_blockpcl.do_switch.pcase],	rax
L8370:
    mov       rax,	[rbp + cc_blockpcl.do_switch.pcase]
    test      rax,	rax
    jnz       L8369
    mov       rax,	[r15]
    test      rax,	rax
    jz        L8377
    mov       rax,	r13
    sub       rax,	r12
    inc       rax
    mov       r14,	rax
    jmp       L8376
L8377:
    xor       r14,	r14
L8376:
    call      cc_libpcl.createfwdlabel
    mov       rdi,	rax
    call      cc_libpcl.createfwdlabel
    mov       rbx,	rax
    cmp       r14,	500
    jg        L8380
    mov       rax,	[rbp + cc_blockpcl.do_switch.ncases]
    cmp       rax,	8
    jg        L8379
L8380:
    mov       al,	1
    mov       [rbp + cc_blockpcl.do_switch.serialsw],	al
    mov       rcx,	[rbp + cc_blockpcl.do_switch.a]
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rax,	1
    mov       [rbp + cc_blockpcl.do_switch.i],	rax
    mov       rax,	[rbp + cc_blockpcl.do_switch.ncases]
    cmp       rax,	1
    jl        L8383
L8381:
    call      cc_libpcl.createfwdlabel
    mov       r10,	[rbp + cc_blockpcl.do_switch.i]
    mov       [rbp + r10*4 + cc_blockpcl.do_switch.labeltable-4],	eax
    mov       rax,	[rbp + cc_blockpcl.do_switch.i]
    movsxd    rax,	dword ptr[rbp + rax*4 + cc_blockpcl.do_switch.valuetable-4]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      cc_libpcl.setmode
    mov       rax,	[rbp + cc_blockpcl.do_switch.i]
    movsxd    rax,	dword ptr[rbp + rax*4 + cc_blockpcl.do_switch.labeltable-4]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	26
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      cc_libpcl.setmode
    mov       al,	1
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+2],	al
    mov       rax,	[rbp + cc_blockpcl.do_switch.i]
    cmp       rax,	[rbp + cc_blockpcl.do_switch.ncases]
    jge       L8385
    mov       eax,	1
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+16],	eax
L8385:
    mov       rax,	[rbp + cc_blockpcl.do_switch.i]
    inc       rax
    mov       [rbp + cc_blockpcl.do_switch.i],	rax
    cmp       rax,	[rbp + cc_blockpcl.do_switch.ncases]
    jle       L8381
L8383:
    mov       rcx,	rdi
    call      cc_blockpcl.genjumpl
    jmp       L8378
L8379:
    test      r14,	r14
    jnz       L8386
    mov       rcx,	rdi
    call      cc_blockpcl.genjumpl
    jmp       L8378
L8386:
    xor       eax,	eax
    mov       [rbp + cc_blockpcl.do_switch.serialsw],	al
    lea       rcx,	[rbp + cc_blockpcl.do_switch.flags]
    xor       edx,	edx
    mov       r8,	r14
    call      memset
    mov       rax,	1
    mov       [rbp + cc_blockpcl.do_switch.i],	rax
    cmp       r14,	1
    jl        L8389
L8387:
    mov       eax,	edi
    mov       r10,	[rbp + cc_blockpcl.do_switch.i]
    mov       [rbp + r10*4 + cc_blockpcl.do_switch.labeltable-4],	eax
    mov       rax,	[rbp + cc_blockpcl.do_switch.i]
    inc       rax
    mov       [rbp + cc_blockpcl.do_switch.i],	rax
    cmp       rax,	r14
    jle       L8387
L8389:
    mov       rax,	1
    mov       [rbp + cc_blockpcl.do_switch.i],	rax
    mov       rax,	[rbp + cc_blockpcl.do_switch.ncases]
    cmp       rax,	1
    jl        L8392
L8390:
    mov       rax,	[rbp + cc_blockpcl.do_switch.i]
    movsxd    rax,	dword ptr[rbp + rax*4 + cc_blockpcl.do_switch.valuetable-4]
    mov       [rbp + cc_blockpcl.do_switch.value],	rax
    mov       rax,	[rbp + cc_blockpcl.do_switch.value]
    sub       rax,	r12
    inc       rax
    mov       [rbp + cc_blockpcl.do_switch.index],	rax
    call      cc_libpcl.createfwdlabel
    mov       r10,	[rbp + cc_blockpcl.do_switch.index]
    mov       [rbp + r10*4 + cc_blockpcl.do_switch.labeltable-4],	eax
    mov       rax,	[rbp + cc_blockpcl.do_switch.index]
    mov       al,	[rbp + rax + cc_blockpcl.do_switch.flags-1]
    test      al,	al
    jz        L8394
    mov       rcx,	[rbp + cc_blockpcl.do_switch.value]
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rip+L11397]
    mov       rdx,	rax
    xor       r8d,	r8d
    call      cc_support.gerror_s
L8394:
    mov       al,	1
    mov       r10,	[rbp + cc_blockpcl.do_switch.index]
    mov       [rbp + r10 + cc_blockpcl.do_switch.flags-1],	al
    mov       rax,	[rbp + cc_blockpcl.do_switch.i]
    inc       rax
    mov       [rbp + cc_blockpcl.do_switch.i],	rax
    cmp       rax,	[rbp + cc_blockpcl.do_switch.ncases]
    jle       L8390
L8392:
    call      cc_libpcl.createfwdlabel
    mov       rsi,	rax
    mov       rcx,	[rbp + cc_blockpcl.do_switch.a]
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    mov       rcx,	rsi
    call      pc_api.genlabel
    mov       rcx,	37
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      cc_libpcl.setmode
    mov       rax,	r12
    add       rax,	r14
    dec       rax
    mov       rcx,	r12
    mov       rdx,	rax
    call      pc_api.pc_setxy
    mov       rcx,	rdi
    call      pc_api.genlabel
    mov       rcx,	12
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      cc_libpcl.setmode
    mov       rcx,	rsi
    call      cc_libpcl.definefwdlabel
    mov       rax,	1
    mov       [rbp + cc_blockpcl.do_switch.i],	rax
    cmp       r14,	1
    jl        L8397
L8395:
    mov       rax,	[rbp + cc_blockpcl.do_switch.i]
    movsxd    rax,	dword ptr[rbp + rax*4 + cc_blockpcl.do_switch.labeltable-4]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	39
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rax,	[rbp + cc_blockpcl.do_switch.i]
    inc       rax
    mov       [rbp + cc_blockpcl.do_switch.i],	rax
    cmp       rax,	r14
    jle       L8395
L8397:
    mov       rcx,	40
    xor       edx,	edx
    call      pc_api.pc_gen
L8378:
    mov       rax,	[rip+cc_blockpcl.sw_labeltable]
    mov       [rbp + cc_blockpcl.do_switch.old_labeltable],	rax
    mov       rax,	[rip+cc_blockpcl.sw_valuetable]
    mov       [rbp + cc_blockpcl.do_switch.old_valuetable],	rax
    mov       rax,	[rip+cc_blockpcl.sw_lower]
    mov       [rbp + cc_blockpcl.do_switch.old_lower],	rax
    mov       rax,	[rip+cc_blockpcl.sw_ncases]
    mov       [rbp + cc_blockpcl.do_switch.old_ncases],	rax
    mov       al,	[rip+cc_blockpcl.sw_defaultseen]
    mov       [rbp + cc_blockpcl.do_switch.old_defaultseen],	al
    mov       rax,	[rip+cc_blockpcl.sw_defaultlabel]
    mov       [rbp + cc_blockpcl.do_switch.old_defaultlabel],	rax
    mov       rax,	[rip+cc_blockpcl.sw_breaklabel]
    mov       [rbp + cc_blockpcl.do_switch.old_breaklabel],	rax
    lea       rax,	[rbp + cc_blockpcl.do_switch.labeltable]
    mov       [rip+cc_blockpcl.sw_labeltable],	rax
    lea       rax,	[rbp + cc_blockpcl.do_switch.valuetable]
    mov       [rip+cc_blockpcl.sw_valuetable],	rax
    mov       [rip+cc_blockpcl.sw_lower],	r12
    mov       al,	[rbp + cc_blockpcl.do_switch.serialsw]
    test      al,	al
    jz        L8399
    mov       rax,	[rbp + cc_blockpcl.do_switch.ncases]
    jmp       L8398
L8399:
    xor       eax,	eax
L8398:
    mov       [rip+cc_blockpcl.sw_ncases],	rax
    xor       eax,	eax
    mov       [rip+cc_blockpcl.sw_defaultseen],	al
    mov       [rip+cc_blockpcl.sw_defaultlabel],	rdi
    mov       [rip+cc_blockpcl.sw_breaklabel],	rbx
    mov       rcx,	[rbp + cc_blockpcl.do_switch.b]
    call      cc_blockpcl.do_stmt
    mov       al,	[rip+cc_blockpcl.sw_defaultseen]
    test      al,	al
    jnz       L8401
    mov       rcx,	rdi
    call      cc_libpcl.definefwdlabel
L8401:
    mov       rcx,	rbx
    call      cc_libpcl.definefwdlabel
    mov       rax,	[rbp + cc_blockpcl.do_switch.old_labeltable]
    mov       [rip+cc_blockpcl.sw_labeltable],	rax
    mov       rax,	[rbp + cc_blockpcl.do_switch.old_valuetable]
    mov       [rip+cc_blockpcl.sw_valuetable],	rax
    mov       rax,	[rbp + cc_blockpcl.do_switch.old_lower]
    mov       [rip+cc_blockpcl.sw_lower],	rax
    mov       rax,	[rbp + cc_blockpcl.do_switch.old_ncases]
    mov       [rip+cc_blockpcl.sw_ncases],	rax
    mov       al,	[rbp + cc_blockpcl.do_switch.old_defaultseen]
    mov       [rip+cc_blockpcl.sw_defaultseen],	al
    mov       rax,	[rbp + cc_blockpcl.do_switch.old_defaultlabel]
    mov       [rip+cc_blockpcl.sw_defaultlabel],	rax
    mov       rax,	[rbp + cc_blockpcl.do_switch.old_breaklabel]
    mov       [rip+cc_blockpcl.sw_breaklabel],	rax
#---------------
    add       rsp,	4648
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_andorl
cc_blockpcl.dx_andorl:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    call      cc_libpcl.createfwdlabel
    mov       rdi,	rax
    mov       rcx,	117
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	28
    mov       rdx,	rsi
    mov       r8,	rdi
    call      cc_blockpcl.genjumpcond
    call      cc_libpcl.createfwdlabel
    mov       rbx,	rax
    mov       rcx,	1
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      cc_libpcl.setmode
    mov       rcx,	118
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	[rsi+16]
    call      cc_libpcl.setmode_u
    mov       rcx,	rbx
    call      cc_blockpcl.genjumpl
    mov       rcx,	rdi
    call      cc_libpcl.definefwdlabel
    xor       ecx,	ecx
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	3
    call      cc_libpcl.setmode
    mov       rcx,	119
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rcx,	[rsi+16]
    call      cc_libpcl.setmode_u
    mov       rcx,	rbx
    call      cc_libpcl.definefwdlabel
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.dx_scale
cc_blockpcl.dx_scale:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.dx_scale.b, 56
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rbx+48]
    mov       rdi,	rax
    mov       rcx,	rsi
    xor       edx,	edx
    call      cc_blockpcl.dx_expr
    movsxd    rax,	dword ptr[rbx+48]
    cmp       rax,	0
    jl        L8405
    movsxd    rax,	dword ptr[rbx+48]
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      cc_libpcl.setmode
    mov       rcx,	45
    xor       edx,	edx
    call      pc_api.pc_gen
    jmp       L8404
L8405:
    movsxd    rax,	dword ptr[rbx+48]
    neg       rax
    mov       rcx,	rax
    call      pc_api.genint
    mov       rcx,	1
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rcx,	4
    call      cc_libpcl.setmode
    mov       rcx,	47
    xor       edx,	edx
    call      pc_api.pc_gen
L8404:
    mov       rcx,	rsi
    call      cc_libpcl.setmode_u
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.widen
cc_blockpcl.widen:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    movsx     rax,	word ptr[rbx+56]
    test      rax,	rax
    jnz       L8408
    movsxd    rax,	dword ptr[rbx+52]
    mov       rcx,	rax
    call      cc_libpcl.setmode
    jmp       L8406
L8408:
    mov       rcx,	rbx
    call      cc_parse.getmemmode
    mov       rdi,	rax
    mov       rcx,	rdi
    call      cc_libpcl.setmode
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    cmp       rax,	4
    jge       L8410
    mov       rax,	[rip+pc_api.pccurr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	1
    jz        L8411
    cmp       rax,	2
    jz        L8411
    cmp       rax,	3
    jz        L8411
    cmp       rax,	86
    jz        L8411
    cmp       rax,	87
    jz        L8411
    cmp       rax,	88
    jz        L8411
    cmp       rax,	89
    jz        L8411
    cmp       rax,	21
    jnz       L8410
L8411:
    mov       rcx,	114
    xor       edx,	edx
    call      pc_api.pc_gen
    mov       rax,	rdi
    cmp       rax,	1
    jz        L8414
    cmp       rax,	2
    jnz       L8413
L8414:
    mov       rax,	3
    jmp       L8412
L8413:
    mov       rax,	8
L8412:
    mov       rcx,	rax
    call      cc_libpcl.setmode
    mov       rcx,	rdi
    call      cc_libpcl.setmode2
L8410:
L8406:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_blockpcl.do_setinplace
cc_blockpcl.do_setinplace:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+pc_api.pccurr]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	1
    jnz       L8417
    mov       rax,	[rip+pc_api.pccurr]
    movzx     rax,	byte ptr[rax+1]
    cmp       rax,	2
    jnz       L8417
    mov       eax,	1
    mov       r10,	[rip+pc_api.pccurr]
    mov       [r10+16],	eax
L8417:
#---------------
    ret       
# End 
# Proc cc_blockpcl.do_fixwiden
cc_blockpcl.do_fixwiden:
#PROC1
#PROC2
#?>>
    .set cc_blockpcl.do_fixwiden.a, 16
    .set cc_blockpcl.do_fixwiden.b, 24
#?]]
#---------------
#PROC3
#PROC4
L8418:
#---------------
    ret       
# End 
# Proc cc_libpcl.getpsymbol
cc_libpcl.getpsymbol:
#PROC1
#PROC2
#?>>
    .set cc_libpcl.getpsymbol.str, -256
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    test      rsi,	rsi
    jnz       L8421
    xor       eax,	eax
    jmp       L8419
L8421:
    mov       rax,	[rsi+56]
    test      rax,	rax
    jz        L8423
    mov       rax,	[rsi+56]
    jmp       L8419
L8423:
    mov       rbx,	[rsi]
    movzx     rax,	byte ptr[rsi+109]
    cmp       rax,	8
    jz        L8426
    cmp       rax,	9
    jnz       L8425
L8426:
    mov       rax,	[rsi]
    lea       rcx,	[rbp + cc_libpcl.getpsymbol.str]
    mov       rdx,	rax
    call      strcpy
    movzx     rax,	word ptr[rsi+96]
    cmp       rax,	1
    jle       L8428
    lea       rcx,	[rbp + cc_libpcl.getpsymbol.str]
    lea       rdx,	[rip+L11398]
    call      strcat
    movzx     rax,	word ptr[rsi+96]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rbp + cc_libpcl.getpsymbol.str]
    mov       rdx,	rax
    call      strcat
L8428:
    jmp       L8424
L8425:
    movzx     rax,	byte ptr[rsi+109]
    cmp       rax,	7
    jnz       L8429
    mov       rax,	[rsi+8]
    test      rax,	rax
    jz        L8429
    mov       rax,	[rsi+8]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	6
    jnz       L8429
    mov       rax,	[rsi+8]
    mov       rax,	[rax]
    lea       rcx,	[rbp + cc_libpcl.getpsymbol.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + cc_libpcl.getpsymbol.str]
    lea       rdx,	[rip+L11398]
    call      strcat
    mov       rax,	[rsi]
    lea       rcx,	[rbp + cc_libpcl.getpsymbol.str]
    mov       rdx,	rax
    call      strcat
    movzx     rax,	word ptr[rsi+96]
    cmp       rax,	1
    jle       L8431
    lea       rcx,	[rbp + cc_libpcl.getpsymbol.str]
    lea       rdx,	[rip+L11398]
    call      strcat
    movzx     rax,	word ptr[rsi+96]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rbp + cc_libpcl.getpsymbol.str]
    mov       rdx,	rax
    call      strcat
L8431:
    jmp       L8424
L8429:
    mov       rax,	[rsi]
    lea       rcx,	[rbp + cc_libpcl.getpsymbol.str]
    mov       rdx,	rax
    call      strcpy
L8424:
    movzx     rax,	byte ptr[rsi+109]
    lea       r10,	[rip+cc_tables.name2pid]
    movzx     r10,	byte ptr[r10 + rax]
    lea       rcx,	[rbp + cc_libpcl.getpsymbol.str]
    mov       rdx,	r10
    call      pc_api.pc_makesymbol
    mov       rdi,	rax
    mov       [rsi+56],	rax
    movzx     rax,	word ptr[rsi+102]
    mov       rcx,	rax
    call      cc_lib.getpclmode
    mov       [rdi+82],	al
    movzx     rax,	word ptr[rsi+102]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r10,	[r10 + rax*8]
    mov       [rdi+84],	r10d
    mov       rax,	[rsi+8]
    test      rax,	rax
    jz        L8433
    mov       rax,	[rsi+8]
    mov       rax,	[rax+8]
    test      rax,	rax
    jz        L8433
    mov       rax,	[rsi+8]
    mov       rcx,	rax
    call      cc_libpcl.getpsymbol
    mov       [rdi+32],	rax
L8433:
    movzx     rax,	byte ptr[rsi+110]
    cmp       rax,	4
    jnz       L8435
    mov       al,	1
    mov       [rdi+81],	al
L8435:
    movzx     rax,	byte ptr[rsi+110]
    cmp       rax,	3
    jnz       L8437
    mov       al,	1
    mov       [rdi+80],	al
    mov       al,	1
    mov       [rdi+72],	al
L8437:
    mov       al,	[rsi+122]
    mov       [rdi+92],	al
    mov       eax,	[rsi+88]
    mov       [rdi+100],	eax
    movzx     rax,	byte ptr[rsi+109]
    cmp       rax,	6
    jnz       L8439
    mov       rax,	[rsi]
    mov       rcx,	rax
    lea       rdx,	[rip+L11399]
    call      mlib.eqstring
    test      rax,	rax
    jz        L8439
    mov       al,	1
    mov       [rdi+110],	al
    lea       r10,	[rsi+108]
    and       byte ptr[r10],	247
    shl       al,	3
    or        [r10],	al
L8439:
    mov       rax,	rdi
L8419:
#---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_libpcl.setmode
cc_libpcl.setmode:
#PROC1
#PROC2
#?>>
    .set cc_libpcl.setmode.$T1, -8
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	40
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       [rbp + cc_libpcl.setmode.$T1],	rax
    mov       rcx,	rdi
    call      cc_lib.getpclmode
    mov       rcx,	rax
    mov       rdx,	[rbp + cc_libpcl.setmode.$T1]
    call      pc_api.pc_setmode
#---------------
    add       rsp,	40
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc cc_libpcl.setmode2
cc_libpcl.setmode2:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      cc_lib.getpclmode
    mov       rcx,	rax
    call      pc_api.pc_setmode2
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_libpcl.setmode_u
cc_libpcl.setmode_u:
#PROC1
#PROC2
#?>>
    .set cc_libpcl.setmode_u.$T1, -8
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[rbx+52]
    mov       rdi,	rax
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       [rbp + cc_libpcl.setmode_u.$T1],	rax
    mov       rcx,	rdi
    call      cc_lib.getpclmode
    mov       rcx,	rax
    mov       rdx,	[rbp + cc_libpcl.setmode_u.$T1]
    call      pc_api.pc_setmode
#---------------
    add       rsp,	48
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_libpcl.genmem_d
cc_libpcl.genmem_d:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      cc_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.genmem
L8443:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_libpcl.genmemaddr_d
cc_libpcl.genmemaddr_d:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      cc_libpcl.getpsymbol
    mov       rcx,	rax
    call      pc_api.genmemaddr
L8444:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_libpcl.definelabel
cc_libpcl.definelabel:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rax,	[rip+pc_api.mlabelno]
    mov       rcx,	rax
    call      pc_api.genlabel
    mov       rcx,	127
    mov       rdx,	rax
    call      pc_api.pc_gen
    mov       rax,	[rip+pc_api.mlabelno]
L8445:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_libpcl.createfwdlabel
cc_libpcl.createfwdlabel:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    inc       qword ptr[rip+pc_api.mlabelno]
    mov       rax,	[rip+pc_api.mlabelno]
L8446:
#---------------
    ret       
# End 
# Proc cc_libpcl.definefwdlabel
cc_libpcl.definefwdlabel:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      pc_api.genlabel
    mov       rcx,	127
    mov       rdx,	rax
    call      pc_api.pc_gen
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lib.newstrec
cc_lib.newstrec:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    mov       rcx,	128
    call      mlib.pcm_alloc
    mov       rdi,	rax
    mov       rax,	rdi
    xor       r10d,	r10d
    mov       r11,	4
L11400:
    mov       [rax],	r10
    mov       [rax+8],	r10
    mov       [rax+16],	r10
    mov       [rax+24],	r10
    add       rax,	32
    dec       r11
    jnz       L11400
    lea       rax,	[rip+cc_decls.lx]
    mov       eax,	[rax+16]
    mov       [rdi+92],	eax
    lea       rax,	[rip+cc_decls.lx]
    mov       al,	[rax+20]
    mov       [rdi+113],	al
    mov       rax,	rdi
L8448:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lib.initcclib
cc_lib.initcclib:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
#---------------
    ret       
# End 
# Proc cc_lib.createname
cc_lib.createname:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       rdi,	rax
    mov       eax,	3
    mov       [rdi+40],	eax
    mov       [rdi],	rbx
    mov       rax,	rdi
L8450:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createunit0
cc_lib.createunit0:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       rdi,	rax
    mov       [rdi+40],	ebx
    mov       rax,	rdi
L8451:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createunit1
cc_lib.createunit1:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       rdi,	rax
    mov       [rdi+40],	ebx
    mov       [rdi+16],	rsi
    mov       rax,	rdi
L8452:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createunit2
cc_lib.createunit2:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       rdi,	rax
    mov       [rdi+40],	ebx
    mov       [rdi+16],	rsi
    mov       [rdi+24],	r12
    mov       rax,	rdi
L8453:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createunit3
cc_lib.createunit3:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
    mov       r13,	r9
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       rdi,	rax
    mov       [rdi+40],	ebx
    mov       [rdi+16],	rsi
    mov       [rdi+24],	r12
    mov       [rdi+32],	r13
    mov       rax,	rdi
L8454:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createconstunit
cc_lib.createconstunit:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       rdi,	rax
    mov       eax,	1
    mov       [rdi+40],	eax
    mov       [rdi],	rbx
    mov       [rdi+52],	esi
    mov       rax,	rdi
L8455:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createstringconstunit
cc_lib.createstringconstunit:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       rdi,	rax
    mov       eax,	1
    mov       [rdi+40],	eax
    mov       [rdi],	rbx
    mov       eax,	[rip+cc_decls.trefchar]
    mov       [rdi+52],	eax
    cmp       rsi,	-1
    jnz       L8458
    mov       rcx,	rbx
    call      strlen
    mov       [rdi+48],	eax
    jmp       L8457
L8458:
    mov       [rdi+48],	esi
L8457:
    mov       al,	1
    mov       [rdi+61],	al
    mov       rax,	rdi
L8456:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createwstringconstunit
cc_lib.createwstringconstunit:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    call      cc_lib.allocunitrec
    mov       rdi,	rax
    mov       eax,	1
    mov       [rdi+40],	eax
    mov       [rdi],	rbx
    mov       eax,	[rip+cc_decls.trefwchar]
    mov       [rdi+52],	eax
    mov       [rdi+48],	esi
    mov       al,	1
    mov       [rdi+62],	al
    mov       rax,	rdi
L8459:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.getoptocode
cc_lib.getoptocode:
#PROC1
#PROC2
#?>>
    .set cc_lib.getoptocode.str, -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_lib.getoptocode.opctotable]
    mov       r10,	r12
    movsx     rax,	word ptr[rax + r10*2]
    mov       rdi,	rax
    test      rdi,	rdi
    jz        L8462
    mov       rax,	rdi
    jmp       L8460
L8462:
    lea       rax,	[rip+cc_tables.jtagnames]
    mov       r10,	r12
    mov       rax,	[rax + r10*8]
    lea       rcx,	[rbp + cc_lib.getoptocode.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rbp + cc_lib.getoptocode.str]
    lea       rdx,	[rip+L11401]
    call      strcat
    xor       rbx,	rbx
    mov       rax,	77
    mov       rsi,	rax
    cmp       rsi,	0
    jl        L8465
L8463:
    lea       rax,	[rip+cc_tables.jtagnames]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    lea       rdx,	[rbp + cc_lib.getoptocode.str]
    call      mlib.eqstring
    test      rax,	rax
    jz        L8467
    mov       ax,	bx
    lea       r10,	[rip+cc_lib.getoptocode.opctotable]
    mov       r11,	r12
    mov       [r10 + r11*2],	ax
    mov       rax,	rbx
    jmp       L8460
L8467:
    inc       rbx
    cmp       rbx,	rsi
    jle       L8463
L8465:
    call      msys.m$print_startcon
    lea       rax,	[rip+cc_tables.jtagnames]
    mov       r10,	r12
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11402]
    call      cc_support.serror
    xor       eax,	eax
L8460:
#---------------
    add       rsp,	64
    pop       rbp
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.getconstvalue
cc_lib.getconstvalue:
#PROC1
#PROC2
#?>>
    .set cc_lib.getconstvalue.id, 32
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    test      rdi,	rdi
    jz        L8470
    movsxd    rax,	dword ptr[rdi+40]
    cmp       rax,	1
    jnz       L8470
    mov       rax,	[rdi]
    jmp       L8468
L8470:
    lea       rcx,	[rip+L11403]
    call      cc_support.serror
    xor       eax,	eax
L8468:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lib.nextautotype
cc_lib.nextautotype:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+cc_lib.nextautotype.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L11404]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword ptr[rip+cc_lib.autotypeno]
    mov       rcx,	[rip+cc_lib.autotypeno]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rax,	[rip+cc_lib.nextautotype.str]
L8471:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_lib.createconstmode
cc_lib.createconstmode:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.ttconst]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L8474
    mov       rax,	rbx
    jmp       L8472
L8474:
    lea       rax,	[rip+cc_decls.ttconsttype]
    mov       r10,	rbx
    mov       ax,	[rax + r10*2]
    test      ax,	ax
    jz        L8476
    lea       rax,	[rip+cc_decls.ttconsttype]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    jmp       L8472
L8476:
    mov       rcx,	rbx
    call      cc_lib.copymode
    mov       rdi,	rax
    mov       ax,	di
    lea       r10,	[rip+cc_decls.ttconsttype]
    mov       r11,	rbx
    mov       [r10 + r11*2],	ax
    mov       al,	1
    lea       r10,	[rip+cc_decls.ttconst]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       ax,	bx
    lea       r10,	[rip+cc_decls.ttconsttype]
    mov       r11,	rdi
    mov       [r10 + r11*2],	ax
    mov       rax,	rdi
L8472:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createrefmode
cc_lib.createrefmode:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.ttreftype]
    mov       r10,	rbx
    mov       ax,	[rax + r10*2]
    test      ax,	ax
    jz        L8479
    lea       rax,	[rip+cc_decls.ttreftype]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    lea       r10,	[rip+cc_decls.ttshared]
    lea       r10,	[r10 + rax*4]
    inc       dword ptr[r10]
    lea       rax,	[rip+cc_decls.ttreftype]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    jmp       L8477
L8479:
    mov       rcx,	13
    call      cc_lib.createnewmode
    mov       rdi,	rax
    mov       ax,	di
    lea       r10,	[rip+cc_decls.ttreftype]
    mov       r11,	rbx
    mov       [r10 + r11*2],	ax
    mov       ax,	bx
    lea       r10,	[rip+cc_decls.tttarget]
    mov       r11,	rdi
    mov       [r10 + r11*2],	ax
    mov       al,	1
    lea       r10,	[rip+cc_decls.ttisref]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       rax,	rdi
L8477:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createprocmode
cc_lib.createprocmode:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	14
    call      cc_lib.createnewmode
    mov       rdi,	rax
    mov       rax,	rsi
    lea       r10,	[rip+cc_decls.ttparams]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    mov       ax,	bx
    lea       r10,	[rip+cc_decls.tttarget]
    mov       r11,	rdi
    mov       [r10 + r11*2],	ax
    mov       rax,	rdi
L8480:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createarraymode
cc_lib.createarraymode:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	17
    call      cc_lib.createnewmode
    mov       rdi,	rax
    mov       ax,	bx
    lea       r10,	[rip+cc_decls.tttarget]
    mov       r11,	rdi
    mov       [r10 + r11*2],	ax
    mov       rax,	rsi
    lea       r10,	[rip+cc_decls.ttlength]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    mov       r10,	rsi
    imul      r10,	rax
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r11,	rdi
    mov       [rax + r11*8],	r10
    mov       al,	1
    lea       r10,	[rip+cc_decls.ttisblock]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       rax,	rdi
L8481:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createenummode
cc_lib.createenummode:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	12
    call      cc_lib.createnewmode
    mov       rdi,	rax
    mov       rax,	rbx
    lea       r10,	[rip+cc_decls.ttnamedef]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    mov       rax,	rdi
L8482:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createstructmode
cc_lib.createstructmode:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rsi
    call      cc_lib.createnewmode
    mov       rdi,	rax
    mov       rax,	rbx
    lea       r10,	[rip+cc_decls.ttnamedef]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    mov       al,	1
    lea       r10,	[rip+cc_decls.ttisblock]
    mov       r11,	rdi
    mov       [r10 + r11],	al
    mov       rax,	rdi
L8483:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.setnameptr
cc_lib.setnameptr:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rcx]
    mov       r10,	rcx
    mov       [rax+72],	r10
#---------------
    ret       
# End 
# Proc cc_lib.getautofieldname
cc_lib.getautofieldname:
#PROC1
#PROC2
#?>>
    .set cc_lib.getautofieldname.str, -32
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	72
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + cc_lib.getautofieldname.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L11405]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    inc       qword ptr[rip+cc_lib.nextafindex]
    mov       rcx,	[rip+cc_lib.nextafindex]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + cc_lib.getautofieldname.str]
    call      mlib.pcm_copyheapstring
    mov       rdi,	rax
    mov       rcx,	rdi
    call      cc_lex.addnamestr
L8485:
#---------------
    add       rsp,	72
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc cc_lib.convertstringc
cc_lib.convertstringc:
#PROC1
#PROC2
#?>>
    .set cc_lib.convertstringc.str, -24
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	64
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
#---------------
#PROC3
#PROC4
    cmp       r14,	-1
    jnz       L8488
    mov       rcx,	r12
    call      strlen
    mov       r14,	rax
L8488:
    mov       rbx,	r13
    mov       rsi,	r14
    cmp       rsi,	0
    jle       L8491
L8489:
    mov       rax,	r12
    inc       r12
    movzx     rax,	byte ptr[rax]
    mov       rdi,	rax
    lea       rax,	[rdi-7]
    cmp       rax,	86
    jae       L8494
    lea       r10,	[rip+L8493]
    jmp       [r10 + rax*8]
    .data
L8493:
    .quad     L8501
    .quad     L8502
    .quad     L8499
    .quad     L8497
    .quad     L8504
    .quad     L8503
    .quad     L8498
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8495
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8496
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8494
    .quad     L8500
    .text
L8495:
    mov       rax,	r13
    inc       r13
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r13
    inc       r13
    mov       r10b,	34
    mov       [rax],	r10b
    jmp       L8492
L8496:
    mov       rax,	r13
    inc       r13
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r13
    inc       r13
    mov       r10b,	39
    mov       [rax],	r10b
    jmp       L8492
L8497:
    mov       rax,	r13
    inc       r13
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r13
    inc       r13
    mov       r10b,	110
    mov       [rax],	r10b
    jmp       L8492
L8498:
    mov       rax,	r13
    inc       r13
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r13
    inc       r13
    mov       r10b,	114
    mov       [rax],	r10b
    jmp       L8492
L8499:
    mov       rax,	r13
    inc       r13
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r13
    inc       r13
    mov       r10b,	116
    mov       [rax],	r10b
    jmp       L8492
L8500:
    mov       rax,	r13
    inc       r13
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r13
    inc       r13
    mov       r10b,	92
    mov       [rax],	r10b
    jmp       L8492
L8501:
    mov       rax,	r13
    inc       r13
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r13
    inc       r13
    mov       r10b,	97
    mov       [rax],	r10b
    jmp       L8492
L8502:
    mov       rax,	r13
    inc       r13
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r13
    inc       r13
    mov       r10b,	98
    mov       [rax],	r10b
    jmp       L8492
L8503:
    mov       rax,	r13
    inc       r13
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r13
    inc       r13
    mov       r10b,	102
    mov       [rax],	r10b
    jmp       L8492
L8504:
    mov       rax,	r13
    inc       r13
    mov       r10b,	92
    mov       [rax],	r10b
    mov       rax,	r13
    inc       r13
    mov       r10b,	118
    mov       [rax],	r10b
    jmp       L8492
L8494:
    cmp       rdi,	32
    jl        L8507
    cmp       rdi,	127
    jl        L8506
L8507:
    lea       rcx,	[rbp + cc_lib.convertstringc.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L11406]
    call      msys.m$print_setfmt
    mov       rcx,	rdi
    lea       rdx,	[rip+L11407]
    call      msys.m$print_i64
    call      msys.m$print_end
    mov       al,	[rbp + cc_lib.convertstringc.str]
    mov       r10,	r13
    inc       r13
    mov       [r10],	al
    mov       al,	[rbp + cc_lib.convertstringc.str+1]
    mov       r10,	r13
    inc       r13
    mov       [r10],	al
    mov       al,	[rbp + cc_lib.convertstringc.str+2]
    mov       r10,	r13
    inc       r13
    mov       [r10],	al
    mov       al,	[rbp + cc_lib.convertstringc.str+3]
    mov       r10,	r13
    inc       r13
    mov       [r10],	al
    jmp       L8505
L8506:
    mov       rax,	r13
    inc       r13
    mov       r10b,	dil
    mov       [rax],	r10b
L8505:
L8492:
    dec       rsi
    jnz       L8489
L8491:
    xor       eax,	eax
    mov       [r13],	al
    mov       rax,	r13
    sub       rax,	rbx
L8486:
#---------------
    add       rsp,	64
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.getopcjname
cc_lib.getopcjname:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_tables.jtagnames]
    mov       r10,	rsi
    mov       rdi,	[rax + r10*8]
    mov       rcx,	rdi
    mov       rdx,	32
    call      strchr
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L8510
    mov       rax,	rbx
    sub       rax,	rdi
    lea       rcx,	[rip+cc_lib.getopcjname.str]
    mov       rdx,	rdi
    mov       r8,	rax
    call      memcpy
    mov       rax,	rbx
    sub       rax,	rdi
    xor       r10d,	r10d
    lea       r11,	[rip+cc_lib.getopcjname.str]
    mov       [r11 + rax],	r10b
    lea       rax,	[rip+cc_lib.getopcjname.str]
    jmp       L8509
L8510:
    mov       rax,	rdi
L8509:
L8508:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.strmode
cc_lib.strmode:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    lea       r8,	[rip+cc_lib.strmode.str]
    call      cc_lib.istrmode
    lea       rax,	[rip+cc_lib.strmode.str]
L8511:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.strmode2
cc_lib.strmode2:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    lea       r8,	[rip+cc_lib.strmode2.str]
    call      cc_lib.istrmode
    lea       rax,	[rip+cc_lib.strmode2.str]
L8512:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.istrmode
cc_lib.istrmode:
#PROC1
#PROC2
#?>>
    .set cc_lib.istrmode.expand, 80
    .set cc_lib.istrmode.dest, 88
    .set cc_lib.istrmode.n, -8
    .set cc_lib.istrmode.sxx, -24
    .set cc_lib.istrmode.xx, -32
    .set cc_lib.istrmode.pm, -40
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	72
    mov       r15,	rcx
    mov       [rbp+80],	rdx
    mov       [rbp+88],	r8
#---------------
#PROC3
#PROC4
    lea       rax,	[rbp + cc_lib.istrmode.sxx]
    mov       [rbp + cc_lib.istrmode.xx],	rax
    cmp       r15,	21
    jge       L8515
    mov       rcx,	r15
    call      cc_lib.typename
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcpy
    jmp       L8513
L8515:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	r15
    movsx     rax,	word ptr[rax + r10*2]
    mov       r14,	rax
    mov       rax,	r14
    cmp       rax,	13
    jz        L8517
    cmp       rax,	17
    jz        L8518
    cmp       rax,	12
    jz        L8519
    cmp       rax,	18
    jz        L8520
    cmp       rax,	19
    jz        L8520
    test      rax,	rax
    jz        L8521
    cmp       rax,	14
    jz        L8522
    jmp       L8523
L8517:
    lea       rax,	[rip+cc_decls.ttconst]
    mov       r10,	r15
    mov       al,	[rax + r10]
    test      al,	al
    jz        L8525
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    lea       rdx,	[rip+L11408]
    call      strcpy
    jmp       L8524
L8525:
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    lea       rdx,	[rip+L11409]
    call      strcpy
L8524:
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	r15
    movsx     rax,	word ptr[rax + r10*2]
    mov       r13,	rax
    cmp       r13,	0
    jl        L8527
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	r15
    movsx     rax,	word ptr[rax + r10*2]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    cmp       r10,	18
    jnz       L8527
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	r15
    movsx     rax,	word ptr[rax + r10*2]
    mov       rcx,	rax
    call      cc_lib.typename
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
    jmp       L8526
L8527:
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + cc_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r11,	r15
    movsx     rax,	word ptr[rax + r11*2]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      cc_lib.istrmode
L8526:
    jmp       L8516
L8518:
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	r15
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L8529
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L11410]
    call      msys.m$print_setfmt
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	r15
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8528
L8529:
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    lea       rdx,	[rip+L11411]
    call      strcpy
L8528:
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + cc_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r11,	r15
    movsx     rax,	word ptr[rax + r11*2]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      cc_lib.istrmode
    jmp       L8516
L8519:
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    lea       rdx,	[rip+L11412]
    call      strcpy
    mov       rcx,	r15
    call      cc_lib.typename
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
    jmp       L8516
L8520:
    mov       rax,	[rbp + cc_lib.istrmode.expand]
    test      rax,	rax
    jnz       L8531
    mov       rcx,	r15
    call      cc_lib.typename
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcpy
    jmp       L8513
L8531:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	r15
    movsx     rax,	word ptr[rax + r10*2]
    mov       rcx,	rax
    call      cc_lib.typename
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcpy
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    lea       rdx,	[rip+L11413]
    call      strcat
    lea       rax,	[rip+cc_decls.ttnamedef]
    mov       r10,	r15
    mov       rdi,	[rax + r10*8]
    xor       rsi,	rsi
    mov       rax,	[rdi+16]
    mov       rbx,	rax
    jmp       L8533
L8532:
    test      rsi,	rsi
    jz        L8536
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    lea       rdx,	[rip+L11414]
    call      strcat
L8536:
    mov       rsi,	1
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + cc_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    movzx     rax,	word ptr[rbx+102]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      cc_lib.istrmode
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    lea       rdx,	[rip+L11415]
    call      strcat
    mov       rax,	[rbx]
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcat
    mov       rbx,	[rbx+32]
L8533:
    test      rbx,	rbx
    jnz       L8532
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    lea       rdx,	[rip+L11416]
    call      strcat
    jmp       L8516
L8521:
    mov       rcx,	r15
    call      cc_lib.typename
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcpy
    jmp       L8516
L8522:
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    lea       rdx,	[rip+L11417]
    call      strcpy
    lea       rax,	[rip+cc_decls.ttparams]
    mov       r10,	r15
    mov       rax,	[rax + r10*8]
    mov       [rbp + cc_lib.istrmode.pm],	rax
    mov       rax,	[rbp + cc_lib.istrmode.pm]
    movsx     rax,	word ptr[rax+20]
    mov       [rbp + cc_lib.istrmode.n],	rax
    mov       r12,	1
    mov       rax,	[rbp + cc_lib.istrmode.n]
    cmp       rax,	1
    jl        L8539
L8537:
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + cc_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    mov       rax,	[rbp + cc_lib.istrmode.pm]
    movsxd    rax,	dword ptr[rax+16]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      cc_lib.istrmode
    cmp       r12,	[rbp + cc_lib.istrmode.n]
    jz        L8541
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    lea       rdx,	[rip+L11418]
    call      strcat
L8541:
    mov       rax,	[rbp + cc_lib.istrmode.pm]
    mov       rax,	[rax+8]
    mov       [rbp + cc_lib.istrmode.pm],	rax
    inc       r12
    cmp       r12,	[rbp + cc_lib.istrmode.n]
    jle       L8537
L8539:
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    lea       rdx,	[rip+L11419]
    call      strcat
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    call      strlen
    mov       r10,	[rbp + cc_lib.istrmode.dest]
    lea       r10,	[r10 + rax]
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r11,	r15
    movsx     rax,	word ptr[rax + r11*2]
    mov       rcx,	rax
    xor       edx,	edx
    mov       r8,	r10
    call      cc_lib.istrmode
    jmp       L8516
L8523:
    cmp       r14,	21
    jge       L8543
    mov       rcx,	r15
    call      cc_lib.typename
    mov       rcx,	[rbp + cc_lib.istrmode.dest]
    mov       rdx,	rax
    call      strcpy
    jmp       L8513
L8543:
    call      msys.m$print_startcon
    mov       rcx,	r15
    call      cc_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11420]
    call      cc_support.mcerror
L8542:
L8516:
L8513:
#---------------
    add       rsp,	72
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.typename
cc_lib.typename:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    mov       rdi,	rax
    mov       rax,	rdi
    cmp       rax,	18
    jz        L8546
    cmp       rax,	19
    jz        L8546
    cmp       rax,	17
    jz        L8547
    cmp       rax,	12
    jz        L8548
    jmp       L8549
L8546:
    cmp       rdi,	18
    jnz       L8551
    lea       rax,	[rip+L11421]
    jmp       L8550
L8551:
    lea       rax,	[rip+L11422]
L8550:
    lea       rcx,	[rip+cc_lib.typename.str]
    mov       rdx,	rax
    call      strcpy
    lea       rax,	[rip+cc_decls.ttnamedef]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L8553
    lea       rax,	[rip+cc_decls.ttnamedef]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax]
    lea       rcx,	[rip+cc_lib.typename.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rip+cc_lib.typename.str]
    lea       rdx,	[rip+L11423]
    call      strcat
    lea       rax,	[rip+cc_decls.ttnamedef]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    movzx     rax,	word ptr[rax+96]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strint
    lea       rcx,	[rip+cc_lib.typename.str]
    mov       rdx,	rax
    call      strcat
L8553:
    lea       rax,	[rip+cc_lib.typename.str]
    jmp       L8544
L8547:
    lea       rax,	[rip+L11424]
    jmp       L8544
L8548:
    lea       rax,	[rip+cc_decls.ttnamedef]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L8555
    lea       rax,	[rip+cc_decls.ttnamedef]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    mov       rax,	[rax]
    jmp       L8544
L8555:
    lea       rax,	[rip+L11425]
    jmp       L8544
L8549:
    lea       rax,	[rip+cc_decls.ttconst]
    mov       r10,	rbx
    mov       al,	[rax + r10]
    test      al,	al
    jz        L8557
    lea       rcx,	[rip+cc_lib.typename.str]
    lea       rdx,	[rip+L11426]
    call      strcpy
    lea       rax,	[rip+cc_tables.stdtypenames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       rcx,	[rip+cc_lib.typename.str]
    mov       rdx,	rax
    call      strcat
    lea       rax,	[rip+cc_lib.typename.str]
    jmp       L8544
L8557:
    lea       rax,	[rip+cc_tables.stdtypenames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    jmp       L8544
L8545:
    lea       rax,	[rip+L11427]
L8544:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.allocunitrec
cc_lib.allocunitrec:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
#---------------
#PROC3
#PROC4
    inc       qword ptr[rip+cc_decls.nunits]
    mov       rax,	[rip+cc_lib.remainingunits]
    dec       qword ptr[rip+cc_lib.remainingunits]
    test      rax,	rax
    jz        L8560
    mov       rdi,	[rip+cc_lib.unitheapptr]
    add       qword ptr[rip+cc_lib.unitheapptr],	64
    lea       rax,	[rip+cc_decls.lx]
    mov       eax,	[rax+16]
    mov       [rdi+44],	eax
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+20]
    cmp       rax,	255
    jg        L8562
    lea       rax,	[rip+cc_decls.lx]
    mov       al,	[rax+20]
    mov       [rdi+60],	al
L8562:
    mov       rax,	rdi
    jmp       L8558
L8560:
    mov       rcx,	3200000
    call      mlib.pcm_alloc
    mov       [rip+cc_lib.unitheapptr],	rax
    mov       rdi,	rax
    mov       rcx,	rdi
    xor       edx,	edx
    mov       r8,	3200000
    call      memset
    mov       rax,	49999
    mov       [rip+cc_lib.remainingunits],	rax
    add       qword ptr[rip+cc_lib.unitheapptr],	64
    lea       rax,	[rip+cc_decls.lx]
    mov       eax,	[rax+16]
    mov       [rdi+44],	eax
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+20]
    cmp       rax,	255
    jg        L8564
    lea       rax,	[rip+cc_decls.lx]
    mov       al,	[rax+20]
    mov       [rdi+60],	al
L8564:
    mov       rax,	rdi
L8558:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lib.copymode
cc_lib.copymode:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_decls.ntypes]
    cmp       rax,	80000
    jl        L8567
    lea       rcx,	[rip+L11428]
    call      cc_support.serror
L8567:
    inc       qword ptr[rip+cc_decls.ntypes]
    lea       rax,	[rip+cc_decls.ttnamedef]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       r10,	[rip+cc_decls.ttnamedef]
    mov       r11,	[rip+cc_decls.ntypes]
    mov       [r10 + r11*8],	rax
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rdi
    mov       ax,	[rax + r10*2]
    lea       r10,	[rip+cc_decls.ttbasetype]
    mov       r11,	[rip+cc_decls.ntypes]
    mov       [r10 + r11*2],	ax
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       r10,	[rip+cc_decls.ttlength]
    mov       r11,	[rip+cc_decls.ntypes]
    mov       [r10 + r11*8],	rax
    lea       rax,	[rip+cc_decls.ttconst]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    lea       r10,	[rip+cc_decls.ttconst]
    mov       r11,	[rip+cc_decls.ntypes]
    mov       [r10 + r11],	al
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r11,	[rip+cc_decls.ntypes]
    mov       [r10 + r11*8],	rax
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	rdi
    mov       ax,	[rax + r10*2]
    lea       r10,	[rip+cc_decls.tttarget]
    mov       r11,	[rip+cc_decls.ntypes]
    mov       [r10 + r11*2],	ax
    lea       rax,	[rip+cc_decls.ttparams]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       r10,	[rip+cc_decls.ttparams]
    mov       r11,	[rip+cc_decls.ntypes]
    mov       [r10 + r11*8],	rax
    lea       rax,	[rip+cc_decls.ttisref]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    lea       r10,	[rip+cc_decls.ttisref]
    mov       r11,	[rip+cc_decls.ntypes]
    mov       [r10 + r11],	al
    lea       rax,	[rip+cc_decls.ttisblock]
    mov       r10,	rdi
    mov       al,	[rax + r10]
    lea       r10,	[rip+cc_decls.ttisblock]
    mov       r11,	[rip+cc_decls.ntypes]
    mov       [r10 + r11],	al
    mov       rax,	[rip+cc_decls.ntypes]
L8565:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lib.createnewmode
cc_lib.createnewmode:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_decls.ntypes]
    cmp       rax,	80000
    jl        L8570
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11429]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11430]
    call      cc_support.serror
L8570:
    inc       qword ptr[rip+cc_decls.ntypes]
    mov       ax,	di
    lea       r10,	[rip+cc_decls.ttbasetype]
    mov       r11,	[rip+cc_decls.ntypes]
    mov       [r10 + r11*2],	ax
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r11,	[rip+cc_decls.ntypes]
    mov       [r10 + r11*8],	rax
    mov       rax,	[rip+cc_decls.ntypes]
L8568:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lib.addlistunit
cc_lib.addlistunit:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rcx]
    test      rax,	rax
    jnz       L8573
    mov       rax,	r8
    mov       [rdx],	rax
    mov       [rcx],	rax
    jmp       L8572
L8573:
    mov       rax,	[rdx]
    mov       r10,	r8
    mov       [rax+8],	r10
L8572:
    xor       eax,	eax
    mov       [r8+8],	rax
    mov       [rdx],	r8
#---------------
    ret       
# End 
# Proc cc_lib.addlistdef
cc_lib.addlistdef:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rcx]
    test      rax,	rax
    jnz       L8576
    mov       rax,	r8
    mov       [rdx],	rax
    mov       [rcx],	rax
    jmp       L8575
L8576:
    mov       rax,	[rdx]
    mov       r10,	r8
    mov       [rax+32],	r10
L8575:
    xor       eax,	eax
    mov       [r8+32],	rax
    mov       [rdx],	r8
#---------------
    ret       
# End 
# Proc cc_lib.addlistparam
cc_lib.addlistparam:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rcx]
    test      rax,	rax
    jnz       L8579
    mov       rax,	r8
    mov       [rdx],	rax
    mov       [rcx],	rax
    jmp       L8578
L8579:
    mov       rax,	[rdx]
    mov       r10,	r8
    mov       [rax+8],	r10
L8578:
    xor       eax,	eax
    mov       [r8+8],	rax
    mov       [rdx],	r8
#---------------
    ret       
# End 
# Proc cc_lib.checksymbol
cc_lib.checksymbol:
#PROC1
#PROC2
#?>>
    .set cc_lib.checksymbol.str, -256
    push      rdi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	rdi
    jz        L8582
    lea       rcx,	[rbp + cc_lib.checksymbol.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L11431]
    call      msys.m$print_setfmt
    lea       rax,	[rip+cc_tables.symbolnames]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8-8]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    lea       r10,	[rip+cc_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	67
    jnz       L8584
    lea       rcx,	[rbp + cc_lib.checksymbol.str]
    lea       rdx,	[rip+L11432]
    call      strcat
    lea       rax,	[rip+cc_decls.lx]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      cc_lib.getstname
    lea       rcx,	[rbp + cc_lib.checksymbol.str]
    mov       rdx,	rax
    call      strcat
    lea       rcx,	[rbp + cc_lib.checksymbol.str]
    lea       rdx,	[rip+L11433]
    call      strcat
L8584:
    lea       rcx,	[rbp + cc_lib.checksymbol.str]
    call      cc_support.serror
L8582:
#---------------
    add       rsp,	296
    pop       rbp
    pop       rdi
    ret       
# End 
# Proc cc_lib.skipsymbol
cc_lib.skipsymbol:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+21]
    cmp       rax,	rdi
    jz        L8587
    mov       rcx,	rdi
    call      cc_lib.checksymbol
L8587:
    call      cc_lex.lex
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lib.inittypetables
cc_lib.inittypetables:
#PROC1
#PROC2
#?>>
    .set cc_lib.inittypetables.av_2, -8
    .set cc_lib.inittypetables.av_3, -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
    push      r15
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	56
#---------------
#PROC3
#PROC4
    xor       rdi,	rdi
    mov       rax,	20
    mov       r15,	rax
    cmp       r15,	0
    jl        L8591
L8589:
    mov       ax,	di
    lea       r10,	[rip+cc_decls.ttbasetype]
    mov       r11,	rdi
    mov       [r10 + r11*2],	ax
    lea       rax,	[rip+cc_tables.stdtypewidths]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10]
    mov       rsi,	rax
    mov       rax,	rsi
    sar       rax,	3
    mov       rbx,	rax
    mov       rax,	rbx
    lea       r10,	[rip+cc_decls.ttsize]
    mov       r11,	rdi
    mov       [r10 + r11*8],	rax
    mov       rax,	rdi
    cmp       rax,	17
    jz        L8594
    cmp       rax,	18
    jnz       L8593
L8594:
    mov       al,	1
    lea       r10,	[rip+cc_decls.ttisblock]
    mov       r11,	rdi
    mov       [r10 + r11],	al
L8593:
    inc       rdi
    cmp       rdi,	r15
    jle       L8589
L8591:
    mov       rax,	20
    mov       [rip+cc_decls.ntypes],	rax
    mov       rcx,	1
    call      cc_lib.createrefmode
    mov       [rip+cc_decls.trefchar],	rax
    mov       rcx,	7
    call      cc_lib.createrefmode
    mov       [rip+cc_decls.trefwchar],	rax
    mov       rdi,	1
    mov       rax,	121
    mov       [rbp + cc_lib.inittypetables.av_2],	rax
    mov       rax,	[rbp + cc_lib.inittypetables.av_2]
    cmp       rax,	1
    jl        L8597
L8595:
    lea       rax,	[rip+cc_tables.dominantsetuptable]
    mov       r10,	rdi
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-3]
    movzx     rax,	byte ptr[rax]
    mov       r12,	rax
    lea       rax,	[rip+cc_tables.dominantsetuptable]
    mov       r10,	rdi
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-3]
    movzx     rax,	byte ptr[rax+1]
    mov       r13,	rax
    lea       rax,	[rip+cc_tables.dominantsetuptable]
    mov       r10,	rdi
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-3]
    movzx     rax,	byte ptr[rax+2]
    mov       r14,	rax
    lea       rax,	[rip+cc_tables.dominantmode]
    mov       r10,	r12
    shl       r10,	5
    lea       rax,	[rax + r10]
    mov       r10b,	r14b
    mov       r11,	r13
    mov       [rax + r11],	r10b
    inc       rdi
    cmp       rdi,	[rbp + cc_lib.inittypetables.av_2]
    jle       L8595
L8597:
    mov       rdi,	1
    mov       rax,	121
    mov       [rbp + cc_lib.inittypetables.av_3],	rax
    mov       rax,	[rbp + cc_lib.inittypetables.av_3]
    cmp       rax,	1
    jl        L8600
L8598:
    lea       rax,	[rip+cc_tables.convsetuptable]
    mov       r10,	rdi
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-3]
    movzx     rax,	byte ptr[rax]
    mov       r12,	rax
    lea       rax,	[rip+cc_tables.convsetuptable]
    mov       r10,	rdi
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-3]
    movzx     rax,	byte ptr[rax+1]
    mov       r13,	rax
    lea       rax,	[rip+cc_tables.convsetuptable]
    mov       r10,	rdi
    lea       r10,	[r10 + r10*2]
    lea       rax,	[rax + r10-3]
    movzx     rax,	byte ptr[rax+2]
    mov       r14,	rax
    lea       rax,	[rip+cc_tables.conversionops]
    mov       r10,	r12
    shl       r10,	4
    lea       rax,	[rax + r10]
    mov       r10b,	r14b
    mov       r11,	r13
    mov       [rax + r11],	r10b
    inc       rdi
    cmp       rdi,	[rbp + cc_lib.inittypetables.av_3]
    jle       L8598
L8600:
#---------------
    add       rsp,	56
    pop       rbp
    pop       r15
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createdupldef
cc_lib.createdupldef:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
#---------------
#PROC3
#PROC4
    call      cc_lib.newstrec
    mov       rdi,	rax
    mov       rax,	[r12]
    mov       [rdi],	rax
    mov       al,	[r12+106]
    mov       [rdi+106],	al
    mov       al,	67
    mov       [rdi+107],	al
    mov       [rdi+8],	rsi
    mov       [rdi+109],	r13b
    lea       rax,	[rip+cc_tables.namespaces]
    mov       r10,	r13
    mov       eax,	[rax + r10*4]
    mov       [rdi+98],	ax
    mov       rax,	[r12+40]
    mov       rbx,	rax
    test      rax,	rax
    jz        L8603
    mov       [rbx+48],	rdi
L8603:
    mov       [rdi+40],	rbx
    mov       [rdi+48],	r12
    mov       [r12+40],	rdi
    test      rsi,	rsi
    jz        L8605
    mov       rax,	[rsi+16]
    test      rax,	rax
    jnz       L8607
    mov       rax,	rdi
    mov       [rsi+24],	rax
    mov       [rsi+16],	rax
    jmp       L8606
L8607:
    mov       rax,	[rsi+24]
    mov       r10,	rdi
    mov       [rax+32],	r10
    mov       [rsi+24],	rdi
L8606:
L8605:
    mov       rax,	rdi
L8601:
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createnewmoduledef
cc_lib.createnewmoduledef:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	3
    call      cc_lib.createdupldef
    mov       rdi,	rax
    mov       rax,	rdi
L8608:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.createnewproc
cc_lib.createnewproc:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rsi
    mov       rdx,	r12
    mov       r8,	6
    call      cc_lib.createdupldef
    mov       rdi,	rax
    mov       rbx,	rdi
    jmp       L8611
L8610:
    mov       rax,	[rbx+8]
    cmp       rax,	rsi
    jnz       L8614
    call      msys.m$print_startcon
    mov       rcx,	[rbx]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11434]
    call      msys.m$print_str_nf
    mov       rcx,	[rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11435]
    call      cc_support.serror
L8614:
L8611:
    mov       rax,	[rbx+40]
    mov       rbx,	rax
    test      rax,	rax
    jnz       L8610
    mov       rax,	rdi
L8609:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.resolvename
cc_lib.resolvename:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
    mov       r13,	r8
    mov       r14,	r9
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[r12+109]
    cmp       rax,	1
    jle       L8617
    mov       rax,	r12
    jmp       L8615
L8617:
    cmp       r13,	3
    jnz       L8619
    mov       rcx,	rsi
    mov       rdx,	r12
    call      cc_lib.resolvelabel
    jmp       L8615
L8619:
    test      r14,	r14
    jz        L8621
    lea       rax,	[rip+cc_decls.blockcounts]
    mov       r10,	r14
    movsxd    rax,	dword ptr[rax + r10*4]
    test      rax,	rax
    jnz       L8621
    lea       rax,	[rip+cc_decls.blockowner]
    mov       r10,	r14
    movsxd    rax,	dword ptr[rax + r10*4]
    mov       r14,	rax
L8621:
L8622:
    mov       rax,	r13
    shl       rax,	16
    or        rax,	r14
    mov       rdi,	rax
    mov       rbx,	r12
    jmp       L8625
L8624:
    movzx     rax,	byte ptr[rsi+109]
    cmp       rax,	6
    jnz       L8628
    mov       rax,	[rbx+8]
    cmp       rax,	rsi
    jz        L8628
    mov       rax,	[rbx+8]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	6
    jz        L8626
L8628:
    mov       rax,	[rbx+8]
    cmp       rax,	rsi
    jnz       L8630
    mov       eax,	[rbx+96]
    cmp       rax,	rdi
    jnz       L8630
    movzx     rax,	byte ptr[rbx+122]
    cmp       rax,	255
    jge       L8632
    lea       rax,	[rbx+122]
    inc       byte ptr[rax]
L8632:
    mov       rax,	rbx
    jmp       L8615
L8630:
L8625:
    mov       rax,	[rbx+40]
    mov       rbx,	rax
    test      rax,	rax
    jnz       L8624
L8626:
    test      r14,	r14
    jnz       L8634
    movzx     rax,	byte ptr[rsi+109]
    cmp       rax,	6
    jz        L8636
    cmp       rax,	13
    jz        L8637
    jmp       L8638
L8636:
    mov       rsi,	[rip+cc_decls.stmodule]
    jmp       L8622
L8637:
    mov       rsi,	[rsi+8]
    test      rsi,	rsi
    jnz       L8640
    xor       eax,	eax
    jmp       L8615
L8640:
    jmp       L8635
L8638:
    xor       eax,	eax
    jmp       L8615
L8635:
    jmp       L8633
L8634:
    lea       rax,	[rip+cc_decls.blockowner]
    mov       r10,	r14
    movsxd    rax,	dword ptr[rax + r10*4]
    mov       r14,	rax
    test      rax,	rax
    jnz       L8641
    mov       rsi,	[rip+cc_decls.stmodule]
L8641:
L8633:
    jmp       L8622
    xor       eax,	eax
L8615:
#---------------
    add       rsp,	40
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.resolvelabel
cc_lib.resolvelabel:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    mov       rdi,	rdx
    jmp       L8644
L8643:
    movzx     rax,	byte ptr[rcx+109]
    cmp       rax,	6
    jnz       L8647
    mov       rax,	[rdi+8]
    cmp       rax,	rcx
    jz        L8647
    mov       rax,	[rdi+8]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	6
    jz        L8645
L8647:
    mov       rax,	[rdi+8]
    cmp       rax,	rcx
    jnz       L8649
    movzx     rax,	word ptr[rdi+98]
    cmp       rax,	3
    jnz       L8649
    mov       rax,	rdi
    jmp       L8642
L8649:
L8644:
    mov       rax,	[rdi+40]
    mov       rdi,	rax
    test      rax,	rax
    jnz       L8643
L8645:
    xor       eax,	eax
L8642:
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc cc_lib.checkdupl
cc_lib.checkdupl:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
#---------------
#PROC3
#PROC4
    mov       rbx,	rdx
    mov       rax,	r8
    shl       rax,	16
    or        rax,	r9
    mov       rdi,	rax
    jmp       L8652
L8651:
    mov       rax,	[rbx+8]
    cmp       rax,	rcx
    jnz       L8655
    mov       eax,	[rbx+96]
    cmp       rax,	rdi
    jnz       L8655
    mov       rax,	rbx
    jmp       L8650
L8655:
L8652:
    mov       rax,	[rbx+40]
    mov       rbx,	rax
    test      rax,	rax
    jnz       L8651
    xor       eax,	eax
L8650:
#---------------
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.checkdupl_inproc
cc_lib.checkdupl_inproc:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
#---------------
#PROC3
#PROC4
    mov       rbx,	rdx
    mov       rax,	r8
    shl       rax,	16
    or        rax,	r9
    mov       rdi,	rax
    jmp       L8658
L8657:
    mov       eax,	[rbx+96]
    cmp       rax,	rdi
    jnz       L8661
    mov       rax,	rbx
    jmp       L8656
L8661:
L8658:
    mov       rax,	[rbx+40]
    mov       rbx,	rax
    test      rax,	rax
    jz        L8662
    mov       rax,	[rbx+8]
    cmp       rax,	rcx
    jz        L8657
L8662:
    xor       eax,	eax
L8656:
#---------------
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.getalignment
cc_lib.getalignment:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jz        L8665
    cmp       rax,	18
    jz        L8666
    cmp       rax,	19
    jz        L8666
    jmp       L8667
L8665:
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    mov       rcx,	rax
    call      cc_lib.getalignment
    jmp       L8663
L8666:
    lea       rax,	[rip+cc_decls.ttnamedef]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    movzx     rax,	byte ptr[rax+112]
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L8669
    mov       rax,	16
    jmp       L8663
L8669:
    mov       rax,	rdi
    jmp       L8663
L8667:
L8664:
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rbx
    mov       rdi,	[rax + r10*8]
    mov       rax,	rdi
    cmp       rax,	1
    jz        L8671
    cmp       rax,	2
    jz        L8671
    cmp       rax,	4
    jz        L8671
    cmp       rax,	8
    jnz       L8672
L8671:
    mov       rax,	rdi
    jmp       L8663
L8672:
L8670:
    call      msys.m$print_startcon
    mov       rcx,	rbx
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11436]
    call      cc_support.serror
    xor       eax,	eax
L8663:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.isexported
cc_lib.isexported:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rcx+109]
    cmp       rax,	6
    jnz       L8675
    mov       rax,	[rcx+72]
    test      rax,	rax
    jz        L8677
    movzx     rax,	byte ptr[rcx+110]
    cmp       rax,	3
    jz        L8678
    movzx     rax,	byte ptr[rcx+110]
    cmp       rax,	4
    jnz       L8677
L8678:
    mov       rax,	1
    jmp       L8673
L8677:
    jmp       L8674
L8675:
    movzx     rax,	byte ptr[rcx+110]
    cmp       rax,	4
    jnz       L8680
    mov       rax,	1
    jmp       L8673
L8680:
L8674:
    xor       eax,	eax
L8673:
#---------------
    ret       
# End 
# Proc cc_lib.isimported
cc_lib.isimported:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rcx+109]
    cmp       rax,	6
    jnz       L8683
    mov       rax,	[rcx+72]
    test      rax,	rax
    jnz       L8685
    movzx     rax,	byte ptr[rcx+110]
    cmp       rax,	3
    jz        L8686
    movzx     rax,	byte ptr[rcx+110]
    cmp       rax,	4
    jnz       L8685
L8686:
    mov       rax,	1
    jmp       L8681
L8685:
    jmp       L8682
L8683:
    movzx     rax,	byte ptr[rcx+110]
    cmp       rax,	3
    jnz       L8688
    mov       rax,	1
    jmp       L8681
L8688:
L8682:
    xor       eax,	eax
L8681:
#---------------
    ret       
# End 
# Proc cc_lib.getstname
cc_lib.getstname:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rdi+106]
    mov       r10,	[rdi]
    lea       rcx,	[rip+cc_lib.getstname.name]
    mov       rdx,	r10
    mov       r8,	rax
    call      memcpy
    movzx     rax,	byte ptr[rdi+106]
    xor       r10d,	r10d
    lea       r11,	[rip+cc_lib.getstname.name]
    mov       [r11 + rax],	r10b
    lea       rax,	[rip+cc_lib.getstname.name]
L8689:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lib.isrealcc
cc_lib.isrealcc:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rcx
    movsx     rax,	word ptr[rax + r10*2]
    mov       rcx,	rax
    mov       rax,	rcx
    cmp       rax,	10
    jl        L8691
    cmp       rax,	11
    jg        L8691
    mov       rax,	1
    jmp       L8692
L8691:
    xor       eax,	eax
L8692:
L8690:
#---------------
    ret       
# End 
# Proc cc_lib.isintcc
cc_lib.isintcc:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rcx
    movsx     rax,	word ptr[rax + r10*2]
    mov       rcx,	rax
    mov       rax,	rcx
    cmp       rax,	1
    jl        L8694
    cmp       rax,	9
    jg        L8694
    mov       rax,	1
    jmp       L8695
L8694:
    xor       eax,	eax
L8695:
L8693:
#---------------
    ret       
# End 
# Proc cc_lib.ispoweroftwo
cc_lib.ispoweroftwo:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    mov       rdi,	1
    xor       rbx,	rbx
    mov       rax,	60
    mov       rsi,	rax
L8697:
    inc       rbx
    mov       rax,	rdi
    shl       rax,	1
    mov       rdi,	rax
    cmp       rdi,	rcx
    jnz       L8701
    mov       rax,	rbx
    jmp       L8696
L8701:
    dec       rsi
    jnz       L8697
    xor       eax,	eax
L8696:
#---------------
    add       rsp,	16
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.writegsfile
cc_lib.writegsfile:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    lea       rdx,	[rip+L11437]
    call      fopen
    mov       rdi,	rax
    mov       rcx,	rsi
    mov       rdx,	rdi
    call      mlib.gs_println
    mov       rcx,	rdi
    call      fclose
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_lib.pause
cc_lib.pause:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      mwindows.os_getch
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_lib.getpclmode
cc_lib.getpclmode:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rcx
    movsx     rax,	word ptr[rax + r10*2]
    lea       r10,	[rip+cc_tables.stdpcl]
    movzx     r10,	byte ptr[r10 + rax]
    mov       rdi,	r10
    cmp       rdi,	11
    jnz       L8706
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rcx
    mov       rax,	[rax + r10*8]
    cmp       rax,	8
    jz        L8708
    cmp       rax,	4
    jz        L8709
    cmp       rax,	2
    jz        L8710
    cmp       rax,	1
    jz        L8711
    jmp       L8712
L8708:
    mov       rdi,	6
    jmp       L8707
L8709:
    mov       rdi,	5
    jmp       L8707
L8710:
    mov       rdi,	4
    jmp       L8707
L8711:
    mov       rdi,	3
L8712:
L8707:
L8706:
    mov       rax,	rdi
L8704:
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc cc_lib.addtolog
cc_lib.addtolog:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rsi
    lea       rdx,	[rip+L11438]
    call      fopen
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L8715
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11439]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    jmp       L8713
L8715:
L8716:
    mov       rcx,	rdi
    call      fgetc
    movsxd    r10,	eax
    mov       rbx,	r10
    cmp       rbx,	-1
    jz        L8717
L8719:
    mov       rcx,	rbx
    mov       rdx,	r12
    call      fputc
    jmp       L8716
L8717:
    mov       rcx,	rdi
    call      fclose
L8713:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.stopcompiler
cc_support.stopcompiler:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       al,	[rip+cc_cli.fwriteerrors]
    test      al,	al
    jz        L8722
    lea       rcx,	[rip+L11440]
    lea       rdx,	[rip+L11441]
    call      fopen
    mov       rdi,	rax
    mov       rcx,	rdi
    call      msys.m$print_startfile
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rdi
    call      fclose
L8722:
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	1
    call      exit
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.mcerror
cc_support.mcerror:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11442]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	40
    call      exit
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_support.serror
cc_support.serror:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      cc_support.serror_gen
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_support.serror_gen
cc_support.serror_gen:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_decls.currproc]
    test      rax,	rax
    jz        L8727
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11443]
    call      msys.m$print_str_nf
    mov       rax,	[rip+cc_decls.currproc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11444]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L8726
L8727:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11445]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L8726:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11446]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.lx]
    mov       eax,	[rax+16]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[rip+L11447]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+20]
    lea       r10,	[rip+cc_decls.sourcefilepaths]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+20]
    lea       r10,	[rip+cc_decls.sourcefilenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_support.showmacrolineno
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11448]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11449]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[rip+cc_decls.lx]
    mov       eax,	[rax+16]
    lea       r10,	[rip+cc_decls.lx]
    movzx     r10,	byte ptr[r10+20]
    lea       r11,	[rip+cc_decls.sourcefilepaths]
    mov       r11,	[r11 + r10*8]
    mov       rcx,	r11
    mov       rdx,	rax
    call      cc_support.stopcompiler
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_support.serror_ss
cc_support.serror_ss:
#PROC1
#PROC2
#?>>
    .set cc_support.serror_ss.str, -256
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + cc_support.serror_ss.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + cc_support.serror_ss.str]
    call      cc_support.serror_gen
#---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.serror_s
cc_support.serror_s:
#PROC1
#PROC2
#?>>
    .set cc_support.serror_s.str, -256
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + cc_support.serror_s.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + cc_support.serror_s.str]
    call      cc_support.serror_gen
#---------------
    add       rsp,	288
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.terror_gen
cc_support.terror_gen:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_decls.currproc]
    test      rax,	rax
    jz        L8732
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11450]
    call      msys.m$print_str_nf
    mov       rax,	[rip+cc_decls.currproc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L8732:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11451]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11452]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.lx]
    mov       eax,	[rax+16]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rax,	[rip+cc_decls.lx]
    movzx     rax,	byte ptr[rax+20]
    lea       r10,	[rip+cc_decls.sourcefilepaths]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      cc_support.showmacrolineno
    lea       rax,	[rip+cc_decls.lx]
    mov       eax,	[rax+16]
    lea       r10,	[rip+cc_decls.lx]
    movzx     r10,	byte ptr[r10+20]
    lea       r11,	[rip+cc_decls.sourcefilepaths]
    mov       r11,	[r11 + r10*8]
    mov       rcx,	r11
    mov       rdx,	rax
    call      cc_support.stopcompiler
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_support.terror
cc_support.terror:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    call      cc_support.terror_gen
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_support.terror_s
cc_support.terror_s:
#PROC1
#PROC2
#?>>
    .set cc_support.terror_s.str, -256
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + cc_support.terror_s.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + cc_support.terror_s.str]
    call      cc_support.terror_gen
#---------------
    add       rsp,	288
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.terror_ss
cc_support.terror_ss:
#PROC1
#PROC2
#?>>
    .set cc_support.terror_ss.str, -256
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + cc_support.terror_ss.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + cc_support.terror_ss.str]
    call      cc_support.terror_gen
#---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.gerror_gen
cc_support.gerror_gen:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rsi,	rcx
    mov       r12,	rdx
#---------------
#PROC3
#PROC4
    test      r12,	r12
    jz        L8738
    mov       eax,	[r12+44]
    mov       rdi,	rax
    movzx     rax,	byte ptr[r12+60]
    mov       rbx,	rax
    jmp       L8737
L8738:
    mov       rdi,	[rip+cc_decls.clineno]
    mov       rbx,	[rip+cc_decls.cfileno]
L8737:
    mov       rax,	[rip+cc_decls.currproc]
    test      rax,	rax
    jz        L8740
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11453]
    call      msys.m$print_str_nf
    mov       rax,	[rip+cc_decls.currproc]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11454]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L8740:
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11455]
    call      msys.m$print_str_nf
    mov       rax,	rdi
    and       rax,	16777215
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    lea       rcx,	[rip+L11456]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.sourcefilepaths]
    mov       r10,	rbx
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11457]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11458]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[rip+cc_decls.sourcefilepaths]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    mov       rdx,	rdi
    call      cc_support.stopcompiler
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.gerror
cc_support.gerror:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rdi
    mov       rdx,	rbx
    call      cc_support.gerror_gen
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.gerror_s
cc_support.gerror_s:
#PROC1
#PROC2
#?>>
    .set cc_support.gerror_s.str, -256
    push      rdi
    push      rbx
    push      rsi
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + cc_support.gerror_s.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    lea       rcx,	[rbp + cc_support.gerror_s.str]
    mov       rdx,	rsi
    call      cc_support.gerror_gen
#---------------
    add       rsp,	296
    pop       rbp
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.nextpoweroftwo
cc_support.nextpoweroftwo:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	16
#---------------
#PROC3
#PROC4
    test      rcx,	rcx
    jnz       L8745
    xor       eax,	eax
    jmp       L8743
L8745:
    mov       rdi,	1
    jmp       L8747
L8746:
    shl       rdi,	1
L8747:
    cmp       rdi,	rcx
    jl        L8746
    mov       rax,	rdi
L8743:
#---------------
    add       rsp,	16
    pop       rdi
    ret       
# End 
# Proc cc_support.loaderror
cc_support.loaderror:
#PROC1
#PROC2
#?>>
    .set cc_support.loaderror.str, -512
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	544
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    lea       rcx,	[rbp + cc_support.loaderror.str]
    call      msys.m$print_startstr
    mov       rcx,	rdi
    call      msys.m$print_setfmt
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11459]
    call      msys.m$print_str_nf
    lea       rcx,	[rbp + cc_support.loaderror.str]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11460]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	45
    call      exit
#---------------
    add       rsp,	544
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.loadsourcefile
cc_support.loadsourcefile:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_decls.nsourcefiles]
    cmp       rax,	200
    jle       L8752
    lea       rcx,	[rip+L11461]
    lea       rdx,	[rip+L11462]
    call      cc_support.loaderror
L8752:
    inc       qword ptr[rip+cc_decls.nsourcefiles]
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    lea       r10,	[rip+cc_decls.sourcefilepaths]
    mov       r11,	[rip+cc_decls.nsourcefiles]
    mov       [r10 + r11*8],	rax
    mov       rcx,	rsi
    call      mlib.pcm_copyheapstring
    lea       r10,	[rip+cc_decls.sourcefilenames]
    mov       r11,	[rip+cc_decls.nsourcefiles]
    mov       [r10 + r11*8],	rax
    mov       rcx,	rbx
    call      mlib.readfile
    mov       rdi,	rax
    test      rdi,	rdi
    jnz       L8754
    lea       rcx,	[rip+L11463]
    mov       rdx,	rbx
    call      cc_support.loaderror
L8754:
    mov       rax,	rdi
    lea       r10,	[rip+cc_decls.sourcefiletext]
    mov       r11,	[rip+cc_decls.nsourcefiles]
    mov       [r10 + r11*8],	rax
    mov       eax,	[rip+mlib.rfsize]
    lea       r10,	[rip+cc_decls.sourcefilesizes]
    mov       r11,	[rip+cc_decls.nsourcefiles]
    mov       [r10 + r11*4],	eax
    xor       eax,	eax
    mov       r10,	[rip+mlib.rfsize]
    mov       [rdi + r10],	al
    mov       rax,	[rip+cc_decls.nsourcefiles]
L8750:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.splicelines
cc_support.splicelines:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rsi
    call      strlen
    inc       rax
    mov       rcx,	rax
    call      mlib.pcm_alloc
    mov       rbx,	rax
    mov       rdi,	rax
    jmp       L8757
L8756:
    movzx     rax,	byte ptr[rsi]
    cmp       rax,	92
    jnz       L8760
    movzx     rax,	byte ptr[rsi+1]
    cmp       rax,	10
    jnz       L8760
    add       rsi,	2
    jmp       L8759
L8760:
    movzx     rax,	byte ptr[rsi]
    cmp       rax,	92
    jnz       L8761
    movzx     rax,	byte ptr[rsi+1]
    cmp       rax,	13
    jnz       L8761
    movzx     rax,	byte ptr[rsi+2]
    cmp       rax,	10
    jnz       L8761
    add       rsi,	3
    jmp       L8759
L8761:
    mov       rax,	rsi
    inc       rsi
    mov       al,	[rax]
    mov       r10,	rdi
    inc       rdi
    mov       [r10],	al
L8759:
    xor       eax,	eax
    mov       [rdi],	al
L8757:
    mov       al,	[rsi]
    test      al,	al
    jnz       L8756
    mov       rax,	rbx
L8755:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.loadbuiltin
cc_support.loadbuiltin:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_decls.nsourcefiles]
    cmp       rax,	200
    jle       L8764
    lea       rcx,	[rip+L11464]
    lea       rdx,	[rip+L11465]
    call      cc_support.loaderror
L8764:
    inc       qword ptr[rip+cc_decls.nsourcefiles]
    lea       rax,	[rip+L11466]
    lea       r10,	[rip+cc_decls.sourcefilepaths]
    mov       r11,	[rip+cc_decls.nsourcefiles]
    mov       [r10 + r11*8],	rax
    mov       rcx,	rdi
    call      mlib.pcm_copyheapstring
    lea       r10,	[rip+cc_decls.sourcefilenames]
    mov       r11,	[rip+cc_decls.nsourcefiles]
    mov       [r10 + r11*8],	rax
    mov       rcx,	rbx
    call      mlib.pcm_copyheapstring
    lea       r10,	[rip+cc_decls.sourcefiletext]
    mov       r11,	[rip+cc_decls.nsourcefiles]
    mov       [r10 + r11*8],	rax
    mov       rcx,	rbx
    call      strlen
    lea       r10,	[rip+cc_decls.sourcefilesizes]
    mov       r11,	[rip+cc_decls.nsourcefiles]
    mov       [r10 + r11*4],	eax
    mov       rax,	[rip+cc_decls.nsourcefiles]
L8762:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.gs_copytostr
cc_support.gs_copytostr:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
#---------------
#PROC3
#PROC4
    mov       eax,	[rdi+8]
    test      eax,	eax
    jz        L8767
    movsxd    rax,	dword ptr[rdi+8]
    mov       r10,	[rdi]
    mov       rcx,	rbx
    mov       rdx,	r10
    mov       r8,	rax
    call      memcpy
    movsxd    rax,	dword ptr[rdi+8]
    xor       r10d,	r10d
    mov       [rbx + rax],	r10b
    jmp       L8766
L8767:
    xor       eax,	eax
    mov       [rbx],	al
L8766:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.gs_additem
cc_support.gs_additem:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    sub       rsp,	48
    mov       r12,	rcx
    mov       r13,	rdx
#---------------
#PROC3
#PROC4
    mov       rdi,	[r12]
    mov       eax,	[r12+8]
    test      eax,	eax
    jz        L8770
    movsxd    rax,	dword ptr[r12+8]
    lea       r10,	[rdi + rax]
    sub       r10,	1
    movzx     r10,	byte ptr[r10]
    mov       rbx,	r10
    movzx     rax,	byte ptr[r13]
    mov       rsi,	rax
    mov       rcx,	rbx
    call      cc_support.isalphanum
    test      rax,	rax
    jz        L8772
    mov       rcx,	rsi
    call      cc_support.isalphanum
    test      rax,	rax
    jz        L8772
    mov       rcx,	r12
    lea       rdx,	[rip+L11467]
    mov       r8,	-1
    call      mlib.strbuffer_add
L8772:
L8770:
    mov       rcx,	r12
    mov       rdx,	r13
    mov       r8,	-1
    call      mlib.strbuffer_add
#---------------
    add       rsp,	48
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_support.isalphanum
cc_support.isalphanum:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    cmp       rcx,	65
    jl        L8777
    cmp       rcx,	90
    jle       L8776
L8777:
    cmp       rcx,	97
    jl        L8778
    cmp       rcx,	122
    jle       L8776
L8778:
    cmp       rcx,	48
    jl        L8775
    cmp       rcx,	57
    jg        L8775
L8776:
    mov       rax,	1
    jmp       L8773
L8775:
    xor       eax,	eax
L8773:
#---------------
    ret       
# End 
# Proc cc_support.showmacrolineno
cc_support.showmacrolineno:
#PROC1
#PROC2
#?>>
#?]]
#---------------
#PROC3
#PROC4
    mov       rax,	[rip+cc_decls.slineno]
    test      rax,	rax
    jz        L8781
L8781:
#---------------
    ret       
# End 
# Proc cc_headers.findheader
cc_headers.findheader:
#PROC1
#PROC2
#?>>
    .set cc_headers.findheader.newname, -256
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	296
    mov       r13,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	r13
    mov       rdx,	92
    call      strchr
    test      rax,	rax
    jz        L8784
    mov       rbx,	r13
    lea       rax,	[rbp + cc_headers.findheader.newname]
    mov       rsi,	rax
    jmp       L8786
L8785:
    movzx     rax,	byte ptr[rbx]
    cmp       rax,	92
    jnz       L8789
    mov       rax,	rsi
    inc       rsi
    mov       r10b,	47
    mov       [rax],	r10b
    jmp       L8788
L8789:
    mov       al,	[rbx]
    mov       r10,	rsi
    inc       rsi
    mov       [r10],	al
L8788:
    inc       rbx
L8786:
    mov       al,	[rbx]
    test      al,	al
    jnz       L8785
    xor       eax,	eax
    mov       [rsi],	al
    lea       rax,	[rbp + cc_headers.findheader.newname]
    mov       r13,	rax
L8784:
    mov       rdi,	1
    mov       r12,	40
    cmp       r12,	1
    jl        L8792
L8790:
    lea       rax,	[rip+cc_headers.stdhdrnames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	r13
    mov       rdx,	rax
    call      mlib.eqstring
    test      rax,	rax
    jz        L8794
    lea       rax,	[rip+cc_headers.stdhdrtext]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax]
    jmp       L8782
L8794:
    inc       rdi
    cmp       rdi,	r12
    jle       L8790
L8792:
    xor       eax,	eax
L8782:
#---------------
    add       rsp,	296
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_headers.writeheaders
cc_headers.writeheaders:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    mov       rsi,	1
    mov       r12,	40
    cmp       r12,	1
    jl        L8798
L8796:
    lea       rax,	[rip+cc_headers.stdhdrnames]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    lea       rdx,	[rip+L11468]
    call      mlib.changeext
    mov       rbx,	rax
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11469]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_headers.stdhdrnames]
    mov       r10,	rsi
    mov       rcx,	[rax + r10*8-8]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11470]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rbx
    lea       rdx,	[rip+L11471]
    call      fopen
    mov       rdi,	rax
    lea       rax,	[rip+cc_headers.stdhdrtext]
    mov       r10,	rsi
    mov       rax,	[rax + r10*8-8]
    mov       rax,	[rax]
    mov       rcx,	rax
    call      strlen
    lea       r10,	[rip+cc_headers.stdhdrtext]
    mov       r11,	rsi
    mov       r10,	[r10 + r11*8-8]
    mov       r10,	[r10]
    mov       rcx,	r10
    mov       rdx,	1
    mov       r8,	rax
    mov       r9,	rdi
    call      fwrite
    mov       rcx,	rdi
    call      fclose
    inc       rsi
    cmp       rsi,	r12
    jle       L8796
L8798:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_headers.isheaderfile
cc_headers.isheaderfile:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rsi,	rcx
#---------------
#PROC3
#PROC4
    mov       rbx,	1
    mov       rdi,	40
    cmp       rdi,	1
    jl        L8802
L8800:
    lea       rax,	[rip+cc_headers.stdhdrnames]
    mov       r10,	rbx
    mov       rax,	[rax + r10*8-8]
    mov       rcx,	rax
    mov       rdx,	rsi
    call      mlib.eqstring
    test      rax,	rax
    jz        L8804
    mov       rax,	1
    jmp       L8799
L8804:
    inc       rbx
    cmp       rbx,	rdi
    jle       L8800
L8802:
    xor       eax,	eax
L8799:
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_show.printcode
cc_show.printcode:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
#?]]
    sub       rsp,	48
    mov       rbx,	rcx
    mov       rsi,	rdx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       rcx,	rsi
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rip+cc_decls.stmodule]
    mov       rdi,	[rax+16]
    jmp       L8807
L8806:
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	6
    jnz       L8811
L8810:
    mov       rax,	[rdi+72]
    test      rax,	rax
    jz        L8813
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11472]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rdi+110]
    lea       r10,	[rip+cc_tables.scopenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rdi+72]
    mov       rcx,	rbx
    mov       rdx,	rax
    xor       r8d,	r8d
    lea       r9,	[rip+L11473]
    call      cc_show.printunit
    mov       rcx,	rbx
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
L8813:
L8811:
L8809:
    mov       rdi,	[rdi+32]
L8807:
    test      rdi,	rdi
    jnz       L8806
#---------------
    add       rsp,	48
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_show.printunit
cc_show.printunit:
#PROC1
#PROC2
#?>>
    .set cc_show.printunit.level, 80
    .set cc_show.printunit.prefix, 88
    .set cc_show.printunit.idname, -8
    .set cc_show.printunit.pc, -16
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	48
    mov       r13,	rcx
    mov       r14,	rdx
    mov       [rbp+80],	r8
    mov       [rbp+88],	r9
#---------------
#PROC3
#PROC4
    test      r14,	r14
    jnz       L8816
    jmp       L8814
L8816:
    movsxd    rax,	dword ptr[r14+40]
    cmp       rax,	77
    jl        L8818
    call      msys.m$print_startcon
    lea       rcx,	[rip+L11474]
    call      msys.m$print_str_nf
    movsxd    rax,	dword ptr[r14+40]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	30
    call      exit
L8818:
    mov       eax,	[r14+44]
    test      eax,	eax
    jz        L8820
    mov       eax,	[r14+44]
    mov       [rip+cc_show.currlineno],	rax
    movzx     rax,	byte ptr[r14+60]
    mov       [rip+cc_show.currfileno],	rax
L8820:
    mov       r12,	1
    mov       rax,	[rbp + cc_show.printunit.level]
    cmp       rax,	0
    jge       L8822
    mov       r12,	-1
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11475]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L8822:
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rax,	[rbp + cc_show.printunit.level]
    cmp       rax,	0
    jge       L11476
    neg       rax
L11476:
    mov       rcx,	rax
    mov       rdx,	[rbp + cc_show.printunit.prefix]
    mov       r8,	r14
    call      cc_show.getprefix
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    rax,	dword ptr[r14+40]
    lea       r10,	[rip+cc_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       [rbp + cc_show.printunit.idname],	r10
    mov       rax,	[rbp + cc_show.printunit.idname]
    movzx     rax,	byte ptr[rax]
    cmp       rax,	106
    jnz       L8824
    inc       qword ptr[rbp + cc_show.printunit.idname]
L8824:
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[rbp + cc_show.printunit.idname]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11477]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    movsxd    rax,	dword ptr[r14+40]
    cmp       rax,	3
    jz        L8826
    cmp       rax,	5
    jz        L8826
    cmp       rax,	7
    jz        L8827
    cmp       rax,	8
    jz        L8827
    cmp       rax,	16
    jz        L8827
    cmp       rax,	16
    jz        L8828
    cmp       rax,	17
    jz        L8829
    cmp       rax,	18
    jz        L8830
    cmp       rax,	1
    jz        L8831
    cmp       rax,	56
    jz        L8832
    cmp       rax,	57
    jz        L8833
    cmp       rax,	53
    jz        L8834
    cmp       rax,	54
    jz        L8834
    cmp       rax,	22
    jz        L8835
    cmp       rax,	30
    jz        L8836
    cmp       rax,	52
    jz        L8837
    cmp       rax,	49
    jz        L8838
    jmp       L8839
L8826:
    mov       rdi,	[r14]
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rdi+109]
    lea       r10,	[rip+cc_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[rdi+72]
    test      rax,	rax
    jz        L8841
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11478]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rax,	[rdi+72]
    movsxd    rax,	dword ptr[rax+40]
    lea       r10,	[rip+cc_tables.jtagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11479]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L8841:
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11480]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	rdi
    call      cc_show.getdottedname
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rax,	[r14+32]
    test      rax,	rax
    jz        L8843
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11481]
    call      msys.m$print_str_nf
    mov       rcx,	[r14+32]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
L8843:
    jmp       L8825
L8827:
    mov       rdi,	[r14]
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rdi+109]
    lea       r10,	[rip+cc_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rbp + cc_show.printunit.level]
    add       rax,	r12
    mov       r10,	[rdi+72]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    lea       r9,	[rip+L11482]
    call      cc_show.printunit
    jmp       L8814
L8828:
    mov       rdi,	[r14]
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[rdi]
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rdi+109]
    lea       r10,	[rip+cc_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L8825
L8829:
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rax,	[r14]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L8825
L8830:
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11483]
    call      msys.m$print_str_nf
    mov       rcx,	[r14]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8825
L8831:
    movsxd    rax,	dword ptr[r14+52]
    mov       rbx,	rax
    cmp       rbx,	[rip+cc_decls.trefchar]
    jnz       L8845
    mov       al,	[r14+61]
    test      al,	al
    jz        L8848
L8847:
#cc_show.printunit.dostring:
L8849:
    movsxd    rax,	dword ptr[r14+48]
    cmp       rax,	256
    jle       L8851
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11484]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11485]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11486]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    rax,	dword ptr[r14+48]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8850
L8851:
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11487]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	[r14]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11488]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    rax,	dword ptr[r14+48]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L8850:
    jmp       L8844
L8845:
    cmp       rbx,	[rip+cc_decls.trefwchar]
    jnz       L8852
    mov       al,	[r14+62]
    test      al,	al
    jz        L8848
L8854:
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11489]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11490]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11491]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movsxd    rax,	dword ptr[r14+48]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8844
L8852:
    cmp       rbx,	1
    jl        L8855
    cmp       rbx,	4
    jg        L8855
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[r14]
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8844
L8855:
    cmp       rbx,	6
    jl        L8856
    cmp       rbx,	9
    jg        L8856
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rax,	[r14]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.m$print_u64
    call      msys.m$print_end
    jmp       L8844
L8856:
    mov       rcx,	rbx
    call      cc_lib.isrealcc
    test      rax,	rax
    jz        L8857
    mov       rcx,	r13
    call      msys.m$print_startfile
    movq      XMM4,	[r14]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.m$print_r64
    call      msys.m$print_end
    jmp       L8844
L8857:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	13
    jnz       L8858
    mov       al,	[r14+61]
    test      al,	al
    jnz       L8849
L8860:
#cc_show.printunit.doref:
L8848:
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[r14]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    jmp       L8844
L8858:
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rbx
    movsx     rax,	word ptr[rax + r10*2]
    cmp       rax,	17
    jnz       L8861
    mov       al,	[r14+61]
    test      al,	al
    jnz       L8849
L8863:
    lea       rcx,	[rip+L11492]
    call      cc_support.serror
    jmp       L8844
L8861:
    call      msys.m$print_startcon
    mov       rcx,	rbx
    call      cc_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11493]
    call      cc_support.serror
L8844:
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11494]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rcx,	rbx
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       al,	[r14+61]
    test      al,	al
    jz        L8865
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11495]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L8865:
    mov       al,	[r14+62]
    test      al,	al
    jz        L8867
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11496]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L8867:
    jmp       L8825
L8832:
    mov       rcx,	r13
    call      msys.m$print_startfile
    movsxd    rax,	dword ptr[r14+48]
    lea       r10,	[rip+cc_tables.convnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11497]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rax,	[r14+16]
    movsxd    rax,	dword ptr[rax+52]
    mov       rcx,	rax
    call      cc_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11498]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	r13
    call      msys.m$print_startfile
    movsx     rax,	word ptr[r14+58]
    mov       rcx,	rax
    call      cc_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
    jmp       L8825
L8833:
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11499]
    call      msys.m$print_str_nf
    movsxd    rax,	dword ptr[r14+48]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8825
L8834:
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11500]
    call      msys.m$print_str_nf
    movsxd    rax,	dword ptr[r14]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8825
L8835:
    mov       rax,	[r14]
    mov       [rbp + cc_show.printunit.pc],	rax
    xor       rsi,	rsi
    jmp       L8869
L8868:
    inc       rsi
    mov       rax,	[rbp + cc_show.printunit.pc]
    mov       rax,	[rax]
    mov       [rbp + cc_show.printunit.pc],	rax
L8869:
    mov       rax,	[rbp + cc_show.printunit.pc]
    test      rax,	rax
    jnz       L8868
    mov       rcx,	r13
    call      msys.m$print_startfile
    mov       rcx,	[r14]
    call      msys.m$print_ptr_nf
    mov       rcx,	rsi
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8825
L8836:
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11501]
    call      msys.m$print_str_nf
    movsxd    rax,	dword ptr[r14+48]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L8825
L8837:
    jmp       L8825
L8838:
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11502]
    call      msys.m$print_str_nf
    movsxd    rax,	dword ptr[r14]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L8839:
L8825:
    mov       ax,	[r14+56]
    test      ax,	ax
    jz        L8872
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11503]
    call      msys.m$print_str_nf
    movsx     rax,	word ptr[r14+56]
    mov       rcx,	rax
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_end
L8872:
    mov       eax,	[r14+48]
    test      eax,	eax
    jz        L8874
    mov       rcx,	r13
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11504]
    call      msys.m$print_str_nf
    movsxd    rax,	dword ptr[r14+48]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
L8874:
    mov       rcx,	r13
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rax,	[rbp + cc_show.printunit.level]
    add       rax,	r12
    mov       r10,	[r14+16]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    lea       r9,	[rip+L11505]
    call      cc_show.printunitlist
    mov       rax,	[rbp + cc_show.printunit.level]
    add       rax,	r12
    mov       r10,	[r14+24]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    lea       r9,	[rip+L11506]
    call      cc_show.printunitlist
    movsxd    rax,	dword ptr[r14+40]
    cmp       rax,	6
    jz        L8876
    mov       rax,	[rbp + cc_show.printunit.level]
    add       rax,	r12
    mov       r10,	[r14+32]
    mov       rcx,	r13
    mov       rdx,	r10
    mov       r8,	rax
    lea       r9,	[rip+L11507]
    call      cc_show.printunitlist
L8876:
L8814:
#---------------
    add       rsp,	48
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_show.printunitlist
cc_show.printunitlist:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rdi,	rcx
    mov       rbx,	rdx
    mov       rsi,	r8
    mov       r12,	r9
#---------------
#PROC3
#PROC4
    test      rbx,	rbx
    jnz       L8879
    jmp       L8877
L8879:
    jmp       L8881
L8880:
    mov       rcx,	rdi
    mov       rdx,	rbx
    mov       r8,	rsi
    mov       r9,	r12
    call      cc_show.printunit
    mov       rbx,	[rbx+8]
L8881:
    test      rbx,	rbx
    jnz       L8880
L8877:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_show.getprefix
cc_show.getprefix:
#PROC1
#PROC2
#?>>
    .set cc_show.getprefix.indentstr, -512
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	544
    mov       r12,	rcx
    mov       r13,	rdx
    mov       r14,	r8
#---------------
#PROC3
#PROC4
    xor       eax,	eax
    mov       [rbp + cc_show.getprefix.indentstr],	al
    cmp       r12,	10
    jle       L8885
    mov       r12,	10
L8885:
    lea       rcx,	[rbp + cc_show.getprefix.indentstr]
    lea       rdx,	[rip+L11508]
    call      strcpy
    movsxd    rax,	dword ptr[r14+52]
    mov       rcx,	rax
    xor       edx,	edx
    call      cc_lib.strmode
    mov       rdi,	rax
    mov       rcx,	rdi
    call      strlen
    mov       rbx,	rax
    lea       rcx,	[rbp + cc_show.getprefix.indentstr]
    call      strlen
    mov       r10,	rbx
    cmp       r10,	rax
    jge       L8887
    lea       rcx,	[rbp + cc_show.getprefix.indentstr]
    mov       rdx,	rdi
    mov       r8,	rbx
    call      memcpy
    jmp       L8886
L8887:
    lea       rcx,	[rbp + cc_show.getprefix.indentstr]
    mov       rdx,	rdi
    call      strcpy
L8886:
    mov       rsi,	r12
    cmp       rsi,	0
    jle       L8890
L8888:
    lea       rcx,	[rbp + cc_show.getprefix.indentstr]
    lea       rdx,	[rip+L11509]
    call      strcat
    dec       rsi
    jnz       L8888
L8890:
    call      cc_show.getlineinfok
    lea       rcx,	[rip+cc_show.getprefix.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rip+cc_show.getprefix.str]
    lea       rdx,	[rbp + cc_show.getprefix.indentstr]
    call      strcat
    lea       rcx,	[rip+cc_show.getprefix.str]
    mov       rdx,	r13
    call      strcat
    mov       al,	[r13]
    test      al,	al
    jz        L8892
    lea       rcx,	[rip+cc_show.getprefix.str]
    lea       rdx,	[rip+L11510]
    call      strcat
L8892:
    lea       rax,	[rip+cc_show.getprefix.str]
L8883:
#---------------
    add       rsp,	544
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_show.getdottedname
cc_show.getdottedname:
#PROC1
#PROC2
#?>>
    .set cc_show.getdottedname.str2, -256
    push      rdi
    push      rbx
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	288
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rax,	[rbx]
    lea       rcx,	[rip+cc_show.getdottedname.str]
    mov       rdx,	rax
    call      strcpy
    mov       rdi,	[rbx+8]
    jmp       L8895
L8894:
    lea       rcx,	[rbp + cc_show.getdottedname.str2]
    lea       rdx,	[rip+cc_show.getdottedname.str]
    call      strcpy
    mov       rax,	[rdi]
    lea       rcx,	[rip+cc_show.getdottedname.str]
    mov       rdx,	rax
    call      strcpy
    lea       rcx,	[rip+cc_show.getdottedname.str]
    lea       rdx,	[rip+L11511]
    call      strcat
    lea       rcx,	[rip+cc_show.getdottedname.str]
    lea       rdx,	[rbp + cc_show.getdottedname.str2]
    call      strcat
    mov       rdi,	[rdi+8]
L8895:
    test      rdi,	rdi
    jz        L8897
    movzx     rax,	byte ptr[rdi+109]
    cmp       rax,	2
    jnz       L8894
L8897:
    mov       ax,	[rbx+96]
    test      ax,	ax
    jz        L8899
    lea       rcx,	[rbp + cc_show.getdottedname.str2]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L11511]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     rax,	word ptr[rbx+96]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    lea       rcx,	[rip+cc_show.getdottedname.str]
    lea       rdx,	[rbp + cc_show.getdottedname.str2]
    call      strcat
L8899:
    lea       rax,	[rip+cc_show.getdottedname.str]
L8893:
#---------------
    add       rsp,	288
    pop       rbp
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_show.getlineinfok
cc_show.getlineinfok:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    lea       rcx,	[rip+cc_show.getlineinfok.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L11512]
    call      msys.m$print_setfmt
    mov       rcx,	[rip+cc_show.currfileno]
    call      msys.m$print_i64_nf
    mov       rcx,	[rip+cc_show.currlineno]
    lea       rdx,	[rip+L11513]
    call      msys.m$print_i64
    call      msys.m$print_space
    call      msys.m$print_end
    lea       rax,	[rip+cc_show.getlineinfok.str]
L8900:
#---------------
    add       rsp,	40
    ret       
# End 
# Proc cc_show.printst
cc_show.printst:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
    mov       rsi,	rdx
    mov       r12,	r8
#---------------
#PROC3
#PROC4
    movzx     rax,	byte ptr[rsi+107]
    cmp       rax,	67
    jz        L8903
    lea       rcx,	[rip+L11514]
    call      cc_support.mcerror
L8903:
    mov       rcx,	rbx
    mov       rdx,	rsi
    mov       r8,	r12
    call      cc_show.printstrec
    mov       rdi,	[rsi+16]
    jmp       L8905
L8904:
    lea       rax,	[r12+1]
    mov       rcx,	rbx
    mov       rdx,	rdi
    mov       r8,	rax
    call      cc_show.printst
    mov       rdi,	[rdi+32]
L8905:
    test      rdi,	rdi
    jnz       L8904
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_show.printstrec
cc_show.printstrec:
#PROC1
#PROC2
#?>>
    .set cc_show.printstrec.p, 72
    .set cc_show.printstrec.level, 80
    .set cc_show.printstrec.v, -16
    .set cc_show.printstrec.str, -272
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
    push      r14
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	304
    mov       r14,	rcx
    mov       [rbp+72],	rdx
    mov       [rbp+80],	r8
#---------------
#PROC3
#PROC4
    lea       rax,	[rbp + cc_show.printstrec.v]
    mov       rdi,	rax
    mov       rcx,	rdi
    call      mlib.gs_init
    xor       rsi,	rsi
    mov       rax,	[rbp + cc_show.printstrec.level]
    mov       r13,	rax
    cmp       r13,	0
    jle       L8910
L8908:
    mov       rcx,	rdi
    lea       rdx,	[rip+L11515]
    call      mlib.gs_str
    mov       rax,	4
    add       rsi,	rax
    dec       r13
    jnz       L8908
L8910:
    mov       rcx,	rdi
    lea       rdx,	[rip+L11516]
    call      mlib.gs_str
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       ax,	[rax+96]
    test      ax,	ax
    jz        L8912
    lea       rcx,	[rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11517]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    mov       rax,	[rbp + cc_show.printstrec.p]
    movzx     rax,	word ptr[rax+96]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       rax,	28
    sub       rax,	rsi
    mov       rcx,	rdi
    lea       rdx,	[rbp + cc_show.printstrec.str]
    mov       r8,	rax
    mov       r9,	45
    call      mlib.gs_leftstr
    jmp       L8911
L8912:
    mov       rax,	28
    sub       rax,	rsi
    mov       r10,	[rbp + cc_show.printstrec.p]
    mov       r10,	[r10]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	rax
    mov       r9,	45
    call      mlib.gs_leftstr
L8911:
    mov       rax,	[rbp + cc_show.printstrec.p]
    movzx     rax,	byte ptr[rax+109]
    lea       r10,	[rip+cc_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    mov       r8,	12
    mov       r9,	46
    call      mlib.gs_leftstr
    mov       rcx,	rdi
    call      mlib.gs_getcol
    mov       rbx,	rax
    mov       rcx,	rdi
    lea       rdx,	[rip+L11518]
    call      mlib.gs_str
    mov       rax,	[rbp + cc_show.printstrec.p]
    movzx     rax,	byte ptr[rax+110]
    lea       r10,	[rip+cc_tables.scopenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[rip+L11519]
    call      mlib.gs_str
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       al,	[rax+112]
    test      al,	al
    jz        L8914
    mov       rcx,	rdi
    lea       rdx,	[rip+L11520]
    call      mlib.gs_str
    mov       rax,	[rbp + cc_show.printstrec.p]
    movzx     rax,	byte ptr[rax+112]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    lea       rdx,	[rip+L11521]
    call      mlib.gs_str
L8914:
    mov       rax,	[rbp + cc_show.printstrec.p]
    movzx     rax,	byte ptr[rax+108]
    shr       eax,	1
    and       eax,	1
    test      rax,	rax
    jz        L8916
    mov       rcx,	rdi
    lea       rdx,	[rip+L11522]
    call      mlib.gs_str
L8916:
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       al,	[rax+122]
    test      al,	al
    jz        L8918
    mov       rcx,	rdi
    lea       rdx,	[rip+L11523]
    call      mlib.gs_str
L8918:
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       al,	[rax+111]
    test      al,	al
    jz        L8920
    lea       rcx,	[rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L11524]
    call      msys.m$print_setfmt
    mov       rax,	[rbp + cc_show.printstrec.p]
    movzx     rax,	byte ptr[rax+111]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    mov       rcx,	rdi
    lea       rdx,	[rbp + cc_show.printstrec.str]
    call      mlib.gs_str
L8920:
    mov       rcx,	rdi
    lea       rdx,	[rip+L11525]
    call      mlib.gs_str
    lea       rax,	[rbx+10]
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	61
    call      mlib.gs_padto
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       rax,	[rax+8]
    test      rax,	rax
    jz        L8922
    lea       rcx,	[rbp + cc_show.printstrec.str]
    call      msys.m$print_startstr
    lea       rcx,	[rip+L11526]
    call      msys.m$print_setfmt
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       rax,	[rax+8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_end
    mov       rcx,	rdi
    lea       rdx,	[rbp + cc_show.printstrec.str]
    mov       r8,	18
    mov       r9,	32
    call      mlib.gs_leftstr
    jmp       L8921
L8922:
    mov       rcx,	rdi
    lea       rdx,	[rip+L11527]
    mov       r8,	18
    mov       r9,	32
    call      mlib.gs_leftstr
L8921:
    mov       rax,	[rbp + cc_show.printstrec.p]
    movzx     rax,	word ptr[rax+102]
    test      rax,	rax
    jnz       L8925
L8924:
    mov       rcx,	rdi
    lea       rdx,	[rip+L11528]
    call      mlib.gs_str
    jmp       L8923
L8925:
    mov       rax,	[rbp + cc_show.printstrec.p]
    movzx     rax,	word ptr[rax+102]
    mov       rcx,	rax
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strsp
L8923:
    mov       rax,	[rbp + cc_show.printstrec.p]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	10
    jz        L8927
    cmp       rax,	8
    jz        L8928
    cmp       rax,	9
    jz        L8928
    cmp       rax,	6
    jz        L8929
    cmp       rax,	11
    jz        L8930
    cmp       rax,	7
    jz        L8931
    jmp       L8932
L8927:
    mov       rcx,	rdi
    lea       rdx,	[rip+L11529]
    call      mlib.gs_str
    mov       rax,	[rbp + cc_show.printstrec.p]
    movsxd    rax,	dword ptr[rax+88]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    jmp       L8926
L8928:
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       rax,	[rax+72]
    test      rax,	rax
    jz        L8934
    mov       rcx,	rdi
    lea       rdx,	[rip+L11530]
    call      mlib.gs_str
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       rax,	[rax+72]
    mov       rcx,	rax
    call      cc_show.strexpr
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strvar
L8934:
    mov       rcx,	rdi
    lea       rdx,	[rip+L11531]
    call      mlib.gs_str
    mov       rax,	[rbp + cc_show.printstrec.p]
    movsxd    rax,	dword ptr[rax+88]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    jmp       L8926
L8929:
    mov       rcx,	rdi
    lea       rdx,	[rip+L11532]
    call      mlib.gs_str
    mov       rax,	[rbp + cc_show.printstrec.p]
    movsxd    rax,	dword ptr[rax+88]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    jmp       L8926
L8930:
    mov       rcx,	rdi
    lea       rdx,	[rip+L11533]
    call      mlib.gs_str
    mov       rax,	[rbp + cc_show.printstrec.p]
    movsxd    rax,	dword ptr[rax+88]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    jmp       L8926
L8931:
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       rax,	[rax+72]
    test      rax,	rax
    jz        L8936
    mov       rcx,	rdi
    lea       rdx,	[rip+L11534]
    call      mlib.gs_str
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       rax,	[rax+72]
    mov       rcx,	rax
    call      cc_show.strexpr
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strvar
L8936:
    mov       rcx,	rdi
    lea       rdx,	[rip+L11535]
    call      mlib.gs_str
L8932:
L8926:
    mov       rcx,	rdi
    lea       rdx,	[rip+L11536]
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[rip+L11537]
    call      mlib.gs_str
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       eax,	[rax+92]
    and       rax,	16777215
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    lea       rdx,	[rip+L11538]
    call      mlib.gs_str
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       eax,	[rax+92]
    sar       rax,	24
    lea       r10,	[rip+cc_decls.sourcefilenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mlib.gs_str
    mov       rax,	[rbp + cc_show.printstrec.p]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	6
    jnz       L8938
    mov       rcx,	rdi
    call      mlib.gs_line
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       r12,	[rax+80]
    jmp       L8940
L8939:
    mov       rcx,	rdi
    lea       rdx,	[rip+L11539]
    call      mlib.gs_str
    mov       rax,	[r12]
    test      rax,	rax
    jz        L8943
    mov       rax,	[r12]
    mov       rax,	[rax]
    jmp       L8942
L8943:
    lea       rax,	[rip+L11540]
L8942:
    mov       rcx,	rdi
    mov       rdx,	rax
    mov       r8,	10
    mov       r9,	45
    call      mlib.gs_leftstr
    movsx     rax,	word ptr[r12+22]
    lea       r10,	[rip+cc_tables.pmflagnames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	rdi
    mov       rdx,	r10
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[rip+L11541]
    call      mlib.gs_str
    movsxd    rax,	dword ptr[r12+16]
    mov       rcx,	rax
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_str
    mov       rcx,	rdi
    lea       rdx,	[rip+L11542]
    call      mlib.gs_str
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       rax,	[rax+72]
    mov       rcx,	rdi
    mov       rdx,	rax
    call      mlib.gs_strint
    mov       rcx,	rdi
    call      mlib.gs_line
    mov       r12,	[r12+8]
L8940:
    test      r12,	r12
    jnz       L8939
L8938:
    mov       rcx,	rdi
    mov       rdx,	r14
    call      mlib.gs_println
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       rax,	[rax+72]
    test      rax,	rax
    jz        L8945
    mov       rax,	[rbp + cc_show.printstrec.p]
    movzx     rax,	byte ptr[rax+109]
    cmp       rax,	8
    jz        L8947
    cmp       rax,	7
    jnz       L8948
L8947:
    mov       rax,	[rbp + cc_show.printstrec.p]
    mov       rax,	[rax+72]
    mov       rcx,	r14
    mov       rdx,	rax
    mov       r8,	-3
    lea       r9,	[rip+L11543]
    call      cc_show.printunit
L8948:
L8946:
L8945:
#---------------
    add       rsp,	304
    pop       rbp
    pop       r14
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_show.printstflat
cc_show.printstflat:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11544]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       rdi,	rdi
    mov       rax,	[rip+cc_decls.hstsize]
    dec       rax
    mov       rsi,	rax
    cmp       rsi,	0
    jl        L8952
L8950:
    mov       rax,	[rip+cc_decls.hashtable]
    mov       r10,	rdi
    mov       rbx,	[rax + r10*8]
    mov       rax,	[rbx]
    test      rax,	rax
    jz        L8954
    movzx     rax,	byte ptr[rbx+107]
    cmp       rax,	67
    jz        L8956
    cmp       rax,	70
    jz        L8956
    cmp       rax,	68
    jnz       L8957
L8956:
    mov       rcx,	r12
    call      msys.m$print_startfile
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    mov       rcx,	rbx
    call      msys.m$print_ptr_nf
    lea       rcx,	[rip+L11545]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      cc_lib.getstname
    mov       rcx,	rax
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rbx+107]
    lea       r10,	[rip+cc_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rbx+109]
    lea       r10,	[rip+cc_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rbx,	[rbx+40]
    jmp       L8959
L8958:
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11546]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_ptr_nf
    mov       rcx,	rbx
    call      cc_lib.getstname
    mov       rcx,	rax
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rbx+107]
    lea       r10,	[rip+cc_tables.symbolnames]
    mov       r10,	[r10 + rax*8-8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    movzx     rax,	byte ptr[rbx+109]
    lea       r10,	[rip+cc_tables.namenames]
    mov       r10,	[r10 + rax*8]
    mov       rcx,	r10
    call      msys.m$print_str_nf
    mov       rcx,	[rbx+48]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11547]
    call      msys.m$print_str_nf
    mov       rax,	[rbx+8]
    test      rax,	rax
    jz        L8962
    mov       rcx,	[rbx+8]
    call      cc_lib.getstname
    jmp       L8961
L8962:
    lea       rax,	[rip+L11548]
L8961:
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11549]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rbx,	[rbx+40]
L8959:
    test      rbx,	rbx
    jnz       L8958
L8957:
L8955:
L8954:
    inc       rdi
    cmp       rdi,	rsi
    jle       L8950
L8952:
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_show.strexpr
cc_show.strexpr:
#PROC1
#PROC2
#?>>
    push      rdi
#?]]
    sub       rsp,	48
    mov       rdi,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	[rip+cc_show.exprstr]
    call      mlib.gs_init
    mov       rcx,	[rip+cc_show.exprstr]
    mov       rdx,	rdi
    call      cc_show.jeval
    mov       rax,	[rip+cc_show.exprstr]
L8963:
#---------------
    add       rsp,	48
    pop       rdi
    ret       
# End 
# Proc cc_show.jeval
cc_show.jeval:
#PROC1
#PROC2
#?>>
    .set cc_show.jeval.str, -16000
    push      rdi
    push      rbx
    push      rsi
    push      r12
    push      r13
#?]]
    push      rbp
    mov       rbp,	rsp
    sub       rsp,	16040
    mov       r12,	rcx
    mov       r13,	rdx
#---------------
#PROC3
#PROC4
    movsxd    rax,	dword ptr[r13+40]
    cmp       rax,	1
    jz        L8966
    cmp       rax,	3
    jz        L8967
    cmp       rax,	5
    jz        L8968
    cmp       rax,	24
    jz        L8969
    cmp       rax,	25
    jz        L8969
    cmp       rax,	32
    jz        L8969
    cmp       rax,	33
    jz        L8969
    cmp       rax,	34
    jz        L8969
    cmp       rax,	35
    jz        L8969
    cmp       rax,	36
    jz        L8969
    cmp       rax,	37
    jz        L8969
    cmp       rax,	38
    jz        L8969
    cmp       rax,	39
    jz        L8969
    cmp       rax,	40
    jz        L8969
    cmp       rax,	41
    jz        L8969
    cmp       rax,	42
    jz        L8969
    cmp       rax,	43
    jz        L8969
    cmp       rax,	44
    jz        L8969
    cmp       rax,	45
    jz        L8969
    cmp       rax,	46
    jz        L8969
    cmp       rax,	47
    jz        L8969
    cmp       rax,	48
    jz        L8969
    cmp       rax,	61
    jz        L8969
    cmp       rax,	62
    jz        L8969
    cmp       rax,	63
    jz        L8969
    cmp       rax,	64
    jz        L8969
    cmp       rax,	65
    jz        L8969
    cmp       rax,	66
    jz        L8969
    cmp       rax,	67
    jz        L8969
    cmp       rax,	68
    jz        L8969
    cmp       rax,	69
    jz        L8969
    cmp       rax,	70
    jz        L8969
    cmp       rax,	58
    jz        L8970
    cmp       rax,	59
    jz        L8970
    cmp       rax,	60
    jz        L8970
    cmp       rax,	26
    jz        L8970
    cmp       rax,	27
    jz        L8970
    cmp       rax,	30
    jz        L8971
    cmp       rax,	49
    jz        L8972
    cmp       rax,	50
    jz        L8973
    cmp       rax,	28
    jz        L8974
    cmp       rax,	29
    jz        L8974
    cmp       rax,	11
    jz        L8975
    cmp       rax,	31
    jz        L8976
    cmp       rax,	56
    jz        L8977
    cmp       rax,	52
    jz        L8978
    cmp       rax,	6
    jz        L8979
    cmp       rax,	71
    jz        L8980
    cmp       rax,	72
    jz        L8981
    cmp       rax,	73
    jz        L8982
    cmp       rax,	74
    jz        L8983
    cmp       rax,	2
    jz        L8984
    cmp       rax,	57
    jz        L8985
    cmp       rax,	53
    jz        L8986
    cmp       rax,	4
    jz        L8987
    jmp       L8988
L8966:
    movsxd    rax,	dword ptr[r13+52]
    mov       rsi,	rax
    cmp       rax,	[rip+cc_decls.trefchar]
    jnz       L8990
    movsxd    rax,	dword ptr[r13+48]
    test      rax,	rax
    jz        L8993
L8992:
    mov       al,	[r13+61]
    test      al,	al
    jz        L8993
L8995:
    movsxd    rax,	dword ptr[r13+48]
    cmp       rax,	8000
    jle       L8997
    lea       rcx,	[rbp + cc_show.jeval.str]
    lea       rdx,	[rip+L11550]
    call      strcpy
    jmp       L8996
L8997:
    mov       rax,	[r13]
    mov       rcx,	rax
    lea       rdx,	[rbp + cc_show.jeval.str]
    call      pc_api.convertstring
L8996:
    mov       rcx,	r12
    lea       rdx,	[rip+L11551]
    call      cc_support.gs_additem
    mov       rcx,	r12
    lea       rdx,	[rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       rcx,	r12
    lea       rdx,	[rip+L11551]
    call      cc_support.gs_additem
    jmp       L8964
L8990:
    cmp       rsi,	1
    jl        L8998
    cmp       rsi,	4
    jg        L8998
    mov       rax,	[r13]
    mov       rcx,	rax
    lea       rdx,	[rbp + cc_show.jeval.str]
    call      msys.getstrint
    jmp       L8989
L8998:
    cmp       rsi,	6
    jl        L8999
    cmp       rsi,	9
    jg        L8999
    mov       rax,	[r13]
    mov       rcx,	rax
    xor       edx,	edx
    call      msys.strword
    lea       rcx,	[rbp + cc_show.jeval.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L8989
L8999:
    cmp       rsi,	11
    jz        L9001
    cmp       rsi,	10
    jnz       L9000
L9001:
    movq      XMM4,	[r13]
    movq      XMM0,	XMM4
    xor       edx,	edx
    call      msys.strreal
    lea       rcx,	[rbp + cc_show.jeval.str]
    mov       rdx,	rax
    call      strcpy
    jmp       L8989
L9000:
    movsxd    rax,	dword ptr[r13+52]
    lea       r10,	[rip+cc_decls.ttbasetype]
    movsx     r10,	word ptr[r10 + rax*2]
    cmp       r10,	13
    jz        L9003
    cmp       r10,	17
    jz        L9004
    jmp       L9005
L9003:
#cc_show.jeval.doref:
L8993:
    lea       rcx,	[rbp + cc_show.jeval.str]
    call      msys.m$print_startstr
    mov       rcx,	[r13]
    call      msys.m$print_ptr_nf
    call      msys.m$print_end
    jmp       L9002
L9004:
    lea       rcx,	[rbp + cc_show.jeval.str]
    lea       rdx,	[rip+L11552]
    call      strcpy
    jmp       L9002
L9005:
    call      msys.m$print_startcon
    movsxd    rax,	dword ptr[r13+52]
    mov       rcx,	rax
    call      cc_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rcx,	[rip+L11553]
    call      mlib.abortprogram
L9002:
L8989:
    mov       rcx,	r12
    lea       rdx,	[rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    jmp       L8965
L8967:
    mov       rax,	[r13]
    mov       rax,	[rax]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_support.gs_additem
    jmp       L8965
L8968:
    mov       rcx,	r12
    lea       rdx,	[rip+L11554]
    call      mlib.gs_str
    mov       rax,	[r13]
    mov       rax,	[rax]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_support.gs_additem
    jmp       L8965
L8969:
    movsxd    rax,	dword ptr[r13+40]
    mov       rcx,	rax
    call      cc_lib.getopcjname
    lea       rcx,	[rbp + cc_show.jeval.str]
    mov       rdx,	rax
    call      strcpy
    mov       rcx,	r12
    lea       rdx,	[rip+L11555]
    call      cc_support.gs_additem
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rcx,	r12
    lea       rdx,	[rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       rax,	[r13+24]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rcx,	r12
    lea       rdx,	[rip+L11556]
    call      cc_support.gs_additem
    jmp       L8965
L8970:
    movsxd    rax,	dword ptr[r13+40]
    mov       rcx,	rax
    call      cc_lib.getopcjname
    lea       rcx,	[rbp + cc_show.jeval.str]
    mov       rdx,	rax
    call      strcpy
    mov       rcx,	r12
    lea       rdx,	[rbp + cc_show.jeval.str]
    call      cc_support.gs_additem
    mov       rcx,	r12
    lea       rdx,	[rip+L11557]
    call      cc_support.gs_additem
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rcx,	r12
    lea       rdx,	[rip+L11558]
    call      cc_support.gs_additem
    jmp       L8965
L8971:
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rcx,	r12
    lea       rdx,	[rip+L11559]
    call      cc_support.gs_additem
    mov       rdi,	[r13+24]
    jmp       L9007
L9006:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      cc_show.jeval
    mov       rdi,	[rdi+8]
    test      rdi,	rdi
    jz        L9010
    mov       rcx,	r12
    lea       rdx,	[rip+L11560]
    call      cc_support.gs_additem
L9010:
L9007:
    test      rdi,	rdi
    jnz       L9006
    mov       rcx,	r12
    lea       rdx,	[rip+L11561]
    call      cc_support.gs_additem
    jmp       L8965
L8972:
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rcx,	r12
    lea       rdx,	[rip+L11562]
    call      cc_support.gs_additem
    mov       rcx,	r12
    lea       rdx,	[rip+L11563]
    call      mlib.gs_str
    jmp       L8965
L8973:
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rcx,	r12
    lea       rdx,	[rip+L11564]
    call      cc_support.gs_additem
    mov       rax,	[r13+24]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    jmp       L8965
L8974:
    movsxd    rax,	dword ptr[r13+40]
    cmp       rax,	29
    setz      al
    movzx     eax,	al
    mov       rbx,	rax
    test      rbx,	rbx
    jz        L9012
    lea       rax,	[rip+L11565]
    jmp       L9011
L9012:
    lea       rax,	[rip+L11566]
L9011:
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_support.gs_additem
    mov       rdi,	[r13+16]
    jmp       L9014
L9013:
    mov       rcx,	r12
    mov       rdx,	rdi
    call      cc_show.jeval
    mov       rdi,	[rdi+8]
    test      rdi,	rdi
    jz        L9017
    mov       rcx,	r12
    lea       rdx,	[rip+L11567]
    call      cc_support.gs_additem
L9017:
L9014:
    test      rdi,	rdi
    jnz       L9013
    test      rbx,	rbx
    jz        L9019
    lea       rax,	[rip+L11568]
    jmp       L9018
L9019:
    lea       rax,	[rip+L11569]
L9018:
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_support.gs_additem
    jmp       L8965
L8975:
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rcx,	r12
    lea       rdx,	[rip+L11570]
    call      cc_support.gs_additem
    mov       rax,	[r13+24]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    jmp       L8965
L8976:
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rcx,	r12
    lea       rdx,	[rip+L11571]
    call      cc_support.gs_additem
    mov       rax,	[r13+24]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rcx,	r12
    lea       rdx,	[rip+L11572]
    call      cc_support.gs_additem
    mov       rax,	[r13+32]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    jmp       L8965
L8977:
    movsxd    rax,	dword ptr[r13+52]
    mov       rcx,	rax
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_support.gs_additem
    mov       rcx,	r12
    lea       rdx,	[rip+L11573]
    call      cc_support.gs_additem
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rcx,	r12
    lea       rdx,	[rip+L11574]
    call      cc_support.gs_additem
    jmp       L8965
L8978:
    mov       rcx,	r12
    lea       rdx,	[rip+L11575]
    call      cc_support.gs_additem
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rax,	[r13+24]
    test      rax,	rax
    jz        L9021
    mov       rcx,	r12
    lea       rdx,	[rip+L11576]
    call      cc_support.gs_additem
    mov       rax,	[r13+24]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
L9021:
    mov       rcx,	r12
    lea       rdx,	[rip+L11577]
    call      cc_support.gs_additem
    jmp       L8965
L8979:
    mov       rcx,	r12
    lea       rdx,	[rip+L11578]
    call      cc_support.gs_additem
    jmp       L8965
L8980:
    mov       rcx,	r12
    lea       rdx,	[rip+L11579]
    call      cc_support.gs_additem
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    jmp       L8965
L8981:
    mov       rcx,	r12
    lea       rdx,	[rip+L11580]
    call      cc_support.gs_additem
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    jmp       L8965
L8982:
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rcx,	r12
    lea       rdx,	[rip+L11581]
    call      cc_support.gs_additem
    jmp       L8965
L8983:
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rcx,	r12
    lea       rdx,	[rip+L11582]
    call      cc_support.gs_additem
    jmp       L8965
L8984:
    mov       rcx,	r12
    lea       rdx,	[rip+L11583]
    call      mlib.gs_str
    jmp       L8965
L8985:
    mov       rcx,	r12
    lea       rdx,	[rip+L11584]
    call      mlib.gs_str
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    movsxd    rax,	dword ptr[r13+48]
    cmp       rax,	0
    jle       L9023
    mov       rcx,	r12
    lea       rdx,	[rip+L11585]
    call      mlib.gs_str
    movsxd    rax,	dword ptr[r13+48]
    mov       rcx,	r12
    mov       rdx,	rax
    call      mlib.gs_strint
    jmp       L9022
L9023:
    mov       rcx,	r12
    lea       rdx,	[rip+L11586]
    call      mlib.gs_str
    movsxd    rax,	dword ptr[r13+48]
    neg       rax
    mov       rcx,	r12
    mov       rdx,	rax
    call      mlib.gs_strint
L9022:
    mov       rcx,	r12
    lea       rdx,	[rip+L11587]
    call      mlib.gs_str
    jmp       L8965
L8986:
    mov       rcx,	r12
    lea       rdx,	[rip+L11588]
    call      mlib.gs_str
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rcx,	r12
    lea       rdx,	[rip+L11589]
    call      mlib.gs_str
    mov       rax,	[r13+24]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    mov       rcx,	r12
    lea       rdx,	[rip+L11590]
    call      mlib.gs_str
    jmp       L8965
L8987:
    mov       rax,	[r13+16]
    mov       rcx,	r12
    mov       rdx,	rax
    call      cc_show.jeval
    jmp       L8965
L8988:
    mov       rcx,	r12
    lea       rdx,	[rip+L11591]
    call      mlib.gs_str
L8965:
L8964:
#---------------
    add       rsp,	16040
    pop       rbp
    pop       r13
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_show.printfilelist
cc_show.printfilelist:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
#?]]
    sub       rsp,	40
    mov       rbx,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	rbx
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11592]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+cc_decls.nsourcefiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	1
    mov       rax,	[rip+cc_decls.nsourcefiles]
    cmp       rax,	1
    jl        L9027
L9025:
    mov       rcx,	rbx
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11593]
    call      msys.m$print_setfmt
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    lea       rax,	[rip+cc_decls.sourcefilenames]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rcx,	rax
    lea       rdx,	[rip+L11594]
    call      msys.m$print_str
    lea       rax,	[rip+cc_decls.sourcefilepaths]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       rdi
    cmp       rdi,	[rip+cc_decls.nsourcefiles]
    jle       L9025
L9027:
    mov       rcx,	rbx
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11595]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+cc_decls.inputfile]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	rbx
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11596]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+cc_decls.nlibfiles]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rdi,	1
    mov       rax,	[rip+cc_decls.nlibfiles]
    cmp       rax,	1
    jl        L9030
L9028:
    mov       rcx,	rbx
    call      msys.m$print_startfile
    mov       rcx,	rdi
    call      msys.m$print_i64_nf
    lea       rax,	[rip+cc_decls.libfiles]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       rdi
    cmp       rdi,	[rip+cc_decls.nlibfiles]
    jle       L9028
L9030:
#---------------
    add       rsp,	40
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc cc_show.printmodelist
cc_show.printmodelist:
#PROC1
#PROC2
#?>>
    push      rdi
    push      rbx
    push      rsi
    push      r12
#?]]
    sub       rsp,	40
    mov       r12,	rcx
#---------------
#PROC3
#PROC4
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11597]
    call      msys.m$print_str_nf
    mov       rcx,	[rip+cc_decls.ntypes]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    xor       rdi,	rdi
    mov       rax,	[rip+cc_decls.ntypes]
    cmp       rax,	0
    jl        L9034
L9032:
    mov       rcx,	r12
    call      msys.m$print_startfile
    mov       rcx,	rdi
    lea       rdx,	[rip+L11598]
    call      msys.m$print_i64
    mov       rcx,	rdi
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[rip+cc_decls.ttbasetype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    mov       rbx,	rax
    lea       rax,	[rip+cc_decls.tttypedef]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    test      rax,	rax
    jz        L9036
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11599]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11600]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.tttypedef]
    mov       r10,	rdi
    mov       rax,	[rax + r10*8]
    mov       rcx,	[rax]
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
L9036:
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11601]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11602]
    call      msys.m$print_str_nf
    mov       rcx,	rbx
    call      msys.m$print_i64_nf
    mov       rcx,	rbx
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11603]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11604]
    call      msys.m$print_str_nf
    mov       rcx,	rdi
    call      cc_lib.typename
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    lea       rax,	[rip+cc_decls.ttnamedef]
    mov       r10,	rdi
    mov       rsi,	[rax + r10*8]
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11605]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11606]
    call      msys.m$print_str_nf
    mov       rcx,	rsi
    call      msys.m$print_ptr_nf
    call      msys.m$print_space
    call      msys.m$print_end
    test      rsi,	rsi
    jz        L9038
    mov       rcx,	r12
    call      msys.m$print_startfile
    mov       rcx,	[rsi]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    lea       rcx,	[rip+L11607]
    call      msys.m$print_str_nf
    call      msys.m$print_nogap
    movzx     rax,	word ptr[rsi+96]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_end
    jmp       L9037
L9038:
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11608]
    call      msys.m$print_str_nf
    call      msys.m$print_end
L9037:
    mov       rcx,	r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11609]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11610]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.tttarget]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    mov       rcx,	rax
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11611]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11612]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.ttsize]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11613]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11614]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.ttlength]
    mov       r10,	rdi
    mov       rcx,	[rax + r10*8]
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11615]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11616]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.ttisblock]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11617]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11618]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.ttconst]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11619]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11620]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.ttsigned]
    mov       r10,	rdi
    movzx     rax,	byte ptr[rax + r10]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11621]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11622]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.ttreftype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11623]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11624]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.ttconsttype]
    mov       r10,	rdi
    movsx     rax,	word ptr[rax + r10*2]
    mov       rcx,	rax
    mov       rdx,	1
    call      cc_lib.strmode
    mov       rcx,	rax
    call      msys.m$print_str_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r12
    call      msys.m$print_startfile
    lea       rcx,	[rip+L11625]
    call      msys.m$print_str_nf
    lea       rcx,	[rip+L11626]
    call      msys.m$print_str_nf
    lea       rax,	[rip+cc_decls.ttshared]
    mov       r10,	rdi
    movsxd    rax,	dword ptr[rax + r10*4]
    mov       rcx,	rax
    call      msys.m$print_i64_nf
    call      msys.m$print_newline
    call      msys.m$print_end
    mov       rcx,	r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
    inc       rdi
    cmp       rdi,	[rip+cc_decls.ntypes]
    jle       L9032
L9034:
    mov       rcx,	r12
    call      msys.m$print_startfile
    call      msys.m$print_newline
    call      msys.m$print_end
#---------------
    add       rsp,	40
    pop       r12
    pop       rsi
    pop       rbx
    pop       rdi
    ret       
# End 
# Proc msyswin.start
msyswin.start:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      msys.start
#---------------
    add       rsp,	40
    ret       
# End 
# Proc pcl.start
pcl.start:
#PROC1
#PROC2
#?>>
#?]]
    sub       rsp,	40
#---------------
#PROC3
#PROC4
    call      mc_genss.start
    call      mc_decls.start
    call      mc_writegas.start
#---------------
    add       rsp,	40
    ret       
# End 
    .data
$procaddr:
    .quad     mc_genmcl.px_nop
    .quad     mc_genmcl.px_dupl
    .quad     mc_genmcl.px_double
    .quad     mc_genmcl.px_opnd
    .quad     mc_genmcl.px_type
    .quad     mc_genmcl.px_comment
    .quad     mc_genmcl.px_proc
    .quad     mc_genmcl.px_endproc
    .quad     mc_genmcl.px_endprog
    .quad     mc_genmcl.px_istatic
    .quad     mc_genmcl.px_zstatic
    .quad     mc_genmcl.px_data
    .quad     mc_genmcl.px_label
    .quad     mc_genmcl.px_load
    .quad     mc_genmcl.px_store
    .quad     mc_genmcl.px_add
    .quad     mc_genmcl.px_sub
    .quad     mc_genmcl.px_mul
    .quad     mc_genmcl.px_div
    .quad     mc_genmcl.px_eval
    .quad     mc_genmcl.px_widen
    .quad     mc_genmcl.px_jump
    .quad     mc_genmcl.px_ijump
    .quad     mc_genmcl.px_neg
    .quad     mc_genmcl.px_abs
    .quad     mc_genmcl.px_bitnot
    .quad     mc_genmcl.px_not
    .quad     mc_genmcl.px_toboolt
    .quad     mc_genmcl.px_sqr
    .quad     mc_genmcl.px_sqrt
    .quad     mc_genmcl.px_jumpcc
    .quad     mc_genmcl.px_jumpt
    .quad     mc_genmcl.px_jumpf
    .quad     mc_genmcl.px_bitand
    .quad     mc_genmcl.px_bitor
    .quad     mc_genmcl.px_bitxor
    .quad     mc_genmcl.px_shl
    .quad     mc_genmcl.px_shr
    .quad     mc_genmcl.px_retproc
    .quad     mc_genmcl.px_retfn
    .quad     mc_genmcl.px_setcall
    .quad     mc_genmcl.px_setarg
    .quad     mc_genmcl.px_callp
    .quad     mc_genmcl.px_jumpret
    .quad     mc_genmcl.px_jumpretm
    .quad     mc_genmcl.px_startmx
    .quad     mc_genmcl.px_resetmx
    .quad     mc_genmcl.px_stop
    .quad     mc_genmcl.px_incrto
    .quad     mc_genmcl.px_decrto
    .quad     mc_genmcl.px_incrload
    .quad     mc_genmcl.px_decrload
    .quad     mc_genmcl.px_loadincr
    .quad     mc_genmcl.px_loaddecr
    .quad     mc_genmcl.px_forup
    .quad     mc_genmcl.px_fordown
    .quad     mc_genmcl.px_iload
    .quad     mc_genmcl.px_iloadx
    .quad     mc_genmcl.px_istore
    .quad     mc_genmcl.px_istorex
    .quad     mc_genmcl.px_storem
    .quad     mc_genmcl.px_addpx
    .quad     mc_genmcl.px_subpx
    .quad     mc_genmcl.px_to
    .quad     mc_genmcl.px_iswap
    .quad     mc_genmcl.px_swapstk
    .quad     mc_genmcl.px_labeldef
    .quad     mc_genmcl.px_addto
    .quad     mc_genmcl.px_subto
    .quad     mc_genmcl.px_multo
    .quad     mc_genmcl.px_bitandto
    .quad     mc_genmcl.px_bitorto
    .quad     mc_genmcl.px_bitxorto
    .quad     mc_genmcl.px_shlto
    .quad     mc_genmcl.px_shrto
    .quad     mc_genmcl.px_fix
    .quad     mc_genmcl.px_float
    .quad     mc_genmcl.px_idiv
    .quad     mc_genmcl.px_irem
    .quad     mc_genmcl.px_idivrem
    .quad     mc_genmcl.px_clear
    .quad     mc_genmcl.px_subp
    .quad     mc_genmcl.px_switch
    .quad     mc_genmcl.px_switchu
    .quad     mc_genmcl.px_swlabel
    .quad     mc_genmcl.px_endsw
    .quad     mc_genmcl.px_fwiden
    .quad     mc_genmcl.px_fnarrow
    .quad     mc_genmcl.px_truncate
    .quad     mc_genmcl.px_typepun
    .quad     mc_genmcl.px_unload
    .quad     mc_genmcl.px_loadbit
    .quad     mc_genmcl.px_assem
    .quad     mc_genmcl.px_sin
    .quad     mc_genmcl.px_cos
    .quad     mc_genmcl.px_tan
    .quad     mc_genmcl.px_asin
    .quad     mc_genmcl.px_acos
    .quad     mc_genmcl.px_atan
    .quad     mc_genmcl.px_log
    .quad     mc_genmcl.px_log10
    .quad     mc_genmcl.px_exp
    .quad     mc_genmcl.px_round
    .quad     mc_genmcl.px_floor
    .quad     mc_genmcl.px_ceil
    .quad     mc_genmcl.px_atan2
    .quad     mc_genmcl.px_fmod
    .quad     mc_genmcl.px_setcc
    .quad     mc_genmcl.px_min
    .quad     mc_genmcl.px_max
    .quad     mc_genmcl.px_power
    .quad     mc_genmcl.px_minto
    .quad     mc_genmcl.px_maxto
    .quad     mc_genmcl.px_negto
    .quad     mc_genmcl.px_absto
    .quad     mc_genmcl.px_addpxto
    .quad     mc_genmcl.px_subpxto
    .quad     mc_genmcl.px_divto
    .quad     mc_genmcl.px_bitnotto
    .quad     mc_genmcl.px_notto
    .quad     mc_genmcl.px_toboolto
    .quad     mc_genmcl.px_sign
    .quad     mc_genmcl.px_loadbf
    .quad     mc_genmcl.px_storebit
    .quad     mc_genmcl.px_storebf
    .quad     mc_genmcl.px_loadall
    .quad     mc_genmcl.px_setjmp
    .quad     mc_genmcl.px_longjmp
    .quad     mc_genmcl.px_initdswx
    .quad     mc_auxmcl.do_addrmode
$procname:
    .quad     L11627
    .quad     L11628
    .quad     L11629
    .quad     L11630
    .quad     L11631
    .quad     L11632
    .quad     L11633
    .quad     L11634
    .quad     L11635
    .quad     L11636
    .quad     L11637
    .quad     L11638
    .quad     L11639
    .quad     L11640
    .quad     L11641
    .quad     L11642
    .quad     L11643
    .quad     L11644
    .quad     L11645
    .quad     L11646
    .quad     L11647
    .quad     L11648
    .quad     L11649
    .quad     L11650
    .quad     L11651
    .quad     L11652
    .quad     L11653
    .quad     L11654
    .quad     L11655
    .quad     L11656
    .quad     L11657
    .quad     L11658
    .quad     L11659
    .quad     L11660
    .quad     L11661
    .quad     L11662
    .quad     L11663
    .quad     L11664
    .quad     L11665
    .quad     L11666
    .quad     L11667
    .quad     L11668
    .quad     L11669
    .quad     L11670
    .quad     L11671
    .quad     L11672
    .quad     L11673
    .quad     L11674
    .quad     L11675
    .quad     L11676
    .quad     L11677
    .quad     L11678
    .quad     L11679
    .quad     L11680
    .quad     L11681
    .quad     L11682
    .quad     L11683
    .quad     L11684
    .quad     L11685
    .quad     L11686
    .quad     L11687
    .quad     L11688
    .quad     L11689
    .quad     L11690
    .quad     L11691
    .quad     L11692
    .quad     L11693
    .quad     L11694
    .quad     L11695
    .quad     L11696
    .quad     L11697
    .quad     L11698
    .quad     L11699
    .quad     L11700
    .quad     L11701
    .quad     L11702
    .quad     L11703
    .quad     L11704
    .quad     L11705
    .quad     L11706
    .quad     L11707
    .quad     L11708
    .quad     L11709
    .quad     L11710
    .quad     L11711
    .quad     L11712
    .quad     L11713
    .quad     L11714
    .quad     L11715
    .quad     L11716
    .quad     L11717
    .quad     L11718
    .quad     L11719
    .quad     L11720
    .quad     L11721
    .quad     L11722
    .quad     L11723
    .quad     L11724
    .quad     L11725
    .quad     L11726
    .quad     L11727
    .quad     L11728
    .quad     L11729
    .quad     L11730
    .quad     L11731
    .quad     L11732
    .quad     L11733
    .quad     L11734
    .quad     L11735
    .quad     L11736
    .quad     L11737
    .quad     L11738
    .quad     L11739
    .quad     L11740
    .quad     L11741
    .quad     L11742
    .quad     L11743
    .quad     L11744
    .quad     L11745
    .quad     L11746
    .quad     L11747
    .quad     L11748
    .quad     L11749
    .quad     L11750
    .quad     L11751
    .quad     L11752
    .quad     L11753
    .quad     L11754
    .quad     L11755
    .quad     L11756
$nprocs:
    .quad     0x82
#Real Table
    .align    8
L11315:
    .quad     0x3FF0000000000000
L11223:
    .quad     0x4024000000000000
L11220:
    .quad     0x4024000000000000
L11217:
    .quad     0
L11216:
    .quad     0x4000000000000000
L11101:
    .quad     0x4000000000000000
L11057:
    .quad     0x4059000000000000
L10657:
    .quad     0x7FF0000000000000
L10655:
    .quad     0x7FF0000000000000
L10638:
    .quad     0
L10451:
    .quad     0x7FF0000000000000
L10379:
    .quad     0x43E0000000000000
L10378:
    .quad     0x3FF0000000000000
L10377:
    .quad     0x43E0000000000000
L10353:
    .quad     0
L10351:
    .quad     0
#Real32 Table
    .align    16
#lababs64
L10546:
    .quad     0x7FFFFFFFFFFFFFFF
    .quad     0x7FFFFFFFFFFFFFFF
#labneg64
L10545:
    .quad     0x8000000000000000
    .quad     0x8000000000000000
#mask63/offset64
L10554:
    .quad     0x7FFFFFFFFFFFFFFF
L10555:
    .quad     0x43E0000000000000
#String Table
    .align    8
L11756:
    .ascii    "do_addrmode"
    .byte     0
L11755:
    .ascii    "px_initdswx"
    .byte     0
L11754:
    .ascii    "px_longjmp"
    .byte     0
L11753:
    .ascii    "px_setjmp"
    .byte     0
L11752:
    .ascii    "px_loadall"
    .byte     0
L11751:
    .ascii    "px_storebf"
    .byte     0
L11750:
    .ascii    "px_storebit"
    .byte     0
L11749:
    .ascii    "px_loadbf"
    .byte     0
L11748:
    .ascii    "px_sign"
    .byte     0
L11747:
    .ascii    "px_toboolto"
    .byte     0
L11746:
    .ascii    "px_notto"
    .byte     0
L11745:
    .ascii    "px_bitnotto"
    .byte     0
L11744:
    .ascii    "px_divto"
    .byte     0
L11743:
    .ascii    "px_subpxto"
    .byte     0
L11742:
    .ascii    "px_addpxto"
    .byte     0
L11741:
    .ascii    "px_absto"
    .byte     0
L11740:
    .ascii    "px_negto"
    .byte     0
L11739:
    .ascii    "px_maxto"
    .byte     0
L11738:
    .ascii    "px_minto"
    .byte     0
L11737:
    .ascii    "px_power"
    .byte     0
L11736:
    .ascii    "px_max"
    .byte     0
L11735:
    .ascii    "px_min"
    .byte     0
L11734:
    .ascii    "px_setcc"
    .byte     0
L11733:
    .ascii    "px_fmod"
    .byte     0
L11732:
    .ascii    "px_atan2"
    .byte     0
L11731:
    .ascii    "px_ceil"
    .byte     0
L11730:
    .ascii    "px_floor"
    .byte     0
L11729:
    .ascii    "px_round"
    .byte     0
L11728:
    .ascii    "px_exp"
    .byte     0
L11727:
    .ascii    "px_log10"
    .byte     0
L11726:
    .ascii    "px_log"
    .byte     0
L11725:
    .ascii    "px_atan"
    .byte     0
L11724:
    .ascii    "px_acos"
    .byte     0
L11723:
    .ascii    "px_asin"
    .byte     0
L11722:
    .ascii    "px_tan"
    .byte     0
L11721:
    .ascii    "px_cos"
    .byte     0
L11720:
    .ascii    "px_sin"
    .byte     0
L11719:
    .ascii    "px_assem"
    .byte     0
L11718:
    .ascii    "px_loadbit"
    .byte     0
L11717:
    .ascii    "px_unload"
    .byte     0
L11716:
    .ascii    "px_typepun"
    .byte     0
L11715:
    .ascii    "px_truncate"
    .byte     0
L11714:
    .ascii    "px_fnarrow"
    .byte     0
L11713:
    .ascii    "px_fwiden"
    .byte     0
L11712:
    .ascii    "px_endsw"
    .byte     0
L11711:
    .ascii    "px_swlabel"
    .byte     0
L11710:
    .ascii    "px_switchu"
    .byte     0
L11709:
    .ascii    "px_switch"
    .byte     0
L11708:
    .ascii    "px_subp"
    .byte     0
L11707:
    .ascii    "px_clear"
    .byte     0
L11706:
    .ascii    "px_idivrem"
    .byte     0
L11705:
    .ascii    "px_irem"
    .byte     0
L11704:
    .ascii    "px_idiv"
    .byte     0
L11703:
    .ascii    "px_float"
    .byte     0
L11702:
    .ascii    "px_fix"
    .byte     0
L11701:
    .ascii    "px_shrto"
    .byte     0
L11700:
    .ascii    "px_shlto"
    .byte     0
L11699:
    .ascii    "px_bitxorto"
    .byte     0
L11698:
    .ascii    "px_bitorto"
    .byte     0
L11697:
    .ascii    "px_bitandto"
    .byte     0
L11696:
    .ascii    "px_multo"
    .byte     0
L11695:
    .ascii    "px_subto"
    .byte     0
L11694:
    .ascii    "px_addto"
    .byte     0
L11693:
    .ascii    "px_labeldef"
    .byte     0
L11692:
    .ascii    "px_swapstk"
    .byte     0
L11691:
    .ascii    "px_iswap"
    .byte     0
L11690:
    .ascii    "px_to"
    .byte     0
L11689:
    .ascii    "px_subpx"
    .byte     0
L11688:
    .ascii    "px_addpx"
    .byte     0
L11687:
    .ascii    "px_storem"
    .byte     0
L11686:
    .ascii    "px_istorex"
    .byte     0
L11685:
    .ascii    "px_istore"
    .byte     0
L11684:
    .ascii    "px_iloadx"
    .byte     0
L11683:
    .ascii    "px_iload"
    .byte     0
L11682:
    .ascii    "px_fordown"
    .byte     0
L11681:
    .ascii    "px_forup"
    .byte     0
L11680:
    .ascii    "px_loaddecr"
    .byte     0
L11679:
    .ascii    "px_loadincr"
    .byte     0
L11678:
    .ascii    "px_decrload"
    .byte     0
L11677:
    .ascii    "px_incrload"
    .byte     0
L11676:
    .ascii    "px_decrto"
    .byte     0
L11675:
    .ascii    "px_incrto"
    .byte     0
L11674:
    .ascii    "px_stop"
    .byte     0
L11673:
    .ascii    "px_resetmx"
    .byte     0
L11672:
    .ascii    "px_startmx"
    .byte     0
L11671:
    .ascii    "px_jumpretm"
    .byte     0
L11670:
    .ascii    "px_jumpret"
    .byte     0
L11669:
    .ascii    "px_callp"
    .byte     0
L11668:
    .ascii    "px_setarg"
    .byte     0
L11667:
    .ascii    "px_setcall"
    .byte     0
L11666:
    .ascii    "px_retfn"
    .byte     0
L11665:
    .ascii    "px_retproc"
    .byte     0
L11664:
    .ascii    "px_shr"
    .byte     0
L11663:
    .ascii    "px_shl"
    .byte     0
L11662:
    .ascii    "px_bitxor"
    .byte     0
L11661:
    .ascii    "px_bitor"
    .byte     0
L11660:
    .ascii    "px_bitand"
    .byte     0
L11659:
    .ascii    "px_jumpf"
    .byte     0
L11658:
    .ascii    "px_jumpt"
    .byte     0
L11657:
    .ascii    "px_jumpcc"
    .byte     0
L11656:
    .ascii    "px_sqrt"
    .byte     0
L11655:
    .ascii    "px_sqr"
    .byte     0
L11654:
    .ascii    "px_toboolt"
    .byte     0
L11653:
    .ascii    "px_not"
    .byte     0
L11652:
    .ascii    "px_bitnot"
    .byte     0
L11651:
    .ascii    "px_abs"
    .byte     0
L11650:
    .ascii    "px_neg"
    .byte     0
L11649:
    .ascii    "px_ijump"
    .byte     0
L11648:
    .ascii    "px_jump"
    .byte     0
L11647:
    .ascii    "px_widen"
    .byte     0
L11646:
    .ascii    "px_eval"
    .byte     0
L11645:
    .ascii    "px_div"
    .byte     0
L11644:
    .ascii    "px_mul"
    .byte     0
L11643:
    .ascii    "px_sub"
    .byte     0
L11642:
    .ascii    "px_add"
    .byte     0
L11641:
    .ascii    "px_store"
    .byte     0
L11640:
    .ascii    "px_load"
    .byte     0
L11639:
    .ascii    "px_label"
    .byte     0
L11638:
    .ascii    "px_data"
    .byte     0
L11637:
    .ascii    "px_zstatic"
    .byte     0
L11636:
    .ascii    "px_istatic"
    .byte     0
L11635:
    .ascii    "px_endprog"
    .byte     0
L11634:
    .ascii    "px_endproc"
    .byte     0
L11633:
    .ascii    "px_proc"
    .byte     0
L11632:
    .ascii    "px_comment"
    .byte     0
L11631:
    .ascii    "px_type"
    .byte     0
L11630:
    .ascii    "px_opnd"
    .byte     0
L11629:
    .ascii    "px_double"
    .byte     0
L11628:
    .ascii    "px_dupl"
    .byte     0
L11627:
    .ascii    "px_nop"
    .byte     0
L11626:
    .ascii    "Shared:"
    .byte     0
L11625:
    .byte     9
    .byte     0
L11624:
    .ascii    "Constver:"
    .byte     0
L11623:
    .byte     9
    .byte     0
L11622:
    .ascii    "Ref:"
    .byte     0
L11621:
    .byte     9
    .byte     0
L11620:
    .ascii    "Signed:"
    .byte     0
L11619:
    .byte     9
    .byte     0
L11618:
    .ascii    "Const:"
    .byte     0
L11617:
    .byte     9
    .byte     0
L11616:
    .ascii    "Isblock:"
    .byte     0
L11615:
    .byte     9
    .byte     0
L11614:
    .ascii    "Length:"
    .byte     0
L11613:
    .byte     9
    .byte     0
L11612:
    .ascii    "Size:"
    .byte     0
L11611:
    .byte     9
    .byte     0
L11610:
    .ascii    "Target:"
    .byte     0
L11609:
    .byte     9
    .byte     0
L11608:
    .ascii    "-"
    .byte     0
L11607:
    .ascii    "."
    .byte     0
L11606:
    .ascii    "ttnamedef:"
    .byte     0
L11605:
    .byte     9
    .byte     0
L11604:
    .ascii    "Name:"
    .byte     0
L11603:
    .byte     9
    .byte     0
L11602:
    .ascii    "Basetype:"
    .byte     0
L11601:
    .byte     9
    .byte     0
L11600:
    .ascii    "Typedef:"
    .byte     0
L11599:
    .byte     9
    .byte     0
L11598:
    .ascii    "4"
    .byte     0
L11597:
    .ascii    "PROC MODELIST"
    .byte     0
L11596:
    .byte     10
    .ascii    "Libfiles"
    .byte     0
L11595:
    .byte     10
    .ascii    "Input file:"
    .byte     0
L11594:
    .ascii    "12jl"
    .byte     0
L11593:
    .ascii    "# # (#)"
    .byte     0
L11592:
    .ascii    "Source files"
    .byte     0
L11591:
    .ascii    "<CAN'T DO JEVAL>"
    .byte     0
L11590:
    .ascii    ")"
    .byte     0
L11589:
    .ascii    "+"
    .byte     0
L11588:
    .ascii    "("
    .byte     0
L11587:
    .ascii    ")"
    .byte     0
L11586:
    .ascii    ")/"
    .byte     0
L11585:
    .ascii    ")*"
    .byte     0
L11584:
    .ascii    "scale(("
    .byte     0
L11583:
    .ascii    "<nullunit>"
    .byte     0
L11582:
    .ascii    "--"
    .byte     0
L11581:
    .ascii    "++"
    .byte     0
L11580:
    .ascii    "--"
    .byte     0
L11579:
    .ascii    "++"
    .byte     0
L11578:
    .ascii    "<JBLOCK>"
    .byte     0
L11577:
    .ascii    ")"
    .byte     0
L11576:
    .ascii    "+"
    .byte     0
L11575:
    .ascii    "*("
    .byte     0
L11574:
    .ascii    ")"
    .byte     0
L11573:
    .ascii    "("
    .byte     0
L11572:
    .ascii    ":"
    .byte     0
L11571:
    .ascii    "?"
    .byte     0
L11570:
    .ascii    "="
    .byte     0
L11569:
    .ascii    "}"
    .byte     0
L11568:
    .ascii    ")"
    .byte     0
L11567:
    .ascii    ","
    .byte     0
L11566:
    .ascii    "{"
    .byte     0
L11565:
    .ascii    "("
    .byte     0
L11564:
    .ascii    "->"
    .byte     0
L11563:
    .ascii    "???"
    .byte     0
L11562:
    .ascii    "."
    .byte     0
L11561:
    .ascii    ")"
    .byte     0
L11560:
    .ascii    ","
    .byte     0
L11559:
    .ascii    "("
    .byte     0
L11558:
    .ascii    ")"
    .byte     0
L11557:
    .ascii    "("
    .byte     0
L11556:
    .ascii    ")"
    .byte     0
L11555:
    .ascii    "("
    .byte     0
L11554:
    .ascii    "&"
    .byte     0
L11553:
    .ascii    "EVAL/C"
    .byte     0
L11552:
    .ascii    "ARRAY"
    .byte     0
L11551:
    .byte     34
    .byte     0
L11550:
    .ascii    "LONGSTR)"
    .byte     0
L11549:
    .ascii    ")"
    .byte     0
L11548:
    .ascii    "-"
    .byte     0
L11547:
    .ascii    "(From"
    .byte     0
L11546:
    .byte     9
    .byte     0
L11545:
    .ascii    ":"
    .byte     0
L11544:
    .ascii    "GLOBAL SYMBOL TABLE:"
    .byte     0
L11543:
    .ascii    "*"
    .byte     0
L11542:
    .ascii    " Code:"
    .byte     0
L11541:
    .ascii    " Mode:"
    .byte     0
L11540:
    .ascii    "Anon"
    .byte     0
L11539:
    .byte     9
    .byte     9
    .ascii    "Param: "
    .byte     0
L11538:
    .ascii    " "
    .byte     0
L11537:
    .ascii    "Lineno:"
    .byte     0
L11536:
    .ascii    " "
    .byte     0
L11535:
    .ascii    "STATIC********"
    .byte     0
L11534:
    .ascii    "="
    .byte     0
L11533:
    .ascii    "Enum:"
    .byte     0
L11532:
    .ascii    "Index:"
    .byte     0
L11531:
    .ascii    " Offset: "
    .byte     0
L11530:
    .ascii    "="
    .byte     0
L11529:
    .ascii    "Offset:"
    .byte     0
L11528:
    .ascii    "Void "
    .byte     0
L11527:
    .ascii    "()"
    .byte     0
L11526:
    .ascii    "(#)"
    .byte     0
L11525:
    .ascii    "]"
    .byte     0
L11524:
    .ascii    "Pm:# "
    .byte     0
L11523:
    .ascii    "Used "
    .byte     0
L11522:
    .ascii    "Var "
    .byte     0
L11521:
    .ascii    " "
    .byte     0
L11520:
    .ascii    "@@"
    .byte     0
L11519:
    .ascii    " "
    .byte     0
L11518:
    .ascii    "["
    .byte     0
L11517:
    .ascii    "."
    .byte     0
L11516:
    .ascii    ":"
    .byte     0
L11515:
    .ascii    "    "
    .byte     0
L11514:
    .ascii    "PRINTST not name"
    .byte     0
L11513:
    .ascii    "z5"
    .byte     0
L11512:
    .ascii    "# "
    .byte     0
L11511:
    .ascii    "."
    .byte     0
L11510:
    .ascii    " "
    .byte     0
L11509:
    .ascii    "|---"
    .byte     0
L11508:
    .ascii    "-----------------------"
    .byte     0
L11507:
    .ascii    "3"
    .byte     0
L11506:
    .ascii    "2"
    .byte     0
L11505:
    .ascii    "1"
    .byte     0
L11504:
    .ascii    " ALENGTH="
    .byte     0
L11503:
    .ascii    " Widen from:"
    .byte     0
L11502:
    .ascii    " Offset:"
    .byte     0
L11501:
    .ascii    " Aparams:"
    .byte     0
L11500:
    .ascii    "Ptrscale:"
    .byte     0
L11499:
    .ascii    "Scale:"
    .byte     0
L11498:
    .ascii    " => "
    .byte     0
L11497:
    .ascii    " "
    .byte     0
L11496:
    .ascii    "<WSTRCONST>"
    .byte     0
L11495:
    .ascii    "<STRCONST>"
    .byte     0
L11494:
    .ascii    " "
    .byte     0
L11493:
    .ascii    "PRINTUNIT BAD CONST"
    .byte     0
L11492:
    .ascii    "PRINTUNIT/CONST/aRRAY"
    .byte     0
L11491:
    .byte     34
    .ascii    " *"
    .byte     0
L11490:
    .ascii    "(WSTRING)"
    .byte     0
L11489:
    .byte     34
    .byte     0
L11488:
    .byte     34
    .ascii    " *"
    .byte     0
L11487:
    .byte     34
    .byte     0
L11486:
    .byte     34
    .ascii    " *"
    .byte     0
L11485:
    .ascii    "(LONGSTR)"
    .byte     0
L11484:
    .byte     34
    .byte     0
L11483:
    .ascii    "Value:"
    .byte     0
L11482:
    .ascii    "1"
    .byte     0
L11481:
    .ascii    " Lastcall:"
    .byte     0
L11480:
    .ascii    " "
    .byte     0
L11479:
    .ascii    "}"
    .byte     0
L11478:
    .ascii    " {"
    .byte     0
L11477:
    .ascii    ": "
    .byte     0
L11475:
    .ascii    "             "
    .byte     0
L11474:
    .ascii    "print unit: bad tag"
    .byte     0
L11473:
    .ascii    "1"
    .byte     0
L11472:
    .ascii    "="
    .byte     0
L11471:
    .ascii    "wb"
    .byte     0
L11470:
    .ascii    "as"
    .byte     0
L11469:
    .ascii    "Writing internal"
    .byte     0
L11468:
    .ascii    "hdr"
    .byte     0
L11467:
    .ascii    " "
    .byte     0
L11466:
    .ascii    "<builtin>"
    .byte     0
L11465:
    .byte     0
L11464:
    .ascii    "Too many source files"
    .byte     0
L11463:
    .ascii    "LSF can't load "
    .byte     0
L11462:
    .byte     0
L11461:
    .ascii    "Too many source files"
    .byte     0
L11460:
    .ascii    "Stopping"
    .byte     0
L11459:
    .ascii    "Load Error:"
    .byte     0
L11458:
    .ascii    "****"
    .byte     0
L11457:
    .ascii    "**** Code Gen Error:"
    .byte     0
L11456:
    .ascii    "in file"
    .byte     0
L11455:
    .ascii    "On line"
    .byte     0
L11454:
    .ascii    " "
    .byte     0
L11453:
    .ascii    "In function"
    .byte     0
L11452:
    .ascii    "on line"
    .byte     0
L11451:
    .ascii    "Type error:"
    .byte     0
L11450:
    .byte     10
    .ascii    "In function"
    .byte     0
L11449:
    .ascii    "****"
    .byte     0
L11448:
    .ascii    "**** Syntax Error:"
    .byte     0
L11447:
    .ascii    "in file"
    .byte     0
L11446:
    .ascii    "On line"
    .byte     0
L11445:
    .ascii    "OUTSIDE PROC"
    .byte     0
L11444:
    .ascii    " "
    .byte     0
L11443:
    .byte     10
    .ascii    "In function"
    .byte     0
L11442:
    .byte     10
    .ascii    "MC Error:"
    .byte     0
L11441:
    .ascii    "w"
    .byte     0
L11440:
    .ascii    "$error.tmp"
    .byte     0
L11439:
    .ascii    "ATL ERROR"
    .byte     0
L11438:
    .ascii    "rb"
    .byte     0
L11437:
    .ascii    "w"
    .byte     0
L11436:
    .ascii    "GETALIGN SIZE NOT 1248"
    .byte     0
L11435:
    .ascii    "Dupl proc name"
    .byte     0
L11434:
    .ascii    "in"
    .byte     0
L11433:
    .byte     34
    .byte     0
L11432:
    .ascii    " "
    .byte     34
    .byte     0
L11431:
    .ascii    "# expected, not #"
    .byte     0
L11430:
    .ascii    "Too many types/cnm"
    .byte     0
L11429:
    .ascii    "STRMODE(M)="
    .byte     0
L11428:
    .ascii    "Too many types"
    .byte     0
L11427:
    .byte     0
L11426:
    .ascii    "const "
    .byte     0
L11425:
    .ascii    "<enum>"
    .byte     0
L11424:
    .ascii    "<array>"
    .byte     0
L11423:
    .ascii    "."
    .byte     0
L11422:
    .ascii    "union "
    .byte     0
L11421:
    .ascii    "struct "
    .byte     0
L11420:
    .ascii    "NEWSTRMODE"
    .byte     0
L11419:
    .ascii    ")"
    .byte     0
L11418:
    .ascii    ","
    .byte     0
L11417:
    .ascii    "proc("
    .byte     0
L11416:
    .ascii    ")"
    .byte     0
L11415:
    .ascii    " "
    .byte     0
L11414:
    .ascii    ","
    .byte     0
L11413:
    .ascii    "("
    .byte     0
L11412:
    .ascii    "enum "
    .byte     0
L11411:
    .ascii    "[]"
    .byte     0
L11410:
    .ascii    "[#]"
    .byte     0
L11409:
    .ascii    "ref "
    .byte     0
L11408:
    .ascii    "const ref "
    .byte     0
L11407:
    .ascii    "z3"
    .byte     0
L11406:
    .byte     92
    .ascii    "#o"
    .byte     0
L11405:
    .ascii    "$F"
    .byte     0
L11404:
    .ascii    "$T"
    .byte     0
L11403:
    .ascii    "GCV Not constant"
    .byte     0
L11402:
    .ascii    "Can't find -to version"
    .byte     0
L11401:
    .ascii    "to"
    .byte     0
L11399:
    .ascii    "main"
    .byte     0
L11398:
    .ascii    "."
    .byte     0
L11397:
    .ascii    "Dupl case value: #"
    .byte     0
L11396:
    .ascii    "Too many cases on one switch"
    .byte     0
L11395:
    .ascii    "case: serial switch not found"
    .byte     0
L11394:
    .ascii    "Label not defined: #"
    .byte     0
L11393:
    .ascii    "maxparams"
    .byte     0
L11392:
    .ascii    "Convert op not implem: #"
    .byte     0
L11391:
    .ascii    "Bad cast"
    .byte     0
L11390:
    .ascii    "DOASSIGN not ready: #"
    .byte     0
L11389:
    .ascii    "dxname"
    .byte     0
L11388:
    .ascii    "const?"
    .byte     0
L11387:
    .ascii    "CONST/WSTRING"
    .byte     0
L11386:
    .ascii    "DX-EXPR: can't do tag: #"
    .byte     0
L11385:
    .ascii    "2:Runtime expr in static data"
    .byte     0
L11384:
    .ascii    "*"
    .byte     0
L11383:
    .ascii    "Complex ptr expr in static data"
    .byte     0
L11382:
    .ascii    "1:Runtime or unsupported expr in static data"
    .byte     0
L11381:
    .ascii    "+"
    .byte     0
L11380:
    .ascii    "Add/Idata &frame"
    .byte     0
L11379:
    .ascii    "+"
    .byte     0
L11378:
    .ascii    ","
    .byte     0
L11377:
    .ascii    "`"
    .byte     0
L11376:
    .ascii    "Idata &frame"
    .byte     0
L11375:
    .ascii    "IDATA/SCALAR"
    .byte     0
L11374:
    .ascii    "GENIDATA/WSTRING2"
    .byte     0
L11373:
    .ascii    "$#.#.#"
    .byte     0
L11372:
    .byte     0
L11371:
    .ascii    "------------------------"
    .byte     0
L11370:
    .ascii    "main"
    .byte     0
L11369:
    .byte     0
L11368:
    .ascii    "Static fn not defined: #"
    .byte     0
L11367:
    .ascii    "1:Start of code"
    .byte     0
L11366:
    .ascii    "GenPCL:"
    .byte     0
L11365:
    .ascii    "Generic: multiple types match"
    .byte     0
L11364:
    .ascii    "Generic: no type match"
    .byte     0
L11363:
    .ascii    "generic/default twice"
    .byte     0
L11362:
    .ascii    "Not array"
    .byte     0
L11361:
    .ascii    "*"
    .byte     0
L11360:
    .ascii    "Can't do conversion # => #"
    .byte     0
L11359:
    .ascii    "*"
    .byte     0
L11358:
    .ascii    "case not inside switch stmt"
    .byte     0
L11357:
    .ascii    "poploop?"
    .byte     0
L11356:
    .ascii    "Too many nested loop or switch"
    .byte     0
L11355:
    .ascii    "Not allowed on ptrs"
    .byte     0
L11354:
    .ascii    "-= refs don't match"
    .byte     0
L11353:
    .ascii    "ptr+=ptr"
    .byte     0
L11352:
    .ascii    "Not a field of struct # #"
    .byte     0
L11351:
    .ascii    ". -> not a struct"
    .byte     0
L11350:
    .ascii    "-> needs pointer"
    .byte     0
L11349:
    .ascii    "enum name reused #"
    .byte     0
L11348:
    .ascii    "Redefining enum #"
    .byte     0
L11347:
    .ascii    "Enum tag in use #"
    .byte     0
L11346:
    .ascii    "BAD REF[]"
    .byte     0
L11345:
    .ascii    "const to non-const pointer"
    .byte     0
L11344:
    .ascii    "Struct decl error #"
    .byte     0
L11343:
    .ascii    "Struct decl error"
    .byte     0
L11342:
    .ascii    "Can't use ss in struct"
    .byte     0
L11341:
    .ascii    "member name in use #"
    .byte     0
L11340:
    .ascii    "typedef or function inside struct"
    .byte     0
L11339:
    .ascii    "Field name expected"
    .byte     0
L11338:
    .ascii    "Redefining struct #"
    .byte     0
L11337:
    .ascii    "Prev"
    .byte     0
L11336:
    .ascii    "Struct tag in use #"
    .byte     0
L11335:
    .ascii    "ATP?"
    .byte     0
L11334:
    .ascii    "*"
    .byte     0
L11333:
    .ascii    "ATP:"
    .byte     0
L11332:
    .ascii    "Variadic param is void"
    .byte     0
L11331:
    .ascii    "Too many args"
    .byte     0
L11330:
    .ascii    "1:Too few args"
    .byte     0
L11329:
    .ascii    "ccall?"
    .byte     0
L11328:
    .ascii    "*"
    .byte     0
L11327:
    .ascii    "JTAGNAMES[P.TAG]="
    .byte     0
L11326:
    .ascii    "Not function pointer: #"
    .byte     0
L11325:
    .ascii    "value: #"
    .byte     0
L11324:
    .ascii    "*"
    .byte     0
L11323:
    .ascii    "CHECKLV/WIDEN"
    .byte     0
L11321:
    .ascii    "Invalid condition #"
    .byte     0
L11320:
    .ascii    "rem 0"
    .byte     0
L11319:
    .ascii    "div 0"
    .byte     0
L11318:
    .ascii    "EVALSUB/REF"
    .byte     0
L11316:
    .ascii    "Rem bad types"
    .byte     0
L11314:
    .ascii    "Div bad types"
    .byte     0
L11313:
    .ascii    "Mul bad types"
    .byte     0
L11312:
    .ascii    "Sub bad types"
    .byte     0
L11311:
    .ascii    "++ bad type"
    .byte     0
L11310:
    .ascii    "* not pointer"
    .byte     0
L11309:
    .ascii    "*"
    .byte     0
L11308:
    .ascii    "! bad type"
    .byte     0
L11307:
    .ascii    "abs bad type"
    .byte     0
L11305:
    .ascii    "neg bad type"
    .byte     0
L11304:
    .ascii    "; after function def"
    .byte     0
L11303:
    .ascii    "Can't define function twice #"
    .byte     0
L11302:
    .ascii    "fn: name in use #"
    .byte     0
L11301:
    .ascii    "NAME not allowed in cast type #"
    .byte     0
L11300:
    .ascii    "bad symbol in paramlist"
    .byte     0
L11299:
    .ascii    "Param name reused # #"
    .byte     0
L11298:
    .ascii    "Param type missing or misspelt"
    .byte     0
L11297:
    .ascii    "Typedef redefined or can't match types #"
    .byte     0
L11296:
    .ascii    "Typedef name in use #"
    .byte     0
L11295:
    .ascii    "Local decl error #"
    .byte     0
L11294:
    .ascii    "Nested function"
    .byte     0
L11293:
    .ascii    "Var name expected"
    .byte     0
L11292:
    .ascii    "Return value needed"
    .byte     0
L11291:
    .ascii    "Can't return value in void function"
    .byte     0
L11290:
    .ascii    "For decl error"
    .byte     0
L11289:
    .ascii    "Not allowed in for stmt"
    .byte     0
L11288:
    .ascii    "Var name expected"
    .byte     0
L11286:
    .ascii    "2:Duplicate label"
    .byte     0
L11285:
    .ascii    "continue outside loop"
    .byte     0
L11284:
    .ascii    "break outside loop/sw"
    .byte     0
L11283:
    .ascii    "{...} statement expected"
    .byte     0
L11282:
    .ascii    "Too many blocks"
    .byte     0
L11281:
    .ascii    "Too many block levels"
    .byte     0
L11280:
    .ascii    "Init str too long"
    .byte     0
L11279:
    .ascii    "Array init"
    .byte     0
L11278:
    .ascii    "{} initialiser expected"
    .byte     0
L11277:
    .ascii    "Too many struct elems"
    .byte     0
L11276:
    .ascii    "Too many array elems"
    .byte     0
L11275:
    .ascii    "init/Empty struct"
    .byte     0
L11274:
    .ascii    "init/0-size array"
    .byte     0
L11273:
    .ascii    "readconstint #"
    .byte     0
L11272:
    .ascii    "Negative array dim"
    .byte     0
L11271:
    .ascii    "ZERO LEN ARRAY"
    .byte     0
L11270:
    .ascii    "Can't do VLAs"
    .byte     0
L11269:
    .ascii    "rnt1"
    .byte     0
L11268:
    .ascii    "Can't init extern #"
    .byte     0
L11267:
    .ascii    "Can't init twice #"
    .byte     0
L11266:
    .ascii    "var: name in use #"
    .byte     0
L11265:
    .ascii    "Can't init extern #"
    .byte     0
L11264:
    .ascii    "Can't init twice #"
    .byte     0
L11263:
    .ascii    "var: redefining #"
    .byte     0
L11262:
    .ascii    "var: name in use # #"
    .byte     0
L11261:
    .ascii    "Readterm?"
    .byte     0
L11260:
    .ascii    "RT"
    .byte     0
L11259:
    .ascii    "rt/alignof"
    .byte     0
L11258:
    .ascii    "rt/compound lit"
    .byte     0
L11257:
    .ascii    "rt/&&label"
    .byte     0
L11256:
    .ascii    "char const too long"
    .byte     0
L11255:
    .ascii    "Undefined name "
    .byte     34
    .ascii    "#"
    .byte     34
    .byte     0
L11254:
    .ascii    "shift:Not an int"
    .byte     0
L11253:
    .ascii    "invalid rel operands"
    .byte     0
L11252:
    .ascii    "Comparing distinct pointers/rel"
    .byte     0
L11251:
    .ascii    "invalid == operands"
    .byte     0
L11250:
    .ascii    "U="
    .byte     0
L11249:
    .ascii    "Can't compare pointer to int2"
    .byte     0
L11248:
    .ascii    "Can't compare pointer to int"
    .byte     0
L11247:
    .ascii    "Comparing distinct pointers/eq"
    .byte     0
L11246:
    .ascii    "invalid & operands"
    .byte     0
L11245:
    .ascii    "float&float"
    .byte     0
L11244:
    .ascii    "invalid ^ operands"
    .byte     0
L11243:
    .ascii    "float^float"
    .byte     0
L11242:
    .ascii    "invalid | operands"
    .byte     0
L11241:
    .ascii    "float|float"
    .byte     0
L11240:
    .ascii    "?: incompatible types"
    .byte     0
L11239:
    .ascii    "Modifying constant?"
    .byte     0
L11238:
    .ascii    "Modifying read-only var"
    .byte     0
L11237:
    .ascii    "declspec/float"
    .byte     0
L11236:
    .ascii    "dbl decl?"
    .byte     0
L11235:
    .ascii    "char decl?"
    .byte     0
L11234:
    .ascii    "Implicit decls not allowed: #"
    .byte     0
L11233:
    .ascii    "enum?"
    .byte     0
L11232:
    .ascii    "struct?"
    .byte     0
L11231:
    .ascii    "Dual storage spec"
    .byte     0
L11230:
    .ascii    "declspec/ts #"
    .byte     0
L11229:
    .ascii    "PARSETEST"
    .byte     0
L11228:
    .ascii    "Parsing:"
    .byte     0
L11227:
    .ascii    "Decl error #"
    .byte     0
L11226:
    .ascii    "fn def after comma"
    .byte     0
L11225:
    .ascii    "Var name expected"
    .byte     0
L11224:
    .ascii    "Extra semicolon 2"
    .byte     0
L11215:
    .ascii    "Real too long"
    .byte     0
L11214:
    .ascii    "REGENHST FULL?"
    .byte     0
L11213:
    .ascii    "regenhst dupl?"
    .byte     0
L11212:
    .ascii    "mcc.h"
    .byte     0
L11211:
    .ascii    "TMLM"
    .byte     0
L11210:
    .ascii    "TMH"
    .byte     0
L11209:
    .ascii    "TMM"
    .byte     0
L11208:
    .ascii    "Str expected"
    .byte     0
L11207:
    .ascii    "link"
    .byte     0
L11206:
    .ascii    "header"
    .byte     0
L11205:
    .ascii    "module"
    .byte     0
L11204:
    .ascii    "Only pack(1) or () allowed"
    .byte     0
L11203:
    .ascii    "'(' expected"
    .byte     0
L11202:
    .ascii    "pack"
    .byte     0
L11201:
    .ascii    "2:Too many pasted tokens"
    .byte     0
L11200:
    .ascii    "PDM"
    .byte     0
L11199:
    .ascii    "???"
    .byte     0
L11198:
    .ascii    "(File not available)"
    .byte     0
L11197:
    .ascii    "z2"
    .byte     0
L11196:
    .ascii    "2"
    .byte     0
L11195:
    .ascii    "#:#:#"
    .byte     0
L11194:
    .ascii    "4"
    .byte     0
L11193:
    .ascii    "#-#-#"
    .byte     0
L11192:
    .ascii    "#if:Unexpected eof"
    .byte     0
L11191:
    .ascii    "EOL expected"
    .byte     0
L11190:
    .ascii    "Name expected"
    .byte     0
L11189:
    .ascii    "evalterm?"
    .byte     0
L11188:
    .ascii    ") expected"
    .byte     0
L11187:
    .ascii    "')' expected"
    .byte     0
L11186:
    .ascii    "sizeof2"
    .byte     0
L11185:
    .ascii    "name expected"
    .byte     0
L11184:
    .ascii    "'(' expected"
    .byte     0
L11183:
    .ascii    "')' expected"
    .byte     0
L11182:
    .ascii    "defined?"
    .byte     0
L11181:
    .ascii    "#if:div by zero"
    .byte     0
L11180:
    .ascii    ": expected"
    .byte     0
L11179:
    .ascii    "#if:eol expected"
    .byte     0
L11178:
    .ascii    "Too many pasted tokens"
    .byte     0
L11177:
    .ascii    ".*"
    .byte     0
L11176:
    .ascii    "v"
    .byte     0
L11175:
    .byte     0
L11174:
    .byte     10
    .byte     0
L11173:
    .ascii    "Too many ##"
    .byte     0
L11172:
    .ascii    "## at start"
    .byte     0
L11171:
    .ascii    "# not followed by param"
    .byte     0
L11170:
    .ascii    "# at end"
    .byte     0
L11169:
    .ascii    "Wrong # macro params"
    .byte     0
L11168:
    .ascii    "EOS in macro call"
    .byte     0
L11167:
    .ascii    "rmc: ')' expected"
    .byte     0
L11166:
    .ascii    "rmc: no '('"
    .byte     0
L11165:
    .ascii    ">"
    .byte     0
L11164:
    .ascii    "<"
    .byte     0
L11163:
    .ascii    "macro params?"
    .byte     0
L11162:
    .ascii    "')' expected"
    .byte     0
L11161:
    .ascii    "__VA_ARGS__"
    .byte     0
L11160:
    .ascii    "Dupl macro param"
    .byte     0
L11159:
    .ascii    "define: name expected"
    .byte     0
L11158:
    .ascii    "Local str too long"
    .byte     0
L11157:
    .ascii    "String not terminated"
    .byte     0
L11156:
    .ascii    "NEXTLX.LINENO="
    .byte     0
L11155:
    .ascii    "#define __attribute__(x)"
    .byte     10
    .ascii    "#define _WIN32"
    .byte     10
    .ascii    "#define WIN32"
    .byte     10
    .ascii    "#define __WIN32__"
    .byte     10
    .ascii    "#define __inline"
    .byte     10
    .ascii    "#define __dllimport(x)"
    .byte     10
    .ascii    "#define __declspec(x)"
    .byte     10
    .ascii    "#define __stdcall"
    .byte     10
    .ascii    "#define CALLBACK $callback"
    .byte     10
    .ascii    "#define __cdecl"
    .byte     10
    .ascii    "#define EXTERN_C extern"
    .byte     10
    .ascii    "#define DECLSPEC_IMPORT"
    .byte     10
    .ascii    "#define __32BIT__"
    .byte     10
    .ascii    "#define register"
    .byte     10
    .ascii    "#define __MCCC__"
    .byte     10
    .byte     10
    .ascii    "typedef signed char"
    .byte     9
    .byte     9
    .ascii    "i8;"
    .byte     10
    .ascii    "typedef short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "i16;"
    .byte     10
    .ascii    "typedef int"
    .byte     9
    .byte     9
    .byte     9
    .byte     9
    .ascii    "i32;"
    .byte     10
    .ascii    "typedef long long int"
    .byte     9
    .ascii    "i64;"
    .byte     10
    .ascii    "typedef unsigned char"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u8;"
    .byte     10
    .ascii    "typedef unsigned short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u16;"
    .byte     10
    .ascii    "typedef unsigned int"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "u32;"
    .byte     10
    .ascii    "typedef unsigned long long int"
    .byte     9
    .ascii    "u64;"
    .byte     10
    .byte     10
    .ascii    "typedef unsigned char byte;"
    .byte     10
    .byte     10
    .ascii    "typedef float r32;"
    .byte     10
    .ascii    "typedef double r64;"
    .byte     10
    .byte     10
    .byte     0
L11154:
    .ascii    "mcc.h"
    .byte     0
L11153:
    .ascii    "Too many nested includes"
    .byte     0
L11152:
    .ascii    "Can't find include file"
    .byte     0
L11151:
    .ascii    "Overflow in decimal number"
    .byte     0
L11150:
    .ascii    "18446744073709551615"
    .byte     0
L11149:
    .ascii    "-U?"
    .byte     0
L11148:
    .ascii    "-LL?"
    .byte     0
L11147:
    .ascii    "Overflow in octal number"
    .byte     0
L11146:
    .ascii    "1777777777777777777777"
    .byte     0
L11145:
    .ascii    "-U?"
    .byte     0
L11144:
    .ascii    "-LL?"
    .byte     0
L11143:
    .ascii    "Overflow in binary number"
    .byte     0
L11142:
    .ascii    "Binary fp"
    .byte     0
L11141:
    .ascii    "Binary bad digit"
    .byte     0
L11140:
    .ascii    "Overflow in hex number"
    .byte     0
L11139:
    .ascii    "-U?"
    .byte     0
L11138:
    .ascii    "-LL?"
    .byte     0
L11137:
    .ascii    "block comment eof"
    .byte     0
L11136:
    .ascii    ":##"
    .byte     0
L11135:
    .ascii    ":::"
    .byte     0
L11134:
    .ascii    "#endif missing"
    .byte     0
L11133:
    .ascii    "Directive not implemented"
    .byte     0
L11132:
    .ascii    "DIRECTIVE NOT IMPL:"
    .byte     0
L11131:
    .ascii    "ABORTING"
    .byte     0
L11130:
    .ascii    "#ERROR:"
    .byte     0
L11129:
    .ascii    "#if missing/endif"
    .byte     0
L11128:
    .ascii    "#if missing/elif/else"
    .byte     0
L11127:
    .ascii    "undef: name expected"
    .byte     0
L11126:
    .ascii    "NSOURCEFILES="
    .byte     0
L11125:
    .ascii    "FROM"
    .byte     0
L11124:
    .ascii    "INCLUDE"
    .byte     0
L11123:
    .ascii    "include?"
    .byte     0
L11122:
    .ascii    "include: > expected"
    .byte     0
L11121:
    .ascii    "Bad include file"
    .byte     0
L11120:
    .ascii    "Invalid # directive"
    .byte     0
L11119:
    .ascii    "Duplicate symbol table entry"
    .byte     0
L11118:
    .ascii    "HASHTABLE FULL"
    .byte     0
L11117:
    .ascii    "Digit out of range"
    .byte     0
L11116:
    .ascii    ".*"
    .byte     0
L11115:
    .ascii    "v"
    .byte     0
L11114:
    .ascii    ".*"
    .byte     0
L11113:
    .ascii    "v"
    .byte     0
L11112:
    .ascii    "#"
    .byte     0
L11111:
    .ascii    "'"
    .byte     0
L11110:
    .byte     34
    .byte     0
L11109:
    .ascii    " "
    .byte     0
L11108:
    .ascii    "%-18s"
    .byte     0
L11107:
    .ascii    "Line:"
    .byte     0
L11106:
    .ascii    "in:"
    .byte     0
L11105:
    .byte     10
    .ascii    "Lex error"
    .byte     0
L11104:
    .ascii    "Non-base-10 floats temporarily unavailable"
    .byte     0
L11103:
    .ascii    "p"
    .byte     0
L11102:
    .ascii    "e"
    .byte     0
L11100:
    .ascii    "Real too long"
    .byte     0
L11099:
    .ascii    "ERROR CHAR"
    .byte     0
L11098:
    .ascii    "@ SEEN"
    .byte     0
L11097:
    .ascii    "wb"
    .byte     0
L11096:
    .ascii    "#endif missing"
    .byte     0
L11095:
    .ascii    "mcc.h"
    .byte     0
L11094:
    .ascii    "23:38:20"
    .byte     0
L11093:
    .ascii    "26-Sep-2025"
    .byte     0
L11092:
    .ascii    "CC C Compiler"
    .byte     0
L11091:
    .ascii    "C Subset Compiler for 64-bit Windows"
    .byte     10
    .byte     10
    .ascii    "Normal use:           Compiles prog.c to:"
    .byte     10
    .byte     10
    .ascii    "    cc      prog      prog.exe (default)"
    .byte     10
    .ascii    "    cc -r   prog      in-memory native code then execute"
    .byte     10
    .ascii    "    cc -i   prog      in-memory IL then interpret"
    .byte     10
    .byte     10
    .ascii    "    cc -exe prog      prog.exe"
    .byte     10
    .ascii    "    cc -dll prog      prog.dll"
    .byte     10
    .ascii    "    cc -obj prog      prog.obj"
    .byte     10
    .ascii    "    cc -a   prog      prog.asm"
    .byte     10
    .ascii    "    cc -n   prog      prog.nasm"
    .byte     10
    .ascii    "    cc -mx  prog      prog.mx"
    .byte     10
    .ascii    "    cc -p   prog      prog.pcl (textual IL)"
    .byte     10
    .ascii    "    cc -e   prog      prog.i   (preprocess only)"
    .byte     10
    .byte     10
    .ascii    "Other options:"
    .byte     10
    .byte     10
    .ascii    "    -incl:path        Add path to search for includes"
    .byte     10
    .ascii    "    -ext              Used std headers external to compiler"
    .byte     10
    .ascii    "    -opt              Optimise native code"
    .byte     10
    .ascii    "    -out:file         Name output file (extension can be added)"
    .byte     10
    .ascii    "    -rip              Use RIP address modes"
    .byte     10
    .ascii    "    -himem            Generate PIC code (automatic with -obj/-dll)"
    .byte     10
    .ascii    "    @file             Read files and options from a file"
    .byte     10
    .ascii    "    file.dll          Include one or more extra dynamic libs"
    .byte     10
    .ascii    "    -c                Same as -obj"
    .byte     10
    .ascii    "    -s                Same as -asm"
    .byte     10
    .ascii    "    -ei               Same as -e, but when result is interpreted"
    .byte     10
    .byte     10
    .ascii    "Notes:"
    .byte     10
    .byte     10
    .ascii    "    * Compiles single module only (use bcc driver program for multiple-modules)"
    .byte     10
    .ascii    "    * For -i and -r, options and any .dlls must appear before the C source file"
    .byte     10
    .ascii    "    * .c extension is optional on input file"
    .byte     10
    .byte     0
L11090:
    .ascii    "Include paths"
    .byte     0
L11089:
    .ascii    "/"
    .byte     0
L11088:
    .byte     0
L11087:
    .ascii    "Too many include paths"
    .byte     0
L11086:
    .byte     0
L11085:
    .ascii    "-RUNP OUT OF ORDER"
    .byte     0
L11084:
    .ascii    "-help                Show all options"
    .byte     0
L11083:
    .ascii    "    "
    .byte     0
L11082:
    .ascii    "-i prog[.c]          Compile prog.c and interpret"
    .byte     0
L11081:
    .ascii    "    "
    .byte     0
L11080:
    .ascii    "-r prog[.c]          Compile prog.c and run"
    .byte     0
L11079:
    .ascii    "    "
    .byte     0
L11078:
    .ascii    "   prog[.c]          Compile prog.c to prog.exe"
    .byte     0
L11077:
    .ascii    "    "
    .byte     0
L11076:
    .ascii    "Usage:"
    .byte     0
L11075:
    .byte     0
L11074:
    .ascii    "Too many lib files"
    .byte     0
L11073:
    .byte     0
L11072:
    .ascii    "One input file only"
    .byte     0
L11071:
    .ascii    "Unknown option:"
    .byte     0
L11070:
    .ascii    ".c"
    .byte     0
L11069:
    .byte     0
L11068:
    .ascii    "cs.exe"
    .byte     0
L11067:
    .ascii    "Total:"
    .byte     0
L11066:
    .ascii    "-----------------------------"
    .byte     0
L11065:
    .ascii    "EXE:"
    .byte     0
L11064:
    .ascii    "SS:"
    .byte     0
L11063:
    .ascii    "MCL:"
    .byte     0
L11062:
    .ascii    "PCL:"
    .byte     0
L11061:
    .ascii    "Parse:"
    .byte     0
L11060:
    .ascii    "Load:"
    .byte     0
L11059:
    .ascii    "Init:"
    .byte     0
L11058:
    .ascii    "5.1jr"
    .byte     0
L11056:
    .ascii    "5"
    .byte     0
L11055:
    .ascii    "12jl"
    .byte     0
L11054:
    .ascii    "# # ms # %"
    .byte     0
L11053:
    .ascii    "Size:"
    .byte     0
L11052:
    .ascii    ":"
    .byte     0
L11051:
    .ascii    "Sourcefiles:"
    .byte     0
L11050:
    .ascii    "PROC"
    .byte     0
L11049:
    .ascii    "PROC AST"
    .byte     0
L11048:
    .ascii    ": ."
    .byte     0
L11047:
    .ascii    ":"
    .byte     0
L11046:
    .ascii    "0: Internal standard headers (disable with -ext)"
    .byte     0
L11045:
    .ascii    "Include search paths:"
    .byte     0
L11044:
    .ascii    "c:/cx/headers/"
    .byte     0
L11043:
    .byte     0
L11042:
    .ascii    "<line>"
    .byte     0
L11041:
    .ascii    "kernel32"
    .byte     0
L11040:
    .ascii    "user32"
    .byte     0
L11039:
    .ascii    "gdi32"
    .byte     0
L11038:
    .ascii    "msvcrt"
    .byte     0
L11037:
    .ascii    "mcc.log"
    .byte     0
L11036:
    .ascii    "Diagnostic outputs written to"
    .byte     0
L11035:
    .ascii    "cc.m"
    .byte     0
L11034:
    .ascii    "mcc.log"
    .byte     0
L11033:
    .byte     92
    .ascii    "m"
    .byte     92
    .ascii    "scripts"
    .byte     92
    .ascii    "med.bat "
    .byte     0
L11032:
    .ascii    "PRESS KEY"
    .byte     0
L11031:
    .ascii    "STFLAT"
    .byte     0
L11030:
    .ascii    "ST"
    .byte     0
L11029:
    .ascii    "PSYMTAB"
    .byte     0
L11028:
    .ascii    "!PROC PCL"
    .byte     0
L11027:
    .ascii    "PROC ASM"
    .byte     0
L11026:
    .ascii    "w"
    .byte     0
L11025:
    .ascii    "mcc.log"
    .byte     0
L11024:
    .ascii    "Can't load main module: #"
    .byte     0
L11023:
    .ascii    "$prog"
    .byte     0
L11022:
    .ascii    "<sourcefile0>"
    .byte     0
L11021:
    .ascii    "<dummy path>"
    .byte     0
L11020:
    .ascii    "<dummy file>"
    .byte     0
L11019:
    .ascii    "Loading:"
    .byte     0
L11018:
    .ascii    "Done."
    .byte     0
L11017:
    .ascii    "not ready"
    .byte     0
L11016:
    .ascii    "Compiling # to #"
    .byte     0
L11015:
    .ascii    "reloc?"
    .byte     0
L11014:
    .ascii    "rel32/rel not imported"
    .byte     0
L11013:
    .ascii    "0.1234"
    .byte     0
L11012:
    .byte     0
L11011:
    .ascii    "No entry point found"
    .byte     0
L11010:
    .ascii    "$cmdskip"
    .byte     0
L11009:
    .ascii    "msys.$cmdskip"
    .byte     0
L11008:
    .byte     0
L11007:
    .ascii    "Too many Imports"
    .byte     0
L11006:
    .byte     0
L11005:
    .ascii    "Too many DLLs"
    .byte     0
L11004:
    .ascii    "Dupl symbol:"
    .byte     0
L11003:
    .ascii    "Can't find #"
    .byte     0
L11002:
    .ascii    "ml"
    .byte     0
L11001:
    .ascii    "Loading sublib"
    .byte     0
L11000:
    .byte     0
L10999:
    .ascii    "imprel32?"
    .byte     0
L10998:
    .ascii    "Undef"
    .byte     0
L10997:
    .ascii    "Can't find DLL: #"
    .byte     0
L10996:
    .byte     0
L10995:
    .ascii    "Too many libs"
    .byte     0
L10994:
    .ascii    "Lib already exists:"
    .byte     0
L10993:
    .ascii    "Aborting"
    .byte     0
L10992:
    .byte     0
L10991:
    .ascii    "Can't alloc code memory"
    .byte     0
L10990:
    .ascii    "Unknown directive:"
    .byte     0
L10989:
    .ascii    "Bad sig - not MCX file"
    .byte     0
L10987:
    .ascii    "NO MAIN FOUND"
    .byte     0
L10986:
    .ascii    "reloc?"
    .byte     0
L10985:
    .ascii    "rel32/rel not imported"
    .byte     0
L10984:
    .ascii    "0.1234"
    .byte     0
L10982:
    .ascii    "W:too many strings"
    .byte     0
L10981:
    .ascii    ".text"
    .byte     0
L10980:
    .ascii    ".data"
    .byte     0
L10979:
    .ascii    ".bss"
    .byte     0
L10978:
    .ascii    ".file"
    .byte     0
L10977:
    .ascii    "as:Too many symbols"
    .byte     0
L10976:
    .ascii    "OBJ/phighmem 1?"
    .byte     0
L10975:
    .ascii    "wrelocs/bad seg"
    .byte     0
L10974:
    .ascii    "Writing file:"
    .byte     0
L10973:
    .ascii    ".text"
    .byte     0
L10972:
    .ascii    ".data"
    .byte     0
L10971:
    .ascii    "Too many relocs (exceeds 16-bit field)"
    .byte     0
L10970:
    .ascii    ".bss"
    .byte     0
L10969:
    .ascii    "GSN"
    .byte     0
L10968:
    .ascii    "Too many blocks"
    .byte     0
L10966:
    .ascii    "Too many exports - can't sort"
    .byte     0
L10965:
    .ascii    "Entry point not found: main"
    .byte     0
L10964:
    .ascii    "User entry point not found"
    .byte     0
L10962:
    .ascii    "Can't do this rel type"
    .byte     0
L10961:
    .ascii    "RELOCDATA/SEG?"
    .byte     0
L10960:
    .ascii    "rel32/not imported"
    .byte     0
L10959:
    .ascii    "gendll: Too many exports"
    .byte     0
L10958:
    .ascii    "genexe: Too many imports"
    .byte     0
L10957:
    .ascii    "2:Too many libs"
    .byte     0
L10956:
    .ascii    ".dll"
    .byte     0
L10955:
    .ascii    "Can't find external function"
    .byte     0
L10954:
    .ascii    "Too many libs"
    .byte     0
L10953:
    .ascii    ".dll"
    .byte     0
L10952:
    .ascii    ".idata"
    .byte     0
L10951:
    .ascii    ".bss"
    .byte     0
L10950:
    .ascii    ".data"
    .byte     0
L10949:
    .ascii    "10s,jr"
    .byte     0
L10948:
    .ascii    "Zdata size:"
    .byte     0
L10947:
    .ascii    "10s,jr"
    .byte     0
L10946:
    .ascii    "Code+Idata:"
    .byte     0
L10945:
    .ascii    "10s,jr"
    .byte     0
L10944:
    .ascii    "Idata size:"
    .byte     0
L10943:
    .ascii    "bytes"
    .byte     0
L10942:
    .ascii    "10s,jr"
    .byte     0
L10941:
    .ascii    "Code size: "
    .byte     0
L10940:
    .ascii    ".text"
    .byte     0
L10939:
    .ascii    "Can't load search lib"
    .byte     0
L10938:
    .ascii    "File:"
    .byte     0
L10937:
    .ascii    "Error writing exe file (possibly still running)"
    .byte     0
L10936:
    .ascii    "10s,jr"
    .byte     0
L10935:
    .ascii    "EXE size:  "
    .byte     0
L10934:
    .byte     0
L10933:
    .ascii    "qword ptr"
    .byte     0
L10932:
    .ascii    "dword ptr"
    .byte     0
L10931:
    .ascii    "word ptr"
    .byte     0
L10930:
    .ascii    "byte ptr"
    .byte     0
L10929:
    .byte     0
L10928:
    .ascii    "#.$T#"
    .byte     0
L10927:
    .ascii    "T"
    .byte     0
L10926:
    .ascii    "XMM"
    .byte     0
L10925:
    .ascii    "-"
    .byte     0
L10924:
    .byte     0
L10923:
    .ascii    "Stropnd?"
    .byte     0
L10922:
    .ascii    "L"
    .byte     0
L10921:
    .byte     34
    .byte     0
L10920:
    .ascii    "M"
    .byte     0
L10919:
    .ascii    "20.20"
    .byte     0
L10918:
    .byte     0
L10917:
    .ascii    "+"
    .byte     0
L10916:
    .byte     0
L10915:
    .ascii    "<BAD OPND>"
    .byte     0
L10914:
    .ascii    "BAD OPND"
    .byte     0
L10913:
    .ascii    "]"
    .byte     0
L10912:
    .ascii    " + "
    .byte     0
L10911:
    .ascii    "rip+"
    .byte     0
L10910:
    .ascii    "*"
    .byte     0
L10909:
    .ascii    " + "
    .byte     0
L10908:
    .byte     0
L10907:
    .ascii    "["
    .byte     0
L10906:
    .ascii    "H"
    .byte     0
L10905:
    .ascii    "0x"
    .byte     0
L10904:
    .ascii    ","
    .byte     0
L10903:
    .ascii    ","
    .byte     9
    .byte     0
L10902:
    .ascii    " "
    .byte     0
L10901:
    .ascii    "  "
    .byte     0
L10900:
    .ascii    " "
    .byte     0
L10899:
    .ascii    ".ascii"
    .byte     0
L10898:
    .ascii    ".quad"
    .byte     0
L10897:
    .ascii    ".long"
    .byte     0
L10896:
    .ascii    ".word"
    .byte     0
L10895:
    .ascii    ".byte"
    .byte     0
L10894:
    .ascii    ".space"
    .byte     0
L10893:
    .ascii    ".align"
    .byte     0
L10892:
    .ascii    "movsxd"
    .byte     0
L10891:
    .ascii    "imul"
    .byte     0
L10890:
    .ascii    "not"
    .byte     0
L10889:
    .ascii    "xor"
    .byte     0
L10888:
    .ascii    "or"
    .byte     0
L10887:
    .ascii    "and"
    .byte     0
L10886:
    .ascii    "cmov"
    .byte     0
L10885:
    .ascii    "set"
    .byte     0
L10884:
    .ascii    "j"
    .byte     0
L10883:
    .ascii    "    .bss"
    .byte     0
L10882:
    .ascii    "    .data"
    .byte     0
L10881:
    .ascii    "    .text"
    .byte     0
L10880:
    .ascii    ", "
    .byte     0
L10879:
    .ascii    "    .set "
    .byte     0
L10878:
    .ascii    "L#:"
    .byte     0
L10877:
    .ascii    ":"
    .byte     0
L10876:
    .byte     10
    .byte     0
L10875:
    .ascii    ":"
    .byte     0
L10874:
    .byte     0
L10873:
    .ascii    "strmcl/lab"
    .byte     0
L10872:
    .ascii    "# End "
    .byte     0
L10871:
    .ascii    "# Proc "
    .byte     0
L10870:
    .byte     10
    .byte     0
L10869:
    .ascii    "    .global "
    .byte     0
L10868:
    .byte     10
    .byte     0
L10867:
    .ascii    "    .intel_syntax noprefix"
    .byte     10
    .byte     0
L10866:
    .ascii    "# GAS VERSION"
    .byte     10
    .byte     0
L10865:
    .ascii    "PHIGHMEM="
    .byte     0
L10864:
    .ascii    "WRITE GAS"
    .byte     0
L10863:
    .ascii    "dshift/size"
    .byte     0
L10862:
    .ascii    "bswap reg>"
    .byte     0
L10861:
    .ascii    "fixrip disp?"
    .byte     0
L10860:
    .ascii    "DISPSIZE="
    .byte     0
L10859:
    .ascii    "movdq opnds"
    .byte     0
L10858:
    .ascii    "movdq mem,?"
    .byte     0
L10857:
    .ascii    "5:movdq size"
    .byte     0
L10856:
    .ascii    "movdq xreg,?"
    .byte     0
L10855:
    .ascii    "31:movdq size"
    .byte     0
L10854:
    .ascii    "3:movdq size"
    .byte     0
L10853:
    .ascii    "movdq reg,?"
    .byte     0
L10852:
    .ascii    "1:movdq size"
    .byte     0
L10851:
    .ascii    "float opnds"
    .byte     0
L10850:
    .ascii    "fix opnds"
    .byte     0
L10849:
    .ascii    "convertfloat opnds"
    .byte     0
L10848:
    .ascii    "logicxmm opnds"
    .byte     0
L10847:
    .ascii    "arithxmm opnds"
    .byte     0
L10846:
    .ascii    "Wrong size"
    .byte     0
L10845:
    .ascii    "A.SIZE="
    .byte     0
L10844:
    .ascii    "Need size"
    .byte     0
L10843:
    .ascii    "setcc opnd/size"
    .byte     0
L10842:
    .ascii    "test opnds"
    .byte     0
L10841:
    .ascii    "shift opnds2?"
    .byte     0
L10840:
    .ascii    "cl or b10 needed"
    .byte     0
L10839:
    .ascii    "shift/label"
    .byte     0
L10838:
    .ascii    "shift opnds1?"
    .byte     0
L10837:
    .ascii    "imul2 opnds"
    .byte     0
L10836:
    .ascii    "mul/label"
    .byte     0
L10835:
    .ascii    "imul2 size"
    .byte     0
L10834:
    .ascii    "imul2 byte"
    .byte     0
L10833:
    .ascii    "imul2 opnds"
    .byte     0
L10832:
    .ascii    "movsxd opnds"
    .byte     0
L10831:
    .ascii    "movsxd size"
    .byte     0
L10830:
    .ascii    "exch size"
    .byte     0
L10829:
    .ascii    "exch opnds"
    .byte     0
L10828:
    .ascii    "exch size"
    .byte     0
L10827:
    .ascii    "movsx not reg/mem"
    .byte     0
L10826:
    .ascii    "movsx size 8"
    .byte     0
L10825:
    .ascii    "movsx need size prefix"
    .byte     0
L10824:
    .ascii    "movsx 4=>8 bytes?"
    .byte     0
L10823:
    .ascii    "movsx size error"
    .byte     0
L10822:
    .ascii    "movsx not reg"
    .byte     0
L10821:
    .ascii    "LEA size error"
    .byte     0
L10820:
    .ascii    "A.SIZE="
    .byte     0
L10819:
    .ascii    "LEA not reg/mem"
    .byte     0
L10818:
    .ascii    "neg/div/etc opnd?"
    .byte     0
L10817:
    .ascii    "inc/opnd?"
    .byte     0
L10816:
    .ascii    "pop opnd?"
    .byte     0
L10815:
    .ascii    "pop not 64-bit"
    .byte     0
L10814:
    .ascii    "popreg not 64-bit"
    .byte     0
L10813:
    .ascii    "push opnd?"
    .byte     0
L10812:
    .ascii    "push not 64-bit"
    .byte     0
L10811:
    .ascii    "push imm value too large"
    .byte     0
L10810:
    .ascii    "pushreg not 64-bit"
    .byte     0
L10809:
    .ascii    "MOV ?/.."
    .byte     0
L10808:
    .ascii    "MOV MEM/?"
    .byte     0
L10807:
    .ascii    "mov imm?"
    .byte     0
L10806:
    .ascii    "3:Opnd size mismatch"
    .byte     0
L10805:
    .ascii    "MOV REG/??"
    .byte     0
L10804:
    .ascii    "1:exceeding u32 value"
    .byte     0
L10803:
    .ascii    "exceeding u16 value"
    .byte     0
L10802:
    .ascii    "exceeding byte value"
    .byte     0
L10801:
    .ascii    "mov imm?"
    .byte     0
L10800:
    .ascii    "2:Opnd size mismatch"
    .byte     0
L10799:
    .ascii    "1:Can't add to this opnd"
    .byte     0
L10798:
    .ascii    "CODE="
    .byte     0
L10797:
    .ascii    "ADD mem,???"
    .byte     0
L10796:
    .ascii    "ADD reg,???"
    .byte     0
L10795:
    .ascii    "Exceeding i8/u8 range"
    .byte     0
L10794:
    .ascii    "add imm/size"
    .byte     0
L10793:
    .ascii    "Addr32 can't use RIP, line"
    .byte     0
L10792:
    .ascii    "Can't scale rstack"
    .byte     0
L10791:
    .ascii    "Scaled rstack?"
    .byte     0
L10790:
    .ascii    "genrm not mem"
    .byte     0
L10789:
    .ascii    "2:exceeding u32 value"
    .byte     0
L10788:
    .ascii    "exceeding u16 value"
    .byte     0
L10787:
    .ascii    "exceeding byte value"
    .byte     0
L10786:
    .ascii    "dbuffer error"
    .byte     0
L10785:
    .ascii    "l#"
    .byte     0
L10784:
    .ascii    "bsf size"
    .byte     0
L10783:
    .ascii    "genrel8"
    .byte     0
L10782:
    .ascii    "fmem int size"
    .byte     0
L10781:
    .ascii    "fst i64?"
    .byte     0
L10780:
    .ascii    "fmem size"
    .byte     0
L10779:
    .ascii    "SIZE="
    .byte     0
L10778:
    .ascii    "r80 not allowed"
    .byte     0
L10777:
    .ascii    "fmem/not mem"
    .byte     0
L10776:
    .ascii    "cmov/byte"
    .byte     0
L10775:
    .ascii    "1:Opnd size mismatch"
    .byte     0
L10774:
    .ascii    "jmp[]size"
    .byte     0
L10773:
    .ascii    "call[]size"
    .byte     0
L10772:
    .ascii    "Can't do jcxz fwd jump"
    .byte     0
L10771:
    .ascii    "jcxz jmp out of range"
    .byte     0
L10770:
    .ascii    "Can't do loopxx fwd jump"
    .byte     0
L10769:
    .ascii    "loop jmp out of range"
    .byte     0
L10768:
    .ascii    "Operand size not set"
    .byte     0
L10767:
    .ascii    "genamode size 2/8"
    .byte     0
L10766:
    .ascii    "GENAMODE/MODE?"
    .byte     0
L10765:
    .ascii    "genam/3"
    .byte     0
L10764:
    .ascii    "DOFWDREFS/CAN'T DO RELTYPE"
    .byte     0
L10763:
    .ascii    "Fwd ref in zdata"
    .byte     0
L10762:
    .ascii    "Rel label across segments2"
    .byte     0
L10761:
    .ascii    "getdef/no def"
    .byte     0
L10760:
    .ascii    "Rel label across segments"
    .byte     0
L10759:
    .ascii    "OPND/8/VALTYPE?"
    .byte     0
L10758:
    .ascii    "OPND/4/VALTYPE?"
    .byte     0
L10757:
    .ascii    "8/16-BIT RELOC"
    .byte     0
L10756:
    .ascii    "GENSS/NAME OPND"
    .byte     0
L10755:
    .ascii    "STOPPING"
    .byte     0
L10754:
    .ascii    "M_HALT="
    .byte     0
L10753:
    .ascii    "M.OPCODE="
    .byte     0
L10752:
    .ascii    "line"
    .byte     0
L10751:
    .ascii    "*** Can't do opcode"
    .byte     0
L10750:
    .ascii    "align?"
    .byte     0
L10749:
    .ascii    "align2"
    .byte     0
L10748:
    .ascii    "resb?"
    .byte     0
L10747:
    .ascii    "retn?"
    .byte     0
L10746:
    .ascii    "Zdata contains code or data"
    .byte     0
L10745:
    .byte     0
L10744:
    .ascii    "delmcl?"
    .byte     0
L10743:
    .ascii    " ncalldepth:"
    .byte     0
L10742:
    .ascii    " noperands:"
    .byte     0
L10741:
    .ascii    ") hwstack:"
    .byte     0
L10740:
    .ascii    "0 "
    .byte     0
L10739:
    .ascii    "1 "
    .byte     0
L10738:
    .ascii    "XWR:("
    .byte     0
L10737:
    .ascii    ") "
    .byte     0
L10736:
    .ascii    "0 "
    .byte     0
L10735:
    .ascii    "1 "
    .byte     0
L10734:
    .ascii    "WR:("
    .byte     0
L10733:
    .ascii    " "
    .byte     0
L10732:
    .ascii    ") "
    .byte     0
L10731:
    .ascii    ", "
    .byte     0
L10730:
    .ascii    ">"
    .byte     0
L10729:
    .ascii    "<"
    .byte     0
L10728:
    .ascii    "@"
    .byte     0
L10727:
    .ascii    ")"
    .byte     0
L10726:
    .ascii    "(=="
    .byte     0
L10725:
    .ascii    "T"
    .byte     0
L10724:
    .ascii    "*"
    .byte     0
L10723:
    .byte     0
L10722:
    .ascii    "W:"
    .byte     0
L10721:
    .ascii    "X:"
    .byte     0
L10720:
    .ascii    "Y:"
    .byte     0
L10719:
    .ascii    "Z:"
    .byte     0
L10718:
    .ascii    "#:("
    .byte     0
L10717:
    .ascii    "========================================#:("
    .byte     0
L10716:
    .byte     0
L10715:
    .ascii    "MSA"
    .byte     0
L10714:
    .byte     0
L10713:
    .ascii    "makeopndind"
    .byte     0
L10712:
    .byte     0
L10711:
    .ascii    "SOR1"
    .byte     0
L10710:
    .byte     0
L10709:
    .ascii    "MOVE TO REG: XREG IN USE"
    .byte     0
L10708:
    .byte     0
L10707:
    .ascii    "No more work xregs"
    .byte     0
L10706:
    .byte     0
L10705:
    .ascii    "No more work regs"
    .byte     0
L10704:
    .byte     0
L10703:
    .ascii    "poppcl/underflow"
    .byte     0
L10702:
    .byte     0
L10701:
    .ascii    "PCL stack overflow"
    .byte     0
L10700:
    .byte     0
L10699:
    .ascii    "PCL stack overflow"
    .byte     0
L10698:
    .ascii    "getopnd"
    .byte     0
L10697:
    .byte     0
L10696:
    .ascii    "Ext nametab overflow"
    .byte     0
L10695:
    .ascii    "$B#"
    .byte     0
L10694:
    .byte     0
L10693:
    .ascii    "Too many block temps"
    .byte     0
L10692:
    .ascii    "Line:"
    .byte     0
L10691:
    .ascii    "AX ERROR:"
    .byte     0
L10690:
    .ascii    "MCL Opnd not supported: # (#) [#]"
    .byte     0
L10689:
    .byte     0
L10688:
    .ascii    "2:SIZE=0"
    .byte     0
L10687:
    .byte     0
L10686:
    .ascii    "1:SIZE=0"
    .byte     0
L10685:
    .byte     0
L10684:
    .ascii    "BAD SEG CODE"
    .byte     0
L10683:
    .byte     0
L10682:
    .ascii    "CAN'T DO RODATA SEG"
    .byte     0
L10681:
    .ascii    "MCLREC>64B"
    .byte     0
L10680:
    .ascii    "__getmainargs*"
    .byte     0
L10679:
    .ascii    "$info"
    .byte     0
L10678:
    .ascii    "$env"
    .byte     0
L10677:
    .ascii    "()"
    .byte     0
L10676:
    .ascii    "High block arg not copied in"
    .byte     0
L10675:
    .ascii    "No host fn:"
    .byte     0
L10674:
    .ascii    "gethostfn?"
    .byte     0
L10673:
    .ascii    "msysc.m$power_i64"
    .byte     0
L10672:
    .ascii    "msys.m$power_i64"
    .byte     0
L10671:
    .byte     0
L10670:
    .ascii    "storebf not imm"
    .byte     0
L10669:
    .byte     0
L10668:
    .ascii    "Storebit: both vars"
    .byte     0
L10667:
    .byte     0
L10666:
    .ascii    "STOREBIT/VAR"
    .byte     0
L10665:
    .byte     0
L10664:
    .ascii    "LOADBF_VAR"
    .byte     0
L10663:
    .ascii    "mask63/offset64"
    .byte     0
L10662:
    .ascii    "labzero"
    .byte     0
L10661:
    .ascii    "labneg64"
    .byte     0
L10660:
    .ascii    "labneg32"
    .byte     0
L10659:
    .ascii    "lababs64"
    .byte     0
L10658:
    .ascii    "lababs32"
    .byte     0
L10656:
    .ascii    "Real32 Table"
    .byte     0
L10654:
    .ascii    "Real Table"
    .byte     0
L10653:
    .ascii    "String Table"
    .byte     0
L10652:
    .ascii    "ENDDATA"
    .byte     0
L10651:
    .byte     0
L10650:
    .ascii    "div/u8"
    .byte     0
L10649:
    .byte     0
L10648:
    .ascii    "Divide by zero"
    .byte     0
L10647:
    .ascii    "---------------"
    .byte     0
L10646:
    .ascii    "?]]"
    .byte     0
L10645:
    .byte     0
L10644:
    .ascii    "Threaded proc has temps"
    .byte     0
L10643:
    .byte     0
L10642:
    .ascii    "Threaded proc has locals/params"
    .byte     0
L10641:
    .byte     0
L10640:
    .ascii    "@PARAM"
    .byte     0
L10639:
    .ascii    "$1x"
    .byte     0
L10637:
    .byte     0
L10636:
    .ascii    "SUBTOREF/EXTRA"
    .byte     0
L10635:
    .ascii    "pow*"
    .byte     0
L10634:
    .byte     0
L10633:
    .ascii    "setcc/block"
    .byte     0
L10632:
    .ascii    "fmod*"
    .byte     0
L10631:
    .ascii    "atan2*"
    .byte     0
L10630:
    .ascii    "ceil*"
    .byte     0
L10629:
    .ascii    "floor*"
    .byte     0
L10628:
    .ascii    "round*"
    .byte     0
L10627:
    .ascii    "exp*"
    .byte     0
L10626:
    .ascii    "log10*"
    .byte     0
L10625:
    .ascii    "log*"
    .byte     0
L10624:
    .ascii    "atan*"
    .byte     0
L10623:
    .ascii    "acos*"
    .byte     0
L10622:
    .ascii    "asin*"
    .byte     0
L10621:
    .ascii    "tan*"
    .byte     0
L10620:
    .ascii    "cos*"
    .byte     0
L10619:
    .ascii    "sin*"
    .byte     0
L10618:
    .byte     0
L10617:
    .ascii    "No Assem handler"
    .byte     0
L10616:
    .byte     0
L10615:
    .ascii    "SUB/REF NOT POWER OF xx"
    .byte     0
L10614:
    .byte     0
L10613:
    .ascii    "float/short"
    .byte     0
L10612:
    .byte     0
L10611:
    .ascii    "multo/byte"
    .byte     0
L10610:
    .ascii    ":"
    .byte     0
L10609:
    .byte     0
L10608:
    .ascii    "swap/block"
    .byte     0
L10607:
    .byte     0
L10606:
    .ascii    "SUBREF/EXTRA"
    .byte     0
L10605:
    .ascii    "EXTRA="
    .byte     0
L10604:
    .byte     0
L10603:
    .ascii    "Storem not 16"
    .byte     0
L10602:
    .ascii    "exit*"
    .byte     0
L10601:
    .byte     0
L10600:
    .ascii    "Too many nested calls"
    .byte     0
L10599:
    .ascii    "---"
    .byte     0
L10598:
    .byte     0
L10597:
    .ascii    "JUMPCC/BLOCK"
    .byte     0
L10596:
    .byte     0
L10595:
    .ascii    "DATA/not 1248"
    .byte     0
L10594:
    .ascii    "STRPMODE(P.MODE)="
    .byte     0
L10593:
    .ascii    "P.SIZE="
    .byte     0
L10592:
    .ascii    "db/dq optype? #"
    .byte     0
L10591:
    .ascii    "PCL STACK NOT EMPTY"
    .byte     0
L10590:
    .ascii    "PROC4"
    .byte     0
L10589:
    .ascii    "PROC3"
    .byte     0
L10588:
    .ascii    "?>>"
    .byte     0
L10587:
    .ascii    "PROC2"
    .byte     0
L10586:
    .ascii    "PROC1"
    .byte     0
L10585:
    .ascii    "Unimpl: # (#)"
    .byte     0
L10584:
    .ascii    "                       "
    .byte     0
L10583:
    .ascii    "Invalid handler name:"
    .byte     0
L10582:
    .ascii    "px_"
    .byte     0
L10581:
    .ascii    "MCL1"
    .byte     0
L10580:
    .ascii    "********* ASM HAS PCL INFO *********"
    .byte     0
L10579:
    .ascii    "$cmdskip"
    .byte     0
L10578:
    .ascii    "Can't load lib:"
    .byte     0
L10577:
    .ascii    "Can't find DLL func:"
    .byte     0
L10576:
    .ascii    "in"
    .byte     0
L10575:
    .ascii    "Unsupported operand:"
    .byte     0
L10574:
    .ascii    "seq:"
    .byte     0
L10573:
    .ascii    "PC Exec error:"
    .byte     0
L10572:
    .byte     0
L10571:
    .ascii    "Not mem"
    .byte     0
L10570:
    .ascii    "Null ptr access"
    .byte     0
L10569:
    .ascii    "Stopped"
    .byte     0
L10568:
    .ascii    "Run PCL:"
    .byte     0
L10567:
    .byte     0
L10566:
    .ascii    "No 'main' entry point"
    .byte     0
L10565:
    .byte     0
L10564:
    .ascii    "data &mem = nil"
    .byte     0
L10563:
    .byte     0
L10562:
    .ascii    "data &mem"
    .byte     0
L10561:
    .byte     0
L10560:
    .ascii    "FIX/DATA/MEM"
    .byte     0
L10559:
    .ascii    "Unimpl: # at seq: #"
    .byte     0
L10558:
    .ascii    "GETOPCODE="
    .byte     0
L10557:
    .ascii    "# Enter:  # SP=# FP=#"
    .byte     0
L10556:
    .ascii    "  "
    .byte     0
L10538:
    .byte     0
L10537:
    .ascii    "swap/block"
    .byte     0
L10536:
    .byte     0
L10535:
    .ascii    "setcc/r32"
    .byte     0
L10534:
    .byte     0
L10533:
    .ascii    "setcc/r64"
    .byte     0
L10532:
    .byte     0
L10531:
    .ascii    "ICALLF NIL PTR"
    .byte     0
L10530:
    .byte     0
L10529:
    .ascii    "ICALLP NIL PTR"
    .byte     0
L10528:
    .byte     0
L10527:
    .ascii    "RETF/SP mismatch: old=# curr=# "
    .byte     0
L10526:
    .byte     0
L10525:
    .ascii    "ref/call underflow"
    .byte     0
L10524:
    .byte     0
L10523:
    .ascii    "RETP/SP mismatch: old=# curr=# "
    .byte     0
L10522:
    .byte     0
L10521:
    .ascii    "retp/call underflow"
    .byte     0
L10520:
    .ascii    "Proc not defined:"
    .byte     0
L10519:
    .byte     0
L10518:
    .ascii    "Stack overflow"
    .byte     0
L10517:
    .ascii    "# Call:   # # SP=# FP=#"
    .byte     0
L10516:
    .ascii    "  "
    .byte     0
L10515:
    .ascii    "<Fn ptr>"
    .byte     0
L10514:
    .ascii    "  Loc: # used:#, addrof:#"
    .byte     0
L10513:
    .ascii    "  Pm: # used:#, addrof:#"
    .byte     0
L10512:
    .ascii    "  Hasblocks:#"
    .byte     0
L10511:
    .ascii    "  MCLdone:  #"
    .byte     0
L10510:
    .ascii    "  Assem:    #"
    .byte     0
L10509:
    .ascii    "  Nmaxargs: #"
    .byte     0
L10508:
    .ascii    "  Leaf:     #"
    .byte     0
L10507:
    .ascii    "  Locals:   #"
    .byte     0
L10506:
    .ascii    "  Params:   #"
    .byte     0
L10505:
    .ascii    "PROC INFO FOR: #"
    .byte     0
L10504:
    .ascii    " Has statics"
    .byte     0
L10503:
    .ascii    ")"
    .byte     0
L10502:
    .ascii    "H"
    .byte     0
L10501:
    .ascii    ") (D:"
    .byte     0
L10500:
    .ascii    " (Proc:"
    .byte     0
L10499:
    .ascii    ")"
    .byte     0
L10498:
    .ascii    " "
    .byte     0
L10497:
    .ascii    " ("
    .byte     0
L10496:
    .ascii    "H"
    .byte     0
L10495:
    .ascii    " .PCADDR ="
    .byte     0
L10494:
    .ascii    " ENTRY PT"
    .byte     0
L10493:
    .ascii    " Dot"
    .byte     0
L10492:
    .ascii    " TC"
    .byte     0
L10491:
    .ascii    " Var:"
    .byte     0
L10490:
    .ascii    " Imp"
    .byte     0
L10489:
    .ascii    " Exp"
    .byte     0
L10488:
    .ascii    " Loc:"
    .byte     0
L10487:
    .ascii    " Pm:"
    .byte     0
L10486:
    .ascii    " "
    .byte     0
L10485:
    .ascii    "4"
    .byte     0
L10484:
    .ascii    "21jl"
    .byte     0
L10483:
    .ascii    "    "
    .byte     0
L10482:
    .ascii    "21jl"
    .byte     0
L10481:
    .ascii    "    "
    .byte     0
L10480:
    .ascii    "25jl"
    .byte     0
L10479:
    .ascii    " "
    .byte     0
L10478:
    .ascii    "H"
    .byte     0
L10477:
    .ascii    "PROC PC Symbol table"
    .byte     0
L10476:
    .ascii    " "
    .byte     0
L10475:
    .ascii    "  "
    .byte     0
L10474:
    .ascii    "    data mem:"
    .byte     0
L10473:
    .ascii    " "
    .byte     0
L10472:
    .ascii    ":"
    .byte     0
L10471:
    .ascii    "#"
    .byte     0
L10470:
    .ascii    " "
    .byte     0
L10469:
    .byte     10
    .byte     0
L10468:
    .ascii    " 1"
    .byte     0
L10467:
    .ascii    "extproc    "
    .byte     0
L10466:
    .byte     34
    .byte     0
L10465:
    .ascii    "addlib    "
    .byte     34
    .byte     0
L10464:
    .ascii    "!PROC PCL"
    .byte     0
L10463:
    .ascii    "<BIGSTR>"
    .byte     0
L10462:
    .ascii    "<PCLOPND?>"
    .byte     0
L10461:
    .ascii    "---------"
    .byte     0
L10460:
    .ascii    "<Data * # (#)>"
    .byte     0
L10459:
    .byte     0
L10458:
    .ascii    "#"
    .byte     0
L10457:
    .ascii    "## "
    .byte     0
L10456:
    .ascii    "&"
    .byte     0
L10455:
    .ascii    ":"
    .byte     0
L10454:
    .byte     34
    .byte     0
L10453:
    .ascii    "e16.16"
    .byte     0
L10452:
    .ascii    "infinity"
    .byte     0
L10450:
    .byte     0
L10449:
    .ascii    " "
    .byte     0
L10448:
    .ascii    "/"
    .byte     0
L10447:
    .ascii    " "
    .byte     0
L10446:
    .ascii    "/"
    .byte     0
L10445:
    .ascii    "set"
    .byte     0
L10444:
    .ascii    "jump"
    .byte     0
L10443:
    .ascii    "    "
    .byte     0
L10442:
    .ascii    "endprog"
    .byte     0
L10441:
    .ascii    "endproc"
    .byte     0
L10440:
    .ascii    "    variadic"
    .byte     0
L10439:
    .ascii    "    rettype  "
    .byte     0
L10438:
    .ascii    "       "
    .byte     0
L10437:
    .ascii    "    local    "
    .byte     0
L10436:
    .ascii    "       "
    .byte     0
L10435:
    .ascii    "    param    "
    .byte     0
L10434:
    .ascii    ":"
    .byte     0
L10433:
    .ascii    "::"
    .byte     0
L10432:
    .ascii    " "
    .byte     0
L10431:
    .ascii    "proc"
    .byte     0
L10430:
    .ascii    "tcproc"
    .byte     0
L10429:
    .ascii    "! - - -"
    .byte     0
L10428:
    .ascii    "!"
    .byte     0
L10427:
    .ascii    ":"
    .byte     0
L10426:
    .ascii    "! "
    .byte     0
L10425:
    .ascii    " NOT USED"
    .byte     0
L10424:
    .ascii    "z2h"
    .byte     0
L10422:
    .ascii    "MCL Error: # (#) on Line: # in #, PCL:#"
    .byte     0
L10421:
    .ascii    "Proc:"
    .byte     0
L10420:
    .ascii    "?"
    .byte     0
L10419:
    .ascii    "FILENAME="
    .byte     0
L10418:
    .ascii    "LINENO="
    .byte     0
L10417:
    .ascii    "No proc"
    .byte     0
L10416:
    .ascii    "Dupl proc:"
    .byte     0
L10415:
    .ascii    "Nested proc"
    .byte     0
L10414:
    .byte     0
L10413:
    .ascii    "Too many libs"
    .byte     0
L10412:
    .ascii    "w"
    .byte     0
L10411:
    .ascii    "$error.tmp"
    .byte     0
L10410:
    .ascii    "."
    .byte     0
L10409:
    .ascii    "*"
    .byte     0
L10408:
    .ascii    "`"
    .byte     0
L10407:
    .ascii    "PCL Error:"
    .byte     0
L10406:
    .ascii    ":"
    .byte     0
L10405:
    .ascii    "PCL error:"
    .byte     0
L10404:
    .ascii    "---"
    .byte     0
L10403:
    .ascii    "mem:"
    .byte     0
L10402:
    .byte     0
L10401:
    .ascii    "dummy"
    .byte     0
L10400:
    .ascii    "PHIGHMEM="
    .byte     0
L10399:
    .ascii    "w"
    .byte     0
L10398:
    .ascii    "Writing"
    .byte     0
L10397:
    .ascii    "w"
    .byte     0
L10396:
    .byte     0
L10395:
    .ascii    "Writing PST"
    .byte     0
L10394:
    .byte     0
L10393:
    .ascii    "Writing PCL"
    .byte     0
L10392:
    .ascii    "PCL start?"
    .byte     0
L10391:
    .ascii    "C:@@@@"
    .byte     92
    .ascii    "m"
    .byte     92
    .byte     34
    .byte     0
L10390:
    .ascii    "wb"
    .byte     0
L10389:
    .ascii    "con"
    .byte     0
L10388:
    .ascii    "rb"
    .byte     0
L10387:
    .ascii    "con"
    .byte     0
L10386:
    .ascii    "W64"
    .byte     0
L10385:
    .ascii    "Regclass error: %lld %lld"
    .byte     10
    .byte     0
L10383:
    .ascii    "pcc001"
    .byte     0
L10381:
    .ascii    "Winexec error: %lld"
    .byte     10
    .byte     0
L10376:
    .ascii    "@file item too long"
    .byte     0
L10375:
    .ascii    "Unexpected EOF in @file"
    .byte     0
L10374:
    .ascii    "mcx"
    .byte     0
L10373:
    .ascii    "dll"
    .byte     0
L10372:
    .ascii    "Can't open"
    .byte     0
L10371:
    .byte     13
    .byte     0
L10370:
    .byte     10
    .byte     0
L10369:
    .ascii    " "
    .byte     0
L10368:
    .byte     0
L10367:
    .ascii    "."
    .byte     0
L10366:
    .byte     0
L10365:
    .ascii    "."
    .byte     0
L10364:
    .ascii    "line too long"
    .byte     0
L10363:
    .ascii    "rb"
    .byte     0
L10362:
    .ascii    "wb"
    .byte     0
L10361:
    .ascii    "rb"
    .byte     0
L10360:
    .ascii    "ABORTING: Press key..."
    .byte     0
L10359:
    .ascii    "Realloc mem failure"
    .byte     0
L10358:
    .ascii    "Alloc mem failure"
    .byte     0
L10357:
    .ascii    "Can't alloc pc heap"
    .byte     0
L10356:
    .ascii    "pcm_alloc failure"
    .byte     0
L10355:
    .ascii    "%.*s"
    .byte     0
L10354:
    .ascii    "MCL-UNIMPL: %s"
    .byte     10
    .byte     0
L10352:
    .ascii    "%lf%n"
    .byte     0
L10350:
    .ascii    "READ CMDLINE"
    .byte     0
L10348:
    .ascii    "<mindint>"
    .byte     0
L10347:
    .ascii    "1000000000000000000000000000000000000000000000000000000000000000"
    .byte     0
L10346:
    .ascii    "8000000000000000"
    .byte     0
L10345:
    .ascii    "9223372036854775808"
    .byte     0
L10344:
    .ascii    "|"
    .byte     0
L10343:
    .ascii    "%.*s"
    .byte     0
L10342:
    .ascii    " "
    .byte     0
L10341:
    .byte     13
    .byte     10
    .byte     0
L10340:
    .ascii    "PRTSL"
    .byte     0
L10339:
    .ascii    "<null>"
    .byte     0
L10338:
    .ascii    "%f"
    .byte     0
L10337:
    .ascii    "%llu"
    .byte     0
L10336:
    .ascii    "False"
    .byte     0
L10335:
    .ascii    "True"
    .byte     0
L10334:
    .ascii    "z8H"
    .byte     0
L10333:
    .ascii    "Too many io levels"
    .byte     10
    .byte     0
L10332:
    .ascii    "Too many params"
    .byte     10
    .byte     0
L10331:
    .ascii    "windowsx.h"
    .byte     0
L10330:
    .ascii    "_mingw.h"
    .byte     0
L10329:
    .ascii    "winsock2.h"
    .byte     0
L10328:
    .ascii    "conio.h"
    .byte     0
L10327:
    .ascii    "memory.h"
    .byte     0
L10326:
    .ascii    "process.h"
    .byte     0
L10325:
    .ascii    "direct.h"
    .byte     0
L10324:
    .ascii    "io.h"
    .byte     0
L10323:
    .ascii    "fcntl.h"
    .byte     0
L10322:
    .ascii    "malloc.h"
    .byte     0
L10321:
    .ascii    "sys/utime.h"
    .byte     0
L10320:
    .ascii    "sys/timeb.h"
    .byte     0
L10319:
    .ascii    "sys/stat.h"
    .byte     0
L10318:
    .ascii    "sys/types.h"
    .byte     0
L10317:
    .ascii    "wctype.h"
    .byte     0
L10316:
    .ascii    "wchar.h"
    .byte     0
L10315:
    .ascii    "safelib.h"
    .byte     0
L10314:
    .ascii    "unistd.h"
    .byte     0
L10313:
    .ascii    "utime.h"
    .byte     0
L10312:
    .ascii    "time.h"
    .byte     0
L10311:
    .ascii    "string.h"
    .byte     0
L10310:
    .ascii    "_syslist.h"
    .byte     0
L10309:
    .ascii    "stdlib.h"
    .byte     0
L10308:
    .ascii    "stdio.h"
    .byte     0
L10307:
    .ascii    "stddef.h"
    .byte     0
L10306:
    .ascii    "stdbool.h"
    .byte     0
L10305:
    .ascii    "stdarg.h"
    .byte     0
L10304:
    .ascii    "signal.h"
    .byte     0
L10303:
    .ascii    "setjmp.h"
    .byte     0
L10302:
    .ascii    "math.h"
    .byte     0
L10301:
    .ascii    "_ansi.h"
    .byte     0
L10300:
    .ascii    "locale.h"
    .byte     0
L10299:
    .ascii    "limits.h"
    .byte     0
L10298:
    .ascii    "stdint.h"
    .byte     0
L10297:
    .ascii    "inttypes.h"
    .byte     0
L10296:
    .ascii    "float.h"
    .byte     0
L10295:
    .ascii    "fenv.h"
    .byte     0
L10294:
    .ascii    "errno.h"
    .byte     0
L10293:
    .ascii    "ctype.h"
    .byte     0
L10292:
    .ascii    "assert.h"
    .byte     0
L10291:
    .ascii    "/* Header windowsx.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $windowsx"
    .byte     13
    .byte     10
    .ascii    "#define $windowsx 1"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))"
    .byte     13
    .byte     10
    .ascii    "#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif // windowsx"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L10290:
    .ascii    "/*"
    .byte     13
    .byte     10
    .ascii    " * _mingw.h"
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  This file is for TinyCC and not part of the Mingw32 package."
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  THIS SOFTWARE IS NOT COPYRIGHTED"
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  This source code is offered for use in the public domain. You may"
    .byte     13
    .byte     10
    .ascii    " *  use, modify or distribute it freely."
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " *  This code is distributed in the hope that it will be useful but"
    .byte     13
    .byte     10
    .ascii    " *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY"
    .byte     13
    .byte     10
    .ascii    " *  DISCLAIMED. This includes but is not limited to warranties of"
    .byte     13
    .byte     10
    .ascii    " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
    .byte     13
    .byte     10
    .ascii    " *"
    .byte     13
    .byte     10
    .ascii    " */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef __MINGW_H"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_H"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* some winapi files define these before including _mingw.h --> */"
    .byte     13
    .byte     10
    .ascii    "#undef __cdecl"
    .byte     13
    .byte     10
    .ascii    "#undef _X86_"
    .byte     13
    .byte     10
    .ascii    "#undef WIN32"
    .byte     13
    .byte     10
    .ascii    "/* <-- */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .ascii    "#include <stdarg.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __int8 char"
    .byte     13
    .byte     10
    .ascii    "#define __int16 short"
    .byte     13
    .byte     10
    .ascii    "#define __int32 int"
    .byte     13
    .byte     10
    .ascii    "#define __int64 long long"
    .byte     13
    .byte     10
    .ascii    "#define _HAVE_INT64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __cdecl"
    .byte     13
    .byte     10
    .ascii    "#define __declspec(x) __attribute__((x))"
    .byte     13
    .byte     10
    .ascii    "#define __unaligned __attribute__((packed))"
    .byte     13
    .byte     10
    .ascii    "#define __fastcall __attribute__((fastcall))"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __MSVCRT__ 1"
    .byte     13
    .byte     10
    .ascii    "#undef _MSVCRT_"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_IMPORT extern __declspec(dllimport)"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_NORETURN"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_CONST"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_DEPRECATED"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_MALLOC"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_PURE"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_ATTRIB_NONNULL(arg)"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_NOTHROW"
    .byte     13
    .byte     10
    .ascii    "#define __GNUC_VA_LIST"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _CRTIMP extern"
    .byte     13
    .byte     10
    .ascii    "#define __CRT_INLINE extern __inline__"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _CRT_ALIGN(x) __attribute__((aligned(x)))"
    .byte     13
    .byte     10
    .ascii    "#define DECLSPEC_ALIGN(x) __attribute__((aligned(x)))"
    .byte     13
    .byte     10
    .ascii    "#define _CRT_PACKING 8"
    .byte     13
    .byte     10
    .ascii    "#define __CRT_UNALIGNED"
    .byte     13
    .byte     10
    .ascii    "#define _CONST_RETURN"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TRUNCATE"
    .byte     13
    .byte     10
    .ascii    "#define _TRUNCATE ((size_t)-1)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __CRT_STRINGIZE(_Value) #_Value"
    .byte     13
    .byte     10
    .ascii    "#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)"
    .byte     13
    .byte     10
    .ascii    "#define __CRT_WIDE(_String) L ## _String"
    .byte     13
    .byte     10
    .ascii    "#define _CRT_WIDE(_String) __CRT_WIDE(_String)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifdef _WIN64"
    .byte     13
    .byte     10
    .ascii    "#define __stdcall"
    .byte     13
    .byte     10
    .ascii    "#define _AMD64_ 1"
    .byte     13
    .byte     10
    .ascii    "#define __x86_64 1"
    .byte     13
    .byte     10
    .ascii    "#define _M_X64 100 /* Visual Studio */"
    .byte     13
    .byte     10
    .ascii    "#define _M_AMD64 100 /* Visual Studio */"
    .byte     13
    .byte     10
    .ascii    "#define USE_MINGW_SETJMP_TWO_ARGS"
    .byte     13
    .byte     10
    .ascii    "#define mingw_getsp tinyc_getbp"
    .byte     13
    .byte     10
    .ascii    "#define __TRY__"
    .byte     13
    .byte     10
    .ascii    "#else"
    .byte     13
    .byte     10
    .ascii    "#define __stdcall __attribute__((__stdcall__))"
    .byte     13
    .byte     10
    .ascii    "#define _X86_ 1"
    .byte     13
    .byte     10
    .ascii    "#define _M_IX86 300 /* Visual Studio */"
    .byte     13
    .byte     10
    .ascii    "#define WIN32 1"
    .byte     13
    .byte     10
    .ascii    "#define _USE_32BIT_TIME_T"
    .byte     13
    .byte     10
    .ascii    "#ifdef __arm__"
    .byte     13
    .byte     10
    .ascii    "#define __TRY__"
    .byte     13
    .byte     10
    .ascii    "#else"
    .byte     13
    .byte     10
    .ascii    "#define __TRY__ void __try__(void**), *_sehrec[6]; __try__(_sehrec);"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* in stddef.h */"
    .byte     13
    .byte     10
    .ascii    "#define _SIZE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _SSIZE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _PTRDIFF_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _WCHAR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _UINTPTR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _INTPTR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _INTEGRAL_MAX_BITS 64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME32_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME32_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef long __time32_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME64_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME64_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef long long __time64_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#ifdef _USE_32BIT_TIME_T"
    .byte     13
    .byte     10
    .ascii    "typedef __time32_t time_t;"
    .byte     13
    .byte     10
    .ascii    "#else"
    .byte     13
    .byte     10
    .ascii    "typedef __time64_t time_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _WCTYPE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _WCTYPE_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef wchar_t wctype_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _WINT_T"
    .byte     13
    .byte     10
    .ascii    "#define _WINT_T"
    .byte     13
    .byte     10
    .ascii    "typedef short wint_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef int errno_t;"
    .byte     13
    .byte     10
    .ascii    "#define _ERRCODE_DEFINED"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef struct threadlocaleinfostruct *pthreadlocinfo;"
    .byte     13
    .byte     10
    .ascii    "typedef struct threadmbcinfostruct *pthreadmbcinfo;"
    .byte     13
    .byte     10
    .ascii    "typedef struct localeinfo_struct _locale_tstruct,*_locale_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* for winapi */"
    .byte     13
    .byte     10
    .ascii    "#define _ANONYMOUS_UNION"
    .byte     13
    .byte     10
    .ascii    "#define _ANONYMOUS_STRUCT"
    .byte     13
    .byte     10
    .ascii    "#define DECLSPEC_NORETURN"
    .byte     13
    .byte     10
    .ascii    "#define DECLARE_STDCALL_P(type) __stdcall type"
    .byte     13
    .byte     10
    .ascii    "#define NOSERVICE 1"
    .byte     13
    .byte     10
    .ascii    "#define NOMCX 1"
    .byte     13
    .byte     10
    .ascii    "#define NOIME 1"
    .byte     13
    .byte     10
    .ascii    "#define __INTRIN_H_"
    .byte     13
    .byte     10
    .ascii    "#ifndef DUMMYUNIONNAME"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME1"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME2"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME3"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME4"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYUNIONNAME5"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#ifndef DUMMYSTRUCTNAME"
    .byte     13
    .byte     10
    .ascii    "#  define DUMMYSTRUCTNAME"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#ifndef WINVER"
    .byte     13
    .byte     10
    .ascii    "# define WINVER 0x0502"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .ascii    "#ifndef _WIN32_WINNT"
    .byte     13
    .byte     10
    .ascii    "# define _WIN32_WINNT 0x502"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define __C89_NAMELESS"
    .byte     13
    .byte     10
    .ascii    "#define __MINGW_EXTENSION"
    .byte     13
    .byte     10
    .ascii    "#define WINAPI_FAMILY_PARTITION(X) 1"
    .byte     13
    .byte     10
    .ascii    "#define MINGW_HAS_SECURE_API"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif /* __MINGW_H */"
    .byte     13
    .byte     10
    .byte     0
L10289:
    .ascii    "#ifndef _WINSOCK2_H"
    .byte     13
    .byte     10
    .ascii    "#define _WINSOCK2_H"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <_mingw.h>"
    .byte     13
    .byte     10
    .ascii    "#include <windows.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_SETSIZE"
    .byte     13
    .byte     10
    .ascii    "#define FD_SETSIZE 64"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int SOCKET;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef struct fd_set {"
    .byte     13
    .byte     10
    .ascii    "  unsigned int   fd_count;"
    .byte     13
    .byte     10
    .ascii    "  SOCKET  fd_array[FD_SETSIZE];"
    .byte     13
    .byte     10
    .ascii    "} fd_set;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern int __stdcall __WSAFDIsSet(SOCKET,fd_set *);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_CLR"
    .byte     13
    .byte     10
    .ascii    "#define FD_CLR(fd,set) do { unsigned int __i;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "for (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    if (((fd_set *)(set))->fd_array[__i] == (fd)) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    while (__i < ((fd_set *)(set))->fd_count-1) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        ((fd_set*)(set))->fd_array[__i] = ((fd_set*)(set))->fd_array[__i+1];"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        __i++;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    ((fd_set*)(set))->fd_count--;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    break;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "}"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "} while (0)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_SET"
    .byte     13
    .byte     10
    .ascii    "/* this differs from the define in winsock.h and in cygwin sys/types.h */"
    .byte     13
    .byte     10
    .ascii    "#define FD_SET(fd, set) do { unsigned int __i;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "for (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    if (((fd_set *)(set))->fd_array[__i] == (fd)) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        break;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "}"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "if (__i == ((fd_set *)(set))->fd_count) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    if (((fd_set *)(set))->fd_count < FD_SETSIZE) {"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        ((fd_set *)(set))->fd_array[__i] = (fd);"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "        ((fd_set *)(set))->fd_count++;"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "    }"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "}"
    .byte     92
    .byte     13
    .byte     10
    .ascii    "} while(0)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_ZERO"
    .byte     13
    .byte     10
    .ascii    "#define FD_ZERO(set) (((fd_set *)(set))->fd_count=0)"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef FD_ISSET"
    .byte     13
    .byte     10
    .ascii    "#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set *)(set))"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIMEVAL_DEFINED /* also in sys/time.h */"
    .byte     13
    .byte     10
    .ascii    "#define _TIMEVAL_DEFINED"
    .byte     13
    .byte     10
    .ascii    "struct timeval {"
    .byte     13
    .byte     10
    .ascii    "    long tv_sec;"
    .byte     13
    .byte     10
    .ascii    "    long tv_usec;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct in_addr {"
    .byte     13
    .byte     10
    .ascii    "    union {"
    .byte     13
    .byte     10
    .ascii    "        struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;"
    .byte     13
    .byte     10
    .ascii    "        struct { unsigned short s_w1,s_w2; } S_un_w;"
    .byte     13
    .byte     10
    .ascii    "        unsigned long S_addr;"
    .byte     13
    .byte     10
    .ascii    "    } S_un;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#define s_addr  S_un.S_addr"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct sockaddr_in {"
    .byte     13
    .byte     10
    .ascii    "    short sin_family;"
    .byte     13
    .byte     10
    .ascii    "    unsigned short sin_port;"
    .byte     13
    .byte     10
    .ascii    "    struct in_addr sin_addr;"
    .byte     13
    .byte     10
    .ascii    "    char sin_zero[8];"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct sockaddr {"
    .byte     13
    .byte     10
    .ascii    "    unsigned short sa_family;"
    .byte     13
    .byte     10
    .ascii    "    char sa_data[14];"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct hostent {"
    .byte     13
    .byte     10
    .ascii    "    char *h_name;"
    .byte     13
    .byte     10
    .ascii    "    char **h_aliases;"
    .byte     13
    .byte     10
    .ascii    "    short h_addrtype;"
    .byte     13
    .byte     10
    .ascii    "    short h_length;"
    .byte     13
    .byte     10
    .ascii    "    char **h_addr_list;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#define h_addr h_addr_list[0]"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WSADESCRIPTION_LEN  256"
    .byte     13
    .byte     10
    .ascii    "#define WSASYS_STATUS_LEN   128"
    .byte     13
    .byte     10
    .ascii    "typedef struct WSAData {"
    .byte     13
    .byte     10
    .ascii    "    WORD wVersion;"
    .byte     13
    .byte     10
    .ascii    "    WORD wHighVersion;"
    .byte     13
    .byte     10
    .ascii    "    char szDescription[WSADESCRIPTION_LEN+1];"
    .byte     13
    .byte     10
    .ascii    "    char szSystemStatus[WSASYS_STATUS_LEN+1];"
    .byte     13
    .byte     10
    .ascii    "    unsigned short iMaxSockets;"
    .byte     13
    .byte     10
    .ascii    "    unsigned short iMaxUdpDg;"
    .byte     13
    .byte     10
    .ascii    "    char *lpVendorInfo;"
    .byte     13
    .byte     10
    .ascii    "} WSADATA;"
    .byte     13
    .byte     10
    .ascii    "typedef WSADATA *LPWSADATA;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INVALID_SOCKET (SOCKET)(~0)"
    .byte     13
    .byte     10
    .ascii    "#define SOCK_STREAM  1"
    .byte     13
    .byte     10
    .ascii    "#define SO_REUSEADDR 4"
    .byte     13
    .byte     10
    .ascii    "#define AF_INET 2"
    .byte     13
    .byte     10
    .ascii    "#define MSG_PEEK 0x2"
    .byte     13
    .byte     10
    .ascii    "#define INADDR_ANY (unsigned long)0x00000000"
    .byte     13
    .byte     10
    .ascii    "#define INADDR_LOOPBACK 0x7f000001"
    .byte     13
    .byte     10
    .ascii    "#define SOL_SOCKET 0xffff"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SD_RECEIVE  0x00"
    .byte     13
    .byte     10
    .ascii    "#define SD_SEND     0x01"
    .byte     13
    .byte     10
    .ascii    "#define SD_BOTH     0x02"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define h_errno WSAGetLastError()"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WSABASEERR 10000"
    .byte     13
    .byte     10
    .ascii    "#define TRY_AGAIN (WSABASEERR+1002)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "SOCKET __stdcall accept(SOCKET, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall bind(SOCKET, const struct sockaddr *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall closesocket(SOCKET);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall connect(SOCKET, const struct sockaddr *, int);"
    .byte     13
    .byte     10
    .ascii    "struct hostent *__stdcall gethostbyname(const char *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall gethostname(char *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall getpeername(SOCKET, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall getsockname(SOCKET, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "unsigned long __stdcall htonl(unsigned long);"
    .byte     13
    .byte     10
    .ascii    "unsigned short __stdcall htons(unsigned short);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall listen(SOCKET, int);"
    .byte     13
    .byte     10
    .ascii    "unsigned long __stdcall ntohl(unsigned long);"
    .byte     13
    .byte     10
    .ascii    "unsigned short __stdcall ntohs(unsigned short);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall recv(SOCKET, char *, int, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall recvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall select(int nfds, fd_set *, fd_set *, fd_set *, const struct timeval *);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall send(SOCKET, const char *, int, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall sendto(SOCKET, const char *, int, int, const struct sockaddr *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall setsockopt(SOCKET, int, int, const char *, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall shutdown(SOCKET, int);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall WSACleanup(void);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall WSAGetLastError(void);"
    .byte     13
    .byte     10
    .ascii    "int __stdcall WSAStartup(WORD, LPWSADATA);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "SOCKET __stdcall socket(int, int, int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L10288:
    .ascii    "/* conio.h */"
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .ascii    "#include <wchar.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _getch(void);"
    .byte     13
    .byte     10
    .ascii    "int _kbhit(void);"
    .byte     13
    .byte     10
    .ascii    "wint_t _getwch(void);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define getch _getch"
    .byte     13
    .byte     10
    .ascii    "#define kbhit _kbhit"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _putch(int);"
    .byte     13
    .byte     10
    .ascii    "int _cprintf(char *, ...);"
    .byte     13
    .byte     10
    .ascii    "int _getche(void);"
    .byte     13
    .byte     10
    .ascii    "int _ungetch(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define putch _putch"
    .byte     13
    .byte     10
    .ascii    "#define cprintf _cprintf"
    .byte     13
    .byte     10
    .ascii    "#define getche _getche"
    .byte     13
    .byte     10
    .ascii    "#define ungetch _ungetch"
    .byte     13
    .byte     10
    .byte     0
L10287:
    .ascii    "#include <stddef.h>"
    .byte     10
    .byte     10
    .ascii    "void* malloc(size_t);"
    .byte     10
    .ascii    "void* realloc(void *, size_t);"
    .byte     10
    .ascii    "void  free(void *);"
    .byte     10
    .ascii    "void *_alloca(size_t);"
    .byte     10
    .byte     10
    .ascii    "#define alloca malloc"
    .byte     10
    .byte     0
L10286:
    .ascii    "/* Header process.h */"
    .byte     13
    .byte     10
    .ascii    "#ifndef $process"
    .byte     13
    .byte     10
    .ascii    "#define $process"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stdint.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define P_WAIT"
    .byte     9
    .byte     9
    .ascii    "0"
    .byte     13
    .byte     10
    .ascii    "#define P_NOWAIT"
    .byte     9
    .ascii    "1"
    .byte     13
    .byte     10
    .ascii    "#define P_OVERLAY"
    .byte     9
    .ascii    "2"
    .byte     13
    .byte     10
    .ascii    "#define P_DETACH"
    .byte     9
    .ascii    "4"
    .byte     13
    .byte     10
    .ascii    "#define WAIT_CHILD 0"
    .byte     13
    .byte     10
    .ascii    "#define _P_WAIT P_WAIT"
    .byte     13
    .byte     10
    .ascii    "#define _P_NOWAIT P_NOWAIT"
    .byte     13
    .byte     10
    .ascii    "#define _P_OVERLAY P_OVERLAY"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _spawnvp(int, const char*, const char*const*);"
    .byte     13
    .byte     10
    .ascii    "#define spawnvp _spawnvp"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "void endthread(void);"
    .byte     13
    .byte     10
    .ascii    "unsigned long _beginthreadex(void *,unsigned,unsigned (*)(void *),void *,unsigned,unsigned *);"
    .byte     13
    .byte     10
    .ascii    "void _endthreadex(unsigned);"
    .byte     13
    .byte     10
    .ascii    "int _cwait(int*, int, int);"
    .byte     13
    .byte     10
    .ascii    "#define cwait _cwait"
    .byte     13
    .byte     10
    .ascii    "//int _System(const char *cmd,int nCmdShow);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "intptr_t _execve(const char*, const char*const*, const char*const*);"
    .byte     13
    .byte     10
    .ascii    "#define execve _execve"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define _WAIT_CHILD"
    .byte     9
    .ascii    "0"
    .byte     13
    .byte     10
    .ascii    "//#endif"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L10285:
    .ascii    "#ifndef $direct"
    .byte     13
    .byte     10
    .ascii    "#define $direct"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef struct {"
    .byte     13
    .byte     10
    .ascii    " unsigned int total_clusters;"
    .byte     13
    .byte     10
    .ascii    " unsigned int avail_clusters;"
    .byte     13
    .byte     10
    .ascii    " unsigned int sectors_per_cluster;"
    .byte     13
    .byte     10
    .ascii    " unsigned int bytes_per_sector;"
    .byte     13
    .byte     10
    .ascii    "} diskfree_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int chdir(const char *);"
    .byte     13
    .byte     10
    .ascii    "char* _getcwd(char *, int);"
    .byte     13
    .byte     10
    .ascii    "#define getcwd _getcwd"
    .byte     13
    .byte     10
    .ascii    "int _mkdir(const char *);"
    .byte     13
    .byte     10
    .ascii    "int _rmdir(const char *);"
    .byte     13
    .byte     10
    .ascii    "int _wrmdir(const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "int _wmkdir(const wchar_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define mkdir _mkdir"
    .byte     13
    .byte     10
    .ascii    "#define rmdir _rmdir"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _chdrive(int);"
    .byte     13
    .byte     10
    .ascii    "char* _getdcwd(int, char *, int);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* _wgetcwd(wchar_t*, int);"
    .byte     13
    .byte     10
    .ascii    "int _wchdir(const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "int _getdrive(void);"
    .byte     13
    .byte     10
    .ascii    "int _chdir(const char*);"
    .byte     13
    .byte     10
    .ascii    "#define chdir _chdir"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "unsigned long _getdrives(void);"
    .byte     13
    .byte     10
    .ascii    "unsigned int _getdiskfree(unsigned int, diskfree_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L10284:
    .byte     13
    .byte     10
    .ascii    "#ifndef $io"
    .byte     13
    .byte     10
    .ascii    "#define $io"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stdint.h>"
    .byte     13
    .byte     10
    .ascii    "#include <wchar.h>"
    .byte     13
    .byte     10
    .ascii    "#include <time.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* io.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _A_NORMAL 0x00"
    .byte     13
    .byte     10
    .ascii    "#define _A_RDONLY 0x01"
    .byte     13
    .byte     10
    .ascii    "#define _A_HIDDEN 0x02"
    .byte     13
    .byte     10
    .ascii    "#define _A_SYSTEM 0x04"
    .byte     13
    .byte     10
    .ascii    "#define _A_SUBDIR 0x10"
    .byte     13
    .byte     10
    .ascii    "#define _A_ARCH 0x20"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#message "
    .byte     34
    .ascii    "IO included"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "struct _finddata_t {"
    .byte     13
    .byte     10
    .ascii    "        unsigned    attrib;"
    .byte     13
    .byte     10
    .ascii    "        time_t      time_create;"
    .byte     13
    .byte     10
    .ascii    "        time_t      time_access;"
    .byte     13
    .byte     10
    .ascii    "        time_t      time_write;"
    .byte     13
    .byte     10
    .ascii    "        unsigned long    size;"
    .byte     13
    .byte     10
    .ascii    "        char        name[260];"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _isatty(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _read(int, void*, unsigned int);"
    .byte     13
    .byte     10
    .ascii    "#define read _read"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _open(const char*, int, ...);"
    .byte     13
    .byte     10
    .ascii    "#define open _open"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "long _lseek(int, long, int);"
    .byte     13
    .byte     10
    .ascii    "#define lseek _lseek"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _close(int);"
    .byte     13
    .byte     10
    .ascii    "#define close _close"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "intptr_t _get_osfhandle(int);"
    .byte     13
    .byte     10
    .ascii    "int _open_osfhandle(intptr_t,int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _setmode(int,int);"
    .byte     13
    .byte     10
    .ascii    "#define setmode _setmode"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _wchmod(const wchar_t*, int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _chmod(const char *, int);"
    .byte     13
    .byte     10
    .ascii    "#define chmod _chmod"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _dup(int);"
    .byte     13
    .byte     10
    .ascii    "#define dup _dup"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "intptr_t _findfirst(const char*, struct _finddata_t*);"
    .byte     13
    .byte     10
    .ascii    "int _findnext(intptr_t, struct _finddata_t*);"
    .byte     13
    .byte     10
    .ascii    "int _findclose(intptr_t);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _access(const char*,int);"
    .byte     13
    .byte     10
    .ascii    "#define access _access"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _wunlink(const wchar_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10283:
    .ascii    "/* FCNTL.H */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _setmode(int,int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef _INC_FCNTL"
    .byte     13
    .byte     10
    .ascii    "#define _INC_FCNTL"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _O_RDONLY 0x0000"
    .byte     13
    .byte     10
    .ascii    "#define _O_WRONLY 0x0001"
    .byte     13
    .byte     10
    .ascii    "#define _O_RDWR 0x0002"
    .byte     13
    .byte     10
    .ascii    "#define _O_APPEND 0x0008"
    .byte     13
    .byte     10
    .ascii    "#define _O_CREAT 0x0100"
    .byte     13
    .byte     10
    .ascii    "#define _O_TRUNC 0x0200"
    .byte     13
    .byte     10
    .ascii    "#define _O_EXCL 0x0400"
    .byte     13
    .byte     10
    .ascii    "#define _O_TEXT 0x4000"
    .byte     13
    .byte     10
    .ascii    "#define _O_BINARY 0x8000"
    .byte     13
    .byte     10
    .ascii    "#define _O_WTEXT 0x10000"
    .byte     13
    .byte     10
    .ascii    "#define _O_U16TEXT 0x20000"
    .byte     13
    .byte     10
    .ascii    "#define _O_U8TEXT 0x40000"
    .byte     13
    .byte     10
    .ascii    "#define _O_ACCMODE (_O_RDONLY|_O_WRONLY|_O_RDWR)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _O_RAW _O_BINARY"
    .byte     13
    .byte     10
    .ascii    "#define _O_NOINHERIT 0x0080"
    .byte     13
    .byte     10
    .ascii    "#define _O_TEMPORARY 0x0040"
    .byte     13
    .byte     10
    .ascii    "#define _O_SHORT_LIVED 0x1000"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _O_SEQUENTIAL 0x0020"
    .byte     13
    .byte     10
    .ascii    "#define _O_RANDOM 0x0010"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#if !defined(NO_OLDNAMES) || defined(_POSIX)"
    .byte     13
    .byte     10
    .ascii    "#define O_RDONLY _O_RDONLY"
    .byte     13
    .byte     10
    .ascii    "#define O_WRONLY _O_WRONLY"
    .byte     13
    .byte     10
    .ascii    "#define O_RDWR _O_RDWR"
    .byte     13
    .byte     10
    .ascii    "#define O_APPEND _O_APPEND"
    .byte     13
    .byte     10
    .ascii    "#define O_CREAT _O_CREAT"
    .byte     13
    .byte     10
    .ascii    "#define O_TRUNC _O_TRUNC"
    .byte     13
    .byte     10
    .ascii    "#define O_EXCL _O_EXCL"
    .byte     13
    .byte     10
    .ascii    "#define O_TEXT _O_TEXT"
    .byte     13
    .byte     10
    .ascii    "#define O_BINARY _O_BINARY"
    .byte     13
    .byte     10
    .ascii    "#define O_RAW _O_BINARY"
    .byte     13
    .byte     10
    .ascii    "#define O_TEMPORARY _O_TEMPORARY"
    .byte     13
    .byte     10
    .ascii    "#define O_NOINHERIT _O_NOINHERIT"
    .byte     13
    .byte     10
    .ascii    "#define O_SEQUENTIAL _O_SEQUENTIAL"
    .byte     13
    .byte     10
    .ascii    "#define O_RANDOM _O_RANDOM"
    .byte     13
    .byte     10
    .ascii    "#define O_ACCMODE _O_ACCMODE"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10282:
    .ascii    "#include <malloc.h>"
    .byte     13
    .byte     10
    .byte     0
L10281:
    .ascii    "/* sys/utime.h header */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $utime"
    .byte     10
    .ascii    "#define $utime"
    .byte     10
    .byte     10
    .ascii    "struct _utimbuf {"
    .byte     10
    .byte     9
    .ascii    "long actime;"
    .byte     10
    .byte     9
    .ascii    "long modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "struct utimbuf {"
    .byte     10
    .byte     9
    .ascii    "long actime;"
    .byte     10
    .byte     9
    .ascii    "long modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .ascii    "struct __utimbuf64 {"
    .byte     10
    .ascii    "  long long int actime;"
    .byte     10
    .ascii    "  long long int modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .ascii    "int _utime64(const char *_Filename,struct __utimbuf64 *_Time);"
    .byte     10
    .byte     10
    .ascii    "int utime(const char *_Filename,struct utimbuf *_Utimbuf) {"
    .byte     10
    .ascii    "  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);"
    .byte     10
    .ascii    "}"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     0
L10280:
    .ascii    "/* timeb.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $timeb"
    .byte     13
    .byte     10
    .ascii    "#define $timeb"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <time.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct _timeb {"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "time_t time;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned short millitm;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short timezone;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short dstflag;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "#define timeb _timeb"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "void _ftime64(struct _timeb*);"
    .byte     13
    .byte     10
    .ascii    "#define _ftime _ftime64"
    .byte     13
    .byte     10
    .ascii    "#define ftime _ftime64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10279:
    .ascii    "/* stat.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $sysstat"
    .byte     13
    .byte     10
    .ascii    "#define $sysstat"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct _stat {"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned int"
    .byte     9
    .ascii    "st_dev;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned short"
    .byte     9
    .ascii    "st_ino;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned short"
    .byte     9
    .ascii    "st_mode;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "st_nlink;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "st_uid;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "short"
    .byte     9
    .byte     9
    .byte     9
    .ascii    "st_gid;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long"
    .byte     9
    .ascii    "st_rdev;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned int"
    .byte     9
    .ascii    "st_size;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long long int"
    .byte     9
    .ascii    "st_atime;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long long int"
    .byte     9
    .ascii    "st_mtime;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "unsigned long long int"
    .byte     9
    .ascii    "st_ctime;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define stat _stat"
    .byte     13
    .byte     10
    .ascii    "#define _stati64 _stat"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _S_IFMT 0xF000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFDIR 0x4000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFCHR 0x2000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFIFO 0x1000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IFREG 0x8000"
    .byte     13
    .byte     10
    .ascii    "#define _S_IREAD 0x0100"
    .byte     13
    .byte     10
    .ascii    "#define _S_IWRITE 0x0080"
    .byte     13
    .byte     10
    .ascii    "#define _S_IEXEC 0x0040"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_IFMT 0xF000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFDIR 0x4000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFCHR 0x2000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFIFO 0x1000"
    .byte     13
    .byte     10
    .ascii    "#define S_IFREG 0x8000"
    .byte     13
    .byte     10
    .ascii    "#define S_IREAD 0x0100"
    .byte     13
    .byte     10
    .ascii    "#define S_IWRITE 0x0080"
    .byte     13
    .byte     10
    .ascii    "#define S_IEXEC 0x0040"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_ISCHR(nd) (((nd) & S_IFMT) == S_IFCHR)"
    .byte     13
    .byte     10
    .ascii    "#define S_ISDIR(nd) (((nd) & S_IFMT) == S_IFDIR)"
    .byte     13
    .byte     10
    .ascii    "#define S_ISFIFO(nd) (((nd) & S_IFMT) == S_IFIFO)"
    .byte     13
    .byte     10
    .ascii    "#define S_ISREG(nd) (((nd) & S_IFMT) == S_IFREG)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IRWXU"
    .byte     9
    .ascii    "(_S_IREAD | _S_IWRITE | _S_IEXEC)"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IXUSR"
    .byte     9
    .ascii    "_S_IEXEC"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IWUSR"
    .byte     9
    .ascii    "_S_IWRITE"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IRWXU"
    .byte     9
    .byte     9
    .ascii    "_S_IRWXU"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IXUSR"
    .byte     9
    .byte     9
    .ascii    "_S_IXUSR"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IWUSR"
    .byte     9
    .byte     9
    .ascii    "_S_IWUSR"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IRUSR"
    .byte     9
    .byte     9
    .ascii    "_S_IRUSR"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "_S_IRUSR"
    .byte     9
    .ascii    "_S_IREAD"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_IRGRP    (S_IRUSR >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IWGRP    (S_IWUSR >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IXGRP    (S_IXUSR >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IRWXG    (S_IRWXU >> 3)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define S_IROTH    (S_IRGRP >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IWOTH    (S_IWGRP >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IXOTH    (S_IXGRP >> 3)"
    .byte     13
    .byte     10
    .ascii    "#define S_IRWXO    (S_IRWXG >> 3)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define"
    .byte     9
    .ascii    "S_ISDIR(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFDIR)"
    .byte     13
    .byte     10
    .ascii    "//#define"
    .byte     9
    .ascii    "S_ISFIFO(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFIFO)"
    .byte     13
    .byte     10
    .ascii    "//#define"
    .byte     9
    .ascii    "S_ISCHR(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFCHR)"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_IFBLK"
    .byte     9
    .ascii    "0x3000"
    .byte     9
    .ascii    "/* Block: Is this ever set under w32? */"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_ISBLK(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFBLK)"
    .byte     13
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "S_ISREG(m)"
    .byte     9
    .ascii    "(((m) & S_IFMT) == S_IFREG)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int stat(const char *, struct stat*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _fstati64(int, struct stat*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int fstat(int, struct stat *);"
    .byte     13
    .byte     10
    .ascii    "#define _fstat fstat"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _wstati64(const wchar_t,struct _stati64 *buffer);  "
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10278:
    .ascii    "/* types.h */"
    .byte     13
    .byte     10
    .ascii    "#ifndef $systypes"
    .byte     13
    .byte     10
    .ascii    "#define $systypes 1"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long int off_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long int ino_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int dev_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long long time_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10277:
    .ascii    "/* Header wctype.h */"
    .byte     13
    .byte     10
    .byte     0
L10276:
    .ascii    "/* Header wchar.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _WCHAR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short wint_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short wchar_t;"
    .byte     13
    .byte     10
    .ascii    "//typedef signed short wchar_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "size_t wcslen(const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcscpy(wchar_t*,const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "//wchar_t* _wgetenv(constwchar_t*);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcstok(wchar_t*,wchar_t*,wchar_t**);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcstok_s(wchar_t*,wchar_t*,wchar_t**);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcschr(wchar_t*,wchar_t);"
    .byte     13
    .byte     10
    .ascii    "wchar_t* wcsstr(const wchar_t*,const wchar_t*);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int wcscmp(const wchar_t*,const wchar_t*);"
    .byte     13
    .byte     10
    .ascii    "typedef long _off_t;"
    .byte     13
    .byte     10
    .byte     0
L10275:
    .ascii    "/* Header safelib.h */"
    .byte     13
    .byte     10
    .byte     0
L10274:
    .ascii    "/* unistd.h header */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "unsigned int _sleep(unsigned int);"
    .byte     13
    .byte     10
    .ascii    "#define sleep _sleep"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define alarm(x) {puts("
    .byte     34
    .ascii    "ALARM"
    .byte     34
    .ascii    "); exit(1);}"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _write(int,void*,unsigned int);"
    .byte     13
    .byte     10
    .ascii    "#define write _write"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int _close(int);"
    .byte     13
    .byte     10
    .ascii    "#define close _close"
    .byte     13
    .byte     10
    .byte     0
L10273:
    .ascii    "/* sys/utime.h header */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $utime"
    .byte     10
    .ascii    "#define $utime"
    .byte     10
    .byte     10
    .ascii    "struct _utimbuf {"
    .byte     10
    .byte     9
    .ascii    "long actime;"
    .byte     10
    .byte     9
    .ascii    "long modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "struct utimbuf {"
    .byte     10
    .byte     9
    .ascii    "long actime;"
    .byte     10
    .byte     9
    .ascii    "long modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .ascii    "struct __utimbuf64 {"
    .byte     10
    .ascii    "  long long int actime;"
    .byte     10
    .ascii    "  long long int modtime;"
    .byte     10
    .ascii    "};"
    .byte     10
    .byte     10
    .ascii    "int _utime64(const char *_Filename,struct __utimbuf64 *_Time);"
    .byte     10
    .byte     10
    .ascii    "int utime(const char *_Filename,struct utimbuf *_Utimbuf) {"
    .byte     10
    .ascii    "  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);"
    .byte     10
    .ascii    "}"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     0
L10272:
    .ascii    "/* Header time.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $time"
    .byte     13
    .byte     10
    .ascii    "#define $time"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long clock_t;"
    .byte     13
    .byte     10
    .ascii    "clock_t clock(void);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//typedef long time_t;"
    .byte     13
    .byte     10
    .ascii    "#ifndef _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "#define _TIME_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef long long int time_t;"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct tm"
    .byte     13
    .byte     10
    .ascii    "{"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_sec;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_min;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_hour;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_mday;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_mon;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_year;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_wday;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_yday;"
    .byte     13
    .byte     10
    .ascii    "  int"
    .byte     9
    .ascii    "tm_isdst;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//struct tm *localtime(time_t*);"
    .byte     13
    .byte     10
    .ascii    "struct tm* _localtime32(time_t*);"
    .byte     13
    .byte     10
    .ascii    "#define localtime _localtime32"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "time_t _time64(time_t *_timer);"
    .byte     13
    .byte     10
    .ascii    "#define time _time64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define CLOCKS_PER_SEC 1000"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct tm *gmtime(const time_t*);"
    .byte     13
    .byte     10
    .ascii    "size_t strftime(char *, size_t, const char *, const struct tm *);"
    .byte     13
    .byte     10
    .ascii    "time_t mktime(struct tm *);"
    .byte     13
    .byte     10
    .ascii    "double difftime(time_t, time_t);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "char* asctime(const struct tm*);"
    .byte     13
    .byte     10
    .ascii    "//char* ctime(const time_t *_time);"
    .byte     13
    .byte     10
    .ascii    "char* _ctime64(const time_t *_time);"
    .byte     13
    .byte     10
    .ascii    "#define ctime _ctime64"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10271:
    .ascii    "/* Header string.h */"
    .byte     10
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     10
    .byte     10
    .ascii    "void* memcpy(void*, const void*, size_t);"
    .byte     10
    .ascii    "void* memmove(const void*, const void*, size_t);"
    .byte     10
    .ascii    "void* memset(void*, int, size_t);"
    .byte     10
    .ascii    "int memcmp(const void*, const void*, size_t);"
    .byte     10
    .ascii    "void* memchr(const void *, int, size_t);"
    .byte     10
    .byte     10
    .ascii    "size_t strlen(const char*);"
    .byte     10
    .ascii    "char* strcpy(char*, const char*);"
    .byte     10
    .ascii    "char* strncpy(char*, const char*, size_t);"
    .byte     10
    .ascii    "char* strcat(char*, const char*);"
    .byte     10
    .ascii    "int strcmp(const char*, const char*);"
    .byte     10
    .ascii    "int strncmp(const char*, const char*, size_t);"
    .byte     10
    .ascii    "char* strchr(const char*, int);"
    .byte     10
    .ascii    "char* strstr(const char*, const char*);"
    .byte     10
    .ascii    "char* strrchr(const char*, int);"
    .byte     10
    .ascii    "int _stricmp(const char*, const char*);"
    .byte     10
    .ascii    "#define stricmp _stricmp"
    .byte     10
    .ascii    "#define strcasecmp _stricmp"
    .byte     10
    .byte     10
    .byte     10
    .byte     10
    .ascii    "int _strnicmp(const char*, const char*, size_t);"
    .byte     10
    .ascii    "#define strnicmp _strnicmp"
    .byte     10
    .ascii    "char* strncat(char*, const char*, size_t);"
    .byte     10
    .ascii    "char* strtok(char*, const char*);"
    .byte     10
    .byte     10
    .ascii    "size_t strcspn(const char*, const char*);"
    .byte     10
    .ascii    "size_t strspn(const char*, const char*);"
    .byte     10
    .ascii    "int strcoll(const char *, const char *);"
    .byte     10
    .byte     10
    .ascii    "unsigned long strtoul(const char*, char**, int);"
    .byte     10
    .byte     10
    .ascii    "char* strerror(int);"
    .byte     10
    .ascii    "char* strpbrk(const char*, const char*);"
    .byte     10
    .ascii    "size_t strxfrm(char*, const char *, size_t);"
    .byte     10
    .byte     10
    .ascii    "char* _strupr(char*);"
    .byte     10
    .ascii    "char* _strlwr(char*);"
    .byte     10
    .ascii    "#define strupr _strupr"
    .byte     10
    .ascii    "#define strlwr _strlwr"
    .byte     10
    .byte     10
    .ascii    "char*strnupr(char*,size_t);"
    .byte     10
    .ascii    "char*strnlwr(char*,size_t);"
    .byte     10
    .ascii    "int strtrim(char*);"
    .byte     10
    .ascii    "char*strrev(char*);"
    .byte     10
    .byte     10
    .ascii    "char* _strdup(const char*);"
    .byte     10
    .ascii    "#define strdup _strdup"
    .byte     10
    .byte     10
    .ascii    "int _wcsicmp(const wchar_t *,const wchar_t *);"
    .byte     10
    .byte     10
    .ascii    "wchar_t *wcspbrk(const wchar_t*,const wchar_t*);"
    .byte     10
    .byte     10
    .ascii    "size_t wcslen(const wchar_t*);"
    .byte     10
    .byte     0
L10270:
    .ascii    "/* Header _syslist.h */"
    .byte     13
    .byte     10
    .byte     0
L10269:
    .ascii    "/* Header stdlib.h */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $stdlib"
    .byte     10
    .ascii    "#define $stdlib 1"
    .byte     10
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     10
    .byte     10
    .ascii    "#define EXIT_FAILURE 1"
    .byte     10
    .ascii    "#define EXIT_SUCCESS 0"
    .byte     10
    .byte     10
    .ascii    "#define RAND_MAX 32767"
    .byte     10
    .byte     10
    .ascii    "void* malloc(size_t);"
    .byte     10
    .ascii    "void* realloc(void*, size_t);"
    .byte     10
    .ascii    "void* calloc(size_t, size_t);"
    .byte     10
    .byte     10
    .ascii    "void free(void*);"
    .byte     10
    .byte     10
    .ascii    "void exit(int);"
    .byte     10
    .byte     10
    .ascii    "int system(const char*);"
    .byte     10
    .ascii    "int _wsystem(const wchar_t*);"
    .byte     10
    .byte     10
    .ascii    "int abs(int);"
    .byte     10
    .ascii    "long labs(long);"
    .byte     10
    .ascii    "long long llabs(long);"
    .byte     10
    .ascii    "int rand(void);"
    .byte     10
    .ascii    "void srand(unsigned int);"
    .byte     10
    .ascii    "int atoi(const char*);"
    .byte     10
    .ascii    "long atol(const char*);"
    .byte     10
    .ascii    "long long atoll(const char*);"
    .byte     10
    .ascii    "long long atoi64(const char*);"
    .byte     10
    .ascii    "double atof(const char *);"
    .byte     10
    .ascii    "int"
    .byte     9
    .ascii    "atexit(void (*)(void));"
    .byte     10
    .ascii    "char *_itoa(int,char *,int);"
    .byte     10
    .byte     10
    .ascii    "#define itoa _itoa"
    .byte     10
    .byte     10
    .ascii    "void qsort(void*, size_t, size_t, int (*)(void*, void*));"
    .byte     10
    .byte     10
    .ascii    "typedef struct {"
    .byte     10
    .byte     9
    .ascii    "long long int quot;"
    .byte     10
    .byte     9
    .ascii    "long long int rem;"
    .byte     10
    .ascii    "} lldiv_t;"
    .byte     10
    .byte     10
    .ascii    "lldiv_t lldiv(long long int, long long int);"
    .byte     10
    .byte     10
    .ascii    "char* getenv(const char*);"
    .byte     10
    .ascii    "wchar_t* _wgetenv(const wchar_t*);"
    .byte     10
    .ascii    "int _wputenv(const wchar_t*);"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "double strtod(const char*, char**);"
    .byte     10
    .byte     10
    .ascii    "//float strtof(const char *, char**);"
    .byte     10
    .ascii    "#define strtof strtod"
    .byte     10
    .byte     10
    .ascii    "long double strtold(const char*, char**);"
    .byte     10
    .ascii    "void abort(void);"
    .byte     10
    .ascii    "long int strtol(const char*, char**, int);"
    .byte     10
    .byte     10
    .ascii    "long double strtold(const char *,char **);"
    .byte     10
    .byte     10
    .ascii    "long long int _strtoi64(const char *,char **,int);"
    .byte     10
    .ascii    "#define strtoll _strtoi64"
    .byte     10
    .byte     10
    .ascii    "unsigned long long int _strtoui64(const char *,char **,int);"
    .byte     10
    .byte     10
    .ascii    "unsigned long long int _strtoui64(const char*, char**, int);"
    .byte     10
    .ascii    "#define strtoull _strtoui64"
    .byte     10
    .ascii    "unsigned long strtoul(const char*, char**, int);"
    .byte     10
    .byte     10
    .ascii    "size_t _msize(void *);"
    .byte     10
    .ascii    "#define msize _msize"
    .byte     10
    .byte     10
    .ascii    "void* bsearch(const void *,const void *, size_t, size_t,"
    .byte     10
    .byte     9
    .byte     9
    .ascii    "int (*_compar)(const void *,const void *));"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "char* _fullpath(char*, const char*, size_t);"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     0
L10268:
    .ascii    "/* Header stdio.h */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $stdio"
    .byte     10
    .ascii    "#define $stdio 1"
    .byte     10
    .byte     10
    .ascii    "#define __attribute__(x)"
    .byte     10
    .byte     10
    .ascii    "#ifndef $valist"
    .byte     10
    .byte     9
    .ascii    "typedef char* va_list;"
    .byte     10
    .byte     9
    .ascii    "#define $valist"
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     10
    .ascii    "#include <stddef.h>"
    .byte     10
    .byte     10
    .ascii    "typedef long long int fpos_t;"
    .byte     10
    .byte     10
    .ascii    "#define SEEK_SET 0"
    .byte     10
    .ascii    "#define SEEK_CUR 1"
    .byte     10
    .ascii    "#define SEEK_END 2"
    .byte     10
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "STDIN_FILENO"
    .byte     9
    .ascii    "0"
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "STDOUT_FILENO"
    .byte     9
    .ascii    "1"
    .byte     10
    .ascii    "#define"
    .byte     9
    .ascii    "STDERR_FILENO"
    .byte     9
    .ascii    "2"
    .byte     10
    .byte     10
    .ascii    "#define EOF (-1)"
    .byte     10
    .ascii    "#define FILENAME_MAX 260"
    .byte     10
    .byte     10
    .ascii    "#define L_tmpnam 10"
    .byte     10
    .byte     10
    .ascii    "typedef struct {"
    .byte     10
    .byte     9
    .ascii    "char *_ptr;"
    .byte     10
    .byte     9
    .ascii    "int   _cnt;"
    .byte     10
    .byte     9
    .ascii    "char *_base;"
    .byte     10
    .byte     9
    .ascii    "int   _flag;"
    .byte     10
    .byte     9
    .ascii    "int   _file;"
    .byte     10
    .byte     9
    .ascii    "int   _charbuf;"
    .byte     10
    .byte     9
    .ascii    "int   _bufsiz;"
    .byte     10
    .byte     9
    .ascii    "char *_tmpfname;"
    .byte     10
    .ascii    "} FILE;"
    .byte     10
    .byte     10
    .ascii    "extern char* __iob_func(void);"
    .byte     10
    .byte     10
    .ascii    "#define stdin ((FILE*)(__iob_func()))"
    .byte     10
    .ascii    "#define stdout ((FILE*)(__iob_func()+sizeof(FILE)))"
    .byte     10
    .ascii    "#define stderr ((FILE*)(__iob_func()+sizeof(FILE)*2))"
    .byte     10
    .byte     10
    .ascii    "#define _IOREAD 0x0001"
    .byte     10
    .ascii    "#define _IOWRT 0x0002"
    .byte     10
    .byte     10
    .ascii    "#define _IOFBF 0x0000"
    .byte     10
    .ascii    "#define _IOLBF 0x0040"
    .byte     10
    .ascii    "#define _IONBF 0x0004"
    .byte     10
    .byte     10
    .ascii    "#define _IOMYBUF 0x0008"
    .byte     10
    .ascii    "#define _IOEOF 0x0010"
    .byte     10
    .ascii    "#define _IOERR 0x0020"
    .byte     10
    .ascii    "#define _IOSTRG 0x0040"
    .byte     10
    .ascii    "#define _IORW 0x0080"
    .byte     10
    .byte     10
    .ascii    "#define BUFSIZ 512"
    .byte     10
    .byte     10
    .ascii    "FILE* fopen(const char*, const char*);"
    .byte     10
    .ascii    "int fclose(FILE*);"
    .byte     10
    .ascii    "long ftell(FILE*);"
    .byte     10
    .ascii    "//long long int _ftelli64(FILE*);"
    .byte     10
    .ascii    "int fseek(FILE*,long,int);"
    .byte     10
    .ascii    "int _fseeki64(FILE*,long long int,int);"
    .byte     10
    .byte     10
    .ascii    "size_t fread(void*, size_t, size_t, FILE*);"
    .byte     10
    .ascii    "size_t fwrite(const void*, size_t, size_t, FILE*);"
    .byte     10
    .ascii    "int remove(const char*);"
    .byte     10
    .ascii    "int rename(const char *,const char *);"
    .byte     10
    .ascii    "FILE* freopen(const char*, const char*, FILE*);"
    .byte     10
    .ascii    "FILE* _wfopen(const wchar_t*,const wchar_t *);"
    .byte     10
    .byte     10
    .ascii    "int printf(const char*, ...);"
    .byte     10
    .ascii    "int sprintf(char*,const char*, ...);"
    .byte     10
    .ascii    "int fprintf(FILE*,const char*, ...);"
    .byte     10
    .ascii    "int sscanf(const char*, const char*, ...);"
    .byte     10
    .ascii    "int scanf(const char*, ...);"
    .byte     10
    .ascii    "int fscanf(FILE *,const char *, ...);"
    .byte     10
    .ascii    "int _snprintf(char *,size_t,const char*,...);"
    .byte     10
    .ascii    "#define snprintf _snprintf"
    .byte     10
    .ascii    "int _vsnprintf(char*, size_t, const char*, va_list);"
    .byte     10
    .ascii    "int vsnprintf(char*,size_t,const char*,va_list);"
    .byte     10
    .ascii    "int vsprintf(char*, const char*, va_list);"
    .byte     10
    .ascii    "int _wremove(const wchar_t*);"
    .byte     10
    .ascii    "int _wrename(const wchar_t*,const wchar_t*);"
    .byte     10
    .byte     10
    .ascii    "typedef char* va_list;"
    .byte     10
    .byte     10
    .ascii    "int vfprintf(FILE*, const char*, va_list);"
    .byte     10
    .ascii    "int vprintf(const char*, va_list);"
    .byte     10
    .byte     10
    .ascii    "int puts(const char*);"
    .byte     10
    .ascii    "char* fgets(char*, int, FILE*);"
    .byte     10
    .ascii    "int fputs(const char*, FILE*);"
    .byte     10
    .ascii    "int fgetc(FILE*);"
    .byte     10
    .ascii    "int fputc(int, FILE*);"
    .byte     10
    .ascii    "int ungetc(int, FILE*);"
    .byte     10
    .ascii    "int getchar(void);"
    .byte     10
    .ascii    "int putchar(int);"
    .byte     10
    .ascii    "int fflush(FILE *);"
    .byte     10
    .ascii    "int getc(FILE *);"
    .byte     10
    .ascii    "int putc(int, FILE *);"
    .byte     10
    .byte     10
    .ascii    "int feof(FILE*);"
    .byte     10
    .ascii    "int ferror(FILE*);"
    .byte     10
    .ascii    "void clearerr(FILE*);"
    .byte     10
    .byte     10
    .ascii    "int fileno(FILE*);"
    .byte     10
    .ascii    "int _fileno(FILE*);"
    .byte     10
    .ascii    "int setvbuf(FILE*,char*,int,size_t);"
    .byte     10
    .ascii    "FILE* _popen(const char*, const char*);"
    .byte     10
    .ascii    "int _pclose(FILE*);"
    .byte     10
    .ascii    "int _unlink(const char *);"
    .byte     10
    .ascii    "#define unlink _unlink;"
    .byte     10
    .ascii    "FILE* _fdopen(int, const char *);"
    .byte     10
    .ascii    "#define fdopen _fdopen"
    .byte     10
    .ascii    "int fgetpos(FILE*, fpos_t*);"
    .byte     10
    .ascii    "int fsetpos(FILE*, const fpos_t*);"
    .byte     10
    .ascii    "void perror(char*);"
    .byte     10
    .ascii    "void setbuf(FILE*, char*);"
    .byte     10
    .byte     10
    .ascii    "void rewind(FILE*);"
    .byte     10
    .byte     10
    .ascii    "FILE* tmpfile(void);"
    .byte     10
    .byte     10
    .ascii    "char* tmpnam(char*);"
    .byte     10
    .ascii    "wchar_t getwc(FILE *);"
    .byte     10
    .byte     10
    .ascii    "extern void* _wenviron;"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     10
    .byte     0
L10267:
    .ascii    "/* Header stddef.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $stddef"
    .byte     13
    .byte     10
    .ascii    "#define $stddef"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef signed long long int ssize_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long int size_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define _WCHAR_T_DEFINED"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short wchar_t;"
    .byte     13
    .byte     10
    .ascii    "//typedef signed short wchar_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define NULL ((void*)0)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define offsetof(a,b) (size_t) &( ((a*)0) -> b)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long long int ptrdiff_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif // stddef"
    .byte     13
    .byte     10
    .byte     0
L10266:
    .ascii    "/* Header stdbool.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define bool unsigned char"
    .byte     13
    .byte     10
    .ascii    "#define true 1"
    .byte     13
    .byte     10
    .ascii    "#define false 0"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L10265:
    .ascii    "/* Header stdarg.h */"
    .byte     10
    .byte     10
    .ascii    "#ifndef $STDARG"
    .byte     10
    .ascii    " #define $STDARG"
    .byte     10
    .byte     10
    .ascii    "//coded for x64 target as used by mcc (with first four params also on stack)"
    .byte     10
    .byte     10
    .ascii    " typedef char *"
    .byte     9
    .ascii    "va_list;"
    .byte     10
    .byte     10
    .ascii    " #if __MCCI__"
    .byte     10
    .ascii    "  #define va_start(ap,v) ap=((va_list)&v-8)"
    .byte     10
    .ascii    "  #define va_arg(ap,t) *(t*)((ap-=8)+8)"
    .byte     10
    .ascii    "  #define va_copy(dest,src) (dest=src)"
    .byte     10
    .ascii    "  #define va_end(ap)"
    .byte     9
    .ascii    "( ap = (va_list)0 )"
    .byte     10
    .byte     10
    .ascii    " #else"
    .byte     10
    .ascii    "  #define va_start(ap,v) ap=((va_list)&v+8)"
    .byte     10
    .ascii    "  #define va_arg(ap,t) *(t*)((ap+=8)-8)"
    .byte     10
    .ascii    "  #define va_copy(dest,src) (dest=src)"
    .byte     10
    .ascii    "  #define va_end(ap)"
    .byte     9
    .ascii    "( ap = (va_list)0 )"
    .byte     10
    .byte     10
    .ascii    " #endif"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     0
L10264:
    .ascii    "/* Header signal.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SIGINT    2"
    .byte     13
    .byte     10
    .ascii    "#define SIGILL    4"
    .byte     13
    .byte     10
    .ascii    "#define SIGFPE    8"
    .byte     13
    .byte     10
    .ascii    "#define SIGSEGV  11"
    .byte     13
    .byte     10
    .ascii    "#define SIGTERM  15"
    .byte     13
    .byte     10
    .ascii    "#define SIGBREAK 21"
    .byte     13
    .byte     10
    .ascii    "#define SIGABRT  22"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SIG_DFL (void (*)(int))0"
    .byte     13
    .byte     10
    .ascii    "#define SIG_IGN (void (*)(int))1"
    .byte     13
    .byte     10
    .ascii    "#define SIG_SGE (void (*)(int))3"
    .byte     13
    .byte     10
    .ascii    "#define SIG_ACK (void (*)(int))4"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define SIG_ERR (void (*)(int))-1"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern void (*signal(int, void (*)(int)))(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern int raise(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef int sig_atomic_t;"
    .byte     13
    .byte     10
    .byte     0
L10263:
    .ascii    "/* Header setjmp.h */"
    .byte     10
    .byte     10
    .byte     10
    .ascii    "#ifndef $setjmphdr"
    .byte     10
    .ascii    "#define $setjmphdr 1"
    .byte     10
    .byte     10
    .ascii    "typedef int jmp_buf[128];"
    .byte     10
    .byte     10
    .ascii    "//void $mcclongjmp(jmp_buf, int);"
    .byte     10
    .ascii    "//int $mccsetjmp(jmp_buf);"
    .byte     10
    .byte     10
    .ascii    "#define setjmp $setjmp"
    .byte     10
    .ascii    "#define longjmp $longjmp"
    .byte     10
    .byte     10
    .ascii    "#endif"
    .byte     10
    .byte     10
    .byte     0
L10262:
    .ascii    "/* Header math.h */"
    .byte     10
    .byte     10
    .ascii    "#define HUGE_VAL 1.7976931348623156e+308"
    .byte     10
    .byte     10
    .ascii    "double floor(double);"
    .byte     10
    .ascii    "double ceil(double);"
    .byte     10
    .ascii    "double sqrt(double);"
    .byte     10
    .ascii    "double sin(double);"
    .byte     10
    .ascii    "double cos(double);"
    .byte     10
    .ascii    "double tan(double);"
    .byte     10
    .ascii    "double fmod(double,double);"
    .byte     10
    .ascii    "double asin(double);"
    .byte     10
    .ascii    "double acos(double);"
    .byte     10
    .ascii    "double atan(double);"
    .byte     10
    .ascii    "double log(double);"
    .byte     10
    .ascii    "double log10(double);"
    .byte     10
    .ascii    "double exp(double);"
    .byte     10
    .ascii    "double modf(double,double*);"
    .byte     10
    .ascii    "double atan2(double,double);"
    .byte     10
    .ascii    "double pow(double,double);"
    .byte     10
    .ascii    "double fabs(double);"
    .byte     10
    .ascii    "double sinh(double);"
    .byte     10
    .ascii    "double cosh(double);"
    .byte     10
    .ascii    "double tanh(double);"
    .byte     10
    .ascii    "double frexp(double,int*);"
    .byte     10
    .ascii    "double ldexp(double,int);"
    .byte     10
    .ascii    "int isnan(double);"
    .byte     10
    .byte     10
    .ascii    "#define ldexpl ldexp"
    .byte     10
    .byte     10
    .ascii    "float sinf(float);"
    .byte     10
    .ascii    "float cosf(float);"
    .byte     10
    .ascii    "float tanf(float);"
    .byte     10
    .ascii    "float expf(float);"
    .byte     10
    .ascii    "float powf(float, float);"
    .byte     10
    .ascii    "float logf(float);"
    .byte     10
    .byte     10
    .ascii    "float sqrtf(float);"
    .byte     10
    .ascii    "float acosf(float);"
    .byte     10
    .ascii    "float atan2f(float,float);"
    .byte     10
    .ascii    "float ceilf(float);"
    .byte     10
    .byte     10
    .ascii    "double acosh (double);"
    .byte     10
    .ascii    "long double acoshl(long double);"
    .byte     10
    .ascii    "long double acoshl(long double);"
    .byte     10
    .ascii    "float acoshf(float);"
    .byte     10
    .byte     10
    .ascii    "double asinh (double);"
    .byte     10
    .ascii    "long double asinhl(long double);"
    .byte     10
    .ascii    "long double sinhl(long double);"
    .byte     10
    .ascii    "float asinhf(float);"
    .byte     10
    .byte     10
    .ascii    "double atanh(double);"
    .byte     10
    .ascii    "long double atanhl(long double);"
    .byte     10
    .ascii    "float atanhf(float);"
    .byte     10
    .byte     10
    .ascii    "long double expm1l(long double);"
    .byte     10
    .ascii    "double expm1(double);"
    .byte     10
    .ascii    "float expm1f(float);"
    .byte     10
    .ascii    "double _expm1i(int);"
    .byte     10
    .byte     10
    .ascii    "double cbrt(double);"
    .byte     10
    .ascii    "long double cbrtl(long double);"
    .byte     10
    .ascii    "float cbrtf(float);"
    .byte     10
    .byte     10
    .ascii    "double trunc(double x);"
    .byte     10
    .ascii    "long double truncl(long double);"
    .byte     10
    .ascii    "float truncf(float);"
    .byte     10
    .byte     10
    .ascii    "double round(double);"
    .byte     10
    .ascii    "float roundf(float);"
    .byte     10
    .ascii    "long double roundl(long double);"
    .byte     10
    .ascii    "double _roundi(int);"
    .byte     10
    .byte     10
    .ascii    "long double fminl(long double,long double);"
    .byte     10
    .ascii    "float fminf(float ,float);"
    .byte     10
    .ascii    "double fmin(double,double);"
    .byte     10
    .byte     10
    .ascii    "//float fabsf(float);"
    .byte     10
    .ascii    "#define fabsf fabs"
    .byte     10
    .byte     10
    .ascii    "double lgamma (double);"
    .byte     10
    .ascii    "long double lgammal(long double);"
    .byte     10
    .ascii    "float lgammaf(float);"
    .byte     10
    .byte     10
    .ascii    "long double tgammal(long double);"
    .byte     10
    .ascii    "double tgamma(double);"
    .byte     10
    .ascii    "float tgammaf(float);"
    .byte     10
    .byte     10
    .ascii    "double log1p(double);"
    .byte     10
    .ascii    "long double log1pl(long double);"
    .byte     10
    .ascii    "float log1pf(float);"
    .byte     10
    .byte     10
    .ascii    "long double log10l(long double);"
    .byte     10
    .ascii    "float log10f(float);"
    .byte     10
    .ascii    "double _log10i(int);"
    .byte     10
    .ascii    "double log10(double);"
    .byte     10
    .byte     10
    .ascii    "double erf(double);"
    .byte     10
    .ascii    "long double erfl(long double);"
    .byte     10
    .ascii    "float erff(float);"
    .byte     10
    .byte     10
    .ascii    "double hypot (double, double);"
    .byte     10
    .ascii    "double _hypot(double,double);"
    .byte     10
    .ascii    "long double hypotl(long double,long double);"
    .byte     10
    .ascii    "float hypotf(float,float);"
    .byte     10
    .byte     10
    .ascii    "double nextafter (double, double);"
    .byte     10
    .ascii    "long double nextafterl(long double,long double);"
    .byte     10
    .ascii    "float nextafterf(float,float);"
    .byte     10
    .byte     10
    .ascii    "double nexttoward(double,long double);"
    .byte     10
    .ascii    "long double nexttowardl(long double,long double);"
    .byte     10
    .ascii    "float nexttowardf(float,long double);"
    .byte     10
    .byte     10
    .ascii    "double erfc(double);"
    .byte     10
    .ascii    "long double erfcl(long double);"
    .byte     10
    .ascii    "float erfcf(float);"
    .byte     10
    .byte     10
    .ascii    "int _finite(double);"
    .byte     10
    .ascii    "#define finite _finite"
    .byte     10
    .byte     10
    .ascii    "float floorf(float);"
    .byte     10
    .byte     10
    .ascii    "double _copysign(double,double);"
    .byte     10
    .ascii    "#define copysign _copysign"
    .byte     10
    .byte     10
    .ascii    "long double fmaxl(long double,long double);"
    .byte     10
    .ascii    "double fmax(double,double);"
    .byte     10
    .ascii    "float fmaxf(float,float);"
    .byte     10
    .ascii    "float fmodf(float,float);"
    .byte     10
    .byte     10
    .ascii    "//long double exp2l(long double);"
    .byte     10
    .ascii    "double exp2(double);"
    .byte     10
    .ascii    "float exp2f(float);"
    .byte     10
    .byte     10
    .ascii    "//double log2(double);"
    .byte     10
    .ascii    "#define log2(x) (log(x)*1.442695041)"
    .byte     10
    .byte     10
    .ascii    "#define M_PI 3.1415926535897932384625433"
    .byte     10
    .ascii    "#define M_PI_2 (M_PI/2.0)"
    .byte     10
    .ascii    "#define M_2_PI 0.63661977236758134308"
    .byte     10
    .byte     10
    .ascii    "int isinf(double);"
    .byte     10
    .byte     10
    .ascii    "int _finite(double);"
    .byte     10
    .byte     10
    .ascii    "#define isfinite _finite"
    .byte     10
    .byte     10
    .ascii    "int isfinitef(float);"
    .byte     10
    .ascii    "int isfinitel(long double);"
    .byte     10
    .byte     10
    .byte     0
L10261:
    .ascii    "/* Header _ansi.h */"
    .byte     13
    .byte     10
    .byte     0
L10260:
    .ascii    "/* Header locale.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $locale"
    .byte     13
    .byte     10
    .ascii    "#define $locale"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define LC_ALL 0"
    .byte     13
    .byte     10
    .ascii    "#define LC_COLLATE 1"
    .byte     13
    .byte     10
    .ascii    "#define LC_CTYPE 2"
    .byte     13
    .byte     10
    .ascii    "#define LC_MONETARY 3"
    .byte     13
    .byte     10
    .ascii    "#define LC_NUMERIC 4"
    .byte     13
    .byte     10
    .ascii    "#define LC_TIME 5"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct lconv {"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *decimal_point;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *thousands_sep;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *grouping;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *int_curr_symbol;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *currency_symbol;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *mon_decimal_point;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *mon_thousands_sep;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *mon_grouping;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *positive_sign;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char *negative_sign;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char int_frac_digits;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char frac_digits;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char p_cs_precedes;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char p_sep_by_space;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char n_cs_precedes;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char n_sep_by_space;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char p_sign_posn;"
    .byte     13
    .byte     10
    .byte     9
    .ascii    "char n_sign_posn;"
    .byte     13
    .byte     10
    .ascii    "};"
    .byte     13
    .byte     10
    .ascii    "char *setlocale(int category, const char *locale);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "struct lconv *localeconv(void);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "char * setlocale(int,const char *);"
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10259:
    .ascii    "/* Header limits.h */"
    .byte     10
    .byte     10
    .ascii    "#define CHAR_BIT 8"
    .byte     10
    .byte     10
    .ascii    "#define CHAR_MIN 0"
    .byte     10
    .ascii    "#define CHAR_MAX 255"
    .byte     10
    .byte     10
    .ascii    "#define UCHAR_MIN 0"
    .byte     10
    .ascii    "#define UCHAR_MAX 255"
    .byte     10
    .byte     10
    .ascii    "#define SCHAR_MIN -128"
    .byte     10
    .ascii    "#define SCHAR_MAX 127"
    .byte     10
    .byte     10
    .ascii    "#define SHRT_MIN -32768"
    .byte     10
    .ascii    "#define SHRT_MAX 32767"
    .byte     10
    .byte     10
    .ascii    "#define USHRT_MIN 0"
    .byte     10
    .ascii    "#define USHRT_MAX 65535"
    .byte     10
    .byte     10
    .ascii    "#define INT_MIN -2147483648"
    .byte     10
    .ascii    "#define INT_MAX  2147483647"
    .byte     10
    .byte     10
    .ascii    "#define UINT_MIN 0"
    .byte     10
    .ascii    "#define UINT_MAX 4294967295"
    .byte     10
    .byte     10
    .ascii    "#define LONG_MIN -2147483648"
    .byte     10
    .ascii    "#define LONG_MAX  2147483647"
    .byte     10
    .byte     10
    .ascii    "#define ULONG_MIN 0"
    .byte     10
    .ascii    "#define ULONG_MAX 4294967295"
    .byte     10
    .byte     10
    .ascii    "#define LLONG_MIN -9223372036854775808LL"
    .byte     10
    .ascii    "#define LLONG_MAX  9223372036854775807LL"
    .byte     10
    .byte     10
    .ascii    "#define ULLONG_MIN 0"
    .byte     10
    .ascii    "#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFLL"
    .byte     10
    .byte     10
    .ascii    "#define SIZE_MAX ULLONG_MAX"
    .byte     10
    .byte     0
L10258:
    .ascii    "/* Header stdint.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $stdint"
    .byte     13
    .byte     10
    .ascii    "#define $stdint"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef signed char int8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef short int16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef int int32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long int int64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef unsigned char uint8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short uint16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int uint32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long int uint64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef long long int intptr_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long int uintptr_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long intmax_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long uintmax_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef char int_least8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned char uint_least8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef short int_least16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short uint_least16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef int int_least32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int uint_least32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long int_least64_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long uint_least64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INTMAX_C(a) (a##LL)"
    .byte     13
    .byte     10
    .ascii    "#define UINTMAX_C(a) (a##ULL)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "typedef char int_fast8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned char uint_fast8_t;"
    .byte     13
    .byte     10
    .ascii    "typedef short int_fast16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned short uint_fast16_t;"
    .byte     13
    .byte     10
    .ascii    "typedef int int_fast32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned int uint_fast32_t;"
    .byte     13
    .byte     10
    .ascii    "typedef long long int_fast64_t;"
    .byte     13
    .byte     10
    .ascii    "typedef unsigned long long uint_fast64_t;"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INT8_MIN -128"
    .byte     13
    .byte     10
    .ascii    "#define INT8_MAX 127"
    .byte     13
    .byte     10
    .ascii    "#define INT16_MIN -32768"
    .byte     13
    .byte     10
    .ascii    "#define INT16_MAX 32767"
    .byte     13
    .byte     10
    .ascii    "#define INT32_MIN 0x80000000"
    .byte     13
    .byte     10
    .ascii    "#define INT32_MAX 0x7FFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define INT64_MIN 0x8000000000000000"
    .byte     13
    .byte     10
    .ascii    "#define INT64_MAX 0x7FFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define UINT8_MAX 255"
    .byte     13
    .byte     10
    .ascii    "#define UINT16_MAX 65535"
    .byte     13
    .byte     10
    .ascii    "#define UINT32_MAX 0xFFFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define UINT64_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define INTPTR_MIN 0x8000000000000000"
    .byte     13
    .byte     10
    .ascii    "#define INTPTR_MAX 0x7FFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define UINTPTR_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define UINT64_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .ascii    "#define SIZE_MAX 0xFFFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PTRDIFF_MIN 0x8000000000000000"
    .byte     13
    .byte     10
    .ascii    "#define PTRDIFF_MAX 0x7FFFFFFFFFFFFFFF"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WCHAR_MIN 0"
    .byte     13
    .byte     10
    .ascii    "#define WCHAR_MAX 65535"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define WINT_MIN 0"
    .byte     13
    .byte     10
    .ascii    "#define WINT_MAX 65535"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define UINT64_C(x) (x##ull)"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10257:
    .ascii    "/* Header inttypes.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#include <stdint.h>"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* fprintf macros for signed types */"
    .byte     13
    .byte     10
    .ascii    "#define PRId8 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRId16 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRId32 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRId64 "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST8 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST16 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST32 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdLEAST64 "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST8 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST16 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST32 "
    .byte     34
    .ascii    "d"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIdFAST64 "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIdMAX "
    .byte     34
    .ascii    "I64d"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIi8 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIi16 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIi32 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIi64 "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST8 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST16 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST32 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiLEAST64 "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST8 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST16 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST32 "
    .byte     34
    .ascii    "i"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIiFAST64 "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIiMAX "
    .byte     34
    .ascii    "I64i"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIo8 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIo16 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIo32 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIo64 "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST8 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST16 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST32 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoLEAST64 "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST8 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST16 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST32 "
    .byte     34
    .ascii    "o"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIoFAST64 "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIoMAX "
    .byte     34
    .ascii    "I64o"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "/* fprintf macros for unsigned types */"
    .byte     13
    .byte     10
    .ascii    "#define PRIu8 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIu16 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIu32 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIu64 "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST8 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST16 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST32 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuLEAST64 "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST8 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST16 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST32 "
    .byte     34
    .ascii    "u"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIuFAST64 "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIuMAX "
    .byte     34
    .ascii    "I64u"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIx8 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIx16 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIx32 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIx64 "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST8 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST16 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST32 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxLEAST64 "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST8 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST16 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST32 "
    .byte     34
    .ascii    "x"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIxFAST64 "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIxMAX "
    .byte     34
    .ascii    "I64x"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIX8 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIX16 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIX32 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIX64 "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST8 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST16 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST32 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXLEAST64 "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST8 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST16 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST32 "
    .byte     34
    .ascii    "X"
    .byte     34
    .byte     13
    .byte     10
    .ascii    "#define PRIXFAST64 "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define PRIXMAX "
    .byte     34
    .ascii    "I64X"
    .byte     34
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .byte     0
L10256:
    .ascii    "/* Header float.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MAX_10_EXP 308"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MANT_DIG 53"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define FLT_RADIX 2"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define FLT_DIG 6"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN_EXP -125"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN 1.17549435E-38F // decimal constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN 0X1P-126F // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_TRUE_MIN 1.40129846E-45F // decimal constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_TRUE_MIN 0X1P-149F // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_HAS_SUBNORM 1"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MIN_10_EXP -37"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX_EXP +128"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX 3.40282347E+38F // decimal constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX 0X1.fffffeP127F // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MAX_10_EXP +38"
    .byte     13
    .byte     10
    .ascii    "#define FLT_EPSILON 1.19209290e-07F"
    .byte     13
    .byte     10
    .ascii    "#define FLT_MANT_DIG 23"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define DBL_MANT_DIG 53"
    .byte     13
    .byte     10
    .ascii    "#define DBL_EPSILON 2.2204460492503131E-16 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_EPSILON 0X1P-52 // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define DBL_DECIMAL_DIG 17"
    .byte     13
    .byte     10
    .ascii    "#define DBL_DIG 15"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MIN_EXP -1021"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MIN 2.2250738585072014E-308 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MIN 0X1P-1022 // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define DBL_TRUE_MIN 4.9406564584124654E-324 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_TRUE_MIN 0X1P-1074 // hex constant"
    .byte     13
    .byte     10
    .ascii    "#define DBL_HAS_SUBNORM 1"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MIN_10_EXP -307"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MAX_EXP +1024"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MAX 1.7976931348623157E+308 // decimal constant"
    .byte     13
    .byte     10
    .ascii    "//#define DBL_MAX 0X1.fffffffffffffP1023 // h"
    .byte     13
    .byte     10
    .ascii    "#define DBL_MAX_10_EXP +308"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MIN DBL_MIN"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MAX DBL_MAX"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_EPSILON 2.2204460492503131E-16"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MANT_DIG 53"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MIN_EXP -1021"
    .byte     13
    .byte     10
    .ascii    "#define LDBL_MAX_EXP +1024"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int     _isnan(double);"
    .byte     13
    .byte     10
    .ascii    "#define isnan _isnan"
    .byte     13
    .byte     10
    .byte     0
L10255:
    .ascii    "/* Header fenv.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int feclearexcept(int);"
    .byte     13
    .byte     10
    .ascii    "int fetestexcept(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define FE_INVALID 1"
    .byte     13
    .byte     10
    .ascii    "#define FE_DENORMAL 2"
    .byte     13
    .byte     10
    .ascii    "#define FE_INEXACT 32"
    .byte     13
    .byte     10
    .ascii    "#define FE_DIVBYZERO 4 "
    .byte     13
    .byte     10
    .ascii    "#define FE_OVERFLOW 8"
    .byte     13
    .byte     10
    .ascii    "#define FE_UNDERFLOW 16"
    .byte     13
    .byte     10
    .ascii    "#define FE_STACKFAULT 64"
    .byte     13
    .byte     10
    .ascii    "#define FE_ALL_EXCEPT (FE_INVALID|FE_DENORMAL|FE_INEXACT|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW)"
    .byte     13
    .byte     10
    .byte     0
L10254:
    .ascii    "/* Header errno.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#ifndef $errno"
    .byte     13
    .byte     10
    .ascii    "#define $errno"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "extern int* _errno(void);"
    .byte     13
    .byte     10
    .ascii    "#define errno (*_errno())"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#define EPERM 1"
    .byte     13
    .byte     10
    .ascii    "#define ENOENT 2"
    .byte     13
    .byte     10
    .ascii    "#define ESRCH 3"
    .byte     13
    .byte     10
    .ascii    "#define EINTR 4"
    .byte     13
    .byte     10
    .ascii    "#define EIO 5"
    .byte     13
    .byte     10
    .ascii    "#define ENXIO 6"
    .byte     13
    .byte     10
    .ascii    "#define E2BIG 7"
    .byte     13
    .byte     10
    .ascii    "#define ENOEXEC 8"
    .byte     13
    .byte     10
    .ascii    "#define EBADF 9"
    .byte     13
    .byte     10
    .ascii    "#define ECHILD 10"
    .byte     13
    .byte     10
    .ascii    "#define EAGAIN 11"
    .byte     13
    .byte     10
    .ascii    "#define ENOMEM 12"
    .byte     13
    .byte     10
    .ascii    "#define EACCES 13"
    .byte     13
    .byte     10
    .ascii    "#define EFAULT 14"
    .byte     13
    .byte     10
    .ascii    "#define ENOTBLK 15"
    .byte     13
    .byte     10
    .ascii    "#define EBUSY 16"
    .byte     13
    .byte     10
    .ascii    "#define EEXIST 17"
    .byte     13
    .byte     10
    .ascii    "#define EXDEV 18"
    .byte     13
    .byte     10
    .ascii    "#define ENODEV 19"
    .byte     13
    .byte     10
    .ascii    "#define ENOTDIR 20"
    .byte     13
    .byte     10
    .ascii    "#define EISDIR 21"
    .byte     13
    .byte     10
    .ascii    "#define EINVAL 22"
    .byte     13
    .byte     10
    .ascii    "#define ENFILE 23"
    .byte     13
    .byte     10
    .ascii    "#define EMFILE 24"
    .byte     13
    .byte     10
    .ascii    "#define ENOTTY 25"
    .byte     13
    .byte     10
    .ascii    "#define ETXTBSY 26"
    .byte     13
    .byte     10
    .ascii    "#define EFBIG 27"
    .byte     13
    .byte     10
    .ascii    "#define ENOSPC 28"
    .byte     13
    .byte     10
    .ascii    "#define ESPIPE 29"
    .byte     13
    .byte     10
    .ascii    "#define EROFS 30"
    .byte     13
    .byte     10
    .ascii    "#define EMLINK 31"
    .byte     13
    .byte     10
    .ascii    "#define EPIPE 32"
    .byte     13
    .byte     10
    .ascii    "#define EDOM 33"
    .byte     13
    .byte     10
    .ascii    "#define ERANGE 34"
    .byte     13
    .byte     10
    .ascii    "#define ENOMSG 35"
    .byte     13
    .byte     10
    .ascii    "#define EIDRM 36"
    .byte     13
    .byte     10
    .ascii    "#define ECHRNG 37"
    .byte     13
    .byte     10
    .ascii    "#define EL2NSYNC 38"
    .byte     13
    .byte     10
    .ascii    "#define EL3HLT 39"
    .byte     13
    .byte     10
    .ascii    "#define EL3RST 40"
    .byte     13
    .byte     10
    .ascii    "#define ELNRNG 41"
    .byte     13
    .byte     10
    .ascii    "#define EUNATCH 42"
    .byte     13
    .byte     10
    .ascii    "#define ENOCSI 43"
    .byte     13
    .byte     10
    .ascii    "#define EL2HLT 44"
    .byte     13
    .byte     10
    .ascii    "#define EDEADLK 45"
    .byte     13
    .byte     10
    .ascii    "#define ENOLCK 46"
    .byte     13
    .byte     10
    .ascii    "#define EBADE 50"
    .byte     13
    .byte     10
    .ascii    "#define EBADR 51"
    .byte     13
    .byte     10
    .ascii    "#define EXFULL 52"
    .byte     13
    .byte     10
    .ascii    "#define ENOANO 53"
    .byte     13
    .byte     10
    .ascii    "#define EBADRQC 54"
    .byte     13
    .byte     10
    .ascii    "#define EBADSLT 55"
    .byte     13
    .byte     10
    .ascii    "#define EDEADLOCK 56"
    .byte     13
    .byte     10
    .ascii    "#define EBFONT 57"
    .byte     13
    .byte     10
    .ascii    "#define ENOSTR 60"
    .byte     13
    .byte     10
    .ascii    "#define ENODATA 61"
    .byte     13
    .byte     10
    .ascii    "#define ETIME 62"
    .byte     13
    .byte     10
    .ascii    "#define ENOSR 63"
    .byte     13
    .byte     10
    .ascii    "#define ENONET 64"
    .byte     13
    .byte     10
    .ascii    "#define ENOPKG 65"
    .byte     13
    .byte     10
    .ascii    "#define EREMOTE 66"
    .byte     13
    .byte     10
    .ascii    "#define ENOLINK 67"
    .byte     13
    .byte     10
    .ascii    "#define EADV 68"
    .byte     13
    .byte     10
    .ascii    "#define ESRMNT 69"
    .byte     13
    .byte     10
    .ascii    "#define ECOMM 70"
    .byte     13
    .byte     10
    .ascii    "#define EPROTO 71"
    .byte     13
    .byte     10
    .ascii    "#define EMULTIHOP 74"
    .byte     13
    .byte     10
    .ascii    "#define ELBIN 75"
    .byte     13
    .byte     10
    .ascii    "#define EOVERFLOW 76"
    .byte     13
    .byte     10
    .ascii    "#define EBADMSG 77"
    .byte     13
    .byte     10
    .ascii    "#define ENOTUNIQ 80"
    .byte     13
    .byte     10
    .ascii    "#define EBADFD 81"
    .byte     13
    .byte     10
    .ascii    "#define EREMCHG 82"
    .byte     13
    .byte     10
    .ascii    "#define ELIBACC 83"
    .byte     13
    .byte     10
    .ascii    "#define ELIBBAD 84"
    .byte     13
    .byte     10
    .ascii    "#define ELIBSCN 85"
    .byte     13
    .byte     10
    .ascii    "#define ELIBMAX 86"
    .byte     13
    .byte     10
    .ascii    "#define ELIBEXEC 87"
    .byte     13
    .byte     10
    .ascii    "#define ENOSYS 88"
    .byte     13
    .byte     10
    .ascii    "#define ENMFILE 89"
    .byte     13
    .byte     10
    .ascii    "#define ENOTEMPTY 90"
    .byte     13
    .byte     10
    .ascii    "#define ENAMETOOLONG 91"
    .byte     13
    .byte     10
    .ascii    "#define EILSEQ 92"
    .byte     13
    .byte     10
    .ascii    "#define __ELASTERROR 2000"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "#endif"
    .byte     13
    .byte     10
    .byte     0
L10253:
    .ascii    "/* Header ctype.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int tolower(int);"
    .byte     13
    .byte     10
    .ascii    "int toupper(int);"
    .byte     13
    .byte     10
    .ascii    "int isalpha(int);"
    .byte     13
    .byte     10
    .ascii    "int isdigit(int);"
    .byte     13
    .byte     10
    .ascii    "int isspace(int);"
    .byte     13
    .byte     10
    .ascii    "int isalnum(int);"
    .byte     13
    .byte     10
    .ascii    "int isupper(int);"
    .byte     13
    .byte     10
    .ascii    "int islower(int);"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int isxdigit(int);"
    .byte     13
    .byte     10
    .ascii    "int iscntrl(int);"
    .byte     13
    .byte     10
    .ascii    "int isgraph(int);"
    .byte     13
    .byte     10
    .ascii    "int ispunct(int);"
    .byte     13
    .byte     10
    .ascii    "int isprint(int);"
    .byte     13
    .byte     10
    .ascii    "int __isascii(int);"
    .byte     13
    .byte     10
    .ascii    "#define isascii __isascii"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "int __toascii(int);"
    .byte     13
    .byte     10
    .ascii    "#define toascii __toascii"
    .byte     13
    .byte     10
    .byte     0
L10252:
    .ascii    "/* Header assert.h */"
    .byte     13
    .byte     10
    .byte     13
    .byte     10
    .ascii    "//#define assert(x) 0"
    .byte     13
    .byte     10
    .ascii    "#define assert(x)"
    .byte     13
    .byte     10
    .byte     0
L10251:
    .ascii    "stderr"
    .byte     0
L10250:
    .ascii    "stdout"
    .byte     0
L10249:
    .ascii    "stdin"
    .byte     0
L10248:
    .ascii    "Dec"
    .byte     0
L10247:
    .ascii    "Nov"
    .byte     0
L10246:
    .ascii    "Oct"
    .byte     0
L10245:
    .ascii    "Sep"
    .byte     0
L10244:
    .ascii    "Aug"
    .byte     0
L10243:
    .ascii    "Jul"
    .byte     0
L10242:
    .ascii    "Jun"
    .byte     0
L10241:
    .ascii    "May"
    .byte     0
L10240:
    .ascii    "Apr"
    .byte     0
L10239:
    .ascii    "Mar"
    .byte     0
L10238:
    .ascii    "Feb"
    .byte     0
L10237:
    .ascii    "Jan"
    .byte     0
L10236:
    .ascii    "bool_c"
    .byte     0
L10235:
    .ascii    "truncate_c"
    .byte     0
L10234:
    .ascii    "narrow_c"
    .byte     0
L10233:
    .ascii    "fnarrow_c"
    .byte     0
L10232:
    .ascii    "fwiden_c"
    .byte     0
L10231:
    .ascii    "ufix_c"
    .byte     0
L10230:
    .ascii    "sfix_c"
    .byte     0
L10229:
    .ascii    "ufloat_c"
    .byte     0
L10228:
    .ascii    "sfloat_c"
    .byte     0
L10227:
    .ascii    "uwiden_c"
    .byte     0
L10226:
    .ascii    "swiden_c"
    .byte     0
L10225:
    .ascii    "hard_c"
    .byte     0
L10224:
    .ascii    "soft_c"
    .byte     0
L10223:
    .ascii    "no_conv"
    .byte     0
L10222:
    .ascii    "$$dummy"
    .byte     0
L10221:
    .ascii    "$longjmp"
    .byte     0
L10220:
    .ascii    "$setjmp"
    .byte     0
L10219:
    .ascii    "_Alignof"
    .byte     0
L10218:
    .ascii    "_Generic"
    .byte     0
L10217:
    .ascii    "defined"
    .byte     0
L10216:
    .ascii    "lengthof"
    .byte     0
L10215:
    .ascii    "sizeof"
    .byte     0
L10214:
    .ascii    "__FUNCTION__"
    .byte     0
L10213:
    .ascii    "__func__"
    .byte     0
L10212:
    .ascii    "__MCCI__"
    .byte     0
L10211:
    .ascii    "__MCC__"
    .byte     0
L10210:
    .ascii    "__TIME__"
    .byte     0
L10209:
    .ascii    "__LINE__"
    .byte     0
L10208:
    .ascii    "__FILE__"
    .byte     0
L10207:
    .ascii    "__DATE__"
    .byte     0
L10206:
    .ascii    "_Bool"
    .byte     0
L10205:
    .ascii    "unsigned"
    .byte     0
L10204:
    .ascii    "signed"
    .byte     0
L10203:
    .ascii    "double"
    .byte     0
L10202:
    .ascii    "float"
    .byte     0
L10201:
    .ascii    "int"
    .byte     0
L10200:
    .ascii    "long"
    .byte     0
L10199:
    .ascii    "short"
    .byte     0
L10198:
    .ascii    "char"
    .byte     0
L10197:
    .ascii    "void"
    .byte     0
L10196:
    .ascii    "enum"
    .byte     0
L10195:
    .ascii    "_Alignas"
    .byte     0
L10194:
    .ascii    "_Noreturn"
    .byte     0
L10193:
    .ascii    "inline"
    .byte     0
L10192:
    .ascii    "_Atomic"
    .byte     0
L10191:
    .ascii    "restrict"
    .byte     0
L10190:
    .ascii    "volatile"
    .byte     0
L10189:
    .ascii    "const"
    .byte     0
L10188:
    .ascii    "typedef"
    .byte     0
L10187:
    .ascii    "extern"
    .byte     0
L10186:
    .ascii    "static"
    .byte     0
L10185:
    .ascii    "register"
    .byte     0
L10184:
    .ascii    "auto"
    .byte     0
L10183:
    .ascii    "line"
    .byte     0
L10182:
    .ascii    "pragma"
    .byte     0
L10181:
    .ascii    "error"
    .byte     0
L10180:
    .ascii    "undef"
    .byte     0
L10179:
    .ascii    "endif"
    .byte     0
L10178:
    .ascii    "ifndef"
    .byte     0
L10177:
    .ascii    "ifdef"
    .byte     0
L10176:
    .ascii    "elif"
    .byte     0
L10175:
    .ascii    "define"
    .byte     0
L10174:
    .ascii    "include"
    .byte     0
L10173:
    .ascii    "union"
    .byte     0
L10172:
    .ascii    "struct"
    .byte     0
L10171:
    .ascii    "switch"
    .byte     0
L10170:
    .ascii    "goto"
    .byte     0
L10169:
    .ascii    "continue"
    .byte     0
L10168:
    .ascii    "break"
    .byte     0
L10167:
    .ascii    "return"
    .byte     0
L10166:
    .ascii    "while"
    .byte     0
L10165:
    .ascii    "do"
    .byte     0
L10164:
    .ascii    "for"
    .byte     0
L10163:
    .ascii    "default"
    .byte     0
L10162:
    .ascii    "case"
    .byte     0
L10161:
    .ascii    "else"
    .byte     0
L10160:
    .ascii    "if"
    .byte     0
L10159:
    .ascii    "labelid"
    .byte     0
L10158:
    .ascii    "structtagid"
    .byte     0
L10157:
    .ascii    "enumtagid"
    .byte     0
L10156:
    .ascii    "enumid"
    .byte     0
L10155:
    .ascii    "fieldid"
    .byte     0
L10154:
    .ascii    "paramid"
    .byte     0
L10153:
    .ascii    "frameid"
    .byte     0
L10152:
    .ascii    "staticid"
    .byte     0
L10151:
    .ascii    "procid"
    .byte     0
L10150:
    .ascii    "typeid"
    .byte     0
L10149:
    .ascii    "extmoduleid"
    .byte     0
L10148:
    .ascii    "moduleid"
    .byte     0
L10147:
    .ascii    "programid"
    .byte     0
L10146:
    .ascii    "macroid"
    .byte     0
L10145:
    .ascii    "nullid"
    .byte     0
L10144:
    .ascii    "ns_fields"
    .byte     0
L10143:
    .ascii    "ns_labels"
    .byte     0
L10142:
    .ascii    "ns_tags"
    .byte     0
L10141:
    .ascii    "ns_general"
    .byte     0
L10140:
    .ascii    "ns_none"
    .byte     0
L10139:
    .ascii    "pragmadir"
    .byte     0
L10138:
    .ascii    "linedir"
    .byte     0
L10137:
    .ascii    "blankdir"
    .byte     0
L10136:
    .ascii    "messagedir"
    .byte     0
L10135:
    .ascii    "errordir"
    .byte     0
L10134:
    .ascii    "undefdir"
    .byte     0
L10133:
    .ascii    "ifndefdir"
    .byte     0
L10132:
    .ascii    "ifdefdir"
    .byte     0
L10131:
    .ascii    "includedir"
    .byte     0
L10130:
    .ascii    "endifdir"
    .byte     0
L10129:
    .ascii    "elsedir"
    .byte     0
L10128:
    .ascii    "elifdir"
    .byte     0
L10127:
    .ascii    "ifdir"
    .byte     0
L10126:
    .ascii    "emitdir"
    .byte     0
L10125:
    .ascii    "definedir"
    .byte     0
L10124:
    .byte     0
L10123:
    .ascii    "k"
    .byte     0
L10122:
    .byte     0
L10121:
    .ascii    "w"
    .byte     0
L10120:
    .ascii    "s"
    .byte     0
L10119:
    .ascii    "n"
    .byte     0
L10118:
    .byte     0
L10117:
    .ascii    ">>="
    .byte     0
L10116:
    .ascii    "<<="
    .byte     0
L10115:
    .ascii    "^="
    .byte     0
L10114:
    .ascii    "&="
    .byte     0
L10113:
    .ascii    "|="
    .byte     0
L10112:
    .ascii    "%="
    .byte     0
L10111:
    .ascii    "/="
    .byte     0
L10110:
    .ascii    "*="
    .byte     0
L10109:
    .ascii    "-="
    .byte     0
L10108:
    .ascii    "+="
    .byte     0
L10107:
    .ascii    ">"
    .byte     0
L10106:
    .ascii    ">="
    .byte     0
L10105:
    .ascii    "<="
    .byte     0
L10104:
    .ascii    "<"
    .byte     0
L10103:
    .ascii    "!="
    .byte     0
L10102:
    .ascii    "=="
    .byte     0
L10101:
    .ascii    "abs"
    .byte     0
L10100:
    .ascii    "--"
    .byte     0
L10099:
    .ascii    "++"
    .byte     0
L10098:
    .ascii    "!"
    .byte     0
L10097:
    .ascii    "~"
    .byte     0
L10096:
    .ascii    ">>"
    .byte     0
L10095:
    .ascii    "<<"
    .byte     0
L10094:
    .ascii    "&&"
    .byte     0
L10093:
    .ascii    "||"
    .byte     0
L10092:
    .ascii    "^"
    .byte     0
L10091:
    .ascii    "&"
    .byte     0
L10090:
    .ascii    "|"
    .byte     0
L10089:
    .ascii    "%"
    .byte     0
L10088:
    .ascii    "/"
    .byte     0
L10087:
    .ascii    "*"
    .byte     0
L10086:
    .ascii    "-"
    .byte     0
L10085:
    .ascii    "+"
    .byte     0
L10084:
    .byte     92
    .byte     0
L10083:
    .ascii    "..."
    .byte     0
L10082:
    .ascii    "~"
    .byte     0
L10081:
    .ascii    "?"
    .byte     0
L10080:
    .ascii    "}"
    .byte     0
L10079:
    .ascii    "{"
    .byte     0
L10078:
    .ascii    "]"
    .byte     0
L10077:
    .ascii    "["
    .byte     0
L10076:
    .ascii    ")"
    .byte     0
L10075:
    .ascii    "("
    .byte     0
L10074:
    .ascii    ":="
    .byte     0
L10073:
    .ascii    "="
    .byte     0
L10072:
    .ascii    ":"
    .byte     0
L10071:
    .ascii    ";"
    .byte     0
L10070:
    .ascii    ","
    .byte     0
L10069:
    .ascii    "##"
    .byte     0
L10068:
    .ascii    "#"
    .byte     0
L10067:
    .ascii    "->"
    .byte     0
L10066:
    .ascii    "."
    .byte     0
L10065:
    .byte     0
L10064:
    .ascii    "kdummysym"
    .byte     0
L10063:
    .ascii    "ksetjmpsym"
    .byte     0
L10062:
    .ascii    "kalignofsym"
    .byte     0
L10061:
    .ascii    "kgenericsym"
    .byte     0
L10060:
    .ascii    "kdefinedsym"
    .byte     0
L10059:
    .ascii    "ksizeofsym"
    .byte     0
L10058:
    .ascii    "kenumsym"
    .byte     0
L10057:
    .ascii    "kalignassym"
    .byte     0
L10056:
    .ascii    "kfnspecsym"
    .byte     0
L10055:
    .ascii    "kstdtypesym"
    .byte     0
L10054:
    .ascii    "ktypequalsym"
    .byte     0
L10053:
    .ascii    "klinkagesym"
    .byte     0
L10052:
    .ascii    "kunionsym"
    .byte     0
L10051:
    .ascii    "kstructsym"
    .byte     0
L10050:
    .ascii    "kswitchsym"
    .byte     0
L10049:
    .ascii    "kgotosym"
    .byte     0
L10048:
    .ascii    "kcontinuesym"
    .byte     0
L10047:
    .ascii    "kbreaksym"
    .byte     0
L10046:
    .ascii    "kreturnsym"
    .byte     0
L10045:
    .ascii    "kdosym"
    .byte     0
L10044:
    .ascii    "kwhilesym"
    .byte     0
L10043:
    .ascii    "kforsym"
    .byte     0
L10042:
    .ascii    "kdefaultsym"
    .byte     0
L10041:
    .ascii    "kcasesym"
    .byte     0
L10040:
    .ascii    "kelsesym"
    .byte     0
L10039:
    .ascii    "kifsym"
    .byte     0
L10038:
    .ascii    "ktypespecsym"
    .byte     0
L10037:
    .ascii    "predefmacrosym"
    .byte     0
L10036:
    .ascii    "ksourcedirsym"
    .byte     0
L10035:
    .ascii    "namesym"
    .byte     0
L10034:
    .ascii    "placeholdersym"
    .byte     0
L10033:
    .ascii    "whitespacesym"
    .byte     0
L10032:
    .ascii    "wstringconstsym"
    .byte     0
L10031:
    .ascii    "stringconstsym"
    .byte     0
L10030:
    .ascii    "wcharconstsym"
    .byte     0
L10029:
    .ascii    "charconstsym"
    .byte     0
L10028:
    .ascii    "realconstsym"
    .byte     0
L10027:
    .ascii    "intconstsym"
    .byte     0
L10026:
    .ascii    "rawnumbersym"
    .byte     0
L10025:
    .ascii    "eofsym"
    .byte     0
L10024:
    .ascii    "eolsym"
    .byte     0
L10023:
    .ascii    "shrtosym"
    .byte     0
L10022:
    .ascii    "shltosym"
    .byte     0
L10021:
    .ascii    "ixortosym"
    .byte     0
L10020:
    .ascii    "iandtosym"
    .byte     0
L10019:
    .ascii    "iortosym"
    .byte     0
L10018:
    .ascii    "remtosym"
    .byte     0
L10017:
    .ascii    "divtosym"
    .byte     0
L10016:
    .ascii    "multosym"
    .byte     0
L10015:
    .ascii    "subtosym"
    .byte     0
L10014:
    .ascii    "addtosym"
    .byte     0
L10013:
    .ascii    "gtsym"
    .byte     0
L10012:
    .ascii    "gesym"
    .byte     0
L10011:
    .ascii    "lesym"
    .byte     0
L10010:
    .ascii    "ltsym"
    .byte     0
L10009:
    .ascii    "nesym"
    .byte     0
L10008:
    .ascii    "eqsym"
    .byte     0
L10007:
    .ascii    "abssym"
    .byte     0
L10006:
    .ascii    "decrsym"
    .byte     0
L10005:
    .ascii    "incrsym"
    .byte     0
L10004:
    .ascii    "notlsym"
    .byte     0
L10003:
    .ascii    "inotsym"
    .byte     0
L10002:
    .ascii    "shrsym"
    .byte     0
L10001:
    .ascii    "shlsym"
    .byte     0
L10000:
    .ascii    "andlsym"
    .byte     0
L9999:
    .ascii    "orlsym"
    .byte     0
L9998:
    .ascii    "ixorsym"
    .byte     0
L9997:
    .ascii    "iandsym"
    .byte     0
L9996:
    .ascii    "iorsym"
    .byte     0
L9995:
    .ascii    "remsym"
    .byte     0
L9994:
    .ascii    "divsym"
    .byte     0
L9993:
    .ascii    "mulsym"
    .byte     0
L9992:
    .ascii    "subsym"
    .byte     0
L9991:
    .ascii    "addsym"
    .byte     0
L9990:
    .ascii    "backslashsym"
    .byte     0
L9989:
    .ascii    "ellipsissym"
    .byte     0
L9988:
    .ascii    "curlsym"
    .byte     0
L9987:
    .ascii    "questionsym"
    .byte     0
L9986:
    .ascii    "rcurlysym"
    .byte     0
L9985:
    .ascii    "lcurlysym"
    .byte     0
L9984:
    .ascii    "rsqsym"
    .byte     0
L9983:
    .ascii    "lsqsym"
    .byte     0
L9982:
    .ascii    "rbracksym"
    .byte     0
L9981:
    .ascii    "lbracksym"
    .byte     0
L9980:
    .ascii    "assignsym2"
    .byte     0
L9979:
    .ascii    "assignsym"
    .byte     0
L9978:
    .ascii    "colonsym"
    .byte     0
L9977:
    .ascii    "semisym"
    .byte     0
L9976:
    .ascii    "commasym"
    .byte     0
L9975:
    .ascii    "hashhashsym"
    .byte     0
L9974:
    .ascii    "lithashsym"
    .byte     0
L9973:
    .ascii    "hashsym"
    .byte     0
L9972:
    .ascii    "lexhashsym"
    .byte     0
L9971:
    .ascii    "idotsym"
    .byte     0
L9970:
    .ascii    "dotsym"
    .byte     0
L9969:
    .ascii    "errorsym"
    .byte     0
L9968:
    .ascii    "jdummy"
    .byte     0
L9967:
    .ascii    "longjmp"
    .byte     0
L9966:
    .ascii    "setjmp"
    .byte     0
L9965:
    .ascii    "-- postdecr"
    .byte     0
L9964:
    .ascii    "++ postincr"
    .byte     0
L9963:
    .ascii    "-- preincr"
    .byte     0
L9962:
    .ascii    "++ preincr"
    .byte     0
L9961:
    .ascii    ">>="
    .byte     0
L9960:
    .ascii    "<<="
    .byte     0
L9959:
    .ascii    "^="
    .byte     0
L9958:
    .ascii    "|="
    .byte     0
L9957:
    .ascii    "&="
    .byte     0
L9956:
    .ascii    "%="
    .byte     0
L9955:
    .ascii    "/="
    .byte     0
L9954:
    .ascii    "*="
    .byte     0
L9953:
    .ascii    "-="
    .byte     0
L9952:
    .ascii    "+="
    .byte     0
L9951:
    .ascii    "~ inot"
    .byte     0
L9950:
    .ascii    "abs"
    .byte     0
L9949:
    .ascii    "- neg"
    .byte     0
L9948:
    .ascii    "jscale"
    .byte     0
L9947:
    .ascii    "jconvert"
    .byte     0
L9946:
    .ascii    "addrof &"
    .byte     0
L9945:
    .ascii    "subptr"
    .byte     0
L9944:
    .ascii    "addptr"
    .byte     0
L9943:
    .ascii    "ptr"
    .byte     0
L9942:
    .ascii    "jindex"
    .byte     0
L9941:
    .ascii    "jidot"
    .byte     0
L9940:
    .ascii    "jdot"
    .byte     0
L9939:
    .ascii    ">>"
    .byte     0
L9938:
    .ascii    "<<"
    .byte     0
L9937:
    .ascii    "^ ixor"
    .byte     0
L9936:
    .ascii    "| ior"
    .byte     0
L9935:
    .ascii    "& iand"
    .byte     0
L9934:
    .ascii    "% mod"
    .byte     0
L9933:
    .ascii    "/ div"
    .byte     0
L9932:
    .ascii    "* mul"
    .byte     0
L9931:
    .ascii    "- sub"
    .byte     0
L9930:
    .ascii    "+ add"
    .byte     0
L9929:
    .ascii    ">="
    .byte     0
L9928:
    .ascii    ">"
    .byte     0
L9927:
    .ascii    "<="
    .byte     0
L9926:
    .ascii    "<"
    .byte     0
L9925:
    .ascii    "!="
    .byte     0
L9924:
    .ascii    "=="
    .byte     0
L9923:
    .ascii    "&&"
    .byte     0
L9922:
    .ascii    "jifx"
    .byte     0
L9921:
    .ascii    "jcallfn"
    .byte     0
L9920:
    .ascii    "jexprlist"
    .byte     0
L9919:
    .ascii    "jmakelist"
    .byte     0
L9918:
    .ascii    "jistruel"
    .byte     0
L9917:
    .ascii    "! notl"
    .byte     0
L9916:
    .ascii    "|| orl"
    .byte     0
L9915:
    .ascii    "&& andl"
    .byte     0
L9914:
    .ascii    "jbreaksw"
    .byte     0
L9913:
    .ascii    "jswitch"
    .byte     0
L9912:
    .ascii    "jcontinue"
    .byte     0
L9911:
    .ascii    "jbreak"
    .byte     0
L9910:
    .ascii    "jdefaultstmt"
    .byte     0
L9909:
    .ascii    "jcasestmt"
    .byte     0
L9908:
    .ascii    "jlabelstmt"
    .byte     0
L9907:
    .ascii    "jgoto"
    .byte     0
L9906:
    .ascii    "jdowhile"
    .byte     0
L9905:
    .ascii    "jwhile"
    .byte     0
L9904:
    .ascii    "jfor"
    .byte     0
L9903:
    .ascii    "jif"
    .byte     0
L9902:
    .ascii    "jassign"
    .byte     0
L9901:
    .ascii    "jreturnx"
    .byte     0
L9900:
    .ascii    "jreturn"
    .byte     0
L9899:
    .ascii    "jdecl"
    .byte     0
L9898:
    .ascii    "jtempdecl"
    .byte     0
L9897:
    .ascii    "jblock"
    .byte     0
L9896:
    .ascii    "jfuncname"
    .byte     0
L9895:
    .ascii    "jwidenmem"
    .byte     0
L9894:
    .ascii    "jname"
    .byte     0
L9893:
    .ascii    "jnull"
    .byte     0
L9892:
    .ascii    "jconst"
    .byte     0
L9891:
    .ascii    "jnone"
    .byte     0
L9890:
    .ascii    "callback_fnspec"
    .byte     0
L9889:
    .ascii    "noreturn_fnspec"
    .byte     0
L9888:
    .ascii    "inline_fnspec"
    .byte     0
L9887:
    .ascii    "atomic_qual"
    .byte     0
L9886:
    .ascii    "restrict_qual"
    .byte     0
L9885:
    .ascii    "volatile_qual"
    .byte     0
L9884:
    .ascii    "const_qual"
    .byte     0
L9883:
    .ascii    "typedef_ss"
    .byte     0
L9882:
    .ascii    "extern_ss"
    .byte     0
L9881:
    .ascii    "register_ss"
    .byte     0
L9880:
    .ascii    "auto_ss"
    .byte     0
L9879:
    .ascii    "static_ss"
    .byte     0
L9878:
    .ascii    "none_ss"
    .byte     0
L9877:
    .ascii    "dummy_cc"
    .byte     0
L9876:
    .ascii    "callback_cc"
    .byte     0
L9875:
    .ascii    "stdcall_cc"
    .byte     0
L9874:
    .ascii    "clang_cc"
    .byte     0
L9873:
    .ascii    "own_cc"
    .byte     0
L9872:
    .ascii    "open_cc"
    .byte     0
L9871:
    .ascii    "Exp"
    .byte     0
L9870:
    .ascii    "Imp"
    .byte     0
L9869:
    .ascii    "Loc"
    .byte     0
L9868:
    .ascii    "Fn"
    .byte     0
L9867:
    .ascii    "-"
    .byte     0
L9866:
    .ascii    "pm_variadic"
    .byte     0
L9865:
    .ascii    "pm_empty"
    .byte     0
L9864:
    .ascii    "pm_notset"
    .byte     0
L9863:
    .ascii    "pm_normal"
    .byte     0
L9862:
    .ascii    "ts_atomic"
    .byte     0
L9861:
    .ascii    "ts_enum"
    .byte     0
L9860:
    .ascii    "ts_union"
    .byte     0
L9859:
    .ascii    "ts_struct"
    .byte     0
L9858:
    .ascii    "ts_user"
    .byte     0
L9857:
    .ascii    "ts_bool"
    .byte     0
L9856:
    .ascii    "ts_unsigned"
    .byte     0
L9855:
    .ascii    "ts_signed"
    .byte     0
L9854:
    .ascii    "ts_double"
    .byte     0
L9853:
    .ascii    "ts_float"
    .byte     0
L9852:
    .ascii    "ts_int"
    .byte     0
L9851:
    .ascii    "ts_long"
    .byte     0
L9850:
    .ascii    "ts_short"
    .byte     0
L9849:
    .ascii    "ts_char"
    .byte     0
L9848:
    .ascii    "ts_void"
    .byte     0
L9847:
    .ascii    "blockcat"
    .byte     0
L9846:
    .ascii    "shortcat"
    .byte     0
L9845:
    .ascii    "realcat"
    .byte     0
L9844:
    .ascii    "intcat"
    .byte     0
L9843:
    .ascii    "voidcat"
    .byte     0
L9842:
    .ascii    "tlast"
    .byte     0
L9841:
    .ascii    "notset"
    .byte     0
L9840:
    .ascii    "union"
    .byte     0
L9839:
    .ascii    "struct"
    .byte     0
L9838:
    .ascii    "array"
    .byte     0
L9837:
    .ascii    "block"
    .byte     0
L9836:
    .ascii    "label"
    .byte     0
L9835:
    .ascii    "proc"
    .byte     0
L9834:
    .ascii    "ref"
    .byte     0
L9833:
    .ascii    "enum"
    .byte     0
L9832:
    .ascii    "r64"
    .byte     0
L9831:
    .ascii    "r32"
    .byte     0
L9830:
    .ascii    "u64"
    .byte     0
L9829:
    .ascii    "u32"
    .byte     0
L9828:
    .ascii    "u16"
    .byte     0
L9827:
    .ascii    "u8"
    .byte     0
L9826:
    .ascii    "bool"
    .byte     0
L9825:
    .ascii    "i64"
    .byte     0
L9824:
    .ascii    "i32"
    .byte     0
L9823:
    .ascii    "i16"
    .byte     0
L9822:
    .ascii    "i8"
    .byte     0
L9821:
    .ascii    "void"
    .byte     0
L9820:
    .ascii    "MCC"
    .byte     0
L9819:
    .ascii    "    The 'MCC' C Compiler comprises:"
    .byte     10
    .byte     10
    .ascii    "    mcc.exe            Compiles to .asm files"
    .byte     10
    .ascii    "    aa.exe             Assembles .asm files to .obj files"
    .byte     10
    .ascii    "                       Assemblers and links .asm/.dll files to .exe"
    .byte     10
    .ascii    "    Standard headers   A minimal set inside mcc.exe"
    .byte     10
    .ascii    "    windows.h          As a standalone file"
    .byte     10
    .byte     10
    .ascii    "    Input files:"
    .byte     10
    .byte     10
    .ascii    "      prog             This is prog.c as the extension is optional"
    .byte     10
    .ascii    "      prog.c"
    .byte     10
    .ascii    "      lib.dll          Include .dll library when generating .exe"
    .byte     10
    .ascii    "      @file            Read parameters and optons from given file"
    .byte     10
    .byte     10
    .ascii    "    Options:"
    .byte     10
    .byte     10
    .ascii    "      -exe             (DEFAULT) Compile all modules to one .exe file via .asm files"
    .byte     10
    .ascii    "      -e               Preprocess each module to .i file"
    .byte     10
    .ascii    "      -s               Compile each module to .asm file"
    .byte     10
    .ascii    "      -c               Compile each module .obj via .asm"
    .byte     10
    .byte     10
    .ascii    "      -out:file        Specify output file for -exe only"
    .byte     10
    .byte     10
    .ascii    "    For .exe output, it will be named based on the first input file. Otherwise"
    .byte     10
    .ascii    "    use -out option"
    .byte     10
    .byte     10
    .ascii    "    .obj files can be linked using gcc on Windows. This option is"
    .byte     10
    .ascii    "    needed to be able to generate .dll files. However, this will not"
    .byte     10
    .ascii    "    work on newer gcc versions because mcc's generated code is not position"
    .byte     10
    .ascii    "    independent, and will only work loaded in the low 2GB of address space."
    .byte     10
    .byte     10
    .ascii    "    Libraries msvcrt.dll, gdi32.dll, user32.dll and kernel32.dll are"
    .byte     10
    .ascii    "    automatically included as search libraries for imported functions."
    .byte     10
    .byte     10
    .ascii    "    Other kinds of binary libraries or files (.a, .lib, .obj etc) are not supported."
    .byte     10
    .byte     10
    .ascii    "    Omissions, Restrictions and Bugs (highlights only as there are dozens):"
    .byte     10
    .byte     10
    .ascii    "      * No VLAs, compound literals, designated initialisers"
    .byte     10
    .ascii    "      * Restrictions on complexity of data initialisers"
    .byte     10
    .byte     0
L9818:
    .ascii    "himem"
    .byte     0
L9817:
    .ascii    "norip"
    .byte     0
L9816:
    .ascii    "shortnames"
    .byte     0
L9815:
    .ascii    "stdout"
    .byte     0
L9814:
    .ascii    "o"
    .byte     0
L9813:
    .ascii    "writeheaders"
    .byte     0
L9812:
    .ascii    "ext"
    .byte     0
L9811:
    .ascii    "help"
    .byte     0
L9810:
    .ascii    "h"
    .byte     0
L9809:
    .ascii    "ss"
    .byte     0
L9808:
    .ascii    "cs"
    .byte     0
L9807:
    .ascii    "q"
    .byte     0
L9806:
    .ascii    "vv"
    .byte     0
L9805:
    .ascii    "v"
    .byte     0
L9804:
    .ascii    "time2"
    .byte     0
L9803:
    .ascii    "time"
    .byte     0
L9802:
    .ascii    "showfiles"
    .byte     0
L9801:
    .ascii    "showtypes"
    .byte     0
L9800:
    .ascii    "showss"
    .byte     0
L9799:
    .ascii    "showmcl"
    .byte     0
L9798:
    .ascii    "showpst"
    .byte     0
L9797:
    .ascii    "showpcl"
    .byte     0
L9796:
    .ascii    "showast"
    .byte     0
L9795:
    .ascii    "showstflat"
    .byte     0
L9794:
    .ascii    "showst"
    .byte     0
L9793:
    .ascii    "includes"
    .byte     0
L9792:
    .ascii    "incl"
    .byte     0
L9791:
    .ascii    "headers"
    .byte     0
L9790:
    .ascii    "paths"
    .byte     0
L9789:
    .ascii    "no"
    .byte     0
L9788:
    .ascii    "nopeep"
    .byte     0
L9787:
    .ascii    "noregs"
    .byte     0
L9786:
    .ascii    "r"
    .byte     0
L9785:
    .ascii    "exe"
    .byte     0
L9784:
    .ascii    "dll"
    .byte     0
L9783:
    .ascii    "mx"
    .byte     0
L9782:
    .ascii    "obj"
    .byte     0
L9781:
    .ascii    "c"
    .byte     0
L9780:
    .ascii    "a"
    .byte     0
L9779:
    .ascii    "s"
    .byte     0
L9778:
    .ascii    "mcl"
    .byte     0
L9777:
    .ascii    "i"
    .byte     0
L9776:
    .ascii    "pi"
    .byte     0
L9775:
    .ascii    "p"
    .byte     0
L9774:
    .ascii    "type"
    .byte     0
L9773:
    .ascii    "parse"
    .byte     0
L9772:
    .ascii    "ei"
    .byte     0
L9771:
    .ascii    "e"
    .byte     0
L9770:
    .ascii    "load"
    .byte     0
L9769:
    .ascii    "exe"
    .byte     0
L9768:
    .ascii    "(run)"
    .byte     0
L9767:
    .ascii    "exe"
    .byte     0
L9766:
    .ascii    "dll"
    .byte     0
L9765:
    .ascii    "obj"
    .byte     0
L9764:
    .ascii    "mx"
    .byte     0
L9763:
    .ascii    "asm"
    .byte     0
L9762:
    .ascii    "(int)"
    .byte     0
L9761:
    .ascii    "pcl"
    .byte     0
L9760:
    .byte     0
L9759:
    .ascii    "i"
    .byte     0
L9758:
    .byte     0
L9757:
    .ascii    "run_pass"
    .byte     0
L9756:
    .ascii    "exe_pass"
    .byte     0
L9755:
    .ascii    "dll_pass"
    .byte     0
L9754:
    .ascii    "obj_pass"
    .byte     0
L9753:
    .ascii    "mx_pass"
    .byte     0
L9752:
    .ascii    "asm_pass"
    .byte     0
L9751:
    .ascii    "mcl_pass"
    .byte     0
L9750:
    .ascii    "runpcl_pass"
    .byte     0
L9749:
    .ascii    "pcl_pass"
    .byte     0
L9748:
    .ascii    "type_pass"
    .byte     0
L9747:
    .ascii    "parse_pass"
    .byte     0
L9746:
    .ascii    "pp_pass"
    .byte     0
L9745:
    .ascii    "load_pass"
    .byte     0
L9744:
    .ascii    "impdata_rseg"
    .byte     0
L9743:
    .ascii    "rodata_rseg"
    .byte     0
L9742:
    .ascii    "zdata_rseg"
    .byte     0
L9741:
    .ascii    "idata_rseg"
    .byte     0
L9740:
    .ascii    "code_rseg"
    .byte     0
L9739:
    .ascii    "no_seg"
    .byte     0
L9738:
    .ascii    "imprel32"
    .byte     0
L9737:
    .ascii    "impabs64"
    .byte     0
L9736:
    .ascii    "impabs32"
    .byte     0
L9735:
    .ascii    "locabs64"
    .byte     0
L9734:
    .ascii    "locabs32"
    .byte     0
L9733:
    .ascii    "no_rel"
    .byte     0
L9732:
    .ascii    "end_dir"
    .byte     0
L9731:
    .ascii    "entry_dir"
    .byte     0
L9730:
    .ascii    "exportoffsets_dir"
    .byte     0
L9729:
    .ascii    "exportsegs_dir"
    .byte     0
L9728:
    .ascii    "exportsymbols_dir"
    .byte     0
L9727:
    .ascii    "importsymbols_dir"
    .byte     0
L9726:
    .ascii    "libs_dir"
    .byte     0
L9725:
    .ascii    "dlls_dir"
    .byte     0
L9724:
    .ascii    "reloc_dir"
    .byte     0
L9723:
    .ascii    "zdata_dir"
    .byte     0
L9722:
    .ascii    "idata_dir"
    .byte     0
L9721:
    .ascii    "code_dir"
    .byte     0
L9720:
    .ascii    "version_dir"
    .byte     0
L9719:
    .ascii    "pad_dir"
    .byte     0
L9718:
    .ascii    "asm"
    .byte     0
L9717:
    .ascii    "rel8_rel"
    .byte     0
L9716:
    .ascii    "rel321_rel"
    .byte     0
L9715:
    .ascii    "rel32_rel"
    .byte     0
L9714:
    .ascii    "addr32nb_rel"
    .byte     0
L9713:
    .ascii    "addr32_rel"
    .byte     0
L9712:
    .ascii    "addr64_rel"
    .byte     0
L9711:
    .ascii    "abs_rel"
    .byte     0
L9710:
    .ascii    "xmm15"
    .byte     0
L9709:
    .ascii    "xmm13"
    .byte     0
L9708:
    .ascii    "xmm12"
    .byte     0
L9707:
    .ascii    "xmm11"
    .byte     0
L9706:
    .ascii    "xmm10"
    .byte     0
L9705:
    .ascii    "xmm9"
    .byte     0
L9704:
    .ascii    "xmm8"
    .byte     0
L9703:
    .ascii    "xmm7"
    .byte     0
L9702:
    .ascii    "xmm6"
    .byte     0
L9701:
    .ascii    "xmm5"
    .byte     0
L9700:
    .ascii    "xmm4"
    .byte     0
L9699:
    .ascii    "xmm3"
    .byte     0
L9698:
    .ascii    "xmm2"
    .byte     0
L9697:
    .ascii    "xmm1"
    .byte     0
L9696:
    .ascii    "xmm0"
    .byte     0
L9695:
    .ascii    "-"
    .byte     0
L9694:
    .ascii    "temp"
    .byte     0
L9693:
    .ascii    "regvar"
    .byte     0
L9692:
    .ascii    "reg"
    .byte     0
L9691:
    .ascii    "pend"
    .byte     0
L9690:
    .ascii    "a_xreg"
    .byte     0
L9689:
    .ascii    "a_cond"
    .byte     0
L9688:
    .ascii    "a_mem"
    .byte     0
L9687:
    .ascii    "a_imm"
    .byte     0
L9686:
    .ascii    "a_reg"
    .byte     0
L9685:
    .ascii    "a_none"
    .byte     0
L9684:
    .ascii    "back_ref"
    .byte     0
L9683:
    .ascii    "fwd_ref"
    .byte     0
L9682:
    .ascii    "extern_ref"
    .byte     0
L9681:
    .ascii    "impdata_seg"
    .byte     0
L9680:
    .ascii    "rodata_seg"
    .byte     0
L9679:
    .ascii    "zdata_seg"
    .byte     0
L9678:
    .ascii    "idata_seg"
    .byte     0
L9677:
    .ascii    "code_seg"
    .byte     0
L9676:
    .ascii    "no_seg"
    .byte     0
L9675:
    .ascii    "cmovg"
    .byte     0
L9674:
    .ascii    "cmovle"
    .byte     0
L9673:
    .ascii    "cmovge"
    .byte     0
L9672:
    .ascii    "cmovl"
    .byte     0
L9671:
    .ascii    "cmovnp"
    .byte     0
L9670:
    .ascii    "cmovp"
    .byte     0
L9669:
    .ascii    "cmovns"
    .byte     0
L9668:
    .ascii    "cmovs"
    .byte     0
L9667:
    .ascii    "cmova"
    .byte     0
L9666:
    .ascii    "cmovbe"
    .byte     0
L9665:
    .ascii    "cmovnz"
    .byte     0
L9664:
    .ascii    "cmovz"
    .byte     0
L9663:
    .ascii    "cmovae"
    .byte     0
L9662:
    .ascii    "cmovb"
    .byte     0
L9661:
    .ascii    "cmovno"
    .byte     0
L9660:
    .ascii    "cmovo"
    .byte     0
L9659:
    .ascii    "setg"
    .byte     0
L9658:
    .ascii    "setle"
    .byte     0
L9657:
    .ascii    "setge"
    .byte     0
L9656:
    .ascii    "setl"
    .byte     0
L9655:
    .ascii    "setnp"
    .byte     0
L9654:
    .ascii    "setp"
    .byte     0
L9653:
    .ascii    "setns"
    .byte     0
L9652:
    .ascii    "sets"
    .byte     0
L9651:
    .ascii    "seta"
    .byte     0
L9650:
    .ascii    "setbe"
    .byte     0
L9649:
    .ascii    "setnz"
    .byte     0
L9648:
    .ascii    "setz"
    .byte     0
L9647:
    .ascii    "setae"
    .byte     0
L9646:
    .ascii    "setb"
    .byte     0
L9645:
    .ascii    "setno"
    .byte     0
L9644:
    .ascii    "seto"
    .byte     0
L9643:
    .ascii    "jnc"
    .byte     0
L9642:
    .ascii    "jc"
    .byte     0
L9641:
    .ascii    "jg"
    .byte     0
L9640:
    .ascii    "jle"
    .byte     0
L9639:
    .ascii    "jge"
    .byte     0
L9638:
    .ascii    "jl"
    .byte     0
L9637:
    .ascii    "jnp"
    .byte     0
L9636:
    .ascii    "jp"
    .byte     0
L9635:
    .ascii    "jns"
    .byte     0
L9634:
    .ascii    "js"
    .byte     0
L9633:
    .ascii    "ja"
    .byte     0
L9632:
    .ascii    "jbe"
    .byte     0
L9631:
    .ascii    "jnz"
    .byte     0
L9630:
    .ascii    "jz"
    .byte     0
L9629:
    .ascii    "jae"
    .byte     0
L9628:
    .ascii    "jb"
    .byte     0
L9627:
    .ascii    "jno"
    .byte     0
L9626:
    .ascii    "jo"
    .byte     0
L9625:
    .ascii    "mmx7"
    .byte     0
L9624:
    .ascii    "mmx6"
    .byte     0
L9623:
    .ascii    "mmx5"
    .byte     0
L9622:
    .ascii    "mmx4"
    .byte     0
L9621:
    .ascii    "mmx3"
    .byte     0
L9620:
    .ascii    "mmx2"
    .byte     0
L9619:
    .ascii    "mmx1"
    .byte     0
L9618:
    .ascii    "mmx0"
    .byte     0
L9617:
    .ascii    "st7"
    .byte     0
L9616:
    .ascii    "st6"
    .byte     0
L9615:
    .ascii    "st5"
    .byte     0
L9614:
    .ascii    "st4"
    .byte     0
L9613:
    .ascii    "st3"
    .byte     0
L9612:
    .ascii    "st2"
    .byte     0
L9611:
    .ascii    "st1"
    .byte     0
L9610:
    .ascii    "st0"
    .byte     0
L9609:
    .ascii    "xmm15"
    .byte     0
L9608:
    .ascii    "xmm14"
    .byte     0
L9607:
    .ascii    "xmm13"
    .byte     0
L9606:
    .ascii    "xmm12"
    .byte     0
L9605:
    .ascii    "xmm11"
    .byte     0
L9604:
    .ascii    "xmm10"
    .byte     0
L9603:
    .ascii    "xmm9"
    .byte     0
L9602:
    .ascii    "xmm8"
    .byte     0
L9601:
    .ascii    "xmm7"
    .byte     0
L9600:
    .ascii    "xmm6"
    .byte     0
L9599:
    .ascii    "xmm5"
    .byte     0
L9598:
    .ascii    "xmm4"
    .byte     0
L9597:
    .ascii    "xmm3"
    .byte     0
L9596:
    .ascii    "xmm2"
    .byte     0
L9595:
    .ascii    "xmm1"
    .byte     0
L9594:
    .ascii    "xmm0"
    .byte     0
L9593:
    .ascii    "r15b"
    .byte     0
L9592:
    .ascii    "r14b"
    .byte     0
L9591:
    .ascii    "r13b"
    .byte     0
L9590:
    .ascii    "r12b"
    .byte     0
L9589:
    .ascii    "r11b"
    .byte     0
L9588:
    .ascii    "r10b"
    .byte     0
L9587:
    .ascii    "r9b"
    .byte     0
L9586:
    .ascii    "r8b"
    .byte     0
L9585:
    .ascii    "spl"
    .byte     0
L9584:
    .ascii    "bpl"
    .byte     0
L9583:
    .ascii    "dil"
    .byte     0
L9582:
    .ascii    "sil"
    .byte     0
L9581:
    .ascii    "dh"
    .byte     0
L9580:
    .ascii    "ch"
    .byte     0
L9579:
    .ascii    "bh"
    .byte     0
L9578:
    .ascii    "ah"
    .byte     0
L9577:
    .ascii    "dl"
    .byte     0
L9576:
    .ascii    "cl"
    .byte     0
L9575:
    .ascii    "bl"
    .byte     0
L9574:
    .ascii    "al"
    .byte     0
L9573:
    .ascii    "r15w"
    .byte     0
L9572:
    .ascii    "r14w"
    .byte     0
L9571:
    .ascii    "r13w"
    .byte     0
L9570:
    .ascii    "r12w"
    .byte     0
L9569:
    .ascii    "r11w"
    .byte     0
L9568:
    .ascii    "r10w"
    .byte     0
L9567:
    .ascii    "r9w"
    .byte     0
L9566:
    .ascii    "r8w"
    .byte     0
L9565:
    .ascii    "sp"
    .byte     0
L9564:
    .ascii    "bp"
    .byte     0
L9563:
    .ascii    "di"
    .byte     0
L9562:
    .ascii    "si"
    .byte     0
L9561:
    .ascii    "dx"
    .byte     0
L9560:
    .ascii    "cx"
    .byte     0
L9559:
    .ascii    "bx"
    .byte     0
L9558:
    .ascii    "ax"
    .byte     0
L9557:
    .ascii    "r15d"
    .byte     0
L9556:
    .ascii    "r14d"
    .byte     0
L9555:
    .ascii    "r13d"
    .byte     0
L9554:
    .ascii    "r12d"
    .byte     0
L9553:
    .ascii    "r11d"
    .byte     0
L9552:
    .ascii    "r10d"
    .byte     0
L9551:
    .ascii    "r9d"
    .byte     0
L9550:
    .ascii    "r8d"
    .byte     0
L9549:
    .ascii    "esp"
    .byte     0
L9548:
    .ascii    "ebp"
    .byte     0
L9547:
    .ascii    "edi"
    .byte     0
L9546:
    .ascii    "esi"
    .byte     0
L9545:
    .ascii    "edx"
    .byte     0
L9544:
    .ascii    "ecx"
    .byte     0
L9543:
    .ascii    "ebx"
    .byte     0
L9542:
    .ascii    "eax"
    .byte     0
L9541:
    .ascii    "r15"
    .byte     0
L9540:
    .ascii    "r14"
    .byte     0
L9539:
    .ascii    "r13"
    .byte     0
L9538:
    .ascii    "r12"
    .byte     0
L9537:
    .ascii    "r11"
    .byte     0
L9536:
    .ascii    "r10"
    .byte     0
L9535:
    .ascii    "r9"
    .byte     0
L9534:
    .ascii    "r8"
    .byte     0
L9533:
    .ascii    "rsp"
    .byte     0
L9532:
    .ascii    "rbp"
    .byte     0
L9531:
    .ascii    "rdi"
    .byte     0
L9530:
    .ascii    "rsi"
    .byte     0
L9529:
    .ascii    "rdx"
    .byte     0
L9528:
    .ascii    "rcx"
    .byte     0
L9527:
    .ascii    "rbx"
    .byte     0
L9526:
    .ascii    "rax"
    .byte     0
L9525:
    .ascii    "_b20"
    .byte     0
L9524:
    .ascii    "b19"
    .byte     0
L9523:
    .ascii    "b18"
    .byte     0
L9522:
    .ascii    "b17"
    .byte     0
L9521:
    .ascii    "b16"
    .byte     0
L9520:
    .ascii    "b15"
    .byte     0
L9519:
    .ascii    "b14"
    .byte     0
L9518:
    .ascii    "b13"
    .byte     0
L9517:
    .ascii    "b12"
    .byte     0
L9516:
    .ascii    "b11"
    .byte     0
L9515:
    .ascii    "b10"
    .byte     0
L9514:
    .ascii    "b9"
    .byte     0
L9513:
    .ascii    "b8"
    .byte     0
L9512:
    .ascii    "b7"
    .byte     0
L9511:
    .ascii    "b6"
    .byte     0
L9510:
    .ascii    "b5"
    .byte     0
L9509:
    .ascii    "b4"
    .byte     0
L9508:
    .ascii    "b3"
    .byte     0
L9507:
    .ascii    "b2"
    .byte     0
L9506:
    .ascii    "b1"
    .byte     0
L9505:
    .ascii    "b0"
    .byte     0
L9504:
    .ascii    "w15"
    .byte     0
L9503:
    .ascii    "w14"
    .byte     0
L9502:
    .ascii    "w13"
    .byte     0
L9501:
    .ascii    "w12"
    .byte     0
L9500:
    .ascii    "w11"
    .byte     0
L9499:
    .ascii    "w10"
    .byte     0
L9498:
    .ascii    "w9"
    .byte     0
L9497:
    .ascii    "w8"
    .byte     0
L9496:
    .ascii    "w7"
    .byte     0
L9495:
    .ascii    "w6"
    .byte     0
L9494:
    .ascii    "w5"
    .byte     0
L9493:
    .ascii    "w4"
    .byte     0
L9492:
    .ascii    "w3"
    .byte     0
L9491:
    .ascii    "w2"
    .byte     0
L9490:
    .ascii    "w1"
    .byte     0
L9489:
    .ascii    "w0"
    .byte     0
L9488:
    .ascii    "a15"
    .byte     0
L9487:
    .ascii    "a14"
    .byte     0
L9486:
    .ascii    "a13"
    .byte     0
L9485:
    .ascii    "a12"
    .byte     0
L9484:
    .ascii    "a11"
    .byte     0
L9483:
    .ascii    "a10"
    .byte     0
L9482:
    .ascii    "a9"
    .byte     0
L9481:
    .ascii    "a8"
    .byte     0
L9480:
    .ascii    "a7"
    .byte     0
L9479:
    .ascii    "a6"
    .byte     0
L9478:
    .ascii    "a5"
    .byte     0
L9477:
    .ascii    "a4"
    .byte     0
L9476:
    .ascii    "a3"
    .byte     0
L9475:
    .ascii    "a2"
    .byte     0
L9474:
    .ascii    "a1"
    .byte     0
L9473:
    .ascii    "a0"
    .byte     0
L9472:
    .ascii    "d15"
    .byte     0
L9471:
    .ascii    "d14"
    .byte     0
L9470:
    .ascii    "d13"
    .byte     0
L9469:
    .ascii    "d12"
    .byte     0
L9468:
    .ascii    "d11"
    .byte     0
L9467:
    .ascii    "d10"
    .byte     0
L9466:
    .ascii    "d9"
    .byte     0
L9465:
    .ascii    "d8"
    .byte     0
L9464:
    .ascii    "d7"
    .byte     0
L9463:
    .ascii    "d6"
    .byte     0
L9462:
    .ascii    "d5"
    .byte     0
L9461:
    .ascii    "d4"
    .byte     0
L9460:
    .ascii    "d3"
    .byte     0
L9459:
    .ascii    "d2"
    .byte     0
L9458:
    .ascii    "d1"
    .byte     0
L9457:
    .ascii    "d0"
    .byte     0
L9456:
    .ascii    "a"
    .byte     0
L9455:
    .ascii    "be"
    .byte     0
L9454:
    .ascii    "ae"
    .byte     0
L9453:
    .ascii    "b"
    .byte     0
L9452:
    .ascii    "g"
    .byte     0
L9451:
    .ascii    "le"
    .byte     0
L9450:
    .ascii    "ge"
    .byte     0
L9449:
    .ascii    "l"
    .byte     0
L9448:
    .ascii    "np"
    .byte     0
L9447:
    .ascii    "p"
    .byte     0
L9446:
    .ascii    "ns"
    .byte     0
L9445:
    .ascii    "s"
    .byte     0
L9444:
    .ascii    "a"
    .byte     0
L9443:
    .ascii    "be"
    .byte     0
L9442:
    .ascii    "nz"
    .byte     0
L9441:
    .ascii    "z"
    .byte     0
L9440:
    .ascii    "ae"
    .byte     0
L9439:
    .ascii    "b"
    .byte     0
L9438:
    .ascii    "no"
    .byte     0
L9437:
    .ascii    "o"
    .byte     0
L9436:
    .ascii    "fgt"
    .byte     0
L9435:
    .ascii    "fle"
    .byte     0
L9434:
    .ascii    "fge"
    .byte     0
L9433:
    .ascii    "flt"
    .byte     0
L9432:
    .ascii    "gt"
    .byte     0
L9431:
    .ascii    "le"
    .byte     0
L9430:
    .ascii    "ge"
    .byte     0
L9429:
    .ascii    "lt"
    .byte     0
L9428:
    .ascii    "np"
    .byte     0
L9427:
    .ascii    "p"
    .byte     0
L9426:
    .ascii    "ns"
    .byte     0
L9425:
    .ascii    "s"
    .byte     0
L9424:
    .ascii    "gtu"
    .byte     0
L9423:
    .ascii    "leu"
    .byte     0
L9422:
    .ascii    "ne"
    .byte     0
L9421:
    .ascii    "eq"
    .byte     0
L9420:
    .ascii    "geu"
    .byte     0
L9419:
    .ascii    "ltu"
    .byte     0
L9418:
    .ascii    "nov"
    .byte     0
L9417:
    .ascii    "ov"
    .byte     0
L9416:
    .ascii    "r19"
    .byte     0
L9415:
    .ascii    "r18"
    .byte     0
L9414:
    .ascii    "r17"
    .byte     0
L9413:
    .ascii    "r16"
    .byte     0
L9412:
    .ascii    "r15"
    .byte     0
L9411:
    .ascii    "r14"
    .byte     0
L9410:
    .ascii    "r13"
    .byte     0
L9409:
    .ascii    "r12"
    .byte     0
L9408:
    .ascii    "r11"
    .byte     0
L9407:
    .ascii    "r10"
    .byte     0
L9406:
    .ascii    "r9"
    .byte     0
L9405:
    .ascii    "r8"
    .byte     0
L9404:
    .ascii    "r7"
    .byte     0
L9403:
    .ascii    "r6"
    .byte     0
L9402:
    .ascii    "r5"
    .byte     0
L9401:
    .ascii    "r4"
    .byte     0
L9400:
    .ascii    "r3"
    .byte     0
L9399:
    .ascii    "r2"
    .byte     0
L9398:
    .ascii    "r1"
    .byte     0
L9397:
    .ascii    "r0"
    .byte     0
L9396:
    .ascii    "rnone"
    .byte     0
L9395:
    .ascii    "m_halt"
    .byte     0
L9394:
    .ascii    "m_xxxx"
    .byte     0
L9393:
    .ascii    "m_cpuid"
    .byte     0
L9392:
    .ascii    "m_fldln2"
    .byte     0
L9391:
    .ascii    "m_fldlg2"
    .byte     0
L9390:
    .ascii    "m_fld2e"
    .byte     0
L9389:
    .ascii    "m_fld2t"
    .byte     0
L9388:
    .ascii    "m_fldpi"
    .byte     0
L9387:
    .ascii    "m_fld1"
    .byte     0
L9386:
    .ascii    "m_fldz"
    .byte     0
L9385:
    .ascii    "m_finit"
    .byte     0
L9384:
    .ascii    "m_bswap"
    .byte     0
L9383:
    .ascii    "m_popcnt"
    .byte     0
L9382:
    .ascii    "m_rdtsc"
    .byte     0
L9381:
    .ascii    "m_cmpsq"
    .byte     0
L9380:
    .ascii    "m_cmpsd"
    .byte     0
L9379:
    .ascii    "m_cmpsw"
    .byte     0
L9378:
    .ascii    "m_cmpsb"
    .byte     0
L9377:
    .ascii    "m_jrcxz"
    .byte     0
L9376:
    .ascii    "m_jecxz"
    .byte     0
L9375:
    .ascii    "m_loopcx"
    .byte     0
L9374:
    .ascii    "m_loopz"
    .byte     0
L9373:
    .ascii    "m_loopnz"
    .byte     0
L9372:
    .ascii    "m_xlat"
    .byte     0
L9371:
    .ascii    "m_resq"
    .byte     0
L9370:
    .ascii    "m_resd"
    .byte     0
L9369:
    .ascii    "m_resw"
    .byte     0
L9368:
    .ascii    "m_resb"
    .byte     0
L9367:
    .ascii    "m_align"
    .byte     0
L9366:
    .ascii    "m_csegment"
    .byte     0
L9365:
    .ascii    "m_zsegment"
    .byte     0
L9364:
    .ascii    "m_isegment"
    .byte     0
L9363:
    .ascii    "m_ascii"
    .byte     0
L9362:
    .ascii    "m_dq"
    .byte     0
L9361:
    .ascii    "m_dd"
    .byte     0
L9360:
    .ascii    "m_dw"
    .byte     0
L9359:
    .ascii    "m_db"
    .byte     0
L9358:
    .ascii    "m_maxsd"
    .byte     0
L9357:
    .ascii    "m_minsd"
    .byte     0
L9356:
    .ascii    "m_maxss"
    .byte     0
L9355:
    .ascii    "m_minss"
    .byte     0
L9354:
    .ascii    "m_fchs"
    .byte     0
L9353:
    .ascii    "m_fabs"
    .byte     0
L9352:
    .ascii    "m_fpatan"
    .byte     0
L9351:
    .ascii    "m_fptan"
    .byte     0
L9350:
    .ascii    "m_fsincos"
    .byte     0
L9349:
    .ascii    "m_fcos"
    .byte     0
L9348:
    .ascii    "m_fsin"
    .byte     0
L9347:
    .ascii    "m_fsqrt"
    .byte     0
L9346:
    .ascii    "m_fdiv"
    .byte     0
L9345:
    .ascii    "m_fmul"
    .byte     0
L9344:
    .ascii    "m_fsub"
    .byte     0
L9343:
    .ascii    "m_fadd"
    .byte     0
L9342:
    .ascii    "m_fistp"
    .byte     0
L9341:
    .ascii    "m_fist"
    .byte     0
L9340:
    .ascii    "m_fild"
    .byte     0
L9339:
    .ascii    "m_fstp"
    .byte     0
L9338:
    .ascii    "m_fst"
    .byte     0
L9337:
    .ascii    "m_fld"
    .byte     0
L9336:
    .ascii    "m_pcmpistrm"
    .byte     0
L9335:
    .ascii    "m_pcmpistri"
    .byte     0
L9334:
    .ascii    "m_movdqu"
    .byte     0
L9333:
    .ascii    "m_movdqa"
    .byte     0
L9332:
    .ascii    "m_cvtss2sd"
    .byte     0
L9331:
    .ascii    "m_cvtsd2ss"
    .byte     0
L9330:
    .ascii    "m_cvtsi2sd"
    .byte     0
L9329:
    .ascii    "m_cvtsi2ss"
    .byte     0
L9328:
    .ascii    "m_cvttsd2si"
    .byte     0
L9327:
    .ascii    "m_cvttss2si"
    .byte     0
L9326:
    .ascii    "m_cvtsd2si"
    .byte     0
L9325:
    .ascii    "m_cvtss2si"
    .byte     0
L9324:
    .ascii    "m_pand"
    .byte     0
L9323:
    .ascii    "m_pxor"
    .byte     0
L9322:
    .ascii    "m_andpd"
    .byte     0
L9321:
    .ascii    "m_andps"
    .byte     0
L9320:
    .ascii    "m_xorpd"
    .byte     0
L9319:
    .ascii    "m_xorps"
    .byte     0
L9318:
    .ascii    "m_ucomisd"
    .byte     0
L9317:
    .ascii    "m_comisd"
    .byte     0
L9316:
    .ascii    "m_comiss"
    .byte     0
L9315:
    .ascii    "m_divsd"
    .byte     0
L9314:
    .ascii    "m_divss"
    .byte     0
L9313:
    .ascii    "m_mulsd"
    .byte     0
L9312:
    .ascii    "m_mulss"
    .byte     0
L9311:
    .ascii    "m_subsd"
    .byte     0
L9310:
    .ascii    "m_subss"
    .byte     0
L9309:
    .ascii    "m_addsd"
    .byte     0
L9308:
    .ascii    "m_addss"
    .byte     0
L9307:
    .ascii    "m_sqrtsd"
    .byte     0
L9306:
    .ascii    "m_sqrtss"
    .byte     0
L9305:
    .ascii    "m_shrd"
    .byte     0
L9304:
    .ascii    "m_shld"
    .byte     0
L9303:
    .ascii    "m_bsr"
    .byte     0
L9302:
    .ascii    "m_bsf"
    .byte     0
L9301:
    .ascii    "m_setcc"
    .byte     0
L9300:
    .ascii    "m_cqo"
    .byte     0
L9299:
    .ascii    "m_cdq"
    .byte     0
L9298:
    .ascii    "m_cwd"
    .byte     0
L9297:
    .ascii    "m_cbw"
    .byte     0
L9296:
    .ascii    "m_dec"
    .byte     0
L9295:
    .ascii    "m_inc"
    .byte     0
L9294:
    .ascii    "m_notx"
    .byte     0
L9293:
    .ascii    "m_neg"
    .byte     0
L9292:
    .ascii    "m_rcr"
    .byte     0
L9291:
    .ascii    "m_rcl"
    .byte     0
L9290:
    .ascii    "m_ror"
    .byte     0
L9289:
    .ascii    "m_rol"
    .byte     0
L9288:
    .ascii    "m_shr"
    .byte     0
L9287:
    .ascii    "m_sar"
    .byte     0
L9286:
    .ascii    "m_shl"
    .byte     0
L9285:
    .ascii    "m_cmp"
    .byte     0
L9284:
    .ascii    "m_test"
    .byte     0
L9283:
    .ascii    "m_xorx"
    .byte     0
L9282:
    .ascii    "m_orx"
    .byte     0
L9281:
    .ascii    "m_andx"
    .byte     0
L9280:
    .ascii    "m_div"
    .byte     0
L9279:
    .ascii    "m_idiv"
    .byte     0
L9278:
    .ascii    "m_imul3"
    .byte     0
L9277:
    .ascii    "m_imul2"
    .byte     0
L9276:
    .ascii    "m_mul"
    .byte     0
L9275:
    .ascii    "m_imul"
    .byte     0
L9274:
    .ascii    "m_sbb"
    .byte     0
L9273:
    .ascii    "m_adc"
    .byte     0
L9272:
    .ascii    "m_sub"
    .byte     0
L9271:
    .ascii    "m_add"
    .byte     0
L9270:
    .ascii    "m_xchg"
    .byte     0
L9269:
    .ascii    "m_jmpcc"
    .byte     0
L9268:
    .ascii    "m_jmp"
    .byte     0
L9267:
    .ascii    "m_retn"
    .byte     0
L9266:
    .ascii    "m_leave"
    .byte     0
L9265:
    .ascii    "m_ret"
    .byte     0
L9264:
    .ascii    "m_call"
    .byte     0
L9263:
    .ascii    "m_movsxd"
    .byte     0
L9262:
    .ascii    "m_movzx"
    .byte     0
L9261:
    .ascii    "m_movsx"
    .byte     0
L9260:
    .ascii    "m_movq"
    .byte     0
L9259:
    .ascii    "m_movd"
    .byte     0
L9258:
    .ascii    "m_cmovcc"
    .byte     0
L9257:
    .ascii    "m_lea"
    .byte     0
L9256:
    .ascii    "m_pop"
    .byte     0
L9255:
    .ascii    "m_push"
    .byte     0
L9254:
    .ascii    "m_mov"
    .byte     0
L9253:
    .ascii    "m_nop"
    .byte     0
L9252:
    .ascii    "m_labelx"
    .byte     0
L9251:
    .ascii    "m_endx"
    .byte     0
L9250:
    .ascii    "m_trace"
    .byte     0
L9249:
    .ascii    "m_definereg"
    .byte     0
L9248:
    .ascii    "m_define"
    .byte     0
L9247:
    .ascii    "m_labelname"
    .byte     0
L9246:
    .ascii    "m_comment"
    .byte     0
L9245:
    .ascii    "m_procend"
    .byte     0
L9244:
    .ascii    "m_procstart"
    .byte     0
L9243:
    .ascii    "temp_val"
    .byte     0
L9242:
    .ascii    "name_val"
    .byte     0
L9241:
    .ascii    "label_val"
    .byte     0
L9240:
    .ascii    "def_val"
    .byte     0
L9239:
    .ascii    "stringimm_val"
    .byte     0
L9238:
    .ascii    "realmem_val"
    .byte     0
L9237:
    .ascii    "realimm_val"
    .byte     0
L9236:
    .ascii    "intimm_val"
    .byte     0
L9235:
    .ascii    "no_val"
    .byte     0
L9234:
    .ascii    "Program"
    .byte     0
L9233:
    .ascii    "Misc"
    .byte     0
L9232:
    .ascii    "Export"
    .byte     0
L9231:
    .ascii    "Label"
    .byte     0
L9230:
    .ascii    "Param"
    .byte     0
L9229:
    .ascii    "Local"
    .byte     0
L9228:
    .ascii    "Static"
    .byte     0
L9227:
    .ascii    "Proc"
    .byte     0
L9226:
    .ascii    "Import"
    .byte     0
L9225:
    .ascii    "--"
    .byte     0
L9224:
    .ascii    "gt"
    .byte     0
L9223:
    .ascii    "ge"
    .byte     0
L9222:
    .ascii    "le"
    .byte     0
L9221:
    .ascii    "lt"
    .byte     0
L9220:
    .ascii    "ne"
    .byte     0
L9219:
    .ascii    "eq"
    .byte     0
L9218:
    .ascii    "xx"
    .byte     0
L9217:
    .ascii    "extproc"
    .byte     0
L9216:
    .ascii    "addlib"
    .byte     0
L9215:
    .ascii    "variadic"
    .byte     0
L9214:
    .ascii    "rettype"
    .byte     0
L9213:
    .ascii    "local"
    .byte     0
L9212:
    .ascii    "param"
    .byte     0
L9211:
    .ascii    "endprog"
    .byte     0
L9210:
    .ascii    "comment"
    .byte     0
L9209:
    .ascii    "eval"
    .byte     0
L9208:
    .ascii    "loadall"
    .byte     0
L9207:
    .ascii    "setarg"
    .byte     0
L9206:
    .ascii    "setcall"
    .byte     0
L9205:
    .ascii    "longjmp"
    .byte     0
L9204:
    .ascii    "setjmp"
    .byte     0
L9203:
    .ascii    "labeldef"
    .byte     0
L9202:
    .ascii    "label"
    .byte     0
L9201:
    .ascii    "initdswx"
    .byte     0
L9200:
    .ascii    "data"
    .byte     0
L9199:
    .ascii    "zstatic"
    .byte     0
L9198:
    .ascii    "istatic"
    .byte     0
L9197:
    .ascii    "endproc"
    .byte     0
L9196:
    .ascii    "tcproc"
    .byte     0
L9195:
    .ascii    "proc"
    .byte     0
L9194:
    .ascii    "endmx"
    .byte     0
L9193:
    .ascii    "resetmx"
    .byte     0
L9192:
    .ascii    "startmx"
    .byte     0
L9191:
    .ascii    "fnarrow"
    .byte     0
L9190:
    .ascii    "fwiden"
    .byte     0
L9189:
    .ascii    "widen"
    .byte     0
L9188:
    .ascii    "truncate"
    .byte     0
L9187:
    .ascii    "fix"
    .byte     0
L9186:
    .ascii    "float"
    .byte     0
L9185:
    .ascii    "typepun"
    .byte     0
L9184:
    .ascii    "toboolto"
    .byte     0
L9183:
    .ascii    "notto"
    .byte     0
L9182:
    .ascii    "bitnotto"
    .byte     0
L9181:
    .ascii    "absto"
    .byte     0
L9180:
    .ascii    "negto"
    .byte     0
L9179:
    .ascii    "subpxto"
    .byte     0
L9178:
    .ascii    "addpxto"
    .byte     0
L9177:
    .ascii    "maxto"
    .byte     0
L9176:
    .ascii    "minto"
    .byte     0
L9175:
    .ascii    "shrto"
    .byte     0
L9174:
    .ascii    "shlto"
    .byte     0
L9173:
    .ascii    "bitxorto"
    .byte     0
L9172:
    .ascii    "bitorto"
    .byte     0
L9171:
    .ascii    "bitandto"
    .byte     0
L9170:
    .ascii    "iremto"
    .byte     0
L9169:
    .ascii    "idivto"
    .byte     0
L9168:
    .ascii    "divto"
    .byte     0
L9167:
    .ascii    "multo"
    .byte     0
L9166:
    .ascii    "subto"
    .byte     0
L9165:
    .ascii    "addto"
    .byte     0
L9164:
    .ascii    "loaddecr"
    .byte     0
L9163:
    .ascii    "loadincr"
    .byte     0
L9162:
    .ascii    "decrload"
    .byte     0
L9161:
    .ascii    "incrload"
    .byte     0
L9160:
    .ascii    "decrto"
    .byte     0
L9159:
    .ascii    "incrto"
    .byte     0
L9158:
    .ascii    "fmod"
    .byte     0
L9157:
    .ascii    "power"
    .byte     0
L9156:
    .ascii    "atan2"
    .byte     0
L9155:
    .ascii    "sign"
    .byte     0
L9154:
    .ascii    "ceil"
    .byte     0
L9153:
    .ascii    "floor"
    .byte     0
L9152:
    .ascii    "round"
    .byte     0
L9151:
    .ascii    "exp"
    .byte     0
L9150:
    .ascii    "log10"
    .byte     0
L9149:
    .ascii    "log"
    .byte     0
L9148:
    .ascii    "atan"
    .byte     0
L9147:
    .ascii    "acos"
    .byte     0
L9146:
    .ascii    "asin"
    .byte     0
L9145:
    .ascii    "tan"
    .byte     0
L9144:
    .ascii    "cos"
    .byte     0
L9143:
    .ascii    "sin"
    .byte     0
L9142:
    .ascii    "sqrt"
    .byte     0
L9141:
    .ascii    "sqr"
    .byte     0
L9140:
    .ascii    "toboolf"
    .byte     0
L9139:
    .ascii    "toboolt"
    .byte     0
L9138:
    .ascii    "not"
    .byte     0
L9137:
    .ascii    "bitnot"
    .byte     0
L9136:
    .ascii    "abs"
    .byte     0
L9135:
    .ascii    "neg"
    .byte     0
L9134:
    .ascii    "subp"
    .byte     0
L9133:
    .ascii    "subpx"
    .byte     0
L9132:
    .ascii    "addpx"
    .byte     0
L9131:
    .ascii    "max"
    .byte     0
L9130:
    .ascii    "min"
    .byte     0
L9129:
    .ascii    "shr"
    .byte     0
L9128:
    .ascii    "shl"
    .byte     0
L9127:
    .ascii    "bitxor"
    .byte     0
L9126:
    .ascii    "bitor"
    .byte     0
L9125:
    .ascii    "bitand"
    .byte     0
L9124:
    .ascii    "idivrem"
    .byte     0
L9123:
    .ascii    "irem"
    .byte     0
L9122:
    .ascii    "idiv"
    .byte     0
L9121:
    .ascii    "div"
    .byte     0
L9120:
    .ascii    "mul"
    .byte     0
L9119:
    .ascii    "sub"
    .byte     0
L9118:
    .ascii    "add"
    .byte     0
L9117:
    .ascii    "assem"
    .byte     0
L9116:
    .ascii    "clear"
    .byte     0
L9115:
    .ascii    "endsw"
    .byte     0
L9114:
    .ascii    "swlabel"
    .byte     0
L9113:
    .ascii    "switchu"
    .byte     0
L9112:
    .ascii    "switch"
    .byte     0
L9111:
    .ascii    "iswap"
    .byte     0
L9110:
    .ascii    "fordown"
    .byte     0
L9109:
    .ascii    "forup"
    .byte     0
L9108:
    .ascii    "to"
    .byte     0
L9107:
    .ascii    "stop"
    .byte     0
L9106:
    .ascii    "setcc"
    .byte     0
L9105:
    .ascii    "jumpretm"
    .byte     0
L9104:
    .ascii    "jumpret"
    .byte     0
L9103:
    .ascii    "jumpf"
    .byte     0
L9102:
    .ascii    "jumpt"
    .byte     0
L9101:
    .ascii    "jumpcc"
    .byte     0
L9100:
    .ascii    "ijump"
    .byte     0
L9099:
    .ascii    "jump"
    .byte     0
L9098:
    .ascii    "retfn"
    .byte     0
L9097:
    .ascii    "icallf"
    .byte     0
L9096:
    .ascii    "callf"
    .byte     0
L9095:
    .ascii    "retproc"
    .byte     0
L9094:
    .ascii    "icallp"
    .byte     0
L9093:
    .ascii    "callp"
    .byte     0
L9092:
    .ascii    "storebf"
    .byte     0
L9091:
    .ascii    "storebit"
    .byte     0
L9090:
    .ascii    "loadbf"
    .byte     0
L9089:
    .ascii    "loadbit"
    .byte     0
L9088:
    .ascii    "type"
    .byte     0
L9087:
    .ascii    "opnd"
    .byte     0
L9086:
    .ascii    "unload"
    .byte     0
L9085:
    .ascii    "swapstk"
    .byte     0
L9084:
    .ascii    "double"
    .byte     0
L9083:
    .ascii    "dupl"
    .byte     0
L9082:
    .ascii    "storem"
    .byte     0
L9081:
    .ascii    "istorex"
    .byte     0
L9080:
    .ascii    "istore"
    .byte     0
L9079:
    .ascii    "store"
    .byte     0
L9078:
    .ascii    "iloadx"
    .byte     0
L9077:
    .ascii    "iload"
    .byte     0
L9076:
    .ascii    "load"
    .byte     0
L9075:
    .ascii    "nop"
    .byte     0
L9074:
    .ascii    "any_opnd"
    .byte     0
L9073:
    .ascii    "data_opnd"
    .byte     0
L9072:
    .ascii    "realimm32_opnd"
    .byte     0
L9071:
    .ascii    "realimm_opnd"
    .byte     0
L9070:
    .ascii    "assem_opnd"
    .byte     0
L9069:
    .ascii    "strimm_opnd"
    .byte     0
L9068:
    .ascii    "string_opnd"
    .byte     0
L9067:
    .ascii    "r32_opnd"
    .byte     0
L9066:
    .ascii    "real_opnd"
    .byte     0
L9065:
    .ascii    "int_opnd"
    .byte     0
L9064:
    .ascii    "label_opnd"
    .byte     0
L9063:
    .ascii    "memaddr_opnd"
    .byte     0
L9062:
    .ascii    "mem_opnd"
    .byte     0
L9061:
    .ascii    "no_opnd"
    .byte     0
L9060:
    .ascii    "$last"
    .byte     0
L9059:
    .ascii    "vec"
    .byte     0
L9058:
    .ascii    "mem"
    .byte     0
L9057:
    .ascii    "i64"
    .byte     0
L9056:
    .ascii    "i32"
    .byte     0
L9055:
    .ascii    "i16"
    .byte     0
L9054:
    .ascii    "i8"
    .byte     0
L9053:
    .ascii    "u64"
    .byte     0
L9052:
    .ascii    "u32"
    .byte     0
L9051:
    .ascii    "u16"
    .byte     0
L9050:
    .ascii    "u8"
    .byte     0
L9049:
    .ascii    "r64"
    .byte     0
L9048:
    .ascii    "r32"
    .byte     0
L9047:
    .ascii    "void"
    .byte     0
L9046:
    .ascii    "pm_extra"
    .byte     0
L9045:
    .ascii    "pm_colon"
    .byte     0
L9044:
    .ascii    "pm_libfile"
    .byte     0
L9043:
    .ascii    "pm_sourcefile"
    .byte     0
L9042:
    .ascii    "pm_option"
    .byte     0
L9041:
    .ascii    "pm_end"
    .byte     0



