// Generated C
#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"

extern double sqrt(double);
extern double sin(double);
extern double cos(double);
extern double tan(double);
extern double asin(double);
extern double acos(double);
extern double atan(double);
extern double log(double);
extern double log10(double);
extern double exp(double);
extern double floor(double);
extern double ceil(double);
extern double atan2(double, double);
extern double fmod(double, double);
extern double pow(double, double);

typedef signed char		i8;
typedef short			i16;
typedef int				i32;
typedef long long int	i64;
typedef unsigned char			u8;
typedef unsigned short			u16;
typedef unsigned int			u32;
typedef unsigned long long int	u64;

typedef unsigned char byte;

typedef float r32;
typedef double r64;

extern void exit(i32);
extern void memset(u64, i32, u64);

#define asi8(x)  *(i8*)&x
#define asi16(x) *(i16*)&x
#define asi32(x) *(i32*)&x
#define asi64(x) *(i64*)&x

#define asu8(x)  *(u8*)&x
#define asu16(x) *(u16*)&x
#define asu32(x) *(u32*)&x
#define asu64(x) *(u64*)&x

#define asr32(x) *(r32*)&x
#define asr64(x) *(r64*)&x


#define toi8(x)  (i8)x
#define toi16(x) (i16)x
#define toi32(x) (i32)x
#define toi64(x) (i64)x

#define tou8(x)  (u8)x
#define tou16(x) (u16)x
#define tou32(x) (u32)x
#define tou64(x) (u64)x

#define tor32(x) (r32)x
#define tor64(x) (r64)x


#define toi8p(x)  (i8*)x
#define toi16p(x) (i16*)x
#define toi32p(x) (i32*)x
#define toi64p(x) (i64*)x

#define tou8p(x)  (u8*)x
#define tou16p(x) (u16*)x
#define tou32p(x) (u32*)x
#define tou64p(x) (u64*)x

#define tor32p(x) (r32*)x
#define tor64p(x) (r64*)x


i64 Getdotindex(u64 a, int i);
u64 Setdotindex(u64 a, i64 i, i64 x);
i64 Getdotslice(u64 a, i64 i, i64 j);
u64 Setdotslice(u64 a, i64 i, i64 j, u64 x);
i64 Poweri64(i64 a, i64 n);

#define Min(x, y) (x<=y ? x : y)
#define Max(x, y) (x>=y ? x : y)

i64 ncmdparams;
i64 nenvstrings;
char* (*cmdparams)[];
i64 $cmdskip;

/*
PROC START
*/
void cc_cli_main();
void (*entrypoint)(void) = cc_cli_main;

// ***** Types *****
struct $B1 {u64 a[10];};   // mem:80;
struct $B2 {u16 a[5];};   // mem:10;
struct $B3 {u64 a[2];};   // mem:16;
struct $B4 {u64 a[512];};   // mem:4096;
struct $B5 {u32 a[25];};   // mem:100;
struct $B6 {u64 a[40];};   // mem:320;
struct $B7 {u64 a[301];};   // mem:2408;
struct $B8 {u64 a[3];};   // mem:24;
struct $B9 {u32 a[3];};   // mem:12;
struct $B10 {u8 a[2049];};   // mem:2049;
struct $B11 {u64 a[9];};   // mem:72;
struct $B12 {u64 a[6];};   // mem:48;
struct $B13 {u32 a[9];};   // mem:36;
struct $B14 {u32 a[65];};   // mem:260;
struct $B15 {u32 a[75];};   // mem:300;
struct $B16 {u64 a[32];};   // mem:256;
struct $B17 {u32 a[5];};   // mem:20;
struct $B18 {u64 a[4];};   // mem:32;
struct $B19 {u64 a[50];};   // mem:400;
struct $B20 {u64 a[143];};   // mem:1144;
struct $B21 {u64 a[16];};   // mem:128;
struct $B22 {u64 a[14];};   // mem:112;
struct $B23 {u16 a[7];};   // mem:14;
struct $B24 {u8 a[143];};   // mem:143;
struct $B25 {u64 a[7];};   // mem:56;
struct $B26 {u16 a[3];};   // mem:6;
struct $B27 {u16 a[9];};   // mem:18;
struct $B28 {u16 a[1];};   // mem:2;
struct $B29 {u64 a[12];};   // mem:96;
struct $B30 {u64 a[20];};   // mem:160;
struct $B31 {u64 a[64];};   // mem:512;
struct $B32 {u64 a[8];};   // mem:64;
struct $B33 {u64 a[151];};   // mem:1208;
struct $B34 {u8 a[151];};   // mem:151;
struct $B35 {u64 a[21];};   // mem:168;
struct $B36 {u8 a[21];};   // mem:21;
struct $B37 {u64 a[137];};   // mem:1096;
struct $B38 {u8 a[137];};   // mem:137;
struct $B39 {u64 a[18];};   // mem:144;
struct $B40 {u16 a[25];};   // mem:50;
struct $B41 {u64 a[17];};   // mem:136;
struct $B42 {u64 a[128];};   // mem:1024;
struct $B43 {u64 a[193];};   // mem:1544;
struct $B44 {u64 a[1];};   // mem:8;
struct $B45 {u64 a[500];};   // mem:4000;
struct $B46 {u64 a[250];};   // mem:2000;
struct $B47 {u32 a[125];};   // mem:500;
struct $B48 {u64 a[90];};   // mem:720;
struct $B49 {u64 a[18006];};   // mem:144048;
struct $B50 {u64 a[2000];};   // mem:16000;
struct $B51 {u64 a[300];};   // mem:2400;
struct $B52 {u16 a[117009];};   // mem:234018;
struct $B53 {u64 a[5000];};   // mem:40000;
struct $B54 {u64 a[3000];};   // mem:24000;
struct $B55 {u64 a[375];};   // mem:3000;
struct $B56 {u64 a[750];};   // mem:6000;
struct $B57 {u64 a[80000];};   // mem:640000;
struct $B58 {u64 a[20000];};   // mem:160000;
struct $B59 {u64 a[10000];};   // mem:80000;
struct $B60 {u64 a[40000];};   // mem:320000;
struct $B61 {u64 a[201];};   // mem:1608;
struct $B62 {u32 a[201];};   // mem:804;
struct $B63 {u32 a[2101];};   // mem:8404;
struct $B64 {u32 a[101];};   // mem:404;
struct $B65 {u64 a[199];};   // mem:1592;
struct $B66 {u64 a[100];};   // mem:800;
struct $B67 {u64 a[22];};   // mem:176;
struct $B68 {u16 a[11];};   // mem:22;
struct $B69 {u64 a[5];};   // mem:40;
struct $B70 {u64 a[15];};   // mem:120;
struct $B71 {u32 a[15];};   // mem:60;
struct $B72 {u8 a[15];};   // mem:15;
struct $B73 {u64 a[78];};   // mem:624;
struct $B74 {u64 a[96];};   // mem:768;
struct $B75 {u64 a[63];};   // mem:504;
struct $B76 {u32 a[63];};   // mem:252;
struct $B77 {u8 a[363];};   // mem:363;
struct $B78 {u8 a[3];};   // mem:3;
struct $B79 {u64 a[34];};   // mem:272;
struct $B80 {u64 a[60];};   // mem:480;
struct $B81 {u64 a[87000];};   // mem:696000;
struct $B82 {u64 a[200];};   // mem:1600;
struct $B83 {u32 a[39];};   // mem:156;
struct $B84 {u64 a[2048];};   // mem:16384;
struct $B85 {u64 a[13];};   // mem:104;
struct $B86 {u64 a[30];};   // mem:240;
struct $B87 {u64 a[27];};   // mem:216;
struct $B88 {u64 a[130];};   // mem:1040;
struct $B89 {u64 a[45];};   // mem:360;
struct $B90 {u64 a[320];};   // mem:2560;
struct $B91 {u64 a[41];};   // mem:328;
struct $B92 {u64 a[157];};   // mem:1256;
struct $B93 {u64 a[256];};   // mem:2048;

// Function Ptr Types:
typedef i64 (*F1)(u64);
typedef i64 (*F2)();
typedef i64 (*F3)(i64);
typedef i64 (*F4)(i64, i64);
typedef i64 (*F5)(i64, i64, i64);
typedef i64 (*F6)(i64, i64, i64, i64);
typedef i64 (*F7)(i64, i64, i64, i64, i64);
typedef i64 (*F8)(i64, i64, i64, i64, i64, i64);
typedef i64 (*F9)(i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F10)(i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F11)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F12)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F13)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef r64 (*F14)();
typedef r64 (*F15)(i64);
typedef r64 (*F16)(i64, i64);
typedef i64 (*F17)(i64, u64, u64);
typedef void (*F18)(u64);
typedef u64 (*F19)(i64);
typedef void (*F20)();

// ***** Variables *****
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap;
static i64 msysc_outdev;
static u64 msysc_outchan;
static u64 msysc_fmtstr;
static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack;
static struct $B3 msysc_digits;
static struct $B3 msysc_defaultfmt;
static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug;
static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup;
static i64 mlib_show;
static i64 mlib_memtotal;
static i64 mlib_smallmemtotal;
static i64 mlib_smallmemobjs;
static i64 mlib_maxmemtotal;
static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames;
static struct $B3 mlib_seed;
static i64 mlib_pcm_newblock_totalheapsize;
static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static u64 mwindows_hconsole;
static u64 mwindows_hconsolein;
static struct $B17 mwindows_lastkey;
static struct $B17 mwindows_pendkey;
static i64 mwindows_keypending;
static i64 mwindows_hpfreq;
static u64 mwindows_wndproc_callbackfn;
static i64 mwindows_init_flag;
static u8 mwindows_os_gxregisterclass_registered;
static struct $B15 mwindows_os_gethostname_name;
static i64 mwindows_os_gethostname_n;
static i64 mwindows_os_peek_lastticks;
static u8 pclpe_pc_userunpcl;
static i64 pc_api_pclseqno;
static i64 pc_api_stseqno;
static u64 pc_api_pcstart;
static u64 pc_api_pccurr;
static u64 pc_api_pcend;
static i64 pc_api_pcalloc;
static u8 pc_api_pcfixed;
static i64 pc_api_pcseqno;
static i64 pc_api_pcneedfntable;
static i64 pc_api_initpcalloc;
static u64 pc_api_longstring;
static i64 pc_api_longstringlen;
static i64 pc_api_mlabelno;
static u8 pc_api_phighmem;
static u8 pc_api_pfullsys;
static u8 pc_api_fpshortnames;
static u64 pc_api_idomcl_assem;
static u64 pc_api_icheckasmlabel;
static u64 pc_api_igethostfn;
static struct $B18 pc_api_strpmode_str;
static struct $B16 pc_api_getfullname_str;
static struct $B16 pc_api_addstr_str;
static u64 pc_decls_pinfo;
static i64 pc_decls_bspill;
static i64 pc_decls_bxspill;
static u8 pc_decls_r10used;
static u8 pc_decls_r11used;
static u8 pc_decls_localshadow;
static i64 pc_decls_mmpos;
static u64 pc_decls_psymboltable;
static u64 pc_decls_psymboltablex;
static u64 pc_decls_currprog;
static u64 pc_decls_currfunc;
static u64 pc_decls_blockretname;
static u64 pc_decls_entryproc;
static struct $B3 pc_decls_sbuffer;
static u64 pc_decls_pdest;
static struct $B19 pc_decls_plibfiles;
static struct $B19 pc_decls_plibinst;
static i64 pc_decls_nplibfiles;
static u64 pc_decls_igetmsourceinfo;
static u8 pc_decls_pcldone;
static u8 pc_decls_mcldone;
static u8 pc_decls_ssdone;
static u8 pc_decls_objdone;
static u8 pc_decls_exedone;
static u8 pc_decls_pverbose;
static i64 pc_decls_pcmdskip;
static i64 pc_decls_assemtype;
static i64 pc_decls_ppseqno;
static u8 pc_decls_fpeephole;
static u8 pc_decls_fregoptim;
static i64 pc_decls_pcltime;
static i64 pc_decls_mcltime;
static i64 pc_decls_sstime;
static i64 pc_decls_objtime;
static i64 pc_decls_exetime;
static u64 pc_decls_$pmodulename;
static struct $B20 pc_decls_pclflags;
static i64 pc_decls_pstartclock;
static i64 pc_decls_npcl;
static i64 pc_run_dotrace;
static i64 pc_run_dostep;
static i64 pc_run_go;
static i64 pc_run_seqno;
static struct $B21 pc_run_emptyst;
static u64 pc_run_labeltable;
static struct $B22 pc_tables_pstdnames;
static struct $B23 pc_tables_psize;
static struct $B23 pc_tables_psigned;
static struct $B23 pc_tables_pint;
static struct $B23 pc_tables_pfloat;
static struct $B23 pc_tables_pmin;
static struct $B23 pc_tables_xxpiwrb;
static struct $B22 pc_tables_opndnames;
static struct $B20 pc_tables_pclnames;
static struct $B24 pc_tables_pclhastype;
static struct $B24 pc_tables_pclextra;
static struct $B24 pc_tables_pclhasopnd;
static struct $B24 pc_tables_pclargs;
static struct $B25 pc_tables_ccnames;
static struct $B1 pc_tables_idnames;
static i64 mc_genmcl_debug;
static i64 mc_genmcl_frameoffset;
static i64 mc_genmcl_paramoffset;
static i64 mc_genmcl_framebytes;
static struct $B20 mc_genmcl_px_handlertable;
static struct $B26 mc_genmcl_scondcodes;
static struct $B26 mc_genmcl_ucondcodes;
static i64 mc_auxmcl_nnn;
static i64 mc_auxmcl_nauxprocs;
static i64 mc_auxmcl_nauxnoframe;
static u64 mc_auxmcl_mclframesetup;
static i64 mc_libmcl_mclseqno;
static i64 mc_libmcl_nmclopnd;
static struct $B29 mc_libmcl_smallinttable;
static struct $B30 mc_libmcl_nametable;
static i64 mc_libmcl_nnametable;
static struct $B30 mc_libmcl_mgenextname_table;
static i64 mc_libmcl_mgenextname_ntable;
static struct $B31 mc_stackmcl_stropndstack_str;
static u8 mc_genss_rex;
static u8 mc_genss_sizeoverride;
static u8 mc_genss_addroverride;
static u8 mc_genss_f2override;
static u8 mc_genss_f3override;
static u8 mc_genss_nowmask;
static u8 mc_genss_usesizeb;
static u64 mc_genss_extraparam;
static i64 mc_genss_currseg;
static u64 mc_genss_currdata;
static u64 mc_genss_currrelocs;
static i64 mc_genss_nrelocs;
static struct $B3 mc_genss_ishighreg;
static u64 mc_genss_currmcl;
static u64 mc_genss_ripentry;
static struct $B11 mc_decls_valtypenames;
static struct $B33 mc_decls_mclnames;
static struct $B34 mc_decls_mclnopnds;
static struct $B34 mc_decls_mclcodes;
static struct $B35 mc_decls_regnames;
static struct $B36 mc_decls_regcodes;
static struct $B30 mc_decls_condnames;
static struct $B30 mc_decls_asmcondnames;
static struct $B30 mc_decls_asmrevcond;
static struct $B37 mc_decls_dregnames;
static struct $B38 mc_decls_regsizes;
static struct $B38 mc_decls_regindices;
static struct $B21 mc_decls_xmmregnames;
static struct $B32 mc_decls_fregnames;
static struct $B32 mc_decls_mregnames;
static struct $B39 mc_decls_jmpccnames;
static struct $B27 mc_decls_jmpcccodes;
static struct $B21 mc_decls_setccnames;
static struct $B3 mc_decls_setcccodes;
static struct $B21 mc_decls_cmovccnames;
static struct $B3 mc_decls_cmovcccodes;
static struct $B12 mc_decls_segmentnames;
static struct $B8 mc_decls_reftypenames;
static struct $B12 mc_decls_opndnames_ma;
static struct $B19 mc_decls_pclopnd;
static struct $B40 mc_decls_pclreg;
static struct $B40 mc_decls_pclmode;
static struct $B40 mc_decls_pclcount;
static struct $B40 mc_decls_pclloc;
static struct $B40 mc_decls_pcltempflags;
static struct $B19 mc_decls_pcltempopnds;
static i64 mc_decls_noperands;
static i64 mc_decls_mstackdepth;
static struct $B18 mc_decls_locnames;
static struct $B3 mc_decls_workregs;
static struct $B3 mc_decls_workxregs;
static i64 mc_decls_nworkregs;
static i64 mc_decls_nworkxregs;
static i64 mc_decls_nregvars;
static i64 mc_decls_nxregvars;
static i64 mc_decls_maxregvars;
static i64 mc_decls_maxxregvars;
static i64 mc_decls_xregmax;
static struct $B3 mc_decls_regset;
static struct $B3 mc_decls_xregset;
static struct $B3 mc_decls_isregvar;
static struct $B3 mc_decls_isxregvar;
static struct $B3 mc_decls_usedregs;
static struct $B3 mc_decls_usedxregs;
static u8 mc_decls_noxorclear;
static struct $B41 mc_decls_xregnames;
static struct $B18 mc_decls_callalign;
static struct $B18 mc_decls_callblockret;
static struct $B21 mc_decls_callblocksize;
static struct $B31 mc_decls_callargsize;
static i64 mc_decls_ncalldepth;
static i64 mc_decls_lababs32;
static i64 mc_decls_lababs64;
static i64 mc_decls_labneg32;
static i64 mc_decls_labneg64;
static i64 mc_decls_labmask63;
static i64 mc_decls_laboffset64;
static i64 mc_decls_labzero;
static i64 mc_decls_kk0used;
static u64 mc_decls_mccode;
static u64 mc_decls_mccodex;
static i64 mc_decls_currsegment;
static u64 mc_decls_dstackopnd;
static u64 mc_decls_dframeopnd;
static struct $B42 mc_decls_regtable;
static struct $B43 mc_decls_frameregtable;
static u64 mc_decls_cstringlist;
static u64 mc_decls_vstringlist;
static u64 mc_decls_creallist;
static u64 mc_decls_cr32list;
static u64 mc_decls_currasmproc;
static i64 mc_decls_lab_funcnametable;
static i64 mc_decls_lab_funcaddrtable;
static i64 mc_decls_lab_funcnprocs;
static i64 mc_decls_ss_zdatalen;
static u64 mc_decls_ss_zdata;
static u64 mc_decls_ss_idata;
static u64 mc_decls_ss_code;
static u64 mc_decls_ss_idatarelocs;
static u64 mc_decls_ss_coderelocs;
static i64 mc_decls_ss_nidatarelocs;
static i64 mc_decls_ss_ncoderelocs;
static u64 mc_decls_ss_symboltable;
static i64 mc_decls_ss_nsymbols;
static i64 mc_decls_ss_symboltablesize;
static u64 mc_decls_labeldeftable;
static i64 mc_decls_aaseqno;
static i64 mc_decls_aapos;
static u64 mc_decls_regmodes;
static u8 mc_decls_pmode;
static u64 mc_decls_currpcl;
static u64 mc_decls_mclprocentry;
static u64 mc_decls_mce_oldmccodex;
static u64 mc_decls_mce_lastmcl;
static u64 mc_decls_mce_nextmcl;
static u64 mc_decls_mcf_oldmccodex;
static u64 mc_decls_mcf_lastmcl;
static u64 mc_decls_mcf_nextmcl;
static u8 mc_decls_fpcheckunusedlocals;
static u64 mc_decls_riplist;
static struct $B19 mc_decls_blockdefs;
static i64 mc_decls_nblocktemps;
static struct $B12 mc_decls_multregs;
static struct $B12 mc_decls_multxregs;
static struct $B23 mc_decls_ploadopx;
static struct $B23 mc_decls_ploadop;
static struct $B25 mc_objdecls_relocnames;
static struct $B42 mc_writenasm_nregnames;
static u8 mc_writenasm_currseg;
static struct $B31 mc_writenasm_strmcl_str;
static struct $B31 mc_writenasm_mstropnd_str;
static struct $B31 mc_writenasm_strvalue_str;
static struct $B18 mc_writenasm_getxregname_str;
static struct $B16 mc_writenasm_getdispname_str;
static struct $B21 mc_writenasm_gettempname_str;
static struct $B19 mc_writeexe_libinsttable;
static struct $B19 mc_writeexe_libinstnames;
static struct $B19 mc_writeexe_libnotable;
static u64 mc_writeexe_basereloclist;
static i64 mc_writeexe_nbaserelocs;
static i64 mc_writeexe_maxrelocaddr;
static struct $B45 mc_writeexe_blockbases;
static struct $B46 mc_writeexe_blockcounts;
static struct $B46 mc_writeexe_blockbytes;
static struct $B47 mc_writeexe_blockpadding;
static i64 mc_writeexe_nbaseblocks;
static i64 mc_writeexe_basetablesize;
static i64 mc_writeexe_imagebase;
static i64 mc_writeexe_imagesize;
static i64 mc_writeexe_filesize;
static u64 mc_writeexe_thunktable;
static i64 mc_writeexe_fileiatoffset;
static i64 mc_writeexe_fileiatsize;
static u64 mc_writeexe_stentrypoint;
static u64 mc_writeexe_stentrypoint2;
static u64 mc_writeexe_stentrypoint3;
static struct $B48 mc_writeexe_sectiontable;
static i64 mc_writeexe_nsections;
static u64 mc_writeexe_importdir;
static struct $B49 mc_writeexe_importtable;
static i64 mc_writeexe_nimports;
static struct $B50 mc_writeexe_exporttable;
static i64 mc_writeexe_nexports;
static u64 mc_writeexe_dllfilename;
static i64 mc_writeexe_isdll;
static struct $B51 mc_writeexe_dlltable;
static i64 mc_writeexe_ndlls;
static u64 mc_writeexe_datastart;
static u64 mc_writeexe_dataptr;
static u64 mc_writeexe_userentrypoint;
static i64 mc_writeexe_exportdirvirtaddr;
static i64 mc_writeexe_exportdirvirtsize;
static i64 mc_writeexe_exportdiroffset;
static i64 mc_writeexe_blockdirvirtaddr;
static i64 mc_writeexe_blockdirvirtsize;
static i64 mc_writeexe_blockdiroffset;
static i64 mc_writeobj_symtaboffset;
static u64 mc_writeobj_datastart;
static u64 mc_writeobj_dataptr;
static struct $B52 mc_writeobj_symboltable;
static i64 mc_writeobj_nsymbols;
static i64 mc_writeobj_stoffset;
static struct $B53 mc_writeobj_stringtable;
static struct $B53 mc_writeobj_stringlengths;
static i64 mc_writeobj_nextstringoffset;
static i64 mc_writeobj_nstrings;
static struct $B2 mc_writeobj_writerelocs_s;
static struct $B27 mc_writeobj_makesymbol_r;
static struct $B27 mc_writeobj_strtoaux_r;
static struct $B27 mc_writeobj_sectiontoaux_r;
static struct $B22 mx_decls_mcxdirnames;
static struct $B12 mx_decls_mcxrelocnames;
static struct $B30 mx_decls_dllnametable;
static struct $B30 mx_decls_dllinsttable;
static i64 mx_decls_ndlllibs;
static struct $B30 mx_decls_libnametable;
static struct $B30 mx_decls_libtable;
static struct $B17 mx_decls_librelocated;
static struct $B17 mx_decls_libinitdone;
static i64 mx_decls_nlibs;
static struct $B54 mx_decls_symbolnametable;
static struct $B55 mx_decls_symboldefined;
static struct $B54 mx_decls_symboladdress;
static struct $B56 mx_decls_symbollibindex;
static struct $B55 mx_decls_symboldllindex;
static i64 mx_decls_nsymbols;
static i64 mx_decls_nsymimports;
static i64 mx_decls_nsymexports;
static struct $B12 mx_lib_rsegmentnames;
static u64 mx_write_dest;
static u64 mx_write_entrypoint;
static struct $B22 cc_cli_passnames;
static struct $B22 cc_cli_extnames;
static u8 cc_cli_cc_pass;
static u8 cc_cli_debugmode;
static u64 cc_cli_outfile;
static u64 cc_cli_outext;
static i64 cc_cli_cmdskip;
static i64 cc_cli_ttt;
static u8 cc_cli_fverbose;
static u8 cc_cli_fshowincludes;
static u8 cc_cli_dointheaders;
static u8 cc_cli_highmem;
static u8 cc_cli_fshowst;
static u8 cc_cli_fshowstflat;
static u8 cc_cli_fshowast;
static u8 cc_cli_fshowpcl;
static u8 cc_cli_fshowpst;
static u8 cc_cli_fshowmcl;
static u8 cc_cli_fshowss;
static u8 cc_cli_fshowtypes;
static u8 cc_cli_fshowfiles;
static u8 cc_cli_fshowpaths;
static u8 cc_cli_fshowheaders;
static u8 cc_cli_fwriteheaders;
static u8 cc_cli_fshowlog;
static u8 cc_cli_fshowtiming;
static u8 cc_cli_fgendll;
static u8 cc_cli_fstdout;
static u8 cc_cli_fshortnames;
static u8 cc_cli_fwriteerrors;
static u64 cc_cli_entrypointname;
static struct $B19 cc_cli_optionnames;
static struct $B19 cc_cli_optvars;
static struct $B40 cc_cli_optvalues;
static i64 cc_cli_totallines;
static i64 cc_cli_nstringobjects;
static i64 cc_cli_startclock;
static i64 cc_cli_loadtime;
static i64 cc_cli_parsetime;
static i64 cc_cli_pcltime;
static i64 cc_cli_compiletime;
static i64 cc_cli_inittime;
static i64 cc_decls_ntypes;
static struct $B57 cc_decls_ttnamedef;
static struct $B58 cc_decls_ttbasetype;
static struct $B57 cc_decls_ttlength;
static struct $B59 cc_decls_ttconst;
static struct $B58 cc_decls_tttarget;
static struct $B58 cc_decls_ttreftype;
static struct $B58 cc_decls_ttconsttype;
static struct $B57 cc_decls_ttsize;
static struct $B59 cc_decls_ttisref;
static struct $B59 cc_decls_ttisblock;
static struct $B59 cc_decls_ttsigned;
static struct $B60 cc_decls_ttshared;
static struct $B57 cc_decls_ttparams;
static struct $B57 cc_decls_tttypedef;
static i64 cc_decls_trefchar;
static i64 cc_decls_trefwchar;
static u64 cc_decls_inputfile;
static i64 cc_decls_mainfileno;
static struct $B61 cc_decls_libfiles;
static struct $B61 cc_decls_sourcefilenames;
static struct $B61 cc_decls_sourcefilepaths;
static struct $B61 cc_decls_sourcefiletext;
static struct $B62 cc_decls_sourcefilesizes;
static i64 cc_decls_nsourcefiles;
static i64 cc_decls_nlibfiles;
static struct $B30 cc_decls_searchdirs;
static i64 cc_decls_nsearchdirs;
static struct $B30 cc_decls_includepaths;
static i64 cc_decls_nincludepaths;
static u64 cc_decls_stprogram;
static u64 cc_decls_stmodule;
static u64 cc_decls_logdev;
static u64 cc_decls_nullunit;
static i64 cc_decls_clineno;
static i64 cc_decls_cfileno;
static struct $B18 cc_decls_lx;
static struct $B18 cc_decls_nextlx;
static i64 cc_decls_debug;
static i64 cc_decls_hstsize;
static i64 cc_decls_hstmask;
static u64 cc_decls_hashtable;
static struct $B63 cc_decls_blockowner;
static struct $B63 cc_decls_blockcounts;
static struct $B64 cc_decls_blockstack;
static i64 cc_decls_currblockno;
static i64 cc_decls_nextblockno;
static i64 cc_decls_blocklevel;
static u64 cc_decls_currproc;
static u64 cc_decls_dheaderfile;
static i64 cc_decls_structpadding;
static i64 cc_decls_callbackflag;
static i64 cc_decls_slineno;
static i64 cc_decls_sfileno;
static u64 cc_decls_oemname;
static u64 cc_decls_mclstr;
static i64 cc_decls_mclstrlen;
static i64 cc_decls_nunits;
static struct $B65 cc_decls_pmodulelist;
static struct $B66 cc_decls_pheaderlist;
static struct $B66 cc_decls_pliblist;
static i64 cc_decls_npmodules;
static i64 cc_decls_npheaders;
static i64 cc_decls_nplibs;
static u8 cc_decls_pci_target;
static struct $B67 cc_tables_stdtypenames;
static struct $B68 cc_tables_stdtypewidths;
static struct $B68 cc_tables_stdsigned;
static struct $B68 cc_tables_stdpcl;
static struct $B68 cc_tables_stdsize;
static struct $B69 cc_tables_catnames;
static struct $B70 cc_tables_typespecnames;
static struct $B71 cc_tables_typespectypes;
static struct $B72 cc_tables_typespecsizes;
static struct $B18 cc_tables_pmflagnames;
static struct $B69 cc_tables_scopenames;
static struct $B12 cc_tables_cccnames;
static struct $B12 cc_tables_linkagenames;
static struct $B18 cc_tables_typequalnames;
static struct $B8 cc_tables_fnspecnames;
static struct $B73 cc_tables_jtagnames;
static struct $B74 cc_tables_symbolnames;
static struct $B74 cc_tables_shortsymbolnames;
static struct $B29 cc_tables_symboltojtag;
static struct $B70 cc_tables_sourcedirnames;
static struct $B69 cc_tables_namespacenames;
static struct $B70 cc_tables_namenames;
static struct $B71 cc_tables_namespaces;
static struct $B72 cc_tables_name2pid;
static struct $B75 cc_tables_stnames;
static struct $B76 cc_tables_stsymbols;
static struct $B76 cc_tables_stsubcodes;
static struct $B22 cc_tables_convnames;
static struct $B42 cc_tables_dominantmode;
static struct $B16 cc_tables_conversionops;
static struct $B77 cc_tables_dominantsetuptable;
static struct $B77 cc_tables_convsetuptable;
static struct $B79 cc_tables_badexprs;
static u64 cc_lex_tkptr;
static i64 cc_lex_dowhitespace;
static i64 cc_lex_nincludes;
static struct $B18 cc_lex_normaltkx;
static u64 cc_lex_normaltk;
static i64 cc_lex_noexpand;
static struct $B80 cc_lex_lx_stack;
static i64 cc_lex_lx_stackindex;
static i64 cc_lex_ifcondlevel;
static struct $B30 cc_lex_headerpathlist;
static struct $B15 cc_lex_headerpath;
static u64 cc_lex_lxstart;
static u64 cc_lex_lxsptr;
static i64 cc_lex_lxhashvalue;
static u64 cc_lex_lxsvalue;
static struct $B16 cc_lex_alphamap;
static struct $B16 cc_lex_digitmap;
static struct $B16 cc_lex_commentmap;
static struct $B16 cc_lex_linecommentmap;
static struct $B16 cc_lex_spacemap;
static u64 cc_lex_destcopy;
static struct $B81 cc_lex_pastedtokenlist;
static i64 cc_lex_npastedtokens;
static i64 cc_lex_isincludefile;
static i64 cc_lex_firstsymbol;
static u64 cc_lex_reallxsptr;
static i64 cc_lex_nhstsymbols;
static i64 cc_lex_hstthreshold;
static struct $B3 cc_lex_lex_preprocess_only_sbuffer;
static struct $B15 cc_lex_getsourcefile_filespec;
static i64 cc_lex_lasttoken;
static struct $B3 cc_lex_showtoken_buffer;
static struct $B3 cc_lex_stringify_buffer;
static u64 cc_parse_ist_symptr;
static struct $B32 cc_parse_looptypestack;
static i64 cc_parse_loopindex;
static struct $B31 cc_parse_casevaluestack;
static u8 cc_parse_ingeneric;
static i64 cc_genpcl_retindex;
static i64 cc_genpcl_initstaticsindex;
static struct $B82 cc_genpcl_loopstack;
static i64 cc_genpcl_loopindex;
static struct $B32 cc_genpcl_zero_unit;
static u64 cc_genpcl_pzero;
static i64 cc_genpcl_nvarlocals;
static i64 cc_genpcl_nvarparams;
static struct $B31 cc_blockpcl_continuestack;
static struct $B31 cc_blockpcl_breakstack;
static i64 cc_blockpcl_loopindex;
static u64 cc_blockpcl_sw_labeltable;
static u64 cc_blockpcl_sw_valuetable;
static i64 cc_blockpcl_sw_lower;
static i64 cc_blockpcl_sw_ncases;
static u8 cc_blockpcl_sw_defaultseen;
static i64 cc_blockpcl_sw_defaultlabel;
static i64 cc_blockpcl_sw_breaklabel;
static i64 cc_lib_autotypeno;
static i64 cc_lib_nextafindex;
static u64 cc_lib_unitheapptr;
static i64 cc_lib_remainingunits;
static struct $B83 cc_lib_getoptocode_opctotable;
static struct $B18 cc_lib_nextautotype_str;
static struct $B17 cc_lib_getopcjname_str;
static struct $B84 cc_lib_strmode_str;
static struct $B84 cc_lib_strmode2_str;
static struct $B15 cc_lib_typename_str;
static struct $B16 cc_lib_getstname_name;
static u64 cc_support_bytemasks;
static i64 cc_headers_builtinheaders;
static u64 cc_headers_h_assert;
static u64 cc_headers_h_ctype;
static u64 cc_headers_h_errno;
static u64 cc_headers_h_fenv;
static u64 cc_headers_h_float;
static u64 cc_headers_h_inttypes;
static u64 cc_headers_h_stdint;
static u64 cc_headers_h_limits;
static u64 cc_headers_h_locale;
static u64 cc_headers_h__ansi;
static u64 cc_headers_h_math;
static u64 cc_headers_h_setjmp;
static u64 cc_headers_h_signal;
static u64 cc_headers_h_stdarg;
static u64 cc_headers_h_stdbool;
static u64 cc_headers_h_stddef;
static u64 cc_headers_h_stdio;
static u64 cc_headers_h_stdlib;
static u64 cc_headers_h__syslist;
static u64 cc_headers_h_string;
static u64 cc_headers_h_time;
static u64 cc_headers_h_utime;
static u64 cc_headers_h_unistd;
static u64 cc_headers_h_safelib;
static u64 cc_headers_h_wchar;
static u64 cc_headers_h_wctype;
static u64 cc_headers_h_systypes;
static u64 cc_headers_h_sysstat;
static u64 cc_headers_h_systimeb;
static u64 cc_headers_h_sysutime;
static u64 cc_headers_h_memory;
static u64 cc_headers_h_fcntl;
static u64 cc_headers_h_io;
static u64 cc_headers_h_direct;
static u64 cc_headers_h_process;
static u64 cc_headers_h_malloc;
static u64 cc_headers_h_conio;
static u64 cc_headers_h_winsock2;
static u64 cc_headers_h__mingw;
static u64 cc_headers_h_windowsx;
static struct $B6 cc_headers_stdhdrnames;
static struct $B6 cc_headers_stdhdrtext;
static struct $B3 cc_showdummy_sbuffer;
static u64 cc_showdummy_dest;
static i64 cc_showdummy_currlineno;
static i64 $nprocs;
static struct $B88 $procname;
static struct $B88 $procaddr;

// ***** Imported Functions *****
extern u64 malloc(u64 $1);
extern u64 realloc(u64 $1, u64 $2);
extern void free(u64 $1);
extern void memset(u64 $1, i32 $2, u64 $3);
extern void memcpy(u64 $1, u64 $2, u64 $3);
extern void memmove(u64 $1, u64 $2, u64 $3);
extern i32 clock();
extern i32 ftell(u64 $1);
extern i32 fseek(u64 $1, i32 $2, i32 $3);
extern u64 fread(u64 $1, u64 $2, u64 $3, u64 $4);
extern u64 fwrite(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 getc(u64 $1);
extern i32 ungetc(i32 $1, u64 $2);
extern u64 fopen(u64 a, u64 b);
extern i32 fclose(u64 $1);
extern u64 fgets(u64 $1, i64 $2, u64 $3);
extern i32 remove(u64 $1);
extern i32 rename(u64 $1, u64 $2);
extern i32 getchar();
extern void putchar(i32 $1);
extern void setbuf(u64 $1, u64 $2);
extern i64 strlen(u64 $1);
extern u64 strcpy(u64 $1, u64 $2);
extern i32 strcmp(u64 $1, u64 $2);
extern i32 strncmp(u64 $1, u64 $2, u64 $3);
extern u64 strncpy(u64 $1, u64 $2, u64 $3);
extern i32 memcmp(u64 $1, u64 $2, u64 $3);
extern u64 strcat(u64 $1, u64 $2);
extern i32 tolower(i32 $1);
extern i32 toupper(i32 $1);
extern i32 isalpha(i32 $1);
extern i32 isupper(i32 $1);
extern i32 islower(i32 $1);
extern i32 isalnum(i32 $1);
extern i32 isspace(i32 $1);
extern u64 strstr(u64 $1, u64 $2);
extern i64 atol(u64 $1);
extern i32 atoi(u64 $1);
extern r64 strtod(u64 $1, u64 $2);
extern u64 _strdup(u64 $1);
extern i32 puts(u64 $1);
extern i32 printf(u64 $1, ...);
extern i32 sprintf(u64 $1, u64 $2, ...);
extern i32 sscanf(u64 $1, u64 $2, ...);
extern i32 scanf(u64 $1, ...);
extern i32 rand();
extern void srand(u32 $1);
extern i32 system(u64 $1);
extern i32 fgetc(u64 $1);
extern i32 fputc(i32 $1, u64 $2);
extern i32 fprintf(u64 $1, u64 $2, ...);
extern i32 fputs(u64 $1, u64 $2);
extern i32 feof(u64 $1);
extern i32 getch();
extern i32 _getch();
extern i32 kbhit();
extern i32 _mkdir(u64 $1);
extern i32 mkdir(u64 $1);
extern u64 strchr(u64 $1, i32 $2);
extern i32 _setmode(i32 $1, i32 $2);
extern void _exit(i32 $1);
extern void exit(i32 $1);
extern r64 pow(r64 $1, r64 $2);
extern r64 sqrt(r64 $1);
extern r64 sin(r64 $1);
extern r64 cos(r64 $1);
extern r64 tan(r64 $1);
extern r64 asin(r64 $1);
extern r64 acos(r64 $1);
extern r64 atan(r64 $1);
extern r64 log(r64 $1);
extern r64 log10(r64 $1);
extern r64 exp(r64 $1);
extern r64 floor(r64 $1);
extern r64 ceil(r64 $1);
extern void qsort(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 __getmainargs(u64 $1, u64 $2, u64 $3, i64 $4, u64 $5);
extern u64 GetStdHandle(u32 $1);
extern i64 GetConsoleScreenBufferInfo(u64 $1, u64 $2);
extern i64 SetConsoleCtrlHandler(u64 $1, i64 $2);
extern i64 SetConsoleMode(u64 $1, u32 $2);
extern i64 CreateProcessA(u64 $1, u64 $2, u64 $3, u64 $4, i64 $5, u32 $6, u64 $7, u64 $8, u64 $9, u64 $10);
extern u32 GetLastError();
extern u32 WaitForSingleObject(u64 $1, u32 $2);
extern i64 GetExitCodeProcess(u64 $1, u64 $2);
extern i64 CloseHandle(u64 $1);
extern i64 GetNumberOfConsoleInputEvents(u64 $1, u64 $2);
extern i64 FlushConsoleInputBuffer(u64 $1);
extern u64 LoadLibraryA(u64 $1);
extern u64 GetProcAddress(u64 $1, u64 $2);
extern u64 LoadCursorA(u64 $1, u64 $2);
extern u32 RegisterClassExA(u64 $1);
extern i64 DefWindowProcA(u64 $1, u32 $2, u64 $3, u64 $4);
extern i64 ReadConsoleInputA(u64 $1, u64 $2, u32 $3, u64 $4);
extern void Sleep(u32 $1);
extern u32 GetModuleFileNameA(u64 $1, u64 $2, u32 $3);
extern void ExitProcess(u32 $1);
extern void PostQuitMessage(i32 $1);
extern void MessageBoxA(i32 x, u64 message, u64 caption, i32 y);
extern u32 QueryPerformanceCounter(u64 $1);
extern u32 QueryPerformanceFrequency(u64 $1);
extern u64 CreateFileA(u64 $1, u32 $2, u32 $3, u64 $4, u32 $5, u32 $6, u64 $7);
extern u32 GetFileTime(u64 $1, u64 $2, u64 $3, u64 $4);
extern void GetSystemTime(u64 $1);
extern void GetLocalTime(u64 $1);
extern u64 GetTickCount64();
extern u32 PeekMessageA(u64 $1, u64 $2, u32 $3, u32 $4, u32 $5);
extern u64 GetCommandLineA();
extern u64 VirtualAlloc(u64 $1, u32 $2, u32 $3, u32 $4);
extern u32 VirtualProtect(u64 $1, u32 $2, u32 $3, u64 $4);
extern u32 WriteConsoleA(u64 $1, u64 $2, i32 $3, u64 $4, u64 $5);
extern u64 FindFirstFileA(u64 $1, u64 $2);
extern u32 FindNextFileA(u64 $1, u64 $2);
extern u32 FindClose(u64 $1);
extern u32 MessageBeep(i32 $1);
extern u32 Beep(i32 freq, i32 dur);

// ***** Function Declarations *****
static u64 msysc_getfmt(u64 fmtstyle);
static u64 msysc_strint(i64 a, u64 fmtstyle);
static u64 msysc_strword(u64 a, u64 fmtstyle);
static u64 msysc_strreal(r64 a, u64 fmtstyle);
static u64 mlib_pcm_newblock(i64 itemsize);
static i64 mlib_pcm_round(i64 n);
static u64 mlib_changeext(u64 s, u64 newext);
static u64 mlib_extractpath(u64 s);
static u64 mlib_extractbasefile(u64 s);
static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext);
static i64 mlib_readnextfileitem(u64 fileptr, u64 item);
static u64 mlib_padstr(u64 s, i64 width, u64 padchar);
static u64 mlib_chr(i64 c);
static void mwindows_os_gxregisterclass(u64 classname);
static i64 mwindows_mainwndproc(u64 hwnd, u32 message, u64 wparam, u64 lparam);
static u64 mwindows_os_gethostname();
static void mwindows_os_peek();
static u64 pc_api_strpmode(i64 mode, i64 size);
static u64 pc_api_getfullname(u64 d, i64 backtick);
static u64 pc_api_addstr(u64 s, u64 t);
static void mc_genmcl_inithandlers();
static u64 mc_libmcl_mgenextname(u64 s);
static u64 mc_stackmcl_stropndstack(i64 indent);
static u64 mc_genss_genrm(i64 reg, i64 opc, u64 b, i64 isxreg);
static void mc_writenasm_strmcl(u64 mcl);
static u64 mc_writenasm_mstropnd(u64 a, i64 sizeprefix, i64 opcode);
static u64 mc_writenasm_strvalue(u64 a);
static u64 mc_writenasm_getxregname(i64 reg, i64 size);
static u64 mc_writenasm_getdispname(u64 d);
static u64 mc_writenasm_gettempname(u64 d, i64 n);
static void mc_writeexe_writedosstub();
static void mc_writeobj_writerelocs(u64 r, i64 nrelocs);
static u64 mc_writeobj_makesymbol(u64 name, i64 value, i64 sectionno, i64 symtype, i64 storage, i64 naux);
static u64 mc_writeobj_strtoaux(u64 s);
static u64 mc_writeobj_sectiontoaux(u64 data, i64 nrelocs);
static void cc_cli_showextrainfo();
static void cc_lex_lex_preprocess_only(u64 infile, u64 outfile, i64 toconsole);
static i64 cc_lex_getsourcefile(u64 file, i64 syshdr);
static void cc_lex_lexm();
static void cc_lex_showtoken(u64 lp);
static void cc_lex_stringify(u64 seq, u64 dest);
static void cc_lex_expandpredefmacro(i64 pdmcode, u64 tk, i64 lineno);
static i64 cc_lex_issimpleconstmacro(u64 m);
static i64 cc_lib_getoptocode(i64 opc);
static u64 cc_lib_nextautotype();
static u64 cc_lib_getopcjname(i64 opc);
static u64 cc_lib_strmode(i64 m, i64 expand);
static u64 cc_lib_strmode2(i64 m, i64 expand);
static u64 cc_lib_typename(i64 m);
static u64 cc_lib_getstname(u64 d);
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl);
static void msysc_pushio();
static void msysc_m$print_startfile(u64 dev);
static void msysc_resetprintbuffer();
static void msysc_m$print_startstr(u64 s);
static void msysc_m$print_startptr(u64 p);
static void msysc_m$print_startcon();
static void msysc_m$print_setfmt(u64 format);
static void msysc_m$print_end();
static void msysc_nextfmtchars(i64 lastx);
static void msysc_dumpprintbuffer();
static void msysc_m$print_ptr(u64 a, u64 fmtstyle);
static void msysc_m$print_u64(u64 a, u64 fmtstyle);
static void msysc_m$print_ptr_nf(u64 a);
static void msysc_m$print_i64(i64 a, u64 fmtstyle);
static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep);
static void msysc_printstr_n(u64 s, i64 n);
static void msysc_strtofmt(u64 s, i64 slen, u64 fmt);
static void msysc_tostr_i64(i64 a, u64 fmt);
static void msysc_m$print_i64_nf(i64 a);
static void msysc_m$print_bool(i64 a, u64 fmtstyle);
static void msysc_m$print_str(u64 s, u64 fmtstyle);
static void msysc_printstr(u64 s);
static void msysc_tostr_u64(u64 a, u64 fmt);
static void msysc_m$print_r64(r64 x, u64 fmtstyle);
static void msysc_tostr_r64(r64 x, u64 fmt);
static void msysc_m$print_r32(r32 x, u64 fmtstyle);
static void msysc_m$print_c8(i64 a, u64 fmtstyle);
static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt);
static i64 msysc_getutfsize(u64 s);
static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt);
static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle);
static void msysc_m$print_str_nf(u64 s);
static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle);
static void mlib_abortprogram(u64 s);
static void msysc_m$print_newline();
static void msysc_m$print_nogap();
static void msysc_m$print_space();
static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer);
static void msysc_printstrn_app(u64 s, i64 length, u64 f);
static void msysc_printchar(i64 ch);
static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt);
static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep);
static u64 mlib_convlcstring(u64 s);
static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt);
static u64 mlib_pcm_alloc(i64 n);
static u64 mlib_convucstring(u64 s);
static void mlib_pcm_free(u64 p, i64 n);
static u64 msysc_getstr(u64 s, u64 fmt);
static void msysc_getstrint(i64 a, u64 dest);
static u64 mlib_pcm_copyheapstring(u64 s);
static void msysc_initreadbuffer();
static void msysc_m$read_conline();
static void mlib_readlinen(u64 handlex, u64 buffer, i64 size);
static void msysc_m$read_fileline(u64 f);
static void msysc_m$read_strline(u64 s);
static u64 msysc_readitem(u64 itemlength);
static i64 msysc_strtoint(u64 s, i64 length, u64 base);
static i64 msysc_m$read_i64(i64 fmt);
static r64 msysc_m$read_r64(i64 fmt);
static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt);
static void mlib_iconvlcn(u64 s, i64 n);
static void msysc_readstr(u64 dest, i64 fmt, i64 destlen);
static void msysc_rereadln();
static void msysc_reread();
static i64 msysc_valint(u64 s, i64 fmt);
static r64 msysc_valreal(u64 s);
static void msysc_mclunimpl(u64 mess);
static void msysc_addtobuffer(u64 s, i64 n);
static i64 msysc_m$sign_i64(i64 a);
static r64 msysc_m$sign_r64(r64 x);
static void mlib_pcm_init();
static i64 mlib_pcm_getac(i64 size);
static u64 mlib_allocmem(i64 n);
static void mlib_pcm_freeac(u64 p, i64 alloc);
static void mlib_pcm_clearmem(u64 p, i64 n);
static u64 mlib_pcm_allocz(i64 n);
static u64 mlib_pcm_copyheapstringn(u64 s, i64 n);
static u64 mlib_pcm_copyheapblock(u64 s, i64 length);
static u64 mlib_reallocmem(u64 p, i64 n);
static i64 mlib_getfilesize(u64 handlex);
static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_setfilepos(u64 file, i64 offset);
static i64 mlib_getfilepos(u64 file);
static u64 mlib_readfile(u64 filename);
static i64 mlib_writefile(u64 filename, u64 data, i64 size);
static i64 mlib_checkfile(u64 file);
static u64 mwindows_os_getstdin();
static void mlib_iconvucn(u64 s, i64 n);
static u64 mlib_extractext(u64 s, i64 period);
static u64 mlib_extractfile(u64 s);
static u64 mlib_addext(u64 s, u64 newext);
static u64 mlib_pcm_alloc32();
static void mlib_pcm_free32(u64 p);
static void mlib_outbyte(u64 f, i64 x);
static void mlib_outu16(u64 f, u64 x);
static void mlib_outu32(u64 f, u64 x);
static void mlib_outu64(u64 f, u64 x);
static void mlib_outstring(u64 f, u64 s);
static void mlib_outblock(u64 f, u64 p, i64 n);
static i64 mlib_myeof(u64 f);
static void mlib_strbuffer_add(u64 dest, u64 s, i64 n);
static void mlib_gs_init(u64 dest);
static void mlib_gs_free(u64 dest);
static void mlib_gs_str(u64 dest, u64 s);
static void mlib_gs_char(u64 dest, i64 c);
static void mlib_gs_strn(u64 dest, u64 s, i64 length);
static void mlib_gs_strvar(u64 dest, u64 s);
static void mlib_gs_strint(u64 dest, i64 a);
static void mlib_gs_strln(u64 dest, u64 s);
static void mlib_gs_line(u64 dest);
static void mlib_gs_strsp(u64 dest, u64 s);
static i64 mlib_gs_getcol(u64 dest);
static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch);
static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch);
static void mlib_gs_padto(u64 dest, i64 col, i64 ch);
static void mlib_gs_println(u64 dest, u64 f);
static i64 mlib_eqstring(u64 s, u64 t);
static void mlib_ipadstr(u64 s, i64 width, u64 padchar);
static i64 mlib_cmpstring(u64 s, u64 t);
static i64 mlib_cmpstringn(u64 s, u64 t, i64 n);
static i64 mlib_cmpbytes(u64 p, u64 q, i64 n);
static i64 mlib_eqbytes(u64 p, u64 q, i64 n);
static void mlib_mseed(u64 a, u64 b);
static u64 mlib_mrandom();
static i64 mlib_mrandomp();
static i64 mlib_mrandomint(i64 n);
static i64 mlib_mrandomrange(i64 a, i64 b);
static r64 mlib_mrandomreal();
static r64 mlib_mrandomreal1();
static u64 mlib_readline();
static u64 mlib_findfunction(u64 name);
static i64 mlib_roundtoblock(i64 n, i64 align);
static u64 mlib_pcm_allocnfz(i64 n);
static void mwindows_os_init();
static i64 mwindows_os_execwait(u64 cmdline, i64 newconsole, u64 workdir);
static i64 mwindows_os_execcmd(u64 cmdline, i64 newconsole);
static i64 mwindows_os_getch();
static i64 mwindows_os_getchx();
static i64 mwindows_os_kbhit();
static u64 mwindows_os_getdllinst(u64 name);
static u64 mwindows_os_getdllprocaddr(i64 hinst, u64 name);
static void mwindows_os_initwindows();
static void mwindows_os_setmesshandler(u64 addr);
static u64 mwindows_os_getos();
static i64 mwindows_os_gethostsize();
static i64 mwindows_os_shellexec(u64 opc, u64 file);
static void mwindows_os_sleep(i64 a);
static u64 mwindows_os_getstdout();
static u64 mwindows_os_getmpath();
static i64 mwindows_os_clock();
static i64 mwindows_os_hpcounter();
static i64 mwindows_os_ticks();
static i64 mwindows_os_iswindows();
static void mwindows_os_getsystime(u64 tm);
static u64 mwindows_os_allocexecmem(i64 n);
static i64 mwindows_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t);
static i64 mwindows_os_hpfreq();
static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes);
static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams);
static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams);
static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat);
static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d);
static u64 pc_api_pcl_start(u64 name, i64 nunits);
static void pc_api_pclerror(u64 mess);
static u64 pc_api_pc_makesymbol(u64 s, i64 id);
static void pc_api_pcl_end();
static void pc_api_pc_gen(i64 opcode, u64 p);
static u64 pc_api_pcl_writepcl(u64 filename);
static u64 pc_diags_dummy_writeallpcl();
static u64 pc_api_pcl_writepst(u64 filename);
static u64 pc_diags_dummy_writepst();
static void pc_api_pcl_genmcl();
static void mc_genmcl_genmcl(u64 dummy);
static void pc_api_pcl_genss(i64 obj);
static void mc_genss_genss(i64 obj);
static u64 pc_api_pcl_writess(u64 filename, i64 obj);
static u64 mc_writess_dummy_writessdata(i64 fexe);
static u64 pc_api_pcl_writeasm(u64 filename, i64 atype);
static u64 mc_writenasm_getassemstr();
static void pc_api_pcl_writeobj(u64 filename);
static void mc_writeobj_writecoff(u64 outfile);
static void pc_api_pcl_writedll(u64 filename);
static void mc_writeexe_writeexe(u64 outfile, i64 dodll, u64 entrypoint);
static void pc_api_pcl_writeexe(u64 filename);
static void pc_api_pcl_writemx(u64 filename);
static void mx_write_writemcx(u64 filename);
static void pc_api_pcl_exec();
static void mx_run_runlibfile(u64 filename, i64 cmdskip);
static void pc_api_pcl_setflags(i64 highmem, i64 verbose, i64 shortnames);
static void pc_api_extendpclblock();
static u64 pc_api_newpcl();
static void pc_api_pc_genix(i64 opcode, i64 scale, i64 offset);
static void pc_api_pc_genx(i64 opcode, i64 x, u64 p);
static void pc_api_pc_genxy(i64 opcode, i64 x, i64 y, u64 p);
static void pc_api_pc_gencond(i64 opcode, i64 cond, u64 p);
static u64 pc_api_genint(i64 a);
static u64 pc_api_genreal(r64 x, i64 mode);
static u64 pc_api_genrealimm(r64 x, i64 mode);
static u64 pc_api_genstring(u64 s);
static u64 pc_api_genpcstrimm(u64 s);
static u64 pc_api_genlabel(i64 a);
static u64 pc_api_genmem(u64 d);
static u64 pc_api_genmemaddr(u64 d);
static u64 pc_api_gendata(u64 s, i64 length);
static void pc_api_gencomment(u64 s);
static u64 pc_api_genname(u64 s);
static u64 pc_api_gennameaddr(u64 s);
static u64 pc_api_genassem(u64 code);
static void pc_api_pc_setmode(i64 m, i64 size);
static void pc_api_pc_setmode2(i64 m);
static void pc_api_pc_setxy(i64 x, i64 y);
static void pc_api_pc_setscaleoff(i64 scale, i64 offset);
static void pc_api_pc_setoffset(i64 offset);
static void pc_api_pc_addoffset(i64 offset);
static void pc_api_pc_setincr(i64 n);
static void pc_api_pc_setnargs(i64 n);
static void pc_api_pc_setnvariadics(i64 n);
static void pc_api_pc_setalign(i64 n);
static void pc_api_perror(u64 mess);
static void pc_api_perror_s(u64 mess, u64 param);
static u64 pc_api_getbasename(u64 s);
static void pc_api_pc_addsymbol(u64 d);
static void pc_api_pcerrorstop(u64 filename, i64 lineno);
static void pc_api_pc_addplib(u64 name);
static void pc_api_pc_defproc(u64 d, i64 mode, i64 isentry, i64 threaded);
static void pc_api_pc_setimport(u64 d);
static void pc_api_pc_addparam(u64 d);
static void pc_api_pc_addlocal(u64 d);
static void pc_api_pc_endproc();
static void pc_api_merror(u64 mess, u64 param);
static u64 pc_api_pc_duplpst(u64 d);
static void pc_api_pcl_cmdskip(i64 cmdskip, u64 dcmdskip);
static i64 pc_api_convertstring(u64 s, u64 t);
static void pc_diags_dummy_pshowlogfile();
static void pc_diags_dummy_strpcl(u64 p);
static u64 pc_diags_dummy_stropnd(u64 p);
static u64 pc_diags_dummy_strpclstr(u64 p, i64 buffsize);
static void pc_diags_dummy_writepcl(u64 p);
static void pc_reduce_pcl_reducetest();
static i64 pc_run_dispatch_loop(u64 pcentry, i64 cmain);
static i64 pc_runaux_pci_getopnd(u64 p, u64 locals);
static i64 pc_runaux_pci_loadptr(u64 p, i64 mode);
static void pc_runaux_pci_storeptr(u64 p, i64 a, i64 mode, i64 size);
static void pc_runaux_pcusopnd(u64 p);
static u64 pc_runaux_pci_loadbf(u64 a, u64 i, u64 j);
static u64 pc_runaux_pci_storebf(u64 a, u64 i, u64 j, u64 x);
static i64 pc_run_getlineno(u64 pc);
static void pc_runaux_pcerrorx(u64 p, u64 mess, u64 param);
static i64 pc_runaux_docalldll(u64 d, u64 fnaddr, u64 revargs, i64 nargs, i64 nvars, i64 retmode);
static i64 pc_runaux_cmpreal(i64 cond, r64 x, r64 y);
static i64 pc_runaux_cmpint(i64 cond, i64 x, i64 y);
static i64 pc_runaux_cmpword(i64 cond, u64 x, u64 y);
static u64 pc_runaux_pci_getopndaddr(u64 p, u64 locals);
static void pc_runaux_doincr(u64 pu8, i64 incr, i64 mode);
static void pc_run_fixuppcl();
static u64 pc_runaux_getdllfnptr(u64 d);
static void pc_run_pcl_runpcl();
static void pc_runaux_loadlibs();
static void pc_runaux_docmdskip();
static void mc_libmcl_mclinit(i64 bypass);
static void mc_genmcl_convertpcl(u64 p);
static void mc_stackmcl_showopndstack();
static void mc_auxmcl_genrealtable();
static void mc_auxmcl_genabsneg();
static void mc_auxmcl_genstringtable();
static void mc_libmcl_genmc(i64 opcode, u64 a, u64 b);
static void mc_optim_peephole();
static void mc_genmcl_unimpl(u64 p);
static void mc_genmcl_doshowpcl(u64 p);
static void mc_libmcl_mgencomment(u64 s);
static void mc_genmcl_px_nop(u64 p);
static void mc_genmcl_px_dupl(u64 p);
static void mc_stackmcl_duplpcl();
static void mc_genmcl_px_double(u64 p);
static void mc_genmcl_px_opnd(u64 p);
static void mc_genmcl_px_type(u64 p);
static void mc_genmcl_px_comment(u64 p);
static void mc_genmcl_px_proc(u64 p);
static void mc_libmcl_setsegment(i64 seg, i64 align);
static u64 mc_libmcl_mgenmemaddr(u64 d);
static void mc_auxmcl_initproc(u64 d);
static void mc_auxmcl_fixmain();
static void mc_genmcl_px_endproc(u64 p);
static void mc_genmcl_px_endprog(u64 p);
static void mc_genmcl_px_istatic(u64 p);
static void mc_genmcl_px_zstatic(u64 p);
static u64 mc_libmcl_mgenint(i64 x, i64 mode);
static void mc_genmcl_px_data(u64 p);
static void mc_auxmcl_do_blockdata(u64 p);
static u64 mc_libmcl_mgenrealimm(r64 x, i64 mode);
static i64 mc_libmcl_getstringindex(u64 s);
static u64 mc_libmcl_mgenlabel(i64 x);
static void mc_genmcl_px_label(u64 p);
static void mc_genmcl_px_load(u64 p);
static void mc_stackmcl_pushpcl(u64 p);
static void mc_genmcl_px_store(u64 p);
static u64 mc_stackmcl_loadopnd(i64 n, i64 mode, i64 reg);
static u64 mc_libmcl_mgenmem(u64 d, i64 mode);
static u64 mc_stackmcl_getworkregm(i64 mode);
static u64 mc_stackmcl_makeopndind(u64 a, i64 mode);
static void mc_auxmcl_copyblock(u64 ax, u64 bx, i64 n, i64 savedest);
static void mc_stackmcl_poppcl();
static void mc_genmcl_px_add(u64 p);
static u64 mc_stackmcl_isimmload(i64 n);
static u64 mc_stackmcl_getopnd(i64 n, i64 mode, i64 reg);
static void mc_genmcl_px_sub(u64 p);
static void mc_genmcl_px_mul(u64 p);
static void mc_auxmcl_mulimm(u64 ax, i64 n);
static void mc_genmcl_px_div(u64 p);
static void mc_genmcl_px_eval(u64 p);
static void mc_genmcl_px_widen(u64 p);
static void mc_stackmcl_setnewzz(i64 reg, i64 mode);
static void mc_genmcl_px_jump(u64 p);
static void mc_genmcl_px_ijump(u64 p);
static void mc_genmcl_px_neg(u64 p);
static void mc_auxmcl_do_negreal(u64 ax, i64 mode);
static void mc_genmcl_px_abs(u64 p);
static void mc_libmcl_genmc_cond(i64 opcode, i64 cond, u64 a, u64 b);
static void mc_auxmcl_do_absreal(u64 ax, i64 mode);
static void mc_genmcl_px_bitnot(u64 p);
static void mc_genmcl_px_not(u64 p);
static u64 mc_libmcl_changeopndsize(u64 a, i64 size);
static void mc_genmcl_px_toboolt(u64 p);
static void mc_genmcl_px_sqr(u64 p);
static void mc_genmcl_px_sqrt(u64 p);
static void mc_genmcl_px_jumpcc(u64 p);
static void mc_genmcl_px_jumpt(u64 p);
static void mc_auxmcl_do_jumptruefalse(u64 p, i64 cond);
static void mc_genmcl_px_jumpf(u64 p);
static void mc_genmcl_px_bitand(u64 p);
static void mc_auxmcl_do_bitwise(u64 p, i64 opc);
static void mc_genmcl_px_bitor(u64 p);
static void mc_genmcl_px_bitxor(u64 p);
static void mc_genmcl_px_shl(u64 p);
static void mc_auxmcl_do_shift(u64 p, i64 opc);
static void mc_genmcl_px_shr(u64 p);
static void mc_genmcl_px_retproc(u64 p);
static void mc_auxmcl_do_procentry(u64 p);
static void mc_auxmcl_do_procexit();
static void mc_genmcl_px_retfn(u64 p);
static u64 mc_libmcl_mgenireg(i64 reg, i64 mode, i64 offset);
static u64 mc_libmcl_mgenreg(i64 reg, i64 mode);
static void mc_genmcl_px_setcall(u64 p);
static void mc_stackmcl_saveopnds(i64 n);
static void mc_libmcl_pushslots(i64 nslots);
static void mc_genmcl_px_setarg(u64 p);
static void mc_auxmcl_copyblockarg(u64 px, i64 size, i64 argno);
static void mc_stackmcl_pushopnd(i64 n, i64 mode);
static void mc_genmcl_px_callp(u64 p);
static void mc_auxmcl_do_pushlowargs(i64 nargs, i64 nvariadics, i64 isptr);
static void mc_libmcl_popslots(i64 nslots);
static void mc_auxmcl_do_getretvalue(u64 p);
static void mc_genmcl_px_jumpret(u64 p);
static u64 mc_stackmcl_loadparam(i64 n, i64 mode, i64 reg);
static void mc_genmcl_px_jumpretm(u64 p);
static void mc_stackmcl_movetoreg(i64 newreg);
static void mc_genmcl_px_startmx(u64 p);
static void mc_genmcl_px_resetmx(u64 p);
static void mc_genmcl_px_stop(u64 p);
static void mc_genmcl_px_incrto(u64 p);
static void mc_auxmcl_do_incr(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_decrto(u64 p);
static void mc_genmcl_px_incrload(u64 p);
static void mc_auxmcl_do_incrload(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_decrload(u64 p);
static void mc_genmcl_px_loadincr(u64 p);
static void mc_auxmcl_do_loadincr(u64 p, i64 incrop, i64 addop);
static void mc_genmcl_px_loaddecr(u64 p);
static void mc_genmcl_px_forup(u64 p);
static void mc_auxmcl_do_for(u64 p, i64 incop, i64 addop, i64 cond);
static void mc_genmcl_px_fordown(u64 p);
static void mc_genmcl_px_iload(u64 p);
static u64 mc_stackmcl_getopnd_ind(i64 n, i64 mode);
static i64 mc_genmcl_getsharereg(u64 ax, i64 mode);
static u64 mc_stackmcl_getworkreg_rm(i64 reg, i64 mode);
static u64 mc_stackmcl_getopnd_ind_simp(i64 n, i64 mode);
static void mc_auxmcl_dolea(u64 ax, u64 px);
static void mc_genmcl_px_iloadx(u64 p);
static u64 mc_auxmcl_do_addrmode(u64 p);
static void mc_genmcl_px_istore(u64 p);
static u64 mc_stackmcl_makesimpleaddr(u64 ax);
static void mc_genmcl_px_istorex(u64 p);
static void mc_genmcl_px_storem(u64 p);
static u64 mc_libmcl_newblocktemp(i64 size);
static u64 mc_libmcl_applyoffset(u64 a, i64 offset, i64 size);
static void mc_genmcl_px_addpx(u64 p);
static void mc_genmcl_px_subpx(u64 p);
static i64 mc_auxmcl_scaleindex(u64 ax, i64 scale);
static void mc_genmcl_px_to(u64 p);
static void mc_genmcl_px_iswap(u64 p);
static void mc_genmcl_px_swapstk(u64 p);
static void mc_stackmcl_swapopnds(i64 m, i64 n);
static void mc_genmcl_px_labeldef(u64 p);
static void mc_genmcl_px_addto(u64 p);
static void mc_auxmcl_do_binto(u64 p, i64 opc, i64 fopc);
static void mc_genmcl_px_subto(u64 p);
static void mc_genmcl_px_multo(u64 p);
static void mc_auxmcl_do_binto_float(u64 p, i64 opc);
static void mc_stackmcl_pushpcl_reg(i64 mode, i64 reg);
static void mc_genmcl_px_bitandto(u64 p);
static void mc_genmcl_px_bitorto(u64 p);
static void mc_genmcl_px_bitxorto(u64 p);
static void mc_genmcl_px_shlto(u64 p);
static void mc_auxmcl_do_shiftnto(u64 p, i64 opc);
static void mc_genmcl_px_shrto(u64 p);
static void mc_genmcl_px_fix(u64 p);
static void mc_genmcl_px_float(u64 p);
static i64 mc_libmcl_mcreatefwdlabel();
static void mc_libmcl_mdefinefwdlabel(i64 lab);
static u64 mc_libmcl_mgenlabelmem(i64 x);
static void mc_genmcl_px_idiv(u64 p);
static void mc_auxmcl_do_divrem(u64 p, i64 issigned, i64 isdiv);
static void mc_genmcl_px_irem(u64 p);
static void mc_genmcl_px_idivrem(u64 p);
static void mc_genmcl_px_clear(u64 p);
static void mc_auxmcl_clearblock(u64 ax, i64 n);
static void mc_genmcl_px_subp(u64 p);
static i64 mc_libmcl_ispoweroftwo(i64 x);
static void mc_genmcl_px_switch(u64 p);
static i64 mc_stackmcl_getworkireg();
static u64 mc_libmcl_mgenindex(i64 areg, i64 ireg, i64 scale, i64 offset, i64 size, i64 labno, u64 def);
static void mc_genmcl_px_switchu(u64 p);
static void mc_genmcl_px_swlabel(u64 p);
static void mc_genmcl_px_endsw(u64 p);
static void mc_genmcl_px_fwiden(u64 p);
static void mc_genmcl_px_fnarrow(u64 p);
static void mc_genmcl_px_truncate(u64 p);
static void mc_genmcl_px_typepun(u64 p);
static void mc_genmcl_px_unload(u64 p);
static void mc_genmcl_px_loadbit(u64 p);
static void mc_genmcl_px_assem(u64 p);
static void mc_genmcl_px_sin(u64 p);
static void mc_auxmcl_do_maths(u64 p, u64 opname, i64 nargs);
static void mc_genmcl_px_cos(u64 p);
static void mc_genmcl_px_tan(u64 p);
static void mc_genmcl_px_asin(u64 p);
static void mc_genmcl_px_acos(u64 p);
static void mc_genmcl_px_atan(u64 p);
static void mc_genmcl_px_log(u64 p);
static void mc_genmcl_px_log10(u64 p);
static void mc_genmcl_px_exp(u64 p);
static void mc_genmcl_px_round(u64 p);
static void mc_genmcl_px_floor(u64 p);
static void mc_genmcl_px_ceil(u64 p);
static void mc_genmcl_px_atan2(u64 p);
static void mc_genmcl_px_fmod(u64 p);
static void mc_genmcl_px_setcc(u64 p);
static void mc_genmcl_px_min(u64 p);
static void mc_auxmcl_do_max_int(i64 cond);
static void mc_auxmcl_do_max_float(i64 opc);
static void mc_genmcl_px_max(u64 p);
static void mc_genmcl_px_power(u64 p);
static u64 mc_auxmcl_gethostfn(i64 opc);
static void mc_auxmcl_do_host(u64 p, u64 d, i64 nargs);
static void mc_genmcl_px_minto(u64 p);
static void mc_auxmcl_do_maxto_int(i64 cond, i64 mode);
static void mc_auxmcl_do_maxto_real(i64 cond, i64 mode);
static void mc_genmcl_px_maxto(u64 p);
static void mc_genmcl_px_negto(u64 p);
static void mc_genmcl_px_absto(u64 p);
static void mc_genmcl_px_addpxto(u64 p);
static void mc_genmcl_px_subpxto(u64 p);
static void mc_genmcl_px_divto(u64 p);
static void mc_genmcl_px_bitnotto(u64 p);
static void mc_genmcl_px_notto(u64 p);
static void mc_genmcl_px_toboolto(u64 p);
static void mc_genmcl_px_sign(u64 p);
static void mc_libmcl_clearreg(u64 ax);
static u64 mc_libmcl_mgenrealmem(r64 x, i64 mode);
static void mc_genmcl_px_loadbf(u64 p);
static void mc_auxmcl_do_loadbf_const(u64 p, i64 i, i64 j);
static void mc_auxmcl_do_loadbf_var(u64 p);
static void mc_genmcl_px_storebit(u64 p);
static void mc_auxmcl_do_storebit(u64 p);
static void mc_genmcl_px_storebf(u64 p);
static void mc_auxmcl_do_storebf(u64 p);
static void mc_genmcl_px_loadall(u64 p);
static void mc_stackmcl_checkallloaded();
static void mc_genmcl_px_setjmp(u64 p);
static void mc_stackmcl_freeworkregs(u64 p);
static void mc_genmcl_px_longjmp(u64 p);
static void mc_stackmcl_swapopndregs(i64 reg2);
static void mc_genmcl_px_initdswx(u64 p);
static void mc_auxmcl_allocregvars(i64 skipparams, i64 isleaf);
static void mc_auxmcl_setmclentry(u64 p);
static u64 mc_libmcl_mgenname(u64 s);
static i64 mc_libmcl_roundsizetg(i64 size);
static u64 mc_auxmcl_resetmclentry();
static u64 mc_libmcl_mgenxreg(i64 xreg, i64 size);
static void mc_auxmcl_spillparams();
static void mc_auxmcl_setmclentryf(u64 p);
static void mc_libmcl_pushstack(i64 n);
static u64 mc_auxmcl_resetmclentryf();
static void mc_libmcl_popstack(i64 n);
static i64 mc_auxmcl_ismemaddr(i64 n);
static i64 mc_auxmcl_scaleregvar(i64 reg, u64 scale, i64 n);
static void mc_auxmcl_saverdx();
static void mc_auxmcl_fixdivopnds(i64 locyy, i64 loczz);
static void mc_auxmcl_restorerdx();
static void mc_auxmcl_genstring_db(u64 s, i64 length, i64 strtype);
static void mc_auxmcl_gendb(i64 a);
static void mc_auxmcl_gendbstring(u64 s, i64 length);
static u64 mc_libmcl_mgenstring(u64 s, i64 length);
static void mc_auxmcl_gendq(i64 a);
static void mc_auxmcl_do_callrts(u64 p, u64 opname, u64 d, i64 nargs);
static u64 mc_libmcl_mgenreg0(i64 reg, i64 size);
static u64 mc_libmcl_newmclopnd();
static void mc_libmcl_initmcdest();
static u64 mc_libmcl_mgenint0(i64 x, i64 size);
static void mc_libmcl_genmc_str(i64 opcode, u64 s);
static u64 mc_libmcl_duplopnd(u64 a);
static i64 mc_libmcl_getrealindex(r64 x);
static i64 mc_libmcl_getr32index(r64 x);
static u64 mc_libmcl_mgenxregvar(u64 d);
static u64 mc_libmcl_mgenregvar(u64 d, i64 mode);
static u64 mc_libmcl_mgenregi(i64 reg, i64 mode);
static u64 mc_libmcl_mgentemp(i64 n, i64 mode);
static void mc_libmcl_merroropnd(u64 mess, i64 opndtype);
static u64 mc_libmcl_findnamesym(u64 s);
static void mc_libmcl_addnamesym(u64 d);
static i64 mc_libmcl_getprimreg(u64 ax);
static i64 mc_libmcl_addconst(u64 clist, i64 value);
static void mc_libmcl_axerror(u64 mess);
static void mc_libmcl_callproc(u64 cpname, u64 name, i64 lineno);
static u64 mc_libmcl_mgenstringx(u64 s);
static i64 mc_stackmcl_getworkreg(i64 mode);
static u64 mc_stackmcl_loadtoreg(u64 ax, i64 mode, i64 reg);
static u64 mc_stackmcl_loadtoreg_m(u64 ax, i64 mode, i64 reg);
static void mc_stackmcl_loadtoreg_common(u64 bx, u64 ax);
static void mc_stackmcl_savenextopnd();
static i64 mc_stackmcl_getworkxreg();
static void mc_stackmcl_saveopnd(i64 n, i64 allregs);
static void mc_stackmcl_savenextxopnd();
static i64 mc_optim_isreg0(u64 a);
static i64 mc_optim_endr0(u64 m);
static i64 mc_optim_isreg10(u64 a);
static i64 mc_optim_isreg(u64 a);
static u64 mc_optim_deletemcl(u64 p);
static i64 mc_optim_isconst(u64 a);
static i64 mc_optim_isreg00(u64 m);
static i64 mc_optim_sameoperand(u64 a, u64 b);
static i64 mc_optim_sameregopnd(u64 a, u64 b);
static void mc_genss_initlib(i64 nlabels);
static u64 mc_genss_buffercreate(i64 size);
static void mc_genss_switchseg(i64 newseg);
static void mc_genss_doinstr(u64 m, i64 index);
static i64 mc_genss_bufferlength(u64 a);
static u64 mc_genss_bufferelemptr(u64 a, i64 offset);
static void mc_genss_bufferexpand(u64 a);
static i64 mc_genss_getcurrdatalen(i64 id);
static i64 mc_genss_getstindex(u64 d);
static void mc_genss_dofwdrefs(u64 d);
static void mc_genss_do_call(u64 a);
static void mc_genss_do_jmp(u64 a, u64 m);
static u64 mc_genss_getdef(u64 a, i64 dneeded);
static i64 mc_genss_getrel32(u64 d, i64 offset);
static void mc_genss_gendword(i64 x);
static i64 mc_genss_checkshortjump(u64 m, u64 d);
static void mc_genss_genrel32(u64 a);
static void mc_genss_genrel8(u64 a);
static void mc_genss_genopnd(u64 a, i64 size);
static void mc_genss_genword(i64 x);
static void mc_genss_do_push(u64 a);
static void mc_genss_do_pop(u64 a);
static void mc_genss_do_inc(u64 a, i64 code);
static void mc_genss_do_neg(u64 a, i64 code);
static void mc_genss_do_arith(u64 a, u64 b, i64 code);
static void mc_genss_do_mov(u64 a, u64 b);
static void mc_genss_do_lea(u64 a, u64 b);
static void mc_genss_do_movsx(u64 a, u64 b, i64 opc);
static void mc_genss_do_movsxd(u64 a, u64 b);
static void mc_genss_do_exch(u64 a, u64 b);
static void mc_genss_do_imul2(u64 a, u64 b);
static void mc_genss_buffercheck(u64 a, i64 n);
static void mc_genss_do_shift(u64 a, u64 b, i64 code);
static void mc_genss_do_test(u64 a, u64 b);
static void mc_genss_do_loop(u64 a, i64 opc);
static void mc_genss_do_jcxz(u64 a, i64 opsize);
static void mc_genss_do_setcc(i64 cond, u64 b);
static void mc_genss_do_movxmm(u64 a, u64 b, i64 size);
static void mc_genss_do_arithxmm(u64 a, u64 b, i64 prefix, i64 opc);
static void mc_genss_do_logicxmm(u64 a, u64 b, i64 opc, i64 size);
static void mc_genss_do_convertfloat(u64 a, u64 b, i64 prefix);
static void mc_genss_do_fix(u64 a, u64 b, i64 prefix, i64 opc);
static void mc_genss_do_float(u64 a, u64 b, i64 prefix);
static void mc_genss_do_cmovcc(i64 cond, u64 a, u64 b);
static void mc_genss_do_fmem(u64 a, i64 freal, i64 code);
static void mc_genss_do_movdqx(u64 a, u64 b, i64 prefix);
static void mc_genss_do_popcnt(u64 a, u64 b);
static void mc_genss_do_bsf(u64 a, u64 b, i64 opc);
static void mc_genss_do_bswap(u64 a);
static void mc_genss_do_dshift(u64 a, u64 b, i64 c, i64 opc);
static void mc_genss_start();
static void mc_genss_addword(u64 a, i64 x);
static void mc_genss_adddword(u64 a, i64 x);
static void mc_genss_genqword(i64 x);
static void mc_genss_addqword(u64 a, i64 x);
static void mc_genss_genabs32(u64 a);
static void mc_genss_genabs64(u64 a);
static void mc_genss_addrelocitem(i64 reloctype, u64 d);
static void mc_genss_extendsymboltable();
static u64 mc_genss_addfwdref(u64 p, i64 offset, i64 reltype, i64 seg);
static void mc_genss_genrex();
static i64 mc_genss_isbytesized(i64 x);
static i64 mc_genss_isdwordsized(i64 x);
static void mc_genss_genamode(u64 a, u64 am);
static void mc_genss_setopsize(u64 a);
static i64 mc_genss_getdispsize(u64 a, u64 offset);
static void mc_genss_checkhighreg(u64 a);
static void mc_genss_genxrm(i64 opcode, i64 code, u64 b);
static void mc_genss_genrrm(i64 opcode, u64 a, u64 b);
static i64 mc_genss_getregcode(i64 reg, i64 mask, i64 isxreg);
static void mc_genss_checkimmrange(i64 value, i64 size);
static u64 mc_writenasm_strmclstr(u64 m);
static void mc_genss_fixrip(i64 dispsize);
static void mc_genss_checksize(u64 a, i64 size1, i64 size2);
static void mc_decls_start();
static void mc_writenasm_asmstr(u64 s);
static void mc_writenasm_writemcl(i64 index, u64 mcl);
static void mc_writenasm_start();
static void mc_writenasm_asmchar(i64 c);
static void mc_writenasm_asmopnd(u64 a, i64 sizeprefix, i64 opcode);
static u64 mc_writenasm_strreg(i64 reg, i64 size);
static u64 mc_writenasm_strxreg(i64 reg, i64 size);
static i64 mc_writenasm_needsizeprefix(i64 opcode, u64 a, u64 b);
static u64 mc_writenasm_getsizeprefix(i64 size, i64 enable);
static u64 mc_writenasm_checkregvar(i64 reg, i64 ispfloat);
static void mc_writeexe_genexe1(u64 entrypoint, u64 outfile, i64 dodll);
static void mc_writeexe_genexe2(u64 outfile, i64 dodll);
static void mc_writeexe_initsectiontable();
static void mc_writeexe_loadlibs();
static void mc_writeexe_scanst();
static void mc_writeexe_getoffsets();
static void mc_writeexe_relocdata(u64 s);
static i64 mc_writeexe_getripoffset(i64 addr, i64 dest, i64 extra);
static void mc_writeexe_writepesig();
static void mc_writeexe_writefileheader();
static void mc_writeexe_writeoptheader();
static void mc_writeexe_writesectionheader(u64 s);
static void mc_writeexe_writepadding(i64 offset);
static void mc_writeexe_writesectiondata(u64 s);
static u64 mc_writeexe_extractlibname(u64 name, u64 libno, i64 moduleno);
static void mc_writeexe_getbaserelocs(u64 s);
static void mc_writeexe_newbasereloc(i64 addr, i64 reltype);
static void mc_writeexe_writerecordx(u64 r, i64 length);
static void mc_writeexe_writeexporttable(u64 pstart);
static void mc_writeexe_sortexports(u64 sortindex);
static i64 mc_writeexe_getsectionno(i64 segment);
static i64 mc_writeexe_getexporttablesize();
static void mc_writeexe_scanbaserelocs();
static void mc_writeexe_writebasereloctable(u64 pstart);
static void mc_writeobj_initsymboltable(u64 filename);
static void mc_writeobj_convertsymboltable();
static void mc_writeobj_writerecord(u64 r, i64 length);
static void mc_writeobj_writedata(u64 data);
static void mc_writeobj_writesymboltable();
static void mc_writeobj_writestringtable();
static i64 mc_writeobj_addstringentry(u64 s, i64 length);
static void mc_writeobj_addsymbol(u64 r);
static u64 mx_run_writememlib(u64 filename);
static void mx_run_roundsegment(u64 p, i64 align, i64 value);
static void mx_run_countsymbols();
static void mx_run_writerelocs(u64 lib);
static void mx_run_addsymbols(u64 lib);
static void mx_lib_loadmemmcu(u64 lib);
static void mx_lib_fixuplib(u64 lib);
static void mx_lib_runprogram(u64 lib, i64 cmdskip);
static u64 mx_lib_readlibfile(u64 filespec, u64 p);
static u64 mx_lib_readu32(u64 p);
static i64 mx_lib_readbyte(u64 p);
static u64 mx_lib_readstring(u64 p);
static void mx_lib_alloclibdata(u64 lib);
static void mx_lib_error(u64 mess, u64 param);
static void mx_lib_checknew(u64 name, u64 filename);
static i64 mx_lib_mxaddlib(u64 name);
static void mx_lib_loadimports(u64 plib);
static i64 mx_lib_findlib(u64 name);
static void mx_lib_loaddlls();
static void mx_lib_checksymbols();
static void mx_lib_dorelocations();
static u64 mx_lib_finddllsymbol(u64 name, u64 dllindex);
static void mx_lib_reloclib(u64 lib);
static void mx_lib_dosublib(u64 name);
static void mx_lib_dosymbols(u64 lib);
static u64 mx_lib_loadlibfile(u64 filename, i64 libno);
static u64 mx_lib_readmxfile(u64 filename);
static void mx_lib_adddll(u64 name);
static i64 mx_lib_addsymbol(u64 name);
static void mx_lib_setspecialglobals(i64 cmdskip);
static void mx_lib_calllibinit(u64 lib);
static u64 mx_lib_findsymbol(u64 name);
static u64 mx_lib_loadmx(u64 filename);
static u64 mx_lib_loadmemmcb(u64 filename, u64 p);
static void mx_write_roundsegment(u64 p, i64 align, i64 value);
static void mx_write_genu32(i64 x);
static void mx_write_genbyte(i64 x);
static void mx_write_genstring(u64 s);
static void mx_write_writerelocs();
static void mx_write_genblock(u64 p, i64 length);
static void mx_write_writesymbols();
void cc_cli_main();
static void pclpe_start();
static void cc_cli_starttiming();
static void cc_cli_initdata();
static void cc_cli_getinputoptions();
static void cc_cli_initsearchdirs();
static void cc_cli_showsearchdirs();
static void cc_cli_initlogfile();
static i64 cc_cli_gettiming();
static void cc_cli_do_loadmodule();
static void cc_cli_do_preprocess();
static void cc_cli_do_parsemodule();
static void cc_cli_do_genpcl();
static void cc_cli_do_genmcl();
static void cc_cli_do_asm();
static void cc_cli_do_obj();
static void cc_cli_do_dll();
static void cc_cli_do_exe();
static void cc_cli_do_mx();
static void cc_cli_do_run();
static void cc_cli_showtiming();
static void cc_cli_closelogfile();
static u64 cc_lex_addnamestr(u64 name);
static u64 cc_lib_createdupldef(u64 owner, u64 symptr, i64 id);
static void cc_support_loaderror(u64 mess, u64 mess2);
static i64 cc_support_loadsourcefile(u64 file, u64 shortfile);
static i64 cc_parse_parsemodule();
static void cc_genpcl_codegen_pcl();
static void cc_lib_addtolog(u64 filename, u64 logdest);
static void cc_cli_showast();
static void cc_cli_showst(u64 caption);
static void cc_cli_showstflat(u64 caption);
static void cc_showdummy_printmodelist(u64 f);
static void cc_lex_lexsetup();
static void cc_lib_inittypetables();
static void cc_lib_initcclib();
static i64 cc_cli_cgetsourceinfo(i64 pos, u64 filename, u64 sourceline);
static void cc_showdummy_printcode(u64 f, u64 caption);
static void cc_showdummy_printstflat(u64 f);
static void cc_showdummy_printst(u64 f, u64 p, i64 level);
static void cc_cli_showfiles();
static void cc_cli_showtime(u64 caption, i64 t);
static void cc_cli_do_option(i64 sw, u64 value);
static void cc_cli_showcaption();
static void cc_headers_writeheaders();
static void cc_cli_showhelp();
static void cc_cli_showincludepaths();
static void cc_lex_setfileno(i64 fileno);
static void cc_lex_stacksourcefile(u64 file, i64 syshdr);
static void cc_lex_emittoken(u64 lp, u64 dest, i64 forcespace);
static void cc_lex_lxerror(u64 mess);
static void cc_lex_showtokens(u64 caption, u64 tk);
static void cc_lex_lexreadtoken();
static void cc_lex_lxreadstring(i64 termchar, i64 fwide);
static i64 cc_lex_lookup();
static void cc_lex_setnumberoffset(i64 offset);
static void cc_lex_readdecimal(u64 pstart);
static void cc_lex_readhex(u64 pstart);
static void cc_lex_readbinary(u64 pstart);
static void cc_lex_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base);
static void cc_lex_readoctal(u64 pstart);
static void cc_lex_readlinecomment();
static void cc_lex_readblockcomment();
static void cc_lex_unstacksourcefile();
static void cc_lex_old_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base);
static u64 cc_lex_scannumber(i64 base);
static i64 cc_lex_readexponent(u64 badexpon);
static void cc_lex_readalphanumeric(u64 pstart);
static i64 cc_lex_getfileno();
static void cc_lex_printsymbol(u64 lp);
static void cc_lex_printstrn(u64 s, i64 length, u64 f);
static void cc_lex_shownumberstr(u64 l, u64 f);
static void cc_lex_inithashtable();
static void cc_lex_fillhashtable();
static void cc_lex_newhashtable();
static u64 cc_lex_gethashvalue(u64 s, i64 length);
static i64 cc_lex_dolexdirective();
static i64 cc_lex_getlexdirective();
static u64 cc_lex_strtoken(u64 lp, u64 length);
static void cc_lex_dodefine();
static i64 cc_lex_getifdef();
static i64 cc_lex_getifexpr();
static i64 cc_lex_skipcode();
static void cc_lex_dopragmadir();
static void cc_lex_startlex(u64 caption, i64 fileno);
static void cc_lex_lex();
static void cc_lex_endlex();
static void cc_lex_ps(u64 caption);
static void cc_lex_psnext(u64 caption);
static i64 cc_lex_gethashtablesize();
static i64 cc_lex_checknumbersuffix();
static u64 cc_headers_findheader(u64 name);
static i64 cc_support_loadbuiltin(u64 shortfile, u64 hdrtext);
static i64 cc_lex_getfilenox(u64 tk);
static i64 cc_lex_getnumberoffsetx(u64 tk);
static void cc_lex_addlisttoken(u64 ulist, u64 ulistx, u64 p);
static void cc_lex_addlisttoken_copy(u64 ulist, u64 ulistx, u64 q);
static u64 cc_lex_alloctoken();
static void cc_lex_addlist_nextlx(u64 ulist, u64 ulistx);
static void cc_lex_addlisttoken_seq(u64 ulist, u64 ulistx, u64 seq);
static void cc_lex_addlistmparam(u64 ulist, u64 ulistx, u64 p);
static i64 cc_lex_inmacrostack(u64 d, u64 macrostack);
static void cc_lex_lexa(u64 tk);
static i64 cc_lex_peeklb();
static void cc_lex_dospecialinclude();
static u64 cc_lex_expandfnmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel, u64 endlineno);
static u64 cc_lex_expandobjmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel);
static i64 cc_lex_peektk(u64 tk);
static u64 cc_lex_substituteargs(u64 m, u64 args, u64 expargs, i64 nargs, u64 macrostack);
static u64 cc_lex_scantokenseq(u64 tk, u64 macrostack, u64 expanded);
static i64 cc_lex_readmacrocall(u64 d, u64 args, u64 tksource);
static u64 cc_lex_alloctokenz();
static void cc_lex_setfilenox(u64 tk, i64 fileno);
static void cc_lex_pastetokens(u64 tk, u64 tknext);
static u64 cc_lex_strstring(u64 s, i64 length, u64 newlength, i64 quotechar);
static i64 cc_lib_convertstringc(u64 s, u64 t, i64 length);
static i64 cc_lex_needspace(i64 a, i64 b);
static i64 cc_lex_evalcondexpr(u64 sx);
static i64 cc_lex_evalorexpr(u64 sx);
static i64 cc_lex_evalandexpr(u64 sx);
static i64 cc_lex_evaliorexpr(u64 sx);
static i64 cc_lex_evalixorexpr(u64 sx);
static i64 cc_lex_evaliandexpr(u64 sx);
static i64 cc_lex_evaleqexpr(u64 sx);
static i64 cc_lex_evalcmpexpr(u64 sx);
static i64 cc_lex_evalshiftexpr(u64 sx);
static i64 cc_lex_evaladdexpr(u64 sx);
static i64 cc_lex_evalmulexpr(u64 sx);
static i64 cc_lex_evalunaryexpr(u64 sx);
static i64 cc_lex_evalterm(u64 sx);
static void cc_lex_fastreadtoken();
static void cc_lex_freetokens(u64 tk);
static void cc_lex_addbuildinfo(i64 code);
static void cc_lex_freehashtable();
static void cc_lex_regenlookup(u64 d);
static void cc_parse_readmodule();
static void cc_support_serror(u64 mess);
static i64 cc_parse_readdeclspec(u64 owner, u64 linkage);
static i64 cc_parse_readtype(u64 owner, u64 d, i64 m, u64 pm);
static i64 cc_lib_createprocmode(i64 m, u64 pm);
static u64 cc_parse_createtypedef(u64 owner, u64 symptr, i64 mode);
static u64 cc_parse_readfunction(u64 d, i64 m, i64 linkage, u64 pm, u64 wasdef);
static u64 cc_parse_readmodulevar(u64 d, i64 m, i64 linkage);
static void cc_lib_skipsymbol(i64 symbol);
static void cc_support_serror_s(u64 mess, u64 a);
static void cc_lib_checksymbol(i64 symbol);
static i64 cc_parse_readstructdecl(u64 owner);
static i64 cc_parse_readenumdecl(u64 owner);
static i64 cc_parse_isusertype(u64 owner);
static i64 cc_lib_createconstmode(i64 m);
static i64 cc_parse_istypestarter();
static u64 cc_lib_resolvename(u64 owner, u64 symptr, i64 ns, i64 blockno);
static i64 cc_parse_istypestarter_next();
static u64 cc_parse_readexpression();
static u64 cc_parse_readterm();
static u64 cc_parse_readassignexpr();
static void cc_lib_addlistunit(u64 ulist, u64 ulistx, u64 p);
static u64 cc_lib_createunit1(i64 tag, u64 p);
static u64 cc_parse_readcondexpr();
static void cc_parse_checklvalue(u64 p, i64 assign);
static u64 cc_parse_createassignopref(i64 opc, u64 p, u64 q);
static u64 cc_parse_coercemode(u64 p, i64 t);
static void cc_support_terror(u64 mess);
static u64 cc_lib_createunit2(i64 tag, u64 p, u64 q);
static u64 cc_parse_readorlexpr();
static void cc_parse_coercecond(u64 p);
static u64 cc_lib_createunit3(i64 tag, u64 p, u64 q, u64 r);
static u64 cc_parse_readandlexpr();
static u64 cc_parse_readiorexpr();
static u64 cc_parse_readixorexpr();
static u64 cc_parse_readiandexpr();
static u64 cc_parse_readeqexpr();
static u64 cc_parse_readrelexpr();
static i64 cc_parse_checkpointertypes(i64 s, i64 t, i64 hard);
static u64 cc_parse_readshiftexpr();
static u64 cc_parse_readaddexpr();
static void cc_parse_coercebasetype(u64 p);
static u64 cc_parse_readmulexpr();
static u64 cc_parse_createaddop(u64 x, u64 y);
static u64 cc_parse_createsubop(u64 x, u64 y);
static u64 cc_parse_createmulop(u64 x, u64 y);
static u64 cc_parse_createdivop(u64 x, u64 y);
static u64 cc_parse_createremop(u64 x, u64 y);
static u64 cc_lib_createconstunit(u64 a, i64 t);
static u64 cc_lib_createunit0(i64 tag);
static i64 cc_lib_createrefmode(i64 m);
static u64 cc_lib_createname(u64 p);
static u64 cc_parse_createaddrofop(u64 p);
static void cc_parse_fixmemopnd(u64 p);
static u64 cc_lib_createwstringconstunit(u64 s, i64 length);
static u64 cc_lib_createstringconstunit(u64 s, i64 length);
static u64 cc_parse_createnegop(u64 p);
static u64 cc_parse_createinotop(u64 p);
static u64 cc_parse_createptrop(u64 p);
static u64 cc_parse_createincrop(i64 opc, u64 p);
static u64 cc_parse_createabsop(u64 p);
static i64 cc_parse_readcasttype(u64 d, i64 allowname, u64 pm, i64 m, u64 mbase);
static u64 cc_parse_docast(u64 p, i64 t, i64 hard, i64 inplace);
static u64 cc_parse_createsizeofop(u64 p, i64 islength);
static u64 cc_parse_readgeneric();
static u64 cc_parse_createindexop(u64 p, u64 q);
static u64 cc_parse_createdotop(i64 opc, u64 p, u64 d);
static u64 cc_parse_readexprlist(u64 p);
static u64 cc_parse_createcall(u64 p, u64 q);
static u64 cc_lib_checkdupl(u64 owner, u64 symptr, i64 ns, i64 blockno);
static void cc_support_serror_ss(u64 mess, u64 a, u64 b);
static i64 cc_parse_comparemode(i64 s, i64 t);
static u64 cc_parse_readinitexpr(u64 owner, i64 m);
static u64 cc_parse_readframevar(u64 d, i64 m, i64 linkage);
static u64 cc_lib_checkdupl_inproc(u64 owner, u64 symptr, i64 ns, i64 blockno);
static void cc_parse_readnamedtype(u64 owner, u64 d, u64 modtype, u64 modvalue, u64 nmodifiers);
static i64 cc_lib_createarraymode(i64 m, i64 length);
static u64 cc_parse_readparams(u64 owner);
static i64 cc_parse_readconstintexpr();
static u64 cc_parse_readinitexpr2(u64 owner, i64 m, i64 istop);
static void cc_parse_pushblock();
static void cc_parse_popblock();
static u64 cc_parse_readcompoundstmt(i64 params);
static u64 cc_parse_readstatement();
static u64 cc_parse_readblock(i64 ifelse);
static u64 cc_parse_readifstmt();
static u64 cc_parse_readforstmt();
static u64 cc_parse_readwhilestmt();
static u64 cc_parse_readdostmt();
static u64 cc_parse_readreturnstmt();
static u64 cc_parse_readswitchstmt();
static u64 cc_parse_readgotostmt();
static u64 cc_parse_readcaselabel();
static u64 cc_parse_readlocaldecl();
static u64 cc_parse_readcond();
static i64 cc_parse_iscondtrue(u64 p);
static void cc_parse_deleteunit(u64 p, u64 q);
static i64 cc_parse_iscondfalse(u64 p);
static u64 cc_parse_readexprstmt();
static void cc_parse_pushloop(i64 looptype);
static void cc_parse_poploop();
static void cc_parse_addcasevalue(i64 value);
static void cc_lib_addlistparam(u64 ulist, u64 ulistx, u64 p);
static void cc_parse_readfunctionbody(u64 f);
static i64 cc_lib_isintcc(i64 m);
static void cc_showdummy_printunit(u64 dev, u64 p, i64 level, u64 prefix);
static u64 cc_parse_arraytopointer(u64 p);
static i64 cc_parse_getmemmode(u64 p);
static u64 cc_parse_eval_add(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_divunit(u64 p, i64 elemtype);
static u64 cc_parse_mulunit(u64 p, i64 elemtype);
static u64 cc_parse_eval_sub(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_eval_mul(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_eval_div(i64 opc, u64 x, u64 y, i64 t);
static u64 cc_parse_eval_rem(i64 opc, u64 x, u64 y, i64 t);
static void cc_parse_insertunit(u64 p, i64 tag);
static i64 cc_parse_eval_convert(u64 p, i64 t, i64 opc);
static void cc_support_terror_s(u64 mess, u64 a);
static void cc_parse_coercemode_inplace(u64 p, i64 t);
static i64 cc_lib_createstructmode(u64 s, i64 smode);
static void cc_lib_addlistdef(u64 ulist, u64 ulistx, u64 p);
static i64 cc_lib_getalignment(i64 m);
static i64 cc_parse_roundoffset(i64 offset, i64 alignment);
static void cc_parse_addnewfield(u64 flist, u64 d, i64 offset);
static u64 cc_lib_getautofieldname();
static void cc_parse_readenumnames(u64 owner);
static i64 cc_lib_createenummode(u64 e);
static void cc_support_terror_ss(u64 mess, u64 a, u64 b);
static i64 cc_parse_getpromotedtype(i64 t);
static void cc_genpcl_dolibs();
static void cc_genpcl_dostaticvar(u64 d);
static void cc_support_gerror_s(u64 mess, u64 s, u64 p);
static void cc_genpcl_genprocdef(u64 p);
static u64 cc_libpcl_getpsymbol(u64 d);
static i64 cc_libpcl_createfwdlabel();
static void cc_blockpcl_do_stmt(u64 p);
static void cc_libpcl_definefwdlabel(i64 lab);
static void cc_libpcl_setmode(i64 mode);
static u64 cc_libpcl_genmem_d(u64 d);
static void cc_genpcl_genidata(u64 p, i64 doterm, i64 am, i64 offset);
static void cc_genpcl_doresb(i64 n);
static i64 cc_lib_isrealcc(i64 m);
static void cc_support_gerror(u64 mess, u64 p);
static u64 cc_libpcl_genmemaddr_d(u64 d);
static void cc_genpcl_pushint(i64 a);
static void cc_blockpcl_do_decl(u64 d);
static void cc_blockpcl_dx_call(u64 p, u64 a, u64 b, i64 res);
static void cc_blockpcl_do_return(u64 p, u64 a);
static void cc_blockpcl_do_assign(u64 a, u64 b, i64 res);
static void cc_blockpcl_do_if(u64 a, u64 b, u64 c);
static void cc_blockpcl_do_for(u64 pinit, u64 pbody);
static void cc_blockpcl_do_while(u64 pcond, u64 pbody);
static void cc_blockpcl_do_dowhile(u64 pbody, u64 pcond);
static void cc_blockpcl_do_goto(u64 d);
static void cc_blockpcl_do_labeldef(u64 d);
static void cc_blockpcl_do_casestmt(u64 p, u64 a);
static void cc_blockpcl_genjumpl(i64 lab);
static void cc_blockpcl_do_switch(u64 p, u64 a, u64 b);
static void cc_blockpcl_dx_binto(u64 a, u64 b, i64 opc, i64 res);
static void cc_blockpcl_do_preincr(u64 a, i64 incrop);
static void cc_blockpcl_dx_expr(u64 p, i64 am);
static void cc_libpcl_setmode_u(u64 p);
static void cc_blockpcl_dx_const(u64 p);
static void cc_blockpcl_dx_name(u64 p, i64 am);
static void cc_blockpcl_dx_andorl(u64 p);
static void cc_libpcl_setmode2(i64 mode);
static void cc_blockpcl_dx_ifx(u64 p, u64 a, u64 b, u64 c);
static void cc_blockpcl_dx_eq(u64 p, u64 a, u64 b);
static void cc_blockpcl_dx_bin(u64 a, u64 b, i64 opc);
static void cc_blockpcl_dx_ptr(u64 p, u64 a, i64 am);
static void cc_blockpcl_dx_addptr(u64 p, u64 a, u64 b, i64 opc, i64 am);
static void cc_blockpcl_dx_convert(u64 p, u64 a, i64 t, i64 opc);
static void cc_blockpcl_dx_scale(u64 p, u64 a, u64 b);
static void cc_blockpcl_dx_preincrx(u64 p, u64 a);
static void cc_blockpcl_dx_postincrx(u64 p, u64 a);
static void cc_blockpcl_dx_addrof(u64 p, u64 a, i64 am);
static void cc_blockpcl_dx_dot(u64 p, u64 a, u64 b, i64 am);
static void cc_blockpcl_widen(u64 p);
static void cc_blockpcl_do_setinplace();
static void cc_blockpcl_do_fixwiden(u64 a, u64 b);
static void cc_blockpcl_genjumpcond(i64 opc, u64 p, i64 lab);
static void cc_blockpcl_gcomparejump(i64 jumpopc, u64 p, u64 lhs, u64 rhs, i64 lab);
static i64 cc_blockpcl_getpclcond(i64 op);
static i64 cc_blockpcl_reversecond(i64 cc);
static void cc_blockpcl_do_while1(u64 pbody);
static void cc_blockpcl_stacklooplabels(i64 a, i64 b);
static i64 cc_libpcl_definelabel();
static void cc_blockpcl_setincrstep(i64 m);
static i64 cc_lib_getpclmode(i64 t);
static u64 cc_lib_newstrec();
static u64 cc_lib_allocunitrec();
static i64 cc_lib_getconstvalue(u64 p, i64 id);
static i64 cc_lib_copymode(i64 m);
static i64 cc_lib_createnewmode(i64 m);
static void cc_lib_setnameptr(u64 p);
static void cc_lib_istrmode(i64 m, i64 expand, u64 dest);
static void cc_support_mcerror(u64 mess);
static u64 cc_lib_createnewmoduledef(u64 owner, u64 symptr);
static u64 cc_lib_createnewproc(u64 owner, u64 symptr);
static u64 cc_lib_resolvelabel(u64 owner, u64 symptr);
static i64 cc_lib_isexported(u64 d);
static i64 cc_lib_isimported(u64 d);
static i64 cc_lib_ispoweroftwo(i64 x);
static void cc_lib_writegsfile(u64 filename, u64 d);
static void cc_lib_pause(u64 mess);
static void cc_support_stopcompiler(u64 filename, i64 lineno);
static void cc_support_serror_gen(u64 mess);
static void cc_support_showmacrolineno();
static void cc_support_terror_gen(u64 mess);
static void cc_support_gerror_gen(u64 mess, u64 p);
static i64 cc_support_nextpoweroftwo(i64 x);
static u64 cc_support_splicelines(u64 s);
static void cc_support_gs_copytostr(u64 source, u64 s);
static void cc_support_gs_additem(u64 dest, u64 s);
static i64 cc_support_isalphanum(i64 c);
static i64 cc_headers_isheaderfile(u64 file);
static u64 cc_showdummy_strexpr(u64 p);
static u64 cc_showdummy_writeallpcl();
static u64 cc_showdummy_strpclstr(u64 p);
static u64 cc_showdummy_stropndstack(i64 indent);
static void cc_showdummy_showopndstack();
static void cc_showdummy_printfilelist(u64 f);


int main(int nargs, char** args) {
    msysc_$getcommands(nargs, (u64)args, 0);
    cc_cli_main();
}

// **************************************************
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap = 0;

static i64 msysc_outdev = 1;

static u64 msysc_outchan = 0;

static u64 msysc_fmtstr = 0;

static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack = 0;

static struct $B3 msysc_digits = {{
3978425819141910832,
5063528411713059128}};

static struct $B3 msysc_defaultfmt = {{
112287625641984,
20992}};

static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug = 0;

static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup = 0;

static i64 mlib_show = 0;

static i64 mlib_memtotal = 0;

static i64 mlib_smallmemtotal = 0;

static i64 mlib_smallmemobjs = 0;

static i64 mlib_maxmemtotal = 0;

static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames = {{
(u64)"pm_end",
(u64)"pm_option",
(u64)"pm_sourcefile",
(u64)"pm_libfile",
(u64)"pm_colon",
(u64)"pm_extra"}};

static struct $B3 mlib_seed = {{
2993073034246558322,
1617678968452121188}};

static i64 mlib_pcm_newblock_totalheapsize;
// Istatic skipped:mlib.pcm_round.allocbytes

static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
// Istatic skipped:mlib.nextcmdparamnew.infile

// Istatic skipped:mlib.nextcmdparamnew.filestart

// Istatic skipped:mlib.nextcmdparamnew.fileptr

// Istatic skipped:mlib.nextcmdparamnew.colonseen

static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static u64 mwindows_hconsole;
static u64 mwindows_hconsolein;
static struct $B17 mwindows_lastkey;
static struct $B17 mwindows_pendkey;
static i64 mwindows_keypending;
static i64 mwindows_hpfreq;
static u64 mwindows_wndproc_callbackfn = 0;

static i64 mwindows_init_flag = 0;

static u8 mwindows_os_gxregisterclass_registered;
// Istatic skipped:mwindows.mainwndproc.count

static struct $B15 mwindows_os_gethostname_name;
static i64 mwindows_os_gethostname_n;
static i64 mwindows_os_peek_lastticks;
static u8 pclpe_pc_userunpcl = 0;

static i64 pc_api_pclseqno;
static i64 pc_api_stseqno;
static u64 pc_api_pcstart;
static u64 pc_api_pccurr;
static u64 pc_api_pcend;
static i64 pc_api_pcalloc;
static u8 pc_api_pcfixed;
static i64 pc_api_pcseqno;
static i64 pc_api_pcneedfntable;
static i64 pc_api_initpcalloc = 65536;

static u64 pc_api_longstring;
static i64 pc_api_longstringlen;
static i64 pc_api_mlabelno;
static u8 pc_api_phighmem;
static u8 pc_api_pfullsys;
static u8 pc_api_fpshortnames;
static u64 pc_api_idomcl_assem;
static u64 pc_api_icheckasmlabel;
static u64 pc_api_igethostfn;
static struct $B18 pc_api_strpmode_str;
static struct $B16 pc_api_getfullname_str;
static struct $B16 pc_api_addstr_str;
static u64 pc_decls_pinfo;
static i64 pc_decls_bspill;
static i64 pc_decls_bxspill;
static u8 pc_decls_r10used;
static u8 pc_decls_r11used;
static u8 pc_decls_localshadow;
static i64 pc_decls_mmpos;
static u64 pc_decls_psymboltable;
static u64 pc_decls_psymboltablex;
static u64 pc_decls_currprog;
static u64 pc_decls_currfunc;
static u64 pc_decls_blockretname;
static u64 pc_decls_entryproc;
static struct $B3 pc_decls_sbuffer;
static u64 pc_decls_pdest = (u64)&pc_decls_sbuffer;

static struct $B19 pc_decls_plibfiles;
static struct $B19 pc_decls_plibinst;
static i64 pc_decls_nplibfiles;
static u64 pc_decls_igetmsourceinfo;
static u8 pc_decls_pcldone;
static u8 pc_decls_mcldone;
static u8 pc_decls_ssdone;
static u8 pc_decls_objdone;
static u8 pc_decls_exedone;
static u8 pc_decls_pverbose;
static i64 pc_decls_pcmdskip;
static i64 pc_decls_assemtype = 16705;

static i64 pc_decls_ppseqno;
static u8 pc_decls_fpeephole = 1;

static u8 pc_decls_fregoptim = 1;

static i64 pc_decls_pcltime;
static i64 pc_decls_mcltime;
static i64 pc_decls_sstime;
static i64 pc_decls_objtime;
static i64 pc_decls_exetime;
static u64 pc_decls_$pmodulename;
static struct $B20 pc_decls_pclflags;
static i64 pc_decls_pstartclock;
static i64 pc_decls_npcl;
static i64 pc_run_dotrace = 0;

static i64 pc_run_dostep = 1;

static i64 pc_run_go;
static i64 pc_run_seqno;
static struct $B21 pc_run_emptyst;
static u64 pc_run_labeltable;
static struct $B22 pc_tables_pstdnames = {{
(u64)"void",
(u64)"r32",
(u64)"r64",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"mem",
(u64)"vec",
(u64)"$last"}};

static struct $B23 pc_tables_psize = {{
1024,
264,
1026,
264,
1026,
8,
0}};

static struct $B23 pc_tables_psigned = {{
0,
0,
0,
256,
257,
1,
0}};

static struct $B23 pc_tables_pint = {{
0,
256,
257,
257,
257,
1,
0}};

static struct $B23 pc_tables_pfloat = {{
256,
1,
0,
0,
0,
0,
0}};

static struct $B23 pc_tables_pmin = {{
256,
1282,
1285,
2310,
2313,
2826,
12}};

static struct $B23 pc_tables_xxpiwrb = {{
256,
1538,
1542,
2566,
2570,
10,
0}};

static struct $B22 pc_tables_opndnames = {{
(u64)"no_opnd",
(u64)"mem_opnd",
(u64)"memaddr_opnd",
(u64)"label_opnd",
(u64)"int_opnd",
(u64)"real_opnd",
(u64)"r32_opnd",
(u64)"string_opnd",
(u64)"strimm_opnd",
(u64)"assem_opnd",
(u64)"realimm_opnd",
(u64)"realimm32_opnd",
(u64)"data_opnd",
(u64)"any_opnd"}};

static struct $B20 pc_tables_pclnames = {{
(u64)"nop",
(u64)"load",
(u64)"iload",
(u64)"iloadx",
(u64)"store",
(u64)"istore",
(u64)"istorex",
(u64)"storem",
(u64)"dupl",
(u64)"double",
(u64)"swapstk",
(u64)"unload",
(u64)"opnd",
(u64)"type",
(u64)"loadbit",
(u64)"loadbf",
(u64)"storebit",
(u64)"storebf",
(u64)"callp",
(u64)"icallp",
(u64)"retproc",
(u64)"callf",
(u64)"icallf",
(u64)"retfn",
(u64)"jump",
(u64)"ijump",
(u64)"jumpcc",
(u64)"jumpt",
(u64)"jumpf",
(u64)"jumpret",
(u64)"jumpretm",
(u64)"setcc",
(u64)"stop",
(u64)"to",
(u64)"forup",
(u64)"fordown",
(u64)"iswap",
(u64)"switch",
(u64)"switchu",
(u64)"swlabel",
(u64)"endsw",
(u64)"clear",
(u64)"assem",
(u64)"add",
(u64)"sub",
(u64)"mul",
(u64)"div",
(u64)"idiv",
(u64)"irem",
(u64)"idivrem",
(u64)"bitand",
(u64)"bitor",
(u64)"bitxor",
(u64)"shl",
(u64)"shr",
(u64)"min",
(u64)"max",
(u64)"addpx",
(u64)"subpx",
(u64)"subp",
(u64)"neg",
(u64)"abs",
(u64)"bitnot",
(u64)"not",
(u64)"toboolt",
(u64)"toboolf",
(u64)"sqr",
(u64)"sqrt",
(u64)"sin",
(u64)"cos",
(u64)"tan",
(u64)"asin",
(u64)"acos",
(u64)"atan",
(u64)"log",
(u64)"log10",
(u64)"exp",
(u64)"round",
(u64)"floor",
(u64)"ceil",
(u64)"sign",
(u64)"atan2",
(u64)"power",
(u64)"fmod",
(u64)"incrto",
(u64)"decrto",
(u64)"incrload",
(u64)"decrload",
(u64)"loadincr",
(u64)"loaddecr",
(u64)"addto",
(u64)"subto",
(u64)"multo",
(u64)"divto",
(u64)"idivto",
(u64)"iremto",
(u64)"bitandto",
(u64)"bitorto",
(u64)"bitxorto",
(u64)"shlto",
(u64)"shrto",
(u64)"minto",
(u64)"maxto",
(u64)"addpxto",
(u64)"subpxto",
(u64)"negto",
(u64)"absto",
(u64)"bitnotto",
(u64)"notto",
(u64)"toboolto",
(u64)"typepun",
(u64)"float",
(u64)"fix",
(u64)"truncate",
(u64)"widen",
(u64)"fwiden",
(u64)"fnarrow",
(u64)"startmx",
(u64)"resetmx",
(u64)"endmx",
(u64)"proc",
(u64)"tcproc",
(u64)"endproc",
(u64)"istatic",
(u64)"zstatic",
(u64)"data",
(u64)"initdswx",
(u64)"label",
(u64)"labeldef",
(u64)"setjmp",
(u64)"longjmp",
(u64)"setcall",
(u64)"setarg",
(u64)"loadall",
(u64)"eval",
(u64)"comment",
(u64)"endprog",
(u64)"param",
(u64)"local",
(u64)"rettype",
(u64)"variadic",
(u64)"addlib",
(u64)"extproc"}};

static struct $B24 pc_tables_pclhastype = {{
0,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
0,
0,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
2,
2,
2,
2,
2,
0,
1,
1,
0,
0,
0,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
0,
0,
0}};

static struct $B24 pc_tables_pclextra = {{
0,
1,
0,
2,
0,
0,
2,
0,
0,
0,
2,
0,
0,
0,
0,
0,
0,
0,
2,
2,
0,
2,
2,
0,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
2,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B24 pc_tables_pclhasopnd = {{
0,
13,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
13,
0,
0,
0,
0,
0,
2,
0,
0,
2,
0,
0,
3,
0,
3,
3,
3,
3,
3,
0,
0,
3,
3,
3,
0,
3,
3,
3,
0,
0,
13,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
1,
1,
13,
0,
3,
2,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
7,
1}};

static struct $B24 pc_tables_pclargs = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
2,
2,
9,
9,
0,
9,
9,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B25 pc_tables_ccnames = {{
(u64)"xx",
(u64)"eq",
(u64)"ne",
(u64)"lt",
(u64)"le",
(u64)"ge",
(u64)"gt"}};

static struct $B1 pc_tables_idnames = {{
(u64)"--",
(u64)"Import",
(u64)"Proc",
(u64)"Static",
(u64)"Local",
(u64)"Param",
(u64)"Label",
(u64)"Export",
(u64)"Misc",
(u64)"Program"}};

static i64 mc_genmcl_debug;
static i64 mc_genmcl_frameoffset;
static i64 mc_genmcl_paramoffset;
static i64 mc_genmcl_framebytes;
static struct $B20 mc_genmcl_px_handlertable;
static struct $B26 mc_genmcl_scondcodes = {{
1284,
3596,
3853}};

static struct $B26 mc_genmcl_ucondcodes = {{
1284,
1538,
1795}};

// Istatic skipped:mc_genmcl.inithandlers.initdone

// Istatic skipped:mc_genmcl.inithandlers.dupltable

static i64 mc_auxmcl_nnn;
static i64 mc_auxmcl_nauxprocs;
static i64 mc_auxmcl_nauxnoframe;
static u64 mc_auxmcl_mclframesetup;
static i64 mc_libmcl_mclseqno;
static i64 mc_libmcl_nmclopnd;
static struct $B29 mc_libmcl_smallinttable;
static struct $B30 mc_libmcl_nametable;
static i64 mc_libmcl_nnametable;
static struct $B30 mc_libmcl_mgenextname_table;
static i64 mc_libmcl_mgenextname_ntable;
static struct $B31 mc_stackmcl_stropndstack_str;
static u8 mc_genss_rex;
static u8 mc_genss_sizeoverride;
static u8 mc_genss_addroverride;
static u8 mc_genss_f2override;
static u8 mc_genss_f3override;
static u8 mc_genss_nowmask;
static u8 mc_genss_usesizeb;
static u64 mc_genss_extraparam;
static i64 mc_genss_currseg = 0;

static u64 mc_genss_currdata;
static u64 mc_genss_currrelocs;
static i64 mc_genss_nrelocs;
static struct $B3 mc_genss_ishighreg;
static u64 mc_genss_currmcl;
static u64 mc_genss_ripentry;
// Istatic skipped:mc_genss.genrm.scaletable

static struct $B11 mc_decls_valtypenames = {{
(u64)"no_val",
(u64)"intimm_val",
(u64)"realimm_val",
(u64)"realmem_val",
(u64)"stringimm_val",
(u64)"def_val",
(u64)"label_val",
(u64)"name_val",
(u64)"temp_val"}};

static struct $B33 mc_decls_mclnames = {{
(u64)"m_procstart",
(u64)"m_procend",
(u64)"m_comment",
(u64)"m_labelname",
(u64)"m_define",
(u64)"m_definereg",
(u64)"m_trace",
(u64)"m_endx",
(u64)"m_labelx",
(u64)"m_nop",
(u64)"m_mov",
(u64)"m_push",
(u64)"m_pop",
(u64)"m_lea",
(u64)"m_cmovcc",
(u64)"m_movd",
(u64)"m_movq",
(u64)"m_movsx",
(u64)"m_movzx",
(u64)"m_movsxd",
(u64)"m_call",
(u64)"m_ret",
(u64)"m_leave",
(u64)"m_retn",
(u64)"m_jmp",
(u64)"m_jmpcc",
(u64)"m_xchg",
(u64)"m_add",
(u64)"m_sub",
(u64)"m_adc",
(u64)"m_sbb",
(u64)"m_imul",
(u64)"m_mul",
(u64)"m_imul2",
(u64)"m_imul3",
(u64)"m_idiv",
(u64)"m_div",
(u64)"m_andx",
(u64)"m_orx",
(u64)"m_xorx",
(u64)"m_test",
(u64)"m_cmp",
(u64)"m_shl",
(u64)"m_sar",
(u64)"m_shr",
(u64)"m_rol",
(u64)"m_ror",
(u64)"m_rcl",
(u64)"m_rcr",
(u64)"m_neg",
(u64)"m_notx",
(u64)"m_inc",
(u64)"m_dec",
(u64)"m_cbw",
(u64)"m_cwd",
(u64)"m_cdq",
(u64)"m_cqo",
(u64)"m_setcc",
(u64)"m_bsf",
(u64)"m_bsr",
(u64)"m_shld",
(u64)"m_shrd",
(u64)"m_sqrtss",
(u64)"m_sqrtsd",
(u64)"m_addss",
(u64)"m_addsd",
(u64)"m_subss",
(u64)"m_subsd",
(u64)"m_mulss",
(u64)"m_mulsd",
(u64)"m_divss",
(u64)"m_divsd",
(u64)"m_comiss",
(u64)"m_comisd",
(u64)"m_ucomisd",
(u64)"m_xorps",
(u64)"m_xorpd",
(u64)"m_andps",
(u64)"m_andpd",
(u64)"m_pxor",
(u64)"m_pand",
(u64)"m_cvtss2si",
(u64)"m_cvtsd2si",
(u64)"m_cvttss2si",
(u64)"m_cvttsd2si",
(u64)"m_cvtsi2ss",
(u64)"m_cvtsi2sd",
(u64)"m_cvtsd2ss",
(u64)"m_cvtss2sd",
(u64)"m_movdqa",
(u64)"m_movdqu",
(u64)"m_pcmpistri",
(u64)"m_pcmpistrm",
(u64)"m_fld",
(u64)"m_fst",
(u64)"m_fstp",
(u64)"m_fild",
(u64)"m_fist",
(u64)"m_fistp",
(u64)"m_fadd",
(u64)"m_fsub",
(u64)"m_fmul",
(u64)"m_fdiv",
(u64)"m_fsqrt",
(u64)"m_fsin",
(u64)"m_fcos",
(u64)"m_fsincos",
(u64)"m_fptan",
(u64)"m_fpatan",
(u64)"m_fabs",
(u64)"m_fchs",
(u64)"m_minss",
(u64)"m_maxss",
(u64)"m_minsd",
(u64)"m_maxsd",
(u64)"m_db",
(u64)"m_dw",
(u64)"m_dd",
(u64)"m_dq",
(u64)"m_isegment",
(u64)"m_zsegment",
(u64)"m_csegment",
(u64)"m_align",
(u64)"m_resb",
(u64)"m_resw",
(u64)"m_resd",
(u64)"m_resq",
(u64)"m_xlat",
(u64)"m_loopnz",
(u64)"m_loopz",
(u64)"m_loopcx",
(u64)"m_jecxz",
(u64)"m_jrcxz",
(u64)"m_cmpsb",
(u64)"m_cmpsw",
(u64)"m_cmpsd",
(u64)"m_cmpsq",
(u64)"m_rdtsc",
(u64)"m_popcnt",
(u64)"m_bswap",
(u64)"m_finit",
(u64)"m_fldz",
(u64)"m_fld1",
(u64)"m_fldpi",
(u64)"m_fld2t",
(u64)"m_fld2e",
(u64)"m_fldlg2",
(u64)"m_fldln2",
(u64)"m_cpuid",
(u64)"m_xxxx",
(u64)"m_halt"}};

static struct $B34 mc_decls_mclnopnds = {{
0,
0,
0,
0,
0,
0,
0,
0,
1,
0,
2,
1,
1,
2,
2,
2,
2,
2,
2,
2,
1,
0,
0,
1,
1,
1,
2,
2,
2,
2,
2,
1,
1,
2,
3,
1,
1,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
0,
0,
0,
0,
1,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
3,
3,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
2,
2,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
2,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B34 mc_decls_mclcodes = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
144,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
232,
195,
201,
0,
233,
0,
0,
0,
5,
2,
3,
5,
4,
0,
0,
7,
6,
4,
1,
6,
0,
7,
4,
7,
5,
0,
1,
2,
3,
3,
2,
0,
1,
0,
0,
0,
0,
0,
188,
189,
164,
172,
81,
81,
88,
88,
92,
92,
89,
89,
94,
94,
0,
47,
46,
87,
87,
84,
84,
239,
219,
0,
0,
0,
0,
0,
0,
0,
0,
102,
243,
99,
98,
0,
2,
3,
0,
2,
3,
193,
233,
201,
249,
250,
254,
255,
251,
242,
243,
225,
224,
93,
95,
93,
95,
0,
0,
0,
0,
0,
0,
0,
0,
1,
2,
4,
8,
215,
224,
225,
226,
227,
227,
0,
0,
0,
0,
49,
0,
0,
0,
238,
232,
235,
233,
234,
236,
237,
0,
244,
244}};

static struct $B35 mc_decls_regnames = {{
(u64)"rnone",
(u64)"r0",
(u64)"r1",
(u64)"r2",
(u64)"r3",
(u64)"r4",
(u64)"r5",
(u64)"r6",
(u64)"r7",
(u64)"r8",
(u64)"r9",
(u64)"r10",
(u64)"r11",
(u64)"r12",
(u64)"r13",
(u64)"r14",
(u64)"r15",
(u64)"r16",
(u64)"r17",
(u64)"r18",
(u64)"r19"}};

static struct $B36 mc_decls_regcodes = {{
0,
0,
10,
11,
7,
3,
6,
12,
13,
14,
15,
1,
2,
8,
9,
5,
4,
4,
7,
5,
6}};

static struct $B30 mc_decls_condnames = {{
(u64)"ov",
(u64)"nov",
(u64)"ltu",
(u64)"geu",
(u64)"eq",
(u64)"ne",
(u64)"leu",
(u64)"gtu",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"lt",
(u64)"ge",
(u64)"le",
(u64)"gt",
(u64)"flt",
(u64)"fge",
(u64)"fle",
(u64)"fgt"}};

static struct $B30 mc_decls_asmcondnames = {{
(u64)"o",
(u64)"no",
(u64)"b",
(u64)"ae",
(u64)"z",
(u64)"nz",
(u64)"be",
(u64)"a",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"l",
(u64)"ge",
(u64)"le",
(u64)"g",
(u64)"b",
(u64)"ae",
(u64)"be",
(u64)"a"}};

static struct $B30 mc_decls_asmrevcond = {{
1,
0,
3,
2,
5,
4,
7,
6,
9,
8,
11,
10,
13,
12,
15,
14,
17,
16,
19,
18}};

static struct $B37 mc_decls_dregnames = {{
(u64)"d0",
(u64)"d1",
(u64)"d2",
(u64)"d3",
(u64)"d4",
(u64)"d5",
(u64)"d6",
(u64)"d7",
(u64)"d8",
(u64)"d9",
(u64)"d10",
(u64)"d11",
(u64)"d12",
(u64)"d13",
(u64)"d14",
(u64)"d15",
(u64)"a0",
(u64)"a1",
(u64)"a2",
(u64)"a3",
(u64)"a4",
(u64)"a5",
(u64)"a6",
(u64)"a7",
(u64)"a8",
(u64)"a9",
(u64)"a10",
(u64)"a11",
(u64)"a12",
(u64)"a13",
(u64)"a14",
(u64)"a15",
(u64)"w0",
(u64)"w1",
(u64)"w2",
(u64)"w3",
(u64)"w4",
(u64)"w5",
(u64)"w6",
(u64)"w7",
(u64)"w8",
(u64)"w9",
(u64)"w10",
(u64)"w11",
(u64)"w12",
(u64)"w13",
(u64)"w14",
(u64)"w15",
(u64)"b0",
(u64)"b1",
(u64)"b2",
(u64)"b3",
(u64)"b4",
(u64)"b5",
(u64)"b6",
(u64)"b7",
(u64)"b8",
(u64)"b9",
(u64)"b10",
(u64)"b11",
(u64)"b12",
(u64)"b13",
(u64)"b14",
(u64)"b15",
(u64)"b16",
(u64)"b17",
(u64)"b18",
(u64)"b19",
(u64)"_b20",
(u64)"rax",
(u64)"rbx",
(u64)"rcx",
(u64)"rdx",
(u64)"rsi",
(u64)"rdi",
(u64)"rbp",
(u64)"rsp",
(u64)"r8",
(u64)"r9",
(u64)"r10",
(u64)"r11",
(u64)"r12",
(u64)"r13",
(u64)"r14",
(u64)"r15",
(u64)"eax",
(u64)"ebx",
(u64)"ecx",
(u64)"edx",
(u64)"esi",
(u64)"edi",
(u64)"ebp",
(u64)"esp",
(u64)"r8d",
(u64)"r9d",
(u64)"r10d",
(u64)"r11d",
(u64)"r12d",
(u64)"r13d",
(u64)"r14d",
(u64)"r15d",
(u64)"ax",
(u64)"bx",
(u64)"cx",
(u64)"dx",
(u64)"si",
(u64)"di",
(u64)"bp",
(u64)"sp",
(u64)"r8w",
(u64)"r9w",
(u64)"r10w",
(u64)"r11w",
(u64)"r12w",
(u64)"r13w",
(u64)"r14w",
(u64)"r15w",
(u64)"al",
(u64)"bl",
(u64)"cl",
(u64)"dl",
(u64)"ah",
(u64)"bh",
(u64)"ch",
(u64)"dh",
(u64)"sil",
(u64)"dil",
(u64)"bpl",
(u64)"spl",
(u64)"r8b",
(u64)"r9b",
(u64)"r10b",
(u64)"r11b",
(u64)"r12b",
(u64)"r13b",
(u64)"r14b",
(u64)"r15b"}};

static struct $B38 mc_decls_regsizes = {{
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1}};

static struct $B38 mc_decls_regindices = {{
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
17,
18,
19,
20,
0,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
17,
18,
19,
20,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10}};

static struct $B21 mc_decls_xmmregnames = {{
(u64)"xmm0",
(u64)"xmm1",
(u64)"xmm2",
(u64)"xmm3",
(u64)"xmm4",
(u64)"xmm5",
(u64)"xmm6",
(u64)"xmm7",
(u64)"xmm8",
(u64)"xmm9",
(u64)"xmm10",
(u64)"xmm11",
(u64)"xmm12",
(u64)"xmm13",
(u64)"xmm14",
(u64)"xmm15"}};

static struct $B32 mc_decls_fregnames = {{
(u64)"st0",
(u64)"st1",
(u64)"st2",
(u64)"st3",
(u64)"st4",
(u64)"st5",
(u64)"st6",
(u64)"st7"}};

static struct $B32 mc_decls_mregnames = {{
(u64)"mmx0",
(u64)"mmx1",
(u64)"mmx2",
(u64)"mmx3",
(u64)"mmx4",
(u64)"mmx5",
(u64)"mmx6",
(u64)"mmx7"}};

static struct $B39 mc_decls_jmpccnames = {{
(u64)"jo",
(u64)"jno",
(u64)"jb",
(u64)"jae",
(u64)"jz",
(u64)"jnz",
(u64)"jbe",
(u64)"ja",
(u64)"js",
(u64)"jns",
(u64)"jp",
(u64)"jnp",
(u64)"jl",
(u64)"jge",
(u64)"jle",
(u64)"jg",
(u64)"jc",
(u64)"jnc"}};

static struct $B27 mc_decls_jmpcccodes = {{
256,
770,
1284,
1798,
2312,
2826,
3340,
3854,
770}};

static struct $B21 mc_decls_setccnames = {{
(u64)"seto",
(u64)"setno",
(u64)"setb",
(u64)"setae",
(u64)"setz",
(u64)"setnz",
(u64)"setbe",
(u64)"seta",
(u64)"sets",
(u64)"setns",
(u64)"setp",
(u64)"setnp",
(u64)"setl",
(u64)"setge",
(u64)"setle",
(u64)"setg"}};

static struct $B3 mc_decls_setcccodes = {{
506097522914230528,
1084818905618843912}};

static struct $B21 mc_decls_cmovccnames = {{
(u64)"cmovo",
(u64)"cmovno",
(u64)"cmovb",
(u64)"cmovae",
(u64)"cmovz",
(u64)"cmovnz",
(u64)"cmovbe",
(u64)"cmova",
(u64)"cmovs",
(u64)"cmovns",
(u64)"cmovp",
(u64)"cmovnp",
(u64)"cmovl",
(u64)"cmovge",
(u64)"cmovle",
(u64)"cmovg"}};

static struct $B3 mc_decls_cmovcccodes = {{
506097522914230528,
1084818905618843912}};

static struct $B12 mc_decls_segmentnames = {{
(u64)"no_seg",
(u64)"code_seg",
(u64)"idata_seg",
(u64)"zdata_seg",
(u64)"rodata_seg",
(u64)"impdata_seg"}};

static struct $B8 mc_decls_reftypenames = {{
(u64)"extern_ref",
(u64)"fwd_ref",
(u64)"back_ref"}};

static struct $B12 mc_decls_opndnames_ma = {{
(u64)"a_none",
(u64)"a_reg",
(u64)"a_imm",
(u64)"a_mem",
(u64)"a_cond",
(u64)"a_xreg"}};

static struct $B19 mc_decls_pclopnd;
static struct $B40 mc_decls_pclreg;
static struct $B40 mc_decls_pclmode;
static struct $B40 mc_decls_pclcount;
static struct $B40 mc_decls_pclloc;
static struct $B40 mc_decls_pcltempflags;
static struct $B19 mc_decls_pcltempopnds;
static i64 mc_decls_noperands;
static i64 mc_decls_mstackdepth;
static struct $B18 mc_decls_locnames = {{
(u64)"pend",
(u64)"reg",
(u64)"regvar",
(u64)"temp"}};

static struct $B3 mc_decls_workregs;
static struct $B3 mc_decls_workxregs;
static i64 mc_decls_nworkregs;
static i64 mc_decls_nworkxregs;
static i64 mc_decls_nregvars;
static i64 mc_decls_nxregvars;
static i64 mc_decls_maxregvars;
static i64 mc_decls_maxxregvars;
static i64 mc_decls_xregmax;
static struct $B3 mc_decls_regset;
static struct $B3 mc_decls_xregset;
static struct $B3 mc_decls_isregvar;
static struct $B3 mc_decls_isxregvar;
static struct $B3 mc_decls_usedregs;
static struct $B3 mc_decls_usedxregs;
static u8 mc_decls_noxorclear;
static struct $B41 mc_decls_xregnames = {{
(u64)"-",
(u64)"xmm0",
(u64)"xmm1",
(u64)"xmm2",
(u64)"xmm3",
(u64)"xmm4",
(u64)"xmm5",
(u64)"xmm6",
(u64)"xmm7",
(u64)"xmm8",
(u64)"xmm9",
(u64)"xmm10",
(u64)"xmm11",
(u64)"xmm12",
(u64)"xmm13",
(u64)"xmm15",
(u64)"xmm15"}};

static struct $B18 mc_decls_callalign;
static struct $B18 mc_decls_callblockret;
static struct $B21 mc_decls_callblocksize;
static struct $B31 mc_decls_callargsize;
static i64 mc_decls_ncalldepth;
static i64 mc_decls_lababs32;
static i64 mc_decls_lababs64;
static i64 mc_decls_labneg32;
static i64 mc_decls_labneg64;
static i64 mc_decls_labmask63;
static i64 mc_decls_laboffset64;
static i64 mc_decls_labzero;
static i64 mc_decls_kk0used = 0;

static u64 mc_decls_mccode;
static u64 mc_decls_mccodex;
static i64 mc_decls_currsegment = 0;

static u64 mc_decls_dstackopnd;
static u64 mc_decls_dframeopnd;
static struct $B42 mc_decls_regtable;
static struct $B43 mc_decls_frameregtable;
static u64 mc_decls_cstringlist;
static u64 mc_decls_vstringlist;
static u64 mc_decls_creallist;
static u64 mc_decls_cr32list;
static u64 mc_decls_currasmproc;
static i64 mc_decls_lab_funcnametable;
static i64 mc_decls_lab_funcaddrtable;
static i64 mc_decls_lab_funcnprocs;
static i64 mc_decls_ss_zdatalen;
static u64 mc_decls_ss_zdata;
static u64 mc_decls_ss_idata;
static u64 mc_decls_ss_code;
static u64 mc_decls_ss_idatarelocs;
static u64 mc_decls_ss_coderelocs;
static i64 mc_decls_ss_nidatarelocs;
static i64 mc_decls_ss_ncoderelocs;
static u64 mc_decls_ss_symboltable;
static i64 mc_decls_ss_nsymbols;
static i64 mc_decls_ss_symboltablesize;
static u64 mc_decls_labeldeftable;
static i64 mc_decls_aaseqno;
static i64 mc_decls_aapos;
static u64 mc_decls_regmodes = 432345564311454723;

static u8 mc_decls_pmode;
static u64 mc_decls_currpcl;
static u64 mc_decls_mclprocentry;
static u64 mc_decls_mce_oldmccodex;
static u64 mc_decls_mce_lastmcl;
static u64 mc_decls_mce_nextmcl;
static u64 mc_decls_mcf_oldmccodex;
static u64 mc_decls_mcf_lastmcl;
static u64 mc_decls_mcf_nextmcl;
static u8 mc_decls_fpcheckunusedlocals;
static u64 mc_decls_riplist;
static struct $B19 mc_decls_blockdefs;
static i64 mc_decls_nblocktemps;
static struct $B12 mc_decls_multregs = {{
1,
2,
3,
11,
12,
13}};

static struct $B12 mc_decls_multxregs = {{
1,
2,
3,
4,
5,
6}};

static struct $B23 mc_decls_ploadopx;
static struct $B23 mc_decls_ploadop;
static struct $B25 mc_objdecls_relocnames = {{
(u64)"abs_rel",
(u64)"addr64_rel",
(u64)"addr32_rel",
(u64)"addr32nb_rel",
(u64)"rel32_rel",
(u64)"rel321_rel",
(u64)"rel8_rel"}};

static struct $B42 mc_writenasm_nregnames;
static u8 mc_writenasm_currseg;
static struct $B31 mc_writenasm_strmcl_str;
static struct $B31 mc_writenasm_mstropnd_str;
static struct $B31 mc_writenasm_strvalue_str;
static struct $B18 mc_writenasm_getxregname_str;
static struct $B16 mc_writenasm_getdispname_str;
static struct $B21 mc_writenasm_gettempname_str;
static struct $B19 mc_writeexe_libinsttable;
static struct $B19 mc_writeexe_libinstnames;
static struct $B19 mc_writeexe_libnotable;
static u64 mc_writeexe_basereloclist;
static i64 mc_writeexe_nbaserelocs;
static i64 mc_writeexe_maxrelocaddr;
static struct $B45 mc_writeexe_blockbases;
static struct $B46 mc_writeexe_blockcounts;
static struct $B46 mc_writeexe_blockbytes;
static struct $B47 mc_writeexe_blockpadding;
static i64 mc_writeexe_nbaseblocks;
static i64 mc_writeexe_basetablesize;
static i64 mc_writeexe_imagebase;
static i64 mc_writeexe_imagesize;
static i64 mc_writeexe_filesize;
static u64 mc_writeexe_thunktable;
static i64 mc_writeexe_fileiatoffset;
static i64 mc_writeexe_fileiatsize;
static u64 mc_writeexe_stentrypoint;
static u64 mc_writeexe_stentrypoint2;
static u64 mc_writeexe_stentrypoint3;
static struct $B48 mc_writeexe_sectiontable;
static i64 mc_writeexe_nsections;
static u64 mc_writeexe_importdir;
static struct $B49 mc_writeexe_importtable;
static i64 mc_writeexe_nimports;
static struct $B50 mc_writeexe_exporttable;
static i64 mc_writeexe_nexports;
static u64 mc_writeexe_dllfilename;
static i64 mc_writeexe_isdll;
static struct $B51 mc_writeexe_dlltable;
static i64 mc_writeexe_ndlls;
static u64 mc_writeexe_datastart;
static u64 mc_writeexe_dataptr;
static u64 mc_writeexe_userentrypoint;
static i64 mc_writeexe_exportdirvirtaddr;
static i64 mc_writeexe_exportdirvirtsize;
static i64 mc_writeexe_exportdiroffset;
static i64 mc_writeexe_blockdirvirtaddr;
static i64 mc_writeexe_blockdirvirtsize;
static i64 mc_writeexe_blockdiroffset;
// Istatic skipped:mc_writeexe.writedosstub.stubdata

static i64 mc_writeobj_symtaboffset;
static u64 mc_writeobj_datastart;
static u64 mc_writeobj_dataptr;
static struct $B52 mc_writeobj_symboltable;
static i64 mc_writeobj_nsymbols;
static i64 mc_writeobj_stoffset = 0;

static struct $B53 mc_writeobj_stringtable;
static struct $B53 mc_writeobj_stringlengths;
static i64 mc_writeobj_nextstringoffset = 0;

static i64 mc_writeobj_nstrings = 0;

static struct $B2 mc_writeobj_writerelocs_s;
static struct $B27 mc_writeobj_makesymbol_r;
static struct $B27 mc_writeobj_strtoaux_r;
static struct $B27 mc_writeobj_sectiontoaux_r;
static struct $B22 mx_decls_mcxdirnames = {{
(u64)"pad_dir",
(u64)"version_dir",
(u64)"code_dir",
(u64)"idata_dir",
(u64)"zdata_dir",
(u64)"reloc_dir",
(u64)"dlls_dir",
(u64)"libs_dir",
(u64)"importsymbols_dir",
(u64)"exportsymbols_dir",
(u64)"exportsegs_dir",
(u64)"exportoffsets_dir",
(u64)"entry_dir",
(u64)"end_dir"}};

static struct $B12 mx_decls_mcxrelocnames = {{
(u64)"no_rel",
(u64)"locabs32",
(u64)"locabs64",
(u64)"impabs32",
(u64)"impabs64",
(u64)"imprel32"}};

static struct $B30 mx_decls_dllnametable;
static struct $B30 mx_decls_dllinsttable;
static i64 mx_decls_ndlllibs;
static struct $B30 mx_decls_libnametable;
static struct $B30 mx_decls_libtable;
static struct $B17 mx_decls_librelocated;
static struct $B17 mx_decls_libinitdone;
static i64 mx_decls_nlibs;
static struct $B54 mx_decls_symbolnametable;
static struct $B55 mx_decls_symboldefined;
static struct $B54 mx_decls_symboladdress;
static struct $B56 mx_decls_symbollibindex;
static struct $B55 mx_decls_symboldllindex;
static i64 mx_decls_nsymbols;
static i64 mx_decls_nsymimports = 0;

static i64 mx_decls_nsymexports = 0;

static struct $B12 mx_lib_rsegmentnames = {{
(u64)"no_seg",
(u64)"code_rseg",
(u64)"idata_rseg",
(u64)"zdata_rseg",
(u64)"rodata_rseg",
(u64)"impdata_rseg"}};

static u64 mx_write_dest;
static u64 mx_write_entrypoint;
static struct $B22 cc_cli_passnames = {{
(u64)"load_pass",
(u64)"pp_pass",
(u64)"parse_pass",
(u64)"type_pass",
(u64)"pcl_pass",
(u64)"runpcl_pass",
(u64)"mcl_pass",
(u64)"nasm_pass",
(u64)"asm_pass",
(u64)"mx_pass",
(u64)"obj_pass",
(u64)"dll_pass",
(u64)"exe_pass",
(u64)"run_pass"}};

static struct $B22 cc_cli_extnames = {{
(u64)"",
(u64)"i",
(u64)"",
(u64)"",
(u64)"pcl",
(u64)"(int)",
(u64)"asm",
(u64)"nasm",
(u64)"asm",
(u64)"mx",
(u64)"obj",
(u64)"dll",
(u64)"exe",
(u64)"(run)"}};

static u8 cc_cli_cc_pass;
static u8 cc_cli_debugmode;
static u64 cc_cli_outfile;
static u64 cc_cli_outext = (u64)"exe";

static i64 cc_cli_cmdskip;
static i64 cc_cli_ttt;
static u8 cc_cli_fverbose = 1;

static u8 cc_cli_fshowincludes = 0;

static u8 cc_cli_dointheaders = 1;

static u8 cc_cli_highmem = 1;

static u8 cc_cli_fshowst;
static u8 cc_cli_fshowstflat;
static u8 cc_cli_fshowast;
static u8 cc_cli_fshowpcl;
static u8 cc_cli_fshowpst;
static u8 cc_cli_fshowmcl;
static u8 cc_cli_fshowss;
static u8 cc_cli_fshowtypes;
static u8 cc_cli_fshowfiles;
static u8 cc_cli_fshowpaths;
static u8 cc_cli_fshowheaders;
static u8 cc_cli_fwriteheaders;
static u8 cc_cli_fshowlog;
static u8 cc_cli_fshowtiming;
static u8 cc_cli_fgendll;
static u8 cc_cli_fstdout;
static u8 cc_cli_fshortnames;
static u8 cc_cli_fwriteerrors = 1;

static u64 cc_cli_entrypointname;
static struct $B19 cc_cli_optionnames = {{
(u64)"load",
(u64)"e",
(u64)"ei",
(u64)"parse",
(u64)"type",
(u64)"p",
(u64)"pi",
(u64)"i",
(u64)"mcl",
(u64)"s",
(u64)"a",
(u64)"nasm",
(u64)"c",
(u64)"obj",
(u64)"mx",
(u64)"dll",
(u64)"exe",
(u64)"r",
(u64)"noregs",
(u64)"nopeep",
(u64)"no",
(u64)"paths",
(u64)"headers",
(u64)"incl",
(u64)"includes",
(u64)"showst",
(u64)"showstflat",
(u64)"showast",
(u64)"showpcl",
(u64)"showpst",
(u64)"showmcl",
(u64)"showss",
(u64)"showtypes",
(u64)"showfiles",
(u64)"time",
(u64)"time2",
(u64)"v",
(u64)"vv",
(u64)"q",
(u64)"cs",
(u64)"ss",
(u64)"h",
(u64)"help",
(u64)"ext",
(u64)"writeheaders",
(u64)"o",
(u64)"stdout",
(u64)"shortnames",
(u64)"norip",
(u64)"himem"}};

static struct $B19 cc_cli_optvars = {{
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&cc_cli_cc_pass,
(u64)&pc_decls_fregoptim,
(u64)&pc_decls_fpeephole,
0,
(u64)&cc_cli_fshowpaths,
(u64)&cc_cli_fshowheaders,
0,
(u64)&cc_cli_fshowincludes,
(u64)&cc_cli_fshowst,
(u64)&cc_cli_fshowstflat,
(u64)&cc_cli_fshowast,
(u64)&cc_cli_fshowpcl,
(u64)&cc_cli_fshowpst,
(u64)&cc_cli_fshowmcl,
(u64)&cc_cli_fshowss,
(u64)&cc_cli_fshowtypes,
(u64)&cc_cli_fshowfiles,
(u64)&cc_cli_fshowtiming,
(u64)&cc_cli_fshowtiming,
(u64)&cc_cli_fverbose,
(u64)&cc_cli_fverbose,
(u64)&cc_cli_fverbose,
(u64)&pc_decls_pverbose,
(u64)&pc_decls_pverbose,
0,
0,
(u64)&cc_cli_dointheaders,
(u64)&cc_cli_fwriteheaders,
0,
(u64)&cc_cli_fstdout,
(u64)&cc_cli_fshortnames,
(u64)&cc_cli_highmem,
(u64)&cc_cli_highmem}};

static struct $B40 cc_cli_optvalues = {{
513,
770,
1284,
1541,
2311,
2057,
2827,
3082,
3597,
0,
256,
257,
257,
257,
257,
257,
257,
513,
770,
256,
2,
0,
1,
257,
512}};

static i64 cc_cli_totallines = 0;

static i64 cc_cli_nstringobjects = 0;

static i64 cc_cli_startclock;
static i64 cc_cli_loadtime;
static i64 cc_cli_parsetime;
static i64 cc_cli_pcltime;
static i64 cc_cli_compiletime;
static i64 cc_cli_inittime;
// Istatic skipped:cc_cli.showextrainfo.infotext

static i64 cc_decls_ntypes;
static struct $B57 cc_decls_ttnamedef;
static struct $B58 cc_decls_ttbasetype;
static struct $B57 cc_decls_ttlength;
static struct $B59 cc_decls_ttconst;
static struct $B58 cc_decls_tttarget;
static struct $B58 cc_decls_ttreftype;
static struct $B58 cc_decls_ttconsttype;
static struct $B57 cc_decls_ttsize;
static struct $B59 cc_decls_ttisref;
static struct $B59 cc_decls_ttisblock;
static struct $B59 cc_decls_ttsigned;
static struct $B60 cc_decls_ttshared;
static struct $B57 cc_decls_ttparams;
static struct $B57 cc_decls_tttypedef;
static i64 cc_decls_trefchar;
static i64 cc_decls_trefwchar;
static u64 cc_decls_inputfile;
static i64 cc_decls_mainfileno;
static struct $B61 cc_decls_libfiles;
static struct $B61 cc_decls_sourcefilenames;
static struct $B61 cc_decls_sourcefilepaths;
static struct $B61 cc_decls_sourcefiletext;
static struct $B62 cc_decls_sourcefilesizes;
static i64 cc_decls_nsourcefiles;
static i64 cc_decls_nlibfiles;
static struct $B30 cc_decls_searchdirs;
static i64 cc_decls_nsearchdirs = 0;

static struct $B30 cc_decls_includepaths;
static i64 cc_decls_nincludepaths = 0;

static u64 cc_decls_stprogram;
static u64 cc_decls_stmodule;
static u64 cc_decls_logdev;
static u64 cc_decls_nullunit;
static i64 cc_decls_clineno = 0;

static i64 cc_decls_cfileno = 0;

static struct $B18 cc_decls_lx;
static struct $B18 cc_decls_nextlx;
static i64 cc_decls_debug = 0;

static i64 cc_decls_hstsize = 65536;

static i64 cc_decls_hstmask;
static u64 cc_decls_hashtable;
static struct $B63 cc_decls_blockowner;
static struct $B63 cc_decls_blockcounts;
static struct $B64 cc_decls_blockstack;
static i64 cc_decls_currblockno;
static i64 cc_decls_nextblockno;
static i64 cc_decls_blocklevel;
static u64 cc_decls_currproc;
static u64 cc_decls_dheaderfile = 0;

static i64 cc_decls_structpadding = 1;

static i64 cc_decls_callbackflag = 0;

static i64 cc_decls_slineno;
static i64 cc_decls_sfileno;
static u64 cc_decls_oemname = (u64)"MCC";

static u64 cc_decls_mclstr;
static i64 cc_decls_mclstrlen;
static i64 cc_decls_nunits;
static struct $B65 cc_decls_pmodulelist;
static struct $B66 cc_decls_pheaderlist;
static struct $B66 cc_decls_pliblist;
static i64 cc_decls_npmodules;
static i64 cc_decls_npheaders;
static i64 cc_decls_nplibs;
static u8 cc_decls_pci_target;
static struct $B67 cc_tables_stdtypenames = {{
(u64)"void",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"bool",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"r32",
(u64)"r64",
(u64)"enum",
(u64)"ref",
(u64)"proc",
(u64)"label",
(u64)"block",
(u64)"array",
(u64)"struct",
(u64)"union",
(u64)"notset",
(u64)"tlast"}};

static struct $B68 cc_tables_stdtypewidths = {{
2048,
8208,
2112,
4104,
16416,
16416,
16384,
16448,
0,
0,
0}};

static struct $B68 cc_tables_stdsigned = {{
256,
257,
1,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B68 cc_tables_stdpcl = {{
1792,
2312,
778,
1027,
1541,
513,
1545,
0,
2827,
2827,
0}};

static struct $B68 cc_tables_stdsize = {{
256,
1026,
264,
513,
2052,
2052,
0,
0,
0,
0,
0}};

static struct $B69 cc_tables_catnames = {{
(u64)"voidcat",
(u64)"intcat",
(u64)"realcat",
(u64)"shortcat",
(u64)"blockcat"}};

static struct $B70 cc_tables_typespecnames = {{
(u64)"ts_void",
(u64)"ts_char",
(u64)"ts_short",
(u64)"ts_long",
(u64)"ts_int",
(u64)"ts_float",
(u64)"ts_double",
(u64)"ts_signed",
(u64)"ts_unsigned",
(u64)"ts_bool",
(u64)"ts_user",
(u64)"ts_struct",
(u64)"ts_union",
(u64)"ts_enum",
(u64)"ts_atomic"}};

static struct $B71 cc_tables_typespectypes = {{
0,
1,
0,
0,
3,
10,
11,
0,
0,
5,
0,
0,
0,
0,
0}};

static struct $B72 cc_tables_typespecsizes = {{
0,
1,
2,
4,
4,
4,
8,
0,
0,
1,
0,
0,
0,
4,
0}};

static struct $B18 cc_tables_pmflagnames = {{
(u64)"pm_normal",
(u64)"pm_notset",
(u64)"pm_empty",
(u64)"pm_variadic"}};

static struct $B69 cc_tables_scopenames = {{
(u64)"-",
(u64)"Fn",
(u64)"Loc",
(u64)"Imp",
(u64)"Exp"}};

static struct $B12 cc_tables_cccnames = {{
(u64)"open_cc",
(u64)"own_cc",
(u64)"clang_cc",
(u64)"stdcall_cc",
(u64)"callback_cc",
(u64)"dummy_cc"}};

static struct $B12 cc_tables_linkagenames = {{
(u64)"none_ss",
(u64)"static_ss",
(u64)"auto_ss",
(u64)"register_ss",
(u64)"extern_ss",
(u64)"typedef_ss"}};

static struct $B18 cc_tables_typequalnames = {{
(u64)"const_qual",
(u64)"volatile_qual",
(u64)"restrict_qual",
(u64)"atomic_qual"}};

static struct $B8 cc_tables_fnspecnames = {{
(u64)"inline_fnspec",
(u64)"noreturn_fnspec",
(u64)"callback_fnspec"}};

static struct $B73 cc_tables_jtagnames = {{
(u64)"jnone",
(u64)"jconst",
(u64)"jnull",
(u64)"jname",
(u64)"jwidenmem",
(u64)"jfuncname",
(u64)"jblock",
(u64)"jtempdecl",
(u64)"jdecl",
(u64)"jreturn",
(u64)"jreturnx",
(u64)"jassign",
(u64)"jif",
(u64)"jfor",
(u64)"jwhile",
(u64)"jdowhile",
(u64)"jgoto",
(u64)"jlabelstmt",
(u64)"jcasestmt",
(u64)"jdefaultstmt",
(u64)"jbreak",
(u64)"jcontinue",
(u64)"jswitch",
(u64)"jbreaksw",
(u64)"&& andl",
(u64)"|| orl",
(u64)"! notl",
(u64)"jistruel",
(u64)"jmakelist",
(u64)"jexprlist",
(u64)"jcallfn",
(u64)"jifx",
(u64)"&&",
(u64)"==",
(u64)"!=",
(u64)"<",
(u64)"<=",
(u64)">",
(u64)">=",
(u64)"+ add",
(u64)"- sub",
(u64)"* mul",
(u64)"/ div",
(u64)"% mod",
(u64)"& iand",
(u64)"| ior",
(u64)"^ ixor",
(u64)"<<",
(u64)">>",
(u64)"jdot",
(u64)"jidot",
(u64)"jindex",
(u64)"ptr",
(u64)"addptr",
(u64)"subptr",
(u64)"addrof &",
(u64)"jconvert",
(u64)"jscale",
(u64)"- neg",
(u64)"abs",
(u64)"~ inot",
(u64)"+=",
(u64)"-=",
(u64)"*=",
(u64)"/=",
(u64)"%=",
(u64)"&=",
(u64)"|=",
(u64)"^=",
(u64)"<<=",
(u64)">>=",
(u64)"++ preincr",
(u64)"-- preincr",
(u64)"++ postincr",
(u64)"-- postdecr",
(u64)"setjmp",
(u64)"longjmp",
(u64)"jdummy"}};

static struct $B74 cc_tables_symbolnames = {{
(u64)"errorsym",
(u64)"dotsym",
(u64)"idotsym",
(u64)"lexhashsym",
(u64)"hashsym",
(u64)"lithashsym",
(u64)"hashhashsym",
(u64)"commasym",
(u64)"semisym",
(u64)"colonsym",
(u64)"assignsym",
(u64)"assignsym2",
(u64)"lbracksym",
(u64)"rbracksym",
(u64)"lsqsym",
(u64)"rsqsym",
(u64)"lcurlysym",
(u64)"rcurlysym",
(u64)"questionsym",
(u64)"curlsym",
(u64)"ellipsissym",
(u64)"backslashsym",
(u64)"addsym",
(u64)"subsym",
(u64)"mulsym",
(u64)"divsym",
(u64)"remsym",
(u64)"iorsym",
(u64)"iandsym",
(u64)"ixorsym",
(u64)"orlsym",
(u64)"andlsym",
(u64)"shlsym",
(u64)"shrsym",
(u64)"inotsym",
(u64)"notlsym",
(u64)"incrsym",
(u64)"decrsym",
(u64)"abssym",
(u64)"eqsym",
(u64)"nesym",
(u64)"ltsym",
(u64)"lesym",
(u64)"gesym",
(u64)"gtsym",
(u64)"addtosym",
(u64)"subtosym",
(u64)"multosym",
(u64)"divtosym",
(u64)"remtosym",
(u64)"iortosym",
(u64)"iandtosym",
(u64)"ixortosym",
(u64)"shltosym",
(u64)"shrtosym",
(u64)"eolsym",
(u64)"eofsym",
(u64)"rawnumbersym",
(u64)"intconstsym",
(u64)"realconstsym",
(u64)"charconstsym",
(u64)"wcharconstsym",
(u64)"stringconstsym",
(u64)"wstringconstsym",
(u64)"whitespacesym",
(u64)"placeholdersym",
(u64)"namesym",
(u64)"ksourcedirsym",
(u64)"predefmacrosym",
(u64)"ktypespecsym",
(u64)"kifsym",
(u64)"kelsesym",
(u64)"kcasesym",
(u64)"kdefaultsym",
(u64)"kforsym",
(u64)"kwhilesym",
(u64)"kdosym",
(u64)"kreturnsym",
(u64)"kbreaksym",
(u64)"kcontinuesym",
(u64)"kgotosym",
(u64)"kswitchsym",
(u64)"kstructsym",
(u64)"kunionsym",
(u64)"klinkagesym",
(u64)"ktypequalsym",
(u64)"kstdtypesym",
(u64)"kfnspecsym",
(u64)"kalignassym",
(u64)"kenumsym",
(u64)"ksizeofsym",
(u64)"kdefinedsym",
(u64)"kgenericsym",
(u64)"kalignofsym",
(u64)"ksetjmpsym",
(u64)"kdummysym"}};

static struct $B74 cc_tables_shortsymbolnames = {{
(u64)"",
(u64)".",
(u64)"->",
(u64)"#",
(u64)"#",
(u64)"#",
(u64)"##",
(u64)",",
(u64)";",
(u64)":",
(u64)"=",
(u64)":=",
(u64)"(",
(u64)")",
(u64)"[",
(u64)"]",
(u64)"{",
(u64)"}",
(u64)"?",
(u64)"~",
(u64)"...",
(u64)"\\",
(u64)"+",
(u64)"-",
(u64)"*",
(u64)"/",
(u64)"%",
(u64)"|",
(u64)"&",
(u64)"^",
(u64)"||",
(u64)"&&",
(u64)"<<",
(u64)">>",
(u64)"~",
(u64)"!",
(u64)"++",
(u64)"--",
(u64)"abs",
(u64)"==",
(u64)"!=",
(u64)"<",
(u64)"<=",
(u64)">=",
(u64)">",
(u64)"+=",
(u64)"-=",
(u64)"*=",
(u64)"/=",
(u64)"%=",
(u64)"|=",
(u64)"&=",
(u64)"^=",
(u64)"<<=",
(u64)">>=",
(u64)"",
(u64)"",
(u64)"n",
(u64)"n",
(u64)"n",
(u64)"s",
(u64)"s",
(u64)"s",
(u64)"s",
(u64)"w",
(u64)"",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)"k",
(u64)""}};

static struct $B29 cc_tables_symboltojtag = {{
3289344,
185270272,
2893281285608833024,
1736469898599279145,
2394587097097580591,
4557147102708507426,
19779407841542464,
0,
0,
0,
0,
0}};

static struct $B70 cc_tables_sourcedirnames = {{
(u64)"definedir",
(u64)"emitdir",
(u64)"ifdir",
(u64)"elifdir",
(u64)"elsedir",
(u64)"endifdir",
(u64)"includedir",
(u64)"ifdefdir",
(u64)"ifndefdir",
(u64)"undefdir",
(u64)"errordir",
(u64)"messagedir",
(u64)"blankdir",
(u64)"linedir",
(u64)"pragmadir"}};

static struct $B69 cc_tables_namespacenames = {{
(u64)"ns_none",
(u64)"ns_general",
(u64)"ns_tags",
(u64)"ns_labels",
(u64)"ns_fields"}};

static struct $B70 cc_tables_namenames = {{
(u64)"nullid",
(u64)"macroid",
(u64)"programid",
(u64)"moduleid",
(u64)"extmoduleid",
(u64)"typeid",
(u64)"procid",
(u64)"staticid",
(u64)"frameid",
(u64)"paramid",
(u64)"fieldid",
(u64)"enumid",
(u64)"enumtagid",
(u64)"structtagid",
(u64)"labelid"}};

static struct $B71 cc_tables_namespaces = {{
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
4,
1,
2,
2,
3}};

static struct $B72 cc_tables_name2pid = {{
0,
0,
0,
0,
0,
0,
2,
3,
4,
5,
0,
0,
0,
0,
6}};

static struct $B75 cc_tables_stnames = {{
(u64)"if",
(u64)"else",
(u64)"case",
(u64)"default",
(u64)"for",
(u64)"do",
(u64)"while",
(u64)"return",
(u64)"break",
(u64)"continue",
(u64)"goto",
(u64)"switch",
(u64)"struct",
(u64)"union",
(u64)"include",
(u64)"define",
(u64)"elif",
(u64)"ifdef",
(u64)"ifndef",
(u64)"endif",
(u64)"undef",
(u64)"error",
(u64)"pragma",
(u64)"line",
(u64)"auto",
(u64)"register",
(u64)"static",
(u64)"extern",
(u64)"typedef",
(u64)"const",
(u64)"volatile",
(u64)"restrict",
(u64)"_Atomic",
(u64)"inline",
(u64)"_Noreturn",
(u64)"_Alignas",
(u64)"enum",
(u64)"void",
(u64)"char",
(u64)"short",
(u64)"long",
(u64)"int",
(u64)"float",
(u64)"double",
(u64)"signed",
(u64)"unsigned",
(u64)"_Bool",
(u64)"__DATE__",
(u64)"__FILE__",
(u64)"__LINE__",
(u64)"__TIME__",
(u64)"__MCC__",
(u64)"__MCCI__",
(u64)"__func__",
(u64)"__FUNCTION__",
(u64)"sizeof",
(u64)"lengthof",
(u64)"defined",
(u64)"_Generic",
(u64)"_Alignof",
(u64)"$setjmp",
(u64)"$longjmp",
(u64)"$$dummy"}};

static struct $B76 cc_tables_stsymbols = {{
71,
72,
73,
74,
75,
77,
76,
78,
79,
80,
81,
82,
83,
84,
68,
68,
68,
68,
68,
68,
68,
68,
68,
68,
85,
85,
85,
85,
85,
86,
86,
86,
86,
88,
88,
89,
90,
70,
70,
70,
70,
70,
70,
70,
70,
70,
70,
69,
69,
69,
69,
69,
69,
69,
69,
91,
91,
92,
93,
94,
95,
95,
0}};

static struct $B76 cc_tables_stsubcodes = {{
12,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
7,
1,
4,
8,
9,
6,
10,
11,
15,
14,
2,
3,
1,
4,
5,
1,
2,
3,
4,
1,
2,
0,
0,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
1,
3,
4,
2,
7,
8,
5,
5,
0,
1,
0,
0,
0,
75,
76,
0}};

static struct $B22 cc_tables_convnames = {{
(u64)"no_conv",
(u64)"soft_c",
(u64)"hard_c",
(u64)"swiden_c",
(u64)"uwiden_c",
(u64)"sfloat_c",
(u64)"ufloat_c",
(u64)"sfix_c",
(u64)"ufix_c",
(u64)"fwiden_c",
(u64)"fnarrow_c",
(u64)"narrow_c",
(u64)"truncate_c",
(u64)"bool_c"}};

static struct $B42 cc_tables_dominantmode;
static struct $B16 cc_tables_conversionops;
static struct $B77 cc_tables_dominantsetuptable = {{
1,
1,
3,
1,
2,
3,
1,
3,
3,
1,
4,
4,
1,
5,
3,
1,
6,
3,
1,
7,
3,
1,
8,
3,
1,
9,
4,
1,
10,
10,
1,
11,
11,
2,
1,
3,
2,
2,
3,
2,
3,
3,
2,
4,
4,
2,
5,
3,
2,
6,
3,
2,
7,
3,
2,
8,
3,
2,
9,
4,
2,
10,
10,
2,
11,
11,
3,
1,
3,
3,
2,
3,
3,
3,
3,
3,
4,
4,
3,
5,
3,
3,
6,
3,
3,
7,
3,
3,
8,
8,
3,
9,
4,
3,
10,
10,
3,
11,
11,
4,
1,
4,
4,
2,
4,
4,
3,
4,
4,
4,
4,
4,
5,
4,
4,
6,
4,
4,
7,
4,
4,
8,
4,
4,
9,
9,
4,
10,
10,
4,
11,
11,
5,
1,
3,
5,
2,
3,
5,
3,
3,
5,
4,
4,
5,
5,
8,
5,
6,
8,
5,
7,
8,
5,
8,
8,
5,
9,
9,
5,
10,
10,
5,
11,
11,
6,
1,
3,
6,
2,
3,
6,
3,
3,
6,
4,
4,
6,
5,
0,
6,
6,
8,
6,
7,
8,
6,
8,
8,
6,
9,
9,
6,
10,
10,
6,
11,
11,
7,
1,
3,
7,
2,
3,
7,
3,
3,
7,
4,
4,
7,
5,
8,
7,
6,
8,
7,
7,
8,
7,
8,
8,
7,
9,
9,
7,
10,
10,
7,
11,
11,
8,
1,
3,
8,
2,
3,
8,
3,
8,
8,
4,
4,
8,
5,
8,
8,
6,
8,
8,
7,
8,
8,
8,
8,
8,
9,
9,
8,
10,
10,
8,
11,
11,
9,
1,
9,
9,
2,
9,
9,
3,
9,
9,
4,
9,
9,
5,
9,
9,
6,
9,
9,
7,
9,
9,
8,
9,
9,
9,
9,
9,
10,
10,
9,
11,
11,
10,
1,
11,
10,
2,
11,
10,
3,
11,
10,
4,
11,
10,
5,
11,
10,
6,
11,
10,
7,
11,
10,
8,
11,
10,
9,
11,
10,
10,
10,
10,
11,
11,
11,
1,
11,
11,
2,
11,
11,
3,
11,
11,
4,
11,
11,
5,
11,
11,
6,
11,
11,
7,
11,
11,
8,
11,
11,
9,
11,
11,
10,
11,
11,
11,
11}};

static struct $B77 cc_tables_convsetuptable = {{
1,
1,
3,
1,
2,
3,
1,
3,
3,
1,
4,
3,
1,
5,
13,
1,
6,
1,
1,
7,
3,
1,
8,
3,
1,
9,
3,
1,
10,
5,
1,
11,
5,
2,
1,
12,
2,
2,
0,
2,
3,
3,
2,
4,
3,
2,
5,
13,
2,
6,
12,
2,
7,
1,
2,
8,
3,
2,
9,
3,
2,
10,
5,
2,
11,
5,
3,
1,
12,
3,
2,
12,
3,
3,
0,
3,
4,
3,
3,
5,
13,
3,
6,
12,
3,
7,
12,
3,
8,
1,
3,
9,
3,
3,
10,
5,
3,
11,
5,
4,
1,
12,
4,
2,
12,
4,
3,
12,
4,
4,
0,
4,
5,
13,
4,
6,
12,
4,
7,
12,
4,
8,
12,
4,
9,
1,
4,
10,
5,
4,
11,
5,
5,
1,
1,
5,
2,
4,
5,
3,
4,
5,
4,
4,
5,
5,
0,
5,
6,
1,
5,
7,
4,
5,
8,
4,
5,
9,
4,
5,
10,
6,
5,
11,
6,
6,
1,
1,
6,
2,
4,
6,
3,
4,
6,
4,
4,
6,
5,
13,
6,
6,
1,
6,
7,
4,
6,
8,
4,
6,
9,
4,
6,
10,
6,
6,
11,
6,
7,
1,
12,
7,
2,
1,
7,
3,
4,
7,
4,
4,
7,
5,
13,
7,
6,
12,
7,
7,
0,
7,
8,
4,
7,
9,
4,
7,
10,
6,
7,
11,
6,
8,
1,
12,
8,
2,
12,
8,
3,
1,
8,
4,
4,
8,
5,
13,
8,
6,
12,
8,
7,
12,
8,
8,
0,
8,
9,
4,
8,
10,
6,
8,
11,
6,
9,
1,
12,
9,
2,
12,
9,
3,
12,
9,
4,
1,
9,
5,
13,
9,
6,
12,
9,
7,
12,
9,
8,
12,
9,
9,
0,
9,
10,
6,
9,
11,
6,
10,
1,
7,
10,
2,
7,
10,
3,
7,
10,
4,
7,
10,
5,
8,
10,
6,
8,
10,
7,
8,
10,
8,
8,
10,
9,
8,
10,
10,
0,
10,
11,
9,
11,
1,
7,
11,
2,
7,
11,
3,
7,
11,
4,
7,
11,
5,
8,
11,
6,
8,
11,
7,
8,
11,
8,
8,
11,
9,
8,
11,
10,
10,
11,
11,
0}};

static struct $B79 cc_tables_badexprs = {{
1,
3,
31,
24,
25,
26,
27,
29,
32,
33,
34,
35,
36,
38,
37,
39,
40,
41,
42,
43,
44,
45,
46,
47,
48,
49,
50,
51,
52,
53,
54,
58,
59,
60}};

static u64 cc_lex_tkptr = 0;

static i64 cc_lex_dowhitespace = 0;

static i64 cc_lex_nincludes;
static struct $B18 cc_lex_normaltkx;
static u64 cc_lex_normaltk = (u64)&cc_lex_normaltkx;

static i64 cc_lex_noexpand = 0;

static struct $B80 cc_lex_lx_stack;
static i64 cc_lex_lx_stackindex;
static i64 cc_lex_ifcondlevel = 0;

static struct $B30 cc_lex_headerpathlist;
static struct $B15 cc_lex_headerpath;
static u64 cc_lex_lxstart;
static u64 cc_lex_lxsptr;
static i64 cc_lex_lxhashvalue;
static u64 cc_lex_lxsvalue;
static struct $B16 cc_lex_alphamap;
static struct $B16 cc_lex_digitmap;
static struct $B16 cc_lex_commentmap;
static struct $B16 cc_lex_linecommentmap;
static struct $B16 cc_lex_spacemap;
static u64 cc_lex_destcopy;
static struct $B81 cc_lex_pastedtokenlist;
static i64 cc_lex_npastedtokens = 0;

static i64 cc_lex_isincludefile = 0;

static i64 cc_lex_firstsymbol = 1;

static u64 cc_lex_reallxsptr;
static i64 cc_lex_nhstsymbols;
static i64 cc_lex_hstthreshold;
static struct $B3 cc_lex_lex_preprocess_only_sbuffer;
// Istatic skipped:cc_lex.lex_preprocess_only.dest

static struct $B15 cc_lex_getsourcefile_filespec;
// Istatic skipped:cc_lex.lexm.doreset

static i64 cc_lex_lasttoken = 0;

static struct $B3 cc_lex_showtoken_buffer;
// Istatic skipped:cc_lex.showtoken.dest

static struct $B3 cc_lex_stringify_buffer;
// Istatic skipped:cc_lex.stringify.deststr

// Istatic skipped:cc_lex.expandpredefmacro.monthnames

// Istatic skipped:cc_lex.issimpleconstmacro.specialnames

static u64 cc_parse_ist_symptr;
static struct $B32 cc_parse_looptypestack;
static i64 cc_parse_loopindex;
static struct $B31 cc_parse_casevaluestack;
static u8 cc_parse_ingeneric = 0;

static i64 cc_genpcl_retindex;
static i64 cc_genpcl_initstaticsindex;
static struct $B82 cc_genpcl_loopstack;
static i64 cc_genpcl_loopindex;
static struct $B32 cc_genpcl_zero_unit;
static u64 cc_genpcl_pzero = (u64)&cc_genpcl_zero_unit;

static i64 cc_genpcl_nvarlocals;
static i64 cc_genpcl_nvarparams;
static struct $B31 cc_blockpcl_continuestack;
static struct $B31 cc_blockpcl_breakstack;
static i64 cc_blockpcl_loopindex;
static u64 cc_blockpcl_sw_labeltable;
static u64 cc_blockpcl_sw_valuetable;
static i64 cc_blockpcl_sw_lower;
static i64 cc_blockpcl_sw_ncases;
static u8 cc_blockpcl_sw_defaultseen;
static i64 cc_blockpcl_sw_defaultlabel;
static i64 cc_blockpcl_sw_breaklabel;
static i64 cc_lib_autotypeno = 0;

static i64 cc_lib_nextafindex = 0;

static u64 cc_lib_unitheapptr = 0;

static i64 cc_lib_remainingunits = 0;

static struct $B83 cc_lib_getoptocode_opctotable;
static struct $B18 cc_lib_nextautotype_str;
static struct $B17 cc_lib_getopcjname_str;
static struct $B84 cc_lib_strmode_str;
static struct $B84 cc_lib_strmode2_str;
static struct $B15 cc_lib_typename_str;
static struct $B16 cc_lib_getstname_name;
static u64 cc_support_bytemasks = -9205322385119247871;

static i64 cc_headers_builtinheaders = 1;

static u64 cc_headers_h_assert = (u64)"/* Header assert.h */\r\n\r\n//#define assert(x) 0\r\n#define assert(x)\r\n";

static u64 cc_headers_h_ctype = (u64)"/* Header ctype.h */\r\n\r\nint tolower(int);\r\nint toupper(int);\r\nint isalpha(int);\r\nint isdigit(int);\r\nint isspace(int);\r\nint isalnum(int);\r\nint isupper(int);\r\nint islower(int);\r\n\r\nint isxdigit(int);\r\nint iscntrl(int);\r\nint isgraph(int);\r\nint ispunct(int);\r\nint isprint(int);\r\nint __isascii(int);\r\n#define isascii __isascii\r\n\r\nint __toascii(int);\r\n#define toascii __toascii\r\n";

static u64 cc_headers_h_errno = (u64)"/* Header errno.h */\r\n\r\n#ifndef $errno\r\n#define $errno\r\n\r\nextern int* _errno(void);\r\n#define errno (*_errno())\r\n\r\n#define EPERM 1\r\n#define ENOENT 2\r\n#define ESRCH 3\r\n#define EINTR 4\r\n#define EIO 5\r\n#define ENXIO 6\r\n#define E2BIG 7\r\n#define ENOEXEC 8\r\n#define EBADF 9\r\n#define ECHILD 10\r\n#define EAGAIN 11\r\n#define ENOMEM 12\r\n#define EACCES 13\r\n#define EFAULT 14\r\n#define ENOTBLK 15\r\n#define EBUSY 16\r\n#define EEXIST 17\r\n#define EXDEV 18\r\n#define ENODEV 19\r\n#define ENOTDIR 20\r\n#define EISDIR 21\r\n#define EINVAL 22\r\n#define ENFILE 23\r\n#define EMFILE 24\r\n#define ENOTTY 25\r\n#define ETXTBSY 26\r\n#define EFBIG 27\r\n#define ENOSPC 28\r\n#define ESPIPE 29\r\n#define EROFS 30\r\n#define EMLINK 31\r\n#define EPIPE 32\r\n#define EDOM 33\r\n#define ERANGE 34\r\n#define ENOMSG 35\r\n#define EIDRM 36\r\n#define ECHRNG 37\r\n#define EL2NSYNC 38\r\n#define EL3HLT 39\r\n#define EL3RST 40\r\n#define ELNRNG 41\r\n#define EUNATCH 42\r\n#define ENOCSI 43\r\n#define EL2HLT 44\r\n#define EDEADLK 45\r\n#define ENOLCK 46\r\n#define EBADE 50\r\n#define EBADR 51\r\n#define EXFULL 52\r\n#define ENOANO 53\r\n#define EBADRQC 54\r\n#define EBADSLT 55\r\n#define EDEADLOCK 56\r\n#define EBFONT 57\r\n#define ENOSTR 60\r\n#define ENODATA 61\r\n#define ETIME 62\r\n#define ENOSR 63\r\n#define ENONET 64\r\n#define ENOPKG 65\r\n#define EREMOTE 66\r\n#define ENOLINK 67\r\n#define EADV 68\r\n#define ESRMNT 69\r\n#define ECOMM 70\r\n#define EPROTO 71\r\n#define EMULTIHOP 74\r\n#define ELBIN 75\r\n#define EOVERFLOW 76\r\n#define EBADMSG 77\r\n#define ENOTUNIQ 80\r\n#define EBADFD 81\r\n#define EREMCHG 82\r\n#define ELIBACC 83\r\n#define ELIBBAD 84\r\n#define ELIBSCN 85\r\n#define ELIBMAX 86\r\n#define ELIBEXEC 87\r\n#define ENOSYS 88\r\n#define ENMFILE 89\r\n#define ENOTEMPTY 90\r\n#define ENAMETOOLONG 91\r\n#define EILSEQ 92\r\n#define __ELASTERROR 2000\r\n\r\n#endif\r\n";

static u64 cc_headers_h_fenv = (u64)"/* Header fenv.h */\r\n\r\nint feclearexcept(int);\r\nint fetestexcept(int);\r\n\r\n#define FE_INVALID 1\r\n#define FE_DENORMAL 2\r\n#define FE_INEXACT 32\r\n#define FE_DIVBYZERO 4 \r\n#define FE_OVERFLOW 8\r\n#define FE_UNDERFLOW 16\r\n#define FE_STACKFAULT 64\r\n#define FE_ALL_EXCEPT (FE_INVALID|FE_DENORMAL|FE_INEXACT|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW)\r\n";

static u64 cc_headers_h_float = (u64)"/* Header float.h */\r\n\r\n//#define DBL_MAX_10_EXP 308\r\n//#define DBL_MANT_DIG 53\r\n\r\n#define FLT_RADIX 2\r\n\r\n#define FLT_DIG 6\r\n#define FLT_MIN_EXP -125\r\n#define FLT_MIN 1.17549435E-38F // decimal constant\r\n#define FLT_MIN 0X1P-126F // hex constant\r\n#define FLT_TRUE_MIN 1.40129846E-45F // decimal constant\r\n#define FLT_TRUE_MIN 0X1P-149F // hex constant\r\n#define FLT_HAS_SUBNORM 1\r\n#define FLT_MIN_10_EXP -37\r\n#define FLT_MAX_EXP +128\r\n#define FLT_MAX 3.40282347E+38F // decimal constant\r\n#define FLT_MAX 0X1.fffffeP127F // hex constant\r\n#define FLT_MAX_10_EXP +38\r\n#define FLT_EPSILON 1.19209290e-07F\r\n#define FLT_MANT_DIG 23\r\n\r\n#define DBL_MANT_DIG 53\r\n#define DBL_EPSILON 2.2204460492503131E-16 // decimal constant\r\n//#define DBL_EPSILON 0X1P-52 // hex constant\r\n#define DBL_DECIMAL_DIG 17\r\n#define DBL_DIG 15\r\n#define DBL_MIN_EXP -1021\r\n#define DBL_MIN 2.2250738585072014E-308 // decimal constant\r\n//#define DBL_MIN 0X1P-1022 // hex constant\r\n#define DBL_TRUE_MIN 4.9406564584124654E-324 // decimal constant\r\n//#define DBL_TRUE_MIN 0X1P-1074 // hex constant\r\n#define DBL_HAS_SUBNORM 1\r\n#define DBL_MIN_10_EXP -307\r\n#define DBL_MAX_EXP +1024\r\n#define DBL_MAX 1.7976931348623157E+308 // decimal constant\r\n//#define DBL_MAX 0X1.fffffffffffffP1023 // h\r\n#define DBL_MAX_10_EXP +308\r\n\r\n#define LDBL_MIN DBL_MIN\r\n#define LDBL_MAX DBL_MAX\r\n#define LDBL_EPSILON 2.2204460492503131E-16\r\n#define LDBL_MANT_DIG 53\r\n#define LDBL_MIN_EXP -1021\r\n#define LDBL_MAX_EXP +1024\r\n\r\nint     _isnan(double);\r\n#define isnan _isnan\r\n";

static u64 cc_headers_h_inttypes = (u64)"/* Header inttypes.h */\r\n\r\n#include <stdint.h>\r\n\r\n/* fprintf macros for signed types */\r\n#define PRId8 \"d\"\r\n#define PRId16 \"d\"\r\n#define PRId32 \"d\"\r\n#define PRId64 \"I64d\"\r\n\r\n#define PRIdLEAST8 \"d\"\r\n#define PRIdLEAST16 \"d\"\r\n#define PRIdLEAST32 \"d\"\r\n#define PRIdLEAST64 \"I64d\"\r\n\r\n#define PRIdFAST8 \"d\"\r\n#define PRIdFAST16 \"d\"\r\n#define PRIdFAST32 \"d\"\r\n#define PRIdFAST64 \"I64d\"\r\n\r\n#define PRIdMAX \"I64d\"\r\n\r\n#define PRIi8 \"i\"\r\n#define PRIi16 \"i\"\r\n#define PRIi32 \"i\"\r\n#define PRIi64 \"I64i\"\r\n\r\n#define PRIiLEAST8 \"i\"\r\n#define PRIiLEAST16 \"i\"\r\n#define PRIiLEAST32 \"i\"\r\n#define PRIiLEAST64 \"I64i\"\r\n\r\n#define PRIiFAST8 \"i\"\r\n#define PRIiFAST16 \"i\"\r\n#define PRIiFAST32 \"i\"\r\n#define PRIiFAST64 \"I64i\"\r\n\r\n#define PRIiMAX \"I64i\"\r\n\r\n#define PRIo8 \"o\"\r\n#define PRIo16 \"o\"\r\n#define PRIo32 \"o\"\r\n#define PRIo64 \"I64o\"\r\n\r\n#define PRIoLEAST8 \"o\"\r\n#define PRIoLEAST16 \"o\"\r\n#define PRIoLEAST32 \"o\"\r\n#define PRIoLEAST64 \"I64o\"\r\n\r\n#define PRIoFAST8 \"o\"\r\n#define PRIoFAST16 \"o\"\r\n#define PRIoFAST32 \"o\"\r\n#define PRIoFAST64 \"I64o\"\r\n\r\n#define PRIoMAX \"I64o\"\r\n\r\n/* fprintf macros for unsigned types */\r\n#define PRIu8 \"u\"\r\n#define PRIu16 \"u\"\r\n#define PRIu32 \"u\"\r\n#define PRIu64 \"I64u\"\r\n\r\n\r\n#define PRIuLEAST8 \"u\"\r\n#define PRIuLEAST16 \"u\"\r\n#define PRIuLEAST32 \"u\"\r\n#define PRIuLEAST64 \"I64u\"\r\n\r\n#define PRIuFAST8 \"u\"\r\n#define PRIuFAST16 \"u\"\r\n#define PRIuFAST32 \"u\"\r\n#define PRIuFAST64 \"I64u\"\r\n\r\n#define PRIuMAX \"I64u\"\r\n\r\n#define PRIx8 \"x\"\r\n#define PRIx16 \"x\"\r\n#define PRIx32 \"x\"\r\n#define PRIx64 \"I64x\"\r\n\r\n#define PRIxLEAST8 \"x\"\r\n#define PRIxLEAST16 \"x\"\r\n#define PRIxLEAST32 \"x\"\r\n#define PRIxLEAST64 \"I64x\"\r\n\r\n#define PRIxFAST8 \"x\"\r\n#define PRIxFAST16 \"x\"\r\n#define PRIxFAST32 \"x\"\r\n#define PRIxFAST64 \"I64x\"\r\n\r\n#define PRIxMAX \"I64x\"\r\n\r\n#define PRIX8 \"X\"\r\n#define PRIX16 \"X\"\r\n#define PRIX32 \"X\"\r\n#define PRIX64 \"I64X\"\r\n\r\n#define PRIXLEAST8 \"X\"\r\n#define PRIXLEAST16 \"X\"\r\n#define PRIXLEAST32 \"X\"\r\n#define PRIXLEAST64 \"I64X\"\r\n\r\n#define PRIXFAST8 \"X\"\r\n#define PRIXFAST16 \"X\"\r\n#define PRIXFAST32 \"X\"\r\n#define PRIXFAST64 \"I64X\"\r\n\r\n#define PRIXMAX \"I64X\"\r\n\r\n";

static u64 cc_headers_h_stdint = (u64)"/* Header stdint.h */\r\n\r\n#ifndef $stdint\r\n#define $stdint\r\n\r\ntypedef signed char int8_t;\r\ntypedef short int16_t;\r\ntypedef int int32_t;\r\ntypedef long long int int64_t;\r\n\r\ntypedef unsigned char uint8_t;\r\ntypedef unsigned short uint16_t;\r\ntypedef unsigned int uint32_t;\r\ntypedef unsigned long long int uint64_t;\r\n\r\ntypedef long long int intptr_t;\r\ntypedef unsigned long long int uintptr_t;\r\ntypedef long long intmax_t;\r\ntypedef unsigned long long uintmax_t;\r\n\r\ntypedef char int_least8_t;\r\ntypedef unsigned char uint_least8_t;\r\ntypedef short int_least16_t;\r\ntypedef unsigned short uint_least16_t;\r\ntypedef int int_least32_t;\r\ntypedef unsigned int uint_least32_t;\r\ntypedef long long int_least64_t;\r\ntypedef unsigned long long uint_least64_t;\r\n\r\n#define INTMAX_C(a) (a##LL)\r\n#define UINTMAX_C(a) (a##ULL)\r\n\r\ntypedef char int_fast8_t;\r\ntypedef unsigned char uint_fast8_t;\r\ntypedef short int_fast16_t;\r\ntypedef unsigned short uint_fast16_t;\r\ntypedef int int_fast32_t;\r\ntypedef unsigned int uint_fast32_t;\r\ntypedef long long int_fast64_t;\r\ntypedef unsigned long long uint_fast64_t;\r\n\r\n\r\n#define INT8_MIN -128\r\n#define INT8_MAX 127\r\n#define INT16_MIN -32768\r\n#define INT16_MAX 32767\r\n#define INT32_MIN 0x80000000\r\n#define INT32_MAX 0x7FFFFFFF\r\n#define INT64_MIN 0x8000000000000000\r\n#define INT64_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define UINT8_MAX 255\r\n#define UINT16_MAX 65535\r\n#define UINT32_MAX 0xFFFFFFFF\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define INTPTR_MIN 0x8000000000000000\r\n#define INTPTR_MAX 0x7FFFFFFFFFFFFFFF\r\n#define UINTPTR_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n#define SIZE_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define PTRDIFF_MIN 0x8000000000000000\r\n#define PTRDIFF_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define WCHAR_MIN 0\r\n#define WCHAR_MAX 65535\r\n\r\n#define WINT_MIN 0\r\n#define WINT_MAX 65535\r\n\r\n#define UINT64_C(x) (x##ull)\r\n\r\n#endif\r\n";

static u64 cc_headers_h_limits = (u64)"/* Header limits.h */\n\n#define CHAR_BIT 8\n\n#define CHAR_MIN 0\n#define CHAR_MAX 255\n\n#define UCHAR_MIN 0\n#define UCHAR_MAX 255\n\n#define SCHAR_MIN -128\n#define SCHAR_MAX 127\n\n#define SHRT_MIN -32768\n#define SHRT_MAX 32767\n\n#define USHRT_MIN 0\n#define USHRT_MAX 65535\n\n#define INT_MIN -2147483648\n#define INT_MAX  2147483647\n\n#define UINT_MIN 0\n#define UINT_MAX 4294967295\n\n#define LONG_MIN -2147483648\n#define LONG_MAX  2147483647\n\n#define ULONG_MIN 0\n#define ULONG_MAX 4294967295\n\n#define LLONG_MIN -9223372036854775808LL\n#define LLONG_MAX  9223372036854775807LL\n\n#define ULLONG_MIN 0\n#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFLL\n\n#define SIZE_MAX ULLONG_MAX\n";

static u64 cc_headers_h_locale = (u64)"/* Header locale.h */\r\n\r\n#ifndef $locale\r\n#define $locale\r\n\r\n#define LC_ALL 0\r\n#define LC_COLLATE 1\r\n#define LC_CTYPE 2\r\n#define LC_MONETARY 3\r\n#define LC_NUMERIC 4\r\n#define LC_TIME 5\r\n\r\nstruct lconv {\r\n\tchar *decimal_point;\r\n\tchar *thousands_sep;\r\n\tchar *grouping;\r\n\tchar *int_curr_symbol;\r\n\tchar *currency_symbol;\r\n\tchar *mon_decimal_point;\r\n\tchar *mon_thousands_sep;\r\n\tchar *mon_grouping;\r\n\tchar *positive_sign;\r\n\tchar *negative_sign;\r\n\tchar int_frac_digits;\r\n\tchar frac_digits;\r\n\tchar p_cs_precedes;\r\n\tchar p_sep_by_space;\r\n\tchar n_cs_precedes;\r\n\tchar n_sep_by_space;\r\n\tchar p_sign_posn;\r\n\tchar n_sign_posn;\r\n};\r\nchar *setlocale(int category, const char *locale);\r\n\r\nstruct lconv *localeconv(void);\r\n\r\nchar * setlocale(int,const char *);\r\n#endif\r\n";

static u64 cc_headers_h__ansi = (u64)"/* Header _ansi.h */\r\n";

static u64 cc_headers_h_math = (u64)"/* Header math.h */\n\n#define HUGE_VAL 1.7976931348623156e+308\n\ndouble floor(double);\ndouble ceil(double);\ndouble sqrt(double);\ndouble sin(double);\ndouble cos(double);\ndouble tan(double);\ndouble fmod(double,double);\ndouble asin(double);\ndouble acos(double);\ndouble atan(double);\ndouble log(double);\ndouble log10(double);\ndouble exp(double);\ndouble modf(double,double*);\ndouble atan2(double,double);\ndouble pow(double,double);\ndouble fabs(double);\ndouble sinh(double);\ndouble cosh(double);\ndouble tanh(double);\ndouble frexp(double,int*);\ndouble ldexp(double,int);\nint isnan(double);\n\n#define ldexpl ldexp\n\nfloat sinf(float);\nfloat cosf(float);\nfloat tanf(float);\nfloat expf(float);\nfloat powf(float, float);\nfloat logf(float);\n\nfloat sqrtf(float);\nfloat acosf(float);\nfloat atan2f(float,float);\nfloat ceilf(float);\n\ndouble acosh (double);\nlong double acoshl(long double);\nlong double acoshl(long double);\nfloat acoshf(float);\n\ndouble asinh (double);\nlong double asinhl(long double);\nlong double sinhl(long double);\nfloat asinhf(float);\n\ndouble atanh(double);\nlong double atanhl(long double);\nfloat atanhf(float);\n\nlong double expm1l(long double);\ndouble expm1(double);\nfloat expm1f(float);\ndouble _expm1i(int);\n\ndouble cbrt(double);\nlong double cbrtl(long double);\nfloat cbrtf(float);\n\ndouble trunc(double x);\nlong double truncl(long double);\nfloat truncf(float);\n\ndouble round(double);\nfloat roundf(float);\nlong double roundl(long double);\ndouble _roundi(int);\n\nlong double fminl(long double,long double);\nfloat fminf(float ,float);\ndouble fmin(double,double);\n\n//float fabsf(float);\n#define fabsf fabs\n\ndouble lgamma (double);\nlong double lgammal(long double);\nfloat lgammaf(float);\n\nlong double tgammal(long double);\ndouble tgamma(double);\nfloat tgammaf(float);\n\ndouble log1p(double);\nlong double log1pl(long double);\nfloat log1pf(float);\n\nlong double log10l(long double);\nfloat log10f(float);\ndouble _log10i(int);\ndouble log10(double);\n\ndouble erf(double);\nlong double erfl(long double);\nfloat erff(float);\n\ndouble hypot (double, double);\ndouble _hypot(double,double);\nlong double hypotl(long double,long double);\nfloat hypotf(float,float);\n\ndouble nextafter (double, double);\nlong double nextafterl(long double,long double);\nfloat nextafterf(float,float);\n\ndouble nexttoward(double,long double);\nlong double nexttowardl(long double,long double);\nfloat nexttowardf(float,long double);\n\ndouble erfc(double);\nlong double erfcl(long double);\nfloat erfcf(float);\n\nint _finite(double);\n#define finite _finite\n\nfloat floorf(float);\n\ndouble _copysign(double,double);\n#define copysign _copysign\n\nlong double fmaxl(long double,long double);\ndouble fmax(double,double);\nfloat fmaxf(float,float);\nfloat fmodf(float,float);\n\n//long double exp2l(long double);\ndouble exp2(double);\nfloat exp2f(float);\n\n//double log2(double);\n#define log2(x) (log(x)*1.442695041)\n\n#define M_PI 3.1415926535897932384625433\n#define M_PI_2 (M_PI/2.0)\n#define M_2_PI 0.63661977236758134308\n\nint isinf(double);\n\nint _finite(double);\n\n#define isfinite _finite\n\nint isfinitef(float);\nint isfinitel(long double);\n\n";

static u64 cc_headers_h_setjmp = (u64)"/* Header setjmp.h */\n\n\n#ifndef $setjmphdr\n#define $setjmphdr 1\n\ntypedef int jmp_buf[128];\n\n//void $mcclongjmp(jmp_buf, int);\n//int $mccsetjmp(jmp_buf);\n\n#define setjmp $setjmp\n#define longjmp $longjmp\n\n#endif\n\n";

static u64 cc_headers_h_signal = (u64)"/* Header signal.h */\r\n\r\n#define SIGINT    2\r\n#define SIGILL    4\r\n#define SIGFPE    8\r\n#define SIGSEGV  11\r\n#define SIGTERM  15\r\n#define SIGBREAK 21\r\n#define SIGABRT  22\r\n\r\n#define SIG_DFL (void (*)(int))0\r\n#define SIG_IGN (void (*)(int))1\r\n#define SIG_SGE (void (*)(int))3\r\n#define SIG_ACK (void (*)(int))4\r\n\r\n#define SIG_ERR (void (*)(int))-1\r\n\r\nextern void (*signal(int, void (*)(int)))(int);\r\n\r\nextern int raise(int);\r\n\r\n\r\ntypedef int sig_atomic_t;\r\n";

static u64 cc_headers_h_stdarg = (u64)"/* Header stdarg.h */\n\n#ifndef $STDARG\n #define $STDARG\n\n//coded for x64 target as used by mcc (with first four params also on stack)\n\n typedef char *\tva_list;\n\n #if __MCCI__\n  #define va_start(ap,v) ap=((va_list)&v-8)\n  #define va_arg(ap,t) *(t*)((ap-=8)+8)\n  #define va_copy(dest,src) (dest=src)\n  #define va_end(ap)\t( ap = (va_list)0 )\n\n #else\n  #define va_start(ap,v) ap=((va_list)&v+8)\n  #define va_arg(ap,t) *(t*)((ap+=8)-8)\n  #define va_copy(dest,src) (dest=src)\n  #define va_end(ap)\t( ap = (va_list)0 )\n\n #endif\n\n#endif\n";

static u64 cc_headers_h_stdbool = (u64)"/* Header stdbool.h */\r\n\r\n#define bool unsigned char\r\n#define true 1\r\n#define false 0\r\n\r\n\r\n";

static u64 cc_headers_h_stddef = (u64)"/* Header stddef.h */\r\n\r\n#ifndef $stddef\r\n#define $stddef\r\n\r\ntypedef signed long long int ssize_t;\r\ntypedef unsigned long long int size_t;\r\n\r\n#define _WCHAR_T_DEFINED\r\ntypedef unsigned short wchar_t;\r\n//typedef signed short wchar_t;\r\n\r\n#define NULL ((void*)0)\r\n\r\n#define offsetof(a,b) (size_t) &( ((a*)0) -> b)\r\n\r\ntypedef long long int ptrdiff_t;\r\n\r\n#endif // stddef\r\n";

static u64 cc_headers_h_stdio = (u64)"/* Header stdio.h */\n\n#ifndef $stdio\n#define $stdio 1\n\n#define __attribute__(x)\n\n#ifndef $valist\n\ttypedef char* va_list;\n\t#define $valist\n#endif\n\n#include <stddef.h>\n\ntypedef long long int fpos_t;\n\n#define SEEK_SET 0\n#define SEEK_CUR 1\n#define SEEK_END 2\n\n#define\tSTDIN_FILENO\t0\n#define\tSTDOUT_FILENO\t1\n#define\tSTDERR_FILENO\t2\n\n#define EOF (-1)\n#define FILENAME_MAX 260\n\n#define L_tmpnam 10\n\ntypedef struct {\n\tchar *_ptr;\n\tint   _cnt;\n\tchar *_base;\n\tint   _flag;\n\tint   _file;\n\tint   _charbuf;\n\tint   _bufsiz;\n\tchar *_tmpfname;\n} FILE;\n\nextern char* __iob_func(void);\n\n#define stdin ((FILE*)(__iob_func()))\n#define stdout ((FILE*)(__iob_func()+sizeof(FILE)))\n#define stderr ((FILE*)(__iob_func()+sizeof(FILE)*2))\n\n#define _IOREAD 0x0001\n#define _IOWRT 0x0002\n\n#define _IOFBF 0x0000\n#define _IOLBF 0x0040\n#define _IONBF 0x0004\n\n#define _IOMYBUF 0x0008\n#define _IOEOF 0x0010\n#define _IOERR 0x0020\n#define _IOSTRG 0x0040\n#define _IORW 0x0080\n\n#define BUFSIZ 512\n\nFILE* fopen(const char*, const char*);\nint fclose(FILE*);\nlong ftell(FILE*);\n//long long int _ftelli64(FILE*);\nint fseek(FILE*,long,int);\nint _fseeki64(FILE*,long long int,int);\n\nsize_t fread(void*, size_t, size_t, FILE*);\nsize_t fwrite(const void*, size_t, size_t, FILE*);\nint remove(const char*);\nint rename(const char *,const char *);\nFILE* freopen(const char*, const char*, FILE*);\nFILE* _wfopen(const wchar_t*,const wchar_t *);\n\nint printf(const char*, ...);\nint sprintf(char*,const char*, ...);\nint fprintf(FILE*,const char*, ...);\nint sscanf(const char*, const char*, ...);\nint scanf(const char*, ...);\nint fscanf(FILE *,const char *, ...);\nint _snprintf(char *,size_t,const char*,...);\n#define snprintf _snprintf\nint _vsnprintf(char*, size_t, const char*, va_list);\nint vsnprintf(char*,size_t,const char*,va_list);\nint vsprintf(char*, const char*, va_list);\nint _wremove(const wchar_t*);\nint _wrename(const wchar_t*,const wchar_t*);\n\ntypedef char* va_list;\n\nint vfprintf(FILE*, const char*, va_list);\nint vprintf(const char*, va_list);\n\nint puts(const char*);\nchar* fgets(char*, int, FILE*);\nint fputs(const char*, FILE*);\nint fgetc(FILE*);\nint fputc(int, FILE*);\nint ungetc(int, FILE*);\nint getchar(void);\nint putchar(int);\nint fflush(FILE *);\nint getc(FILE *);\nint putc(int, FILE *);\n\nint feof(FILE*);\nint ferror(FILE*);\nvoid clearerr(FILE*);\n\nint fileno(FILE*);\nint _fileno(FILE*);\nint setvbuf(FILE*,char*,int,size_t);\nFILE* _popen(const char*, const char*);\nint _pclose(FILE*);\nint _unlink(const char *);\n#define unlink _unlink;\nFILE* _fdopen(int, const char *);\n#define fdopen _fdopen\nint fgetpos(FILE*, fpos_t*);\nint fsetpos(FILE*, const fpos_t*);\nvoid perror(char*);\nvoid setbuf(FILE*, char*);\n\nvoid rewind(FILE*);\n\nFILE* tmpfile(void);\n\nchar* tmpnam(char*);\nwchar_t getwc(FILE *);\n\nextern void* _wenviron;\n\n#endif\n\n";

static u64 cc_headers_h_stdlib = (u64)"/* Header stdlib.h */\n\n#ifndef $stdlib\n#define $stdlib 1\n\n#include <stddef.h>\n\n#define EXIT_FAILURE 1\n#define EXIT_SUCCESS 0\n\n#define RAND_MAX 32767\n\nvoid* malloc(size_t);\nvoid* realloc(void*, size_t);\nvoid* calloc(size_t, size_t);\n\nvoid free(void*);\n\nvoid exit(int);\n\nint system(const char*);\nint _wsystem(const wchar_t*);\n\nint abs(int);\nlong labs(long);\nlong long llabs(long);\nint rand(void);\nvoid srand(unsigned int);\nint atoi(const char*);\nlong atol(const char*);\nlong long atoll(const char*);\nlong long atoi64(const char*);\ndouble atof(const char *);\nint\tatexit(void (*)(void));\nchar *_itoa(int,char *,int);\n\n#define itoa _itoa\n\nvoid qsort(void*, size_t, size_t, int (*)(void*, void*));\n\ntypedef struct {\n\tlong long int quot;\n\tlong long int rem;\n} lldiv_t;\n\nlldiv_t lldiv(long long int, long long int);\n\nchar* getenv(const char*);\nwchar_t* _wgetenv(const wchar_t*);\nint _wputenv(const wchar_t*);\n\n\ndouble strtod(const char*, char**);\n\n//float strtof(const char *, char**);\n#define strtof strtod\n\nlong double strtold(const char*, char**);\nvoid abort(void);\nlong int strtol(const char*, char**, int);\n\nlong double strtold(const char *,char **);\n\nlong long int _strtoi64(const char *,char **,int);\n#define strtoll _strtoi64\n\nunsigned long long int _strtoui64(const char *,char **,int);\n\nunsigned long long int _strtoui64(const char*, char**, int);\n#define strtoull _strtoui64\nunsigned long strtoul(const char*, char**, int);\n\nsize_t _msize(void *);\n#define msize _msize\n\nvoid* bsearch(const void *,const void *, size_t, size_t,\n\t\tint (*_compar)(const void *,const void *));\n\n\nchar* _fullpath(char*, const char*, size_t);\n\n\n#endif\n";

static u64 cc_headers_h__syslist = (u64)"/* Header _syslist.h */\r\n";

static u64 cc_headers_h_string = (u64)"/* Header string.h */\n\n#include <stddef.h>\n\nvoid* memcpy(void*, const void*, size_t);\nvoid* memmove(const void*, const void*, size_t);\nvoid* memset(void*, int, size_t);\nint memcmp(const void*, const void*, size_t);\nvoid* memchr(const void *, int, size_t);\n\nsize_t strlen(const char*);\nchar* strcpy(char*, const char*);\nchar* strncpy(char*, const char*, size_t);\nchar* strcat(char*, const char*);\nint strcmp(const char*, const char*);\nint strncmp(const char*, const char*, size_t);\nchar* strchr(const char*, int);\nchar* strstr(const char*, const char*);\nchar* strrchr(const char*, int);\nint _stricmp(const char*, const char*);\n#define stricmp _stricmp\n#define strcasecmp _stricmp\n\n\n\nint _strnicmp(const char*, const char*, size_t);\n#define strnicmp _strnicmp\nchar* strncat(char*, const char*, size_t);\nchar* strtok(char*, const char*);\n\nsize_t strcspn(const char*, const char*);\nsize_t strspn(const char*, const char*);\nint strcoll(const char *, const char *);\n\nunsigned long strtoul(const char*, char**, int);\n\nchar* strerror(int);\nchar* strpbrk(const char*, const char*);\nsize_t strxfrm(char*, const char *, size_t);\n\nchar* _strupr(char*);\nchar* _strlwr(char*);\n#define strupr _strupr\n#define strlwr _strlwr\n\nchar*strnupr(char*,size_t);\nchar*strnlwr(char*,size_t);\nint strtrim(char*);\nchar*strrev(char*);\n\nchar* _strdup(const char*);\n#define strdup _strdup\n\nint _wcsicmp(const wchar_t *,const wchar_t *);\n\nwchar_t *wcspbrk(const wchar_t*,const wchar_t*);\n\nsize_t wcslen(const wchar_t*);\n";

static u64 cc_headers_h_time = (u64)"/* Header time.h */\r\n\r\n#ifndef $time\r\n#define $time\r\n\r\n#include <stddef.h>\r\n\r\ntypedef long clock_t;\r\nclock_t clock(void);\r\n\r\n//typedef long time_t;\r\n#ifndef _TIME_T_DEFINED\r\n#define _TIME_T_DEFINED\r\ntypedef long long int time_t;\r\n#endif\r\n\r\nstruct tm\r\n{\r\n  int\ttm_sec;\r\n  int\ttm_min;\r\n  int\ttm_hour;\r\n  int\ttm_mday;\r\n  int\ttm_mon;\r\n  int\ttm_year;\r\n  int\ttm_wday;\r\n  int\ttm_yday;\r\n  int\ttm_isdst;\r\n};\r\n\r\n//struct tm *localtime(time_t*);\r\nstruct tm* _localtime32(time_t*);\r\n#define localtime _localtime32\r\n\r\ntime_t _time64(time_t *_timer);\r\n#define time _time64\r\n\r\n#define CLOCKS_PER_SEC 1000\r\n\r\nstruct tm *gmtime(const time_t*);\r\nsize_t strftime(char *, size_t, const char *, const struct tm *);\r\ntime_t mktime(struct tm *);\r\ndouble difftime(time_t, time_t);\r\n\r\nchar* asctime(const struct tm*);\r\n//char* ctime(const time_t *_time);\r\nchar* _ctime64(const time_t *_time);\r\n#define ctime _ctime64\r\n\r\n#endif\r\n";

static u64 cc_headers_h_utime = (u64)"/* sys/utime.h header */\n\n#ifndef $utime\n#define $utime\n\nstruct _utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\n\nstruct utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\nstruct __utimbuf64 {\n  long long int actime;\n  long long int modtime;\n};\n\nint _utime64(const char *_Filename,struct __utimbuf64 *_Time);\n\nint utime(const char *_Filename,struct utimbuf *_Utimbuf) {\n  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);\n}\n\n#endif\n";

static u64 cc_headers_h_unistd = (u64)"/* unistd.h header */\r\n\r\nunsigned int _sleep(unsigned int);\r\n#define sleep _sleep\r\n\r\n#define alarm(x) {puts(\"ALARM\"); exit(1);}\r\n\r\nint _write(int,void*,unsigned int);\r\n#define write _write\r\n\r\nint _close(int);\r\n#define close _close\r\n";

static u64 cc_headers_h_safelib = (u64)"/* Header safelib.h */\r\n";

static u64 cc_headers_h_wchar = (u64)"/* Header wchar.h */\r\n\r\n#include <stddef.h>\r\n\r\n\r\n#define _WCHAR_T_DEFINED\r\ntypedef unsigned short wint_t;\r\ntypedef unsigned short wchar_t;\r\n//typedef signed short wchar_t;\r\n\r\nsize_t wcslen(const wchar_t*);\r\nwchar_t* wcscpy(wchar_t*,const wchar_t*);\r\n//wchar_t* _wgetenv(constwchar_t*);\r\nwchar_t* wcstok(wchar_t*,wchar_t*,wchar_t**);\r\nwchar_t* wcstok_s(wchar_t*,wchar_t*,wchar_t**);\r\n\r\nwchar_t* wcschr(wchar_t*,wchar_t);\r\nwchar_t* wcsstr(const wchar_t*,const wchar_t*);\r\n\r\n\r\nint wcscmp(const wchar_t*,const wchar_t*);\r\ntypedef long _off_t;\r\n";

static u64 cc_headers_h_wctype = (u64)"/* Header wctype.h */\r\n";

static u64 cc_headers_h_systypes = (u64)"/* types.h */\r\n#ifndef $systypes\r\n#define $systypes 1\r\n\r\ntypedef long int off_t;\r\ntypedef long int ino_t;\r\ntypedef unsigned int dev_t;\r\n\r\ntypedef long long time_t;\r\n\r\n#endif\r\n";

static u64 cc_headers_h_sysstat = (u64)"/* stat.h */\r\n\r\n#ifndef $sysstat\r\n#define $sysstat\r\n\r\n#include <stddef.h>\r\n\r\nstruct _stat {\r\n\tunsigned int\tst_dev;\r\n\tunsigned short\tst_ino;\r\n\tunsigned short\tst_mode;\r\n\tshort\t\t\tst_nlink;\r\n\tshort\t\t\tst_uid;\r\n\tshort\t\t\tst_gid;\r\n\tunsigned long\tst_rdev;\r\n\tunsigned int\tst_size;\r\n\tunsigned long long int\tst_atime;\r\n\tunsigned long long int\tst_mtime;\r\n\tunsigned long long int\tst_ctime;\r\n};\r\n\r\n#define stat _stat\r\n#define _stati64 _stat\r\n\r\n#define _S_IFMT 0xF000\r\n#define _S_IFDIR 0x4000\r\n#define _S_IFCHR 0x2000\r\n#define _S_IFIFO 0x1000\r\n#define _S_IFREG 0x8000\r\n#define _S_IREAD 0x0100\r\n#define _S_IWRITE 0x0080\r\n#define _S_IEXEC 0x0040\r\n\r\n#define S_IFMT 0xF000\r\n#define S_IFDIR 0x4000\r\n#define S_IFCHR 0x2000\r\n#define S_IFIFO 0x1000\r\n#define S_IFREG 0x8000\r\n#define S_IREAD 0x0100\r\n#define S_IWRITE 0x0080\r\n#define S_IEXEC 0x0040\r\n\r\n#define S_ISCHR(nd) (((nd) & S_IFMT) == S_IFCHR)\r\n#define S_ISDIR(nd) (((nd) & S_IFMT) == S_IFDIR)\r\n#define S_ISFIFO(nd) (((nd) & S_IFMT) == S_IFIFO)\r\n#define S_ISREG(nd) (((nd) & S_IFMT) == S_IFREG)\r\n\r\n\r\n#define\t_S_IRWXU\t(_S_IREAD | _S_IWRITE | _S_IEXEC)\r\n#define\t_S_IXUSR\t_S_IEXEC\r\n#define\t_S_IWUSR\t_S_IWRITE\r\n\r\n#define\tS_IRWXU\t\t_S_IRWXU\r\n#define\tS_IXUSR\t\t_S_IXUSR\r\n#define\tS_IWUSR\t\t_S_IWUSR\r\n#define\tS_IRUSR\t\t_S_IRUSR\r\n#define\t_S_IRUSR\t_S_IREAD\r\n\r\n#define S_IRGRP    (S_IRUSR >> 3)\r\n#define S_IWGRP    (S_IWUSR >> 3)\r\n#define S_IXGRP    (S_IXUSR >> 3)\r\n#define S_IRWXG    (S_IRWXU >> 3)\r\n\r\n#define S_IROTH    (S_IRGRP >> 3)\r\n#define S_IWOTH    (S_IWGRP >> 3)\r\n#define S_IXOTH    (S_IXGRP >> 3)\r\n#define S_IRWXO    (S_IRWXG >> 3)\r\n\r\n//#define\tS_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\r\n//#define\tS_ISFIFO(m)\t(((m) & S_IFMT) == S_IFIFO)\r\n//#define\tS_ISCHR(m)\t(((m) & S_IFMT) == S_IFCHR)\r\n#define\tS_IFBLK\t0x3000\t/* Block: Is this ever set under w32? */\r\n#define\tS_ISBLK(m)\t(((m) & S_IFMT) == S_IFBLK)\r\n#define\tS_ISREG(m)\t(((m) & S_IFMT) == S_IFREG)\r\n\r\n\r\n\r\nint stat(const char *, struct stat*);\r\n\r\nint _fstati64(int, struct stat*);\r\n\r\nint fstat(int, struct stat *);\r\n#define _fstat fstat\r\n\r\nint _wstati64(const wchar_t,struct _stati64 *buffer);  \r\n\r\n\r\n\r\n#endif\r\n";

static u64 cc_headers_h_systimeb = (u64)"/* timeb.h */\r\n\r\n#ifndef $timeb\r\n#define $timeb\r\n\r\n#include <time.h>\r\n\r\nstruct _timeb {\r\n\ttime_t time;\r\n\tunsigned short millitm;\r\n\tshort timezone;\r\n\tshort dstflag;\r\n};\r\n#define timeb _timeb\r\n\r\nvoid _ftime64(struct _timeb*);\r\n#define _ftime _ftime64\r\n#define ftime _ftime64\r\n\r\n#endif\r\n";

static u64 cc_headers_h_sysutime = (u64)"/* sys/utime.h header */\n\n#ifndef $utime\n#define $utime\n\nstruct _utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\n\nstruct utimbuf {\n\tlong actime;\n\tlong modtime;\n};\n\nstruct __utimbuf64 {\n  long long int actime;\n  long long int modtime;\n};\n\nint _utime64(const char *_Filename,struct __utimbuf64 *_Time);\n\nint utime(const char *_Filename,struct utimbuf *_Utimbuf) {\n  return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);\n}\n\n#endif\n";

static u64 cc_headers_h_memory = (u64)"#include <malloc.h>\r\n";

static u64 cc_headers_h_fcntl = (u64)"/* FCNTL.H */\r\n\r\nint _setmode(int,int);\r\n\r\n#ifndef _INC_FCNTL\r\n#define _INC_FCNTL\r\n\r\n#define _O_RDONLY 0x0000\r\n#define _O_WRONLY 0x0001\r\n#define _O_RDWR 0x0002\r\n#define _O_APPEND 0x0008\r\n#define _O_CREAT 0x0100\r\n#define _O_TRUNC 0x0200\r\n#define _O_EXCL 0x0400\r\n#define _O_TEXT 0x4000\r\n#define _O_BINARY 0x8000\r\n#define _O_WTEXT 0x10000\r\n#define _O_U16TEXT 0x20000\r\n#define _O_U8TEXT 0x40000\r\n#define _O_ACCMODE (_O_RDONLY|_O_WRONLY|_O_RDWR)\r\n\r\n#define _O_RAW _O_BINARY\r\n#define _O_NOINHERIT 0x0080\r\n#define _O_TEMPORARY 0x0040\r\n#define _O_SHORT_LIVED 0x1000\r\n\r\n#define _O_SEQUENTIAL 0x0020\r\n#define _O_RANDOM 0x0010\r\n\r\n#if !defined(NO_OLDNAMES) || defined(_POSIX)\r\n#define O_RDONLY _O_RDONLY\r\n#define O_WRONLY _O_WRONLY\r\n#define O_RDWR _O_RDWR\r\n#define O_APPEND _O_APPEND\r\n#define O_CREAT _O_CREAT\r\n#define O_TRUNC _O_TRUNC\r\n#define O_EXCL _O_EXCL\r\n#define O_TEXT _O_TEXT\r\n#define O_BINARY _O_BINARY\r\n#define O_RAW _O_BINARY\r\n#define O_TEMPORARY _O_TEMPORARY\r\n#define O_NOINHERIT _O_NOINHERIT\r\n#define O_SEQUENTIAL _O_SEQUENTIAL\r\n#define O_RANDOM _O_RANDOM\r\n#define O_ACCMODE _O_ACCMODE\r\n#endif\r\n\r\n#endif\r\n";

static u64 cc_headers_h_io = (u64)"\r\n#ifndef $io\r\n#define $io\r\n\r\n#include <stdint.h>\r\n#include <wchar.h>\r\n#include <time.h>\r\n\r\n/* io.h */\r\n\r\n#define _A_NORMAL 0x00\r\n#define _A_RDONLY 0x01\r\n#define _A_HIDDEN 0x02\r\n#define _A_SYSTEM 0x04\r\n#define _A_SUBDIR 0x10\r\n#define _A_ARCH 0x20\r\n\r\n\r\n//#message \"IO included\"\r\nstruct _finddata_t {\r\n        unsigned    attrib;\r\n        time_t      time_create;\r\n        time_t      time_access;\r\n        time_t      time_write;\r\n        unsigned long    size;\r\n        char        name[260];\r\n};\r\n\r\nint _isatty(int);\r\n\r\nint _read(int, void*, unsigned int);\r\n#define read _read\r\n\r\nint _open(const char*, int, ...);\r\n#define open _open\r\n\r\nlong _lseek(int, long, int);\r\n#define lseek _lseek\r\n\r\nint _close(int);\r\n#define close _close\r\n\r\nintptr_t _get_osfhandle(int);\r\nint _open_osfhandle(intptr_t,int);\r\n\r\nint _setmode(int,int);\r\n#define setmode _setmode\r\n\r\nint _wchmod(const wchar_t*, int);\r\n\r\nint _chmod(const char *, int);\r\n#define chmod _chmod\r\n\r\nint _dup(int);\r\n#define dup _dup\r\n\r\nintptr_t _findfirst(const char*, struct _finddata_t*);\r\nint _findnext(intptr_t, struct _finddata_t*);\r\nint _findclose(intptr_t);\r\n\r\nint _access(const char*,int);\r\n#define access _access\r\n\r\nint _wunlink(const wchar_t*);\r\n\r\n\r\n#endif\r\n";

static u64 cc_headers_h_direct = (u64)"#ifndef $direct\r\n#define $direct\r\n\r\ntypedef struct {\r\n unsigned int total_clusters;\r\n unsigned int avail_clusters;\r\n unsigned int sectors_per_cluster;\r\n unsigned int bytes_per_sector;\r\n} diskfree_t;\r\n\r\nint chdir(const char *);\r\nchar* _getcwd(char *, int);\r\n#define getcwd _getcwd\r\nint _mkdir(const char *);\r\nint _rmdir(const char *);\r\nint _wrmdir(const wchar_t*);\r\nint _wmkdir(const wchar_t*);\r\n\r\n#define mkdir _mkdir\r\n#define rmdir _rmdir\r\n\r\nint _chdrive(int);\r\nchar* _getdcwd(int, char *, int);\r\nwchar_t* _wgetcwd(wchar_t*, int);\r\nint _wchdir(const wchar_t*);\r\nint _getdrive(void);\r\nint _chdir(const char*);\r\n#define chdir _chdir\r\n\r\nunsigned long _getdrives(void);\r\nunsigned int _getdiskfree(unsigned int, diskfree_t*);\r\n\r\n#endif\r\n\r\n";

static u64 cc_headers_h_process = (u64)"/* Header process.h */\r\n#ifndef $process\r\n#define $process\r\n\r\n#include <stdint.h>\r\n\r\n#define P_WAIT\t\t0\r\n#define P_NOWAIT\t1\r\n#define P_OVERLAY\t2\r\n#define P_DETACH\t4\r\n#define WAIT_CHILD 0\r\n#define _P_WAIT P_WAIT\r\n#define _P_NOWAIT P_NOWAIT\r\n#define _P_OVERLAY P_OVERLAY\r\n\r\nint _spawnvp(int, const char*, const char*const*);\r\n#define spawnvp _spawnvp\r\n\r\nvoid endthread(void);\r\nunsigned long _beginthreadex(void *,unsigned,unsigned (*)(void *),void *,unsigned,unsigned *);\r\nvoid _endthreadex(unsigned);\r\nint _cwait(int*, int, int);\r\n#define cwait _cwait\r\n//int _System(const char *cmd,int nCmdShow);\r\n\r\nintptr_t _execve(const char*, const char*const*, const char*const*);\r\n#define execve _execve\r\n\r\n//#define _WAIT_CHILD\t0\r\n//#endif\r\n#endif\r\n\r\n";

static u64 cc_headers_h_malloc = (u64)"#include <stddef.h>\n\nvoid* malloc(size_t);\nvoid* realloc(void *, size_t);\nvoid  free(void *);\nvoid *_alloca(size_t);\n\n#define alloca malloc\n";

static u64 cc_headers_h_conio = (u64)"/* conio.h */\r\n#include <stddef.h>\r\n#include <wchar.h>\r\n\r\nint _getch(void);\r\nint _kbhit(void);\r\nwint_t _getwch(void);\r\n\r\n#define getch _getch\r\n#define kbhit _kbhit\r\n\r\nint _putch(int);\r\nint _cprintf(char *, ...);\r\nint _getche(void);\r\nint _ungetch(int);\r\n\r\n#define putch _putch\r\n#define cprintf _cprintf\r\n#define getche _getche\r\n#define ungetch _ungetch\r\n";

static u64 cc_headers_h_winsock2 = (u64)"#ifndef _WINSOCK2_H\r\n#define _WINSOCK2_H\r\n\r\n#include <_mingw.h>\r\n#include <windows.h>\r\n\r\n#ifndef FD_SETSIZE\r\n#define FD_SETSIZE 64\r\n#endif\r\n\r\ntypedef unsigned int SOCKET;\r\n\r\ntypedef struct fd_set {\r\n  unsigned int   fd_count;\r\n  SOCKET  fd_array[FD_SETSIZE];\r\n} fd_set;\r\n\r\nextern int __stdcall __WSAFDIsSet(SOCKET,fd_set *);\r\n\r\n#ifndef FD_CLR\r\n#define FD_CLR(fd,set) do { unsigned int __i;\\\r\nfor (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\\\r\n    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\\\r\n    while (__i < ((fd_set *)(set))->fd_count-1) {\\\r\n        ((fd_set*)(set))->fd_array[__i] = ((fd_set*)(set))->fd_array[__i+1];\\\r\n        __i++;\\\r\n    }\\\r\n    ((fd_set*)(set))->fd_count--;\\\r\n    break;\\\r\n    }\\\r\n}\\\r\n} while (0)\r\n#endif\r\n\r\n#ifndef FD_SET\r\n/* this differs from the define in winsock.h and in cygwin sys/types.h */\r\n#define FD_SET(fd, set) do { unsigned int __i;\\\r\nfor (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\\\r\n    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\\\r\n        break;\\\r\n    }\\\r\n}\\\r\nif (__i == ((fd_set *)(set))->fd_count) {\\\r\n    if (((fd_set *)(set))->fd_count < FD_SETSIZE) {\\\r\n        ((fd_set *)(set))->fd_array[__i] = (fd);\\\r\n        ((fd_set *)(set))->fd_count++;\\\r\n    }\\\r\n}\\\r\n} while(0)\r\n#endif\r\n\r\n#ifndef FD_ZERO\r\n#define FD_ZERO(set) (((fd_set *)(set))->fd_count=0)\r\n#endif\r\n\r\n#ifndef FD_ISSET\r\n#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set *)(set))\r\n#endif\r\n\r\n#ifndef _TIMEVAL_DEFINED /* also in sys/time.h */\r\n#define _TIMEVAL_DEFINED\r\nstruct timeval {\r\n    long tv_sec;\r\n    long tv_usec;\r\n};\r\n#endif\r\n\r\nstruct in_addr {\r\n    union {\r\n        struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;\r\n        struct { unsigned short s_w1,s_w2; } S_un_w;\r\n        unsigned long S_addr;\r\n    } S_un;\r\n};\r\n#define s_addr  S_un.S_addr\r\n\r\nstruct sockaddr_in {\r\n    short sin_family;\r\n    unsigned short sin_port;\r\n    struct in_addr sin_addr;\r\n    char sin_zero[8];\r\n};\r\n\r\nstruct sockaddr {\r\n    unsigned short sa_family;\r\n    char sa_data[14];\r\n};\r\n\r\nstruct hostent {\r\n    char *h_name;\r\n    char **h_aliases;\r\n    short h_addrtype;\r\n    short h_length;\r\n    char **h_addr_list;\r\n};\r\n#define h_addr h_addr_list[0]\r\n\r\n#define WSADESCRIPTION_LEN  256\r\n#define WSASYS_STATUS_LEN   128\r\ntypedef struct WSAData {\r\n    WORD wVersion;\r\n    WORD wHighVersion;\r\n    char szDescription[WSADESCRIPTION_LEN+1];\r\n    char szSystemStatus[WSASYS_STATUS_LEN+1];\r\n    unsigned short iMaxSockets;\r\n    unsigned short iMaxUdpDg;\r\n    char *lpVendorInfo;\r\n} WSADATA;\r\ntypedef WSADATA *LPWSADATA;\r\n\r\n#define INVALID_SOCKET (SOCKET)(~0)\r\n#define SOCK_STREAM  1\r\n#define SO_REUSEADDR 4\r\n#define AF_INET 2\r\n#define MSG_PEEK 0x2\r\n#define INADDR_ANY (unsigned long)0x00000000\r\n#define INADDR_LOOPBACK 0x7f000001\r\n#define SOL_SOCKET 0xffff\r\n\r\n#define SD_RECEIVE  0x00\r\n#define SD_SEND     0x01\r\n#define SD_BOTH     0x02\r\n\r\n#define h_errno WSAGetLastError()\r\n\r\n#define WSABASEERR 10000\r\n#define TRY_AGAIN (WSABASEERR+1002)\r\n\r\nSOCKET __stdcall accept(SOCKET, struct sockaddr *, int *);\r\nint __stdcall bind(SOCKET, const struct sockaddr *, int);\r\nint __stdcall closesocket(SOCKET);\r\nint __stdcall connect(SOCKET, const struct sockaddr *, int);\r\nstruct hostent *__stdcall gethostbyname(const char *);\r\nint __stdcall gethostname(char *, int);\r\nint __stdcall getpeername(SOCKET, struct sockaddr *, int *);\r\nint __stdcall getsockname(SOCKET, struct sockaddr *, int *);\r\nunsigned long __stdcall htonl(unsigned long);\r\nunsigned short __stdcall htons(unsigned short);\r\nint __stdcall listen(SOCKET, int);\r\nunsigned long __stdcall ntohl(unsigned long);\r\nunsigned short __stdcall ntohs(unsigned short);\r\nint __stdcall recv(SOCKET, char *, int, int);\r\nint __stdcall recvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);\r\nint __stdcall select(int nfds, fd_set *, fd_set *, fd_set *, const struct timeval *);\r\nint __stdcall send(SOCKET, const char *, int, int);\r\nint __stdcall sendto(SOCKET, const char *, int, int, const struct sockaddr *, int);\r\nint __stdcall setsockopt(SOCKET, int, int, const char *, int);\r\nint __stdcall shutdown(SOCKET, int);\r\nint __stdcall WSACleanup(void);\r\nint __stdcall WSAGetLastError(void);\r\nint __stdcall WSAStartup(WORD, LPWSADATA);\r\n\r\nSOCKET __stdcall socket(int, int, int);\r\n\r\n#endif\r\n\r\n";

static u64 cc_headers_h__mingw = (u64)"/*\r\n * _mingw.h\r\n *\r\n *  This file is for TinyCC and not part of the Mingw32 package.\r\n *\r\n *  THIS SOFTWARE IS NOT COPYRIGHTED\r\n *\r\n *  This source code is offered for use in the public domain. You may\r\n *  use, modify or distribute it freely.\r\n *\r\n *  This code is distributed in the hope that it will be useful but\r\n *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY\r\n *  DISCLAIMED. This includes but is not limited to warranties of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n *\r\n */\r\n\r\n#ifndef __MINGW_H\r\n#define __MINGW_H\r\n\r\n/* some winapi files define these before including _mingw.h --> */\r\n#undef __cdecl\r\n#undef _X86_\r\n#undef WIN32\r\n/* <-- */\r\n\r\n#include <stddef.h>\r\n#include <stdarg.h>\r\n\r\n#define __int8 char\r\n#define __int16 short\r\n#define __int32 int\r\n#define __int64 long long\r\n#define _HAVE_INT64\r\n\r\n#define __cdecl\r\n#define __declspec(x) __attribute__((x))\r\n#define __unaligned __attribute__((packed))\r\n#define __fastcall __attribute__((fastcall))\r\n\r\n#define __MSVCRT__ 1\r\n#undef _MSVCRT_\r\n#define __MINGW_IMPORT extern __declspec(dllimport)\r\n#define __MINGW_ATTRIB_NORETURN\r\n#define __MINGW_ATTRIB_CONST\r\n#define __MINGW_ATTRIB_DEPRECATED\r\n#define __MINGW_ATTRIB_MALLOC\r\n#define __MINGW_ATTRIB_PURE\r\n#define __MINGW_ATTRIB_NONNULL(arg)\r\n#define __MINGW_NOTHROW\r\n#define __GNUC_VA_LIST\r\n\r\n#define _CRTIMP extern\r\n#define __CRT_INLINE extern __inline__\r\n\r\n#define _CRT_ALIGN(x) __attribute__((aligned(x)))\r\n#define DECLSPEC_ALIGN(x) __attribute__((aligned(x)))\r\n#define _CRT_PACKING 8\r\n#define __CRT_UNALIGNED\r\n#define _CONST_RETURN\r\n\r\n#ifndef _TRUNCATE\r\n#define _TRUNCATE ((size_t)-1)\r\n#endif\r\n\r\n#define __CRT_STRINGIZE(_Value) #_Value\r\n#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)\r\n#define __CRT_WIDE(_String) L ## _String\r\n#define _CRT_WIDE(_String) __CRT_WIDE(_String)\r\n\r\n#ifdef _WIN64\r\n#define __stdcall\r\n#define _AMD64_ 1\r\n#define __x86_64 1\r\n#define _M_X64 100 /* Visual Studio */\r\n#define _M_AMD64 100 /* Visual Studio */\r\n#define USE_MINGW_SETJMP_TWO_ARGS\r\n#define mingw_getsp tinyc_getbp\r\n#define __TRY__\r\n#else\r\n#define __stdcall __attribute__((__stdcall__))\r\n#define _X86_ 1\r\n#define _M_IX86 300 /* Visual Studio */\r\n#define WIN32 1\r\n#define _USE_32BIT_TIME_T\r\n#ifdef __arm__\r\n#define __TRY__\r\n#else\r\n#define __TRY__ void __try__(void**), *_sehrec[6]; __try__(_sehrec);\r\n#endif\r\n#endif\r\n\r\n/* in stddef.h */\r\n#define _SIZE_T_DEFINED\r\n#define _SSIZE_T_DEFINED\r\n#define _PTRDIFF_T_DEFINED\r\n#define _WCHAR_T_DEFINED\r\n#define _UINTPTR_T_DEFINED\r\n#define _INTPTR_T_DEFINED\r\n#define _INTEGRAL_MAX_BITS 64\r\n\r\n#ifndef _TIME32_T_DEFINED\r\n#define _TIME32_T_DEFINED\r\ntypedef long __time32_t;\r\n#endif\r\n\r\n#ifndef _TIME64_T_DEFINED\r\n#define _TIME64_T_DEFINED\r\ntypedef long long __time64_t;\r\n#endif\r\n\r\n#ifndef _TIME_T_DEFINED\r\n#define _TIME_T_DEFINED\r\n#ifdef _USE_32BIT_TIME_T\r\ntypedef __time32_t time_t;\r\n#else\r\ntypedef __time64_t time_t;\r\n#endif\r\n#endif\r\n\r\n#ifndef _WCTYPE_T_DEFINED\r\n#define _WCTYPE_T_DEFINED\r\ntypedef wchar_t wctype_t;\r\n#endif\r\n\r\n#ifndef _WINT_T\r\n#define _WINT_T\r\ntypedef short wint_t;\r\n#endif\r\n\r\ntypedef int errno_t;\r\n#define _ERRCODE_DEFINED\r\n\r\ntypedef struct threadlocaleinfostruct *pthreadlocinfo;\r\ntypedef struct threadmbcinfostruct *pthreadmbcinfo;\r\ntypedef struct localeinfo_struct _locale_tstruct,*_locale_t;\r\n\r\n/* for winapi */\r\n#define _ANONYMOUS_UNION\r\n#define _ANONYMOUS_STRUCT\r\n#define DECLSPEC_NORETURN\r\n#define DECLARE_STDCALL_P(type) __stdcall type\r\n#define NOSERVICE 1\r\n#define NOMCX 1\r\n#define NOIME 1\r\n#define __INTRIN_H_\r\n#ifndef DUMMYUNIONNAME\r\n#  define DUMMYUNIONNAME\r\n#  define DUMMYUNIONNAME1\r\n#  define DUMMYUNIONNAME2\r\n#  define DUMMYUNIONNAME3\r\n#  define DUMMYUNIONNAME4\r\n#  define DUMMYUNIONNAME5\r\n#endif\r\n#ifndef DUMMYSTRUCTNAME\r\n#  define DUMMYSTRUCTNAME\r\n#endif\r\n#ifndef WINVER\r\n# define WINVER 0x0502\r\n#endif\r\n#ifndef _WIN32_WINNT\r\n# define _WIN32_WINNT 0x502\r\n#endif\r\n\r\n#define __C89_NAMELESS\r\n#define __MINGW_EXTENSION\r\n#define WINAPI_FAMILY_PARTITION(X) 1\r\n#define MINGW_HAS_SECURE_API\r\n\r\n#endif /* __MINGW_H */\r\n";

static u64 cc_headers_h_windowsx = (u64)"/* Header windowsx.h */\r\n\r\n#ifndef $windowsx\r\n#define $windowsx 1\r\n\r\n#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))\r\n#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))\r\n\r\n#endif // windowsx\r\n\r\n";

static struct $B6 cc_headers_stdhdrnames = {{
(u64)"assert.h",
(u64)"ctype.h",
(u64)"errno.h",
(u64)"fenv.h",
(u64)"float.h",
(u64)"inttypes.h",
(u64)"stdint.h",
(u64)"limits.h",
(u64)"locale.h",
(u64)"_ansi.h",
(u64)"math.h",
(u64)"setjmp.h",
(u64)"signal.h",
(u64)"stdarg.h",
(u64)"stdbool.h",
(u64)"stddef.h",
(u64)"stdio.h",
(u64)"stdlib.h",
(u64)"_syslist.h",
(u64)"string.h",
(u64)"time.h",
(u64)"utime.h",
(u64)"unistd.h",
(u64)"safelib.h",
(u64)"wchar.h",
(u64)"wctype.h",
(u64)"sys/types.h",
(u64)"sys/stat.h",
(u64)"sys/timeb.h",
(u64)"sys/utime.h",
(u64)"malloc.h",
(u64)"fcntl.h",
(u64)"io.h",
(u64)"direct.h",
(u64)"process.h",
(u64)"memory.h",
(u64)"conio.h",
(u64)"winsock2.h",
(u64)"_mingw.h",
(u64)"windowsx.h"}};

static struct $B6 cc_headers_stdhdrtext = {{
(u64)&cc_headers_h_assert,
(u64)&cc_headers_h_ctype,
(u64)&cc_headers_h_errno,
(u64)&cc_headers_h_fenv,
(u64)&cc_headers_h_float,
(u64)&cc_headers_h_inttypes,
(u64)&cc_headers_h_stdint,
(u64)&cc_headers_h_limits,
(u64)&cc_headers_h_locale,
(u64)&cc_headers_h__ansi,
(u64)&cc_headers_h_math,
(u64)&cc_headers_h_setjmp,
(u64)&cc_headers_h_signal,
(u64)&cc_headers_h_stdarg,
(u64)&cc_headers_h_stdbool,
(u64)&cc_headers_h_stddef,
(u64)&cc_headers_h_stdio,
(u64)&cc_headers_h_stdlib,
(u64)&cc_headers_h__syslist,
(u64)&cc_headers_h_string,
(u64)&cc_headers_h_time,
(u64)&cc_headers_h_utime,
(u64)&cc_headers_h_unistd,
(u64)&cc_headers_h_safelib,
(u64)&cc_headers_h_wchar,
(u64)&cc_headers_h_wctype,
(u64)&cc_headers_h_systypes,
(u64)&cc_headers_h_sysstat,
(u64)&cc_headers_h_systimeb,
(u64)&cc_headers_h_sysutime,
(u64)&cc_headers_h_malloc,
(u64)&cc_headers_h_fcntl,
(u64)&cc_headers_h_io,
(u64)&cc_headers_h_direct,
(u64)&cc_headers_h_process,
(u64)&cc_headers_h_memory,
(u64)&cc_headers_h_conio,
(u64)&cc_headers_h_winsock2,
(u64)&cc_headers_h__mingw,
(u64)&cc_headers_h_windowsx}};

static struct $B3 cc_showdummy_sbuffer;
static u64 cc_showdummy_dest = (u64)&cc_showdummy_sbuffer;

static i64 cc_showdummy_currlineno;
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl) {
    u64 R1, R2; 
	asi64(R1) = ncmd;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_ncmdparams = asi64(R1);
	asu64(R1) = cmds;
	msysc_cmdparams = asu64(R1);
	return;
}

static void msysc_pushio() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_niostack;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4;
	R1 = tou64("Too many io levels\n");
	asi32(R1) = printf(asu64(R1));
	R1 = 53;
	exit(R1);
L4:
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) += 1;
	asu64(R1) = msysc_outchan;
	R2 = (u64)&msysc_outchan_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_outdev;
	R2 = (u64)&msysc_outdev_stack;
	asi64(R3) = msysc_niostack;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = msysc_fmtstr;
	R2 = (u64)&msysc_fmtstr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_needgap;
	R2 = (u64)&msysc_needgap_stack;
	asi64(R3) = msysc_niostack;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 0;
	msysc_fmtstr = asu64(R1);
	R1 = 0;
	msysc_outchan = asu64(R1);
	return;
}

static void msysc_m$print_startfile(u64 dev) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = dev;
	msysc_outchan = asu64(R1);
	asu64(R1) = dev;
	if (!asu64(R1)) goto L7;
	R1 = 2;
	msysc_outdev = asi64(R1);
	goto L6;
L7:
	R1 = 1;
	msysc_outdev = asi64(R1);
L6:
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_startstr(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	msysc_pushio();
	asu64(R1) = s;
	R2 = (u64)&msysc_ptr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&msysc_ptr_stack;
	asi64(R2) = msysc_niostack;
	R1 += (i64)R2*8-8;
	p = asu64(R1);
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startptr(u64 p) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startcon() {
    u64 R1; 
	msysc_pushio();
	R1 = 1;
	msysc_outdev = asi64(R1);
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_setfmt(u64 format) {
    u64 R1; 
	asu64(R1) = format;
	msysc_fmtstr = asu64(R1);
	return;
}

static void msysc_m$print_end() {
    u64 R1, R2; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	asi64(R1) = msysc_niostack;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L14;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L15;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L14;
L15:
	msysc_dumpprintbuffer();
L14:
	asi64(R1) = msysc_niostack;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L17;
	goto L12;
L17:
	R1 = (u64)&msysc_outchan_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_outchan = asu64(R1);
	R1 = (u64)&msysc_outdev_stack;
	asi64(R2) = msysc_niostack;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	msysc_outdev = asi64(R1);
	R1 = (u64)&msysc_fmtstr_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_fmtstr = asu64(R1);
	R1 = (u64)&msysc_needgap_stack;
	asi64(R2) = msysc_niostack;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	msysc_needgap = asi64(R1);
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) -=1;
L12:
	return;
}

static void msysc_m$print_ptr(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L20;
	R1 = tou64("z8H");
	fmtstyle = asu64(R1);
L20:
	asu64(R1) = fmtstyle;
	asu64(R2) = a;
	msysc_m$print_u64(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_ptr_nf(u64 a) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_ptr(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_i64(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B69 s;
	struct $B3 fmt;
	i64 n;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L24;
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L26;
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	asi64(R4) = a;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	goto L25;
L26:
	asi64(R1) = a;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L27;
	(R1_B3) = msysc_defaultfmt;
	fmt = (R1_B3);
	goto L28;
	goto L25;
L27:
	R1 = 45;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = a;
	asi64(R4) = -asi64(R4);
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L25:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L23;
L24:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 86;
	if (asu64(R1) != asu64(R2)) goto L30;
	asi64(R1) = a;
	msysc_fmtparam = asi64(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L29;
L30:
// msysc.m$print_i64.dofmt:
L28:
	R1 = (u64)&fmt;
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
L29:
L23:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_i64_nf(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	return;
}

static void msysc_m$print_bool(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asi64(R1) = a;
	if (!asi64(R1)) goto L34;
	asu64(R1) = fmtstyle;
	R2 = tou64("True");
	msysc_m$print_str(asu64(R2), asu64(R1));
	goto L33;
L34:
	asu64(R1) = fmtstyle;
	R2 = tou64("False");
	msysc_m$print_str(asu64(R2), asu64(R1));
L33:
	return;
}

static void msysc_m$print_u64(u64 a, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B69 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L37;
	asu64(R1) = a;
	R2 = tou64("%llu");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L36;
L37:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
L36:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r64(r64 x, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B89 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L40;
	asr64(R1) = x;
	R2 = tou64("%f");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L39;
L40:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asr64(R2) = x;
	msysc_tostr_r64(asr64(R2), asu64(R1));
L39:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r32(r32 x, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	asr32(R2) = x;
    asr64(R2) = tor64(asr32(R2));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	return;
}

static void msysc_m$print_c8(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; 
	struct $B18 s;
	struct $B3 fmt;
	i64 n;
	u8 charmode;
	R1 = 0;
	charmode = asu8(R1);
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L44;
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	charmode = asu8(R1);
L44:
	asu8(R1) = charmode;
	R1 = toi64(tou8(R1));
	R2 = 77;
	if (asi64(R1) != asi64(R2)) goto L46;
	R1 = (u64)&fmt;
	R2 = (u64)&s;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L45;
L46:
	asi64(R1) = a;
	R2 = (u64)&s;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&s;
	asi64(R1) = msysc_getutfsize(asu64(R1));
	n = asi64(R1);
L45:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_str(u64 s, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L49;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L47;
L49:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L51;
	asu64(R1) = s;
	msysc_printstr(asu64(R1));
	goto L50;
L51:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L50:
	R1 = 1;
	msysc_needgap = asi64(R1);
L47:
	return;
}

static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L54;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L52;
L54:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L56;
	asi64(R1) = length;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L55;
L56:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asi64(R2) = length;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L55:
	R1 = 1;
	msysc_needgap = asi64(R1);
L52:
	return;
}

static void msysc_m$print_str_nf(u64 s) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle) {
    u64 R1; 
	R1 = tou64("PRTSL");
	mlib_abortprogram(asu64(R1));
	return;
}

static void msysc_m$print_newline() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	R1 = tou64("\r\n");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_m$print_nogap() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_space() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = tou64(" ");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_printstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_printstr_n(u64 s, i64 n) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_printstrn_app(u64 s, i64 length, u64 f) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L66;
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L68;
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L67;
L68:
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asu64(R4) = f;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L67:
L66:
	return;
}

static void msysc_printchar(i64 ch) {
    u64 R1, R2, R3; 
	u32 str;
	asi64(R1) = ch;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_nextfmtchars(i64 lastx) {
    u64 R1, R2; 
	u8 c;
	u64 pstart;
	i64 n;
	asu64(R1) = msysc_fmtstr;
	if (asu64(R1)) goto L72;
	asi64(R1) = msysc_needgap;
	if (!asi64(R1)) goto L74;
	R1 = 32;
	msysc_printchar(asi64(R1));
L74:
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L70;
L72:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L75:
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L78;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L79;
	R2 = 126;
	if (asu64(R1) == asu64(R2)) goto L80;
	goto L81;
L78:
	asi64(R1) = lastx;
	if (!asi64(R1)) goto L83;
	goto L84;
L83:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L86;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
L86:
	goto L70;
	goto L77;
L79:
	asi64(R1) = n;
	if (!asi64(R1)) goto L88;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L87;
L88:
	asi64(R1) = lastx;
	if (asi64(R1)) goto L89;
	R1 = 1;
	R2 = tou64("|");
	msysc_printstr_n(asu64(R2), asi64(R1));
L89:
L87:
	goto L70;
	goto L77;
L80:
	asi64(R1) = n;
	if (!asi64(R1)) goto L91;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 0;
	n = asi64(R1);
L91:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	if (!asu8(R1)) goto L93;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_printchar(asi64(R1));
L93:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	goto L77;
L81:
// msysc.nextfmtchars.skip:
L84:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
L77:
	goto L75;
L70:
	return;
}

static void msysc_strtofmt(u64 s, i64 slen, u64 fmt) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 c;
	i64 base;
	u8 wset;
	i64 n;
	struct $B5 str;
	(R1_B3) = msysc_defaultfmt;
	asu64(R2) = fmt;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L96;
	goto L94;
L96:
	asi64(R1) = slen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L98;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
L98:
	asi64(R1) = slen;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	s = asu64(R1);
	R1 = 0;
	wset = asu8(R1);
	goto L100;
L99:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L103;
	R1 = 65;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L103:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) != asi64(R2)) goto L104;
	R1 = 97;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L104:
	asi64(R1) = c;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 66: goto L108;
	case 67: goto L137;
	case 68: goto L136;
	case 69: goto L133;
	case 70: goto L134;
	case 71: goto L135;
	case 72: goto L109;
	case 73: case 75: case 76: case 82: case 87: goto L107;
	case 74: goto L119;
	case 77: goto L138;
	case 78: goto L141;
	case 79: goto L110;
	case 80: goto L126;
	case 81: goto L118;
	case 83: goto L123;
	case 84: goto L129;
	case 85: goto L132;
	case 86: goto L139;
	case 88: goto L111;
	case 89: goto L140;
	case 90: goto L122;
	default: goto L107;
    };
// SWITCH
L108:
	R1 = 2;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L109:
	R1 = 16;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L110:
	R1 = 8;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L111:
	R1 = 0;
	base = asi64(R1);
L112:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L115;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L115;
	asi64(R1) = base;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	base = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L114;
L115:
	goto L113;
L114:
	goto L112;
L113:
	asi64(R1) = base;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L117;
	R2 = 16;
	if (asi64(R1) > asi64(R2)) goto L117;
	asi64(R1) = base;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L117:
	goto L105;
L118:
	R1 = 34;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L119:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = fmt;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L121;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L121:
	goto L105;
L122:
	R1 = 48;
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L123:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L125;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L125:
	goto L105;
L126:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L128;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L128:
	goto L105;
L129:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L131;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L131:
	goto L105;
L132:
	R1 = 87;
	asu64(R2) = fmt;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L133:
	R1 = 101;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L134:
	R1 = 102;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L135:
	R1 = 103;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L136:
	R1 = 68;
	asu64(R2) = fmt;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L137:
	R1 = 67;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L138:
	R1 = 77;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L139:
	R1 = 86;
	asu64(R2) = fmt;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L140:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L141:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L107:
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L143;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L145;
	R2 = 126;
	if (asi64(R1) == asi64(R2)) goto L146;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L147;
	goto L148;
L143:
	R1 = 1;
	wset = asu8(R1);
	goto L142;
L144:
	asi64(R1) = c;
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L145:
	R1 = 43;
	asu64(R2) = fmt;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L146:
	R1 = 126;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L147:
	asi64(R1) = msysc_fmtparam;
	n = asi64(R1);
	goto L149;
	goto L142;
L148:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
L152:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L155;
	goto L153;
L155:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L157;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L157;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L156;
L157:
	goto L153;
L156:
	goto L152;
L153:
// msysc.strtofmt.gotwidth:
L149:
	asu8(R1) = wset;
	if (asu8(R1)) goto L159;
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	wset = asu8(R1);
	goto L158;
L159:
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 1;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
L158:
L151:
L142:
L105:
L102:
L100:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L99;
L94:
	return;
}

static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B17 str;
	u64 q;
	i64 nchars;
	i64 av_1;
	R1 = (u64)&str;
	q = asu64(R1);
	asi64(R1) = n;
	nchars = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L163;
L161:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L165;
	goto L163;
L165:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L161;
L163:
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = dest;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L160;
L160:
	return asi64(R1);
}

static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3; 
	i64 i;
	i64 w;
	i64 m;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 av_5;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L169;
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) > asi64(R2)) goto L168;
L169:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	goto L166;
L168:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 76;
	if (asu64(R1) != asu64(R2)) goto L171;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L174;
L172:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	i += 1; if (i <= av_1) goto L172;
L174:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	goto L170;
L171:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 82;
	if (asu64(R1) != asu64(R2)) goto L175;
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) != asu64(R2)) goto L177;
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L177;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L178;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L177;
L178:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L181;
L179:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_2)) goto L179;
L181:
	asi64(R1) = n;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = s;
	R3 = 1;
	R2 += (i64)R3;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L176;
L177:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L184;
L182:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_3)) goto L182;
L184:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L176:
	goto L170;
L175:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	m = asi64(R1);
	asi64(R1) = m;
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L187;
L185:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_4)) goto L185;
L187:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	asi64(R2) = m;
	asi64(R1) -= asi64(R2);
	av_5 = asi64(R1);
	asi64(R1) = av_5;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L190;
L188:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_5)) goto L188;
L190:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L170:
	asi64(R1) = w;
	goto L166;
L166:
	return asi64(R1);
}

static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B89 t;
	u64 dd;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	u64 s0;
	R1 = 0;
	i = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asu64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L193;
	R1 = 3;
	goto L192;
L193:
	R1 = 4;
L192:
	g = asi64(R1);
L194:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) %= asu64(R2);
	dd = asu64(R1);
	asu64(R1) = aa;
	asu64(R2) = base;
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	aa = asu64(R1);
	R1 = (u64)&msysc_digits;
	asu64(R2) = dd;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = sep;
	if (!asi64(R1)) goto L198;
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L198;
	asi64(R1) = k;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L198;
	asi64(R1) = sep;
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L198:
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L194;
	asi64(R1) = i;
	j = asi64(R1);
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L200;
L199:
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L200:
	asi64(R1) = i;
	if (asi64(R1)) goto L199;
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = j;
	goto L191;
L191:
	return asi64(R1);
}

static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B89 str;
	i64 n;
	i64 usigned;
	R1 = 0;
	usigned = asi64(R1);
	asu64(R1) = fmt;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L204;
	R1 = 1;
	usigned = asi64(R1);
L204:
	asi64(R1) = aa;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L206;
	asi64(R1) = usigned;
	if (asi64(R1)) goto L206;
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R1) = msysc_i64mintostr(asu64(R3), asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L205;
L206:
	asi64(R1) = usigned;
	if (asi64(R1)) goto L210;
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L209;
L210:
	asu64(R1) = fmt;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L208;
L209:
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L212;
	asi64(R1) = aa;
	asi64(R1) = -asi64(R1);
	aa = asi64(R1);
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L211;
L212:
	R1 = 43;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L211:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L207;
L208:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
L207:
L205:
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L214;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L214:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L217;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L216;
L217:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L216;
	R1 = (u64)&str;
	asu64(R1) = mlib_convlcstring(asu64(R1));
L216:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L202;
L202:
	return asi64(R1);
}

static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B89 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L220;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L220:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L223;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L222;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L222;
L223:
L222:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L218;
L218:
	return asi64(R1);
}

static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B89 t;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L226;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L227;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L228;
	goto L229;
L226:
	R1 = tou64("9223372036854775808");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 3;
	j = asi64(R1);
	goto L225;
L227:
	R1 = tou64("8000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1;
	j = asi64(R1);
	goto L225;
L228:
	R1 = tou64("1000000000000000000000000000000000000000000000000000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 7;
	j = asi64(R1);
	goto L225;
L229:
	R1 = tou64("<mindint>");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L225:
	R1 = (u64)&t;
	R2 = 0;
	R1 += (i64)R2;
	asi64(R1) = strlen(asu64(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L231;
	asi64(R1) = j;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L231:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L233;
	R1 = 3;
	goto L232;
L233:
	R1 = 4;
L232:
	g = asi64(R1);
	goto L235;
L234:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L238;
	asi64(R1) = i;
	if (!asi64(R1)) goto L238;
	R1 = (u64)&k;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L238;
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asi64(R1) = sep;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L238:
L235:
	asi64(R1) = i;
	if (asi64(R1)) goto L234;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	goto L224;
L224:
	return asi64(R1);
}

static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3, R4; 
	u64 u;
	u64 v;
	struct $B16 str;
	i64 w;
	i64 nheap;
	R1 = 0;
	nheap = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L242;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L241;
L242:
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L244;
	R1 = (u64)&str;
	u = asu64(R1);
	goto L243;
L244:
	asi64(R1) = n;
	R2 = 3;
	asi64(R1) += asi64(R2);
	nheap = asi64(R1);
	asi64(R1) = nheap;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	u = asu64(R1);
L243:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L246;
	asu64(R1) = u;
	v = asu64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L248;
	asu64(R1) = s;
	asu64(R2) = v;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&v;
	*tou64p(R2) += asu64(R1);
L248:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) += asi64(R1);
	goto L245;
L246:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L245:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) == asu64(R2)) goto L250;
	R2 = 65;
	if (asu64(R1) == asu64(R2)) goto L251;
	goto L252;
L250:
	asu64(R1) = u;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	goto L249;
L251:
	asu64(R1) = u;
	asu64(R1) = mlib_convucstring(asu64(R1));
	goto L249;
L252:
L249:
	asu64(R1) = u;
	s = asu64(R1);
L241:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) <= asi64(R2)) goto L254;
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	goto L253;
L254:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L253:
	asi64(R1) = nheap;
	if (!asi64(R1)) goto L256;
	asi64(R1) = nheap;
	asu64(R2) = u;
	mlib_pcm_free(asu64(R2), asi64(R1));
L256:
	asi64(R1) = n;
	goto L239;
L239:
	return asi64(R1);
}

static void msysc_tostr_i64(i64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B89 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L259;
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L260;
	goto L261;
L259:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R3) = a;
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L260:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L261:
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L257;
L258:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L257:
	return;
}

static void msysc_tostr_u64(u64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B89 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L264;
	R2 = 67;
	if (asu64(R1) == asu64(R2)) goto L265;
	goto L266;
L264:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L263;
L265:
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L262;
	goto L263;
L266:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = a;
	asi64(R1) = msysc_u64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L263:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L262:
	return;
}

static void msysc_tostr_r64(r64 x, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B89 str;
	struct $B89 str2;
	struct $B2 cfmt;
	i64 n;
	R1 = 37;
	R2 = (u64)&cfmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L269;
	R1 = 46;
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 42;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	asu64(R2) = fmt;
	R3 = 1;
	asi8(R2) = *toi8p(((i64)R2+(i64)R3));
	R2 = toi64(toi8(R2));
	R3 = (u64)&cfmt;
	R4 = (u64)&str;
	asi32(R1) = sprintf(asu64(R4), asu64(R3), asi64(R2), asr64(R1));
	goto L268;
L269:
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cfmt;
	R3 = (u64)&str;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
L268:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) >= asi64(R2)) goto L271;
	asu64(R1) = fmt;
	asi64(R2) = n;
	R3 = (u64)&str2;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L271:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 n;
	u64 t;
	asi64(R1) = oldlen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L274;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	oldlen = asi64(R1);
L274:
	asi64(R1) = oldlen;
	newlen = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) > asi64(R2)) goto L277;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L276;
L277:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L279;
	R1 = 2;
	R2 = (u64)&newlen;
	*toi64p(R2) += asi64(R1);
L279:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) <= asi64(R2)) goto L281;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newlen = asi64(R1);
L281:
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	t = asu64(R1);
	asu64(R1) = fmt;
	asi64(R2) = oldlen;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_strtostrfmt(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L283;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = (u64)&n;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
L283:
	asi64(R1) = n;
	asu64(R2) = t;
	msysc_printstr_n(asu64(R2), asi64(R1));
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = t;
	mlib_pcm_free(asu64(R2), asi64(R1));
	goto L275;
L276:
	asi64(R1) = oldlen;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
L275:
	return;
}

static u64 msysc_getfmt(u64 fmtstyle) {
    u64 R1, R2, R3; 
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L286;
	R1 = (u64)&msysc_getfmt_fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&msysc_getfmt_fmt;
	goto L285;
L286:
	R1 = (u64)&msysc_defaultfmt;
L285:
	goto L284;
L284:
	return asu64(R1);
}

static u64 msysc_strint(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strint_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strint_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L287;
L287:
	return asu64(R1);
}

static void msysc_getstrint(i64 a, u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = 0;
	asu64(R1) = msysc_getfmt(asu64(R1));
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	return;
}

static u64 msysc_strword(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strword_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strword_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L289;
L289:
	return asu64(R1);
}

static u64 msysc_strreal(r64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strreal_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asr64(R2) = a;
	msysc_tostr_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strreal_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L290;
L290:
	return asu64(R1);
}

static u64 msysc_getstr(u64 s, u64 fmt) {
    u64 R1, R2; 
	asu64(R1) = fmt;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L293;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	goto L292;
L293:
	asu64(R1) = s;
L292:
	goto L291;
L291:
	return asu64(R1);
}

static void msysc_initreadbuffer() {
    u64 R1, R2; 
	asu64(R1) = msysc_rd_buffer;
	if (!asu64(R1)) goto L296;
	goto L294;
L296:
	R1 = 16384;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	msysc_rd_buffer = asu64(R1);
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = msysc_rd_buffer;
	R2 = R1;
	msysc_rd_lastpos = asu64(R2);
	msysc_rd_pos = asu64(R1);
L294:
	return;
}

static void msysc_m$read_conline() {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	R3 = 0;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_m$read_fileline(u64 f) {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	asu64(R1) = f;
	R2 = 1;
	if (asu64(R1) != asu64(R2)) goto L300;
	R1 = tou64("READ CMDLINE");
	mlib_abortprogram(asu64(R1));
	goto L298;
L300:
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	asu64(R3) = f;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
L298:
	return;
}

static void msysc_m$read_strline(u64 s) {
    u64 R1, R2, R3; 
	i64 n;
	msysc_initreadbuffer();
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 16384;
	if (asi64(R1) >= asi64(R2)) goto L303;
	asu64(R1) = s;
	asu64(R2) = msysc_rd_buffer;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L302;
L303:
	R1 = 16383;
	asu64(R2) = s;
	asu64(R3) = msysc_rd_buffer;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	R3 = 16384;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
L302:
	asi64(R1) = n;
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static u64 msysc_readitem(u64 itemlength) {
    u64 R1, R2; 
	u64 p;
	u64 s;
	u64 itemstr;
	u8 quotechar;
	u8 c;
	asu64(R1) = msysc_rd_buffer;
	if (asu64(R1)) goto L306;
	msysc_initreadbuffer();
L306:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	goto L308;
L307:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L308:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L307;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L307;
	asu64(R1) = s;
	itemstr = asu64(R1);
	asu64(R1) = s;
	R2 = R1;
	msysc_rd_pos = asu64(R2);
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L311;
	R1 = 0;
	msysc_termchar = asi64(R1);
	R1 = 0;
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	goto L304;
L311:
	R1 = 0;
	quotechar = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) != asu64(R2)) goto L313;
	R1 = 34;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L312;
L313:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 39;
	if (asu64(R1) != asu64(R2)) goto L314;
	R1 = 39;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L314:
L312:
	asu64(R1) = s;
	R2 = R1;
	itemstr = asu64(R2);
	p = asu64(R1);
	goto L316;
L315:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L319;
	goto L320;
L319:
	asu8(R1) = quotechar;
	if (asu8(R1)) goto L323;
	asu64(R1) = p;
	asu64(R2) = s;
	if (asu64(R1) != asu64(R2)) goto L322;
L323:
	goto L324;
L322:
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	goto L317;
	goto L318;
L320:
// msysc.readitem.normalchar:
L324:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L326;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L328;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L327;
L328:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	asi64(R1) = msysc_termchar;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L331;
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L330;
L331:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
L330:
	goto L317;
L327:
	goto L325;
L326:
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L325:
L318:
L316:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L315;
L317:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L333;
	R1 = 0;
	msysc_termchar = asi64(R1);
L333:
	asu64(R1) = p;
	asu64(R2) = itemstr;
	asi64(R1) -= asi64(R2);
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = itemstr;
	goto L304;
L304:
	return asu64(R1);
}

static i64 msysc_strtoint(u64 s, i64 length, u64 base) {
    u64 R1, R2; 
	u8 signd;
	u64 aa;
	u64 c;
	u64 d;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L336;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L336:
	R1 = 0;
	signd = asu8(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L338;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L338;
	R1 = 1;
	signd = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	goto L337;
L338:
	asi64(R1) = length;
	if (!asi64(R1)) goto L339;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L339;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L339:
L337:
	R1 = 0;
	aa = asu64(R1);
	goto L341;
L340:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	c = asu64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L344;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L344;
	asu64(R1) = c;
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L344:
	asu64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L345;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L345;
	asu64(R1) = c;
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L345:
	asu64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L346;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L346;
	asu64(R1) = c;
	R2 = 48;
	asu64(R1) -= asu64(R2);
	d = asu64(R1);
	goto L343;
L346:
	asu64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L348;
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L347;
L348:
	goto L341;
	goto L343;
L347:
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L343:
	asu64(R1) = d;
	asu64(R2) = base;
	if (asu64(R1) < asu64(R2)) goto L350;
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L350:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) *= asu64(R2);
	asu64(R2) = d;
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
L341:
	asi64(R1) = length;
	if (asi64(R1)) goto L340;
L342:
	asu8(R1) = signd;
	if (!asu8(R1)) goto L352;
	asu64(R1) = aa;
	asu64(R1) = -asu64(R1);
	goto L351;
L352:
	asu64(R1) = aa;
L351:
	goto L334;
L334:
	return asi64(R1);
}

static i64 msysc_m$read_i64(i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	asi64(R1) = fmt;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	fmt = asi64(R1);
	asi64(R1) = fmt;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L355;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L356;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L357;
	goto L358;
L355:
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L360;
	R1 = (u64)&msysc_rd_pos;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L353;
	goto L359;
L360:
	R1 = 0;
	goto L353;
L359:
	goto L354;
L356:
	asi64(R1) = msysc_termchar;
	goto L353;
	goto L354;
L357:
	asi64(R1) = msysc_itemerror;
	goto L353;
	goto L354;
L358:
L354:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L363;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L364;
	goto L365;
L362:
	R1 = 10;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L363:
	R1 = 2;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L364:
	R1 = 16;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L365:
L361:
	R1 = 0;
	goto L353;
L353:
	return asi64(R1);
}

static r64 msysc_m$read_r64(i64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B31 str;
	u64 s;
	i64 length;
	i32 numlength;
	r64 x;
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L369;
	asi64(R1) = length;
	R2 = 512;
	if (asi64(R1) < asi64(R2)) goto L368;
L369:
	asr64(R1) = 0.000000000000000000e+000;
	goto L366;
L368:
	asi64(R1) = length;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	msysc_itemerror = asi64(R1);
	R1 = (u64)&numlength;
	R2 = (u64)&x;
	R3 = tou64("%lf%n");
	R4 = (u64)&str;
	asi32(R1) = sscanf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L372;
	asi32(R1) = numlength;
	R1 = toi64(toi32(R1));
	asi64(R2) = length;
	if (asi64(R1) == asi64(R2)) goto L371;
L372:
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L371:
	asr64(R1) = x;
	goto L366;
L366:
	return asr64(R1);
}

static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = fmt;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L376;
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L375;
L376:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	asu64(R1) = msysc_rd_buffer;
	asi64(R2) = msysc_rd_length;
	R1 += (i64)R2;
	asu64(R2) = msysc_rd_pos;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	goto L374;
L375:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L379;
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L378;
L379:
	asi64(R1) = length;
	asu64(R2) = s;
	mlib_iconvlcn(asu64(R2), asi64(R1));
L378:
L374:
	asi64(R1) = destlen;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L381;
	asi64(R1) = length;
	asi64(R2) = destlen;
	if (asi64(R1) < asi64(R2)) goto L383;
	asi64(R1) = destlen;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L383:
L381:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void msysc_readstr(u64 dest, i64 fmt, i64 destlen) {
    u64 R1, R2, R3; 
	asi64(R1) = fmt;
	asi64(R2) = destlen;
	asu64(R3) = dest;
	msysc_m$read_str(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_rereadln() {
    u64 R1; 
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_reread() {
    u64 R1; 
	asu64(R1) = msysc_rd_lastpos;
	msysc_rd_pos = asu64(R1);
	return;
}

static i64 msysc_valint(u64 s, i64 fmt) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	i64 aa;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asi64(R1) = fmt;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	aa = asi64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asi64(R1) = aa;
	goto L387;
L387:
	return asi64(R1);
}

static r64 msysc_valreal(u64 s) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	r64 x;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	asr64(R1) = msysc_m$read_r64(asi64(R1));
	x = asr64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asr64(R1) = x;
	goto L388;
L388:
	return asr64(R1);
}

static void msysc_mclunimpl(u64 mess) {
    u64 R1, R2; 
	asu64(R1) = mess;
	R2 = tou64("MCL-UNIMPL: %s\n");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = msysc_outdev;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L392;
	asu64(R1) = msysc_outchan;
	p = asu64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L394;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = p;
	asu64(R3) = *tou64p(R3);
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
L394:
	R1 = 0;
	asu64(R2) = p;
	asu64(R2) = *tou64p(R2);
	*tou8p(R2) = asu8(R1);
	goto L390;
L392:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L396;
	goto L390;
L396:
	asi64(R1) = fbuffer;
	if (!asi64(R1)) goto L398;
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L398;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L398;
	R1 = (u64)&msysc_printptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = msysc_printptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L400;
	asu64(R1) = msysc_printptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L402;
	R1 = 0;
	asu64(R2) = msysc_printptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L401;
L402:
	R1 = 0;
	asu64(R2) = msysc_printptr;
	*tou8p(R2) = asu8(R1);
L401:
	R1 = (u64)&msysc_printbuffer;
	asi32(R1) = puts(asu64(R1));
	goto L390;
L400:
L398:
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L404;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L405;
	goto L406;
L404:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L405:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asu64(R4) = msysc_outchan;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L406:
L403:
L390:
	return;
}

static void msysc_dumpprintbuffer() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	if (!asi64(R1)) goto L409;
	R1 = 1;
	asi64(R2) = msysc_printlen;
	R3 = (u64)&msysc_printbuffer;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L409:
	msysc_resetprintbuffer();
	return;
}

static void msysc_resetprintbuffer() {
    u64 R1; 
	R1 = (u64)&msysc_printbuffer;
	msysc_printptr = asu64(R1);
	R1 = 0;
	msysc_printlen = asi64(R1);
	return;
}

static void msysc_addtobuffer(u64 s, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	R2 = 4088;
	if (asi64(R1) < asi64(R2)) goto L413;
	msysc_dumpprintbuffer();
L413:
	asi64(R1) = n;
	R2 = 4096;
	if (asi64(R1) >= asi64(R2)) goto L415;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = msysc_printptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&msysc_printptr;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&msysc_printlen;
	*toi64p(R2) += asi64(R1);
	goto L411;
L415:
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L411:
	return;
}

static i64 msysc_getutfsize(u64 s) {
    u64 R1, R2, R3; 
	i64 a;
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L418;
	R1 = 0;
	goto L417;
L418:
	asi64(R1) = a;
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L419;
	R1 = 1;
	goto L417;
L419:
	asi64(R1) = a;
	R2 = 5;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L420;
	R1 = 2;
	goto L417;
L420:
	asi64(R1) = a;
	R2 = 4;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L421;
	R1 = 3;
	goto L417;
L421:
	asi64(R1) = a;
	R2 = 3;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 30;
	if (asi64(R1) != asi64(R2)) goto L422;
	R1 = 4;
	goto L417;
L422:
	R1 = 1;
L417:
	goto L416;
L416:
	return asi64(R1);
}

static i64 msysc_m$sign_i64(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L425;
	R1 = -1;
	goto L424;
L425:
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L427;
	R1 = 1;
	goto L426;
L427:
	R1 = 0;
L426:
L424:
	goto L423;
L423:
	return asi64(R1);
}

static r64 msysc_m$sign_r64(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) >= asr64(R2)) goto L430;
	asr64(R1) = -1.000000000000000000e+000;
	goto L428;
L430:
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) <= asr64(R2)) goto L432;
	asr64(R1) = 1.000000000000000000e+000;
	goto L428;
L432:
	asr64(R1) = 0.000000000000000000e+000;
	goto L428;
L428:
	return asr64(R1);
}

static u64 mlib_pcm_alloc(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asu8(R1) = mlib_pcm_setup;
	if (asu8(R1)) goto L435;
	mlib_pcm_init();
L435:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L437;
	asi64(R1) = n;
	asi64(R1) = mlib_pcm_getac(asi64(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L439;
	R1 = tou64("pcm_alloc failure");
	mlib_abortprogram(asu64(R1));
L439:
	asu64(R1) = p;
	goto L433;
L437:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L441;
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	asi64(R3) = mlib_alloccode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L433;
L441:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L443;
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L433;
L443:
	asu64(R1) = p;
	goto L433;
L433:
	return asu64(R1);
}

static void mlib_pcm_free(u64 p, i64 n) {
    u64 R1, R2, R3; 
	i64 acode;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L447;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L446;
L447:
	goto L444;
L446:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L449;
	asu64(R1) = p;
	free(asu64(R1));
	goto L448;
L449:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	acode = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = acode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	asi64(R3) = acode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L448:
L444:
	return;
}

static void mlib_pcm_freeac(u64 p, i64 alloc) {
    u64 R1, R2; 
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = alloc;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void mlib_pcm_clearmem(u64 p, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	return;
}

static void mlib_pcm_init() {
    u64 R1, R2, R3; 
	i64 j;
	i64 k;
	i64 size;
	i64 av_1;
	i64 i;
	R1 = 0;
	mlib_alloccode = asi64(R1);
	asu8(R1) = mlib_pcm_setup;
	if (!asu8(R1)) goto L454;
	goto L452;
L454:
	R1 = 0;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	R1 = 1;
	i = asi64(R1);
L455:
	R1 = 1;
	j = asi64(R1);
	R1 = 16;
	k = asi64(R1);
	goto L459;
L458:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	k = asi64(R1);
	R1 = (u64)&j;
	(*toi64p(R1)) += 1;
L459:
	asi64(R1) = i;
	asi64(R2) = k;
	if (asi64(R1) > asi64(R2)) goto L458;
	asi64(R1) = j;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= 2048) goto L455;
	R1 = 16;
	R2 = (u64)&mlib_allocupper;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 16;
	size = asi64(R1);
	R1 = 2;
	i = asi64(R1);
L461:
	R1 = 2;
	R2 = (u64)&size;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	R2 = 33554432;
	if (asi64(R1) < asi64(R2)) goto L465;
	asi64(R1) = i;
	k = asi64(R1);
	goto L463;
L465:
	i += 1; if (i <= 27) goto L461;
L463:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	R1 = 300;
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L468;
L466:
	R1 = 33554432;
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = size;
	R2 = 8589934592;
	if (asi64(R1) >= asi64(R2)) goto L470;
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	mlib_maxmemory = asu64(R1);
	goto L469;
L470:
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mlib_maxalloccode = asi64(R1);
	goto L468;
L469:
	i += 1; if (i <= av_1) goto L466;
L468:
	R1 = 1;
	mlib_pcm_setup = asu8(R1);
L452:
	return;
}

static i64 mlib_pcm_getac(i64 size) {
    u64 R1, R2; 
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L473;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L471;
L473:
	asi64(R1) = size;
	R2 = 255;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L475;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	asi64(R1) += asi64(R2);
	goto L471;
L475:
	asi64(R1) = size;
	R2 = 63;
	asi64(R1) += asi64(R2);
	R2 = 6;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L477;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	asi64(R1) += asi64(R2);
	goto L471;
L477:
	asi64(R1) = size;
	R2 = 2048;
	asi64(R1) -= asi64(R2);
	R2 = 2047;
	asi64(R1) += asi64(R2);
	R2 = 2048;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 22;
	asi64(R1) += asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	goto L471;
L471:
	return asi64(R1);
}

static u64 mlib_pcm_newblock(i64 itemsize) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 2097152;
	R2 = (u64)&mlib_pcm_newblock_totalheapsize;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	mlib_alloccode = asi64(R1);
	R1 = 2097152;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L480;
	R1 = tou64("Can't alloc pc heap");
	mlib_abortprogram(asu64(R1));
L480:
	R1 = 2097152;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	mlib_pcheapptr = asu64(R1);
	asu64(R1) = p;
	R2 = 2097152;
	R1 += (i64)R2;
	mlib_pcheapend = asu64(R1);
	asu64(R1) = mlib_pcheapstart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L482;
	asu64(R1) = p;
	mlib_pcheapstart = asu64(R1);
L482:
	asi64(R1) = itemsize;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = p;
	goto L478;
L478:
	return asu64(R1);
}

static i64 mlib_pcm_round(i64 n) {
    u64 R1, R2, R3; 
// PROC LOCAL STATICS GO HERE
	static struct $B13 mlib_pcm_round_allocbytes = {{
0,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048    }};
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L485;
	asi64(R1) = n;
	goto L484;
L485:
	R1 = (u64)&mlib_pcm_round_allocbytes;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
L484:
	goto L483;
L483:
	return asi64(R1);
}

static u64 mlib_pcm_allocz(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	goto L486;
L486:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstring(u64 s) {
    u64 R1, R2, R3; 
	u64 q;
	i64 n;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L489;
	R1 = 0;
	goto L487;
L489:
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L487;
L487:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstringn(u64 s, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L492;
	R1 = 0;
	goto L490;
L492:
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = q;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	goto L490;
L490:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapblock(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L495;
	R1 = 0;
	goto L493;
L495:
	asi64(R1) = length;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L493;
L493:
	return asu64(R1);
}

static u64 mlib_allocmem(i64 n) {
    u64 R1; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = malloc(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L498;
	asu64(R1) = p;
	goto L496;
L498:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mlib_memtotal;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Alloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L496;
L496:
	return asu64(R1);
}

static u64 mlib_reallocmem(u64 p, i64 n) {
    u64 R1, R2; 
	asi64(R1) = n;
	asu64(R2) = p;
	asu64(R1) = realloc(asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L501;
	asu64(R1) = p;
	goto L499;
L501:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Realloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L499;
L499:
	return asu64(R1);
}

static void mlib_abortprogram(u64 s) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("ABORTING: Press key...");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 5;
	exit(R1);
	return;
}

static i64 mlib_getfilesize(u64 handlex) {
    u64 R1, R2, R3; 
	u32 p;
	u32 size;
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	p = asu32(R1);
	R1 = 2;
	R2 = 0;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	size = asu32(R1);
	R1 = 0;
	asu32(R2) = p;
	R2 = toi64(tou32(R2));
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu32(R1) = size;
	R1 = toi64(tou32(R1));
	goto L503;
L503:
	return asi64(R1);
}

static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 a;
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fread(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	return;
}

static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L505;
L505:
	return asi64(R1);
}

static i64 mlib_setfilepos(u64 file, i64 offset) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = file;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	R1 = toi64(toi32(R1));
	goto L506;
L506:
	return asi64(R1);
}

static i64 mlib_getfilepos(u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = ftell(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L507;
L507:
	return asi64(R1);
}

static u64 mlib_readfile(u64 filename) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 size;
	u64 m;
	u64 p;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L510;
	R1 = 0;
	goto L508;
L510:
	asu64(R1) = f;
	asi64(R1) = mlib_getfilesize(asu64(R1));
	R2 = R1;
	size = asi64(R2);
	mlib_rfsize = asi64(R1);
	asi64(R1) = size;
	R2 = 2;
	asu64(R1) += asu64(R2);
	asu64(R1) = malloc(asu64(R1));
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L512;
	R1 = 0;
	goto L508;
L512:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = m;
	asu64(R4) = f;
	mlib_readrandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = m;
	asi64(R2) = size;
	R1 += (i64)R2;
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	*tou16p(R2) = asu16(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = m;
	goto L508;
L508:
	return asu64(R1);
}

static i64 mlib_writefile(u64 filename, u64 data, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 n;
	R1 = tou64("wb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L515;
	R1 = 0;
	goto L513;
L515:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = data;
	asu64(R4) = f;
	asi64(R1) = mlib_writerandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asi64(R1) = n;
	goto L513;
L513:
	return asi64(R1);
}

static i64 mlib_checkfile(u64 file) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("rb");
	asu64(R2) = file;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	R2 = R1;
	f = asu64(R2);
	if (!asu64(R1)) goto L518;
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	goto L516;
L518:
	R1 = 0;
	goto L516;
L516:
	return asi64(R1);
}

static void mlib_readlinen(u64 handlex, u64 buffer, i64 size) {
    u64 R1, R2, R3; 
	i64 ch;
	u64 p;
	i64 n;
	u8 crseen;
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L521;
	asu64(R1) = mwindows_os_getstdin();
	handlex = asu64(R1);
L521:
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L523;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = buffer;
	p = asu64(R1);
L524:
	asi32(R1) = getchar();
	R1 = toi64(toi32(R1));
	ch = asi64(R1);
	asi64(R1) = ch;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L527;
L528:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L527:
	asi64(R1) = ch;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = n;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L530;
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L530:
	goto L524;
L523:
	R1 = 0;
	asu64(R2) = buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R3) = buffer;
	asu64(R1) = fgets(asu64(R3), asi64(R2), asu64(R1));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L532;
	goto L519;
L532:
	asu64(R1) = buffer;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L534;
	goto L519;
L534:
	asu64(R1) = buffer;
	asi64(R2) = n;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	p = asu64(R1);
	R1 = 0;
	crseen = asu8(R1);
	goto L536;
L535:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L540;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L539;
L540:
	R1 = 1;
	crseen = asu8(R1);
L539:
	R1 = 0;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) -= 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L536:
	asu64(R1) = p;
	asu64(R2) = buffer;
	if (asu64(R1) < asu64(R2)) goto L541;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L535;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L535;
L541:
	asu8(R1) = crseen;
	if (asu8(R1)) goto L543;
	asi64(R1) = n;
	R2 = 4;
	asi64(R1) += asi64(R2);
	asi64(R2) = size;
	if (asi64(R1) <= asi64(R2)) goto L543;
	msysc_m$print_startcon();
	asi64(R1) = size;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("line too long");
	mlib_abortprogram(asu64(R1));
L543:
L519:
	return;
}

static void mlib_iconvlcn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L547;
L545:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L545;
L547:
	return;
}

static void mlib_iconvucn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L551;
L549:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L549;
L551:
	return;
}

static u64 mlib_convlcstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L554;
L553:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L554:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L553;
	asu64(R1) = s0;
	goto L552;
L552:
	return asu64(R1);
}

static u64 mlib_convucstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L558;
L557:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L558:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L557;
	asu64(R1) = s0;
	goto L556;
L556:
	return asu64(R1);
}

static u64 mlib_changeext(u64 s, u64 newext) {
    u64 R1, R2, R3; 
	struct $B18 newext2;
	u64 sext;
	i64 n;
	asu64(R1) = s;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L562;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L563;
	goto L564;
L562:
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L561;
L563:
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L561;
L564:
	R1 = tou64(".");
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L561:
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L566;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L567;
	goto L568;
L566:
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L567:
	R1 = (u64)&newext2;
	R2 = 1;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L568:
	asu64(R1) = sext;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 2;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asi64(R3) = n;
	R2 += (i64)R3+1;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L565:
	R1 = (u64)&mlib_changeext_newfile;
	R2 = 0;
	R1 += (i64)R2;
	goto L560;
L560:
	return asu64(R1);
}

static u64 mlib_extractext(u64 s, i64 period) {
    u64 R1, R2; 
	u64 t;
	u64 u;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L571;
	R1 = tou64("");
	goto L569;
L571:
	asu64(R1) = t;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	u = asu64(R1);
	goto L573;
L572:
	asu64(R1) = u;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L576;
	asu64(R1) = u;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L578;
	asi64(R1) = period;
	if (!asi64(R1)) goto L580;
	R1 = tou64(".");
	goto L579;
L580:
	R1 = tou64("");
L579:
	goto L569;
L578:
	asu64(R1) = u;
	R2 = 1;
	R1 += (i64)R2;
	goto L569;
L576:
	R1 = (u64)&u;
	(*tou64p(R1)) -=1;
L573:
	asu64(R1) = u;
	asu64(R2) = t;
	if (asu64(R1) >= asu64(R2)) goto L572;
	R1 = tou64("");
	goto L569;
L569:
	return asu64(R1);
}

static u64 mlib_extractpath(u64 s) {
    u64 R1, R2, R3; 
	u64 t;
	i64 n;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L583;
L582:
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 58;
	if (asu64(R1) == asu64(R2)) goto L586;
	goto L587;
L586:
	asu64(R1) = t;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	R3 = (u64)&mlib_extractpath_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractpath_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractpath_str;
	goto L581;
	goto L585;
L587:
L585:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L583:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) >= asu64(R2)) goto L582;
	R1 = tou64("");
	goto L581;
L581:
	return asu64(R1);
}

static u64 mlib_extractfile(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R1) = mlib_extractpath(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L590;
	asu64(R1) = s;
	goto L588;
L590:
	asu64(R1) = s;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	goto L588;
L588:
	return asu64(R1);
}

static u64 mlib_extractbasefile(u64 s) {
    u64 R1, R2, R3; 
	u64 f;
	u64 e;
	i64 n;
	i64 flen;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asi64(R1) = strlen(asu64(R1));
	flen = asi64(R1);
	asi64(R1) = flen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L593;
	R1 = tou64("");
	goto L591;
L593:
	R1 = 0;
	asu64(R2) = f;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L595;
	asi64(R1) = flen;
	asu64(R2) = e;
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L595:
	asu64(R1) = f;
	asi64(R2) = flen;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L597;
	asi64(R1) = flen;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = flen;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L597:
	asu64(R1) = f;
	goto L591;
L591:
	return asu64(R1);
}

static u64 mlib_addext(u64 s, u64 newext) {
    u64 R1, R2; 
	u64 sext;
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L600;
	asu64(R1) = newext;
	asu64(R2) = s;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	goto L598;
L600:
	asu64(R1) = s;
	goto L598;
L598:
	return asu64(R1);
}

static u64 mlib_pcm_alloc32() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 32;
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L603;
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L601;
L603:
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	goto L601;
L601:
	return asu64(R1);
}

static void mlib_pcm_free32(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	return;
}

static void mlib_outbyte(u64 f, i64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 1;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu16(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 2;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu32(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 4;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu64(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 8;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outstring(u64 f, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	R4 = 1;
	asu64(R3) += asu64(R4);
	asu64(R4) = s;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outblock(u64 f, u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asi64(R3) = n;
	asu64(R4) = p;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mlib_myeof(u64 f) {
    u64 R1, R2; 
	i64 c;
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L613;
	R1 = 1;
	goto L611;
L613:
	asu64(R1) = f;
	asi64(R2) = c;
	asi32(R1) = ungetc(asi32(R2), asu64(R1));
	R1 = 0;
	goto L611;
L611:
	return asi64(R1);
}

static void mlib_strbuffer_add(u64 dest, u64 s, i64 n) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 oldlen;
	u64 newptr;
	asi64(R1) = n;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L616;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
L616:
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	oldlen = asi64(R1);
	asi64(R1) = oldlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L618;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L614;
L618:
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = dest;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) <= asi64(R2)) goto L620;
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newptr = asu64(R1);
	asi64(R1) = oldlen;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = newptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = newptr;
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L620:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = newlen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newlen;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L614:
	return;
}

static void mlib_gs_init(u64 dest) {
    u64 R1, R2; 
	R1 = 16;
	asu64(R2) = dest;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_free(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L624;
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L624:
	return;
}

static void mlib_gs_str(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_char(u64 dest, i64 c) {
    u64 R1, R2, R3; 
	struct $B3 s;
	asi64(R1) = c;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strn(u64 dest, u64 s, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strvar(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strint(u64 dest, i64 a) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = 0;
	asi64(R3) = a;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strln(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mlib_gs_strsp(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_line(u64 dest) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = tou64("\n");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 mlib_gs_getcol(u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L633;
L633:
	return asi64(R1);
}

static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	i64 col;
	i64 i;
	i64 n;
	i64 slen;
	struct $B90 str;
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	col = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = slen;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L636;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L639;
L637:
	asi64(R1) = padch;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = i;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L637;
L639:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = n;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L636:
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = padch;
	asi64(R2) = w;
	R3 = 0;
	asi64(R4) = a;
	asu64(R3) = msysc_strint(asi64(R4), asu64(R3));
	asu64(R4) = dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mlib_gs_padto(u64 dest, i64 col, i64 ch) {
    u64 R1, R2, R3; 
	i64 n;
	struct $B90 str;
	i64 i;
	asi64(R1) = col;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L643;
	goto L641;
L643:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L646;
L644:
	asi64(R1) = ch;
	R2 = (u64)&str;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L644;
L646:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
L641:
	return;
}

static void mlib_gs_println(u64 dest, u64 f) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L649;
	goto L647;
L649:
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L651;
	msysc_m$print_startcon();
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\r");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L650;
L651:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\r");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L650:
L647:
	return;
}

static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext) {
    u64 R1, R2; 
	u64 q;
	u64 item;
	u64 fileext;
	i64 length;
// PROC LOCAL STATICS GO HERE
	static i64 mlib_nextcmdparamnew_infile = 0;
	static u64 mlib_nextcmdparamnew_filestart = 0;
	static u64 mlib_nextcmdparamnew_fileptr = 0;
	static u8 mlib_nextcmdparamnew_colonseen = 0;
// mlib.nextcmdparamnew.reenter:
L653:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = mlib_nextcmdparamnew_infile;
	if (!asi64(R1)) goto L655;
	R1 = (u64)&item;
	R2 = (u64)&mlib_nextcmdparamnew_fileptr;
	asi64(R1) = mlib_readnextfileitem(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L657;
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	free(asu64(R1));
	R1 = 0;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L657:
	goto L654;
L655:
	asu64(R1) = paramno;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = msysc_ncmdparams;
	if (asi64(R1) <= asi64(R2)) goto L659;
	R1 = 0;
	goto L652;
L659:
	asu64(R1) = msysc_cmdparams;
	asu64(R2) = paramno;
	asi64(R2) = *toi64p(R2);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	item = asu64(R1);
	asu64(R1) = paramno;
	(*toi64p(R1)) += 1;
	asu64(R1) = item;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 64;
	if (asu64(R1) != asu64(R2)) goto L661;
	asu64(R1) = item;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R1) = mlib_readfile(asu64(R1));
	R2 = R1;
	mlib_nextcmdparamnew_fileptr = asu64(R2);
	mlib_nextcmdparamnew_filestart = asu64(R1);
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L663;
	msysc_m$print_startcon();
	R1 = tou64("Can't open");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = item;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 7;
	exit(R1);
L663:
	R1 = 1;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L661:
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L665;
	R1 = 1;
	mlib_nextcmdparamnew_colonseen = asu8(R1);
	R1 = 4;
	goto L652;
L665:
L654:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L667;
	asu64(R1) = item;
	asu8(R2) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R2)) goto L669;
	R2 = 0;
	goto L668;
L669:
	R2 = 1;
L668:
	R1 += (i64)R2;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	R1 = 58;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (asu64(R1)) goto L671;
	R1 = 61;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
L671:
	asu64(R1) = q;
	if (!asu64(R1)) goto L673;
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
L673:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L675;
	R1 = 5;
	goto L674;
L675:
	R1 = 1;
L674:
	goto L652;
L667:
	R1 = 0;
	asu64(R2) = item;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	fileext = asu64(R1);
	asu64(R1) = item;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = fileext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L677;
	asu64(R1) = name;
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = defext;
	if (!asu64(R1)) goto L679;
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (asu8(R1)) goto L679;
	asu64(R1) = defext;
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
L679:
	goto L676;
L677:
	R1 = tou64("dll");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L681;
	R1 = tou64("mcx");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L680;
L681:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L683;
	R1 = 5;
	goto L682;
L683:
	R1 = 3;
L682:
	goto L652;
L680:
L676:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L685;
	R1 = 5;
	goto L684;
L685:
	R1 = 2;
L684:
	goto L652;
L652:
	return asi64(R1);
}

static i64 mlib_readnextfileitem(u64 fileptr, u64 item) {
    u64 R1, R2, R3; 
	u64 p;
	u64 pstart;
	u64 pend;
	i64 n;
	asu64(R1) = fileptr;
	asu64(R1) = *tou64p(R1);
	p = asu64(R1);
// mlib.readnextfileitem.reenter:
L687:
L688:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L692;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L692;
	goto L693;
L691:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L690;
L692:
	R1 = 0;
	goto L686;
	goto L690;
L693:
	goto L689;
L690:
	goto L688;
L689:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 33;
	if (asu64(R1) == asu64(R2)) goto L695;
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L695;
	goto L696;
L695:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L697:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L699;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L700;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L700;
	goto L701;
L699:
	goto L687;
	goto L697;
L700:
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	goto L686;
	goto L697;
L701:
	goto L697;
	goto L694;
L696:
L694:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L703;
	goto L704;
L703:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 1;
	pstart = asu64(R1);
L705:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L709;
	goto L710;
L708:
	msysc_m$print_startcon();
	R1 = tou64("Unexpected EOF in @file");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 8;
	exit(R1);
	goto L707;
L709:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 44;
	if (asu64(R1) != asu64(R2)) goto L712;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L712:
	goto L706;
	goto L707;
L710:
L707:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L705;
L706:
	goto L702;
L704:
	asu64(R1) = p;
	pstart = asu64(R1);
L713:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L717;
	goto L718;
L716:
	asu64(R1) = p;
	pend = asu64(R1);
	goto L714;
	goto L715;
L717:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	goto L714;
	goto L715;
L718:
L715:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L713;
L714:
L702:
	asu64(R1) = pend;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) < asi64(R2)) goto L720;
	msysc_m$print_startcon();
	R1 = tou64("@file item too long");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 9;
	exit(R1);
L720:
	asi64(R1) = n;
	asu64(R2) = pstart;
	R3 = (u64)&mlib_readnextfileitem_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_readnextfileitem_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_readnextfileitem_str;
	asu64(R2) = item;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 1;
	goto L686;
L686:
	return asi64(R1);
}

static void mlib_ipadstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2; 
	i64 n;
	i64 av_1;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = width;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L724;
L722:
	asu64(R1) = padchar;
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L722;
L724:
	return;
}

static u64 mlib_padstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = (u64)&mlib_padstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = padchar;
	asi64(R2) = width;
	R3 = (u64)&mlib_padstr_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mlib_padstr_str;
	goto L725;
L725:
	return asu64(R1);
}

static u64 mlib_chr(i64 c) {
    u64 R1, R2, R3; 
	asi64(R1) = c;
	R2 = (u64)&mlib_chr_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mlib_chr_str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_chr_str;
	goto L726;
L726:
	return asu64(R1);
}

static i64 mlib_cmpstring(u64 s, u64 t) {
    u64 R1, R2; 
	i64 res;
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L729;
	R1 = -1;
	goto L728;
L729:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L730;
	R1 = 1;
	goto L728;
L730:
	R1 = 0;
L728:
	goto L727;
L727:
	return asi64(R1);
}

static i64 mlib_cmpstringn(u64 s, u64 t, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = s;
	asi32(R1) = strncmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L733;
	R1 = -1;
	goto L732;
L733:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L734;
	R1 = 1;
	goto L732;
L734:
	R1 = 0;
L732:
	goto L731;
L731:
	return asi64(R1);
}

static i64 mlib_eqstring(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L735;
L735:
	return asi64(R1);
}

static i64 mlib_cmpbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L738;
	R1 = -1;
	goto L737;
L738:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L739;
	R1 = 1;
	goto L737;
L739:
	R1 = 0;
L737:
	goto L736;
L736:
	return asi64(R1);
}

static i64 mlib_eqbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L740;
L740:
	return asi64(R1);
}

static void mlib_mseed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L743;
	asu64(R1) = b;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L742;
L743:
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	R2 += (i64)R3*8-8;
	*toi64p(R2) ^= asi64(R1);
L742:
	return;
}

static u64 mlib_mrandom() {
    u64 R1, R2, R3; 
	i64 x;
	i64 y;
	R1 = (u64)&mlib_seed;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	x = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	y = asi64(R1);
	asi64(R1) = y;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = x;
	R2 = 23;
	asi64(R1) <<= asi64(R2);
	R2 = (u64)&x;
	*toi64p(R2) ^= asi64(R1);
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) ^= asi64(R2);
	asi64(R2) = x;
	R3 = 17;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	asi64(R2) = y;
	R3 = 26;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = y;
	asu64(R1) += asu64(R2);
	goto L744;
L744:
	return asu64(R1);
}

static i64 mlib_mrandomp() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandom();
	R2 = 9223372036854775807;
	asi64(R1) &= asi64(R2);
	goto L745;
L745:
	return asi64(R1);
}

static i64 mlib_mrandomint(i64 n) {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = n;
	asi64(R1) %= asi64(R2);
	goto L746;
L746:
	return asi64(R1);
}

static i64 mlib_mrandomrange(i64 a, i64 b) {
    u64 R1, R2; 
	i64 span;
	asi64(R1) = b;
	asi64(R2) = a;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	span = asi64(R1);
	asi64(R1) = span;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L749;
	R1 = 0;
	goto L747;
L749:
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = span;
	asi64(R1) %= asi64(R2);
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	goto L747;
L747:
	return asi64(R1);
}

static r64 mlib_mrandomreal() {
    u64 R1, R2; 
	r64 x;
L751:
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	x = asr64(R1);
	asr64(R1) = x;
	asr64(R2) = 1.000000000000000000e+000;
	if (asr64(R1) == asr64(R2)) goto L751;
	asr64(R1) = x;
	goto L750;
L750:
	return asr64(R1);
}

static r64 mlib_mrandomreal1() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	goto L754;
L754:
	return asr64(R1);
}

static u64 mlib_readline() {
    u64 R1; 
	msysc_m$read_conline();
	asu64(R1) = msysc_rd_buffer;
	goto L755;
L755:
	return asu64(R1);
}

static u64 mlib_findfunction(u64 name) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = $nprocs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L759;
L757:
	asu64(R1) = name;
	R2 = (u64)&$procname;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L761;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L756;
L761:
	i += 1; if (i <= av_1) goto L757;
L759:
	R1 = 0;
	goto L756;
L756:
	return asu64(R1);
}

static i64 mlib_roundtoblock(i64 n, i64 align) {
    u64 R1, R2, R3, R4, R5; 
	asi64(R1) = n;
	asi64(R2) = align;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L764;
	asi64(R1) = n;
	goto L762;
L764:
	asi64(R1) = n;
	asi64(R2) = align;
	asi64(R3) = n;
	asi64(R4) = align;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L762;
L762:
	return asi64(R1);
}

static u64 mlib_pcm_allocnfz(i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = n;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L767;
	asi64(R1) = n;
	R2 = 8;
	asi64(R3) = n;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L767:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L769;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
L769:
	asu64(R1) = p;
	goto L765;
L765:
	return asu64(R1);
}

static void mwindows_os_init() {
    u64 R1, R2, R3; 
	R1 = -11;
	asi64(R1) = toi64(tou32(R1));
	asu64(R1) = GetStdHandle(asu32(R1));
	mwindows_hconsole = asu64(R1);
	R1 = -10;
	asi64(R1) = toi64(tou32(R1));
	asu64(R1) = GetStdHandle(asu32(R1));
	mwindows_hconsolein = asu64(R1);
	R1 = 0;
	R2 = (u64)&mwindows_lastkey;
	R3 = 8;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 0;
	mwindows_keypending = asi64(R1);
	R1 = 1;
	R2 = 0;
	asi64(R1) = SetConsoleCtrlHandler(asu64(R2), asi64(R1));
	R1 = 3;
	asu64(R2) = mwindows_hconsole;
	asi64(R1) = SetConsoleMode(asu64(R2), asu32(R1));
	R1 = 1;
	mwindows_init_flag = asi64(R1);
	return;
}

static i64 mwindows_os_execwait(u64 cmdline, i64 newconsole, u64 workdir) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10; 
	u32 exitcode;
	i64 status;
	i64 cflags;
	struct $B85 si;
	struct $B8 xpi;
	R1 = 0;
	cflags = asi64(R1);
	R1 = 104;
	status = asi64(R1);
	R1 = 24;
	status = asi64(R1);
	R1 = 123456;
	status = asi64(R1);
	R1 = 1193046;
	status = asi64(R1);
	R1 = (u64)&si;
	memset(R1, 0, 104);
	R1 = (u64)&xpi;
	memset(R1, 0, 24);
	asi64(R1) = newconsole;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L773;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L774;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L775;
	goto L776;
L773:
	R1 = 32;
	cflags = asi64(R1);
	goto L772;
L774:
	R1 = 48;
	cflags = asi64(R1);
	goto L772;
L775:
	R1 = 48;
	cflags = asi64(R1);
	goto L772;
L776:
L772:
	R1 = 104;
	R2 = (u64)&si;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&xpi;
	R2 = (u64)&si;
	R3 = 0;
	R4 = 0;
	asi64(R5) = cflags;
	R6 = 1;
	R7 = 0;
	R8 = 0;
	asu64(R9) = cmdline;
	R10 = 0;
	asi64(R1) = CreateProcessA(asu64(R10), asu64(R9), asu64(R8), asu64(R7), asi64(R6), asu32(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	status = asi64(R1);
	asi64(R1) = status;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L778;
	asu32(R1) = GetLastError();
	R1 = toi64(tou32(R1));
	status = asi64(R1);
	asi64(R1) = status;
	R2 = tou64("Winexec error: %lld\n");
	asi32(R1) = printf(asu64(R2), asi64(R1));
	R1 = -1;
	goto L771;
L778:
	R1 = 4294967295;
	R2 = (u64)&xpi;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu32(R1) = WaitForSingleObject(asu64(R2), asu32(R1));
	R1 = (u64)&exitcode;
	R2 = (u64)&xpi;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = GetExitCodeProcess(asu64(R2), asu64(R1));
	R1 = (u64)&xpi;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	R1 = (u64)&xpi;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	asu32(R1) = exitcode;
	R1 = toi64(tou32(R1));
	goto L771;
L771:
	return asi64(R1);
}

static i64 mwindows_os_execcmd(u64 cmdline, i64 newconsole) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10; 
	struct $B85 si;
	struct $B8 xpi;
	R1 = (u64)&si;
	memset(R1, 0, 104);
	R1 = (u64)&xpi;
	memset(R1, 0, 24);
	R1 = 104;
	R2 = (u64)&si;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&xpi;
	R2 = (u64)&si;
	R3 = 0;
	R4 = 0;
	R5 = 32;
	asi64(R6) = newconsole;
	if (!asi64(R6)) goto L781;
	R6 = 16;
	goto L780;
L781:
	R6 = 0;
L780:
	asi64(R5) |= asi64(R6);
	R6 = 1;
	R7 = 0;
	R8 = 0;
	asu64(R9) = cmdline;
	R10 = 0;
	asi64(R1) = CreateProcessA(asu64(R10), asu64(R9), asu64(R8), asu64(R7), asi64(R6), asu32(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&xpi;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	R1 = (u64)&xpi;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	R1 = 1;
	goto L779;
L779:
	return asi64(R1);
}

static i64 mwindows_os_getch() {
    u64 R1, R2; 
	i64 k;
	asi64(R1) = mwindows_os_getchx();
	R2 = 255;
	asi64(R1) &= asi64(R2);
	k = asi64(R1);
	asi64(R1) = k;
	goto L782;
L782:
	return asi64(R1);
}

static i64 mwindows_os_kbhit() {
    u64 R1, R2; 
	u32 count;
	asi64(R1) = mwindows_init_flag;
	if (asi64(R1)) goto L785;
	mwindows_os_init();
L785:
	R1 = (u64)&count;
	asu64(R2) = mwindows_hconsolein;
	asi64(R1) = GetNumberOfConsoleInputEvents(asu64(R2), asu64(R1));
	asu32(R1) = count;
	R1 = toi64(tou32(R1));
	R2 = 1;
	asi64(R1) = asi64(R1)  >  asi64(R2);
	goto L783;
L783:
	return asi64(R1);
}

static u64 mwindows_os_getdllinst(u64 name) {
    u64 R1; 
	u64 hinst;
	asu64(R1) = name;
	asu64(R1) = LoadLibraryA(asu64(R1));
	hinst = asu64(R1);
	asu64(R1) = hinst;
	goto L786;
L786:
	return asu64(R1);
}

static u64 mwindows_os_getdllprocaddr(i64 hinst, u64 name) {
    u64 R1, R2; 
	asu64(R1) = name;
	asi64(R2) = hinst;
	asu64(R1) = GetProcAddress(asu64(R2), asu64(R1));
	goto L787;
L787:
	return asu64(R1);
}

static void mwindows_os_initwindows() {
    u64 R1; 
	mwindows_os_init();
	R1 = tou64("pcc001");
	mwindows_os_gxregisterclass(asu64(R1));
	return;
}

static void mwindows_os_gxregisterclass(u64 classname) {
    u64 R1, R2, R3; 
	struct $B1 r;
	asu8(R1) = mwindows_os_gxregisterclass_registered;
	if (!asu8(R1)) goto L791;
	goto L789;
L791:
	R1 = (u64)&r;
	memset(R1, 0, 80);
	R1 = 80;
	R2 = (u64)&r;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 40;
	R2 = (u64)&r;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mwindows_mainwndproc;
	R2 = (u64)&r;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 32512;
	R2 = 0;
	asu64(R1) = LoadCursorA(asu64(R2), asu64(R1));
	R2 = (u64)&r;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 16;
	R2 = (u64)&r;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = classname;
	R2 = (u64)&r;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&r;
	asu32(R1) = RegisterClassExA(asu64(R1));
	R1 = toi64(tou32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L793;
	asu32(R1) = GetLastError();
	R1 = toi64(tou32(R1));
	asu64(R2) = classname;
	R3 = tou64("Regclass error: %lld %lld\n");
	asi32(R1) = printf(asu64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	exit(R1);
L793:
	R1 = 1;
	mwindows_os_gxregisterclass_registered = asu8(R1);
L789:
	return;
}

static i64 mwindows_mainwndproc(u64 hwnd, u32 message, u64 wparam, u64 lparam) {
    u64 R1, R2, R3, R4; 
	struct $B12 m;
	i64 result;
// PROC LOCAL STATICS GO HERE
	static i64 mwindows_mainwndproc_count = 0;
	asu64(R1) = hwnd;
	R2 = (u64)&m;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu32(R1) = message;
	R2 = (u64)&m;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = wparam;
	R2 = (u64)&m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = lparam;
	R2 = (u64)&m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&m;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = (u64)&m;
	R3 = 44;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = mwindows_wndproc_callbackfn;
	if (!asu64(R1)) goto L796;
	R1 = (u64)&m;
	asu64(R2) = mwindows_wndproc_callbackfn;
	asi64(R1) = ((F1)R2)(asu64(R1));
	result = asi64(R1);
	goto L795;
L796:
	R1 = 0;
	result = asi64(R1);
L795:
	R1 = (u64)&m;
	R2 = 8;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L798;
	R1 = 0;
	goto L794;
L798:
	asi64(R1) = result;
	if (asi64(R1)) goto L800;
	asu64(R1) = lparam;
	asu64(R2) = wparam;
	asu32(R3) = message;
	R3 = toi64(tou32(R3));
	asu64(R4) = hwnd;
	asi64(R1) = DefWindowProcA(asu64(R4), asu32(R3), asu64(R2), asu64(R1));
	goto L799;
L800:
	R1 = 0;
L799:
	goto L794;
L794:
	return asi64(R1);
}

static void mwindows_os_setmesshandler(u64 addr) {
    u64 R1; 
	asu64(R1) = addr;
	mwindows_wndproc_callbackfn = asu64(R1);
	return;
}

static i64 mwindows_os_getchx() {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	i64 count;
	i64 charcode;
	i64 keyshift;
	i64 keycode;
	i64 altdown;
	i64 ctrldown;
	i64 shiftdown;
	i64 capslock;
	asi64(R1) = mwindows_init_flag;
	if (asi64(R1)) goto L804;
	mwindows_os_init();
L804:
	asi64(R1) = mwindows_keypending;
	if (!asi64(R1)) goto L806;
	(R1_B17) = mwindows_pendkey;
	mwindows_lastkey = (R1_B17);
	R1 = 0;
	mwindows_keypending = asi64(R1);
	goto L805;
L806:
	R1 = (u64)&mwindows_lastkey;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L808;
L809:
	R1 = 0;
	count = asi64(R1);
	R1 = (u64)&count;
	R2 = 1;
	R3 = (u64)&mwindows_lastkey;
	asu64(R4) = mwindows_hconsolein;
	asi64(R1) = ReadConsoleInputA(asu64(R4), asu64(R3), asu32(R2), asu64(R1));
	R1 = (u64)&mwindows_lastkey;
	R2 = 0;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L809;
	R1 = (u64)&mwindows_lastkey;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L809;
L808:
L805:
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 3;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L813;
	R1 = 1;
	goto L812;
L813:
	R1 = 0;
L812:
	altdown = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 12;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L815;
	R1 = 1;
	goto L814;
L815:
	R1 = 0;
L814:
	ctrldown = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L817;
	R1 = 1;
	goto L816;
L817:
	R1 = 0;
L816:
	shiftdown = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 128;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L819;
	R1 = 1;
	goto L818;
L819:
	R1 = 0;
L818:
	capslock = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 8;
	R1 += (i64)R2;
	(*tou16p(R1)) -=1;
	R1 = (u64)&mwindows_lastkey;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	charcode = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 10;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 255;
	asi64(R1) &= asi64(R2);
	keycode = asi64(R1);
	asi64(R1) = charcode;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L821;
	asi64(R1) = charcode;
	R2 = -128;
	if (asi64(R1) >= asi64(R2)) goto L823;
	R1 = 0;
	charcode = asi64(R1);
	goto L822;
L823:
	R1 = 256;
	R2 = (u64)&charcode;
	*toi64p(R2) += asi64(R1);
L822:
L821:
	asi64(R1) = altdown;
	if (!asi64(R1)) goto L825;
	asi64(R1) = ctrldown;
	if (!asi64(R1)) goto L825;
	asi64(R1) = charcode;
	R2 = 166;
	if (asi64(R1) != asi64(R2)) goto L825;
	R1 = 0;
	R2 = R1;
	ctrldown = asi64(R2);
	altdown = asi64(R1);
	goto L824;
L825:
	asi64(R1) = altdown;
	if (asi64(R1)) goto L828;
	asi64(R1) = ctrldown;
	if (!asi64(R1)) goto L827;
L828:
	R1 = 0;
	charcode = asi64(R1);
	asi64(R1) = keycode;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L830;
	asi64(R1) = keycode;
	R2 = 90;
	if (asi64(R1) > asi64(R2)) goto L830;
	asi64(R1) = keycode;
	R2 = 64;
	asi64(R1) -= asi64(R2);
	charcode = asi64(R1);
L830:
L827:
L824:
	asi64(R1) = capslock;
	R2 = 3;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = altdown;
	R3 = 2;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asi64(R2) = ctrldown;
	R3 = 1;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asi64(R2) = shiftdown;
	asi64(R1) |= asi64(R2);
	keyshift = asi64(R1);
	asi64(R1) = keyshift;
	R2 = 24;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = keycode;
	R3 = 16;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asi64(R2) = charcode;
	asi64(R1) |= asi64(R2);
	goto L802;
L802:
	return asi64(R1);
}

static u64 mwindows_os_getos() {
    u64 R1; 
	R1 = tou64("W64");
	goto L831;
L831:
	return asu64(R1);
}

static i64 mwindows_os_gethostsize() {
    u64 R1; 
	R1 = 64;
	goto L832;
L832:
	return asi64(R1);
}

static i64 mwindows_os_shellexec(u64 opc, u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = system(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L833;
L833:
	return asi64(R1);
}

static void mwindows_os_sleep(i64 a) {
    u64 R1; 
	asi64(R1) = a;
	Sleep(asu32(R1));
	return;
}

static u64 mwindows_os_getstdin() {
    u64 R1, R2; 
	R1 = tou64("rb");
	R2 = tou64("con");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	goto L835;
L835:
	return asu64(R1);
}

static u64 mwindows_os_getstdout() {
    u64 R1, R2; 
	R1 = tou64("wb");
	R2 = tou64("con");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	goto L836;
L836:
	return asu64(R1);
}

static u64 mwindows_os_gethostname() {
    u64 R1, R2, R3; 
	R1 = 300;
	R2 = (u64)&mwindows_os_gethostname_name;
	R3 = 0;
	asu32(R1) = GetModuleFileNameA(asu64(R3), asu64(R2), asu32(R1));
	R1 = (u64)&mwindows_os_gethostname_name;
	goto L837;
L837:
	return asu64(R1);
}

static u64 mwindows_os_getmpath() {
    u64 R1; 
	R1 = tou64("C:@@@@\\m\\\"");
	goto L838;
L838:
	return asu64(R1);
}

static i64 mwindows_os_clock() {
    u64 R1; 
	asi64(R1) = mwindows_os_hpcounter();
	goto L839;
L839:
	return asi64(R1);
}

static i64 mwindows_os_ticks() {
    u64 R1; 
	asi64(R1) = GetTickCount64();
	goto L840;
L840:
	return asi64(R1);
}

static i64 mwindows_os_iswindows() {
    u64 R1; 
	R1 = 1;
	goto L841;
L841:
	return asi64(R1);
}

static void mwindows_os_getsystime(u64 tm) {
    u64 R1; 
	asu64(R1) = tm;
	GetLocalTime(asu64(R1));
	return;
}

static void mwindows_os_peek() {
    u64 R1, R2, R3, R4, R5; 
	i64 ticks;
	struct $B5 m;
	asi64(R1) = GetTickCount64();
	ticks = asi64(R1);
	asi64(R1) = ticks;
	asi64(R2) = mwindows_os_peek_lastticks;
	asi64(R1) -= asi64(R2);
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L845;
	asi64(R1) = ticks;
	mwindows_os_peek_lastticks = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = (u64)&m;
	asu32(R1) = PeekMessageA(asu64(R5), asu64(R4), asu32(R3), asu32(R2), asu32(R1));
L845:
	return;
}

static u64 mwindows_os_allocexecmem(i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u32 oldprot;
	i64 status;
	R1 = 1;
	R2 = 12288;
	asi64(R3) = n;
	R4 = 0;
	asu64(R1) = VirtualAlloc(asu64(R4), asu32(R3), asu32(R2), asu32(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L848;
	R1 = 0;
	goto L846;
L848:
	R1 = (u64)&oldprot;
	R2 = 64;
	asi64(R3) = n;
	asu64(R4) = p;
	asu32(R1) = VirtualProtect(asu64(R4), asu32(R3), asu32(R2), asu64(R1));
	R1 = toi64(tou32(R1));
	status = asi64(R1);
	asi64(R1) = status;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L850;
	R1 = 0;
	goto L846;
L850:
	asu64(R1) = p;
	goto L846;
L846:
	return asu64(R1);
}

static i64 mwindows_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t) {
    u64 R1, R2, R3; 
	u64 hfind;
	struct $B91 file;
	i64 nfiles;
	struct $B15 path;
	struct $B15 fullfilename;
	R1 = 0;
	nfiles = asi64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&path;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&file;
	asu64(R2) = filespec;
	asu64(R1) = FindFirstFileA(asu64(R2), asu64(R1));
	R2 = R1;
	hfind = asu64(R2);
	R2 = -1;
	if (asu64(R1) == asu64(R2)) goto L853;
L854:
	R1 = (u64)&file;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L858;
	asi64(R1) = t;
	R2 = 2;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L860;
	goto L855;
L860:
	goto L857;
L858:
	asi64(R1) = t;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L862;
	goto L855;
L862:
L857:
	asi64(R1) = nfiles;
	asi64(R2) = capacity;
	if (asi64(R1) < asi64(R2)) goto L864;
	R1 = -1;
	nfiles = asi64(R1);
	goto L856;
L864:
	asi64(R1) = t;
	R2 = 4;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L866;
	R1 = (u64)&file;
	R2 = 44;
	R1 += (i64)R2;
	asu64(R1) = mlib_convlcstring(asu64(R1));
L866:
	R1 = (u64)&path;
	R2 = (u64)&fullfilename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&file;
	R2 = 44;
	R1 += (i64)R2;
	R2 = (u64)&fullfilename;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&fullfilename;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = dest;
	R3 = (u64)&nfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L855:
	R1 = (u64)&file;
	asu64(R2) = hfind;
	asu32(R1) = FindNextFileA(asu64(R2), asu64(R1));
	if (asu32(R1)) goto L854;
L856:
	asu64(R1) = hfind;
	asu32(R1) = FindClose(asu64(R1));
L853:
	asi64(R1) = nfiles;
	goto L851;
L851:
	return asi64(R1);
}

static i64 mwindows_os_hpcounter() {
    u64 R1, R2; 
	i64 a;
	asi64(R1) = mwindows_hpfreq;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L869;
	asi64(R1) = mwindows_os_hpfreq();
	R2 = 1000;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	mwindows_hpfreq = asi64(R1);
L869:
	R1 = (u64)&a;
	asu32(R1) = QueryPerformanceCounter(asu64(R1));
	asi64(R1) = a;
	asi64(R2) = mwindows_hpfreq;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	goto L867;
L867:
	return asi64(R1);
}

static i64 mwindows_os_hpfreq() {
    u64 R1; 
	i64 a;
	R1 = (u64)&a;
	asu32(R1) = QueryPerformanceFrequency(asu64(R1));
	asi64(R1) = a;
	goto L870;
L870:
	return asi64(R1);
}

static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes) {
    u64 R1, R2, R3; 
	u64 a;
	r64 x;
	i64 oddstack;
	i64 nextra;
	i64 pushedbytes;
	asi64(R1) = retcode;
	R2 = 73;
	if (asi64(R1) != asi64(R2)) goto L873;
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_cint(asu64(R3), asu64(R2), asi64(R1));
	goto L872;
L873:
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_creal(asu64(R3), asu64(R2), asi64(R1));
L872:
	goto L871;
L871:
	return asu64(R1);
}

static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat) {
    u64 R1, R2, R3, R4, R5; 
	u64 a;
	r64 x;
	R1 = 0;
	asu64(R2) = args;
	asi64(R3) = nargs;
	asi64(R4) = isfloat;
	if (!asi64(R4)) goto L876;
	R4 = 0;
	goto L875;
L876:
	R4 = 73;
L875:
	asu64(R5) = fnaddr;
	asu64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	goto L874;
L874:
	return asu64(R1);
}

static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13; 
	asi64(R1) = nparams;
	switch (asi64(R1)) {
	case 0: goto L881;
	case 1: goto L882;
	case 2: goto L883;
	case 3: goto L884;
	case 4: goto L885;
	case 5: goto L886;
	case 6: goto L887;
	case 7: goto L880;
	case 8: goto L888;
	case 9: goto L889;
	case 10: goto L890;
	case 11: goto L891;
	case 12: goto L892;
	default: goto L880;
    };
// SWITCH
L881:
	asu64(R1) = fnaddr;
	asi64(R1) = ((F2)R1)();
	goto L877;
	goto L878;
L882:
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asi64(R1) = ((F3)R2)(asi64(R1));
	goto L877;
	goto L878;
L883:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asi64(R1) = ((F4)R3)(asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L884:
	asu64(R1) = params;
	R2 = 3;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 2;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 1;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = fnaddr;
	asi64(R1) = ((F5)R4)(asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L885:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = fnaddr;
	asi64(R1) = ((F6)R5)(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L886:
	asu64(R1) = params;
	R2 = 5;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 4;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 3;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 2;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 1;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = fnaddr;
	asi64(R1) = ((F7)R6)(asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L887:
	asu64(R1) = params;
	R2 = 6;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 5;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 4;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 3;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 2;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 1;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = fnaddr;
	asi64(R1) = ((F8)R7)(asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L888:
	asu64(R1) = params;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 7;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 6;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 5;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 4;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 3;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 2;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 1;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = fnaddr;
	asi64(R1) = ((F9)R9)(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L889:
	asu64(R1) = params;
	R2 = 9;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 7;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 6;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 5;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 4;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 3;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 2;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 1;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = fnaddr;
	asi64(R1) = ((F10)R10)(asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L890:
	asu64(R1) = params;
	R2 = 10;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 9;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 7;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 6;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 5;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 4;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 3;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 2;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 1;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = fnaddr;
	asi64(R1) = ((F11)R11)(asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L891:
	asu64(R1) = params;
	R2 = 11;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 10;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 9;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 8;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 7;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 6;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 5;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 4;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 3;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 2;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 1;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = fnaddr;
	asi64(R1) = ((F12)R12)(asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L892:
	asu64(R1) = params;
	R2 = 12;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 11;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 10;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 9;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 8;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 7;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 6;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 5;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 4;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 3;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 2;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = params;
	R13 = 1;
	asi64(R12) = *toi64p(((i64)R12+(i64)R13*8-8));
	asu64(R13) = fnaddr;
	asi64(R1) = ((F13)R13)(asi64(R12), asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L880:
	msysc_m$print_startcon();
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/int unsupported # of params");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L878:
	R1 = 0;
	goto L877;
L877:
	return asi64(R1);
}

static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5; 
	r64 x;
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L895;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L896;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L897;
	goto L898;
L895:
	asu64(R1) = fnaddr;
	asr64(R1) = ((F14)R1)();
	R1 = toi64(asr64(R1));
	goto L893;
	goto L894;
L896:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asr64(R2) = tor64(asi64(R2));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asr64(R3) = tor64(asi64(R3));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asr64(R4) = tor64(asi64(R4));
	mwindllc_os_dummycall(asr64(R4), asr64(R3), asr64(R2), asr64(R1));
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asr64(R1) = ((F15)R2)(asi64(R1));
	x = asr64(R1);
	goto L894;
L897:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asr64(R1) = ((F16)R3)(asi64(R2), asi64(R1));
	x = asr64(R1);
	goto L894;
L898:
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/real too many params");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L894:
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	goto L893;
L893:
	return asi64(R1);
}

static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d) {
	return;
}

static u64 pc_api_pcl_start(u64 name, i64 nunits) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_pcldone;
	if (!asu8(R1)) goto L902;
	R1 = tou64("PCL start?");
	pc_api_pclerror(asu64(R1));
L902:
	asu64(R1) = name;
	if (!asu64(R1)) goto L904;
	R1 = 9;
	asu64(R2) = name;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	pc_decls_currprog = asu64(R1);
L904:
	asi64(R1) = pc_api_initpcalloc;
	pc_api_pcalloc = asi64(R1);
	asi64(R1) = nunits;
	if (!asi64(R1)) goto L906;
	asi64(R1) = nunits;
	R2 = 9;
	asi64(R1) *= asi64(R2);
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nunits = asi64(R1);
	goto L908;
L907:
	R1 = 2;
	R2 = (u64)&pc_api_pcalloc;
	*toi64p(R2) *= asi64(R1);
L908:
	asi64(R1) = pc_api_pcalloc;
	asi64(R2) = nunits;
	if (asi64(R1) < asi64(R2)) goto L907;
L906:
	asi64(R1) = pc_api_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pc_api_pcstart = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	asi64(R2) = pc_api_pcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	pc_api_pcend = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	pc_api_pccurr = asu64(R1);
	R1 = 0;
	pc_api_pcfixed = asu8(R1);
	R1 = 0;
	pc_api_pcseqno = asi64(R1);
	R1 = 0;
	pc_api_pcneedfntable = asi64(R1);
	R1 = 0;
	pc_api_mlabelno = asi64(R1);
	asu64(R1) = pc_decls_currprog;
	goto L900;
L900:
	return asu64(R1);
}

static void pc_api_pcl_end() {
    u64 R1, R2; 
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) < asu64(R2)) goto L912;
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) == asi64(R2)) goto L912;
	R1 = 0;
	R2 = 136;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L912:
	R1 = 1;
	pc_decls_pcldone = asu8(R1);
	return;
}

static u64 pc_api_pcl_writepcl(u64 filename) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_diags_dummy_writeallpcl();
	d = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L915;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L917;
	msysc_m$print_startcon();
	R1 = tou64("Writing PCL");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L917:
	asu64(R1) = d;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = tou64("");
	goto L914;
L915:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L914:
	goto L913;
L913:
	return asu64(R1);
}

static u64 pc_api_pcl_writepst(u64 filename) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_diags_dummy_writepst();
	d = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L920;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L922;
	msysc_m$print_startcon();
	R1 = tou64("Writing PST");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L922:
	asu64(R1) = d;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = tou64("");
	goto L919;
L920:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L919:
	goto L918;
L918:
	return asu64(R1);
}

static void pc_api_pcl_genmcl() {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	return;
}

static void pc_api_pcl_genss(i64 obj) {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asi64(R1) = obj;
	mc_genss_genss(asi64(R1));
	return;
}

static u64 pc_api_pcl_writess(u64 filename, i64 obj) {
    u64 R1, R2; 
	u64 ssstr;
	u64 f;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asi64(R1) = obj;
	mc_genss_genss(asi64(R1));
	asi64(R1) = obj;
	asi64(R1) = !asi64(R1);
	asu64(R1) = mc_writess_dummy_writessdata(asi64(R1));
	ssstr = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L927;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = ssstr;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = ssstr;
	mlib_gs_free(asu64(R1));
	R1 = 0;
	goto L926;
L927:
	asu64(R1) = ssstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L926:
	goto L925;
L925:
	return asu64(R1);
}

static u64 pc_api_pcl_writeasm(u64 filename, i64 atype) {
    u64 R1, R2; 
	u64 asmstr;
	u64 f;
	asi64(R1) = pc_decls_assemtype;
	R2 = 1297301838;
	if (asi64(R1) != asi64(R2)) goto L930;
	R1 = 2;
	pc_api_phighmem = asu8(R1);
L930:
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	asu64(R1) = mc_writenasm_getassemstr();
	asmstr = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L932;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L934;
	msysc_m$print_startcon();
	R1 = tou64("Writing");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L934:
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = asmstr;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = asmstr;
	mlib_gs_free(asu64(R1));
	R1 = 0;
	goto L931;
L932:
	asu64(R1) = asmstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L931:
	goto L928;
L928:
	return asu64(R1);
}

static void pc_api_pcl_writeobj(u64 filename) {
    u64 R1, R2; 
	i64 tt;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 1;
	mc_genss_genss(asi64(R1));
	R1 = 0;
	pc_api_phighmem = asu8(R1);
	msysc_m$print_startcon();
	R1 = tou64("PHIGHMEM=");
	msysc_m$print_str_nf(asu64(R1));
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mwindows_os_clock();
	tt = asi64(R1);
	asu64(R1) = filename;
	mc_writeobj_writecoff(asu64(R1));
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_objtime = asi64(R1);
	return;
}

static void pc_api_pcl_writedll(u64 filename) {
    u64 R1, R2, R3; 
	i64 tt;
	R1 = 2;
	pc_api_phighmem = asu8(R1);
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asi64(R1) = mwindows_os_clock();
	tt = asi64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = filename;
	mc_writeexe_writeexe(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_exetime = asi64(R1);
	return;
}

static void pc_api_pcl_writeexe(u64 filename) {
    u64 R1, R2, R3; 
	i64 tt;
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asi64(R1) = mwindows_os_clock();
	tt = asi64(R1);
	R1 = 0;
	R2 = 0;
	asu64(R3) = filename;
	mc_writeexe_writeexe(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_exetime = asi64(R1);
	return;
}

static void pc_api_pcl_writemx(u64 filename) {
    u64 R1; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asu64(R1) = filename;
	mx_write_writemcx(asu64(R1));
	return;
}

static void pc_api_pcl_exec() {
    u64 R1, R2; 
	R1 = 0;
	mc_genmcl_genmcl(asu64(R1));
	R1 = 0;
	mc_genss_genss(asi64(R1));
	asi64(R1) = pc_decls_pcmdskip;
	R2 = tou64("dummy");
	mx_run_runlibfile(asu64(R2), asi64(R1));
	return;
}

static void pc_api_pcl_setflags(i64 highmem, i64 verbose, i64 shortnames) {
    u64 R1, R2; 
	asi64(R1) = highmem;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L942;
	asi64(R1) = highmem;
	pc_api_phighmem = asu8(R1);
L942:
	asi64(R1) = verbose;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L944;
	asi64(R1) = verbose;
	pc_decls_pverbose = asu8(R1);
L944:
	asi64(R1) = shortnames;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L946;
	asi64(R1) = shortnames;
	pc_api_fpshortnames = asu8(R1);
L946:
	return;
}

static void pc_api_extendpclblock() {
    u64 R1, R2, R3; 
	i64 newpcalloc;
	i64 lengthused;
	u64 newpcstart;
	asi64(R1) = pc_api_pcalloc;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newpcalloc = asi64(R1);
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcstart;
	asi64(R1) -= asi64(R2);
    asi64(R1) /= 32;
	R2 = 1;
	asi64(R1) += asi64(R2);
	lengthused = asi64(R1);
	R1 = 32;
	asi64(R2) = newpcalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newpcstart = asu64(R1);
	asi64(R1) = lengthused;
	R2 = 32;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pc_api_pcstart;
	asu64(R3) = newpcstart;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = newpcalloc;
	asi64(R2) = lengthused;
	asi64(R1) -= asi64(R2);
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = newpcstart;
	asi64(R3) = lengthused;
	R2 += (i64)R3*32;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	asu64(R2) = pc_api_pccurr;
	asu64(R3) = pc_api_pcstart;
	asi64(R2) -= asi64(R3);
    asi64(R2) /= 32;
	R1 += (i64)R2*32;
	pc_api_pccurr = asu64(R1);
	asu64(R1) = newpcstart;
	asi64(R2) = newpcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	pc_api_pcend = asu64(R1);
	asi64(R1) = pc_api_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc_api_pcstart;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	pc_api_pcstart = asu64(R1);
	asi64(R1) = newpcalloc;
	pc_api_pcalloc = asi64(R1);
	return;
}

static u64 pc_api_newpcl() {
    u64 R1, R2, R3, R4; 
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcend;
	if (asu64(R1) < asu64(R2)) goto L950;
	pc_api_extendpclblock();
L950:
	R1 = (u64)&pc_api_pccurr;
	(*tou64p(R1)) += 32;
	asi64(R1) = pc_decls_mmpos;
	asu64(R2) = pc_api_pccurr;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pc_api_pclseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_decls_npcl;
	(*toi64p(R1)) += 1;
	asu64(R1) = pc_api_pccurr;
	goto L948;
L948:
	return asu64(R1);
}

static void pc_api_pc_gen(i64 opcode, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L953;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L953:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void pc_api_pc_genix(i64 opcode, i64 scale, i64 offset) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_genx(i64 opcode, i64 x, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L957;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L957:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_genxy(i64 opcode, i64 x, i64 y, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L960;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L960:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = y;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_gencond(i64 opcode, i64 cond, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L963;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L963:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cond;
	asu64(R2) = p;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 pc_api_genint(i64 a) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = a;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L964;
L964:
	return asu64(R1);
}

static u64 pc_api_genreal(r64 x, i64 mode) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asr64(R1) = x;
	asu64(R2) = p;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L967;
	R1 = 5;
	goto L966;
L967:
	R1 = 6;
L966:
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L965;
L965:
	return asu64(R1);
}

static u64 pc_api_genrealimm(r64 x, i64 mode) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asr64(R1) = x;
	asu64(R2) = p;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L970;
	R1 = 10;
	goto L969;
L970:
	R1 = 11;
L969:
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L968;
L968:
	return asu64(R1);
}

static u64 pc_api_genstring(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 7;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L971;
L971:
	return asu64(R1);
}

static u64 pc_api_genpcstrimm(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L972;
L972:
	return asu64(R1);
}

static u64 pc_api_genlabel(i64 a) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = a;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L973;
L973:
	return asu64(R1);
}

static u64 pc_api_genmem(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L974;
L974:
	return asu64(R1);
}

static u64 pc_api_genmemaddr(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L975;
L975:
	return asu64(R1);
}

static u64 pc_api_gendata(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 12;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	asu64(R2) = p;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L976;
L976:
	return asu64(R1);
}

static void pc_api_gencomment(u64 s) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_fregoptim;
	if (asu8(R1)) goto L980;
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L979;
L980:
	goto L977;
L979:
	asu64(R1) = s;
	asu64(R1) = pc_api_genpcstrimm(asu64(R1));
	R2 = 135;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L977:
	return;
}

static u64 pc_api_genname(u64 s) {
    u64 R1, R2; 
	R1 = 8;
	asu64(R2) = s;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L981;
L981:
	return asu64(R1);
}

static u64 pc_api_gennameaddr(u64 s) {
    u64 R1, R2; 
	R1 = 8;
	asu64(R2) = s;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	goto L982;
L982:
	return asu64(R1);
}

static u64 pc_api_genassem(u64 code) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = code;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 9;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L983;
L983:
	return asu64(R1);
}

static u64 pc_api_strpmode(i64 mode, i64 size) {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L986;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L987;
	goto L988;
L986:
	R1 = tou64("mem:");
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = size;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_strpmode_str;
	goto L985;
L987:
	R1 = tou64("---");
	goto L985;
L988:
	R1 = (u64)&pc_tables_pstdnames;
	asi64(R2) = mode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
L985:
	goto L984;
L984:
	return asu64(R1);
}

static void pc_api_pc_setmode(i64 m, i64 size) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = m;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L991;
	asi64(R1) = size;
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L990;
L991:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L990:
	R1 = (u64)&pc_tables_pclhastype;
	asu64(R2) = pc_api_pccurr;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L993;
	asu64(R1) = pc_api_pccurr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L993:
	return;
}

static void pc_api_pc_setmode2(i64 m) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = m;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	return;
}

static void pc_api_pc_setxy(i64 x, i64 y) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = y;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setscaleoff(i64 scale, i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = scale;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setoffset(i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_addoffset(i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	return;
}

static void pc_api_pc_setincr(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setnargs(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setnvariadics(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setalign(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_perror(u64 mess) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = mess;
	pc_api_perror_s(asu64(R2), asu64(R1));
	return;
}

static void pc_api_perror_s(u64 mess, u64 param) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PCL error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = param;
	if (!asu64(R1)) goto L1006;
	msysc_m$print_startcon();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L1006:
	R1 = 1;
	exit(R1);
	return;
}

static u64 pc_api_getbasename(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L1009;
L1008:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L1009:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) <= asu64(R2)) goto L1011;
	asu64(R1) = t;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L1008;
L1011:
	asu64(R1) = t;
	goto L1007;
L1007:
	return asu64(R1);
}

static void pc_api_pclerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PCL Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void pc_api_pc_addsymbol(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = pc_decls_psymboltable;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1015;
	asu64(R1) = d;
	R2 = R1;
	pc_decls_psymboltablex = asu64(R2);
	pc_decls_psymboltable = asu64(R1);
	goto L1014;
L1015:
	asu64(R1) = d;
	asu64(R2) = pc_decls_psymboltablex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	pc_decls_psymboltablex = asu64(R1);
L1014:
	return;
}

static u64 pc_api_pc_makesymbol(u64 s, i64 id) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc_api_stseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = id;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1018;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1019;
	goto L1020;
L1018:
	R1 = 1;
	asu64(R2) = d;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1017;
L1019:
	R1 = 1;
	asu64(R2) = d;
	R3 = 81;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 2;
	id = asi64(R1);
	goto L1017;
L1020:
L1017:
	asi64(R1) = id;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = id;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1023;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1022;
L1023:
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1021;
L1022:
	asi64(R1) = id;
	if (!asi64(R1)) goto L1024;
	asu64(R1) = d;
	pc_api_pc_addsymbol(asu64(R1));
L1024:
L1021:
	asu64(R1) = d;
	goto L1016;
L1016:
	return asu64(R1);
}

static u64 pc_api_getfullname(u64 d, i64 backtick) {
    u64 R1, R2, R3; 
	i64 n;
	u64 e;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = d;
	e = asu64(R1);
	R1 = 0;
	R2 = (u64)&pc_api_getfullname_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L1027;
	R1 = tou64("`");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L1027:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1029;
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L1031;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("*");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1030;
L1031:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1030:
	R1 = (u64)&pc_api_getfullname_str;
	goto L1025;
L1029:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1034;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1033;
L1034:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_getfullname_str;
	goto L1025;
L1033:
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L1036;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1035;
L1036:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L1035:
	goto L1025;
L1025:
	return asu64(R1);
}

static void pc_api_pcerrorstop(u64 filename, i64 lineno) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void pc_api_pc_addplib(u64 name) {
    u64 R1, R2, R3; 
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L1040;
	R1 = tou64("Too many libs");
	pc_api_perror(asu64(R1));
L1040:
	R1 = tou64("");
	asu64(R2) = name;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&pc_decls_plibfiles;
	R3 = (u64)&pc_decls_nplibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static void pc_api_pc_defproc(u64 d, i64 mode, i64 isentry, i64 threaded) {
    u64 R1, R2, R3; 
	asu64(R1) = pc_decls_currfunc;
	if (!asu64(R1)) goto L1043;
	R1 = tou64("Nested proc");
	pc_api_pclerror(asu64(R1));
L1043:
	asu64(R1) = d;
	asu64(R1) = pc_api_genmem(asu64(R1));
	asi64(R2) = threaded;
	if (!asi64(R2)) goto L1045;
	R2 = 121;
	goto L1044;
L1045:
	R2 = 120;
L1044:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1047;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
L1047:
	R1 = 0;
	asi64(R2) = mode;
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1049;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Dupl proc:");
	asu64(R1) = pc_api_addstr(asu64(R2), asu64(R1));
	pc_api_pclerror(asu64(R1));
L1049:
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_entryproc;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1051;
	asi64(R1) = isentry;
	if (!asi64(R1)) goto L1051;
	asu64(R1) = d;
	pc_decls_entryproc = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 83;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1051:
	asu64(R1) = d;
	pc_decls_currfunc = asu64(R1);
	return;
}

static void pc_api_pc_setimport(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	pc_decls_currfunc = asu64(R1);
	return;
}

static void pc_api_pc_addparam(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = pc_decls_currfunc;
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L1055;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1055:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1057;
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1056;
L1057:
	goto L1059;
L1058:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L1059:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1058;
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1056:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1062;
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1062:
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	return;
}

static void pc_api_pc_addlocal(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = pc_decls_currfunc;
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L1065;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1065:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1067;
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1066;
L1067:
	goto L1069;
L1068:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L1069:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1068;
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1066:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1072;
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1072:
	asu64(R1) = pc_decls_currfunc;
	R2 = 114;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	return;
}

static void pc_api_pc_endproc() {
    u64 R1, R2; 
	asu64(R1) = pc_decls_currfunc;
	if (asu64(R1)) goto L1075;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1075:
	R1 = 0;
	R2 = 122;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	pc_decls_currfunc = asu64(R1);
	return;
}

static u64 pc_api_addstr(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = s;
	R2 = (u64)&pc_api_addstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = t;
	R2 = (u64)&pc_api_addstr_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_addstr_str;
	goto L1076;
L1076:
	return asu64(R1);
}

static void pc_api_merror(u64 mess, u64 param) {
    u64 R1, R2, R3, R4; 
	i64 lineno;
	u64 filename;
	u64 sourceline;
	asu64(R1) = pc_decls_igetmsourceinfo;
	if (!asu64(R1)) goto L1079;
	R1 = (u64)&sourceline;
	R2 = (u64)&filename;
	asi64(R3) = pc_decls_mmpos;
	asu64(R4) = pc_decls_igetmsourceinfo;
	asi64(R1) = ((F17)R4)(asi64(R3), asu64(R2), asu64(R1));
	lineno = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("LINENO=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("FILENAME=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L1078;
L1079:
	R1 = 0;
	lineno = asi64(R1);
	R1 = tou64("?");
	filename = asu64(R1);
L1078:
	asu64(R1) = pc_decls_currfunc;
	if (!asu64(R1)) goto L1081;
	msysc_m$print_startcon();
	R1 = tou64("Proc:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1081:
	msysc_m$print_startcon();
	R1 = tou64("MCL Error: # (#) on Line: # in #, PCL:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = pc_decls_ppseqno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = lineno;
	asu64(R2) = filename;
	pc_api_pcerrorstop(asu64(R2), asi64(R1));
	return;
}

static u64 pc_api_pc_duplpst(u64 d) {
    u64 R1, R2, R3; struct $B21 R1_B21; 
	u64 e;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	e = asu64(R1);
	asu64(R1) = d;
	(R1_B21) = *(struct $B21*)(R1);
	asu64(R2) = e;
	*(struct $B21*)(R2) = (R1_B21);
	R1 = (u64)&pc_api_stseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = e;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = e;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	goto L1082;
L1082:
	return asu64(R1);
}

static void pc_api_pcl_cmdskip(i64 cmdskip, u64 dcmdskip) {
    u64 R1; 
	asi64(R1) = cmdskip;
	pc_decls_pcmdskip = asi64(R1);
	return;
}

static i64 pc_api_convertstring(u64 s, u64 t) {
    u64 R1, R2, R3; 
	i64 c;
	u64 t0;
	struct $B3 str;
	asu64(R1) = t;
	t0 = asu64(R1);
	goto L1086;
L1085:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1089;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1090;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1091;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1092;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L1093;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1094;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1094;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1094;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L1094;
	goto L1095;
L1089:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1090:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1091:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 114;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1092:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1093:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1094:
	R1 = 60;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
	asi64(R1) %= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 62;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1095:
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L1097;
	R2 = 126;
	if (asi64(R1) > asi64(R2)) goto L1097;
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1096;
L1097:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 120;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z2h");
	asi64(R2) = c;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1096:
L1088:
L1086:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	if (asi64(R1)) goto L1085;
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = t;
	asu64(R2) = t0;
	asi64(R1) -= asi64(R2);
	goto L1084;
L1084:
	return asi64(R1);
}

static void pc_diags_dummy_pshowlogfile() {
	return;
}

static void pc_diags_dummy_strpcl(u64 p) {
	return;
}

static u64 pc_diags_dummy_stropnd(u64 p) {
    u64 R1; 
	R1 = 0;
	goto L1100;
L1100:
	return asu64(R1);
}

static u64 pc_diags_dummy_strpclstr(u64 p, i64 buffsize) {
    u64 R1; 
	R1 = 0;
	goto L1101;
L1101:
	return asu64(R1);
}

static void pc_diags_dummy_writepcl(u64 p) {
	return;
}

static u64 pc_diags_dummy_writeallpcl() {
    u64 R1; 
	R1 = tou64("dummy diags");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L1103;
L1103:
	return asu64(R1);
}

static u64 pc_diags_dummy_writepst() {
    u64 R1; 
	asu64(R1) = pc_diags_dummy_writeallpcl();
	goto L1104;
L1104:
	return asu64(R1);
}

static void pc_reduce_pcl_reducetest() {
    u64 R1, R2, R3, R4; struct $B18 R1_B18; 
	i64 nn;
	i64 seqno;
	i64 lab;
	i64 lab2;
	i64 nargs;
	u64 pc;
	u64 newpc;
	u64 pcnext;
	u64 pcnext2;
	u64 pcproc;
	u64 labelmap;
	u64 pdef;
	struct $B16 callstack;
	i64 ncall;
	i64 nprocs;
	i64 nleaf;
	i64 nallparams;
	i64 nalllocals;
	i64 offset;
	i64 av_1;
	R1 = 0;
	nprocs = asi64(R1);
	R1 = 0;
	nleaf = asi64(R1);
	R1 = 0;
	nallparams = asi64(R1);
	R1 = 0;
	nalllocals = asi64(R1);
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcstart;
	asi64(R1) -= asi64(R2);
    asi64(R1) /= 32;
	R2 = 1;
	asi64(R1) += asi64(R2);
	nn = asi64(R1);
	asu64(R1) = pc_api_pcstart;
	pc = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	labelmap = asu64(R1);
	goto L1109;
L1106:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1111;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1112;
	goto L1113;
L1111:
	goto L1110;
L1112:
	asu64(R1) = pc_api_icheckasmlabel;
	if (!asu64(R1)) goto L1115;
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_api_icheckasmlabel;
	asi64(R1) = ((F1)R2)(asu64(R1));
	lab = asi64(R1);
	asi64(R1) = lab;
	if (!asi64(R1)) goto L1117;
	asu64(R1) = labelmap;
	asi64(R2) = lab;
	R1 += (i64)R2*2-2;
	(*tou16p(R1)) += 1;
L1117:
L1115:
	goto L1110;
L1113:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1119;
	asu64(R1) = labelmap;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2*2-2;
	(*tou16p(R1)) += 1;
L1119:
L1110:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1109:
	asu64(R1) = pc;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1106;
// pc_reduce.pcl_reducetest.skip:
	asu64(R1) = pc_api_pcstart;
	pc = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	newpc = asu64(R1);
	R1 = 0;
	seqno = asi64(R1);
	asi64(R1) = nn;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1123;
L1121:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	pcnext = asu64(R1);
	R1 = (u64)&pc_tables_pclargs;
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	nargs = asi64(R2);
	if (!asi64(R1)) goto L1125;
	asi64(R1) = nargs;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L1127;
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	nargs = asi64(R1);
L1127:
	asu64(R1) = pc_decls_pinfo;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = nargs;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1125:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1129;
	asu64(R1) = pc_decls_pinfo;
	if (!asu64(R1)) goto L1129;
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1129;
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1129:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1131;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1132;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1133;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1133;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L1134;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L1134;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L1134;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L1134;
	R2 = 131;
	if (asi64(R1) == asi64(R2)) goto L1135;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1136;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1137;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1138;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1138;
	R2 = 114;
	if (asi64(R1) == asi64(R2)) goto L1139;
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L1140;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1141;
	goto L1142;
L1131:
	goto L1130;
L1132:
	asu64(R1) = labelmap;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu16(R1) = *tou16p(((i64)R1+(i64)R2*2-2));
	if (!asu16(R1)) goto L1144;
	goto L1142;
	goto L1142;
L1144:
	goto L1130;
L1133:
	R1 = (u64)&nprocs;
	(*toi64p(R1)) += 1;
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdef = asu64(R1);
	asu64(R1) = newpc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pdef;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_decls_pinfo = asu64(R1);
	asu64(R1) = pc_decls_pinfo;
	asu64(R2) = pdef;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&nallparams;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pdef;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&nalllocals;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	ncall = asi64(R1);
	asu64(R1) = newpc;
	R2 = 1;
	R1 += (i64)R2*32;
	pcproc = asu64(R1);
	goto L1142;
	goto L1142;
	goto L1130;
L1134:
	R1 = 0;
	asu64(R2) = pc_decls_pinfo;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&ncall;
	(*toi64p(R1)) -=1;
	goto L1142;
	goto L1142;
	goto L1130;
L1135:
	R1 = (u64)&newpc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	(R1_B18) = *(struct $B18*)(R1);
	asu64(R2) = newpc;
	*(struct $B18*)(R2) = (R1_B18);
	R1 = (u64)&seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = newpc;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = newpc;
	R2 = (u64)&callstack;
	R3 = (u64)&ncall;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L1130;
L1136:
	asu64(R1) = pc_decls_pinfo;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1146;
	R1 = (u64)&nleaf;
	(*toi64p(R1)) += 1;
L1146:
	R1 = 0;
	pc_decls_pinfo = asu64(R1);
	goto L1142;
	goto L1142;
	goto L1130;
L1137:
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1142;
	goto L1142;
	goto L1130;
L1138:
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L1148;
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1148;
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = newpc;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1150;
	R1 = 3;
	goto L1149;
L1150:
	R1 = 6;
L1149:
	asu64(R2) = newpc;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1147;
L1148:
	goto L1142;
	goto L1142;
L1147:
	goto L1130;
L1139:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 113;
	if (asi64(R1) != asi64(R2)) goto L1152;
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = pcnext;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) != asu64(R2)) goto L1152;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1151;
L1152:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1154;
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L1153;
L1154:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = pcnext;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1151;
L1153:
	goto L1142;
	goto L1142;
L1151:
	goto L1130;
L1140:
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1157;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1157;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1156;
L1157:
	asu64(R1) = newpc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asi64(R1) != asi64(R2)) goto L1156;
	goto L1155;
L1156:
	goto L1142;
	goto L1142;
L1155:
	goto L1130;
L1141:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1159;
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = newpc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L1160;
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L1160;
	R1 = 1;
	goto L1161;
L1160:
	R1 = 0;
L1161:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L1159;
	asu64(R1) = pc;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pcnext;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = pcnext;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = newpc;
	R3 = 20;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1158;
L1159:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1162;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1158;
L1162:
	goto L1142;
	goto L1142;
L1158:
	goto L1130;
L1142:
	R1 = (u64)&newpc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	(R1_B18) = *(struct $B18*)(R1);
	asu64(R2) = newpc;
	*(struct $B18*)(R2) = (R1_B18);
	R1 = (u64)&seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = newpc;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = newpc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1164;
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1167;
	asu64(R1) = newpc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (asi32(R1)) goto L1166;
L1167:
	R1 = 1;
	asu64(R2) = newpc;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1166:
L1164:
L1130:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	if (--asi64(av_1)) goto L1121;
L1123:
	asu64(R1) = newpc;
	pc_api_pccurr = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	asu64(R2) = labelmap;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static i64 pc_run_dispatch_loop(u64 pcentry, i64 cmain) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 stack;
	u64 pc;
	i64 sp;
	i64 fp;
	i64 a;
	u64 ptr;
	i64 b;
	u64 ptrb;
	i64 n;
	u64 d;
	struct $B53 callstack;
	struct $B59 callstackst;
	i64 callsp;
	struct $B16 str;
	i64 mag;
	i64 oldsp;
	i64 ncmd;
	u64 cmd;
	i64 lastpos;
	i64 count;
	i64 av_1;
	i64 av_2;
	asu64(R1) = pcentry;
	pc = asu64(R1);
	R1 = 0;
	sp = asi64(R1);
	R1 = 0;
	fp = asi64(R1);
	R1 = 0;
	callsp = asi64(R1);
	R1 = 560000;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	stack = asu64(R1);
	asi64(R1) = cmain;
	if (!asi64(R1)) goto L1170;
	asi64(R1) = msysc_ncmdparams;
	ncmd = asi64(R1);
	asu64(R1) = msysc_cmdparams;
	cmd = asu64(R1);
	asi64(R1) = ncmd;
	asi64(R2) = pc_decls_pcmdskip;
	asi64(R1) -= asi64(R2);
	ncmd = asi64(R1);
	asu64(R1) = cmd;
	asi64(R2) = pc_decls_pcmdskip;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	cmd = asu64(R1);
	asu64(R1) = cmd;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = ncmd;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 0;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1170:
	R1 = 0;
	lastpos = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1172;
	R1 = tou64("<Fn ptr>");
	R2 = (u64)&pc_run_emptyst;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1172:
L1173:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L1177;
	case 1: goto L1178;
	case 2: goto L1181;
	case 3: goto L1182;
	case 4: goto L1183;
	case 5: goto L1190;
	case 6: goto L1191;
	case 7: goto L1176;
	case 8: case 9: goto L1192;
	case 10: goto L1193;
	case 11: goto L1194;
	case 12: goto L1195;
	case 13: goto L1197;
	case 14: goto L1198;
	case 15: goto L1199;
	case 16: goto L1200;
	case 17: goto L1203;
	case 18: case 21: goto L1204;
	case 19: goto L1229;
	case 20: goto L1219;
	case 22: goto L1237;
	case 23: goto L1224;
	case 24: goto L1242;
	case 25: goto L1243;
	case 26: goto L1244;
	case 27: goto L1252;
	case 28: goto L1255;
	case 29: goto L1258;
	case 30: goto L1259;
	case 31: goto L1260;
	case 32: goto L1267;
	case 33: goto L1268;
	case 34: goto L1271;
	case 35: goto L1274;
	case 36: goto L1277;
	case 37: case 38: goto L1280;
	case 39: goto L1283;
	case 40: goto L1284;
	case 41: goto L1285;
	case 42: goto L1286;
	case 43: goto L1287;
	case 44: goto L1290;
	case 45: goto L1293;
	case 46: goto L1296;
	case 47: goto L1297;
	case 48: goto L1300;
	case 49: goto L1303;
	case 50: goto L1304;
	case 51: goto L1305;
	case 52: goto L1306;
	case 53: goto L1307;
	case 54: goto L1308;
	case 55: goto L1311;
	case 56: goto L1315;
	case 57: goto L1319;
	case 58: goto L1320;
	case 59: goto L1321;
	case 60: goto L1322;
	case 61: goto L1325;
	case 62: goto L1328;
	case 63: goto L1329;
	case 64: goto L1330;
	case 65: goto L1331;
	case 66: goto L1332;
	case 67: goto L1335;
	case 68: goto L1336;
	case 69: goto L1337;
	case 70: goto L1338;
	case 71: goto L1339;
	case 72: goto L1340;
	case 73: goto L1341;
	case 74: goto L1342;
	case 75: goto L1343;
	case 76: goto L1344;
	case 77: goto L1345;
	case 78: goto L1346;
	case 79: goto L1347;
	case 80: goto L1348;
	case 81: goto L1349;
	case 82: goto L1350;
	case 83: goto L1353;
	case 84: goto L1354;
	case 85: goto L1355;
	case 86: goto L1356;
	case 87: goto L1357;
	case 88: goto L1358;
	case 89: goto L1359;
	case 90: goto L1360;
	case 91: goto L1363;
	case 92: goto L1366;
	case 93: case 94: goto L1369;
	case 95: goto L1372;
	case 96: goto L1373;
	case 97: goto L1374;
	case 98: goto L1375;
	case 99: goto L1376;
	case 100: goto L1377;
	case 101: goto L1380;
	case 102: goto L1384;
	case 103: goto L1388;
	case 104: goto L1389;
	case 105: goto L1390;
	case 106: goto L1391;
	case 107: goto L1392;
	case 108: goto L1393;
	case 109: goto L1394;
	case 110: goto L1395;
	case 111: goto L1396;
	case 112: goto L1399;
	case 113: goto L1400;
	case 114: goto L1401;
	case 115: goto L1402;
	case 116: goto L1403;
	case 117: goto L1404;
	case 118: goto L1405;
	case 119: goto L1406;
	case 120: goto L1407;
	case 121: goto L1413;
	case 122: goto L1414;
	case 123: goto L1415;
	case 124: goto L1416;
	case 125: goto L1417;
	case 126: goto L1428;
	case 127: goto L1418;
	case 128: goto L1419;
	case 129: goto L1420;
	case 130: goto L1421;
	case 131: goto L1422;
	case 132: goto L1423;
	case 133: goto L1424;
	case 134: goto L1425;
	case 135: goto L1426;
	case 136: goto L1427;
	default: goto L1176;
    };
// SWITCH
L1177:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1178:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1180;
	asu64(R1) = pc;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L1179;
L1180:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1179:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1181:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1182:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1183:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1185;
	goto L1186;
L1185:
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1188;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptr = asu64(R1);
	goto L1187;
L1188:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1189;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1189;
	asu64(R1) = stack;
	asi64(R2) = fp;
	asu64(R3) = d;
	R4 = 76;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) += asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	goto L1187;
L1189:
	asu64(R1) = stack;
	asi64(R2) = fp;
	asu64(R3) = d;
	R4 = 76;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) += asi64(R3);
	R1 += (i64)R2*8-8;
	ptr = asu64(R1);
L1187:
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L1184;
L1186:
	asu64(R1) = pc;
	pc_runaux_pcusopnd(asu64(R1));
L1184:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1190:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1191:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1192:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1193:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asi64(R2) -= asi64(R3);
	R1 += (i64)R2*8-8;
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R4) = pc;
	R5 = 20;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) -= asi64(R4);
	R2 += (i64)R3*8-8;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1194:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1195:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1197:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1198:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1199:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = stack;
	asi64(R4) = sp;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-24));
	asi64(R1) = pc_runaux_pci_loadbf(asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	R1 = 2;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1200:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-24));
	if (!asi64(R1)) goto L1202;
	R1 = 1;
	R2 = (u64)&a;
	asu64(R3) = stack;
	asi64(R4) = sp;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L1201;
L1202:
	R1 = 0;
	R2 = (u64)&a;
	asu64(R3) = stack;
	asi64(R4) = sp;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L1201:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1203:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-24));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-32));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = stack;
	asi64(R4) = sp;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-16));
	asi64(R4) = a;
	asi64(R1) = pc_runaux_pci_storebf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 4;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1204:
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1206;
	asi64(R1) = callsp;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1209;
L1207:
	msysc_m$print_startcon();
	R1 = tou64("  ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_1)) goto L1207;
L1209:
	msysc_m$print_startcon();
	R1 = tou64("# Call:   # # SP=# FP=#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_run_seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	asi64(R1) = pc_run_getlineno(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1206:
	asi64(R1) = sp;
	R2 = 69900;
	if (asi64(R1) <= asi64(R2)) goto L1211;
	R1 = tou64("");
	R2 = tou64("Stack overflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1211:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1213;
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	R5 = 0;
	asu64(R6) = d;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L1215;
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	goto L1214;
L1215:
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1214:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1212;
L1213:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1216;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Proc not defined:");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1212;
L1216:
	asi64(R1) = sp;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 21;
	if (asi64(R2) != asi64(R3)) goto L1218;
	R2 = 1;
	goto L1217;
L1218:
	R2 = 0;
L1217:
	asi64(R1) += asi64(R2);
	R2 = (u64)&callstack;
	R3 = (u64)&callsp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	asu64(R1) = d;
	R2 = (u64)&callstackst;
	asi64(R3) = callsp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) |= asi64(R2);
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
L1212:
	goto L1173;
L1219:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	fp = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = callsp;
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L1221;
	R1 = tou64("");
	R2 = tou64("retp/call underflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1221:
	R1 = (u64)&callstack;
	R2 = (u64)&callsp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	oldsp = asi64(R1);
	asi64(R1) = sp;
	asi64(R2) = oldsp;
	if (asi64(R1) == asi64(R2)) goto L1223;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("RETP/SP mismatch: old=# curr=# ");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = oldsp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = tou64("");
	R2 = (u64)&str;
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1223:
	asu64(R1) = ptr;
	R2 = -16;
	asu64(R1) &= asu64(R2);
	pc = asu64(R1);
	goto L1173;
L1224:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R2) = *(toi64p(R2)) -= 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	fp = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R2) = *(toi64p(R2)) -= 1;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = callsp;
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L1226;
	R1 = tou64("");
	R2 = tou64("ref/call underflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1226:
	R1 = (u64)&callstack;
	R2 = (u64)&callsp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	oldsp = asi64(R1);
	asi64(R1) = sp;
	asi64(R2) = oldsp;
	if (asi64(R1) == asi64(R2)) goto L1228;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("RETF/SP mismatch: old=# curr=# ");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = oldsp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = tou64("");
	R2 = (u64)&str;
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1228:
	asu64(R1) = ptr;
	R2 = -16;
	asu64(R1) &= asu64(R2);
	pc = asu64(R1);
	goto L1173;
L1229:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1231;
	R1 = tou64("");
	R2 = tou64("ICALLP NIL PTR");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1231:
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pcstart;
	if (asu64(R1) < asu64(R2)) goto L1233;
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1233;
// pc_run.dispatch_loop.icallp:
L1234:
	asi64(R1) = sp;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 22;
	if (asi64(R2) != asi64(R3)) goto L1236;
	R2 = 1;
	goto L1235;
L1236:
	R2 = 0;
L1235:
	asi64(R1) += asi64(R2);
	R2 = (u64)&callstack;
	R3 = (u64)&callsp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	R1 = (u64)&pc_run_emptyst;
	R2 = (u64)&callstackst;
	asi64(R3) = callsp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) |= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = ptr;
	pc = asu64(R1);
	goto L1232;
L1233:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	asu64(R5) = ptr;
	R6 = 0;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1232:
	goto L1173;
L1237:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1239;
	R1 = tou64("");
	R2 = tou64("ICALLF NIL PTR");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1239:
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pcstart;
	if (asu64(R1) < asu64(R2)) goto L1241;
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1241;
	goto L1234;
	goto L1240;
L1241:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	asu64(R5) = ptr;
	R6 = 0;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1240:
	goto L1173;
L1242:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1173;
L1243:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1173;
L1244:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1246;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpreal(asi64(R3), asr64(R2), asr64(R1));
	n = asi64(R1);
	goto L1245;
L1246:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1247;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpint(asi64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	goto L1245;
L1247:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpword(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L1245:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L1249;
	asi64(R1) = n;
	if (asi64(R1)) goto L1249;
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	goto L1248;
L1249:
	R1 = 2;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
L1248:
	asi64(R1) = n;
	if (!asi64(R1)) goto L1251;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1250;
L1251:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1250:
	goto L1173;
L1252:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (!asi64(R1)) goto L1254;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1253;
L1254:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1253:
	goto L1173;
L1255:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1257;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1256;
L1257:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1256:
	goto L1173;
L1258:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1173;
L1259:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1260:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1262;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1263;
	goto L1264;
L1262:
	R1 = tou64("");
	R2 = tou64("setcc/r64");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1261;
L1263:
	R1 = tou64("");
	R2 = tou64("setcc/r32");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1261;
L1264:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1266;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpint(asi64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	goto L1265;
L1266:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpword(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L1265:
L1261:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1267:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L1168;
	goto L1173;
L1268:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	(*toi64p(R1)) -=1;
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	if (!asi64(R1)) goto L1270;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1269;
L1270:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1269:
	goto L1173;
L1271:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = ptr;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = n;
	if (asi64(R1) > asi64(R2)) goto L1273;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1272;
L1273:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1272:
	goto L1173;
L1274:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = ptr;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = n;
	if (asi64(R1) < asi64(R2)) goto L1276;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1275;
L1276:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1275:
	goto L1173;
L1277:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1279;
	R1 = tou64("");
	R2 = tou64("swap/block");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1279:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptrb = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptrb;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	b = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = b;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptrb;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1280:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) < asi64(R2)) goto L1282;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) > asi64(R2)) goto L1282;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	R1 += (i64)R2*32;
	asi64(R2) = a;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 -= (i64)R2*32;
	pc = asu64(R1);
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1281;
L1282:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
L1281:
	goto L1173;
L1283:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1284:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1285:
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	R2 = 0;
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1286:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1287:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1289;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) += asr64(R1);
	goto L1288;
L1289:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) += asi64(R1);
L1288:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1290:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1292;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) -= asr64(R1);
	goto L1291;
L1292:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) -= asi64(R1);
L1291:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1293:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1295;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) *= asr64(R1);
	goto L1294;
L1295:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) *= asi64(R1);
L1294:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1296:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-8));
	asr64(R1) /= asr64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-16)) = asr64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1297:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1299;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	goto L1298;
L1299:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-16)) = asu64(R1);
L1298:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1300:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1302;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) %= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	goto L1301;
L1302:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) %= asu64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-16)) = asu64(R1);
L1301:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1303:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1304:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) &= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1305:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) |= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1306:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) ^= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1307:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tou64p(R2) <<= asu64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1308:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1310;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) >>= asi64(R1);
	goto L1309;
L1310:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tou64p(R2) >>= asu64(R1);
L1309:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1311:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1313;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tor64p(R2) = Min(*tor64p(R2), asr64(R1));
	goto L1312;
L1313:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1314;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
	goto L1312;
L1314:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tou64p(R2) = Min(*tou64p(R2), asu64(R1));
L1312:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1315:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1317;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tor64p(R2) = Max(*tor64p(R2), asr64(R1));
	goto L1316;
L1317:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1318;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	goto L1316;
L1318:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tou64p(R2) = Max(*tou64p(R2), asu64(R1));
L1316:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1319:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1320:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 -= (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1321:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1322:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1324;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = -asr64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1323;
L1324:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = -asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1323:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1325:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1327;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	if (asr64(R1) < 0) asr64(R1) = -asr64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1326;
L1327:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1326:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1328:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = ~asu64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1329:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asi64(R1) ^= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1330:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = !!asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1331:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = !asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1332:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1334;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	*tor64p(R2) *= asr64(R1);
	goto L1333;
L1334:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) *= asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1333:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1335:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = sqrt(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1336:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1337:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1338:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1339:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1340:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1341:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1342:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1343:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1344:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1345:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1346:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1347:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1348:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1349:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1350:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1352;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-8));
	asr64(R1) = pow(asr64(R1), asr64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-16)) = asr64(R1);
	goto L1351;
L1352:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = Poweri64(asi64(R1), asi64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
L1351:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1353:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1354:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1355:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1356:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1357:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1358:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1359:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1360:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1362;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) += asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1361;
L1362:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) += asi64(R1);
L1361:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1363:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1365;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) -= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1364;
L1365:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) -= asi64(R1);
L1364:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1366:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1368;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) *= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1367;
L1368:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) *= asi64(R1);
L1367:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1369:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1371;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) /= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1370;
L1371:
	asi64(R1) = a;
	asi64(R2) = b;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	a = asi64(R1);
L1370:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1372:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) %= asi64(R2);
	a = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1373:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) &= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1374:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) |= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1375:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) ^= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1376:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) <<= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1377:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1379;
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) >>= asi64(R1);
	goto L1378;
L1379:
	asu64(R1) = b;
	R2 = (u64)&a;
	*tou64p(R2) >>= asu64(R1);
L1378:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1380:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1382;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) = Min(asr64(R1), asr64(R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1381;
L1382:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1383;
	asi64(R1) = b;
	R2 = (u64)&a;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
	goto L1381;
L1383:
	asu64(R1) = b;
	R2 = (u64)&a;
    *tou64p(R2) = Min(*tou64p(R2), asu64(R1));
L1381:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1384:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1386;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) = Max(asr64(R1), asr64(R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1385;
L1386:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1387;
	asi64(R1) = b;
	R2 = (u64)&a;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	goto L1385;
L1387:
	asu64(R1) = b;
	R2 = (u64)&a;
    *tou64p(R2) = Max(*tou64p(R2), asu64(R1));
L1385:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1388:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) *= asu64(R2);
	asu64(R2) = ptr;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1389:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) *= asu64(R2);
	asu64(R2) = ptr;
	*tou64p(R2) -= asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1390:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1391:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1392:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1393:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1394:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1395:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1396:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1398;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1397;
L1398:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asu64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
L1397:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1399:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	R1 = toi64(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1400:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1401:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1402:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1403:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1404:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1405:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1406:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1407:
	asi64(R1) = fp;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = sp;
	fp = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1409;
	asi64(R1) = callsp;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1412;
L1410:
	msysc_m$print_startcon();
	R1 = tou64("  ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_2)) goto L1410;
L1412:
	msysc_m$print_startcon();
	R1 = tou64("# Enter:  # SP=# FP=#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = pc_run_seqno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = fp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1409:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1413:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1414:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1415:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1416:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1417:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1418:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1419:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1420:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = ptr;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = sp;
	asu64(R2) = ptr;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = fp;
	asu64(R2) = ptr;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 0;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1421:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	asu64(R1) = *tou64p(R1);
	pc = asu64(R1);
	asu64(R1) = ptr;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	sp = asi64(R1);
	asu64(R1) = ptr;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	fp = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L1173;
L1422:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1423:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1424:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1425:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1426:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1427:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1428:
	goto L1173;
L1176:
// pc_run.dispatch_loop.unimpl:
L1196:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("GETOPCODE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Unimpl: # at seq: #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	goto L1173;
	R1 = 0;
	goto L1168;
L1168:
	return asi64(R1);
}

static void pc_run_fixuppcl() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 d;
	u64 e;
	u64 dproc;
	u64 pdata;
	i64 parambytes;
	i64 framebytes;
	i64 paramslots;
	i64 localslots;
	u64 a;
	asi64(R1) = pc_api_mlabelno;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_run_labeltable = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1433;
L1430:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1435;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1435;
	goto L1436;
L1435:
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1434;
L1436:
L1434:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1433:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1430;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1440;
L1437:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1442;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1442;
	goto L1443;
L1442:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1441;
L1443:
L1441:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1440:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1437;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1447;
L1444:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1449;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1449;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1450;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1451;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1452;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1453;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L1453;
	goto L1454;
L1449:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdata = asu64(R1);
	goto L1448;
L1450:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1456;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1458;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1459;
	goto L1460;
L1458:
	R1 = tou64("");
	R2 = tou64("FIX/DATA/MEM");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1457;
L1459:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1462;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1463;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1464;
	goto L1465;
L1462:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L1461;
L1463:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L1461;
L1464:
	asu64(R1) = d;
	asu64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	a = asu64(R1);
	goto L1461;
L1465:
	R1 = tou64("");
	R2 = tou64("data &mem");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1461:
	asu64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1467;
	R1 = tou64("");
	R2 = tou64("data &mem = nil");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1467:
	goto L1457;
L1460:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L1457:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	R2 = (u64)&a;
	asu64(R3) = pdata;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L1455;
L1456:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = pdata;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1455:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&pdata;
	*tou64p(R2) += asu64(R1);
	goto L1448;
L1451:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	dproc = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	parambytes = asi64(R1);
	goto L1471;
L1468:
	R1 = 8;
	R2 = (u64)&parambytes;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = parambytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R1) = -asi64(R1);
	asu64(R2) = e;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1471:
	asu64(R1) = e;
	if (asu64(R1)) goto L1468;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	framebytes = asi64(R1);
	goto L1475;
L1472:
	asi64(R1) = framebytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = e;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 8;
	asu64(R2) = e;
	R3 = 84;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&framebytes;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1475:
	asu64(R1) = e;
	if (asu64(R1)) goto L1472;
	asi64(R1) = parambytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = R1;
	paramslots = asi64(R2);
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = framebytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = R1;
	localslots = asi64(R2);
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1448;
L1452:
	asu64(R1) = p;
	asu64(R2) = pc_run_labeltable;
	asu64(R3) = p;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L1448;
L1453:
	asi64(R1) = paramslots;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = localslots;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1448;
L1454:
L1448:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1447:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1444;
	return;
}

static void pc_run_pcl_runpcl() {
    u64 R1, R2, R3; 
	i64 stopcode;
	pc_runaux_loadlibs();
	pc_run_fixuppcl();
	asu64(R1) = pc_decls_entryproc;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1478;
	R1 = tou64("");
	R2 = tou64("No 'main' entry point");
	asu64(R3) = pc_api_pcstart;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1478:
	pc_runaux_docmdskip();
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L1480;
	msysc_m$print_startcon();
	R1 = tou64("Run PCL:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1480:
	asu64(R1) = pc_decls_entryproc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = pc_decls_entryproc;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_run_dispatch_loop(asu64(R2), asi64(R1));
	stopcode = asi64(R1);
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L1482;
	msysc_m$print_startcon();
	R1 = tou64("Stopped");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = stopcode;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
L1482:
	asi64(R1) = stopcode;
	exit(R1);
	return;
}

static i64 pc_run_getlineno(u64 pc) {
    u64 R1, R2, R3, R4; 
	u64 filename;
	u64 sourceline;
	asu64(R1) = pc_decls_igetmsourceinfo;
	if (!asu64(R1)) goto L1485;
	R1 = (u64)&sourceline;
	R2 = (u64)&filename;
	asu64(R3) = pc;
	R4 = 24;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R4) = pc_decls_igetmsourceinfo;
	asi64(R1) = ((F17)R4)(asi64(R3), asu64(R2), asu64(R1));
	goto L1484;
L1485:
	R1 = 0;
L1484:
	goto L1483;
L1483:
	return asi64(R1);
}

static i64 pc_runaux_pci_getopnd(u64 p, u64 locals) {
    u64 R1, R2, R3; 
	i64 a;
	u64 d;
	u64 ptr;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1488;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1489;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1490;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1491;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1492;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1492;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1493;
	goto L1494;
L1488:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	goto L1487;
L1489:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1496;
	goto L1497;
L1496:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptr = asu64(R1);
	goto L1495;
L1497:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	ptr = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1499;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1499;
	asu64(R1) = ptr;
	asu64(R1) = *tou64p(R1);
	ptr = asu64(R1);
L1499:
L1495:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	goto L1487;
L1490:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1501;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1502;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1503;
	goto L1504;
L1501:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	a = asi64(R1);
	goto L1500;
L1502:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	a = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1506;
	asi64(R1) = a;
	ptr = asu64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	a = asi64(R1);
L1506:
	goto L1500;
L1503:
	asu64(R1) = d;
	asi64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	a = asi64(R1);
	goto L1500;
L1504:
	asu64(R1) = d;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
L1500:
	goto L1487;
L1491:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	goto L1487;
L1492:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1487;
L1493:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	goto L1487;
L1494:
	asu64(R1) = p;
	pc_runaux_pcusopnd(asu64(R1));
L1487:
	asi64(R1) = a;
	goto L1486;
L1486:
	return asi64(R1);
}

static i64 pc_runaux_pci_loadptr(u64 p, i64 mode) {
    u64 R1, R2; 
	r64 x;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1509;
	R1 = tou64("Null ptr access");
	pc_api_pclerror(asu64(R1));
L1509:
	asi64(R1) = mode;
	switch (asi64(R1)) {
	case 1: goto L1515;
	case 2: goto L1514;
	case 3: goto L1523;
	case 4: goto L1522;
	case 5: goto L1521;
	case 6: goto L1520;
	case 7: goto L1519;
	case 8: goto L1518;
	case 9: goto L1517;
	case 10: goto L1516;
	case 11: goto L1513;
	default: goto L1512;
    };
// SWITCH
L1513:
	asu64(R1) = p;
	goto L1510;
L1514:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1510;
L1515:
	asu64(R1) = p;
	asr32(R1) = *tor32p(R1);
    asr64(R1) = tor64(asr32(R1));
	x = asr64(R1);
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	goto L1510;
L1516:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1510;
L1517:
	asu64(R1) = p;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	goto L1510;
L1518:
	asu64(R1) = p;
	asi16(R1) = *toi16p(R1);
	R1 = toi64(toi16(R1));
	goto L1510;
L1519:
	asu64(R1) = p;
	asi8(R1) = *toi8p(R1);
	R1 = toi64(toi8(R1));
	goto L1510;
L1520:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1510;
L1521:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	goto L1510;
L1522:
	asu64(R1) = p;
	asu16(R1) = *tou16p(R1);
	R1 = toi64(tou16(R1));
	goto L1510;
L1523:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L1510;
L1512:
	R1 = 0;
L1510:
	goto L1507;
L1507:
	return asi64(R1);
}

static void pc_runaux_pci_storeptr(u64 p, i64 a, i64 mode, i64 size) {
    u64 R1, R2, R3; 
	r64 x;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1526;
	R1 = tou64("Null ptr access");
	pc_api_pclerror(asu64(R1));
L1526:
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1528;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1529;
	goto L1530;
L1528:
	asi64(R1) = size;
	asi64(R2) = a;
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L1527;
L1529:
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	x = asr64(R1);
	asr64(R1) = x;
    asr32(R1) = tor32(asr64(R1));
	asu64(R2) = p;
	*tor32p(R2) = asr32(R1);
	goto L1527;
L1530:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1532;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1533;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1534;
	goto L1535;
L1532:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi64p(R2) = asi64(R1);
	goto L1531;
L1533:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	goto L1531;
L1534:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi16p(R2) = asi16(R1);
	goto L1531;
L1535:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi8p(R2) = asi8(R1);
L1531:
L1527:
	return;
}

static u64 pc_runaux_pci_getopndaddr(u64 p, u64 locals) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1538;
	R1 = tou64("");
	R2 = tou64("Not mem");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1538:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1540;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1539;
L1540:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
L1539:
	goto L1536;
L1536:
	return asu64(R1);
}

static void pc_runaux_pcerrorx(u64 p, u64 mess, u64 param) {
    u64 R1, R2, R3, R4; 
	msysc_m$print_startcon();
	R1 = tou64("PC Exec error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("seq:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	if (!asu64(R2)) goto L1543;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	goto L1542;
L1543:
	R2 = 0;
L1542:
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void pc_runaux_pcusopnd(u64 p) {
    u64 R1, R2, R3, R4; 
	msysc_m$print_startcon();
	R1 = tou64("Unsupported operand:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static i64 pc_runaux_docalldll(u64 d, u64 fnaddr, u64 revargs, i64 nargs, i64 nvars, i64 retmode) {
    u64 R1, R2, R3, R4, R5; 
	struct $B66 args;
	i64 retval;
	i64 i;
	asu64(R1) = fnaddr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1547;
	asu64(R1) = d;
	asu64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	fnaddr = asu64(R1);
L1547:
	asi64(R1) = nargs;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1550;
L1548:
	asu64(R1) = revargs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&args;
	asi64(R3) = nargs;
	asi64(R4) = i;
	asi64(R3) -= asi64(R4);
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	i += -1; if (i >= 1) goto L1548;
L1550:
	R1 = 0;
	R2 = (u64)&args;
	asi64(R3) = nargs;
	asi64(R4) = retmode;
	R5 = 1;
	if (asi64(R4) == asi64(R5)) goto L1553;
	R5 = 2;
	if (asi64(R4) != asi64(R5)) goto L1552;
L1553:
	R4 = 82;
	goto L1551;
L1552:
	R4 = 73;
L1551:
	asu64(R5) = fnaddr;
	asi64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	retval = asi64(R1);
	asi64(R1) = retval;
	goto L1545;
L1545:
	return asi64(R1);
}

static u64 pc_runaux_getdllfnptr(u64 d) {
    u64 R1, R2, R3; 
	u64 fnaddr;
	i64 libindex;
	u64 dllinst;
	u64 procname;
	u64 libname;
	i64 i;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L1556;
	asu64(R1) = fnaddr;
	goto L1554;
L1556:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	procname = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1560;
L1557:
	asu64(R1) = procname;
	R2 = (u64)&pc_decls_plibinst;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mwindows_os_getdllprocaddr(asi64(R2), asu64(R1));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L1562;
	goto L1559;
L1562:
	i += 1; if (i <= pc_decls_nplibfiles) goto L1557;
L1560:
	asu64(R1) = procname;
	R2 = tou64("Can't find DLL func:");
	R3 = 0;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1559:
	asu64(R1) = fnaddr;
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = fnaddr;
	goto L1554;
L1554:
	return asu64(R1);
}

static void pc_runaux_loadlibs() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1566;
L1564:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mwindows_os_getdllinst(asu64(R1));
	R2 = (u64)&pc_decls_plibinst;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc_decls_plibinst;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (asu64(R1)) goto L1568;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Can't load lib:");
	R3 = 0;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1568:
	i += 1; if (i <= pc_decls_nplibfiles) goto L1564;
L1566:
	return;
}

static i64 pc_runaux_cmpreal(i64 cond, r64 x, r64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1571;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1572;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1573;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1574;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1575;
	goto L1576;
L1571:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  ==  asr64(R2);
	goto L1570;
L1572:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  !=  asr64(R2);
	goto L1570;
L1573:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  <  asr64(R2);
	goto L1570;
L1574:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  <=  asr64(R2);
	goto L1570;
L1575:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  >=  asr64(R2);
	goto L1570;
L1576:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  >  asr64(R2);
L1570:
	goto L1569;
L1569:
	return asi64(R1);
}

static i64 pc_runaux_cmpint(i64 cond, i64 x, i64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1579;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1580;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1581;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1582;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1583;
	goto L1584;
L1579:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L1578;
L1580:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	goto L1578;
L1581:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	goto L1578;
L1582:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	goto L1578;
L1583:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	goto L1578;
L1584:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >  asi64(R2);
L1578:
	goto L1577;
L1577:
	return asi64(R1);
}

static i64 pc_runaux_cmpword(i64 cond, u64 x, u64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1587;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1588;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1589;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1590;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1591;
	goto L1592;
L1587:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  ==  asu64(R2);
	goto L1586;
L1588:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  !=  asu64(R2);
	goto L1586;
L1589:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  <  asu64(R2);
	goto L1586;
L1590:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  <=  asu64(R2);
	goto L1586;
L1591:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  >=  asu64(R2);
	goto L1586;
L1592:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  >  asu64(R2);
L1586:
	goto L1585;
L1585:
	return asi64(R1);
}

static void pc_runaux_doincr(u64 pu8, i64 incr, i64 mode) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1595;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1596;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1597;
	goto L1598;
L1595:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou64p(R2) += asu64(R1);
	goto L1594;
L1596:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou32p(R2) += asu32(R1);
	goto L1594;
L1597:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou16p(R2) += asu16(R1);
	goto L1594;
L1598:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou8p(R2) += asu8(R1);
L1594:
	return;
}

static void pc_runaux_docmdskip() {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1603;
L1600:
	R1 = tou64("$cmdskip");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1605;
	asi64(R1) = pc_decls_pcmdskip;
	asu64(R2) = d;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou8p(R2) = asu8(R1);
	goto L1602;
L1605:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1603:
	asu64(R1) = d;
	if (asu64(R1)) goto L1600;
L1602:
	return;
}

static u64 pc_runaux_pci_loadbf(u64 a, u64 i, u64 j) {
    u64 R1, R2; 
	u64 mask;
	i64 n;
	asu64(R1) = j;
	asu64(R2) = i;
	if (asu64(R1) >= asu64(R2)) goto L1608;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L1608:
	asu64(R1) = j;
	asu64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	R1 = -1;
	asi64(R2) = n;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	mask = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = mask;
	asu64(R1) &= asu64(R2);
	asu64(R2) = i;
	asu64(R1) >>= asu64(R2);
	goto L1606;
L1606:
	return asu64(R1);
}

static u64 pc_runaux_pci_storebf(u64 a, u64 i, u64 j, u64 x) {
    u64 R1, R2; 
	u64 mask;
	u64 n;
	asu64(R1) = j;
	asu64(R2) = i;
	if (asu64(R1) >= asu64(R2)) goto L1611;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L1611:
	asu64(R1) = j;
	asu64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asu64(R1) += asu64(R2);
	n = asu64(R1);
	R1 = -1;
	asu64(R2) = n;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	mask = asu64(R1);
	asu64(R1) = x;
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = mask;
	asu64(R1) &= asu64(R2);
	x = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = mask;
	asu64(R2) = ~asu64(R2);
	asu64(R1) &= asu64(R2);
	asu64(R2) = x;
	asu64(R1) |= asu64(R2);
	goto L1609;
L1609:
	return asu64(R1);
}

static void mc_genmcl_genmcl(u64 dummy) {
    u64 R1, R2, R3; 
	i64 tt;
	i64 i;
	asu8(R1) = pc_decls_mcldone;
	if (!asu8(R1)) goto L1614;
	goto L1612;
L1614:
	R1 = 0;
	if (asu16(R1)) goto L1617;
	R1 = 0;
	if (!asu16(R1)) goto L1616;
L1617:
	msysc_m$print_startcon();
	R1 = tou64("********* ASM HAS PCL INFO *********");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1616:
	asi64(R1) = mwindows_os_clock();
	tt = asi64(R1);
	mc_genmcl_inithandlers();
	R1 = 0;
	mc_libmcl_mclinit(asi64(R1));
	asu64(R1) = pc_api_pcstart;
	mc_decls_currpcl = asu64(R1);
	R1 = 0;
	i = asi64(R1);
L1618:
	asu64(R1) = mc_decls_currpcl;
	mc_genmcl_convertpcl(asu64(R1));
	R1 = 0;
	if (!asu16(R1)) goto L1622;
	asu64(R1) = mc_decls_currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1622;
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1622;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1622;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1622;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1622;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1622;
	mc_stackmcl_showopndstack();
L1622:
	R1 = (u64)&mc_decls_currpcl;
	(*tou64p(R1)) += 32;
	asu64(R1) = mc_decls_currpcl;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1623;
	asu64(R1) = mc_decls_currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) != asi64(R2)) goto L1618;
L1623:
	mc_auxmcl_genrealtable();
	mc_auxmcl_genabsneg();
	mc_auxmcl_genstringtable();
	R1 = 0;
	R2 = 0;
	R3 = 8;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 8;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L1625;
	mc_optim_peephole();
L1625:
	R1 = 1;
	pc_decls_mcldone = asu8(R1);
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_mcltime = asi64(R1);
L1612:
	return;
}

static void mc_genmcl_convertpcl(u64 p) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B3 oldregset;
	i64 reg;
	i64 i;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	mc_decls_pmode = asu8(R1);
	asu64(R1) = p;
	mc_decls_currpcl = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 8;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pc_decls_ppseqno = asi64(R1);
	asu64(R1) = p;
	R2 = (u64)&mc_genmcl_px_handlertable;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	((F18)R2)(asu64(R1));
	(R1_B3) = mc_decls_regset;
	oldregset = (R1_B3);
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1629;
L1627:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = reg;
	if (!asi64(R1)) goto L1631;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1633;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1632;
L1633:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1632:
L1631:
	i += 1; if (i <= mc_decls_noperands) goto L1627;
L1629:
	R1 = (u64)&oldregset;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_regset;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&mc_decls_isregvar;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) |= asu64(R3);
	R3 = 72340172838076673;
	asu64(R2) ^= asu64(R3);
	asi64(R1) &= asi64(R2);
	asu64(R2) = mc_decls_mccodex;
	R3 = 48;
	R2 += (i64)R3;
	*tou64p(R2) |= asu64(R1);
	R1 = (u64)&oldregset;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_regset;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&mc_decls_isregvar;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) |= asu64(R3);
	R3 = 72340172838076673;
	asu64(R2) ^= asu64(R3);
	asi64(R1) &= asi64(R2);
	asu64(R2) = mc_decls_mccodex;
	R3 = 56;
	R2 += (i64)R3;
	*tou64p(R2) |= asu64(R1);
	return;
}

static void mc_genmcl_inithandlers() {
    u64 R1, R2, R3, R4; 
	u64 name;
	u64 s;
	i64 n;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 i;
	i64 k;
// PROC LOCAL STATICS GO HERE
	static u8 mc_genmcl_inithandlers_initdone = 0;
	static struct $B27 mc_genmcl_inithandlers_dupltable = {{
22605,
	16449,
	4629,
	4627,
	4630,
	30327,
	30841,
	12126,
	12383    }};
	asu8(R1) = mc_genmcl_inithandlers_initdone;
	if (!asu8(R1)) goto L1636;
	goto L1634;
L1636:
	asi64(R1) = $nprocs;
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1639;
L1637:
	R1 = (u64)&$procname;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	name = asu64(R1);
	R1 = 3;
	R2 = tou64("px_");
	asu64(R3) = name;
	asi64(R1) = mlib_eqbytes(asu64(R3), asu64(R2), asi64(R1));
	if (!asi64(R1)) goto L1641;
	R1 = 0;
	k = asi64(R1);
	R1 = 142;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1645;
L1642:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = k;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	s = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 107;
	if (asu64(R1) != asu64(R2)) goto L1647;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L1647:
	asu64(R1) = name;
	R2 = 3;
	R1 += (i64)R2;
	asu64(R2) = s;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1649;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mc_genmcl_px_handlertable;
	asi64(R3) = k;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L1644;
L1649:
	k += 1; if (k <= av_1) goto L1642;
L1645:
	asu64(R1) = name;
	R2 = tou64("Invalid handler name:");
	pc_api_merror(asu64(R2), asu64(R1));
L1644:
L1641:
	i += 1; if (i <= n) goto L1637;
L1639:
	R1 = 1;
	i = asi64(R1);
	R1 = 9;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1652;
L1650:
	R1 = (u64)&mc_genmcl_px_handlertable;
	R2 = (u64)&mc_genmcl_inithandlers_dupltable;
	asi64(R3) = i;
	R2 += (i64)R3*2-2;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mc_genmcl_px_handlertable;
	R3 = (u64)&mc_genmcl_inithandlers_dupltable;
	asi64(R4) = i;
	R3 += (i64)R4*2-2;
	R4 = 1;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= av_2) goto L1650;
L1652:
	R1 = 0;
	i = asi64(R1);
	R1 = 142;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1655;
L1653:
	R1 = (u64)&mc_genmcl_px_handlertable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (asu64(R1)) goto L1657;
	R1 = (u64)&mc_genmcl_unimpl;
	R2 = (u64)&mc_genmcl_px_handlertable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L1657:
	i += 1; if (i <= av_3) goto L1653;
L1655:
	R1 = 1;
	mc_genmcl_inithandlers_initdone = asu8(R1);
L1634:
	return;
}

static void mc_genmcl_doshowpcl(u64 p) {
    u64 R1, R2; 
	struct $B92 str;
	goto L1658;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1660;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1660;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1660;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1660;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1660;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1660;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1660;
	goto L1661;
L1660:
	goto L1659;
L1661:
	R1 = tou64("                       ");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1256;
	asu64(R2) = p;
	asu64(R1) = pc_diags_dummy_strpclstr(asu64(R2), asi64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mc_libmcl_mgencomment(asu64(R1));
L1659:
L1658:
	return;
}

static void mc_genmcl_unimpl(u64 p) {
    u64 R1, R2, R3; 
	struct $B5 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("Unimpl: # (#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_genmcl_px_nop(u64 p) {
	return;
}

static void mc_genmcl_px_dupl(u64 p) {
	mc_stackmcl_duplpcl();
	return;
}

static void mc_genmcl_px_double(u64 p) {
    u64 R1, R2; 
	asi64(R1) = mc_decls_ncalldepth;
	if (!asi64(R1)) goto L1667;
	mc_stackmcl_duplpcl();
	goto L1666;
L1667:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = mc_decls_noperands;
	R1 += (i64)R2-1;
	(*tou8p(R1)) += 1;
L1666:
	return;
}

static void mc_genmcl_px_opnd(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_type(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_comment(u64 p) {
	return;
}

static void mc_genmcl_px_proc(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_decls_currfunc = asu64(R1);
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = pc_decls_currfunc;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 1;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = pc_decls_currfunc;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	mc_auxmcl_initproc(asu64(R1));
	R1 = tou64("?>>");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mclprocentry = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1673;
	asu64(R1) = pc_decls_currfunc;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1673;
	mc_auxmcl_fixmain();
L1673:
	return;
}

static void mc_genmcl_px_endproc(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	if (!asi64(R1)) goto L1676;
	msysc_m$print_startcon();
	R1 = tou64("PCL STACK NOT EMPTY");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("PCL STACK NOT EMPTY");
	mc_libmcl_mgencomment(asu64(R1));
L1676:
	R1 = 0;
	R2 = 0;
	R3 = 2;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_endprog(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_genmcl_unimpl(asu64(R1));
	return;
}

static void mc_genmcl_px_istatic(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_zstatic(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 90;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = d;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 4;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 124;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_data(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	i64 opc;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1682;
	asu64(R1) = p;
	mc_auxmcl_do_blockdata(asu64(R1));
	goto L1680;
L1682:
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1684;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1685;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1686;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1687;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1688;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1689;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1690;
	goto L1691;
L1684:
	R1 = 10;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1683;
L1685:
	R1 = 2;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1683;
L1686:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1683;
L1687:
	R1 = 1;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealimm(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L1683;
L1688:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_libmcl_getstringindex(asu64(R1));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L1683;
L1689:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = ax;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1683;
L1690:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	ax = asu64(R1);
	goto L1683;
L1691:
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("db/dq optype? #");
	pc_api_merror(asu64(R2), asu64(R1));
L1683:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1693;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1694;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1695;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1696;
	goto L1697;
L1693:
	R1 = 116;
	opc = asi64(R1);
	goto L1692;
L1694:
	R1 = 117;
	opc = asi64(R1);
	goto L1692;
L1695:
	R1 = 118;
	opc = asi64(R1);
	goto L1692;
L1696:
	R1 = 119;
	opc = asi64(R1);
	goto L1692;
L1697:
	msysc_m$print_startcon();
	R1 = tou64("P.SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("STRPMODE(P.MODE)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = pc_api_strpmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("DATA/not 1248");
	pc_api_merror(asu64(R2), asu64(R1));
L1692:
	R1 = 0;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1680:
	return;
}

static void mc_genmcl_px_label(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_load(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_stackmcl_pushpcl(asu64(R1));
	return;
}

static void mc_genmcl_px_store(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1702;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1701;
L1702:
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = ax;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = bx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = ax;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L1701:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_add(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1705;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1707;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1707;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 52;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1706;
L1707:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1706:
	goto L1704;
L1705:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 65;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1704:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_sub(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1710;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1712;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1712;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1711;
L1712:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1711:
	goto L1709;
L1710:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 67;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1709:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_mul(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	i64 x;
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1715;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1717;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	goto L1716;
L1717:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1716:
	goto L1714;
L1715:
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 69;
	asu64(R4) = p;
	R5 = 3;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1714:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_div(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 71;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_eval(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_widen(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 ax;
	u64 bx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L1722;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1722;
	R1 = 0;
	R2 = 5;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1724;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1724:
	goto L1721;
L1722:
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = (u64)&pc_tables_psigned;
	asu64(R4) = p;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	if (!asu8(R3)) goto L1726;
	R3 = 18;
	goto L1725;
L1726:
	R3 = 19;
L1725:
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L1721:
	return;
}

static void mc_genmcl_px_jump(u64 p) {
    u64 R1, R2, R3; 
	i64 labno;
	u64 q;
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	labno = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	q = asu64(R1);
	goto L1729;
L1728:
	R1 = (u64)&q;
	(*tou64p(R1)) += 32;
L1729:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1728;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1732;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L1733;
	goto L1734;
L1732:
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = labno;
	if (asi64(R1) != asi64(R2)) goto L1736;
	goto L1727;
L1736:
	R1 = (u64)&q;
	(*tou64p(R1)) += 32;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) != asi64(R2)) goto L1738;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = labno;
	if (asi64(R1) != asi64(R2)) goto L1738;
	goto L1727;
L1738:
	goto L1731;
L1733:
	R1 = 0;
	asu64(R2) = q;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1731;
L1734:
L1731:
	R1 = 0;
	asi64(R2) = labno;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1727:
	return;
}

static void mc_genmcl_px_ijump(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_getopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_neg(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1742;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1741;
L1742:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_negreal(asu64(R2), asi64(R1));
L1741:
	return;
}

static void mc_genmcl_px_abs(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 lx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1745;
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	R3 = 13;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1744;
L1745:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_absreal(asu64(R2), asi64(R1));
L1744:
	return;
}

static void mc_genmcl_px_bitnot(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_not(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 3;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_toboolt(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	u64 cx;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1750;
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 3;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	cx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = bx;
	R3 = 76;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = cx;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 64;
	if (asi64(R3) != asi64(R4)) goto L1752;
	R3 = 5;
	goto L1751;
L1752:
	R3 = 4;
L1751:
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	R2 = 4;
	asu64(R3) = cx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	goto L1749;
L1750:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	R4 = 64;
	if (asi64(R3) != asi64(R4)) goto L1754;
	R3 = 5;
	goto L1753;
L1754:
	R3 = 4;
L1753:
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-3)) = asu8(R1);
L1749:
	return;
}

static void mc_genmcl_px_sqr(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1757;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1756;
L1757:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 69;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1756:
	return;
}

static void mc_genmcl_px_sqrt(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 63;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_jumpcc(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 mcond;
	u64 ax;
	u64 bx;
	u64 lx;
	R1 = (u64)&mc_genmcl_ucondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mcond = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	lx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1761;
	R1 = tou64("");
	R2 = tou64("JUMPCC/BLOCK");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L1760;
L1761:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1763;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	if (!asu64(R1)) goto L1765;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1765;
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1766;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1765;
L1766:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1764;
L1765:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1768;
	R1 = (u64)&mc_genmcl_scondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mcond = asi64(R1);
L1768:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1764:
	goto L1762;
L1763:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1762:
	R1 = 0;
	asu64(R2) = lx;
	asi64(R3) = mcond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (asi32(R1)) goto L1770;
	mc_stackmcl_poppcl();
L1770:
L1760:
	return;
}

static void mc_genmcl_px_jumpt(u64 p) {
    u64 R1, R2; 
	R1 = 5;
	asu64(R2) = p;
	mc_auxmcl_do_jumptruefalse(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_jumpf(u64 p) {
    u64 R1, R2; 
	R1 = 4;
	asu64(R2) = p;
	mc_auxmcl_do_jumptruefalse(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitand(u64 p) {
    u64 R1, R2; 
	R1 = 38;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitor(u64 p) {
    u64 R1, R2; 
	R1 = 39;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitxor(u64 p) {
    u64 R1, R2; 
	R1 = 40;
	asu64(R2) = p;
	mc_auxmcl_do_bitwise(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shl(u64 p) {
    u64 R1, R2; 
	R1 = 43;
	asu64(R2) = p;
	mc_auxmcl_do_shift(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shr(u64 p) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1779;
	R1 = 44;
	goto L1778;
L1779:
	R1 = 45;
L1778:
	asu64(R2) = p;
	mc_auxmcl_do_shift(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_retproc(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mclprocentry;
	asu64(R2) = mc_decls_mccodex;
	if (asu64(R1) != asu64(R2)) goto L1782;
	R1 = tou64("---");
	mc_libmcl_mgencomment(asu64(R1));
L1782:
	asu64(R1) = p;
	mc_auxmcl_do_procentry(asu64(R1));
	mc_auxmcl_do_procexit();
	return;
}

static void mc_genmcl_px_retfn(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1785;
	R1 = 0;
	R2 = 10;
	R3 = 1;
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = pc_decls_blockretname;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = ax;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = pc_decls_blockretname;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 6;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1785:
	asu64(R1) = p;
	mc_genmcl_px_retproc(asu64(R1));
	return;
}

static void mc_genmcl_px_setcall(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	mc_stackmcl_saveopnds(asi64(R1));
	asi64(R1) = mc_decls_ncalldepth;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L1788;
	R1 = tou64("");
	R2 = tou64("Too many nested calls");
	pc_api_merror(asu64(R2), asu64(R1));
L1788:
	R1 = (u64)&mc_decls_ncalldepth;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L1790;
	asi64(R1) = mc_decls_mstackdepth;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L1789;
L1790:
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asi64(R2) = mc_decls_mstackdepth;
	R3 = 0;
    asi64(R2) = Getdotindex(asu64(R2), asi64(R3));
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1789:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	R2 = (u64)&mc_decls_callblockret;
	asi64(R3) = mc_decls_ncalldepth;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_callblocksize;
	asi64(R3) = mc_decls_ncalldepth;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	R1 = (u64)&mc_decls_callalign;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L1792;
	R1 = 1;
	mc_libmcl_pushslots(asi64(R1));
L1792:
	return;
}

static void mc_genmcl_px_setarg(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mc_decls_callblockret;
	asi64(R3) = mc_decls_ncalldepth;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L1795;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1797;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 0;
	mc_auxmcl_copyblockarg(asu64(R3), asi64(R2), asi64(R1));
L1797:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	mc_stackmcl_pushopnd(asi64(R2), asi64(R1));
	goto L1794;
L1795:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1798;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_callargsize;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*16-16;
	asi64(R3) = n;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
L1798:
L1794:
	return;
}

static void mc_genmcl_px_callp(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 nargs;
	i64 nregargs;
	i64 slots;
	i64 isptr;
	i64 shadow;
	i64 blockret;
	i64 av_1;
	R1 = 0;
	isptr = asi64(R1);
	R1 = 0;
	shadow = asi64(R1);
	R1 = (u64)&mc_decls_callblockret;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	blockret = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = blockret;
	asi64(R1) += asi64(R2);
	nargs = asi64(R1);
	asi64(R1) = nargs;
	R2 = 4;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nregargs = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L1802;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L1801;
L1802:
	R1 = 1;
	isptr = asi64(R1);
L1801:
	asi64(R1) = isptr;
	asu64(R2) = p;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = nregargs;
	mc_auxmcl_do_pushlowargs(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	slots = asi64(R1);
	asi64(R1) = nargs;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L1804;
	asi64(R1) = mc_decls_mstackdepth;
	if (!asi64(R1)) goto L1806;
	R1 = 4;
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
	R1 = (u64)&mc_decls_callalign;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	goto L1805;
L1806:
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
L1805:
	goto L1803;
L1804:
	asi64(R1) = nargs;
	R2 = (u64)&mc_decls_callalign;
	asi64(R3) = mc_decls_ncalldepth;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	slots = asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
L1803:
	asi64(R1) = isptr;
	if (!asi64(R1)) goto L1808;
	R1 = 0;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	goto L1807;
L1808:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1807:
	asi64(R1) = nregargs;
	asi64(R2) = blockret;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1811;
L1809:
	mc_stackmcl_poppcl();
	if (--asi64(av_1)) goto L1809;
L1811:
	asi64(R1) = slots;
	if (!asi64(R1)) goto L1813;
	asi64(R1) = slots;
	mc_libmcl_popslots(asi64(R1));
L1813:
	asu8(R1) = mc_decls_pmode;
	if (!asu8(R1)) goto L1815;
	asu64(R1) = p;
	mc_auxmcl_do_getretvalue(asu64(R1));
L1815:
	R1 = (u64)&mc_decls_ncalldepth;
	(*toi64p(R1)) -=1;
	return;
}

static void mc_genmcl_px_jumpret(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	if (!asu8(R1)) goto L1818;
	asi64(R1) = mc_decls_noperands;
	if (!asi64(R1)) goto L1820;
	R1 = 1;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
L1820:
L1818:
	asu64(R1) = p;
	mc_genmcl_px_jump(asu64(R1));
	return;
}

static void mc_genmcl_px_jumpretm(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	i64 reg;
	i64 av_1;
	i64 av_2;
	asi64(R1) = mc_decls_noperands;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1824;
L1822:
	R1 = 0;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	if (--asi64(av_1)) goto L1822;
L1824:
	R1 = 1;
	reg = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1827;
L1825:
	asi64(R1) = reg;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1829;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1829;
	R1 = 11;
	reg = asi64(R1);
L1829:
	asi64(R1) = reg;
	mc_stackmcl_movetoreg(asi64(R1));
	mc_stackmcl_poppcl();
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	if (--asi64(av_2)) goto L1825;
L1827:
	asu64(R1) = p;
	mc_genmcl_px_jump(asu64(R1));
	return;
}

static void mc_genmcl_px_startmx(u64 p) {
    u64 R1; 
	R1 = 0;
	mc_stackmcl_saveopnds(asi64(R1));
	return;
}

static void mc_genmcl_px_resetmx(u64 p) {
    u64 R1, R2; 
	R1 = 1;
	mc_stackmcl_movetoreg(asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L1833;
	mc_stackmcl_poppcl();
L1833:
	return;
}

static void mc_genmcl_px_stop(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = 11;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = tou64("exit*");
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_incrto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_incr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_decrto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_incr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_incrload(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_incrload(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_decrload(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_incrload(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loadincr(u64 p) {
    u64 R1, R2, R3; 
	R1 = 28;
	R2 = 52;
	asu64(R3) = p;
	mc_auxmcl_do_loadincr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loaddecr(u64 p) {
    u64 R1, R2, R3; 
	R1 = 29;
	R2 = 53;
	asu64(R3) = p;
	mc_auxmcl_do_loadincr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_forup(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 14;
	R2 = 28;
	R3 = 52;
	asu64(R4) = p;
	mc_auxmcl_do_for(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fordown(u64 p) {
    u64 R1, R2, R3, R4; 
	R1 = 13;
	R2 = 29;
	R3 = 53;
	asu64(R4) = p;
	mc_auxmcl_do_for(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_iload(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 ax;
	u64 px;
	u64 nextpcl;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1845;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1847;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	goto L1846;
L1847:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
L1846:
	asu64(R1) = mc_decls_currpcl;
	R2 = 1;
	R1 += (i64)R2*32;
	nextpcl = asu64(R1);
	asu64(R1) = nextpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L1849;
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = nextpcl;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = (u64)&mc_decls_ploadop;
	asu64(R4) = nextpcl;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asu64(R1) = nextpcl;
	mc_decls_currpcl = asu64(R1);
	goto L1848;
L1849:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L1848:
	goto L1844;
L1845:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind_simp(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = px;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
L1844:
	return;
}

static i64 mc_genmcl_getsharereg(u64 ax, i64 mode) {
    u64 R1, R2; 
	u8 reg;
	u8 regix;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	reg = asu8(R1);
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	regix = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1852;
	R1 = 0;
	goto L1850;
L1852:
	asu8(R1) = reg;
	if (!asu8(R1)) goto L1854;
	R1 = (u64)&mc_decls_workregs;
	asu8(R2) = reg;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1855;
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L1854;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L1854;
L1855:
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	goto L1850;
	goto L1853;
L1854:
	asu8(R1) = regix;
	if (!asu8(R1)) goto L1856;
	R1 = (u64)&mc_decls_workregs;
	asu8(R2) = regix;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L1857;
	asu8(R1) = reg;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L1856;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L1856;
L1857:
	asu8(R1) = regix;
	R1 = toi64(tou8(R1));
	goto L1850;
L1856:
L1853:
	R1 = 0;
	goto L1850;
L1850:
	return asi64(R1);
}

static void mc_genmcl_px_iloadx(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 z;
	u64 nextpcl;
	u64 ax;
	u64 bx;
	u64 px;
	u64 fx;
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1860;
	R1 = 6;
	asu64(R2) = px;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 6;
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	goto L1859;
L1860:
	asu64(R1) = mc_decls_currpcl;
	R2 = 1;
	R1 += (i64)R2*32;
	nextpcl = asu64(R1);
	asu64(R1) = nextpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L1862;
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = nextpcl;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = (u64)&mc_decls_ploadop;
	asu64(R4) = nextpcl;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = nextpcl;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asu64(R1) = nextpcl;
	mc_decls_currpcl = asu64(R1);
	goto L1861;
L1862:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = px;
	asi64(R2) = mc_genmcl_getsharereg(asu64(R3), asi64(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
L1861:
L1859:
	return;
}

static void mc_genmcl_px_istore(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 bx;
	u64 px;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1865;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	goto L1864;
L1865:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
L1864:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1867;
	asu64(R1) = px;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = bx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = bx;
	asu64(R4) = px;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L1866;
L1867:
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1866:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_istorex(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 cx;
	u64 px;
	u64 z;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1870;
	asu64(R1) = px;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	px = asu64(R1);
	R1 = 6;
	asu64(R2) = cx;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	cx = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asu64(R3) = cx;
	asu64(R4) = px;
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L1869;
L1870:
	asu64(R1) = cx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1869:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_storem(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 z;
	u64 dblock;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1873;
	R1 = tou64("");
	R2 = tou64("Storem not 16");
	pc_api_merror(asu64(R2), asu64(R1));
L1873:
	R1 = 16;
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	R2 = 0;
	R3 = 8;
	asu64(R4) = px;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = px;
	R2 = 6;
	asu64(R3) = bx;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = bx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_addpx(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 cx;
	asu64(R1) = p;
	asu64(R1) = mc_auxmcl_do_addrmode(asu64(R1));
	cx = asu64(R1);
	R1 = 6;
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = ax;
	mc_auxmcl_dolea(asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = 6;
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_subpx(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 scale;
	i64 extra;
	i64 offset;
	u64 ax;
	u64 bx;
	u64 z;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	extra = asi64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L1877;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R3) = extra;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1876;
L1877:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = scale;
	asu64(R2) = bx;
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L1879;
	asi64(R1) = scale;
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
L1879:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = extra;
	if (!asi64(R1)) goto L1881;
	msysc_m$print_startcon();
	R1 = tou64("EXTRA=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = extra;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("SUBREF/EXTRA");
	pc_api_merror(asu64(R2), asu64(R1));
L1881:
L1876:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_to(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 ax;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = R1;
	mc_decls_currpcl = asu64(R2);
	q = asu64(R1);
	R1 = 6;
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_iswap(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 qx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	qx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1885;
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = qx;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = qx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1884;
L1885:
	R1 = tou64("");
	R2 = tou64("swap/block");
	pc_api_merror(asu64(R2), asu64(R1));
L1884:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_swapstk(u64 p) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = mc_decls_noperands;
	asu64(R2) = p;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_noperands;
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_labeldef(u64 p) {
    u64 R1, R2; 
	struct $B5 str;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(":");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_genmcl_px_addto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 65;
	R2 = 28;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_subto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 67;
	R2 = 29;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_multo(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 cx;
	u64 x;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1892;
	R1 = 69;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	goto L1890;
L1892:
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1894;
	R1 = tou64("");
	R2 = tou64("multo/byte");
	pc_api_merror(asu64(R2), asu64(R1));
L1894:
	R1 = 0;
	R2 = 10;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	x = asu64(R2);
	if (!asu64(R1)) goto L1896;
	asu64(R1) = x;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = cx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	goto L1895;
L1896:
	asu64(R1) = bx;
	asu64(R2) = cx;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1895:
	asu64(R1) = cx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
L1890:
	return;
}

static void mc_genmcl_px_bitandto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 38;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitorto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 39;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitxorto(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 40;
	asu64(R3) = p;
	mc_auxmcl_do_binto(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shlto(u64 p) {
    u64 R1, R2; 
	R1 = 43;
	asu64(R2) = p;
	mc_auxmcl_do_shiftnto(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_shrto(u64 p) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1903;
	R1 = 44;
	goto L1902;
L1903:
	R1 = 45;
L1902:
	asu64(R2) = p;
	mc_auxmcl_do_shiftnto(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fix(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 fx;
	u64 ax;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = (u64)&pc_tables_pmin;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = fx;
	asu64(R2) = ax;
	R3 = 84;
	asu64(R4) = p;
	R5 = 28;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 0;
	R6 = 7;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_float(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 fx;
	i64 lab;
	i64 lab2;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L1907;
	R1 = tou64("");
	R2 = tou64("float/short");
	pc_api_merror(asu64(R2), asu64(R1));
L1907:
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1909;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 86;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L1908;
L1909:
	asu8(R1) = pmode2;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L1910;
	R1 = 0;
	R2 = 2;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 2;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab = asi64(R1);
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab2 = asi64(R1);
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 12;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab2;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = lab;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
	asi64(R1) = mc_decls_labmask63;
	if (asi64(R1)) goto L1912;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_labmask63 = asi64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_laboffset64 = asi64(R1);
L1912:
	asi64(R1) = mc_decls_labmask63;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_laboffset64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = fx;
	R3 = 66;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = lab2;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
// mc_genmcl.px_float.reduce:
L1913:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1915;
	asu64(R1) = fx;
	R2 = 4;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 88;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L1915:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L1908;
L1910:
	R1 = 0;
	R2 = 2;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 2;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = fx;
	R3 = 87;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1913;
L1908:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_idiv(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_irem(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_idivrem(u64 p) {
    u64 R1, R2, R3; 
	R1 = 2;
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = p;
	mc_auxmcl_do_divrem(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_clear(u64 p) {
    u64 R1, R2; 
	u64 ax;
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind_simp(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = ax;
	mc_auxmcl_clearblock(asu64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_subp(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	i64 n;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L1922;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mc_libmcl_ispoweroftwo(asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L1924;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1923;
L1924:
	msysc_m$print_startcon();
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("");
	R2 = tou64("SUB/REF NOT POWER OF xx");
	pc_api_merror(asu64(R2), asu64(R1));
L1923:
L1922:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_switch(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 minlab;
	i64 maxlab;
	i64 jumplab;
	i64 elselab;
	i64 reg;
	u64 ax;
	u64 bx;
	u64 ax2;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	minlab = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	maxlab = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	jumplab = asi64(R1);
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	mc_decls_currpcl = asu64(R1);
	asu64(R1) = mc_decls_currpcl;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	elselab = asi64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L1927;
	asu64(R1) = ax;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	ax2 = asu64(R3);
	R3 = 18;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax2;
	ax = asu64(R1);
L1927:
	asi64(R1) = minlab;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1929;
	R1 = 10;
	asi64(R2) = minlab;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1929:
	R1 = 10;
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = elselab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 3;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1931;
	asi64(R1) = mc_stackmcl_getworkireg();
	reg = asi64(R1);
	R1 = 6;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = jumplab;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = bx;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 0;
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asi64(R8) = reg;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1930;
L1931:
	R1 = 0;
	R2 = 0;
	asi64(R3) = jumplab;
	R4 = 0;
	R5 = 0;
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	R8 = 0;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1930:
	mc_stackmcl_poppcl();
	R1 = 1;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_switchu(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 minlab;
	i64 maxlab;
	i64 jumplab;
	i64 reg;
	u64 ax;
	u64 bx;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	minlab = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	maxlab = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	jumplab = asi64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1934;
	asi64(R1) = mc_stackmcl_getworkireg();
	reg = asi64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = jumplab;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = bx;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asi64(R5) = minlab;
	asi64(R5) = -asi64(R5);
	R6 = 8;
	asi64(R5) *= asi64(R6);
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asi64(R8) = reg;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L1933;
L1934:
	R1 = 0;
	R2 = 0;
	asi64(R3) = jumplab;
	R4 = 0;
	asi64(R5) = minlab;
	asi64(R5) = -asi64(R5);
	R6 = 8;
	asi64(R5) *= asi64(R6);
	R6 = 8;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	R8 = 0;
	asu64(R2) = mc_libmcl_mgenindex(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asu64(R2));
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1933:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_swlabel(u64 p) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_endsw(u64 p) {
    u64 R1, R2; 
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fwiden(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 fx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = fx;
	R2 = 8;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 89;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genmcl_px_fnarrow(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 fx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	fx = asu64(R1);
	asu64(R1) = fx;
	R2 = 4;
	asu64(R3) = fx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 88;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genmcl_px_truncate(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u8 pmode2;
	asu64(R1) = p;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	pmode2 = asu8(R1);
	R1 = 0;
	asu8(R2) = pmode2;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&pc_tables_psize;
	asu8(R3) = pmode2;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L1941;
	asu64(R1) = ax;
	R2 = (u64)&pc_tables_psize;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = (u64)&mc_decls_ploadop;
	asu8(R4) = pmode2;
	R4 = toi64(tou8(R4));
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1941:
	return;
}

static void mc_genmcl_px_typepun(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_unload(u64 p) {
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_loadbit(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 z;
	i64 i;
	i64 m;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L1946;
	asu64(R1) = z;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1948;
	R2 = 31;
	if (asi64(R1) > asi64(R2)) goto L1948;
	R1 = 5;
	goto L1947;
L1948:
	R1 = 6;
L1947:
	m = asi64(R1);
	R1 = 0;
	asi64(R2) = m;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = i;
	if (!asi64(R1)) goto L1950;
	asi64(R1) = m;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L1952;
	goto L1953;
L1952:
L1950:
	goto L1945;
L1946:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L1955;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1955:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L1957;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L1957:
L1945:
	R1 = 5;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
// mc_genmcl.px_loadbit.skip:
L1953:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_assem(u64 p) {
    u64 R1, R2; 
	asu64(R1) = pc_api_idomcl_assem;
	if (!asu64(R1)) goto L1960;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_api_idomcl_assem;
	((F18)R2)(asu64(R1));
	goto L1959;
L1960:
	R1 = tou64("");
	R2 = tou64("No Assem handler");
	pc_api_merror(asu64(R2), asu64(R1));
L1959:
	return;
}

static void mc_genmcl_px_sin(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("sin*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_cos(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("cos*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_tan(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("tan*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_asin(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("asin*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_acos(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("acos*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_atan(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("atan*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_log(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("log*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_log10(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("log10*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_exp(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("exp*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_round(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("round*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_floor(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("floor*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_ceil(u64 p) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = tou64("ceil*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_atan2(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("atan2*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_fmod(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("fmod*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_setcc(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 cond;
	u64 ax;
	u64 bx;
	u64 cx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = (u64)&mc_genmcl_ucondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1977;
	R1 = tou64("");
	R2 = tou64("setcc/block");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L1976;
L1977:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1978;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1980;
	R1 = (u64)&mc_genmcl_scondcodes;
	asu64(R2) = p;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
L1980:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	cx = asu64(R1);
	goto L1976;
L1978:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 3;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	cx = asu64(R1);
	R1 = 10;
	asu64(R2) = cx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
L1976:
	R1 = 0;
	asu64(R2) = cx;
	asi64(R3) = cond;
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	R2 = 4;
	asu64(R3) = cx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_min(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1983;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1985;
	R1 = 15;
	goto L1984;
L1985:
	R1 = 7;
L1984:
	mc_auxmcl_do_max_int(asi64(R1));
	goto L1982;
L1983:
	R1 = 112;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	mc_auxmcl_do_max_float(asi64(R1));
L1982:
	return;
}

static void mc_genmcl_px_max(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1988;
	R1 = (u64)&pc_tables_psigned;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1990;
	R1 = 12;
	goto L1989;
L1990:
	R1 = 2;
L1989:
	mc_auxmcl_do_max_int(asi64(R1));
	goto L1987;
L1988:
	R1 = 113;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	mc_auxmcl_do_max_float(asi64(R1));
L1987:
	return;
}

static void mc_genmcl_px_power(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 d;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1993;
	R1 = 82;
	asu64(R1) = mc_auxmcl_gethostfn(asi64(R1));
	d = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	asu64(R2) = d;
	asu64(R3) = p;
	mc_auxmcl_do_host(asu64(R3), asu64(R2), asi64(R1));
	goto L1992;
L1993:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 2;
	R2 = tou64("pow*");
	asu64(R3) = p;
	mc_auxmcl_do_maths(asu64(R3), asu64(R2), asi64(R1));
L1992:
	return;
}

static void mc_genmcl_px_minto(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L1996;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L1998;
	R2 = 14;
	goto L1997;
L1998:
	R2 = 6;
L1997:
	mc_auxmcl_do_maxto_int(asi64(R2), asi64(R1));
	goto L1995;
L1996:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 6;
	mc_auxmcl_do_maxto_real(asi64(R2), asi64(R1));
L1995:
	return;
}

static void mc_genmcl_px_maxto(u64 p) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2001;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&pc_tables_psigned;
	asu8(R3) = mc_decls_pmode;
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L2003;
	R2 = 13;
	goto L2002;
L2003:
	R2 = 3;
L2002:
	mc_auxmcl_do_maxto_int(asi64(R2), asi64(R1));
	goto L2000;
L2001:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 3;
	mc_auxmcl_do_maxto_real(asi64(R2), asi64(R1));
L2000:
	return;
}

static void mc_genmcl_px_negto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	u64 fx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2006;
	R1 = 0;
	asu64(R2) = px;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2005;
L2006:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	fx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = fx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = fx;
	mc_auxmcl_do_negreal(asu64(R2), asi64(R1));
	asu64(R1) = fx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2005:
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_absto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 ax;
	u64 lx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2009;
	R1 = 10;
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	R3 = 13;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2008;
L2009:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	mc_auxmcl_do_absreal(asu64(R2), asi64(R1));
L2008:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_addpxto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 z;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L2012;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2011;
L2012:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2011:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_subpxto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 z;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	R2 = R1;
	z = asu64(R2);
	if (!asu64(R1)) goto L2015;
	R1 = 10;
	asu64(R2) = z;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2014;
L2015:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = bx;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L2017;
	R1 = tou64("");
	R2 = tou64("SUBTOREF/EXTRA");
	pc_api_merror(asu64(R2), asu64(R1));
L2017:
L2014:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_divto(u64 p) {
    u64 R1, R2; 
	R1 = 71;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_bitnotto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	u64 fx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asu64(R2) = px;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_notto(u64 p) {
    u64 R1, R2, R3; 
	u64 px;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 3;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = px;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_toboolto(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 px;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	R3 = 5;
	R4 = 58;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 19;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genmcl_px_sign(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	u64 lx1;
	u64 lx2;
	u64 lx3;
	u8 gtop;
	u8 ltop;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 10;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	mc_libmcl_clearreg(asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2024;
	R1 = 7;
	gtop = asu8(R1);
	R1 = 2;
	ltop = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asr64(R2) = 0.000000000000000000e+000;
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2023;
L2024:
	R1 = 15;
	gtop = asu8(R1);
	R1 = 12;
	ltop = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 0;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2023:
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx1 = asu64(R3);
	asu8(R3) = gtop;
	R3 = toi64(tou8(R3));
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx2 = asu64(R3);
	asu8(R3) = ltop;
	R3 = toi64(tou8(R3));
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&pc_api_mlabelno;
	asi64(R2) = *(toi64p(R2)) += 1;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx3 = asu64(R3);
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx1;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = bx;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx3;
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx2;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = bx;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx3;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	asu64(R2) = bx;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_setnewzz(asi64(R2), asi64(R1));
	return;
}

static void mc_genmcl_px_loadbf(u64 p) {
    u64 R1, R2, R3; 
	u64 y;
	u64 z;
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	y = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	z = asu64(R1);
	asu64(R1) = y;
	if (!asu64(R1)) goto L2027;
	asu64(R1) = z;
	if (!asu64(R1)) goto L2027;
	asu64(R1) = z;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	mc_auxmcl_do_loadbf_const(asu64(R3), asi64(R2), asi64(R1));
	goto L2026;
L2027:
	asu64(R1) = p;
	mc_auxmcl_do_loadbf_var(asu64(R1));
L2026:
	return;
}

static void mc_genmcl_px_storebit(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_auxmcl_do_storebit(asu64(R1));
	return;
}

static void mc_genmcl_px_storebf(u64 p) {
    u64 R1; 
	asu64(R1) = p;
	mc_auxmcl_do_storebf(asu64(R1));
	return;
}

static void mc_genmcl_px_loadall(u64 p) {
	mc_stackmcl_checkallloaded();
	return;
}

static void mc_genmcl_px_setjmp(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	i64 lab;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	lab = asi64(R1);
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	R2 = 6;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = lab;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dstackopnd;
	R2 = 0;
	R3 = 8;
	asu64(R4) = bx;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dframeopnd;
	R2 = 0;
	R3 = 16;
	asu64(R4) = bx;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	asu64(R1) = ax;
	mc_libmcl_clearreg(asu64(R1));
	asu64(R1) = p;
	mc_stackmcl_freeworkregs(asu64(R1));
	R1 = 1;
	mc_stackmcl_movetoreg(asi64(R1));
	asi64(R1) = lab;
	mc_libmcl_mdefinefwdlabel(asi64(R1));
	return;
}

static void mc_genmcl_px_longjmp(u64 p) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 cx;
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 6;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 16;
	asu64(R3) = ax;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 6;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	R1 = 1;
	mc_stackmcl_swapopndregs(asi64(R1));
	R1 = 0;
	asu64(R2) = cx;
	R3 = 25;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_genmcl_px_initdswx(u64 p) {
	return;
}

static void mc_auxmcl_allocregvars(i64 skipparams, i64 isleaf) {
    u64 R1, R2, R3; 
	struct $B18 params;
	struct $B18 xparams;
	struct $B18 leafparams;
	struct $B18 xleafparams;
	u32 leafparamno;
	u32 xleafparamno;
	struct $B16 locals;
	struct $B16 xlocals;
	i64 nparams;
	i64 nxparams;
	i64 nleafparams;
	i64 nxleafparams;
	i64 nlocals;
	i64 nxlocals;
	i64 n;
	i64 reg;
	i64 xreg;
	i64 nl;
	i64 np;
	i64 nlx;
	i64 npx;
	u64 d;
	i64 i;
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	nxparams = asi64(R1);
	R1 = 0;
	nleafparams = asi64(R1);
	R1 = 0;
	nxleafparams = asi64(R1);
	R1 = 0;
	nlocals = asi64(R1);
	R1 = 0;
	nxlocals = asi64(R1);
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = mc_decls_maxxregvars;
	asi64(R1) += asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2036;
	goto L2034;
L2036:
	asi64(R1) = skipparams;
	if (asi64(R1)) goto L2038;
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L2042;
L2039:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2044;
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2044;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2044;
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L2044;
	asi64(R1) = isleaf;
	if (asi64(R1)) goto L2046;
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2048;
	asi64(R1) = nparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2050;
	asu64(R1) = d;
	R2 = (u64)&params;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2050:
	goto L2047;
L2048:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2051;
	asi64(R1) = nxparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2053;
	asu64(R1) = d;
	R2 = (u64)&xparams;
	R3 = (u64)&nxparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2053:
L2051:
L2047:
	goto L2045;
L2046:
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2055;
	asi64(R1) = nleafparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2057;
	asu64(R1) = d;
	R2 = (u64)&leafparams;
	R3 = (u64)&nleafparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&leafparamno;
	asi64(R3) = nleafparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2057:
	goto L2054;
L2055:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2058;
	asi64(R1) = nxleafparams;
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L2060;
	asu64(R1) = d;
	R2 = (u64)&xleafparams;
	R3 = (u64)&nxleafparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&xleafparamno;
	asi64(R3) = nxleafparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2060:
L2058:
L2054:
L2045:
L2044:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2042:
	asu64(R1) = d;
	if (asu64(R1)) goto L2039;
L2038:
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L2064;
L2061:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2066;
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2066;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2066;
	R1 = (u64)&pc_tables_pint;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2068;
	asi64(R1) = nlocals;
	R2 = 32;
	if (asi64(R1) >= asi64(R2)) goto L2070;
	asu64(R1) = d;
	R2 = (u64)&locals;
	R3 = (u64)&nlocals;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2070:
	goto L2067;
L2068:
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2071;
	asi64(R1) = nxlocals;
	R2 = 32;
	if (asi64(R1) >= asi64(R2)) goto L2071;
	asu64(R1) = d;
	R2 = (u64)&xlocals;
	R3 = (u64)&nxlocals;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2071:
L2067:
L2066:
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2064:
	asu64(R1) = d;
	if (asu64(R1)) goto L2061;
	asi64(R1) = nlocals;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2073;
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = nparams;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	np = asi64(R1);
	R1 = 0;
	nl = asi64(R1);
	goto L2072;
L2073:
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2074;
	asi64(R1) = mc_decls_maxregvars;
	asi64(R2) = nlocals;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nl = asi64(R1);
	R1 = 0;
	np = asi64(R1);
	goto L2072;
L2074:
	asi64(R1) = nlocals;
	nl = asi64(R1);
	asi64(R1) = nparams;
	np = asi64(R1);
	asi64(R1) = np;
	asi64(R2) = nl;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_maxregvars;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2076;
	R1 = (u64)&np;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2078;
	asi64(R1) = np;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2078;
	R1 = (u64)&np;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L2078:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2080;
	asi64(R1) = n;
	R2 = (u64)&nl;
	*toi64p(R2) -= asi64(R1);
L2080:
L2076:
L2072:
	R1 = 4;
	reg = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nl;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2083;
L2081:
	R1 = (u64)&locals;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	i += 1; if (i <= nl) goto L2081;
L2083:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = np;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2086;
L2084:
	R1 = (u64)&params;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) += 1;
	i += 1; if (i <= np) goto L2084;
L2086:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nleafparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2089;
L2087:
	R1 = (u64)&leafparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	R1 = (u64)&leafparamno;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 11;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	reg = asi64(R1);
	asi64(R1) = reg;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2091;
	R1 = 1;
	pc_decls_r10used = asu8(R1);
L2091:
	asi64(R1) = reg;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L2093;
	R1 = 1;
	pc_decls_r11used = asu8(R1);
L2093:
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= nleafparams) goto L2087;
L2089:
	asi64(R1) = nxlocals;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2095;
	asi64(R1) = mc_decls_maxxregvars;
	asi64(R2) = nxparams;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	npx = asi64(R1);
	R1 = 0;
	nlx = asi64(R1);
	goto L2094;
L2095:
	asi64(R1) = nxparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2096;
	asi64(R1) = mc_decls_maxxregvars;
	asi64(R2) = nxlocals;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	nlx = asi64(R1);
	R1 = 0;
	npx = asi64(R1);
	goto L2094;
L2096:
	asi64(R1) = nxlocals;
	nlx = asi64(R1);
	asi64(R1) = nxparams;
	npx = asi64(R1);
	asi64(R1) = npx;
	asi64(R2) = nlx;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_maxregvars;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2098;
	R1 = (u64)&npx;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2100;
	asi64(R1) = npx;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2100;
	R1 = (u64)&npx;
	(*toi64p(R1)) -=1;
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L2100:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2102;
	asi64(R1) = n;
	R2 = (u64)&nlx;
	*toi64p(R2) -= asi64(R1);
L2102:
L2098:
L2094:
	R1 = 16;
	reg = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nlx;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2105;
L2103:
	R1 = (u64)&xlocals;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) -=1;
	i += 1; if (i <= nlx) goto L2103;
L2105:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = npx;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2108;
L2106:
	R1 = (u64)&xparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&reg;
	(*toi64p(R1)) -=1;
	i += 1; if (i <= npx) goto L2106;
L2108:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nxleafparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2111;
L2109:
	R1 = (u64)&xleafparams;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	R1 = (u64)&xleafparamno;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	reg = asi64(R1);
	asi64(R1) = reg;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= nxleafparams) goto L2109;
L2111:
L2034:
	return;
}

static void mc_auxmcl_initproc(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 e;
	u64 pinfi;
	i64 reg;
	i64 xreg;
	i64 n;
	i64 r;
	i64 npregs;
	i64 av_1;
	i64 av_2;
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_workregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_workxregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_isregvar;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_isxregvar;
	memset(R1, 0, 16);
	R1 = 3;
	mc_decls_nworkregs = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 2;
	mc_decls_nworkxregs = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	mc_decls_maxxregvars = asi64(R2);
	mc_decls_maxregvars = asi64(R1);
	R1 = 0;
	npregs = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_decls_pinfo = asu64(R1);
	asu64(R1) = pc_decls_pinfo;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2114;
	R1 = 10;
	mc_decls_nworkregs = asi64(R1);
	R1 = 12;
	mc_decls_nworkxregs = asi64(R1);
	R1 = 4;
	r = asi64(R1);
L2115:
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	r += 1; if (r <= 10) goto L2115;
	R1 = 7;
	r = asi64(R1);
L2118:
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	r += 1; if (r <= 16) goto L2118;
	goto L2113;
L2114:
	R1 = 4;
	asu64(R2) = pc_decls_currfunc;
	R3 = 112;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = pc_decls_pinfo;
	R4 = 4;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R2) = Max(asi64(R2), asi64(R3));
	asi64(R1) = Min(asi64(R1), asi64(R2));
	npregs = asi64(R1);
	R1 = 4;
	mc_decls_nworkregs = asi64(R1);
	asu64(R1) = pc_decls_pinfo;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2122;
	R1 = (u64)&mc_decls_nworkregs;
	(*toi64p(R1)) += 1;
L2122:
	R1 = 5;
	mc_decls_nworkxregs = asi64(R1);
	asi64(R1) = mc_decls_nworkregs;
	R2 = 3;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = npregs;
	R2 = 3;
	if (asi64(R1) > asi64(R2)) goto L2124;
	asi64(R1) = n;
	if (!asi64(R1)) goto L2124;
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
	asi64(R1) = npregs;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2126;
	asi64(R1) = n;
	if (!asi64(R1)) goto L2126;
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) -=1;
L2126:
L2124:
	R1 = 10;
	r = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2129;
L2127:
	R1 = 1;
	R2 = (u64)&mc_decls_workregs;
	R3 = (u64)&r;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) -= 1; asi64(R3) = asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	if (--asi64(av_1)) goto L2127;
L2129:
	R1 = 7;
	r = asi64(R1);
	asi64(R1) = mc_decls_nworkxregs;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2132;
L2130:
	R1 = 1;
	R2 = (u64)&mc_decls_workxregs;
	R3 = (u64)&r;
	asi64(R4) = *toi64p(R3); *(toi64p(R3)) += 1; asi64(R3) = asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	if (--asi64(av_2)) goto L2130;
L2132:
L2113:
	R1 = 4;
	r = asi64(R1);
L2133:
	R1 = (u64)&mc_decls_workregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2137;
	R1 = (u64)&mc_decls_maxregvars;
	(*toi64p(R1)) += 1;
L2137:
	r += 1; if (r <= 10) goto L2133;
	R1 = 7;
	r = asi64(R1);
L2138:
	R1 = (u64)&mc_decls_workxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2142;
	R1 = (u64)&mc_decls_maxxregvars;
	(*toi64p(R1)) += 1;
L2142:
	r += 1; if (r <= 16) goto L2138;
	R1 = (u64)&mc_decls_usedregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_usedxregs;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_pcltempflags;
	memset(R1, 0, 50);
	R1 = 0;
	R2 = R1;
	pc_decls_r11used = asu8(R2);
	pc_decls_r10used = asu8(R1);
	R1 = 0;
	mc_decls_mstackdepth = asi64(R1);
	R1 = 0;
	mc_decls_noperands = asi64(R1);
	R1 = 0;
	R2 = R1;
	mc_genmcl_framebytes = asi64(R2);
	R2 = R1;
	mc_genmcl_paramoffset = asi64(R2);
	mc_genmcl_frameoffset = asi64(R1);
	R1 = 0;
	pc_decls_localshadow = asu8(R1);
	R1 = 0;
	mc_decls_nblocktemps = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2144;
	R1 = 8;
	R2 = tou64("$1x");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = e;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 5;
	asu64(R2) = e;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = e;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	asu64(R2) = pc_decls_currfunc;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	pc_decls_blockretname = asu64(R1);
L2144:
	asu8(R1) = pc_decls_fregoptim;
	if (!asu8(R1)) goto L2147;
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L2146;
L2147:
	goto L2112;
L2146:
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2149;
	goto L2112;
L2149:
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc_decls_currfunc;
	R3 = 110;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (asu8(R2)) goto L2150;
	asu64(R2) = pc_decls_currfunc;
	R3 = 113;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	if (!asu8(R2)) goto L2151;
L2150:
	R2 = 1;
	goto L2152;
L2151:
	R2 = 0;
L2152:
	mc_auxmcl_allocregvars(asi64(R2), asi64(R1));
L2112:
	return;
}

static void mc_auxmcl_do_procentry(u64 p) {
    u64 R1, R2, R3; 
	i64 retmode;
	i64 ntemps;
	i64 hasequiv;
	i64 offset;
	i64 size;
	i64 reg;
	u64 ax;
	u64 d;
	struct $B5 str;
	struct $B5 newname;
	i64 rr;
	i64 ff;
	i64 r;
	i64 i;
	asu64(R1) = mc_decls_mclprocentry;
	mc_auxmcl_setmclentry(asu64(R1));
	R1 = 0;
	R2 = R1;
	pc_decls_bxspill = asi64(R2);
	pc_decls_bspill = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2156;
	asu64(R1) = pc_decls_currfunc;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2155;
L2156:
	R1 = 4;
	r = asi64(R1);
L2157:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2162;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2161;
L2162:
	R1 = (u64)&pc_decls_bspill;
	(*toi64p(R1)) += 1;
L2161:
	r += 1; if (r <= 10) goto L2157;
	R1 = 7;
	r = asi64(R1);
L2163:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2168;
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2167;
L2168:
	R1 = (u64)&pc_decls_bxspill;
	(*toi64p(R1)) += 1;
L2167:
	r += 1; if (r <= 16) goto L2163;
L2155:
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L2172;
L2169:
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2174;
	R1 = tou64("");
	R2 = tou64("@PARAM");
	pc_api_merror(asu64(R2), asu64(R1));
L2174:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2176;
	asi64(R1) = mc_genmcl_paramoffset;
	R2 = 16;
	asi64(R1) += asi64(R2);
	asi64(R2) = pc_decls_bspill;
	asi64(R3) = pc_decls_bxspill;
	asi64(R2) += asi64(R3);
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = d;
	asu64(R2) = mc_writenasm_getdispname(asu64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2175;
L2176:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	rr = asi64(R1);
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	ff = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = rr;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = d;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 6;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = rr;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = ff;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2175:
	R1 = 8;
	R2 = (u64)&mc_genmcl_paramoffset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2172:
	asu64(R1) = d;
	if (asu64(R1)) goto L2169;
	asu64(R1) = pc_decls_currfunc;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	retmode = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L2180;
L2177:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2182;
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	size = asi64(R1);
L2182:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2184;
	goto L2178;
L2184:
	asu64(R1) = d;
	R2 = 91;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2186;
	R1 = 1;
	hasequiv = asi64(R1);
	goto L2185;
L2186:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2187;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	rr = asi64(R1);
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	ff = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = rr;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = d;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 6;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = rr;
	asu64(R2) = d;
	R3 = 90;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = ff;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2185;
L2187:
	asi64(R1) = size;
	asi64(R1) = mc_libmcl_roundsizetg(asi64(R1));
	R2 = (u64)&mc_genmcl_frameoffset;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = mc_genmcl_frameoffset;
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = d;
	asu64(R2) = mc_writenasm_getdispname(asu64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2185:
L2178:
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2180:
	asu64(R1) = d;
	if (asu64(R1)) goto L2177;
	R1 = 0;
	ntemps = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L2188:
	R1 = (u64)&mc_decls_pcltempflags;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2192;
	R1 = (u64)&ntemps;
	(*toi64p(R1)) += 1;
	R1 = 8;
	R2 = (u64)&mc_genmcl_frameoffset;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&mc_decls_pcltempopnds;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ax = asu64(R1);
	asi64(R1) = mc_genmcl_frameoffset;
	asu64(R2) = ax;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	asu64(R2) = ax;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asi64(R2) = i;
	asu64(R3) = pc_decls_currfunc;
	asu64(R2) = mc_writenasm_gettempname(asu64(R3), asi64(R2));
	asu64(R2) = mc_libmcl_mgenname(asu64(R2));
	R3 = 5;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2192:
	i += 1; if (i <= 50) goto L2188;
	asu64(R1) = pc_decls_currfunc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2194;
	asu64(R1) = pc_decls_currfunc;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (asi16(R1)) goto L2197;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2196;
L2197:
	R1 = tou64("");
	R2 = tou64("Threaded proc has locals/params");
	pc_api_merror(asu64(R2), asu64(R1));
L2196:
	asi64(R1) = ntemps;
	if (!asi64(R1)) goto L2199;
	R1 = tou64("");
	R2 = tou64("Threaded proc has temps");
	pc_api_merror(asu64(R2), asu64(R1));
L2199:
	asu64(R1) = mc_auxmcl_resetmclentry();
	goto L2153;
L2194:
	asi64(R1) = mc_genmcl_frameoffset;
	asi64(R1) = -asi64(R1);
	mc_genmcl_framebytes = asi64(R1);
	asi64(R1) = pc_decls_bspill;
	asi64(R2) = pc_decls_bxspill;
	asi64(R1) += asi64(R2);
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2201;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L2203;
	R1 = 8;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L2203:
	goto L2200;
L2201:
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L2205;
	R1 = 8;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L2205:
L2200:
	asu8(R1) = pc_decls_localshadow;
	if (!asu8(R1)) goto L2207;
	R1 = 32;
	R2 = (u64)&mc_genmcl_framebytes;
	*toi64p(R2) += asi64(R1);
L2207:
	asi64(R1) = pc_decls_bspill;
	if (!asi64(R1)) goto L2209;
	R1 = 4;
	r = asi64(R1);
L2210:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2215;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2214;
L2215:
	R1 = 0;
	R2 = 6;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2214:
	r += 1; if (r <= 10) goto L2210;
L2209:
	asi64(R1) = pc_decls_bxspill;
	if (!asi64(R1)) goto L2217;
	R1 = 6;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 7;
	r = asi64(R1);
L2218:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2223;
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2222;
L2223:
	R1 = 8;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ax;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2222:
	r += 1; if (r <= 16) goto L2218;
L2217:
	R1 = tou64("?]]");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_mccodex;
	mc_auxmcl_mclframesetup = asu64(R1);
	mc_auxmcl_spillparams();
	R1 = tou64("---------------");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_auxmcl_resetmclentry();
L2153:
	return;
}

static void mc_auxmcl_do_procexit() {
    u64 R1, R2, R3; 
	u64 ax;
	i64 offset;
	i64 r;
	R1 = tou64("---------------");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2226;
	R1 = 0;
	R2 = 0;
	R3 = 22;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2224;
L2226:
	asu64(R1) = mc_auxmcl_mclframesetup;
	mc_auxmcl_setmclentryf(asu64(R1));
	asi64(R1) = mc_genmcl_framebytes;
	if (asi64(R1)) goto L2229;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2228;
L2229:
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2231;
	R1 = 0;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_dstackopnd;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = mc_genmcl_framebytes;
	mc_libmcl_pushstack(asi64(R1));
	goto L2230;
L2231:
	asi64(R1) = mc_genmcl_framebytes;
	if (!asi64(R1)) goto L2233;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) += asi64(R2);
	mc_libmcl_pushstack(asi64(R1));
L2233:
L2230:
L2228:
	asu64(R1) = mc_auxmcl_resetmclentryf();
	asi64(R1) = mc_genmcl_framebytes;
	if (asi64(R1)) goto L2236;
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2235;
L2236:
	R1 = (u64)&mc_decls_usedregs;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2238;
	asi64(R1) = mc_genmcl_framebytes;
	mc_libmcl_popstack(asi64(R1));
	R1 = 0;
	asu64(R2) = mc_decls_dframeopnd;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2237;
L2238:
	asi64(R1) = mc_genmcl_framebytes;
	if (!asi64(R1)) goto L2240;
	asi64(R1) = mc_genmcl_framebytes;
	R2 = 8;
	asi64(R1) += asi64(R2);
	mc_libmcl_popstack(asi64(R1));
L2240:
L2237:
L2235:
	asi64(R1) = pc_decls_bxspill;
	if (!asi64(R1)) goto L2242;
	R1 = 6;
	R2 = 11;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 16;
	r = asi64(R1);
L2243:
	R1 = (u64)&mc_decls_usedxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2247;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	R2 = 8;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenxreg(asi64(R3), asi64(R2));
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2247:
	r += -1; if (r >= 7) goto L2243;
L2242:
	asi64(R1) = pc_decls_bspill;
	if (!asi64(R1)) goto L2249;
	R1 = 10;
	r = asi64(R1);
L2250:
	R1 = (u64)&mc_decls_usedregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2254;
	R1 = 0;
	R2 = 6;
	asi64(R3) = r;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2254:
	r += -1; if (r >= 4) goto L2250;
L2249:
	R1 = 0;
	R2 = 0;
	R3 = 22;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2224:
	return;
}

static void mc_auxmcl_spillparams() {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 d;
	u64 ax;
	i64 offset;
	i64 regoffset;
	i64 xregoffset;
	i64 firstoffset;
	i64 i;
	R1 = 16;
	offset = asi64(R1);
	R1 = 0;
	regoffset = asi64(R1);
	R1 = 0;
	regoffset = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 113;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2257;
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	firstoffset = asi64(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 3;
	if (asi64(R1) > asi64(R2)) goto L2260;
L2258:
	R1 = 0;
	R2 = 0;
	R3 = 8;
	asi64(R4) = i;
	R5 = 8;
	asi64(R4) *= asi64(R5);
	asi64(R5) = firstoffset;
	asi64(R4) += asi64(R5);
	R5 = 1;
	R6 = 0;
	R7 = 15;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = i;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	i += 1; if (i <= 3) goto L2258;
L2260:
L2257:
	goto L2264;
L2261:
	asi64(R1) = regoffset;
	R2 = 3;
	if (asi64(R1) <= asi64(R2)) goto L2266;
	goto L2263;
L2266:
	asu64(R1) = d;
	R2 = 92;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2268;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2270;
	R1 = 0;
	R2 = 0;
	R3 = 8;
	asu64(R4) = d;
	R5 = 76;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 1;
	R6 = 0;
	R7 = 15;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	ax = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2272;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2273;
	goto L2274;
L2272:
	R1 = 8;
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2271;
L2273:
	R1 = 8;
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	R2 = 4;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 16;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2271;
L2274:
	R1 = 10;
	asi64(R2) = regoffset;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2271:
	goto L2269;
L2270:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2275;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2277;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L2279;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = regoffset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	R2 = 8;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenxreg(asi64(R3), asi64(R2));
	R3 = 17;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2279:
	goto L2276;
L2277:
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L2280;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = regoffset;
	R3 = 11;
	asi64(R2) += asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2280:
L2276:
L2275:
L2269:
L2268:
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&regoffset;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L2264:
	asu64(R1) = d;
	if (asu64(R1)) goto L2261;
L2263:
	return;
}

static void mc_auxmcl_do_jumptruefalse(u64 p, i64 cond) {
    u64 R1, R2, R3, R4, R5; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2283;
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 41;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2282;
L2283:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = bx;
	R3 = 76;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2282:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_bitwise(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_shift(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 cx;
	u64 y;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	y = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2287;
	asu64(R1) = y;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2287;
	R1 = 10;
	asu64(R2) = y;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2286;
L2287:
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2289;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2289:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2291;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2291:
L2286:
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_setmclentry(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mce_oldmccodex = asu64(R1);
	asu64(R1) = p;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mce_lastmcl = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mce_nextmcl = asu64(R1);
	return;
}

static u64 mc_auxmcl_resetmclentry() {
    u64 R1, R2, R3; 
	u64 pnew;
	asu64(R1) = mc_decls_mce_lastmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mce_nextmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	pnew = asu64(R1);
	asu64(R1) = mc_decls_mce_oldmccodex;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = pnew;
	goto L2293;
L2293:
	return asu64(R1);
}

static void mc_auxmcl_setmclentryf(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mc_decls_mccodex;
	mc_decls_mcf_oldmccodex = asu64(R1);
	asu64(R1) = p;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mcf_lastmcl = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_mcf_nextmcl = asu64(R1);
	return;
}

static u64 mc_auxmcl_resetmclentryf() {
    u64 R1, R2, R3; 
	u64 pnew;
	asu64(R1) = mc_decls_mcf_lastmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mcf_nextmcl;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_mccodex;
	pnew = asu64(R1);
	asu64(R1) = mc_decls_mcf_oldmccodex;
	mc_decls_mccodex = asu64(R1);
	asu64(R1) = pnew;
	goto L2295;
L2295:
	return asu64(R1);
}

static void mc_auxmcl_do_pushlowargs(i64 nargs, i64 nvariadics, i64 isptr) {
    u64 R1, R2, R3; 
	u64 ax;
	i64 j;
	i64 k;
	i64 nextireg;
	i64 nextxreg;
	i64 mode;
	i64 imode;
	i64 blockret;
	u64 dblock;
	i64 av_1;
	i64 i;
	asi64(R1) = nargs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2298;
	goto L2296;
L2298:
	R1 = (u64)&mc_decls_callblockret;
	asi64(R2) = mc_decls_ncalldepth;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	blockret = asi64(R1);
	R1 = 11;
	nextireg = asi64(R1);
	R1 = 1;
	nextxreg = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = nargs;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) < asi64(R2)) goto L2301;
L2299:
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = k;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2303;
	asi64(R1) = blockret;
	if (!asi64(R1)) goto L2303;
	R1 = (u64)&mc_decls_callblocksize;
	asi64(R2) = mc_decls_ncalldepth;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 1;
	asu64(R2) = dblock;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2302;
L2303:
	asi64(R1) = i;
	asi64(R2) = isptr;
	asi64(R1) -= asi64(R2);
	asi64(R2) = blockret;
	asi64(R1) += asi64(R2);
	j = asi64(R1);
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = j;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2305;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2306;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2306;
	goto L2307;
L2305:
	asi64(R1) = nextireg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = k;
	R2 = (u64)&mc_decls_callargsize;
	asi64(R3) = mc_decls_ncalldepth;
	R2 += (i64)R3*16-16;
	asi64(R3) = k;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4-4));
	R2 = toi64(tou32(R2));
	asu64(R3) = ax;
	mc_auxmcl_copyblockarg(asu64(R3), asi64(R2), asi64(R1));
	goto L2304;
L2306:
	asi64(R1) = nextxreg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = nvariadics;
	if (!asi64(R1)) goto L2309;
	asi64(R1) = k;
	asi64(R2) = nvariadics;
	if (asi64(R1) < asi64(R2)) goto L2309;
	asi64(R1) = mode;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2311;
	R1 = 5;
	goto L2310;
L2311:
	R1 = 6;
L2310:
	imode = asi64(R1);
	asi64(R1) = mode;
	asi64(R2) = nextxreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = imode;
	asi64(R3) = nextireg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2309:
	goto L2304;
L2307:
// mc_auxmcl.do_pushlowargs.doint:
	asi64(R1) = nextireg;
	asi64(R2) = mode;
	asi64(R3) = j;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
L2304:
L2302:
	R1 = (u64)&nextireg;
	(*toi64p(R1)) += 1;
	R1 = (u64)&nextxreg;
	(*toi64p(R1)) += 1;
	i += -1; if (i >= av_1) goto L2299;
L2301:
L2296:
	return;
}

static void mc_auxmcl_do_getretvalue(u64 p) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 xreg;
	i64 i;
	i64 n;
	i64 m;
	struct $B1 modes;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L2315;
	R1 = 0;
	n = asi64(R1);
	goto L2317;
L2316:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&modes;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L2317:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 32;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L2316;
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2*32;
	mc_decls_currpcl = asu64(R1);
	asi64(R1) = n;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2321;
L2319:
	R1 = (u64)&modes;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	m = asi64(R1);
	asi64(R1) = m;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2323;
	R1 = (u64)&mc_decls_multxregs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L2322;
L2323:
	R1 = (u64)&mc_decls_multregs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
L2322:
	asi64(R2) = m;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	i += -1; if (i >= 1) goto L2319;
L2321:
	goto L2314;
L2315:
	R1 = 1;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
L2314:
	return;
}

static i64 mc_auxmcl_ismemaddr(i64 n) {
    u64 R1, R2; 
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2326;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2326;
	R1 = 1;
	goto L2324;
L2326:
	R1 = 0;
	goto L2324;
L2324:
	return asi64(R1);
}

static void mc_auxmcl_do_incr(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 mx;
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2329;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2328;
L2329:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2328:
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_incrload(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 mx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2332;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2331;
L2332:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2331:
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu8(R1) = mc_decls_pmode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_auxmcl_do_loadincr(u64 p, i64 incrop, i64 addop) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 mx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	mx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2335;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incrop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2334;
L2335:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2334:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_for(u64 p, i64 incop, i64 addop, i64 cond) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 r;
	u64 ax;
	u64 bx;
	u64 cx;
	u64 dx;
	u64 mx;
	i64 reg;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2*32;
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2*32;
	R2 = R1;
	mc_decls_currpcl = asu64(R2);
	r = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = q;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	mx = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2338;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2340;
	R1 = 0;
	asu64(R2) = mx;
	asi64(R3) = incop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2339;
L2340:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2339:
	asu64(R1) = mx;
	ax = asu64(R1);
	goto L2337;
L2338:
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2342;
	R1 = 0;
	asu64(R2) = ax;
	asi64(R3) = incop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2341;
L2342:
	R1 = 10;
	asu64(R2) = p;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = addop;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2341:
	asu64(R1) = ax;
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2337:
	asu64(R1) = r;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2344;
	R1 = 10;
	asu64(R2) = r;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	bx = asu64(R1);
	goto L2343;
L2344:
	R1 = 6;
	asu64(R2) = r;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	bx = asu64(R1);
L2343:
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mc_auxmcl_scaleindex(u64 ax, i64 scale) {
    u64 R1, R2; 
	i64 n;
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2348;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2348;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2348;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2347;
L2348:
	asi64(R1) = scale;
	goto L2345;
L2347:
	asi64(R1) = scale;
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	R1 = 1;
	goto L2345;
L2345:
	return asi64(R1);
}

static void mc_auxmcl_mulimm(u64 ax, i64 n) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	i64 shifts;
	i64 m;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2351;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2352;
	R2 = -1;
	if (asi64(R1) == asi64(R2)) goto L2353;
	goto L2354;
L2351:
	asu64(R1) = ax;
	mc_libmcl_clearreg(asu64(R1));
	goto L2349;
	goto L2350;
L2352:
	goto L2349;
	goto L2350;
L2353:
	R1 = 0;
	asu64(R2) = ax;
	R3 = 50;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2349;
	goto L2350;
L2354:
L2350:
	R1 = 0;
	shifts = asi64(R1);
	asi64(R1) = n;
	m = asi64(R1);
	goto L2356;
L2355:
	R1 = 1;
	R2 = (u64)&m;
	*toi64p(R2) >>= asi64(R1);
	R1 = (u64)&shifts;
	(*toi64p(R1)) += 1;
L2356:
	asi64(R1) = m;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2355;
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2359;
	R1 = 10;
	asi64(R2) = shifts;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2359:
	asi64(R1) = m;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2361;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2362;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2362;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2362;
	goto L2363;
L2361:
	goto L2349;
	goto L2360;
L2362:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asi64(R5) = m;
	R6 = 1;
	asi64(R5) -= asi64(R6);
	asu64(R6) = ax;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2360;
L2363:
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2365;
	R1 = 34;
	asu64(R2) = mc_decls_mccodex;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_mccodex;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L2364;
L2365:
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 34;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2364:
L2360:
L2349:
	return;
}

static u64 mc_auxmcl_do_addrmode(u64 p) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 px;
	u64 ax;
	u64 bx;
	i64 scale;
	i64 extra;
	i64 offset;
	i64 reg;
	i64 regix;
	u64 d;
	u64 q;
	asu64(R1) = p;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	asu64(R1) = p;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	extra = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2368;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = extra;
	asi64(R1) += asi64(R2);
	offset = asi64(R1);
L2368:
	R1 = 0;
	px = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2370;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2372;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2371;
L2372:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2373;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2371;
L2373:
	asi64(R1) = scale;
	R2 = 0;
	R3 = (u64)&mc_decls_pclmode;
	asi64(R4) = mc_decls_noperands;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	R7 = (u64)&mc_decls_pclreg;
	asi64(R8) = mc_decls_noperands;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8-2));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2371:
	goto L2369;
L2370:
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R1) = mc_auxmcl_ismemaddr(asi64(R1));
	if (!asi64(R1)) goto L2374;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L2378;
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2377;
L2378:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2376;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2376;
L2377:
	goto L2379;
L2376:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2381;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2380;
L2381:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2382;
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2380;
L2382:
	asi64(R1) = scale;
	R2 = 0;
	R3 = 10;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	R7 = 0;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2380:
	goto L2369;
L2374:
// mc_auxmcl.do_addrmode.skip:
L2379:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2384;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = (u64)&scale;
	asi64(R3) = reg;
	asi64(R1) = mc_auxmcl_scaleregvar(asi64(R3), asu64(R2), asi64(R1));
	regix = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asi64(R6) = regix;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2383;
L2384:
	asu64(R1) = q;
	if (!asu64(R1)) goto L2385;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = offset;
	R5 = 1;
	R6 = 0;
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
	goto L2383;
L2385:
	asi64(R1) = scale;
	R2 = 0;
	R3 = 6;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_loadopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = R2;
	bx = asu64(R3);
	asi64(R1) = mc_auxmcl_scaleindex(asu64(R2), asi64(R1));
	scale = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asi64(R4) = extra;
	asi64(R5) = scale;
	asu64(R6) = bx;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R7) = ax;
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	px = asu64(R1);
L2383:
L2369:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = px;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = px;
	goto L2366;
L2366:
	return asu64(R1);
}

static i64 mc_auxmcl_scaleregvar(i64 reg, u64 scale, i64 n) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	i64 regix;
	u64 ax;
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2389;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2389;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2389;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2388;
L2389:
	asi64(R1) = reg;
	goto L2386;
L2388:
	asi64(R1) = mc_stackmcl_getworkireg();
	regix = asi64(R1);
	R1 = 10;
	asi64(R2) = regix;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L2391;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 1;
	asi64(R6) = reg;
	asi64(R7) = reg;
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = scale;
	*toi64p(R2) = asi64(R1);
	goto L2390;
L2391:
	R1 = 10;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = scale;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = ax;
	mc_auxmcl_mulimm(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = scale;
	*toi64p(R2) = asi64(R1);
L2390:
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = regix;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 10;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = regix;
	goto L2386;
L2386:
	return asi64(R1);
}

static void mc_auxmcl_dolea(u64 ax, u64 px) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = px;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = px;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2396;
	asu64(R2) = px;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2396;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2396;
	R1 = 1;
	goto L2397;
L2396:
	R1 = 0;
L2397:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L2395;
	asu64(R1) = px;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L2394;
L2395:
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2394:
	return;
}

static void mc_auxmcl_do_binto(u64 p, i64 opc, i64 fopc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 rx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2400;
	asi64(R1) = fopc;
	asu64(R2) = p;
	mc_auxmcl_do_binto_float(asu64(R2), asi64(R1));
	goto L2398;
L2400:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
L2398:
	return;
}

static void mc_auxmcl_do_binto_float(u64 p, i64 opc) {
    u64 R1, R2, R3, R4, R5; 
	u64 px;
	u64 bx;
	u64 cx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = cx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = cx;
	asi64(R3) = opc;
	asu8(R4) = mc_decls_pmode;
	R4 = toi64(tou8(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = cx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_shiftnto(u64 p, i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 cx;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2404;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2404;
	R1 = 10;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2403;
L2404:
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2406;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2406:
	R1 = 11;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu64(R1) = cx;
	asu64(R2) = px;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2408;
	R1 = 0;
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2408:
L2403:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_divrem(u64 p, i64 issigned, i64 isdiv) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 px;
	u64 q;
	i64 opc;
	i64 n;
	i64 shifts;
	u8 fdivto;
	i64 locyy;
	i64 loczz;
	R1 = 0;
	fdivto = asu8(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	locyy = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	loczz = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 94;
	if (asi64(R1) == asi64(R2)) goto L2412;
	R2 = 95;
	if (asi64(R1) != asi64(R2)) goto L2411;
L2412:
	R1 = (u64)&locyy;
	R2 = (u64)&loczz;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 1;
	fdivto = asu8(R1);
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	asu64(R1) = mc_stackmcl_makeopndind(asu64(R2), asi64(R1));
	px = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = ax;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2410;
L2411:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
L2410:
	asi64(R1) = loczz;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2414;
	asi64(R1) = isdiv;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2414;
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2416;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2417;
	goto L2418;
L2416:
	R1 = tou64("");
	R2 = tou64("Divide by zero");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2415;
L2417:
	mc_stackmcl_poppcl();
	goto L2409;
	goto L2415;
L2418:
	asi64(R1) = n;
	asi64(R1) = mc_libmcl_ispoweroftwo(asi64(R1));
	shifts = asi64(R1);
	asi64(R1) = shifts;
	if (!asi64(R1)) goto L2420;
	asu8(R1) = fdivto;
	if (asu8(R1)) goto L2420;
	R1 = 10;
	asi64(R2) = shifts;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	asi64(R3) = issigned;
	if (!asi64(R3)) goto L2422;
	R3 = 44;
	goto L2421;
L2422:
	R3 = 45;
L2421:
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	goto L2409;
L2420:
L2415:
L2414:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	mc_auxmcl_saverdx();
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_auxmcl_fixdivopnds(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = issigned;
	if (!asi64(R1)) goto L2424;
	R1 = (u64)&pc_tables_psize;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2426;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2427;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2428;
	goto L2429;
L2426:
	R1 = 57;
	goto L2425;
L2427:
	R1 = 56;
	goto L2425;
L2428:
	R1 = 55;
	goto L2425;
L2429:
	R1 = tou64("");
	R2 = tou64("div/u8");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
L2425:
	opc = asi64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 36;
	opc = asi64(R1);
	goto L2423;
L2424:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_libmcl_clearreg(asu64(R1));
	R1 = 37;
	opc = asi64(R1);
L2423:
	R1 = 0;
	asu64(R2) = bx;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = isdiv;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2431;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2432;
	goto L2433;
L2431:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2430;
L2432:
	R1 = 10;
	R2 = 12;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asu64(R2) = bx;
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	mc_stackmcl_swapopndregs(asi64(R1));
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2430;
L2433:
L2430:
	mc_auxmcl_restorerdx();
	asu8(R1) = fdivto;
	if (!asu8(R1)) goto L2435;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asu64(R2) = bx;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asu64(R3) = bx;
	asu64(R2) = mc_stackmcl_makeopndind(asu64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
L2435:
	asi64(R1) = isdiv;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2437;
	mc_stackmcl_poppcl();
L2437:
L2409:
	return;
}

static void mc_auxmcl_fixdivopnds(i64 locyy, i64 loczz) {
    u64 R1, R2, R3; 
	i64 regx;
	i64 regy;
	i64 zop;
	u64 bx;
	u64 ax;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = locyy;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	regx = asi64(R1);
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = loczz;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	regy = asi64(R1);
	asi64(R1) = regx;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2440;
	goto L2438;
L2440:
	R1 = 0;
	R2 = 6;
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	R2 = 6;
	asi64(R3) = loczz;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = regy;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2442;
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = loczz;
	asi64(R2) = locyy;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	goto L2438;
L2442:
	R1 = (u64)&mc_decls_regset;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2444;
	asu64(R1) = bx;
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = regx;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = locyy;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2438;
L2444:
	asi64(R1) = mc_decls_noperands;
	zop = asi64(R1);
	asi64(R1) = zop;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2448;
L2445:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = zop;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2450;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = zop;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2450;
	goto L2447;
L2450:
	zop += -1; if (zop >= 1) goto L2445;
L2448:
	goto L2438;
L2447:
	R1 = 0;
	R2 = 6;
	asi64(R3) = locyy;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = locyy;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = zop;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
L2438:
	return;
}

static void mc_auxmcl_saverdx() {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_r11used;
	if (!asu8(R1)) goto L2453;
	R1 = 0;
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2453:
	return;
}

static void mc_auxmcl_restorerdx() {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_r11used;
	if (!asu8(R1)) goto L2456;
	R1 = 0;
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2456:
	return;
}

static void mc_auxmcl_clearblock(u64 ax, i64 n) {
    u64 R1, R2, R3, R4; 
	u64 rx;
	u64 rcount;
	i64 nwords;
	i64 lab;
	i64 oddbytes;
	i64 offset;
	i64 workreg;
	i64 countreg;
	i64 av_1;
	i64 i;
	asi64(R1) = n;
	R2 = 8;
	asi64(R1) %= asi64(R2);
	oddbytes = asi64(R1);
	asi64(R1) = oddbytes;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	mc_libmcl_clearreg(asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	R1 = 1;
	asi64(R2) = nwords;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L2459;
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L2459;
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2462;
L2460:
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L2460;
L2462:
	goto L2458;
L2459:
	asi64(R1) = nwords;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2463;
	asi64(R1) = nwords;
	R2 = 3;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L2465;
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	R3 = R2;
	countreg = asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = nwords;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
	goto L2464;
L2465:
	R1 = 10;
	asi64(R2) = mc_stackmcl_getworkireg();
	R3 = R2;
	countreg = asi64(R3);
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	R1 = 10;
	asi64(R2) = nwords;
	R3 = 4;
   if (asi64(R3) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R2) /= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
L2466:
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= 4) goto L2466;
	R1 = 10;
	R2 = 32;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
L2464:
L2463:
L2458:
	asi64(R1) = oddbytes;
	if (!asi64(R1)) goto L2470;
	asi64(R1) = oddbytes;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2472;
	R1 = 4;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 4;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2472:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L2474;
	R1 = 2;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 2;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2474:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2476;
	R1 = 1;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	asu64(R1) = rx;
	R2 = 1;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2476:
L2470:
	return;
}

static void mc_auxmcl_do_blockdata(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 d;
	i64 n;
	i64 nqwords;
	i64 nwords;
	i64 r;
	i64 av_1;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2479;
	goto L2477;
L2479:
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2482;
L2480:
	R1 = 0;
	R2 = 10;
	R3 = (u64)&d;
	asu64(R4) = *tou64p(R3); *(tou64p(R3)) += 8; asu64(R3) = asu64(R4);
	asi64(R3) = *toi64p(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L2480;
L2482:
	asi64(R1) = n;
	asi64(R2) = nwords;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asi64(R1) -= asi64(R2);
	r = asi64(R1);
	asi64(R1) = r;
	if (!asi64(R1)) goto L2484;
	R1 = 66;
	asi64(R2) = r;
	asu64(R3) = d;
	mc_auxmcl_genstring_db(asu64(R3), asi64(R2), asi64(R1));
L2484:
	R1 = tou64("ENDDATA");
	mc_libmcl_mgencomment(asu64(R1));
L2477:
	return;
}

static void mc_auxmcl_copyblock(u64 ax, u64 bx, i64 n, i64 savedest) {
    u64 R1, R2, R3, R4; 
	u64 rx;
	u64 rcount;
	i64 nwords;
	i64 lab;
	i64 oddbytes;
	i64 offset;
	i64 workreg;
	i64 countreg;
	i64 axreg;
	u8 saved;
	i64 av_1;
	R1 = 0;
	saved = asu8(R1);
	asi64(R1) = n;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L2487;
	R1 = 2;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = rx;
	R3 = 91;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 91;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2485;
L2487:
	asi64(R1) = n;
	R2 = 8;
	asi64(R1) %= asi64(R2);
	oddbytes = asi64(R1);
	asi64(R1) = oddbytes;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = n;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nwords = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	R1 = 0;
	offset = asi64(R1);
	R1 = 1;
	asi64(R2) = nwords;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L2489;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L2489;
	R1 = 8;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 8;
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	bx = asu64(R1);
	asi64(R1) = nwords;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2492;
L2490:
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 0;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	if (--asi64(av_1)) goto L2490;
L2492:
	goto L2488;
L2489:
	asi64(R1) = nwords;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2493;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rcount = asu64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	asi64(R1) = savedest;
	if (!asi64(R1)) goto L2495;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	axreg = asi64(R1);
	R1 = 0;
	R2 = 10;
	asi64(R3) = axreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	saved = asu8(R1);
L2495:
	asu64(R1) = ax;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R1) = mc_stackmcl_makesimpleaddr(asu64(R1));
	bx = asu64(R1);
	R1 = 8;
	asu64(R2) = ax;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 10;
	asi64(R2) = nwords;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = rcount;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = ax;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 8;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 10;
	asu64(R3) = bx;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = rcount;
	R3 = 53;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 5;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	offset = asi64(R1);
L2493:
L2488:
	asi64(R1) = oddbytes;
	if (!asi64(R1)) goto L2497;
	asi64(R1) = oddbytes;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2499;
	R1 = 4;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 4;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 4;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 4;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2499:
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L2501;
	R1 = 2;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 2;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 2;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L2501:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2503;
	R1 = 1;
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	rx = asu64(R1);
	R1 = 1;
	asi64(R2) = offset;
	asu64(R3) = bx;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = rx;
	R2 = 1;
	asi64(R3) = offset;
	asu64(R4) = ax;
	asu64(R2) = mc_libmcl_applyoffset(asu64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2503:
L2497:
	asu8(R1) = saved;
	if (!asu8(R1)) goto L2505;
	R1 = 0;
	R2 = 10;
	asi64(R3) = axreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2505:
L2485:
	return;
}

static void mc_auxmcl_genstringtable() {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mc_decls_cstringlist;
	if (asu64(R1)) goto L2508;
	goto L2506;
L2508:
	R1 = tou64("String Table");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 8;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_kk0used;
	if (!asi64(R1)) goto L2510;
	R1 = 0;
	asi64(R2) = mc_decls_kk0used;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
L2510:
	asu64(R1) = mc_decls_cstringlist;
	p = asu64(R1);
	goto L2514;
L2511:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = -1;
	asu64(R3) = p;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mc_auxmcl_genstring_db(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2514:
	asu64(R1) = p;
	if (asu64(R1)) goto L2511;
L2506:
	return;
}

static void mc_auxmcl_genstring_db(u64 s, i64 length, i64 strtype) {
    u64 R1, R2; 
	i64 i;
	i64 c;
	i64 seqlen;
	u64 seq;
	i64 av_1;
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L2517;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L2517:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2519;
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
	goto L2515;
L2519:
	R1 = 0;
	seqlen = asi64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2522;
L2520:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L2525;
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) >= asi64(R2)) goto L2525;
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L2526;
	R2 = 92;
	if (asi64(R1) != asi64(R2)) goto L2524;
L2526:
L2525:
	asi64(R1) = seqlen;
	if (!asi64(R1)) goto L2528;
	asi64(R1) = seqlen;
	asu64(R2) = seq;
	mc_auxmcl_gendbstring(asu64(R2), asi64(R1));
	R1 = 0;
	seqlen = asi64(R1);
L2528:
	asi64(R1) = c;
	mc_auxmcl_gendb(asi64(R1));
	goto L2523;
L2524:
	asi64(R1) = seqlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2530;
	R1 = 1;
	seqlen = asi64(R1);
	asu64(R1) = s;
	R2 = 1;
	R1 -= (i64)R2;
	seq = asu64(R1);
	goto L2529;
L2530:
	R1 = (u64)&seqlen;
	(*toi64p(R1)) += 1;
L2529:
L2523:
	if (--asi64(av_1)) goto L2520;
L2522:
	asi64(R1) = seqlen;
	if (!asi64(R1)) goto L2532;
	asi64(R1) = seqlen;
	asu64(R2) = seq;
	mc_auxmcl_gendbstring(asu64(R2), asi64(R1));
L2532:
	asi64(R1) = strtype;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2534;
	R1 = 0;
	mc_auxmcl_gendb(asi64(R1));
L2534:
L2515:
	return;
}

static void mc_auxmcl_gendb(i64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 10;
	asi64(R3) = a;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 116;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_gendbstring(u64 s, i64 length) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = length;
	asu64(R3) = s;
	asu64(R2) = mc_libmcl_mgenstring(asu64(R3), asi64(R2));
	R3 = 116;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_gendq(i64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 10;
	asi64(R3) = a;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_genrealtable() {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mc_decls_creallist;
	if (asu64(R1)) goto L2540;
	asu64(R1) = mc_decls_cr32list;
	if (asu64(R1)) goto L2540;
	goto L2538;
L2540:
	R1 = tou64("Real Table");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 8;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asu64(R1) = mc_decls_creallist;
	p = asu64(R1);
	goto L2544;
L2541:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L2546;
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R3) = asu64(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2545;
L2546:
	R1 = 0;
	R2 = 2;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R2) = mc_libmcl_mgenrealimm(asr64(R3), asi64(R2));
	R3 = 119;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2545:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2544:
	asu64(R1) = p;
	if (asu64(R1)) goto L2541;
	R1 = tou64("Real32 Table");
	mc_libmcl_mgencomment(asu64(R1));
	asu64(R1) = mc_decls_cr32list;
	p = asu64(R1);
	goto L2550;
L2547:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R2) = (1.0/0.0);
	if (asr64(R1) != asr64(R2)) goto L2552;
	R1 = 0;
	R2 = 10;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
    asr32(R3) = tor32(asr64(R3));
	asi32(R3) = asi32(R3);
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 118;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2551;
L2552:
	R1 = 0;
	R2 = 1;
	asu64(R3) = p;
	R4 = 0;
	asr64(R3) = *tor64p(((i64)R3+(i64)R4));
	asu64(R2) = mc_libmcl_mgenrealimm(asr64(R3), asi64(R2));
	R3 = 118;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2551:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L2550:
	asu64(R1) = p;
	if (asu64(R1)) goto L2547;
L2538:
	return;
}

static void mc_auxmcl_genabsneg() {
    u64 R1, R2, R3; 
	asi64(R1) = mc_decls_lababs32;
	asi64(R2) = mc_decls_lababs64;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_labneg32;
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_decls_labneg64;
	asi64(R1) += asi64(R2);
	if (!asi64(R1)) goto L2555;
	R1 = 16;
	R2 = 73;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
L2555:
	asi64(R1) = mc_decls_lababs32;
	if (!asi64(R1)) goto L2557;
	R1 = tou64("lababs32");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_lababs32;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372034707292159;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 9223372034707292159;
	mc_auxmcl_gendq(asi64(R1));
L2557:
	asi64(R1) = mc_decls_lababs64;
	if (!asi64(R1)) goto L2559;
	R1 = tou64("lababs64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_lababs64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
L2559:
	asi64(R1) = mc_decls_labneg32;
	if (!asi64(R1)) goto L2561;
	R1 = tou64("labneg32");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labneg32;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = -9223372034707292160;
	mc_auxmcl_gendq(asi64(R1));
	R1 = -9223372034707292160;
	mc_auxmcl_gendq(asi64(R1));
L2561:
	asi64(R1) = mc_decls_labneg64;
	if (!asi64(R1)) goto L2563;
	R1 = tou64("labneg64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labneg64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0x8000000000000000;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 0x8000000000000000;
	mc_auxmcl_gendq(asi64(R1));
L2563:
	asi64(R1) = mc_decls_labzero;
	if (!asi64(R1)) goto L2565;
	R1 = tou64("labzero");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labzero;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	mc_auxmcl_gendq(asi64(R1));
L2565:
	asi64(R1) = mc_decls_labmask63;
	if (!asi64(R1)) goto L2567;
	R1 = tou64("mask63/offset64");
	mc_libmcl_mgencomment(asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_labmask63;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 9223372036854775807;
	mc_auxmcl_gendq(asi64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_laboffset64;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 4890909195324358656;
	mc_auxmcl_gendq(asi64(R1));
L2567:
	return;
}

static void mc_auxmcl_do_maths(u64 p, u64 opname, i64 nargs) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = nargs;
	R2 = 0;
	asu64(R3) = opname;
	asu64(R4) = p;
	mc_auxmcl_do_callrts(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_auxmcl_do_host(u64 p, u64 d, i64 nargs) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = nargs;
	asu64(R2) = d;
	R3 = 0;
	asu64(R4) = p;
	mc_auxmcl_do_callrts(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mc_auxmcl_do_callrts(u64 p, u64 opname, u64 d, i64 nargs) {
    u64 R1, R2, R3; 
	i64 slots;
	i64 av_1;
	asi64(R1) = nargs;
	mc_stackmcl_saveopnds(asi64(R1));
	R1 = 0;
	slots = asi64(R1);
	asi64(R1) = mc_decls_mstackdepth;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2572;
	R1 = 1;
	mc_libmcl_pushslots(asi64(R1));
	R1 = 1;
	slots = asi64(R1);
L2572:
	R1 = 0;
	R2 = 0;
	asi64(R3) = nargs;
	mc_auxmcl_do_pushlowargs(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = mc_decls_mstackdepth;
	if (!asi64(R1)) goto L2574;
	R1 = 4;
	R2 = (u64)&slots;
	*toi64p(R2) += asi64(R1);
	R1 = 4;
	mc_libmcl_pushslots(asi64(R1));
	goto L2573;
L2574:
	R1 = 1;
	pc_decls_localshadow = asu8(R1);
L2573:
	asu64(R1) = opname;
	if (!asu64(R1)) goto L2576;
	R1 = 0;
	asu64(R2) = opname;
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2575;
L2576:
	R1 = 0;
	asu64(R2) = d;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2575:
	asi64(R1) = nargs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2579;
L2577:
	mc_stackmcl_poppcl();
	if (--asi64(av_1)) goto L2577;
L2579:
	asi64(R1) = slots;
	if (!asi64(R1)) goto L2581;
	asi64(R1) = slots;
	mc_libmcl_popslots(asi64(R1));
L2581:
	asu64(R1) = p;
	mc_auxmcl_do_getretvalue(asu64(R1));
	return;
}

static void mc_auxmcl_do_max_int(i64 cond) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = cond;
	R4 = 15;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_max_float(i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_maxto_int(i64 cond, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 bx;
	u64 lx;
	i64 lab;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 42;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_maxto_real(i64 cond, i64 mode) {
    u64 R1, R2, R3, R4, R5; 
	u64 px;
	u64 ax;
	u64 bx;
	u64 lx;
	i64 lab;
	asi64(R1) = mode;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	R1 = 0;
	asi64(R2) = mode;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 73;
	asi64(R4) = mode;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	lab = asi64(R1);
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = R2;
	lx = asu64(R3);
	asi64(R3) = cond;
	R4 = 26;
	mc_libmcl_genmc_cond(asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	asu64(R2) = px;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lx;
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_negreal(u64 ax, i64 mode) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2588;
	asi64(R1) = mc_decls_labneg64;
	if (asi64(R1)) goto L2590;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_labneg64 = asi64(R1);
L2590:
	asi64(R1) = mc_decls_labneg64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 77;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2587;
L2588:
	asi64(R1) = mc_decls_labneg32;
	if (asi64(R1)) goto L2592;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_labneg32 = asi64(R1);
L2592:
	asi64(R1) = mc_decls_labneg32;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 76;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2587:
	return;
}

static void mc_auxmcl_do_absreal(u64 ax, i64 mode) {
    u64 R1, R2, R3; 
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2595;
	asi64(R1) = mc_decls_lababs64;
	if (asi64(R1)) goto L2597;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_lababs64 = asi64(R1);
L2597:
	asi64(R1) = mc_decls_lababs64;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 79;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2594;
L2595:
	asi64(R1) = mc_decls_lababs32;
	if (asi64(R1)) goto L2599;
	asi64(R1) = mc_libmcl_mcreatefwdlabel();
	mc_decls_lababs32 = asi64(R1);
L2599:
	asi64(R1) = mc_decls_lababs32;
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 78;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2594:
	return;
}

static void mc_auxmcl_do_loadbf_const(u64 p, i64 i, i64 j) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 mx;
	u64 mask;
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = j;
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L2602;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 44;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2601;
L2602:
	asi64(R1) = i;
	if (!asi64(R1)) goto L2604;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 45;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2604:
	R1 = -1;
	asi64(R2) = j;
	asi64(R3) = i;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	mask = asu64(R1);
	asu64(R1) = mask;
	R2 = 2147483647;
	if (asu64(R1) > asu64(R2)) goto L2606;
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2605;
L2606:
	R1 = 0;
	R2 = 6;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	mx = asu64(R1);
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mx;
	asu64(R2) = ax;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2605:
L2601:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_loadbf_var(u64 p) {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = tou64("LOADBF_VAR");
	pc_api_merror(asu64(R2), asu64(R1));
	return;
}

static void mc_auxmcl_do_storebit(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 px;
	u64 ax;
	u64 cx;
	u64 ix;
	u64 q;
	u64 r;
	i64 i;
	i64 offset;
	u8 mask1s;
	u8 mask0s;
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 2;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	r = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L2610;
	R1 = 3;
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	offset = asi64(R1);
	R1 = 7;
	R2 = (u64)&i;
	*toi64p(R2) &= asi64(R1);
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = px;
	asu64(R1) = mc_libmcl_applyoffset(asu64(R3), asi64(R2), asi64(R1));
	px = asu64(R1);
	R1 = 1;
	asi64(R2) = i;
	asi64(R1) <<= asi64(R2);
	mask0s = asu8(R1);
	R1 = 1;
	asi64(R2) = i;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	mask1s = asu8(R1);
	asu64(R1) = r;
	if (!asu64(R1)) goto L2612;
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2614;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask1s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2613;
L2614:
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask0s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2613:
	goto L2611;
L2612:
	R1 = 0;
	R2 = 3;
	asi64(R3) = mc_decls_noperands;
	R4 = 2;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu8(R2) = mask1s;
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	if (!asi64(R1)) goto L2616;
	R1 = 3;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2616:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2611:
	goto L2609;
L2610:
	asu64(R1) = r;
	if (!asu64(R1)) goto L2617;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	px = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2619;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 10;
	R2 = 1;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	R2 = 11;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	cx = asu64(R1);
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2621;
	R1 = 0;
	asu64(R2) = cx;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2621:
	R1 = 11;
	R2 = 10;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadparam(asi64(R3), asi64(R2), asi64(R1));
	ix = asu64(R1);
	R1 = 1;
	asu64(R2) = cx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu8(R1) = pc_decls_r10used;
	if (!asu8(R1)) goto L2623;
	R1 = 0;
	asu64(R2) = cx;
	R3 = 13;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2623:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2625;
	R1 = 0;
	asu64(R2) = ax;
	R3 = 51;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2624;
L2625:
	asu64(R1) = ax;
	asu64(R2) = px;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2624:
	goto L2618;
L2619:
	R1 = tou64("");
	R2 = tou64("STOREBIT/VAR");
	pc_api_merror(asu64(R2), asu64(R1));
L2618:
	goto L2609;
L2617:
	R1 = tou64("");
	R2 = tou64("Storebit: both vars");
	pc_api_merror(asu64(R2), asu64(R1));
L2609:
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static void mc_auxmcl_do_storebf(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 ax;
	u64 rx;
	u64 mx;
	u64 mx4;
	u64 dx;
	i64 i;
	i64 j;
	u64 q;
	u64 r;
	u64 mask;
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	q = asu64(R1);
	asi64(R1) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_isimmload(asi64(R1));
	r = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = r;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L2628;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2628;
	R1 = tou64("");
	R2 = tou64("storebf not imm");
	pc_api_merror(asu64(R2), asu64(R1));
L2628:
	R1 = 0;
	asu8(R2) = mc_decls_pmode;
	R2 = toi64(tou8(R2));
	asi64(R3) = mc_decls_noperands;
	R4 = 3;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	dx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_decls_noperands;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R1) = mc_stackmcl_getopnd_ind(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	i = asi64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	j = asi64(R1);
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	mx = asu64(R1);
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	rx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = rx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = -1;
	asi64(R2) = j;
	asi64(R3) = i;
	asi64(R2) -= asi64(R3);
	R3 = 1;
	asi64(R2) += asi64(R3);
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	asi64(R2) = i;
	asu64(R1) <<= asu64(R2);
	asu64(R1) = ~asu64(R1);
	mask = asu64(R1);
	R1 = 10;
	asu64(R2) = mask;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	if (!asi64(R1)) goto L2630;
	R1 = 10;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = dx;
	R3 = 43;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2630:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = mx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = rx;
	R3 = 38;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = dx;
	asu64(R2) = rx;
	R3 = 39;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = rx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	mc_stackmcl_poppcl();
	return;
}

static u64 mc_auxmcl_gethostfn(i64 opc) {
    u64 R1, R2; 
	u64 d;
	u64 name;
	u64 namec;
	u64 ps;
	asu64(R1) = pc_api_igethostfn;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2633;
	asi64(R1) = opc;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2635;
	goto L2636;
L2635:
	R1 = tou64("msys.m$power_i64");
	name = asu64(R1);
	R1 = tou64("msysc.m$power_i64");
	namec = asu64(R1);
	goto L2634;
L2636:
	R1 = 0;
	name = asu64(R1);
L2634:
	asu64(R1) = name;
	if (!asu64(R1)) goto L2638;
	asu64(R1) = pc_decls_psymboltable;
	ps = asu64(R1);
	goto L2642;
L2639:
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L2645;
	asu64(R1) = ps;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = namec;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2644;
L2645:
	asu64(R1) = ps;
	goto L2631;
L2644:
	asu64(R1) = ps;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ps = asu64(R1);
L2642:
	asu64(R1) = ps;
	if (asu64(R1)) goto L2639;
L2638:
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("gethostfn?");
	pc_api_merror(asu64(R2), asu64(R1));
L2633:
	asi64(R1) = opc;
	asu64(R2) = pc_api_igethostfn;
	asu64(R1) = ((F19)R2)(asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2647;
	R1 = (u64)&pc_tables_pclnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("No host fn:");
	pc_api_merror(asu64(R2), asu64(R1));
L2647:
	asu64(R1) = d;
	goto L2631;
L2631:
	return asu64(R1);
}

static void mc_auxmcl_copyblockarg(u64 px, i64 size, i64 argno) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 dblock;
	u64 ax;
	u64 bx;
	u64 axi;
	u64 bxi;
	asu64(R1) = px;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2650;
	msysc_m$print_startcon();
	R1 = tou64("High block arg not copied in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("()");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L2648;
L2650:
	asi64(R1) = size;
	asu64(R1) = mc_libmcl_newblocktemp(asi64(R1));
	dblock = asu64(R1);
	R1 = 1;
	asu64(R2) = dblock;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = px;
	if (!asu64(R1)) goto L2652;
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	bx = asu64(R1);
	asu64(R1) = px;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2651;
L2652:
	R1 = 0;
	R2 = 11;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
L2651:
	R1 = 6;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asi64(R2) = size;
	R3 = 0;
	R4 = 10;
	asu64(R5) = bx;
	R6 = 10;
	asu8(R5) = *tou8p(((i64)R5+(i64)R6));
	R5 = toi64(tou8(R5));
	asu64(R3) = mc_libmcl_mgenireg(asi64(R5), asi64(R4), asi64(R3));
	R4 = 0;
	R5 = 10;
	asu64(R6) = ax;
	R7 = 10;
	asu8(R6) = *tou8p(((i64)R6+(i64)R7));
	R6 = toi64(tou8(R6));
	asu64(R4) = mc_libmcl_mgenireg(asi64(R6), asi64(R5), asi64(R4));
	mc_auxmcl_copyblock(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = px;
	if (!asu64(R1)) goto L2654;
	R1 = 6;
	asu64(R2) = dblock;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = px;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2654:
	R1 = 0;
	mc_stackmcl_freeworkregs(asu64(R1));
L2648:
	return;
}

static void mc_auxmcl_fixmain() {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 dn;
	u64 dargs;
	u64 denv;
	u64 dinfo;
	u64 ax;
	asu64(R1) = pc_decls_currfunc;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dn = asu64(R1);
	asu64(R1) = dn;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dargs = asu64(R1);
	R1 = 3;
	R2 = tou64("$env");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	denv = asu64(R1);
	R1 = 6;
	asu64(R2) = denv;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 8;
	asu64(R2) = denv;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 3;
	R2 = tou64("$info");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	dinfo = asu64(R1);
	R1 = 11;
	asu64(R2) = dinfo;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 128;
	asu64(R2) = dinfo;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 8;
	R2 = 90;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = dinfo;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 128;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 124;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = denv;
	asu64(R2) = mc_libmcl_mgenmemaddr(asu64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 8;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 124;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	asu64(R1) = denv;
	pc_api_pc_addlocal(asu64(R1));
	asu64(R1) = dinfo;
	pc_api_pc_addlocal(asu64(R1));
	R1 = 0;
	R2 = R1;
	asu64(R3) = d;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	R2 = R1;
	asu64(R3) = dargs;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = dn;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 112;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dn;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = dn;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dargs;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = dargs;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = dargs;
	pc_api_pc_addlocal(asu64(R1));
	asu64(R1) = dn;
	pc_api_pc_addlocal(asu64(R1));
	R1 = 0;
	R2 = 10;
	R3 = 1;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = R2;
	ax = asu64(R3);
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = dinfo;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dinfo;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = ax;
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 32;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = dn;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 11;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dn;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = dargs;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 12;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = dargs;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asu64(R2) = denv;
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	R2 = 10;
	R3 = 13;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = denv;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	R2 = 14;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_libmcl_clearreg(asu64(R1));
	R1 = 0;
	R2 = tou64("__getmainargs*");
	asu64(R2) = mc_libmcl_mgenextname(asu64(R2));
	R3 = 21;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = 48;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = pc_decls_pcmdskip;
	if (!asi64(R1)) goto L2657;
	R1 = 9;
	asi64(R2) = pc_decls_pcmdskip;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = dn;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	asi64(R2) = pc_decls_pcmdskip;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	R2 = 6;
	asu64(R3) = dargs;
	asu64(R2) = mc_libmcl_mgenmem(asu64(R3), asi64(R2));
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2657:
	return;
}

static void mc_libmcl_mclinit(i64 bypass) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 r;
	i64 s;
	i64 av_1;
	i64 av_2;
	i64 i;
	R1 = 64;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L2660;
	R1 = tou64("MCLREC>64B");
	mlib_abortprogram(asu64(R1));
L2660:
	R1 = 1;
	r = asi64(R1);
L2661:
	R1 = 1;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 2;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 4;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 4;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 8;
	asi64(R2) = r;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_decls_regtable;
	asi64(R3) = r;
	R2 += (i64)R3*64-64;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	r += 1; if (r <= 16) goto L2661;
	R1 = -128;
	i = asi64(R1);
	R1 = 64;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = -128;
	if (asi64(R1) < asi64(R2)) goto L2666;
L2664:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = i;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	R2 = (u64)&mc_decls_frameregtable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8+1024)) = asu64(R1);
	i += 1; if (i <= av_1) goto L2664;
L2666:
	R1 = 6;
	R2 = 15;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_decls_dframeopnd = asu64(R1);
	R1 = 6;
	R2 = 16;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	mc_decls_dstackopnd = asu64(R1);
	mc_libmcl_initmcdest();
	R1 = 1;
	R2 = 67;
	mc_libmcl_setsegment(asi64(R2), asi64(R1));
	R1 = 0;
	mc_decls_lab_funcnametable = asi64(R1);
	R1 = 0;
	mc_decls_lab_funcaddrtable = asi64(R1);
	R1 = -1;
	i = asi64(R1);
	R1 = 10;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = -1;
	if (asi64(R1) < asi64(R2)) goto L2669;
L2667:
	R1 = 8;
	asi64(R2) = i;
	asu64(R1) = mc_libmcl_mgenint0(asi64(R2), asi64(R1));
	R2 = (u64)&mc_libmcl_smallinttable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8+8)) = asu64(R1);
	i += 1; if (i <= av_2) goto L2667;
L2669:
	asi64(R1) = bypass;
	if (!asi64(R1)) goto L2671;
	R1 = 1;
	pc_decls_mcldone = asu8(R1);
L2671:
	return;
}

static void mc_libmcl_initmcdest() {
    u64 R1, R2; 
	R1 = 0;
	R2 = R1;
	mc_decls_mccodex = asu64(R2);
	mc_decls_mccode = asu64(R1);
	return;
}

static void mc_libmcl_genmc(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 m;
	u64 oldm;
	i64 labno;
	R1 = 64;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	m = asu64(R1);
	asi64(R1) = opcode;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mc_libmcl_mclseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = m;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = pc_decls_mmpos;
	asu64(R2) = m;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = a;
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = opcode;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L2675;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2676;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2677;
	goto L2678;
L2675:
	asu64(R1) = b;
	if (!asu64(R1)) goto L2680;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2680;
	R1 = 1;
	asu64(R2) = b;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2680:
	goto L2674;
L2676:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	labno = asi64(R1);
	goto L2674;
L2677:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2683;
	asu64(R1) = b;
	if (!asu64(R1)) goto L2682;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2682;
L2683:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2685;
	R1 = 17;
	goto L2684;
L2685:
	R1 = 16;
L2684:
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2682:
	goto L2674;
L2678:
L2674:
	asu64(R1) = mc_decls_mccode;
	if (!asu64(R1)) goto L2687;
	asu64(R1) = mc_decls_mccodex;
	asu64(R2) = m;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m;
	asu64(R2) = mc_decls_mccodex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m;
	mc_decls_mccodex = asu64(R1);
	goto L2686;
L2687:
	asu64(R1) = m;
	R2 = R1;
	mc_decls_mccodex = asu64(R2);
	mc_decls_mccode = asu64(R1);
L2686:
	return;
}

static void mc_libmcl_genmc_cond(i64 opcode, i64 cond, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opcode;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = cond;
	asu64(R2) = mc_decls_mccodex;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mc_libmcl_genmc_str(i64 opcode, u64 s) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = -1;
	asu64(R3) = s;
	asu64(R2) = mc_libmcl_mgenstring(asu64(R3), asi64(R2));
	asi64(R3) = opcode;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_newmclopnd() {
    u64 R1; 
	u64 a;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	a = asu64(R1);
	R1 = (u64)&mc_libmcl_nmclopnd;
	(*toi64p(R1)) += 1;
	asu64(R1) = a;
	goto L2690;
L2690:
	return asu64(R1);
}

static u64 mc_libmcl_duplopnd(u64 a) {
    u64 R1, R2; struct $B3 R1_B3; 
	u64 b;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	b = asu64(R1);
	asu64(R1) = a;
	(R1_B3) = *(struct $B3*)(R1);
	asu64(R2) = b;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = b;
	goto L2691;
L2691:
	return asu64(R1);
}

static u64 mc_libmcl_mgenindex(i64 areg, i64 ireg, i64 scale, i64 offset, i64 size, i64 labno, u64 def) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = areg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = areg;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L2695;
	asi64(R1) = ireg;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L2694;
L2695:
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2694:
	asi64(R1) = ireg;
	asu64(R2) = a;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 5;
	R4 = 8;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = offset;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = labno;
	if (!asi64(R1)) goto L2697;
	asi64(R1) = labno;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L2696;
L2697:
	asu64(R1) = def;
	if (!asu64(R1)) goto L2698;
	asu64(R1) = def;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = def;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = def;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2701;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2700;
L2701:
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2700:
L2698:
L2696:
	asu64(R1) = a;
	goto L2692;
L2692:
	return asu64(R1);
}

static void mc_libmcl_mgencomment(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	R2 = 3;
	mc_libmcl_genmc_str(asi64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_mgenstring(u64 s, i64 length) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L2705;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L2705:
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = a;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2703;
L2703:
	return asu64(R1);
}

static u64 mc_libmcl_mgenname(u64 s) {
    u64 R1, R2, R3, R4; 
	struct $B32 str;
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 7;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2706;
L2706:
	return asu64(R1);
}

static void mc_libmcl_setsegment(i64 seg, i64 align) {
    u64 R1, R2, R3; 
	i64 opc;
	i64 oldalign;
	asi64(R1) = seg;
	asi64(R2) = mc_decls_currsegment;
	if (asi64(R1) == asi64(R2)) goto L2709;
	asi64(R1) = seg;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L2711;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L2712;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L2713;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2714;
	goto L2715;
L2711:
	R1 = 120;
	opc = asi64(R1);
	goto L2710;
L2712:
	R1 = 121;
	opc = asi64(R1);
	goto L2710;
L2713:
	R1 = 122;
	opc = asi64(R1);
	goto L2710;
L2714:
	R1 = tou64("");
	R2 = tou64("CAN'T DO RODATA SEG");
	pc_api_merror(asu64(R2), asu64(R1));
	goto L2710;
L2715:
	R1 = tou64("");
	R2 = tou64("BAD SEG CODE");
	pc_api_merror(asu64(R2), asu64(R1));
L2710:
	asu64(R1) = mc_decls_mccodex;
	if (!asu64(R1)) goto L2717;
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L2718;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L2718;
	R2 = 122;
	if (asi64(R1) != asi64(R2)) goto L2717;
L2718:
	asi64(R1) = opc;
	asu64(R2) = mc_decls_mccodex;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2716;
L2717:
	R1 = 0;
	R2 = 0;
	asi64(R3) = opc;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2716:
	asi64(R1) = seg;
	mc_decls_currsegment = asi64(R1);
L2709:
	asi64(R1) = align;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2720;
	asu64(R1) = mc_decls_mccodex;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) != asi64(R2)) goto L2722;
	asu64(R1) = mc_decls_mccodex;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	oldalign = asi64(R1);
	asi64(R1) = oldalign;
	asi64(R2) = align;
	if (asi64(R1) < asi64(R2)) goto L2724;
	goto L2707;
L2724:
L2722:
	R1 = 0;
	R2 = 10;
	asi64(R3) = align;
	asu64(R2) = mc_libmcl_mgenint(asi64(R3), asi64(R2));
	R3 = 123;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2720:
L2707:
	return;
}

static u64 mc_libmcl_changeopndsize(u64 a, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L2727;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2729;
	R1 = (u64)&mc_decls_regtable;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*64-64;
	asi64(R2) = size;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	b = asu64(R1);
	goto L2728;
L2729:
	asu64(R1) = a;
	asu64(R1) = mc_libmcl_duplopnd(asu64(R1));
	b = asu64(R1);
	asi64(R1) = size;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2728:
	asu64(R1) = b;
	goto L2725;
L2727:
	asu64(R1) = a;
	goto L2725;
L2725:
	return asu64(R1);
}

static u64 mc_libmcl_applyoffset(u64 a, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2732;
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2732;
	asu64(R1) = a;
	goto L2730;
L2732:
	asu64(R1) = a;
	asu64(R1) = mc_libmcl_duplopnd(asu64(R1));
	b = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = b;
	R3 = 12;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L2734;
	asi64(R1) = size;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2734:
	asu64(R1) = b;
	goto L2730;
L2730:
	return asu64(R1);
}

static u64 mc_libmcl_mgenint(i64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 size;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asi64(R1) = x;
	R2 = -1;
	if (asi64(R1) < asi64(R2)) goto L2737;
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L2737;
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2737;
	R1 = (u64)&mc_libmcl_smallinttable;
	asi64(R2) = x;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8+8));
	goto L2735;
L2737:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2735;
L2735:
	return asu64(R1);
}

static u64 mc_libmcl_mgenint0(i64 x, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2738;
L2738:
	return asu64(R1);
}

static u64 mc_libmcl_mgenrealmem(r64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = mode;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	if (!asi64(R1)) goto L2741;
	asr64(R1) = x;
	asi64(R1) = mc_libmcl_getrealindex(asr64(R1));
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2740;
L2741:
	asr64(R1) = x;
	asi64(R1) = mc_libmcl_getr32index(asr64(R1));
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L2740:
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2739;
L2739:
	return asu64(R1);
}

static u64 mc_libmcl_mgenrealimm(r64 x, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asr64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2742;
L2742:
	return asu64(R1);
}

static u64 mc_libmcl_mgenlabel(i64 x) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2745;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	x = asi64(R1);
L2745:
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 6;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2743;
L2743:
	return asu64(R1);
}

static u64 mc_libmcl_mgenlabelmem(i64 x) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asi64(R1) = x;
	asu64(R1) = mc_libmcl_mgenlabel(asi64(R1));
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2746;
L2746:
	return asu64(R1);
}

static u64 mc_libmcl_mgenmem(u64 d, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 reg;
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2749;
	R1 = (u64)&pc_tables_pfloat;
	asu64(R2) = d;
	R3 = 82;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2751;
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenxregvar(asu64(R1));
	goto L2747;
	goto L2750;
L2751:
	asi64(R1) = mode;
	asu64(R2) = d;
	asu64(R1) = mc_libmcl_mgenregvar(asu64(R2), asi64(R1));
	goto L2747;
L2750:
L2749:
	R1 = 0;
	reg = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2754;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2753;
L2754:
	R1 = 15;
	reg = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2753:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = mode;
	if (!asi64(R1)) goto L2756;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L2755;
L2756:
	asu64(R1) = d;
	R2 = 84;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 8;
	asu64(R1) = Min(asu64(R1), asu64(R2));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2755:
	asu64(R1) = a;
	goto L2747;
L2747:
	return asu64(R1);
}

static u64 mc_libmcl_mgenmemaddr(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 1;
	asu64(R2) = d;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 2;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = d;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 89;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2757;
L2757:
	return asu64(R1);
}

static u64 mc_libmcl_mgenreg0(i64 reg, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2760;
	R1 = tou64("");
	R2 = tou64("1:SIZE=0");
	pc_api_merror(asu64(R2), asu64(R1));
L2760:
	asu64(R1) = a;
	goto L2758;
L2758:
	return asu64(R1);
}

static u64 mc_libmcl_mgenxreg(i64 xreg, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = xreg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2763;
	R1 = tou64("");
	R2 = tou64("2:SIZE=0");
	pc_api_merror(asu64(R2), asu64(R1));
L2763:
	asu64(R1) = a;
	goto L2761;
L2761:
	return asu64(R1);
}

static u64 mc_libmcl_mgenreg(i64 reg, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 size;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	size = asi64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2766;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 5;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedxregs;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = a;
	goto L2765;
L2766:
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2768;
	R1 = 8;
	size = asi64(R1);
L2768:
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = reg;
	R2 = 11;
	if (asi64(R1) < asi64(R2)) goto L2770;
	R2 = 14;
	if (asi64(R1) > asi64(R2)) goto L2770;
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2770:
	R1 = (u64)&mc_decls_regtable;
	asi64(R2) = reg;
	R1 += (i64)R2*64-64;
	asi64(R2) = size;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2764;
	asi64(R1) = size;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
L2765:
	goto L2764;
L2764:
	return asu64(R1);
}

static u64 mc_libmcl_mgenregi(i64 reg, i64 mode) {
    u64 R1, R2, R3; 
	u64 a;
	R1 = (u64)&mc_decls_regtable;
	asi64(R2) = reg;
	R1 += (i64)R2*64-64;
	R2 = (u64)&pc_tables_psize;
	asi64(R3) = mode;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2771;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg0(asi64(R2), asi64(R1));
	goto L2771;
L2771:
	return asu64(R1);
}

static u64 mc_libmcl_mgenireg(i64 reg, i64 mode, i64 offset) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = reg;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = offset;
	asu64(R2) = a;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	goto L2772;
L2772:
	return asu64(R1);
}

static u64 mc_libmcl_mgentemp(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	i64 reg;
	i64 size;
	R1 = (u64)&mc_decls_pcltempflags;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2775;
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_decls_pcltempopnds;
	asi64(R3) = n;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	goto L2773;
L2775:
	asu64(R1) = mc_libmcl_newmclopnd();
	a = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 9;
	R4 = 11;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 15;
	asu64(R2) = a;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_usedregs;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 12;
	R4 = 15;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = n;
	asu64(R2) = a;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = a;
	R2 = (u64)&mc_decls_pcltempopnds;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pcltempflags;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	goto L2773;
L2773:
	return asu64(R1);
}

static i64 mc_libmcl_roundsizetg(i64 size) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = size;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2778;
	asi64(R1) = size;
	goto L2776;
L2778:
	asi64(R1) = size;
	R2 = 8;
	asi64(R3) = size;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L2776;
L2776:
	return asi64(R1);
}

static void mc_libmcl_merroropnd(u64 mess, i64 opndtype) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	R1 = tou64("MCL Opnd not supported: # (#) [#]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asi64(R2) = opndtype;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static i64 mc_libmcl_mcreatefwdlabel() {
    u64 R1; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	goto L2780;
L2780:
	return asi64(R1);
}

static void mc_libmcl_mdefinefwdlabel(i64 lab) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = lab;
	asu64(R2) = mc_libmcl_mgenlabel(asi64(R2));
	R3 = 9;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_libmcl_mgenextname(u64 s) {
    u64 R1, R2, R3; 
	struct $B32 str;
	u64 d;
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mc_libmcl_findnamesym(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (asu64(R1)) goto L2784;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	mc_libmcl_addnamesym(asu64(R1));
L2784:
	asu64(R1) = d;
	asu64(R1) = mc_libmcl_mgenmemaddr(asu64(R1));
	goto L2782;
L2782:
	return asu64(R1);
}

static u64 mc_libmcl_mgenregvar(u64 d, i64 mode) {
    u64 R1, R2, R3; 
	u64 a;
	asi64(R1) = mode;
	asu64(R2) = d;
	R3 = 90;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	a = asu64(R1);
	asu64(R1) = a;
	goto L2785;
L2785:
	return asu64(R1);
}

static u64 mc_libmcl_mgenxregvar(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 8;
	asu64(R2) = d;
	R3 = 90;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	a = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_isxregvar;
	asu64(R3) = d;
	R4 = 90;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	goto L2786;
L2786:
	return asu64(R1);
}

static i64 mc_libmcl_getprimreg(u64 ax) {
    u64 R1, R2; 
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2789;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L2788;
L2789:
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
L2788:
	goto L2787;
L2787:
	return asi64(R1);
}

static void mc_libmcl_pushslots(i64 nslots) {
    u64 R1, R2; 
	asi64(R1) = nslots;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	mc_libmcl_pushstack(asi64(R1));
	asi64(R1) = nslots;
	R2 = (u64)&mc_decls_mstackdepth;
	*toi64p(R2) += asi64(R1);
	return;
}

static void mc_libmcl_popslots(i64 nslots) {
    u64 R1, R2; 
	asi64(R1) = nslots;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	mc_libmcl_popstack(asi64(R1));
	asi64(R1) = nslots;
	R2 = (u64)&mc_decls_mstackdepth;
	*toi64p(R2) -= asi64(R1);
	return;
}

static void mc_libmcl_pushstack(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	if (!asi64(R1)) goto L2794;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 29;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2794:
	return;
}

static void mc_libmcl_popstack(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	if (!asi64(R1)) goto L2797;
	R1 = 10;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	asu64(R2) = mc_decls_dstackopnd;
	R3 = 28;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2797:
	return;
}

static i64 mc_libmcl_getstringindex(u64 s) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2800;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	mc_decls_kk0used = asi64(R1);
	asi64(R1) = mc_decls_kk0used;
	goto L2798;
L2800:
	asu64(R1) = mc_decls_cstringlist;
	if (!asu64(R1)) goto L2802;
	asu64(R1) = s;
	asu64(R2) = mc_decls_cstringlist;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2802;
	asu64(R1) = mc_decls_cstringlist;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L2798;
L2802:
	asu64(R1) = s;
	R2 = (u64)&mc_decls_cstringlist;
	asi64(R1) = mc_libmcl_addconst(asu64(R2), asi64(R1));
	goto L2798;
L2798:
	return asi64(R1);
}

static i64 mc_libmcl_addconst(u64 clist, i64 value) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 24;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = clist;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = clist;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	goto L2803;
L2803:
	return asi64(R1);
}

static i64 mc_libmcl_getrealindex(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	R2 = (u64)&mc_decls_creallist;
	asi64(R1) = mc_libmcl_addconst(asu64(R2), asi64(R1));
	goto L2804;
L2804:
	return asi64(R1);
}

static i64 mc_libmcl_getr32index(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	R2 = (u64)&mc_decls_cr32list;
	asi64(R1) = mc_libmcl_addconst(asu64(R2), asi64(R1));
	goto L2805;
L2805:
	return asi64(R1);
}

static i64 mc_libmcl_ispoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	i64 n;
	i64 av_1;
	R1 = 1;
	a = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 60;
	av_1 = asi64(R1);
L2807:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	a = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) != asi64(R2)) goto L2811;
	asi64(R1) = n;
	goto L2806;
L2811:
	if (--asi64(av_1)) goto L2807;
	R1 = 0;
	goto L2806;
L2806:
	return asi64(R1);
}

static void mc_libmcl_axerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("AX ERROR:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Line:");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aapos;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static u64 mc_libmcl_newblocktemp(i64 size) {
    u64 R1, R2, R3; 
	struct $B3 str;
	u64 d;
	asi64(R1) = mc_decls_nblocktemps;
	R2 = 50;
	if (asi64(R1) <= asi64(R2)) goto L2815;
	R1 = tou64("");
	R2 = tou64("Too many block temps");
	pc_api_merror(asu64(R2), asu64(R1));
L2815:
	R1 = (u64)&mc_decls_nblocktemps;
	(*toi64p(R1)) += 1;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$B#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_nblocktemps;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 8;
	R2 = (u64)&str;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 11;
	asu64(R2) = d;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	asu64(R2) = d;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_decls_currfunc;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = pc_decls_currfunc;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&mc_decls_blockdefs;
	asi64(R3) = mc_decls_nblocktemps;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	goto L2813;
L2813:
	return asu64(R1);
}

static u64 mc_libmcl_findnamesym(u64 s) {
    u64 R1, R2; 
	u64 d;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_libmcl_nnametable;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2819;
L2817:
	R1 = (u64)&mc_libmcl_nametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2821;
	R1 = (u64)&mc_libmcl_nametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2816;
L2821:
	i += 1; if (i <= mc_libmcl_nnametable) goto L2817;
L2819:
	R1 = 0;
	goto L2816;
L2816:
	return asu64(R1);
}

static void mc_libmcl_addnamesym(u64 d) {
    u64 R1, R2, R3; 
	asi64(R1) = mc_libmcl_nnametable;
	R2 = 20;
	if (asi64(R1) >= asi64(R2)) goto L2824;
	asu64(R1) = d;
	R2 = (u64)&mc_libmcl_nametable;
	R3 = (u64)&mc_libmcl_nnametable;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L2823;
L2824:
	R1 = tou64("");
	R2 = tou64("Ext nametab overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L2823:
	return;
}

static void mc_libmcl_callproc(u64 cpname, u64 name, i64 lineno) {
	goto L2825;
L2825:
	return;
}

static u64 mc_libmcl_mgenstringx(u64 s) {
    u64 R1; 
	asu64(R1) = s;
	asi64(R1) = mc_libmcl_getstringindex(asu64(R1));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	goto L2826;
L2826:
	return asu64(R1);
}

static void mc_libmcl_clearreg(u64 ax) {
    u64 R1, R2, R3; 
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2829;
	R1 = 4;
	asu64(R2) = ax;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	ax = asu64(R1);
L2829:
	asu64(R1) = ax;
	asu64(R2) = ax;
	R3 = 40;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static u64 mc_stackmcl_getopnd(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 a;
	u64 d;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2832;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2832;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2833;
	goto L2834;
L2832:
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L2830;
	goto L2831;
L2833:
	asi64(R1) = mode;
	asi64(R2) = n;
	asu64(R1) = mc_libmcl_mgentemp(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	goto L2830;
	goto L2831;
L2834:
L2831:
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2836;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2837;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2838;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2839;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2839;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L2840;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2841;
	goto L2842;
L2836:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2844;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2844;
	R1 = 6;
	mode = asi64(R1);
	goto L2837;
	goto L2843;
L2844:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
L2843:
	goto L2835;
L2837:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2846;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2846;
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2845;
L2846:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2845:
	goto L2835;
L2838:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2848;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2849;
	goto L2850;
L2848:
	R1 = 65535;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L2847;
L2849:
	R1 = 4294967295;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) &= asi64(R1);
	goto L2847;
L2850:
L2847:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = -2147483648;
	if (asi64(R1) < asi64(R2)) goto L2852;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L2852;
	asu64(R1) = bx;
	ax = asu64(R1);
	goto L2851;
L2852:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2851:
	goto L2835;
L2839:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2835;
L2840:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_libmcl_getstringindex(asu64(R1));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2835;
L2841:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mc_libmcl_mgenlabelmem(asi64(R1));
	asu64(R2) = ax;
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2835;
L2842:
// mc_stackmcl.getopnd.error:
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = a;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("getopnd");
	pc_api_merror(asu64(R2), asu64(R1));
L2835:
	asu64(R1) = ax;
	goto L2830;
L2830:
	return asu64(R1);
}

static u64 mc_stackmcl_loadopnd(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	asi64(R1) = reg;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2856;
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2858;
	asi64(R1) = mode;
	asi64(R1) = mc_stackmcl_getworkreg(asi64(R1));
	reg = asi64(R1);
L2858:
L2856:
	asi64(R1) = reg;
	asi64(R2) = mode;
	asu64(R3) = ax;
	asu64(R1) = mc_stackmcl_loadtoreg(asu64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = ax;
	goto L2854;
L2854:
	return asu64(R1);
}

static u64 mc_stackmcl_loadparam(i64 n, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 ax;
	asi64(R1) = reg;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asi64(R1) = reg;
	asi64(R2) = mode;
	asu64(R3) = ax;
	asu64(R1) = mc_stackmcl_loadtoreg_m(asu64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	goto L2859;
L2859:
	return asu64(R1);
}

static void mc_stackmcl_pushopnd(i64 n, i64 mode) {
    u64 R1, R2, R3; 
	u64 ax;
	u64 bx;
	u64 p;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2862;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
L2862:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2864;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2866;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2867;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2868;
	goto L2869;
L2866:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2871;
	asu8(R1) = mc_decls_pmode;
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2872;
L2871:
	goto L2865;
L2867:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = -2147483648;
	if (asi64(R1) < asi64(R2)) goto L2874;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L2874;
	R1 = 10;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenint(asi64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2872;
L2874:
	goto L2865;
L2868:
	R1 = 2;
	asu64(R2) = p;
	R3 = 8;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenrealmem(asr64(R2), asi64(R1));
	ax = asu64(R1);
	goto L2872;
	goto L2865;
L2869:
L2865:
L2864:
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	ax = asu64(R1);
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2876;
	asu64(R1) = ax;
	bx = asu64(R1);
	asi64(R1) = mode;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2878;
	R1 = 5;
	goto L2877;
L2878:
	R1 = 6;
L2877:
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	ax = asu64(R1);
	asu64(R1) = bx;
	asu64(R2) = ax;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2876:
// mc_stackmcl.pushopnd.pushit:
L2872:
	R1 = 0;
	R2 = 8;
	asu64(R3) = ax;
	asu64(R2) = mc_libmcl_changeopndsize(asu64(R3), asi64(R2));
	R3 = 12;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	mc_stackmcl_poppcl();
	R1 = (u64)&mc_decls_mstackdepth;
	(*toi64p(R1)) += 1;
	return;
}

static u64 mc_stackmcl_loadtoreg(u64 ax, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 bx;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2882;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2881;
L2882:
	asi64(R1) = reg;
	if (!asi64(R1)) goto L2885;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	if (asi64(R1) != asi64(R2)) goto L2884;
L2885:
	asu64(R1) = ax;
	goto L2879;
L2884:
L2881:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_stackmcl_getworkreg_rm(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = bx;
	mc_stackmcl_loadtoreg_common(asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L2879;
L2879:
	return asu64(R1);
}

static u64 mc_stackmcl_loadtoreg_m(u64 ax, i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	u64 bx;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2889;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2888;
L2889:
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg;
	if (asi64(R1) != asi64(R2)) goto L2891;
	asu64(R1) = ax;
	goto L2886;
L2891:
L2888:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	asu64(R2) = bx;
	mc_stackmcl_loadtoreg_common(asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L2886;
L2886:
	return asu64(R1);
}

static void mc_stackmcl_loadtoreg_common(u64 bx, u64 ax) {
    u64 R1, R2, R3; 
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2894;
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2894;
	asu64(R1) = ax;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2894;
	R1 = 4;
	asu64(R2) = bx;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = bx;
	mc_libmcl_clearreg(asu64(R1));
	goto L2893;
L2894:
	asu64(R1) = ax;
	asu64(R2) = bx;
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2893:
	return;
}

static void mc_stackmcl_pushpcl(u64 p) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L2897;
	R1 = tou64("");
	R2 = tou64("PCL stack overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L2897:
	R1 = (u64)&mc_decls_noperands;
	asi64(R1) = *(toi64p(R1)) += 1;
	n = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2899;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2899;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 2;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2899:
	return;
}

static void mc_stackmcl_pushpcl_reg(i64 mode, i64 reg) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L2902;
	R1 = tou64("");
	R2 = tou64("PCL stack overflow");
	pc_api_merror(asu64(R2), asu64(R1));
L2902:
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2904;
	asi64(R1) = mode;
	asi64(R1) = mc_stackmcl_getworkreg(asi64(R1));
	reg = asi64(R1);
L2904:
	R1 = (u64)&mc_decls_noperands;
	asi64(R1) = *(toi64p(R1)) += 1;
	n = asi64(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = reg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2906;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2905;
L2906:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2905:
	return;
}

static void mc_stackmcl_poppcl() {
    u64 R1, R2; 
	i64 n;
	asi64(R1) = mc_decls_noperands;
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L2909;
	R1 = tou64("");
	R2 = tou64("poppcl/underflow");
	pc_api_merror(asu64(R2), asu64(R1));
L2909:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2911;
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = n;
	R1 += (i64)R2-1;
	(*tou8p(R1)) -=1;
	goto L2907;
L2911:
	R1 = (u64)&mc_decls_noperands;
	(*toi64p(R1)) -=1;
L2907:
	return;
}

static void mc_stackmcl_duplpcl() {
    u64 R1, R2, R3, R4; 
	i64 mode;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mode;
	mc_stackmcl_pushpcl_reg(asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asu64(R1) = mc_stackmcl_getopnd(asi64(R3), asi64(R2), asi64(R1));
	R2 = 0;
	asi64(R3) = mode;
	asi64(R4) = mc_decls_noperands;
	asu64(R2) = mc_stackmcl_getopnd(asi64(R4), asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mc_stackmcl_getworkireg() {
    u64 R1, R2, R3; 
	i64 r;
	i64 av_1;
	R1 = 10;
	av_1 = asi64(R1);
L2914:
	R1 = 1;
	r = asi64(R1);
L2917:
	R1 = (u64)&mc_decls_workregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2921;
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2921;
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = r;
	goto L2913;
L2921:
	r += 1; if (r <= 14) goto L2917;
	mc_stackmcl_savenextopnd();
	if (--asi64(av_1)) goto L2914;
	R1 = tou64("");
	R2 = tou64("No more work regs");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L2913;
L2913:
	return asi64(R1);
}

static i64 mc_stackmcl_getworkxreg() {
    u64 R1, R2, R3; 
	i64 r;
	R1 = 5;
	r = asi64(R1);
L2923:
	R1 = (u64)&mc_decls_workxregs;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2927;
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2927;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = r;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = r;
	goto L2922;
L2927:
	r += 1; if (r <= 16) goto L2923;
	R1 = tou64("");
	R2 = tou64("No more work xregs");
	pc_api_merror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L2922;
L2922:
	return asi64(R1);
}

static u64 mc_stackmcl_getworkregm(i64 mode) {
    u64 R1, R2; 
	asi64(R1) = mode;
	asi64(R2) = mode;
	asi64(R2) = mc_stackmcl_getworkreg(asi64(R2));
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L2928;
L2928:
	return asu64(R1);
}

static i64 mc_stackmcl_getworkreg(i64 mode) {
    u64 R1, R2; 
	i64 reg;
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2931;
	asi64(R1) = mc_stackmcl_getworkxreg();
	goto L2930;
L2931:
	asi64(R1) = mc_stackmcl_getworkireg();
L2930:
	goto L2929;
L2929:
	return asi64(R1);
}

static u64 mc_stackmcl_getworkreg_rm(i64 reg, i64 mode) {
    u64 R1, R2; 
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2935;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L2934;
L2935:
	asi64(R1) = mode;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	goto L2932;
L2934:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2939;
	R1 = (u64)&mc_decls_isregvar;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L2938;
L2939:
	R1 = (u64)&mc_decls_isxregvar;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2937;
L2938:
	asi64(R1) = mode;
	asu64(R1) = mc_stackmcl_getworkregm(asi64(R1));
	goto L2932;
L2937:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	goto L2932;
L2932:
	return asu64(R1);
}

static void mc_stackmcl_saveopnd(i64 n, i64 allregs) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 mode;
	u64 tx;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2942;
	goto L2940;
L2942:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2944;
	asi64(R1) = allregs;
	if (asi64(R1)) goto L2947;
	asi64(R1) = reg;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L2948;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L2946;
L2948:
L2947:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R2) = mc_libmcl_mgentemp(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2946:
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2943;
L2944:
	asi64(R1) = allregs;
	if (asi64(R1)) goto L2951;
	asi64(R1) = reg;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2950;
	R2 = 6;
	if (asi64(R1) > asi64(R2)) goto L2950;
L2951:
	asi64(R1) = mode;
	asi64(R2) = reg;
	asu64(R1) = mc_libmcl_mgenxreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = n;
	asu64(R2) = mc_libmcl_mgentemp(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
L2950:
	R1 = 0;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2943:
	R1 = 3;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2940:
	return;
}

static void mc_stackmcl_saveopnds(i64 n) {
    u64 R1, R2; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2955;
L2953:
	R1 = 0;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L2953;
L2955:
	return;
}

static void mc_stackmcl_savenextopnd() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2959;
L2957:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2961;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2961;
	R1 = 1;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	goto L2956;
L2961:
	i += 1; if (i <= mc_decls_noperands) goto L2957;
L2959:
L2956:
	return;
}

static void mc_stackmcl_savenextxopnd() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2965;
L2963:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2967;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2967;
	R1 = 1;
	asi64(R2) = i;
	mc_stackmcl_saveopnd(asi64(R2), asi64(R1));
	goto L2962;
L2967:
	i += 1; if (i <= mc_decls_noperands) goto L2963;
L2965:
L2962:
	return;
}

static void mc_stackmcl_movetoreg(i64 newreg) {
    u64 R1, R2, R3; 
	i64 oldreg;
	i64 mode;
	i64 i;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
	R1 = 0;
	asi64(R2) = mode;
	asi64(R3) = mc_decls_noperands;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
// mc_stackmcl.movetoreg.retry:
L2969:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	oldreg = asi64(R1);
	asi64(R1) = oldreg;
	asi64(R2) = newreg;
	if (asi64(R1) != asi64(R2)) goto L2971;
	goto L2968;
L2971:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2973;
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = newreg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2975;
	R1 = tou64("");
	R2 = tou64("MOVE TO REG: XREG IN USE");
	pc_api_merror(asu64(R2), asu64(R1));
L2975:
	goto L2972;
L2973:
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = newreg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L2977;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2980;
L2978:
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L2982;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = newreg;
	if (asi64(R1) != asi64(R2)) goto L2982;
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = i;
	mc_stackmcl_swapopnds(asi64(R2), asi64(R1));
	R1 = 6;
	asi64(R2) = newreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	R2 = 6;
	asi64(R3) = oldreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 27;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	goto L2969;
L2982:
	i += 1; if (i <= mc_decls_noperands) goto L2978;
L2980:
L2977:
L2972:
	asi64(R1) = mode;
	asi64(R2) = oldreg;
	asu64(R1) = mc_libmcl_mgenreg(asi64(R2), asi64(R1));
	asi64(R2) = mode;
	asi64(R3) = newreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 11;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = newreg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L2984;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = newreg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2983;
L2984:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = newreg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L2983:
L2968:
	return;
}

static u64 mc_stackmcl_getopnd_ind(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 d;
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2987;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2989;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L2992;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2991;
L2992:
	asi64(R1) = mode;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_libmcl_mgenmem(asu64(R2), asi64(R1));
	goto L2985;
L2991:
L2989:
L2987:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2994;
	R1 = 0;
	R2 = 6;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L2994:
	R1 = 0;
	asi64(R2) = mode;
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = n;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L2985;
L2985:
	return asu64(R1);
}

static u64 mc_stackmcl_getopnd_ind_simp(i64 n, i64 mode) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2997;
	R1 = 0;
	R2 = 6;
	asi64(R3) = n;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L2997:
	R1 = 0;
	asi64(R2) = mode;
	R3 = (u64)&mc_decls_pclreg;
	asi64(R4) = n;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L2995;
L2995:
	return asu64(R1);
}

static void mc_stackmcl_swapopnds(i64 m, i64 n) {
    u64 R1, R2, R3; 
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = m;
	R1 += (i64)R2*8-8;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = n;
	R2 += (i64)R3*8-8;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = m;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclcount;
	asi64(R3) = n;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	return;
}

static u64 mc_stackmcl_isimmload(i64 n) {
    u64 R1, R2; 
	u64 p;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3001;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3001;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3001;
	asu64(R1) = p;
	goto L3000;
L3001:
	R1 = 0;
L3000:
	goto L2999;
L2999:
	return asu64(R1);
}

static void mc_stackmcl_setnewzz(i64 reg, i64 mode) {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&mc_decls_pclloc;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = mc_decls_noperands;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = reg;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = mode;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_stackmcl_freeworkregs(u64 p) {
    u64 R1, R2, R3; 
	i64 reg;
	i64 i;
	R1 = (u64)&mc_decls_regset;
	memset(R1, 0, 16);
	R1 = (u64)&mc_decls_xregset;
	memset(R1, 0, 16);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3006;
L3004:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3008;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3010;
	R1 = 1;
	R2 = (u64)&mc_decls_xregset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3009;
L3010:
	R1 = 1;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3009:
L3008:
	i += 1; if (i <= mc_decls_noperands) goto L3004;
L3006:
	return;
}

static void mc_stackmcl_swapopndregs(i64 reg2) {
    u64 R1, R2, R3; 
	i64 reg1;
	i64 i;
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3013;
	R1 = tou64("");
	R2 = tou64("SOR1");
	pc_api_merror(asu64(R2), asu64(R1));
L3013:
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	reg1 = asi64(R1);
	asi64(R1) = reg1;
	asi64(R2) = reg2;
	if (asi64(R1) != asi64(R2)) goto L3015;
	goto L3011;
L3015:
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3019;
L3016:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3021;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = reg2;
	if (asi64(R1) != asi64(R2)) goto L3021;
	R1 = (u64)&mc_decls_pclreg;
	asi64(R2) = mc_decls_noperands;
	R1 += (i64)R2-1;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	R2 += (i64)R3-1;
	{u8 temp; temp = *tou8p(R1); *tou8p(R1) = *tou8p(R2); *tou8p(R2) = temp; }
	goto L3011;
L3021:
	i += -1; if (i >= 1) goto L3016;
L3019:
	R1 = 0;
	R2 = (u64)&mc_decls_regset;
	asi64(R3) = reg1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = reg2;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = mc_decls_noperands;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
L3011:
	return;
}

static u64 mc_stackmcl_makeopndind(u64 a, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 b;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3024;
	R1 = tou64("");
	R2 = tou64("makeopndind");
	pc_api_merror(asu64(R2), asu64(R1));
L3024:
	R1 = 0;
	asi64(R2) = mode;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	goto L3022;
L3022:
	return asu64(R1);
}

static u64 mc_stackmcl_makesimpleaddr(u64 ax) {
    u64 R1, R2, R3; 
	u64 bx;
	i64 newreg;
	i64 reg;
	i64 regix;
	asu64(R1) = ax;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asu64(R1) = ax;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	regix = asi64(R1);
	asi64(R1) = reg;
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L3027;
	R1 = 0;
	reg = asi64(R1);
L3027:
	asu64(R1) = ax;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3029;
	R1 = tou64("");
	R2 = tou64("MSA");
	pc_api_merror(asu64(R2), asu64(R1));
L3029:
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3031;
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3031;
	asi64(R1) = mc_stackmcl_getworkireg();
	newreg = asi64(R1);
	goto L3030;
L3031:
	asi64(R1) = reg;
	if (!asi64(R1)) goto L3032;
	asu64(R1) = ax;
	goto L3025;
	goto L3030;
L3032:
	asi64(R1) = regix;
	if (!asi64(R1)) goto L3033;
	asi64(R1) = regix;
	newreg = asi64(R1);
	goto L3030;
L3033:
	asi64(R1) = regix;
	newreg = asi64(R1);
L3030:
	R1 = 0;
	R2 = 10;
	asi64(R3) = newreg;
	asu64(R1) = mc_libmcl_mgenireg(asi64(R3), asi64(R2), asi64(R1));
	bx = asu64(R1);
	asu64(R1) = ax;
	R2 = 10;
	asi64(R3) = newreg;
	asu64(R2) = mc_libmcl_mgenreg(asi64(R3), asi64(R2));
	R3 = 14;
	mc_libmcl_genmc(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = bx;
	goto L3025;
L3025:
	return asu64(R1);
}

static void mc_stackmcl_checkallloaded() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3037;
L3035:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3039;
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3039;
	R1 = 0;
	R2 = (u64)&mc_decls_pclopnd;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = i;
	asu64(R1) = mc_stackmcl_loadopnd(asi64(R3), asi64(R2), asi64(R1));
L3039:
	i += 1; if (i <= mc_decls_noperands) goto L3035;
L3037:
	return;
}

static u64 mc_stackmcl_stropndstack(i64 indent) {
    u64 R1, R2, R3; 
	struct $B31 str2;
	u64 s;
	u64 t;
	i64 fs;
	i64 i;
	i64 r;
	R1 = (u64)&mc_stackmcl_stropndstack_str;
	s = asu64(R1);
	asi64(R1) = indent;
	if (!asi64(R1)) goto L3042;
	asu64(R1) = s;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("========================================#:(");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_noperands;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L3041;
L3042:
	asu64(R1) = s;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:(");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = mc_decls_noperands;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L3041:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_noperands;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3045;
L3043:
	asi64(R1) = mc_decls_noperands;
	asi64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	switch (asi64(R1)) {
	case 1: goto L3049;
	case 2: goto L3050;
	case 3: goto L3051;
	case 4: goto L3052;
	default: goto L3048;
    };
// SWITCH
L3049:
	R1 = tou64("Z:");
	goto L3046;
L3050:
	R1 = tou64("Y:");
	goto L3046;
L3051:
	R1 = tou64("X:");
	goto L3046;
L3052:
	R1 = tou64("W:");
	goto L3046;
L3048:
	R1 = tou64("");
L3046:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3054;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3054;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3055;
	goto L3056;
L3054:
	R1 = (u64)&mc_decls_pclmode;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3058;
	R1 = (u64)&mc_decls_xregnames;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3057;
L3058:
	R1 = (u64)&mc_decls_regnames;
	R2 = (u64)&mc_decls_pclreg;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3057:
	R1 = (u64)&mc_decls_pclloc;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3060;
	R1 = tou64("*");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3060:
	goto L3053;
L3055:
	R1 = tou64("T");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = i;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3053;
L3056:
	R1 = tou64("(==");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu8(R1) = pc_api_fpshortnames;
	R1 = toi64(tou8(R1));
	fs = asi64(R1);
	R1 = 1;
	pc_api_fpshortnames = asu8(R1);
	R1 = (u64)&mc_decls_pclopnd;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = pc_diags_dummy_stropnd(asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = fs;
	pc_api_fpshortnames = asu8(R1);
	R1 = tou64(")");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3053:
	R1 = (u64)&mc_decls_pclcount;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3062;
	R1 = tou64("@");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3062:
	R1 = tou64("<");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_tables_pstdnames;
	R2 = (u64)&mc_decls_pclmode;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(">");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = mc_decls_noperands;
	if (asi64(R1) >= asi64(R2)) goto L3064;
	R1 = tou64(", ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3064:
	i += 1; if (i <= mc_decls_noperands) goto L3043;
L3045:
	R1 = tou64(") ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 50;
	R3 = (u64)&mc_stackmcl_stropndstack_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("WR:(");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	r = asi64(R1);
L3065:
	R1 = (u64)&mc_decls_regset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3069;
	R1 = tou64("1 ");
	goto L3068;
L3069:
	R1 = tou64("0 ");
L3068:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	r += 1; if (r <= 10) goto L3065;
	R1 = tou64(") ");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("XWR:(");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	r = asi64(R1);
	asi64(R1) = mc_decls_xregmax;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3072;
L3070:
	R1 = (u64)&mc_decls_xregset;
	asi64(R2) = r;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L3074;
	R1 = tou64("1 ");
	goto L3073;
L3074:
	R1 = tou64("0 ");
L3073:
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	r += 1; if (r <= mc_decls_xregmax) goto L3070;
L3072:
	R1 = tou64(") hwstack:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_mstackdepth;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" noperands:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_noperands;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" ncalldepth:");
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = mc_decls_ncalldepth;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = s;
	goto L3040;
L3040:
	return asu64(R1);
}

static void mc_stackmcl_showopndstack() {
    u64 R1; 
	R1 = 1;
	asu64(R1) = mc_stackmcl_stropndstack(asi64(R1));
	mc_libmcl_mgencomment(asu64(R1));
	return;
}

static void mc_optim_peephole() {
    u64 R1, R2, R3, R4, R5, R6, R7, R8; 
	u64 m;
	u64 m2;
	u64 m3;
	i64 lab1;
	i64 lab2;
	asu8(R1) = pc_decls_fpeephole;
	if (asu8(R1)) goto L3078;
	goto L3076;
L3078:
	asu64(R1) = mc_decls_mccode;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
	goto L3082;
L3079:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m2 = asu64(R1);
	asu64(R1) = m2;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m3 = asu64(R1);
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3084;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3085;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L3086;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L3087;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L3088;
	goto L3089;
L3084:
	goto L3081;
	goto L3083;
L3085:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3091;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L3092;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L3093;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L3094;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L3094;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L3095;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L3095;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L3096;
	goto L3097;
L3091:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3099;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3099;
	asu64(R1) = m2;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3099;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg10(asu64(R1));
	if (!asi64(R1)) goto L3101;
	goto L3100;
L3101:
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (asi64(R1)) goto L3103;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3102;
L3103:
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3102:
L3100:
	goto L3098;
L3099:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3104;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3104;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg10(asu64(R1));
	if (!asi64(R1)) goto L3104;
	asu64(R1) = m3;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L3104;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3104;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3104:
L3098:
	goto L3090;
L3092:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3106;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L3107;
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3107;
	R1 = 1;
	goto L3108;
L3107:
	R1 = 0;
L3108:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L3106;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3106;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3106;
	R1 = 41;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3106:
	goto L3090;
L3093:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3110;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3110;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3110;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3110;
	R1 = 42;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3110:
	goto L3090;
L3094:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3112;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3112;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3112;
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isconst(asu64(R1));
	if (!asi64(R1)) goto L3112;
	R1 = 14;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = m2;
	R5 = 33;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 28;
	if (asi64(R4) != asi64(R5)) goto L3114;
	asu64(R4) = m2;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 0;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5));
	goto L3113;
L3114:
	asu64(R4) = m2;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	R5 = 0;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5));
	asi64(R4) = -asi64(R4);
L3113:
	R5 = 1;
	R6 = 0;
	asu64(R7) = m;
	R8 = 24;
	asu64(R7) = *tou64p(((i64)R7+(i64)R8));
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3112:
	goto L3090;
L3095:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3116;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3116;
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3116;
	R1 = 14;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = m2;
	R5 = 33;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	R5 = 52;
	if (asi64(R4) != asi64(R5)) goto L3118;
	R4 = 1;
	goto L3117;
L3118:
	R4 = -1;
L3117:
	R5 = 1;
	R6 = 0;
	asu64(R7) = m;
	R8 = 24;
	asu64(R7) = *tou64p(((i64)R7+(i64)R8));
	R8 = 10;
	asu8(R7) = *tou8p(((i64)R7+(i64)R8));
	R7 = toi64(tou8(R7));
	asu64(R1) = mc_libmcl_mgenindex(asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3116:
	goto L3090;
L3096:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3120;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3120;
	R1 = 25;
	asu64(R2) = m;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
L3120:
	goto L3090;
L3097:
L3090:
	goto L3083;
L3086:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L3122;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3124;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m2;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L3125;
	asu64(R2) = m2;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3125;
	R1 = 1;
	goto L3126;
L3125:
	R1 = 0;
L3126:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L3124;
	asu64(R1) = m3;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3124;
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3124:
L3122:
	goto L3083;
L3087:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3128;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3130;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3130;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3130;
	asu64(R1) = m2;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg0(asu64(R1));
	if (!asi64(R1)) goto L3130;
	asu64(R1) = m2;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3130;
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	asu64(R3) = m;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3130:
L3128:
	goto L3083;
L3088:
	asu64(R1) = m2;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) != asi64(R2)) goto L3132;
	asu64(R1) = m3;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L3132;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = m3;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) != asi64(R2)) goto L3132;
	asu64(R1) = m;
	asi64(R1) = mc_optim_endr0(asu64(R1));
	if (!asi64(R1)) goto L3132;
	R1 = (u64)&mc_decls_asmrevcond;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = m;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = m2;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = m2;
	asu64(R1) = mc_optim_deletemcl(asu64(R1));
	m = asu64(R1);
L3132:
	goto L3083;
L3089:
L3083:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L3082:
	asu64(R1) = m;
	if (asu64(R1)) goto L3079;
L3081:
L3076:
	return;
}

static i64 mc_optim_isreg(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L3133;
L3133:
	return asi64(R1);
}

static i64 mc_optim_isreg0(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L3136;
	R1 = 0;
	goto L3134;
L3136:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3138;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3138;
	R1 = 1;
	goto L3134;
L3138:
	R1 = 0;
	goto L3134;
L3134:
	return asi64(R1);
}

static i64 mc_optim_isreg10(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L3141;
	R1 = 0;
	goto L3139;
L3141:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3143;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3143;
	R1 = 1;
	goto L3139;
L3143:
	R1 = 0;
	goto L3139;
L3139:
	return asi64(R1);
}

static i64 mc_optim_isreg00(u64 m) {
    u64 R1, R2, R3; 
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_optim_isreg(asu64(R1));
	if (!asi64(R1)) goto L3146;
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = m;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3146;
	R1 = 1;
	goto L3144;
L3146:
	R1 = 0;
	goto L3144;
L3144:
	return asi64(R1);
}

static i64 mc_optim_isconst(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (asu64(R1)) goto L3149;
	R1 = 0;
	goto L3147;
L3149:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3151;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3151;
	R1 = 1;
	goto L3147;
L3151:
	R1 = 0;
	goto L3147;
L3147:
	return asi64(R1);
}

static i64 mc_optim_sameoperand(u64 a, u64 b) {
    u64 R1, R2, R3; 
	R1 = 16;
	asu64(R2) = b;
	asu64(R3) = a;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L3152;
L3152:
	return asi64(R1);
}

static i64 mc_optim_sameregopnd(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L3156;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3155;
L3156:
	R1 = 0;
	goto L3153;
L3155:
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L3153;
L3153:
	return asi64(R1);
}

static u64 mc_optim_deletemcl(u64 p) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3160;
	asu64(R1) = b;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3159;
L3160:
	R1 = tou64("");
	R2 = tou64("delmcl?");
	pc_api_merror(asu64(R2), asu64(R1));
L3159:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	goto L3157;
L3157:
	return asu64(R1);
}

static i64 mc_optim_endr0(u64 m) {
    u64 R1, R2; 
	asu64(R1) = m;
	R2 = 48;
	R1 += (i64)R2;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	goto L3161;
L3161:
	return asi64(R1);
}

static void mc_genss_genss(i64 obj) {
    u64 R1, R2, R3; 
	i64 index;
	u64 m;
	u64 pr;
	u64 codeaddr;
	u64 offsetptr;
	asu8(R1) = pc_decls_ssdone;
	if (!asu8(R1)) goto L3164;
	goto L3162;
L3164:
	asi64(R1) = mwindows_os_clock();
	pc_decls_sstime = asi64(R1);
	asi64(R1) = pc_api_mlabelno;
	mc_genss_initlib(asi64(R1));
	R1 = 0;
	mc_decls_ss_zdatalen = asi64(R1);
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mc_decls_ss_zdata = asu64(R1);
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mc_decls_ss_idata = asu64(R1);
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mc_decls_ss_code = asu64(R1);
	R1 = 0;
	mc_decls_ss_idatarelocs = asu64(R1);
	R1 = 0;
	mc_decls_ss_coderelocs = asu64(R1);
	R1 = 0;
	mc_decls_ss_nsymbols = asi64(R1);
	R1 = 1;
	mc_genss_switchseg(asi64(R1));
	R1 = 9999;
	mc_decls_aaseqno = asi64(R1);
	R1 = 0;
	mc_genss_extraparam = asu64(R1);
	asu64(R1) = mc_decls_mccode;
	m = asu64(R1);
	R1 = 0;
	index = asi64(R1);
	goto L3166;
L3165:
	R1 = (u64)&index;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = m;
	mc_genss_doinstr(asu64(R2), asi64(R1));
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L3166:
	asu64(R1) = m;
	if (asu64(R1)) goto L3165;
	R1 = 0;
	mc_genss_switchseg(asi64(R1));
	asu64(R1) = mc_decls_ss_zdata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	if (!asi64(R1)) goto L3169;
	R1 = tou64("Zdata contains code or data");
	mc_libmcl_axerror(asu64(R1));
L3169:
	asi64(R1) = obj;
	if (!asi64(R1)) goto L3171;
	R1 = 0;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	codeaddr = asu64(R1);
	asu64(R1) = mc_decls_riplist;
	pr = asu64(R1);
	goto L3175;
L3172:
	asu64(R1) = codeaddr;
	asu64(R2) = pr;
	R3 = 8;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	offsetptr = asu64(R1);
	asu64(R1) = pr;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = offsetptr;
	*tou32p(R2) -= asu32(R1);
	asu64(R1) = pr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pr = asu64(R1);
L3175:
	asu64(R1) = pr;
	if (asu64(R1)) goto L3172;
L3171:
	R1 = 1;
	pc_decls_ssdone = asu8(R1);
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = pc_decls_sstime;
	asi64(R1) -= asi64(R2);
	pc_decls_sstime = asi64(R1);
L3162:
	return;
}

static void mc_genss_doinstr(u64 m, i64 index) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 b;
	u64 d;
	u64 e;
	i64 x;
	i64 offset;
	i64 shortjmp;
	i64 n;
	i64 av_1;
	i64 av_2;
	asu64(R1) = mc_genss_currdata;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 1024;
	if (asi64(R1) >= asi64(R2)) goto L3178;
	asu64(R1) = mc_genss_currdata;
	mc_genss_bufferexpand(asu64(R1));
L3178:
	R1 = 0;
	R2 = R1;
	mc_genss_usesizeb = asu8(R2);
	R2 = R1;
	mc_genss_nowmask = asu8(R2);
	R2 = R1;
	mc_genss_f3override = asu8(R2);
	R2 = R1;
	mc_genss_f2override = asu8(R2);
	R2 = R1;
	mc_genss_addroverride = asu8(R2);
	R2 = R1;
	mc_genss_sizeoverride = asu8(R2);
	mc_genss_rex = asu8(R1);
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = m;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = m;
	R2 = 36;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	mc_decls_aaseqno = asi64(R1);
	asu64(R1) = m;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	mc_decls_aapos = asi64(R1);
	R1 = 0;
	mc_genss_ripentry = asu64(R1);
	asu64(R1) = m;
	mc_genss_currmcl = asu64(R1);
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: goto L3182;
	case 2: goto L3183;
	case 3: case 8: goto L3305;
	case 4: goto L3186;
	case 5: goto L3184;
	case 6: goto L3185;
	case 7: case 23: case 35: case 92: case 93: case 150: goto L3181;
	case 9: goto L3193;
	case 10: case 151: goto L3214;
	case 11: goto L3228;
	case 12: goto L3223;
	case 13: goto L3224;
	case 14: goto L3229;
	case 15: goto L3287;
	case 16: goto L3271;
	case 17: goto L3272;
	case 18: goto L3230;
	case 19: goto L3231;
	case 20: goto L3232;
	case 21: goto L3198;
	case 22: goto L3219;
	case 24: goto L3220;
	case 25: goto L3199;
	case 26: goto L3200;
	case 27: goto L3233;
	case 28: case 29: case 30: case 31: case 38: case 39: case 40: case 42: goto L3227;
	case 32: case 33: case 36: case 37: case 50: case 51: goto L3226;
	case 34: goto L3234;
	case 41: goto L3265;
	case 43: case 44: case 45: case 46: case 47: case 48: case 49: goto L3264;
	case 52: case 53: goto L3225;
	case 54: goto L3215;
	case 55: goto L3216;
	case 56: goto L3217;
	case 57: goto L3218;
	case 58: goto L3270;
	case 59: case 60: goto L3301;
	case 61: case 62: goto L3304;
	case 63: case 65: case 67: case 69: case 71: case 112: case 113: goto L3273;
	case 64: case 66: case 68: case 70: case 72: case 114: case 115: goto L3274;
	case 73: goto L3277;
	case 74: case 75: goto L3278;
	case 76: case 78: goto L3275;
	case 77: case 79: case 80: case 81: goto L3276;
	case 82: goto L3281;
	case 83: goto L3282;
	case 84: goto L3283;
	case 85: goto L3284;
	case 86: goto L3285;
	case 87: goto L3286;
	case 88: goto L3280;
	case 89: goto L3279;
	case 90: case 91: goto L3297;
	case 94: case 95: case 96: goto L3289;
	case 97: case 98: case 99: goto L3290;
	case 100: case 101: case 102: case 103: goto L3291;
	case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: goto L3288;
	case 116: goto L3207;
	case 117: goto L3208;
	case 118: goto L3209;
	case 119: goto L3210;
	case 120: goto L3212;
	case 121: goto L3213;
	case 122: goto L3211;
	case 123: goto L3248;
	case 124: case 125: case 126: case 127: goto L3235;
	case 128: goto L3269;
	case 129: case 130: case 131: goto L3266;
	case 132: goto L3267;
	case 133: goto L3268;
	case 134: goto L3292;
	case 135: goto L3293;
	case 136: goto L3294;
	case 137: goto L3295;
	case 138: goto L3296;
	case 139: goto L3300;
	case 140: goto L3303;
	case 141: goto L3298;
	case 142: case 143: case 144: case 145: case 146: case 147: case 148: goto L3299;
	case 149: goto L3302;
	default: goto L3181;
    };
// SWITCH
L3182:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_currasmproc = asu64(R1);
	goto L3179;
L3183:
	goto L3179;
L3184:
	goto L3179;
L3185:
	goto L3179;
L3186:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3188;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3189;
	goto L3190;
L3188:
	goto L3187;
L3189:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 2;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mc_genss_currseg;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3192;
	asu64(R1) = d;
	asi64(R1) = mc_genss_getstindex(asu64(R1));
L3192:
	asu64(R1) = d;
	mc_genss_dofwdrefs(asu64(R1));
	goto L3187;
L3190:
L3187:
	goto L3179;
L3193:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3195;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L3194;
L3195:
	asu64(R1) = mc_decls_labeldeftable;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
L3194:
	R1 = 2;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mc_genss_currseg;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	asu64(R2) = d;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3197;
	asu64(R1) = d;
	asi64(R1) = mc_genss_getstindex(asu64(R1));
L3197:
	asu64(R1) = d;
	mc_genss_dofwdrefs(asu64(R1));
	goto L3179;
L3198:
	asu64(R1) = a;
	mc_genss_do_call(asu64(R1));
	goto L3179;
L3199:
	asu64(R1) = m;
	asu64(R2) = a;
	mc_genss_do_jmp(asu64(R2), asu64(R1));
	goto L3179;
L3200:
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 7;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = d;
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3202;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) >= asi64(R2)) goto L3204;
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	R2 = 4;
	asi64(R1) -= asi64(R2);
	mc_genss_gendword(asi64(R1));
	goto L3203;
L3204:
	R1 = 112;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3203:
	goto L3201;
L3202:
	asu64(R1) = d;
	asu64(R2) = m;
	asi64(R1) = mc_genss_checkshortjump(asu64(R2), asu64(R1));
	shortjmp = asi64(R1);
	asi64(R1) = shortjmp;
	if (asi64(R1)) goto L3206;
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel32(asu64(R1));
	goto L3205;
L3206:
	R1 = 112;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel8(asu64(R1));
L3205:
L3201:
	goto L3179;
L3207:
	R1 = 1;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3179;
L3208:
	R1 = 2;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3179;
L3209:
	R1 = 4;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3179;
L3210:
	R1 = 8;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3179;
L3211:
	R1 = 1;
	mc_genss_switchseg(asi64(R1));
	goto L3179;
L3212:
	R1 = 2;
	mc_genss_switchseg(asi64(R1));
	goto L3179;
L3213:
	R1 = 3;
	mc_genss_switchseg(asi64(R1));
	goto L3179;
L3214:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3215:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 152;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3216:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 153;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3217:
	R1 = 153;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3218:
	R1 = 72;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 153;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3219:
	R1 = 195;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3220:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3222;
	R1 = tou64("retn?");
	mc_libmcl_axerror(asu64(R1));
L3222:
	R1 = 194;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_genword(asi64(R1));
	goto L3179;
L3223:
	asu64(R1) = a;
	mc_genss_do_push(asu64(R1));
	goto L3179;
L3224:
	asu64(R1) = a;
	mc_genss_do_pop(asu64(R1));
	goto L3179;
L3225:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	mc_genss_do_inc(asu64(R2), asi64(R1));
	goto L3179;
L3226:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	mc_genss_do_neg(asu64(R2), asi64(R1));
	goto L3179;
L3227:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_arith(asu64(R3), asu64(R2), asi64(R1));
	goto L3179;
L3228:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_mov(asu64(R2), asu64(R1));
	goto L3179;
L3229:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_lea(asu64(R2), asu64(R1));
	goto L3179;
L3230:
	R1 = 190;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movsx(asu64(R3), asu64(R2), asi64(R1));
	goto L3179;
L3231:
	R1 = 182;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movsx(asu64(R3), asu64(R2), asi64(R1));
	goto L3179;
L3232:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_movsxd(asu64(R2), asu64(R1));
	goto L3179;
L3233:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_exch(asu64(R2), asu64(R1));
	goto L3179;
L3234:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_imul2(asu64(R2), asu64(R1));
	goto L3179;
L3235:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3237;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_decls_mclcodes;
	asu64(R3) = m;
	R4 = 33;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) *= asi64(R2);
	n = asi64(R1);
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3239;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3240;
	goto L3241;
L3239:
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3244;
L3242:
	R1 = 144;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L3242;
L3244:
	goto L3238;
L3240:
	asi64(R1) = n;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3247;
L3245:
	R1 = 0;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_2)) goto L3245;
L3247:
	goto L3238;
L3241:
	asi64(R1) = n;
	R2 = (u64)&mc_decls_ss_zdatalen;
	*toi64p(R2) += asi64(R1);
L3238:
	goto L3236;
L3237:
	R1 = tou64("resb?");
	mc_libmcl_axerror(asu64(R1));
L3236:
	goto L3179;
L3248:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3250;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	x = asi64(R1);
	asi64(R1) = x;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3253;
	asi64(R1) = x;
	R2 = 16384;
	if (asi64(R1) <= asi64(R2)) goto L3252;
L3253:
	R1 = tou64("align2");
	mc_libmcl_axerror(asu64(R1));
L3252:
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = mc_genss_currseg;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3255;
	goto L3257;
L3256:
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3260;
	R1 = 144;
	goto L3259;
L3260:
	R1 = 0;
L3259:
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3257:
	asu64(R1) = mc_genss_currdata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	asi64(R2) = x;
	asi64(R1) %= asi64(R2);
	if (asi64(R1)) goto L3256;
	goto L3254;
L3255:
	goto L3262;
L3261:
	R1 = (u64)&mc_decls_ss_zdatalen;
	(*toi64p(R1)) += 1;
L3262:
	asi64(R1) = mc_decls_ss_zdatalen;
	asi64(R2) = x;
	asi64(R1) %= asi64(R2);
	if (asi64(R1)) goto L3261;
L3254:
	goto L3249;
L3250:
	R1 = tou64("align?");
	mc_libmcl_axerror(asu64(R1));
L3249:
	goto L3179;
L3264:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_shift(asu64(R3), asu64(R2), asi64(R1));
	goto L3179;
L3265:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_test(asu64(R2), asu64(R1));
	goto L3179;
L3266:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = a;
	mc_genss_do_loop(asu64(R2), asi64(R1));
	goto L3179;
L3267:
	R1 = 4;
	asu64(R2) = a;
	mc_genss_do_jcxz(asu64(R2), asi64(R1));
	goto L3179;
L3268:
	R1 = 8;
	asu64(R2) = a;
	mc_genss_do_jcxz(asu64(R2), asi64(R1));
	goto L3179;
L3269:
	R1 = 215;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3270:
	asu64(R1) = a;
	asu64(R2) = m;
	R3 = 34;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	mc_genss_do_setcc(asi64(R2), asu64(R1));
	goto L3179;
L3271:
	R1 = 4;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movxmm(asu64(R3), asu64(R2), asi64(R1));
	goto L3179;
L3272:
	R1 = 8;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movxmm(asu64(R3), asu64(R2), asi64(R1));
	goto L3179;
L3273:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 243;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3179;
L3274:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 242;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3179;
L3275:
	R1 = 4;
	R2 = (u64)&mc_decls_mclcodes;
	asu64(R3) = m;
	R4 = 33;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_logicxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3179;
L3276:
	R1 = 8;
	R2 = (u64)&mc_decls_mclcodes;
	asu64(R3) = m;
	R4 = 33;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_logicxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3179;
L3277:
	R1 = 47;
	R2 = 0;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3179;
L3278:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 102;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_arithxmm(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3179;
L3279:
	R1 = 243;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_convertfloat(asu64(R3), asu64(R2), asi64(R1));
	goto L3179;
L3280:
	R1 = 242;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_convertfloat(asu64(R3), asu64(R2), asi64(R1));
	goto L3179;
L3281:
	R1 = 45;
	R2 = 243;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3179;
L3282:
	R1 = 45;
	R2 = 242;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3179;
L3283:
	R1 = 44;
	R2 = 243;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3179;
L3284:
	R1 = 44;
	R2 = 242;
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_fix(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3179;
L3285:
	R1 = 243;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_float(asu64(R3), asu64(R2), asi64(R1));
	goto L3179;
L3286:
	R1 = 242;
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_float(asu64(R3), asu64(R2), asi64(R1));
	goto L3179;
L3287:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = m;
	R4 = 34;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	mc_genss_do_cmovcc(asi64(R3), asu64(R2), asu64(R1));
	goto L3179;
L3288:
	R1 = 217;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3289:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asu64(R3) = a;
	mc_genss_do_fmem(asu64(R3), asi64(R2), asi64(R1));
	goto L3179;
L3290:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	asu64(R3) = a;
	mc_genss_do_fmem(asu64(R3), asi64(R2), asi64(R1));
	goto L3179;
L3291:
	R1 = 222;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3292:
	R1 = 166;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3293:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 167;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3294:
	R1 = 167;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3295:
	R1 = 72;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 167;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3296:
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3297:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_movdqx(asu64(R3), asu64(R2), asi64(R1));
	goto L3179;
L3298:
	R1 = 219;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 227;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3299:
	R1 = 217;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3300:
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_popcnt(asu64(R2), asu64(R1));
	goto L3179;
L3301:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	asu64(R3) = a;
	mc_genss_do_bsf(asu64(R3), asu64(R2), asi64(R1));
	goto L3179;
L3302:
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 162;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3179;
L3303:
	asu64(R1) = a;
	mc_genss_do_bswap(asu64(R1));
	goto L3179;
L3304:
	R1 = (u64)&mc_decls_mclcodes;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asu64(R2) = m;
	R3 = 32;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = b;
	asu64(R4) = a;
	mc_genss_do_dshift(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L3179;
L3305:
	goto L3179;
L3181:
	msysc_m$print_startcon();
	R1 = tou64("*** Can't do opcode");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mc_decls_mclnames;
	asu64(R2) = m;
	R3 = 33;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("line");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aaseqno;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M.OPCODE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("M_HALT=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 151;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("STOPPING");
	mc_libmcl_axerror(asu64(R1));
L3179:
	return;
}

static void mc_genss_start() {
    u64 R1, R2, R3; 
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 64;
	R2 = (u64)&mc_genss_ishighreg;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mc_genss_genword(i64 x) {
    u64 R1, R2; 
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_addword(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_gendword(i64 x) {
    u64 R1, R2; 
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_adddword(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_genqword(i64 x) {
    u64 R1, R2; 
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	mc_genss_addqword(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_genopnd(u64 a, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 s;
	i64 x;
	i64 length;
	r32 x32;
	asi64(R1) = size;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3312;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	size = asi64(R1);
L3312:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3314;
	R2 = 7;
	if (asu64(R1) == asu64(R2)) goto L3315;
	goto L3316;
L3314:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 100;
	if (asi64(R1) <= asi64(R2)) goto L3318;
	R1 = 1024;
	asi64(R2) = length;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asi64(R1) = Max(asi64(R1), asi64(R2));
	asu64(R2) = mc_genss_currdata;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
L3318:
	goto L3320;
L3319:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3320:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L3319;
	goto L3310;
	goto L3313;
L3315:
	msysc_m$print_startcon();
	R1 = tou64("GENSS/NAME OPND");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L3313;
L3316:
L3313:
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L3323;
	asi64(R1) = size;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3323;
	R1 = tou64("8/16-BIT RELOC");
	mc_libmcl_axerror(asu64(R1));
L3323:
	asi64(R1) = size;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3325;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3326;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3327;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3328;
	goto L3329;
L3325:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3324;
L3326:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_genword(asi64(R1));
	goto L3324;
L3327:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3331;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3332;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3333;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3333;
	goto L3334;
L3331:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_gendword(asi64(R1));
	goto L3330;
L3332:
	asu64(R1) = a;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
    asr32(R1) = tor32(asr64(R1));
	x32 = asr32(R1);
	asr32(R1) = x32;
	asi32(R1) = asi32(R1);
	mc_genss_gendword(asi64(R1));
	goto L3330;
L3333:
	asu64(R1) = a;
	mc_genss_genabs32(asu64(R1));
	goto L3330;
L3334:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_valtypenames;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("OPND/4/VALTYPE?");
	mc_libmcl_axerror(asu64(R1));
L3330:
	goto L3324;
L3328:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3336;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3337;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3338;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3338;
	goto L3339;
L3336:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_genqword(asi64(R1));
	goto L3335;
L3337:
	asu64(R1) = a;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asi64(R1) = asi64(R1);
	mc_genss_genqword(asi64(R1));
	goto L3335;
L3338:
	asu64(R1) = a;
	mc_genss_genabs64(asu64(R1));
	goto L3335;
L3339:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_valtypenames;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("OPND/8/VALTYPE?");
	mc_libmcl_axerror(asu64(R1));
L3335:
	goto L3324;
L3329:
L3324:
L3310:
	return;
}

static void mc_genss_addrelocitem(i64 reloctype, u64 d) {
    u64 R1, R2, R3; 
	u64 r;
	i64 stindex;
	i64 adjust;
	asu64(R1) = d;
	asi64(R1) = mc_genss_getstindex(asu64(R1));
	stindex = asi64(R1);
	R1 = 4;
	adjust = asi64(R1);
	asi64(R1) = reloctype;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3342;
	R1 = 8;
	adjust = asi64(R1);
L3342:
	R1 = 32;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	r = asu64(R1);
	asu64(R1) = mc_genss_currrelocs;
	asu64(R2) = r;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = reloctype;
	asu64(R2) = r;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	asi64(R2) = adjust;
	asi64(R1) -= asi64(R2);
	asu64(R2) = r;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = stindex;
	asu64(R2) = r;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_genss_nrelocs;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	mc_genss_currrelocs = asu64(R1);
	return;
}

static i64 mc_genss_getstindex(u64 d) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = d;
	R2 = 96;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3345;
	asi64(R1) = mc_decls_ss_nsymbols;
	asi64(R2) = mc_decls_ss_symboltablesize;
	if (asi64(R1) < asi64(R2)) goto L3347;
	mc_genss_extendsymboltable();
L3347:
	R1 = (u64)&mc_decls_ss_nsymbols;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 96;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = d;
	asu64(R2) = mc_decls_ss_symboltable;
	asu64(R3) = d;
	R4 = 96;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3349;
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3351;
	R1 = 1;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3351:
L3349:
L3345:
	asu64(R1) = d;
	R2 = 96;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L3343;
L3343:
	return asi64(R1);
}

static void mc_genss_genrel32(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3354;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_gendword(asi64(R1));
	goto L3352;
L3354:
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3356;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3357;
	goto L3358;
L3356:
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_genss_currseg;
	if (asi64(R1) == asi64(R2)) goto L3360;
	R1 = tou64("Rel label across segments");
	mc_libmcl_axerror(asu64(R1));
L3360:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	asi64(R2) = mc_genss_getcurrdatalen(asi64(R2));
	R3 = 4;
	asi64(R2) += asi64(R3);
	asi64(R1) -= asi64(R2);
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_gendword(asi64(R1));
	goto L3355;
L3357:
	R1 = 0;
	R2 = 4;
	R3 = 3;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	goto L3355;
L3358:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 4;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3355:
L3352:
	return;
}

static u64 mc_genss_getdef(u64 a, i64 dneeded) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3364;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3363;
L3364:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3366;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3367;
	goto L3368;
L3366:
	asu64(R1) = mc_decls_labeldeftable;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L3361;
	goto L3365;
L3367:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3370;
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3372;
	R1 = 1;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3372:
L3370:
	asu64(R1) = d;
	goto L3361;
	goto L3365;
L3368:
L3365:
L3363:
	asi64(R1) = dneeded;
	if (!asi64(R1)) goto L3374;
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_opndnames_ma;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mc_decls_valtypenames;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("getdef/no def");
	mc_libmcl_axerror(asu64(R1));
L3374:
	R1 = 0;
	goto L3361;
L3361:
	return asu64(R1);
}

static void mc_genss_genabs32(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3377;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3378;
	goto L3379;
L3377:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 2;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
	goto L3376;
L3378:
	asi64(R1) = mc_genss_currseg;
	R2 = 2;
	R3 = 4;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3382;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3381;
L3382:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_gendword(asi64(R1));
	goto L3380;
L3381:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 2;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3380:
	goto L3376;
L3379:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	asu64(R1) = d;
	R2 = 2;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3376:
	return;
}

static void mc_genss_genabs64(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3385;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3386;
	goto L3387;
L3385:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_genqword(asi64(R1));
	asu64(R1) = d;
	R2 = 1;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
	goto L3384;
L3386:
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	R3 = 5;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3390;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3389;
L3390:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	mc_genss_genqword(asi64(R1));
	goto L3388;
L3389:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_genqword(asi64(R1));
	asu64(R1) = d;
	R2 = 1;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3388:
	goto L3384;
L3387:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_genqword(asi64(R1));
	asu64(R1) = d;
	R2 = 1;
	mc_genss_addrelocitem(asi64(R2), asu64(R1));
L3384:
	return;
}

static i64 mc_genss_getrel32(u64 d, i64 offset) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3393;
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mc_genss_currseg;
	if (asi64(R1) == asi64(R2)) goto L3395;
	R1 = tou64("Rel label across segments2");
	mc_libmcl_axerror(asu64(R1));
L3395:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	R3 = 1;
	asi64(R2) += asi64(R3);
	asi64(R1) -= asi64(R2);
	goto L3392;
L3393:
	R1 = 2147483647;
L3392:
	goto L3391;
L3391:
	return asi64(R1);
}

static void mc_genss_dofwdrefs(u64 d) {
    u64 R1, R2, R3; 
	u64 f;
	i64 offset;
	i64 seg;
	u64 p8;
	u64 p32;
	u64 p64;
	u64 data;
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3398;
	goto L3396;
L3398:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	goto L3400;
L3399:
	asu64(R1) = f;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	asu64(R1) = f;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3403;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3404;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3404;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3405;
	goto L3406;
L3403:
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p32 = asu64(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = 4;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p32;
	*toi32p(R2) = asi32(R1);
	goto L3402;
L3404:
	asu64(R1) = f;
	R2 = 14;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3408;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3409;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3410;
	goto L3411;
L3408:
	asu64(R1) = mc_decls_ss_code;
	data = asu64(R1);
	goto L3407;
L3409:
	R1 = tou64("Fwd ref in zdata");
	mc_libmcl_axerror(asu64(R1));
	goto L3407;
L3410:
	asu64(R1) = mc_decls_ss_idata;
	data = asu64(R1);
	goto L3407;
L3411:
L3407:
	asi64(R1) = offset;
	asu64(R2) = data;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p32 = asu64(R1);
	asu64(R1) = f;
	R2 = 12;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3413;
	asu64(R1) = p32;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = p32;
	*toi32p(R2) = asi32(R1);
	goto L3412;
L3413:
	asu64(R1) = p32;
	p64 = asu64(R1);
	asu64(R1) = p64;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = p64;
	*toi64p(R2) = asi64(R1);
L3412:
	goto L3402;
L3405:
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p8 = asu64(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p8;
	*tou8p(R2) = asu8(R1);
	goto L3402;
L3406:
	msysc_m$print_startcon();
	R1 = (u64)&mc_objdecls_relocnames;
	asu64(R2) = f;
	R3 = 12;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("DOFWDREFS/CAN'T DO RELTYPE");
	mc_libmcl_axerror(asu64(R1));
L3402:
	asu64(R1) = f;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
L3400:
	asu64(R1) = f;
	if (asu64(R1)) goto L3399;
L3396:
	return;
}

static void mc_genss_genrex() {
    u64 R1, R2, R3; 
	asu8(R1) = mc_genss_f2override;
	if (!asu8(R1)) goto L3416;
	R1 = 242;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3416:
	asu8(R1) = mc_genss_f3override;
	if (!asu8(R1)) goto L3418;
	R1 = 243;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3418:
	asu8(R1) = mc_genss_sizeoverride;
	if (!asu8(R1)) goto L3420;
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3420:
	asu8(R1) = mc_genss_addroverride;
	if (!asu8(R1)) goto L3422;
	R1 = 103;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3422:
	asu8(R1) = mc_genss_nowmask;
	if (!asu8(R1)) goto L3424;
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L3424:
	asu8(R1) = mc_genss_rex;
	if (!asu8(R1)) goto L3426;
	asu8(R1) = mc_genss_rex;
	R1 = toi64(tou8(R1));
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = 64;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3426:
	return;
}

static i64 mc_genss_isbytesized(i64 x) {
    u64 R1, R2; 
	R1 = -128;
	asi64(R2) = x;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3428;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L3428;
	R1 = 1;
	goto L3429;
L3428:
	R1 = 0;
L3429:
	goto L3427;
L3427:
	return asi64(R1);
}

static i64 mc_genss_isdwordsized(i64 x) {
    u64 R1, R2; 
	R1 = -2147483648;
	asi64(R2) = x;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3431;
	R2 = 2147483647;
	if (asi64(R1) > asi64(R2)) goto L3431;
	R1 = 1;
	goto L3432;
L3431:
	R1 = 0;
L3432:
	goto L3430;
L3430:
	return asi64(R1);
}

static void mc_genss_genamode(u64 a, u64 am) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 pr;
	R1 = (u64)&am;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&am;
	R2 = 2;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3435;
	R1 = (u64)&am;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3435:
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3437;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3438;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3439;
	goto L3440;
L3437:
	goto L3436;
L3438:
	R1 = (u64)&am;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3436;
L3439:
	R1 = (u64)&am;
	R2 = 2;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L3442;
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pr = asu64(R1);
	asu64(R1) = mc_decls_riplist;
	asu64(R2) = pr;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_genss_currdata;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pr;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pr;
	R2 = R1;
	mc_decls_riplist = asu64(R2);
	mc_genss_ripentry = asu64(R1);
L3442:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3444;
	goto L3445;
L3444:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3447;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3447;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3448;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3448;
	goto L3449;
L3447:
	asu64(R1) = a;
	mc_genss_genabs32(asu64(R1));
	goto L3446;
L3448:
	R1 = (u64)&am;
	R2 = 4;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mc_genss_gendword(asi64(R1));
	goto L3446;
L3449:
	R1 = tou64("genam/3");
	mc_libmcl_axerror(asu64(R1));
L3446:
	goto L3443;
L3445:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_opndnames_ma;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("GENAMODE/MODE?");
	mc_libmcl_axerror(asu64(R1));
L3443:
	goto L3436;
L3440:
	R1 = tou64("genamode size 2/8");
	mc_libmcl_axerror(asu64(R1));
L3436:
	return;
}

static void mc_genss_setopsize(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3452;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3453;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3454;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3455;
	goto L3456;
L3452:
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	goto L3451;
L3453:
	goto L3451;
L3454:
	goto L3451;
L3455:
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	goto L3451;
L3456:
	R1 = tou64("Operand size not set");
	mc_libmcl_axerror(asu64(R1));
L3451:
	return;
}

static i64 mc_genss_getdispsize(u64 a, u64 offset) {
    u64 R1, R2; 
	u64 d;
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = offset;
	*toi32p(R2) = asi32(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L3459;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3462;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3461;
L3462:
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = offset;
	*toi32p(R2) += asi32(R1);
	goto L3460;
L3461:
	R1 = 4;
	goto L3457;
L3460:
L3459:
	asu64(R1) = offset;
	asi32(R1) = *toi32p(R1);
	if (!asi32(R1)) goto L3464;
	asu64(R1) = offset;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asi64(R1) = mc_genss_isbytesized(asi64(R1));
	if (!asi64(R1)) goto L3466;
	R1 = 1;
	goto L3465;
L3466:
	R1 = 4;
L3465:
	goto L3463;
L3464:
	R1 = 0;
L3463:
	goto L3457;
L3457:
	return asi64(R1);
}

static void mc_genss_checkhighreg(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3469;
	R1 = (u64)&mc_genss_ishighreg;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3469:
	return;
}

static void mc_genss_do_loop(u64 a, i64 opc) {
    u64 R1, R2, R3; 
	i64 offset;
	R1 = 9;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asu64(R3) = a;
	asu64(R2) = mc_genss_getdef(asu64(R3), asi64(R2));
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3472;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) >= asi64(R2)) goto L3474;
	R1 = tou64("loop jmp out of range");
	mc_libmcl_axerror(asu64(R1));
L3474:
	asi64(R1) = opc;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3471;
L3472:
	R1 = tou64("Can't do loopxx fwd jump");
	mc_libmcl_axerror(asu64(R1));
L3471:
	return;
}

static void mc_genss_do_jcxz(u64 a, i64 opsize) {
    u64 R1, R2, R3; 
	i64 offset;
	R1 = 10;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asu64(R3) = a;
	asu64(R2) = mc_genss_getdef(asu64(R3), asi64(R2));
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3477;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) >= asi64(R2)) goto L3479;
	R1 = tou64("jcxz jmp out of range");
	mc_libmcl_axerror(asu64(R1));
L3479:
	asi64(R1) = opsize;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3481;
	R1 = 103;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3481:
	R1 = 227;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3476;
L3477:
	R1 = tou64("Can't do jcxz fwd jump");
	mc_libmcl_axerror(asu64(R1));
L3476:
	return;
}

static void mc_genss_do_call(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3484;
	goto L3485;
L3484:
	R1 = 232;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel32(asu64(R1));
	goto L3483;
L3485:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3487;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3488;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3488;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3488;
	goto L3489;
L3487:
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L3486;
L3488:
	R1 = tou64("call[]size");
	mc_libmcl_axerror(asu64(R1));
	goto L3486;
L3489:
L3486:
	asu64(R1) = a;
	R2 = 2;
	R3 = 255;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
L3483:
	return;
}

static void mc_genss_do_jmp(u64 a, u64 m) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	i64 offset;
	i64 shortjmp;
	u64 d;
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3492;
	goto L3493;
L3492:
	R1 = 11;
	asi64(R1) = mc_genss_getcurrdatalen(asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = d;
	asi64(R1) = mc_genss_getrel32(asu64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3495;
	asi64(R1) = offset;
	R2 = -126;
	if (asi64(R1) <= asi64(R2)) goto L3495;
	R1 = 235;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = offset;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3494;
L3495:
	R1 = 0;
	shortjmp = asi64(R1);
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3497;
	asu64(R1) = d;
	asu64(R2) = m;
	asi64(R1) = mc_genss_checkshortjump(asu64(R2), asu64(R1));
	shortjmp = asi64(R1);
L3497:
	asi64(R1) = shortjmp;
	if (asi64(R1)) goto L3499;
	R1 = 233;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel32(asu64(R1));
	goto L3498;
L3499:
	R1 = 235;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	mc_genss_genrel8(asu64(R1));
L3498:
L3494:
	goto L3491;
L3493:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3501;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3502;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3502;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3502;
	goto L3503;
L3501:
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	goto L3500;
L3502:
	R1 = tou64("jmp[]size");
	mc_libmcl_axerror(asu64(R1));
	goto L3500;
L3503:
L3500:
	asu64(R1) = a;
	R2 = 4;
	R3 = 255;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
L3491:
	return;
}

static i64 mc_genss_getcurrdatalen(i64 id) {
    u64 R1, R2; 
	asi64(R1) = mc_genss_currseg;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3506;
	asi64(R1) = mc_decls_ss_zdatalen;
	goto L3504;
L3506:
	asu64(R1) = mc_genss_currdata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	goto L3504;
L3504:
	return asi64(R1);
}

static void mc_genss_do_cmovcc(i64 cond, u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3509;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3509;
	R1 = tou64("1:Opnd size mismatch");
	mc_libmcl_axerror(asu64(R1));
L3509:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3511;
	R1 = tou64("cmov/byte");
	mc_libmcl_axerror(asu64(R1));
L3511:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3904;
	asi64(R4) = cond;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_fmem(u64 a, i64 freal, i64 code) {
    u64 R1, R2, R3, R4, R5; 
	i64 am;
	i64 regcode;
	i64 mf;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3514;
	R1 = tou64("fmem/not mem");
	mc_libmcl_axerror(asu64(R1));
L3514:
	asi64(R1) = freal;
	if (!asi64(R1)) goto L3516;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3518;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3519;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3520;
	R2 = 16;
	if (asu64(R1) == asu64(R2)) goto L3520;
	goto L3521;
L3518:
	R1 = 0;
	mf = asi64(R1);
	goto L3517;
L3519:
	R1 = 2;
	mf = asi64(R1);
	goto L3517;
L3520:
	R1 = 1;
	mf = asi64(R1);
	asi64(R1) = code;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3523;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3524;
	goto L3525;
L3523:
	R1 = 5;
	code = asi64(R1);
	goto L3522;
L3524:
	R1 = 7;
	code = asi64(R1);
	goto L3522;
L3525:
	R1 = tou64("r80 not allowed");
	mc_libmcl_axerror(asu64(R1));
L3522:
	goto L3517;
L3521:
	msysc_m$print_startcon();
	R1 = tou64("SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("fmem size");
	mc_libmcl_axerror(asu64(R1));
L3517:
	goto L3515;
L3516:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3527;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3528;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3529;
	goto L3530;
L3527:
	R1 = 3;
	mf = asi64(R1);
	goto L3526;
L3528:
	R1 = 1;
	mf = asi64(R1);
	goto L3526;
L3529:
	R1 = 3;
	mf = asi64(R1);
	asi64(R1) = code;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3532;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3533;
	goto L3534;
L3532:
	R1 = 5;
	code = asi64(R1);
	goto L3531;
L3533:
	R1 = 7;
	code = asi64(R1);
	goto L3531;
L3534:
	R1 = tou64("fst i64?");
	mc_libmcl_axerror(asu64(R1));
L3531:
	goto L3526;
L3530:
	R1 = tou64("fmem int size");
	mc_libmcl_axerror(asu64(R1));
L3526:
L3515:
	asu64(R1) = a;
	asi64(R2) = code;
	R3 = 217;
	asi64(R4) = mf;
	R5 = 1;
	asi64(R4) <<= asi64(R5);
	asi64(R3) += asi64(R4);
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	return;
}

static void mc_genss_genrel8(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	R1 = 1;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 93;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3537;
	R1 = 0;
	R2 = 6;
	R3 = 3;
	asi64(R3) = mc_genss_getcurrdatalen(asi64(R3));
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mc_genss_addfwdref(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3536;
L3537:
	R1 = tou64("genrel8");
	mc_libmcl_axerror(asu64(R1));
L3536:
	return;
}

static i64 mc_genss_checkshortjump(u64 m, u64 d) {
    u64 R1, R2, R3; 
	i64 n;
	u64 a;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
	goto L3540;
L3539:
	asu64(R1) = m;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3543;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3544;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3544;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L3545;
	goto L3546;
L3543:
	asu64(R1) = m;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3548;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3549;
	goto L3550;
L3548:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 100;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) != asi64(R2)) goto L3552;
	R1 = 1;
	goto L3538;
L3552:
	goto L3547;
L3549:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L3554;
	R1 = 1;
	goto L3538;
L3554:
	goto L3547;
L3550:
L3547:
	goto L3542;
L3544:
	goto L3542;
L3545:
	R1 = 0;
	goto L3538;
	goto L3542;
L3546:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
L3542:
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L3540:
	asu64(R1) = m;
	if (!asu64(R1)) goto L3555;
	asi64(R1) = n;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L3539;
L3555:
	R1 = 0;
	goto L3538;
L3538:
	return asi64(R1);
}

static u64 mc_genss_addfwdref(u64 p, i64 offset, i64 reltype, i64 seg) {
    u64 R1, R2, R3; 
	u64 q;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = q;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = reltype;
	asu64(R2) = q;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = seg;
	asu64(R2) = q;
	R3 = 14;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = q;
	goto L3556;
L3556:
	return asu64(R1);
}

static void mc_genss_switchseg(i64 newseg) {
    u64 R1, R2; 
	asi64(R1) = newseg;
	asi64(R2) = mc_genss_currseg;
	if (asi64(R1) != asi64(R2)) goto L3559;
	goto L3557;
L3559:
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3561;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3562;
	goto L3563;
L3561:
	asu64(R1) = mc_genss_currrelocs;
	mc_decls_ss_coderelocs = asu64(R1);
	asi64(R1) = mc_genss_nrelocs;
	mc_decls_ss_ncoderelocs = asi64(R1);
	goto L3560;
L3562:
	asu64(R1) = mc_genss_currrelocs;
	mc_decls_ss_idatarelocs = asu64(R1);
	asi64(R1) = mc_genss_nrelocs;
	mc_decls_ss_nidatarelocs = asi64(R1);
	goto L3560;
L3563:
L3560:
	asi64(R1) = newseg;
	mc_genss_currseg = asi64(R1);
	asi64(R1) = mc_genss_currseg;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3565;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3566;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3567;
	goto L3568;
L3565:
	asu64(R1) = mc_decls_ss_code;
	mc_genss_currdata = asu64(R1);
	asu64(R1) = mc_decls_ss_coderelocs;
	mc_genss_currrelocs = asu64(R1);
	asi64(R1) = mc_decls_ss_ncoderelocs;
	mc_genss_nrelocs = asi64(R1);
	goto L3564;
L3566:
	asu64(R1) = mc_decls_ss_idata;
	mc_genss_currdata = asu64(R1);
	asu64(R1) = mc_decls_ss_idatarelocs;
	mc_genss_currrelocs = asu64(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	mc_genss_nrelocs = asi64(R1);
	goto L3564;
L3567:
	asu64(R1) = mc_decls_ss_zdata;
	mc_genss_currdata = asu64(R1);
	goto L3564;
L3568:
L3564:
L3557:
	return;
}

static void mc_genss_do_popcnt(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3571;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3573;
	R1 = 8;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3573:
L3571:
	R1 = 1;
	mc_genss_f3override = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 4024;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_bsf(u64 a, u64 b, i64 opc) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3576;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3578;
	R1 = 8;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3578:
L3576:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3580;
	R1 = tou64("bsf size");
	mc_libmcl_axerror(asu64(R1));
L3580:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_extendsymboltable() {
    u64 R1, R2, R3; 
	u64 oldsymboltable;
	i64 oldsymboltablesize;
	i64 i;
	asi64(R1) = mc_decls_ss_symboltablesize;
	oldsymboltablesize = asi64(R1);
	asu64(R1) = mc_decls_ss_symboltable;
	oldsymboltable = asu64(R1);
	R1 = 2;
	R2 = (u64)&mc_decls_ss_symboltablesize;
	*toi64p(R2) *= asi64(R1);
	R1 = 8;
	asi64(R2) = mc_decls_ss_symboltablesize;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	mc_decls_ss_symboltable = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3584;
L3582:
	asu64(R1) = oldsymboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = mc_decls_ss_symboltable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L3582;
L3584:
	R1 = 8;
	asi64(R2) = oldsymboltablesize;
	asi64(R1) *= asi64(R2);
	asu64(R2) = oldsymboltable;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void mc_genss_initlib(i64 nlabels) {
    u64 R1, R2, R3, R4; 
	struct $B16 str;
	u64 d;
	i64 i;
	R1 = 262144;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	mc_decls_ss_symboltable = asu64(R1);
	R1 = 32768;
	mc_decls_ss_symboltablesize = asi64(R1);
	R1 = 0;
	mc_decls_ss_nsymbols = asi64(R1);
	asi64(R1) = nlabels;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	mc_decls_labeldeftable = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nlabels;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3588;
L3586:
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	R2 = R1;
	asu64(R3) = mc_decls_labeldeftable;
	asi64(R4) = i;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	d = asu64(R1);
	asi64(R1) = i;
	asu64(R2) = d;
	R3 = 100;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("l#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 93;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= nlabels) goto L3586;
L3588:
	return;
}

static u64 mc_genss_buffercreate(i64 size) {
    u64 R1, R2, R3, R4; 
	u64 a;
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	a = asu64(R1);
	asi64(R1) = size;
	asu64(R2) = a;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = a;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	asu64(R3) = a;
	R4 = 8;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = a;
	goto L3589;
L3589:
	return asu64(R1);
}

static void mc_genss_bufferexpand(u64 a) {
    u64 R1, R2, R3; 
	i64 newalloc;
	i64 usedbytes;
	u64 p;
	asu64(R1) = a;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newalloc = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	usedbytes = asi64(R1);
	asi64(R1) = usedbytes;
	asu64(R2) = a;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L3592;
	msysc_m$print_startcon();
	R1 = tou64("dbuffer error");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	exit(R1);
L3592:
	asi64(R1) = newalloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = usedbytes;
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = a;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asi64(R2) = usedbytes;
	R1 += (i64)R2;
	asu64(R2) = a;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = newalloc;
	asu64(R2) = a;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	asi64(R2) = newalloc;
	R1 += (i64)R2;
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mc_genss_buffercheck(u64 a, i64 n) {
    u64 R1, R2, R3; 
	goto L3595;
L3594:
	asu64(R1) = a;
	mc_genss_bufferexpand(asu64(R1));
L3595:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	asi64(R2) = n;
	if (asi64(R1) < asi64(R2)) goto L3594;
	return;
}

static i64 mc_genss_bufferlength(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	goto L3597;
L3597:
	return asi64(R1);
}

static u64 mc_genss_bufferelemptr(u64 a, i64 offset) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = offset;
	R1 += (i64)R2;
	goto L3598;
L3598:
	return asu64(R1);
}

static void mc_genss_addword(u64 a, i64 x) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou16p(R2) = asu16(R1);
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	(*tou64p(R1)) += 2;
	return;
}

static void mc_genss_adddword(u64 a, i64 x) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou32p(R2) = asu32(R1);
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	(*tou64p(R1)) += 4;
	return;
}

static void mc_genss_addqword(u64 a, i64 x) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = a;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou64p(R2) = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	R1 += (i64)R2;
	(*tou64p(R1)) += 8;
	return;
}

static void mc_genss_genxrm(i64 opcode, i64 code, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 am;
	asu64(R1) = b;
	mc_genss_setopsize(asu64(R1));
	R1 = 0;
	asu64(R2) = b;
	asi64(R3) = code;
	R4 = 0;
	asu64(R1) = mc_genss_genrm(asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	am = asu64(R1);
	asu64(R1) = mc_genss_currmcl;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L3604;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3604;
	goto L3605;
L3604:
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L3603;
L3605:
L3603:
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3607;
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 24;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3607:
	mc_genss_genrex();
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3609;
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3609:
	asi64(R1) = opcode;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = am;
	asu64(R2) = b;
	mc_genss_genamode(asu64(R2), asu64(R1));
	return;
}

static void mc_genss_genrrm(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	u64 am;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3612;
	R1 = (u64)&mc_genss_ishighreg;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3612:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	asu8(R1) = mc_genss_usesizeb;
	if (!asu8(R1)) goto L3614;
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3616;
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3616:
L3614:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = b;
	R3 = 0;
	asu64(R4) = a;
	R5 = 10;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R1) = mc_genss_genrm(asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	am = asu64(R1);
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3618;
	asi64(R1) = opcode;
	R2 = 16;
	R3 = 24;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3618:
	mc_genss_genrex();
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3620;
	asi64(R1) = opcode;
	R2 = 8;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3620:
	asi64(R1) = opcode;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = am;
	asu64(R2) = b;
	mc_genss_genamode(asu64(R2), asu64(R1));
	return;
}

static i64 mc_genss_getregcode(i64 reg, i64 mask, i64 isxreg) {
    u64 R1, R2; 
	i64 regcode;
	asi64(R1) = isxreg;
	if (asi64(R1)) goto L3623;
	R1 = (u64)&mc_decls_regcodes;
	asi64(R2) = reg;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	regcode = asi64(R1);
	goto L3622;
L3623:
	asi64(R1) = reg;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	regcode = asi64(R1);
L3622:
	asi64(R1) = regcode;
	R2 = 8;
	if (asi64(R1) < asi64(R2)) goto L3625;
	R1 = 8;
	R2 = (u64)&regcode;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = mask;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
L3625:
	asi64(R1) = regcode;
	goto L3621;
L3621:
	return asi64(R1);
}

static void mc_genss_checkimmrange(i64 value, i64 size) {
    u64 R1, R2; 
	asi64(R1) = size;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3628;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3629;
	goto L3630;
L3628:
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3633;
	R2 = 255;
	if (asi64(R1) <= asi64(R2)) goto L3632;
L3633:
	R1 = tou64("exceeding byte value");
	mc_libmcl_axerror(asu64(R1));
L3632:
	goto L3627;
L3629:
	R1 = -32768;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3636;
	R2 = 65535;
	if (asi64(R1) <= asi64(R2)) goto L3635;
L3636:
	R1 = tou64("exceeding u16 value");
	mc_libmcl_axerror(asu64(R1));
L3635:
	goto L3627;
L3630:
	R1 = -2147483648;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3639;
	R2 = 4294967295;
	if (asi64(R1) <= asi64(R2)) goto L3638;
L3639:
	R1 = tou64("2:exceeding u32 value");
	mc_libmcl_axerror(asu64(R1));
L3638:
L3627:
	return;
}

static u64 mc_genss_genrm(i64 reg, i64 opc, u64 b, i64 isxreg) {
    u64 R1, R2, R3, R4; 
	i64 mode;
	i64 rm;
	i64 scale;
	i64 index;
	i64 base;
	i64 regix;
	i64 code;
	i64 ismem;
	u64 am;
// PROC LOCAL STATICS GO HERE
	static struct $B32 mc_genss_genrm_scaletable = {{
	0,
	1,
	0,
	2,
	0,
	0,
	0,
	3    }};
	R1 = (u64)&am;
	memset(R1, 0, 8);
	asi64(R1) = reg;
	if (!asi64(R1)) goto L3642;
	asi64(R1) = isxreg;
	R2 = 4;
	asi64(R3) = reg;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	opc = asi64(R1);
L3642:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3644;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3644;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3645;
	goto L3646;
L3644:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	R2 = 1;
	asu64(R3) = b;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	rm = asi64(R1);
	R1 = (u64)&mc_genss_ishighreg;
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	R1 = 192;
	asi64(R2) = opc;
	R3 = 3;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = rm;
	asi64(R1) += asi64(R2);
	R2 = (u64)&am;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = am;
	goto L3640;
	goto L3643;
L3645:
	R1 = 1;
	ismem = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3648;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3649;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L3650;
	goto L3651;
L3648:
	asu64(R1) = b;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3653;
	R1 = 2;
	ismem = asi64(R1);
L3653:
	goto L3647;
L3649:
	R1 = 2;
	ismem = asi64(R1);
	goto L3647;
L3650:
	R1 = 2;
	ismem = asi64(R1);
	goto L3647;
L3651:
L3647:
	goto L3643;
L3646:
	R1 = tou64("genrm not mem");
	mc_libmcl_axerror(asu64(R1));
L3643:
	R1 = 0;
	R2 = R1;
	rm = asi64(R2);
	mode = asi64(R1);
	R1 = 0;
	scale = asi64(R1);
	asu64(R1) = b;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	reg = asi64(R1);
	asu64(R1) = b;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	regix = asi64(R1);
	asi64(R1) = reg;
	asi64(R2) = regix;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L3655;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3655;
	R1 = 0;
	mode = asi64(R1);
	R1 = 4;
	rm = asi64(R1);
	R1 = 1;
	scale = asi64(R1);
	R1 = 4;
	index = asi64(R1);
	R1 = 5;
	base = asi64(R1);
	R1 = 4;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3654;
L3655:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L3656;
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3656;
// mc_genss.genrm.simple:
L3657:
	R1 = (u64)&am;
	R2 = 4;
	R1 += (i64)R2;
	asu64(R2) = b;
	asi64(R1) = mc_genss_getdispsize(asu64(R2), asu64(R1));
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3659;
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3661;
	R1 = 1;
	goto L3660;
L3661:
	R1 = 2;
L3660:
	mode = asi64(R1);
L3659:
	R1 = 0;
	R2 = 1;
	asi64(R3) = reg;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	R2 = R1;
	base = asi64(R2);
	rm = asi64(R1);
	asi64(R1) = rm;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3663;
	asi64(R1) = rm;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3665;
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3665;
	R1 = 1;
	mode = asi64(R1);
	R1 = 1;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3665:
	R1 = 0;
	index = asi64(R1);
	goto L3662;
L3663:
	R1 = 4;
	index = asi64(R1);
	R1 = 1;
	scale = asi64(R1);
L3662:
	goto L3654;
L3656:
	asi64(R1) = regix;
	if (!asi64(R1)) goto L3666;
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3666;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L3668;
	R1 = (u64)&reg;
	R2 = (u64)&regix;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	goto L3657;
L3668:
	R1 = 4;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	mode = asi64(R1);
	R1 = 4;
	rm = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3670;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	goto L3669;
L3670:
	R1 = 1;
L3669:
	scale = asi64(R1);
	R1 = 5;
	base = asi64(R1);
	R1 = 0;
	R2 = 2;
	asi64(R3) = regix;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	index = asi64(R1);
	asi64(R1) = regix;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3672;
	R1 = tou64("Scaled rstack?");
	mc_libmcl_axerror(asu64(R1));
L3672:
	goto L3654;
L3666:
	R1 = (u64)&am;
	R2 = 4;
	R1 += (i64)R2;
	asu64(R2) = b;
	asi64(R1) = mc_genss_getdispsize(asu64(R2), asu64(R1));
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3674;
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3676;
	R1 = 1;
	goto L3675;
L3676:
	R1 = 2;
L3675:
	mode = asi64(R1);
L3674:
	R1 = 4;
	rm = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3678;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	goto L3677;
L3678:
	R1 = 1;
L3677:
	scale = asi64(R1);
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3680;
	R1 = 5;
	base = asi64(R1);
	goto L3679;
L3680:
	asi64(R1) = reg;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L3683;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3682;
L3683:
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3682;
	R1 = 1;
	mode = asi64(R1);
	R1 = 1;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3682:
	R1 = 0;
	R2 = 1;
	asi64(R3) = reg;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	base = asi64(R1);
L3679:
	asi64(R1) = regix;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3685;
	R1 = 4;
	index = asi64(R1);
	goto L3684;
L3685:
	R1 = 0;
	R2 = 2;
	asi64(R3) = regix;
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	index = asi64(R1);
	asi64(R1) = reg;
	if (asi64(R1)) goto L3687;
	R1 = 4;
	R2 = (u64)&am;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3687:
	asi64(R1) = regix;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L3689;
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3689;
	R1 = tou64("Can't scale rstack");
	mc_libmcl_axerror(asu64(R1));
L3689:
L3684:
L3654:
	asi64(R1) = scale;
	if (!asi64(R1)) goto L3691;
	R1 = (u64)&mc_genss_genrm_scaletable;
	asi64(R2) = scale;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 6;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = index;
	R3 = 3;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = base;
	asi64(R1) += asi64(R2);
	R2 = (u64)&am;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&am;
	R3 = 2;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
L3691:
	R1 = (u64)&am;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3693;
	asi64(R1) = ismem;
	if (!asi64(R1)) goto L3693;
	asi64(R1) = reg;
	if (asi64(R1)) goto L3696;
	asi64(R1) = regix;
	if (!asi64(R1)) goto L3695;
L3696:
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3698;
	asi64(R1) = ismem;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3698;
	msysc_m$print_startcon();
	R1 = tou64("Addr32 can't use RIP, line");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mc_decls_aaseqno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = mc_genss_currmcl;
	asu64(R1) = mc_writenasm_strmclstr(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3698:
	goto L3694;
L3695:
	asu8(R1) = pc_api_phighmem;
	if (!asu8(R1)) goto L3699;
	R1 = -1;
	R2 = (u64)&am;
	R3 = 2;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
	R1 = 0;
	mode = asi64(R1);
	R1 = 5;
	rm = asi64(R1);
L3699:
L3694:
L3693:
	asi64(R1) = mode;
	R2 = 6;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = opc;
	R3 = 3;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = rm;
	asi64(R1) += asi64(R2);
	R2 = (u64)&am;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = am;
	goto L3640;
L3640:
	return asu64(R1);
}

static void mc_genss_do_arith(u64 a, u64 b, i64 code) {
    u64 R1, R2, R3, R4; 
	u64 d;
	i64 opc;
	i64 dispsize;
	i64 x;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3702;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3703;
	goto L3704;
L3702:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3706;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3706;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3707;
	goto L3708;
L3706:
	asi64(R1) = code;
	R2 = 3;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	R3 = 1;
	if (asi64(R2) != asi64(R3)) goto L3710;
	R2 = 2;
	goto L3709;
L3710:
	R2 = 3;
L3709:
	asi64(R1) |= asi64(R2);
	opc = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opc;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3705;
L3707:
// mc_genss.do_arith.doregimm:
L3711:
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L3713;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L3715;
	R1 = tou64("add imm/size");
	mc_libmcl_axerror(asu64(R1));
L3715:
	asu64(R1) = a;
	asi64(R2) = code;
	R3 = 129;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	R1 = 4;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3700;
L3713:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	x = asi64(R1);
	R1 = 1;
	dispsize = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3717;
	R1 = 128;
	opc = asi64(R1);
	R1 = 1;
	asi64(R2) = x;
	mc_genss_checkimmrange(asi64(R2), asi64(R1));
	asi64(R1) = x;
	R2 = -128;
	if (asi64(R1) < asi64(R2)) goto L3720;
	R2 = 255;
	if (asi64(R1) <= asi64(R2)) goto L3719;
L3720:
	R1 = tou64("Exceeding i8/u8 range");
	mc_libmcl_axerror(asu64(R1));
L3719:
	goto L3716;
L3717:
	R1 = -128;
	asi64(R2) = x;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3721;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L3721;
	R1 = 131;
	opc = asi64(R1);
	goto L3716;
L3721:
	R1 = 4;
	asi64(R2) = x;
	mc_genss_checkimmrange(asi64(R2), asi64(R1));
	R1 = 129;
	opc = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3723;
	R1 = 2;
	goto L3722;
L3723:
	R1 = 4;
L3722:
	dispsize = asi64(R1);
L3716:
	asu64(R1) = a;
	asi64(R2) = code;
	asi64(R3) = opc;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = dispsize;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3725;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3726;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3727;
	goto L3728;
L3725:
	asi64(R1) = x;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3724;
L3726:
	asi64(R1) = x;
	mc_genss_genword(asi64(R1));
	goto L3724;
L3727:
	asi64(R1) = x;
	mc_genss_gendword(asi64(R1));
	goto L3724;
L3728:
L3724:
	asi64(R1) = dispsize;
	mc_genss_fixrip(asi64(R1));
	goto L3705;
L3708:
	R1 = tou64("ADD reg,???");
	mc_libmcl_axerror(asu64(R1));
L3705:
	goto L3701;
L3703:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3730;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3731;
	goto L3732;
L3730:
	asi64(R1) = code;
	R2 = 3;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	R3 = 1;
	if (asi64(R2) != asi64(R3)) goto L3734;
	R2 = 0;
	goto L3733;
L3734:
	R2 = 1;
L3733:
	asi64(R1) |= asi64(R2);
	opc = asi64(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	asi64(R3) = opc;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3729;
L3731:
	goto L3711;
	goto L3729;
L3732:
	R1 = tou64("ADD mem,???");
	mc_libmcl_axerror(asu64(R1));
L3729:
	goto L3701;
L3704:
	msysc_m$print_startcon();
	R1 = (u64)&mc_decls_opndnames_ma;
	asi64(R2) = code;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("CODE=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = code;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1:Can't add to this opnd");
	mc_libmcl_axerror(asu64(R1));
L3701:
L3700:
	return;
}

static void mc_genss_do_mov(u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 regcode;
	i64 opc;
	i64 dispsize;
	i64 value;
	u64 d;
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3737;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3738;
	goto L3739;
L3737:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3741;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3741;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3742;
	goto L3743;
L3741:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3745;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3745;
	R1 = tou64("2:Opnd size mismatch");
	mc_libmcl_axerror(asu64(R1));
L3745:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3747;
	R3 = 138;
	goto L3746;
L3747:
	R3 = 139;
L3746:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3740;
L3742:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	regcode = asi64(R1);
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	asu64(R1) = d;
	if (!asu64(R1)) goto L3749;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3749;
	R1 = tou64("mov imm?");
	mc_libmcl_axerror(asu64(R1));
L3749:
	asu64(R1) = a;
	mc_genss_checkhighreg(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3751;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3752;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3753;
	goto L3754;
L3751:
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3757;
	R2 = 255;
	if (asi64(R1) <= asi64(R2)) goto L3756;
L3757:
	R1 = tou64("exceeding byte value");
	mc_libmcl_axerror(asu64(R1));
L3756:
	mc_genss_genrex();
	R1 = 176;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3750;
L3752:
	R1 = -32768;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3760;
	R2 = 65535;
	if (asi64(R1) <= asi64(R2)) goto L3759;
L3760:
	R1 = tou64("exceeding u16 value");
	mc_libmcl_axerror(asu64(R1));
L3759:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L3750;
L3753:
	asu64(R1) = d;
	if (!asu64(R1)) goto L3762;
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 4;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3761;
L3762:
	R1 = -2147483648;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3765;
	R2 = 4294967295;
	asi64(R2) = toi64(tou32(R2));
	if (asi64(R1) <= asi64(R2)) goto L3764;
L3765:
	msysc_m$print_startcon();
	asi64(R1) = value;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = value;
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("1:exceeding u32 value");
	mc_libmcl_axerror(asu64(R1));
L3764:
// mc_genss.do_mov.doreg32:
L3766:
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
L3761:
	goto L3750;
L3754:
	asu64(R1) = d;
	if (!asu64(R1)) goto L3768;
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 8;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3767;
L3768:
	asi64(R1) = value;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L3770;
	asi64(R1) = value;
	R2 = 4294967295;
	if (asi64(R1) > asi64(R2)) goto L3770;
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L3766;
L3770:
	R1 = 8;
	R2 = (u64)&mc_genss_rex;
	*tou8p(R2) |= asu8(R1);
	mc_genss_genrex();
	R1 = 184;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_genqword(asi64(R1));
L3767:
L3750:
	goto L3740;
L3743:
	R1 = tou64("MOV REG/??");
	mc_libmcl_axerror(asu64(R1));
L3740:
	goto L3736;
L3738:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3772;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3773;
	goto L3774;
L3772:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3776;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3776:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3778;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L3778;
	R1 = tou64("3:Opnd size mismatch");
	mc_libmcl_axerror(asu64(R1));
L3778:
	asu64(R1) = a;
	asu64(R2) = b;
	asu64(R3) = b;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3780;
	R3 = 136;
	goto L3779;
L3780:
	R3 = 137;
L3779:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3771;
L3773:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3782;
	R1 = 1;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3782:
	asu64(R1) = d;
	if (!asu64(R1)) goto L3784;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L3784;
	R1 = tou64("mov imm?");
	mc_libmcl_axerror(asu64(R1));
L3784:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3786;
	R1 = 198;
	goto L3785;
L3786:
	R1 = 199;
L3785:
	opc = asi64(R1);
	asu64(R1) = d;
	if (asu64(R1)) goto L3788;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = value;
	mc_genss_checkimmrange(asi64(R2), asi64(R1));
L3788:
	asu64(R1) = a;
	R2 = 0;
	asi64(R3) = opc;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	dispsize = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3790;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3791;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3792;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L3792;
	goto L3793;
L3790:
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3789;
L3791:
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L3789;
L3792:
	R1 = 4;
	asu64(R2) = b;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	R1 = 4;
	dispsize = asi64(R1);
	goto L3789;
L3793:
L3789:
	asi64(R1) = dispsize;
	mc_genss_fixrip(asi64(R1));
	goto L3771;
L3774:
	R1 = tou64("MOV MEM/?");
	mc_libmcl_axerror(asu64(R1));
L3771:
	goto L3736;
L3739:
	R1 = tou64("MOV ?/..");
	mc_libmcl_axerror(asu64(R1));
L3736:
	return;
}

static void mc_genss_do_push(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 code;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3796;
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3796:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3798;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3799;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3800;
	goto L3801;
L3798:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3803;
	R1 = tou64("pushreg not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3803:
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	code = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_genss_rex;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	mc_genss_genrex();
	R1 = 80;
	asi64(R2) = code;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3797;
L3799:
	R1 = 0;
	asu64(R2) = a;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L3805;
	R1 = 104;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 4;
	asu64(R2) = a;
	mc_genss_genopnd(asu64(R2), asi64(R1));
	goto L3804;
L3805:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_genss_isbytesized(asi64(R1));
	if (!asi64(R1)) goto L3806;
	R1 = 106;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3804;
L3806:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = mc_genss_isdwordsized(asi64(R1));
	if (!asi64(R1)) goto L3807;
	R1 = 104;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_genss_gendword(asi64(R1));
	goto L3804;
L3807:
	R1 = tou64("push imm value too large");
	mc_libmcl_axerror(asu64(R1));
L3804:
	goto L3797;
L3800:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3809;
	R1 = tou64("push not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3809:
	asu64(R1) = a;
	R2 = 6;
	R3 = 255;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L3797;
L3801:
	R1 = tou64("push opnd?");
	mc_libmcl_axerror(asu64(R1));
L3797:
	return;
}

static void mc_genss_do_pop(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 code;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3812;
	R1 = 8;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3812:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3814;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3815;
	goto L3816;
L3814:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3818;
	R1 = tou64("popreg not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3818:
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	code = asi64(R1);
	mc_genss_genrex();
	R1 = 88;
	asi64(R2) = code;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3813;
L3815:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3820;
	R1 = tou64("pop not 64-bit");
	mc_libmcl_axerror(asu64(R1));
L3820:
	asu64(R1) = a;
	R2 = 0;
	R3 = 143;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L3813;
L3816:
	R1 = tou64("pop opnd?");
	mc_libmcl_axerror(asu64(R1));
L3813:
	return;
}

static void mc_genss_do_inc(u64 a, i64 code) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3823;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3823;
	goto L3824;
L3823:
	asu64(R1) = a;
	asi64(R2) = code;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3826;
	R3 = 254;
	goto L3825;
L3826:
	R3 = 255;
L3825:
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L3822;
L3824:
	R1 = tou64("inc/opnd?");
	mc_libmcl_axerror(asu64(R1));
L3822:
	return;
}

static void mc_genss_do_neg(u64 a, i64 code) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3829;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3829;
	goto L3830;
L3829:
	asu64(R1) = a;
	asi64(R2) = code;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3832;
	R3 = 246;
	goto L3831;
L3832:
	R3 = 247;
L3831:
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	goto L3828;
L3830:
	R1 = tou64("neg/div/etc opnd?");
	mc_libmcl_axerror(asu64(R1));
L3828:
	return;
}

static void mc_genss_do_lea(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 regcode;
	i64 am;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3836;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3835;
L3836:
	R1 = tou64("LEA not reg/mem");
	mc_libmcl_axerror(asu64(R1));
L3835:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L3838;
	msysc_m$print_startcon();
	R1 = tou64("A.SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("LEA size error");
	mc_libmcl_axerror(asu64(R1));
L3838:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 141;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_movsx(u64 a, u64 b, i64 opc) {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3841;
	R1 = tou64("movsx not reg");
	mc_libmcl_axerror(asu64(R1));
L3841:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3843;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3843;
	asi64(R1) = opc;
	R2 = 190;
	if (asi64(R1) != asi64(R2)) goto L3845;
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_movsxd(asu64(R2), asu64(R1));
	goto L3844;
L3845:
	R1 = (u64)&mc_decls_regtable;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R1 += (i64)R2*64-64;
	R2 = 4;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	a = asu64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	mc_genss_do_mov(asu64(R2), asu64(R1));
L3844:
	goto L3839;
L3843:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3848;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) > asu64(R2)) goto L3847;
L3848:
	R1 = tou64("movsx size error");
	mc_libmcl_axerror(asu64(R1));
L3847:
	asi64(R1) = opc;
	R2 = 182;
	if (asi64(R1) != asi64(R2)) goto L3850;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3850;
	R1 = tou64("movsx 4=>8 bytes?");
	mc_libmcl_axerror(asu64(R1));
L3850:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3852;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3853;
	goto L3854;
L3852:
	goto L3851;
L3853:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3856;
	R1 = tou64("movsx need size prefix");
	mc_libmcl_axerror(asu64(R1));
L3856:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3858;
	R1 = tou64("movsx size 8");
	mc_libmcl_axerror(asu64(R1));
L3858:
	goto L3851;
L3854:
	R1 = tou64("movsx not reg/mem");
	mc_libmcl_axerror(asu64(R1));
L3851:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asu64(R4) = b;
	R5 = 8;
	asu16(R4) = *tou16p(((i64)R4+(i64)R5));
	R4 = toi64(tou16(R4));
	R5 = 0;
	R6 = 4;
    asi64(R4) = Getdotslice((u64)R4, (i64)R5, (i64)R6);
	R5 = 1;
	if (asi64(R4) != asi64(R5)) goto L3860;
	asi64(R4) = opc;
	goto L3859;
L3860:
	asi64(R4) = opc;
	R5 = 1;
	asi64(R4) += asi64(R5);
L3859:
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L3839:
	return;
}

static void mc_genss_do_exch(u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 regcode;
	i64 am;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3863;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3863;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3864;
	asu64(R1) = b;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3863;
L3864:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3863;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3866;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L3866:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3868;
	R1 = tou64("exch size");
	mc_libmcl_axerror(asu64(R1));
L3868:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	regcode = asi64(R1);
	mc_genss_genrex();
	R1 = 144;
	asi64(R2) = regcode;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3861;
L3863:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3870;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L3870:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3873;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3872;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3872;
L3873:
	R1 = tou64("exch opnds");
	mc_libmcl_axerror(asu64(R1));
L3872:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3875;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3875;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3875:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3877;
	R1 = tou64("exch size");
	mc_libmcl_axerror(asu64(R1));
L3877:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3879;
	R3 = 134;
	goto L3878;
L3879:
	R3 = 135;
L3878:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L3861:
	return;
}

static void mc_genss_do_movsxd(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 regcode;
	i64 am;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3882;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3882;
	R1 = 4;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3882:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3885;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L3884;
L3885:
	R1 = tou64("movsxd size");
	mc_libmcl_axerror(asu64(R1));
L3884:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3888;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3887;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3887;
L3888:
	R1 = tou64("movsxd opnds");
	mc_libmcl_axerror(asu64(R1));
L3887:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 99;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_imul2(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	i64 regcode;
	i64 am;
	i64 opc;
	i64 dispsize;
	i64 value;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3891;
	R1 = tou64("imul2 opnds");
	mc_libmcl_axerror(asu64(R1));
L3891:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3893;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L3893:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3895;
	R1 = tou64("imul2 byte");
	mc_libmcl_axerror(asu64(R1));
L3895:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3897;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3897;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3898;
	goto L3899;
L3897:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) == asu64(R2)) goto L3901;
	R1 = tou64("imul2 size");
	mc_libmcl_axerror(asu64(R1));
L3901:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 4015;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3896;
L3898:
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L3903;
	R1 = tou64("mul/label");
	mc_libmcl_axerror(asu64(R1));
L3903:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3905;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L3905;
	R1 = 107;
	opc = asi64(R1);
	goto L3904;
L3905:
	R1 = 105;
	opc = asi64(R1);
L3904:
	asu64(R1) = a;
	asu64(R2) = a;
	asi64(R3) = opc;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	R1 = -128;
	asi64(R2) = value;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L3907;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L3907;
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	dispsize = asi64(R1);
	goto L3906;
L3907:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3908;
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	R1 = 2;
	dispsize = asi64(R1);
	goto L3906;
L3908:
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
	R1 = 4;
	dispsize = asi64(R1);
L3906:
	asi64(R1) = dispsize;
	mc_genss_fixrip(asi64(R1));
	goto L3896;
L3899:
	R1 = tou64("imul2 opnds");
	mc_libmcl_axerror(asu64(R1));
L3896:
	return;
}

static void mc_genss_do_shift(u64 a, u64 b, i64 code) {
    u64 R1, R2, R3; 
	i64 w;
	i64 opc;
	i64 needdisp;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3911;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3911;
	R1 = tou64("shift opnds1?");
	mc_libmcl_axerror(asu64(R1));
L3911:
	R1 = 0;
	asu64(R2) = b;
	asu64(R1) = mc_genss_getdef(asu64(R2), asi64(R1));
	if (!asu64(R1)) goto L3913;
	R1 = tou64("shift/label");
	mc_libmcl_axerror(asu64(R1));
L3913:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3915;
	R1 = 0;
	goto L3914;
L3915:
	R1 = 1;
L3914:
	w = asi64(R1);
	R1 = 0;
	needdisp = asi64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3917;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3918;
	goto L3919;
L3917:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3921;
	R1 = 208;
	asi64(R2) = w;
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	goto L3920;
L3921:
	R1 = 192;
	asi64(R2) = w;
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	R1 = 1;
	needdisp = asi64(R1);
L3920:
	goto L3916;
L3918:
	asu64(R1) = b;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3924;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3923;
L3924:
	R1 = tou64("cl or b10 needed");
	mc_libmcl_axerror(asu64(R1));
L3923:
	R1 = 210;
	asi64(R2) = w;
	asi64(R1) += asi64(R2);
	opc = asi64(R1);
	goto L3916;
L3919:
	R1 = tou64("shift opnds2?");
	mc_libmcl_axerror(asu64(R1));
L3916:
	asu64(R1) = a;
	asi64(R2) = code;
	asi64(R3) = opc;
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = needdisp;
	if (!asi64(R1)) goto L3926;
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	mc_genss_fixrip(asi64(R1));
L3926:
	return;
}

static void mc_genss_do_test(u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	i64 value;
	i64 opc;
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3929;
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3929;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3929;
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3931;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3932;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L3933;
	goto L3934;
L3931:
	R1 = 168;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3930;
L3932:
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 169;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L3930;
L3933:
	R1 = 169;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
	goto L3930;
L3934:
	R1 = 72;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 169;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
L3930:
	goto L3928;
L3929:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3936;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3935;
L3936:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3935;
	asu64(R1) = a;
	R2 = 0;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3938;
	R3 = 246;
	goto L3937;
L3938:
	R3 = 247;
L3937:
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3940;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L3941;
	goto L3942;
L3940:
	asi64(R1) = value;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3939;
L3941:
	asi64(R1) = value;
	mc_genss_genword(asi64(R1));
	goto L3939;
L3942:
	asi64(R1) = value;
	mc_genss_gendword(asi64(R1));
L3939:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	mc_genss_fixrip(asi64(R1));
	goto L3928;
L3935:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3944;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3943;
L3944:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3943;
// mc_genss.do_test.domemreg:
L3945:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = a;
	R4 = 8;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	R4 = 0;
	R5 = 4;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	R4 = 1;
	if (asi64(R3) != asi64(R4)) goto L3947;
	R3 = 132;
	goto L3946;
L3947:
	R3 = 133;
L3946:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3928;
L3943:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3948;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3948;
	R1 = (u64)&a;
	R2 = (u64)&b;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	goto L3945;
	goto L3928;
L3948:
	R1 = tou64("test opnds");
	mc_libmcl_axerror(asu64(R1));
L3928:
	return;
}

static void mc_genss_do_setcc(i64 cond, u64 b) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3953;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3952;
L3953:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L3951;
L3952:
	R1 = tou64("setcc opnd/size");
	mc_libmcl_axerror(asu64(R1));
L3951:
	asu64(R1) = b;
	R2 = 0;
	R3 = 3984;
	asi64(R4) = cond;
	asi64(R3) += asi64(R4);
	mc_genss_genxrm(asi64(R3), asi64(R2), asu64(R1));
	return;
}

static void mc_genss_checksize(u64 a, i64 size1, i64 size2) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3956;
	R1 = tou64("Need size");
	mc_libmcl_axerror(asu64(R1));
L3956:
	asi64(R1) = size1;
	if (!asi64(R1)) goto L3958;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size1;
	if (asi64(R1) == asi64(R2)) goto L3958;
	asi64(R2) = size2;
	if (asi64(R1) == asi64(R2)) goto L3958;
	msysc_m$print_startcon();
	R1 = tou64("A.SIZE=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Wrong size");
	mc_libmcl_axerror(asu64(R1));
L3958:
	return;
}

static void mc_genss_do_arithxmm(u64 a, u64 b, i64 prefix, i64 opc) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3962;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3961;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3961;
L3962:
	R1 = tou64("arithxmm opnds");
	mc_libmcl_axerror(asu64(R1));
L3961:
	asi64(R1) = prefix;
	if (!asi64(R1)) goto L3964;
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3964:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_logicxmm(u64 a, u64 b, i64 opc, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3968;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3967;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3967;
L3968:
	R1 = tou64("logicxmm opnds");
	mc_libmcl_axerror(asu64(R1));
L3967:
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3970;
	R1 = 102;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3970:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_convertfloat(u64 a, u64 b, i64 prefix) {
    u64 R1, R2, R3; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3974;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3973;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3973;
L3974:
	R1 = tou64("convertfloat opnds");
	mc_libmcl_axerror(asu64(R1));
L3973:
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	mc_genss_nowmask = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3930;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_fix(u64 a, u64 b, i64 prefix, i64 opc) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3978;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3977;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3977;
L3978:
	R1 = tou64("fix opnds");
	mc_libmcl_axerror(asu64(R1));
L3977:
	R1 = 8;
	R2 = 4;
	asu64(R3) = a;
	mc_genss_checksize(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = prefix;
	R2 = 243;
	if (asi64(R1) != asi64(R2)) goto L3980;
	R1 = 4;
	goto L3979;
L3980:
	R1 = 8;
L3979:
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_float(u64 a, u64 b, i64 prefix) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L3984;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3983;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3983;
L3984:
	R1 = tou64("float opnds");
	mc_libmcl_axerror(asu64(R1));
L3983:
	R1 = 8;
	R2 = 4;
	asu64(R3) = b;
	mc_genss_checksize(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = prefix;
	R2 = 243;
	if (asi64(R1) != asi64(R2)) goto L3986;
	R1 = 4;
	goto L3985;
L3986:
	R1 = 8;
L3985:
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asi64(R1) = prefix;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 1;
	mc_genss_usesizeb = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3882;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_genss_do_movxmm(u64 a, u64 b, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 am;
	i64 regcode;
	i64 regcode1;
	i64 regcode2;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3989;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3990;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L3991;
	goto L3992;
L3989:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L3994;
	goto L3995;
L3994:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L3997;
	R1 = tou64("1:movdq size");
	mc_libmcl_axerror(asu64(R1));
L3997:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	R3 = 3966;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3993;
L3995:
	R1 = tou64("movdq reg,?");
	mc_libmcl_axerror(asu64(R1));
L3993:
	goto L3988;
L3990:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L3999;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4000;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4001;
	goto L4002;
L3999:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4004;
	R1 = tou64("3:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4004:
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3950;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3998;
L4000:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 1;
	mc_genss_f3override = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3966;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L3998;
L4001:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4006;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4006:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4008;
	R1 = tou64("31:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4008:
	asi64(R1) = size;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4010;
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	R1 = 1;
	mc_genss_nowmask = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3950;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4009;
L4010:
	R1 = 1;
	mc_genss_f3override = asu8(R1);
	R1 = 1;
	mc_genss_nowmask = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 3966;
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L4009:
	goto L3998;
L4002:
	R1 = tou64("movdq xreg,?");
	mc_libmcl_axerror(asu64(R1));
L3998:
	goto L3988;
L3991:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4012;
	goto L4013;
L4012:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L4015;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asi64(R2) = size;
	if (asi64(R1) == asi64(R2)) goto L4015;
	R1 = tou64("5:movdq size");
	mc_libmcl_axerror(asu64(R1));
L4015:
	R1 = 1;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	asi64(R3) = size;
	R4 = 4;
	if (asi64(R3) != asi64(R4)) goto L4017;
	R3 = 3966;
	goto L4016;
L4017:
	R3 = 4054;
L4016:
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4011;
L4013:
	R1 = tou64("movdq mem,?");
	mc_libmcl_axerror(asu64(R1));
L4011:
	goto L3988;
L3992:
	R1 = tou64("movdq opnds");
	mc_libmcl_axerror(asu64(R1));
L3988:
	return;
}

static void mc_genss_fixrip(i64 dispsize) {
    u64 R1, R2, R3; 
	u64 codeaddr;
	u64 offsetptr;
	asu64(R1) = mc_genss_ripentry;
	if (asu64(R1)) goto L4020;
	goto L4018;
L4020:
	asi64(R1) = dispsize;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4022;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4023;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4023;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4023;
	goto L4024;
L4022:
	goto L4018;
	goto L4021;
L4023:
	goto L4021;
L4024:
	msysc_m$print_startcon();
	R1 = tou64("DISPSIZE=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = dispsize;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("fixrip disp?");
	mc_libmcl_axerror(asu64(R1));
L4021:
	asi64(R1) = dispsize;
	asu64(R2) = mc_genss_ripentry;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4018:
	return;
}

static void mc_genss_do_bswap(u64 a) {
    u64 R1, R2, R3, R4; 
	i64 code;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4028;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L4027;
L4028:
	R1 = tou64("bswap reg>");
	mc_libmcl_axerror(asu64(R1));
L4027:
	asu64(R1) = a;
	mc_genss_setopsize(asu64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	R4 = 10;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = mc_genss_getregcode(asi64(R3), asi64(R2), asi64(R1));
	code = asi64(R1);
	mc_genss_genrex();
	R1 = 15;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 200;
	asi64(R2) = code;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mc_genss_do_movdqx(u64 a, u64 b, i64 prefix) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = prefix;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	R2 = 3840;
	asi64(R1) += asi64(R2);
	prefix = asi64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4031;
	R1 = 16;
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4031:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4033;
	R1 = 16;
	asu64(R2) = b;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4033:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4035;
	asu64(R1) = a;
	asu64(R2) = b;
	asi64(R3) = prefix;
	R4 = 127;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	goto L4034;
L4035:
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = prefix;
	R4 = 111;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
L4034:
	return;
}

static void mc_genss_do_dshift(u64 a, u64 b, i64 c, i64 opc) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4038;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 8;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 4;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L4038:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) != asu64(R2)) goto L4041;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L4040;
L4041:
	R1 = tou64("dshift/size");
	mc_libmcl_axerror(asu64(R1));
L4040:
	R1 = 0;
	mc_genss_sizeoverride = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = b;
	R3 = 3840;
	asi64(R4) = opc;
	asi64(R3) += asi64(R4);
	mc_genss_genrrm(asi64(R3), asu64(R2), asu64(R1));
	asi64(R1) = c;
	asu64(R2) = mc_genss_currdata;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mc_decls_start() {
    u64 R1, R2, R3, R4; 
	i64 av_1;
	i64 i;
	R1 = 0;
	i = asi64(R1);
	R1 = 13;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4045;
L4043:
	R1 = 10;
	R2 = (u64)&mc_decls_ploadop;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L4043;
L4045:
	R1 = 19;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 5;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 4;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 18;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 9;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 8;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 16;
	R2 = (u64)&mc_decls_ploadop;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 17;
	R2 = (u64)&mc_decls_ploadop;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 10;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 mc_writenasm_getassemstr() {
    u64 R1, R2; 
	u64 d;
	u64 e;
	u64 m;
	struct $B18 str2;
	struct $B18 str3;
	i64 i;
	asu64(R1) = pc_decls_pdest;
	mlib_gs_init(asu64(R1));
	R1 = tou64(";NASM VERSION\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    default rel\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern fmod\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern sin\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern cos\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern tan\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern asin\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern acos\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern atan\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern log\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern log10\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern exp\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern floor\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern ceil\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern pow\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern exit\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    extern __getmainargs\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("    global main\n");
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("\n");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L4050;
L4047:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4052;
	R1 = tou64("    extern ");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("\n");
	mc_writenasm_asmstr(asu64(R1));
L4052:
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4054;
	R1 = tou64("    global ");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64("\n");
	mc_writenasm_asmstr(asu64(R1));
L4054:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4050:
	asu64(R1) = d;
	if (asu64(R1)) goto L4047;
	R1 = tou64("\n");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = mc_decls_mccode;
	m = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	goto L4056;
L4055:
	asu64(R1) = m;
	asi64(R2) = i;
	mc_writenasm_writemcl(asi64(R2), asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = m;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
L4056:
	asu64(R1) = m;
	if (asu64(R1)) goto L4055;
	asu64(R1) = pc_decls_pdest;
	goto L4046;
L4046:
	return asu64(R1);
}

static void mc_writenasm_writemcl(i64 index, u64 mcl) {
    u64 R1; 
	asu64(R1) = mcl;
	mc_writenasm_strmcl(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mc_writenasm_start() {
    u64 R1, R2, R3; 
	u8 flag;
	i64 av_1;
	i64 i;
	i64 r;
	i64 k;
	R1 = 1297301838;
	pc_decls_assemtype = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L4060:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4065;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4065;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4065;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4064;
L4065:
	R1 = 1;
	r = asi64(R1);
L4066:
	R1 = 0;
	flag = asu8(R1);
	R1 = 1;
	k = asi64(R1);
	R1 = 137;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4071;
L4069:
	asu8(R1) = flag;
	if (!asu8(R1)) goto L4073;
	R1 = (u64)&mc_decls_regsizes;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L4075;
	R1 = (u64)&mc_decls_regindices;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R2) = r;
	if (asi64(R1) != asi64(R2)) goto L4075;
	R1 = (u64)&mc_decls_dregnames;
	asi64(R2) = k;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mc_writenasm_nregnames;
	asi64(R3) = i;
	R2 += (i64)R3*128-128;
	asi64(R3) = r;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4075:
	goto L4072;
L4073:
	R1 = (u64)&mc_decls_regsizes;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4076;
	R1 = 1;
	flag = asu8(R1);
L4076:
L4072:
	k += 1; if (k <= av_1) goto L4069;
L4071:
	r += 1; if (r <= 16) goto L4066;
L4064:
	i += 1; if (i <= 8) goto L4060;
	return;
}

static void mc_writenasm_strmcl(u64 mcl) {
    u64 R1, R2, R3; 
	struct $B21 opcname;
	u64 a;
	u64 b;
	i64 opcode;
	i64 cond;
	i64 sizepref;
	u64 s;
	u64 comment;
	u64 d;
	asu64(R1) = mcl;
	R2 = 33;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opcode = asi64(R1);
	asu64(R1) = mcl;
	R2 = 34;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cond = asi64(R1);
	asu64(R1) = mcl;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = mcl;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = 0;
	comment = asu64(R1);
	asi64(R1) = opcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4079;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4080;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4081;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4082;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4083;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4084;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4085;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L4086;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L4087;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L4088;
	goto L4089;
L4079:
	R1 = tou64(";Proc ");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_decls_currasmproc = asu64(R1);
	goto L4077;
	goto L4078;
L4080:
	R1 = tou64(";End ");
	mc_writenasm_asmstr(asu64(R1));
	R1 = 0;
	mc_decls_currasmproc = asu64(R1);
	goto L4077;
	goto L4078;
L4081:
	R1 = 59;
	mc_writenasm_asmchar(asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writenasm_asmstr(asu64(R1));
	goto L4077;
	goto L4078;
L4082:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4091;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L4092;
	goto L4093;
L4091:
	asu64(R1) = d;
	asu64(R1) = mc_writenasm_getdispname(asu64(R1));
	mc_writenasm_asmstr(asu64(R1));
	goto L4090;
L4092:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writenasm_asmstr(asu64(R1));
	goto L4077;
	goto L4090;
L4093:
	R1 = tou64("");
	R2 = tou64("strmcl/lab");
	pc_api_merror(asu64(R2), asu64(R1));
L4090:
	R1 = tou64(":");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4095;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4097;
	goto L4096;
L4097:
	R1 = tou64("\n");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64(":");
	mc_writenasm_asmstr(asu64(R1));
L4096:
L4095:
	goto L4077;
	goto L4078;
L4083:
	R1 = (u64)&mc_writenasm_strmcl_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("L#:");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_writenasm_strmcl_str;
	mc_writenasm_asmstr(asu64(R1));
	goto L4077;
	goto L4078;
L4084:
	R1 = tou64("    %define ");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64(" ");
	mc_writenasm_asmstr(asu64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = b;
	mc_writenasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	goto L4077;
	goto L4078;
L4085:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = tou64("   %define ");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = d;
	asu64(R1) = mc_writenasm_getdispname(asu64(R1));
	mc_writenasm_asmstr(asu64(R1));
	R1 = tou64(" ");
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4099;
	goto L4100;
L4099:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writenasm_strreg(asi64(R2), asi64(R1));
	mc_writenasm_asmstr(asu64(R1));
	goto L4098;
L4100:
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = b;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writenasm_strxreg(asi64(R2), asi64(R1));
	mc_writenasm_asmstr(asu64(R1));
L4098:
	goto L4077;
	goto L4077;
	goto L4078;
L4086:
	R1 = tou64("    segment .text");
	mc_writenasm_asmstr(asu64(R1));
	R1 = 1;
	mc_writenasm_currseg = asu8(R1);
	goto L4077;
	goto L4078;
L4087:
	R1 = tou64("    segment .data");
	mc_writenasm_asmstr(asu64(R1));
	R1 = 2;
	mc_writenasm_currseg = asu8(R1);
	goto L4077;
	goto L4078;
L4088:
	R1 = tou64("    segment .bss");
	mc_writenasm_asmstr(asu64(R1));
	R1 = 3;
	mc_writenasm_currseg = asu8(R1);
	goto L4077;
	goto L4078;
L4089:
L4078:
	asi64(R1) = opcode;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L4102;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L4103;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4104;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L4105;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L4106;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L4107;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L4108;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L4109;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L4110;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L4111;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L4112;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L4113;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4114;
	goto L4115;
L4102:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("j");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L4101;
L4103:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("set");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L4101;
L4104:
	R1 = (u64)&opcname;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("cmov");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mc_decls_asmcondnames;
	asi64(R2) = cond;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L4101;
L4105:
	R1 = tou64("and");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4101;
L4106:
	R1 = tou64("or");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4101;
L4107:
	R1 = tou64("xor");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4101;
L4108:
	R1 = tou64("not");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4101;
L4109:
	R1 = tou64("imul");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4101;
L4110:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4117;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4117;
	R1 = 4;
	asu64(R2) = a;
	asu64(R1) = mc_libmcl_changeopndsize(asu64(R2), asi64(R1));
	R2 = R1;
	a = asu64(R2);
	asu64(R2) = mcl;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 11;
	opcode = asi64(R1);
L4117:
	goto L4115;
	goto L4115;
	goto L4101;
L4111:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4119;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4119;
	R1 = tou64("movsxd");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4118;
L4119:
	goto L4115;
	goto L4115;
L4118:
	goto L4101;
L4112:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4121;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4121;
	R1 = 17;
	opcode = asi64(R1);
L4121:
	goto L4115;
	goto L4115;
	goto L4101;
L4113:
	asu8(R1) = mc_writenasm_currseg;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4123;
	R1 = tou64("alignb");
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4122;
L4123:
	goto L4115;
	goto L4115;
L4122:
	goto L4101;
L4114:
	goto L4077;
	goto L4101;
L4115:
	asi64(R1) = opcode;
	R2 = 151;
	if (asi64(R1) <= asi64(R2)) goto L4125;
	R1 = 0;
	asi64(R2) = opcode;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4124;
L4125:
	R1 = (u64)&mc_decls_mclnames;
	asi64(R2) = opcode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 2;
	R1 += (i64)R2;
	R2 = (u64)&opcname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L4124:
L4101:
	R1 = tou64(" ");
	asi64(R2) = opcode;
	R3 = 119;
	if (asi64(R2) != asi64(R3)) goto L4127;
	R2 = 4;
	goto L4126;
L4127:
	R2 = 10;
L4126:
	R3 = (u64)&opcname;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("  ");
	R2 = (u64)&mc_writenasm_strmcl_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	R2 = 4;
	R3 = (u64)&mc_writenasm_strmcl_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&opcname;
	R2 = (u64)&mc_writenasm_strmcl_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mc_writenasm_strmcl_str;
	mc_writenasm_asmstr(asu64(R1));
	asu64(R1) = a;
	if (!asu64(R1)) goto L4129;
	asu64(R1) = b;
	if (!asu64(R1)) goto L4129;
	asu64(R1) = b;
	asu64(R2) = a;
	asi64(R3) = opcode;
	asi64(R1) = mc_writenasm_needsizeprefix(asi64(R3), asu64(R2), asu64(R1));
	sizepref = asi64(R1);
	R1 = 0;
	asi64(R2) = sizepref;
	asu64(R3) = a;
	mc_writenasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64(",\t");
	mc_writenasm_asmstr(asu64(R1));
	R1 = 0;
	asi64(R2) = sizepref;
	asu64(R3) = b;
	mc_writenasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = mcl;
	R2 = 32;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4131;
	R1 = tou64(",");
	mc_writenasm_asmstr(asu64(R1));
	R1 = 0;
	asu64(R2) = mcl;
	R3 = 32;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	mc_writenasm_asmstr(asu64(R1));
L4131:
	goto L4128;
L4129:
	asu64(R1) = a;
	if (!asu64(R1)) goto L4132;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	if (!asu64(R1)) goto L4132;
	asi64(R1) = opcode;
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L4134;
	asi64(R1) = opcode;
	R2 = 0;
	asu64(R3) = a;
	mc_writenasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
	goto L4133;
L4134:
	asi64(R1) = opcode;
	R2 = 1;
	asu64(R3) = a;
	mc_writenasm_asmopnd(asu64(R3), asi64(R2), asi64(R1));
L4133:
L4132:
L4128:
L4077:
	return;
}

static u64 mc_writenasm_strmclstr(u64 m) {
    u64 R1, R2; 
	asu64(R1) = pc_decls_pdest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = m;
	mc_writenasm_strmcl(asu64(R1));
	asu64(R1) = pc_decls_pdest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4135;
L4135:
	return asu64(R1);
}

static u64 mc_writenasm_mstropnd(u64 a, i64 sizeprefix, i64 opcode) {
    u64 R1, R2, R3, R4; 
	struct $B21 str2;
	u64 plus;
	u64 t;
	i64 offset;
	i64 tc;
	R1 = 0;
	R2 = (u64)&mc_writenasm_mstropnd_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4138;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4139;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4140;
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4141;
	goto L4142;
L4138:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writenasm_strreg(asi64(R2), asi64(R1));
	goto L4136;
	goto L4137;
L4139:
	asi64(R1) = opcode;
	R2 = 119;
	if (asi64(R1) != asi64(R2)) goto L4144;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4144;
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4146;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L4146;
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4145;
L4146:
	R1 = tou64("0x");
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("H");
	asu64(R2) = a;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strword(asu64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4145:
	goto L4143;
L4144:
	asu64(R1) = a;
	asu64(R1) = mc_writenasm_strvalue(asu64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L4143:
	goto L4137;
L4140:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4148;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4149;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4150;
	goto L4151;
L4148:
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4147;
L4149:
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strreal(asr64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4147;
L4150:
	R1 = (u64)&mc_writenasm_mstropnd_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("M#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L4147;
L4151:
L4147:
	asi64(R1) = sizeprefix;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	R4 = 4;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = mc_writenasm_getsizeprefix(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("[");
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("");
	plus = asu64(R1);
	asu64(R1) = a;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4153;
	R1 = 8;
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writenasm_strreg(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" + ");
	plus = asu64(R1);
L4153:
	asu64(R1) = a;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4155;
	asu64(R1) = plus;
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = a;
	R3 = 11;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writenasm_strreg(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(" + ");
	plus = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 5;
	R3 = 8;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L4157;
	R1 = tou64("*");
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 5;
	R4 = 8;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4157:
L4155:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4160;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4160;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4159;
L4160:
	asu64(R1) = plus;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L4162;
	asu64(R1) = plus;
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4162:
	asu64(R1) = a;
	asu64(R1) = mc_writenasm_strvalue(asu64(R1));
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4158;
L4159:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	offset = asi64(R2);
	if (!asi64(R1)) goto L4163;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(" + ");
	asi64(R2) = offset;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4163:
L4158:
	R1 = tou64("]");
	R2 = (u64)&mc_writenasm_mstropnd_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4137;
L4141:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	R3 = 4;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = a;
	R3 = 10;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = mc_writenasm_strxreg(asi64(R2), asi64(R1));
	goto L4136;
	goto L4137;
L4142:
	msysc_m$print_startcon();
	R1 = tou64("BAD OPND");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 9;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("<BAD OPND>");
	goto L4136;
L4137:
	R1 = (u64)&mc_writenasm_mstropnd_str;
	goto L4136;
L4136:
	return asu64(R1);
}

static u64 mc_writenasm_strvalue(u64 a) {
    u64 R1, R2, R3; 
	struct $B21 str2;
	u64 def;
	i64 value;
	i64 offset;
	i64 length;
	u64 ss;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	def = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = tou64("");
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 12;
	R3 = 15;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asu64(R1) == asu64(R2)) goto L4166;
	R2 = 1;
	if (asu64(R1) == asu64(R2)) goto L4167;
	R2 = 2;
	if (asu64(R1) == asu64(R2)) goto L4168;
	R2 = 3;
	if (asu64(R1) == asu64(R2)) goto L4169;
	R2 = 4;
	if (asu64(R1) == asu64(R2)) goto L4170;
	R2 = 7;
	if (asu64(R1) == asu64(R2)) goto L4171;
	R2 = 6;
	if (asu64(R1) == asu64(R2)) goto L4172;
	R2 = 8;
	if (asu64(R1) == asu64(R2)) goto L4173;
	goto L4174;
L4166:
	asu64(R1) = def;
	asu64(R1) = mc_writenasm_getdispname(asu64(R1));
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
// mc_writenasm.strvalue.addoffset:
L4175:
	asu64(R1) = a;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	offset = asi64(R2);
	if (!asi64(R1)) goto L4177;
	R1 = (u64)&str2;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = offset;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4179;
	R1 = tou64("+");
	goto L4178;
L4179:
	R1 = tou64("");
L4178:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = offset;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str2;
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L4177:
	goto L4165;
L4167:
	R1 = 0;
	asi64(R2) = value;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4165;
L4168:
	R1 = (u64)&mc_writenasm_strvalue_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("20.20");
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	goto L4165;
L4169:
	R1 = tou64("M");
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strreal(asr64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4165;
L4170:
	R1 = tou64("\"");
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4165;
L4171:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4165;
L4172:
	R1 = tou64("L");
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&mc_writenasm_strvalue_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L4175;
	goto L4165;
L4173:
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_decls_currasmproc;
	asu64(R1) = mc_writenasm_gettempname(asu64(R2), asi64(R1));
	goto L4164;
	goto L4165;
L4174:
	R1 = tou64("");
	R2 = tou64("Stropnd?");
	pc_api_merror(asu64(R2), asu64(R1));
L4165:
	R1 = (u64)&mc_writenasm_strvalue_str;
	goto L4164;
L4164:
	return asu64(R1);
}

static void mc_writenasm_asmopnd(u64 a, i64 sizeprefix, i64 opcode) {
    u64 R1, R2, R3; 
	asi64(R1) = opcode;
	asi64(R2) = sizeprefix;
	asu64(R3) = a;
	asu64(R1) = mc_writenasm_mstropnd(asu64(R3), asi64(R2), asi64(R1));
	mc_writenasm_asmstr(asu64(R1));
	return;
}

static u64 mc_writenasm_getxregname(i64 reg, i64 size) {
    u64 R1, R2; 
	asi64(R1) = reg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4183;
	R1 = tou64("-");
	goto L4181;
L4183:
	R1 = (u64)&mc_writenasm_getxregname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("XMM");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = reg;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_writenasm_getxregname_str;
	goto L4181;
L4181:
	return asu64(R1);
}

static void mc_writenasm_asmstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mc_writenasm_asmchar(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	asu64(R2) = pc_decls_pdest;
	mlib_gs_char(asu64(R2), asi64(R1));
	return;
}

static u64 mc_writenasm_getdispname(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 90;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4188;
	R1 = (u64)&mc_writenasm_getdispname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#.#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("R");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mc_writenasm_getdispname_str;
	goto L4186;
L4188:
	asu8(R1) = pc_api_fpshortnames;
	if (!asu8(R1)) goto L4190;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L4186;
L4190:
	R1 = 0;
	asu64(R2) = d;
	asu64(R1) = pc_api_getfullname(asu64(R2), asi64(R1));
	goto L4186;
L4186:
	return asu64(R1);
}

static u64 mc_writenasm_gettempname(u64 d, i64 n) {
    u64 R1; 
	asu8(R1) = pc_api_fpshortnames;
	if (!asu8(R1)) goto L4193;
	R1 = (u64)&mc_writenasm_gettempname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L4192;
L4193:
	R1 = (u64)&mc_writenasm_gettempname_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#.$T#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	asu64(R1) = mc_writenasm_getdispname(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L4192:
	R1 = (u64)&mc_writenasm_gettempname_str;
	goto L4191;
L4191:
	return asu64(R1);
}

static u64 mc_writenasm_strreg(i64 reg, i64 size) {
    u64 R1, R2; 
	u64 d;
	R1 = (u64)&mc_writenasm_nregnames;
	asi64(R2) = size;
	R1 += (i64)R2*128-128;
	asi64(R2) = reg;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L4194;
L4194:
	return asu64(R1);
}

static u64 mc_writenasm_strxreg(i64 reg, i64 size) {
    u64 R1, R2; 
	u64 d;
	R1 = 1;
	asi64(R2) = reg;
	asu64(R1) = mc_writenasm_checkregvar(asi64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4197;
	asu64(R1) = d;
	if (!asu64(R1)) goto L4197;
	asu64(R1) = d;
	asu64(R1) = mc_writenasm_getdispname(asu64(R1));
	goto L4196;
L4197:
	asi64(R1) = size;
	asi64(R2) = reg;
	asu64(R1) = mc_writenasm_getxregname(asi64(R2), asi64(R1));
L4196:
	goto L4195;
L4195:
	return asu64(R1);
}

static i64 mc_writenasm_needsizeprefix(i64 opcode, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asi64(R1) = opcode;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L4200;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L4200;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L4200;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L4200;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L4201;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L4201;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L4201;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L4201;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L4202;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L4202;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4202;
	goto L4203;
L4200:
	R1 = 1;
	goto L4198;
	goto L4199;
L4201:
	R1 = 1;
	goto L4198;
	goto L4199;
L4202:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4205;
	R1 = 1;
	goto L4198;
L4205:
	R1 = 0;
	goto L4198;
	goto L4199;
L4203:
L4199:
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4208;
	asu64(R1) = a;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4208;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4208;
	asu64(R1) = b;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 9;
	R3 = 11;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4207;
L4208:
	R1 = 0;
	goto L4198;
L4207:
	R1 = 1;
	goto L4198;
L4198:
	return asi64(R1);
}

static u64 mc_writenasm_getsizeprefix(i64 size, i64 enable) {
    u64 R1, R2; 
	asi64(R1) = enable;
	if (asi64(R1)) goto L4211;
	R1 = tou64("");
	goto L4209;
L4211:
	asi64(R1) = size;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4213;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4214;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4215;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4216;
	goto L4217;
L4213:
	R1 = tou64("byte ");
	goto L4209;
	goto L4212;
L4214:
	R1 = tou64("word ");
	goto L4209;
	goto L4212;
L4215:
	R1 = tou64("dword ");
	goto L4209;
	goto L4212;
L4216:
	R1 = tou64("qword ");
	goto L4209;
	goto L4212;
L4217:
L4212:
	R1 = tou64("");
	goto L4209;
L4209:
	return asu64(R1);
}

static u64 mc_writenasm_checkregvar(i64 reg, i64 ispfloat) {
    u64 R1; 
	u64 d;
	R1 = 0;
	goto L4218;
L4218:
	return asu64(R1);
}

static void mc_writeexe_writeexe(u64 outfile, i64 dodll, u64 entrypoint) {
    u64 R1, R2, R3; 
	asu8(R1) = pc_decls_exedone;
	if (!asu8(R1)) goto L4221;
	goto L4219;
L4221:
	asi64(R1) = dodll;
	asu64(R2) = outfile;
	asu64(R3) = entrypoint;
	mc_writeexe_genexe1(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = dodll;
	asu64(R2) = outfile;
	mc_writeexe_genexe2(asu64(R2), asi64(R1));
	R1 = 1;
	pc_decls_exedone = asu8(R1);
L4219:
	return;
}

static void mc_writeexe_genexe1(u64 entrypoint, u64 outfile, i64 dodll) {
    u64 R1, R2, R3, R4; 
	i64 offset;
	u64 codeaddr;
	u64 offsetptr;
	u64 pr;
	mc_writeexe_initsectiontable();
	asu64(R1) = outfile;
	asu64(R1) = mlib_extractfile(asu64(R1));
	mc_writeexe_dllfilename = asu64(R1);
	asi64(R1) = dodll;
	mc_writeexe_isdll = asi64(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4224;
	R1 = 268435456;
	goto L4223;
L4224:
	R1 = 4194304;
L4223:
	mc_writeexe_imagebase = asi64(R1);
	asu64(R1) = entrypoint;
	mc_writeexe_userentrypoint = asu64(R1);
	mc_writeexe_loadlibs();
	mc_writeexe_scanst();
	mc_writeexe_getoffsets();
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 0;
	R1 += (i64)R2;
	mc_writeexe_relocdata(asu64(R1));
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 72;
	R1 += (i64)R2;
	mc_writeexe_relocdata(asu64(R1));
	R1 = 0;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	codeaddr = asu64(R1);
	asu8(R1) = pc_api_phighmem;
	if (!asu8(R1)) goto L4226;
	asu64(R1) = mc_decls_riplist;
	pr = asu64(R1);
	goto L4230;
L4227:
	asu64(R1) = codeaddr;
	asu64(R2) = pr;
	R3 = 8;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	offsetptr = asu64(R1);
	asu64(R1) = pr;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = offsetptr;
	asu32(R2) = *tou32p(R2);
	R2 = toi64(tou32(R2));
	asi64(R3) = mc_writeexe_imagebase;
	asi64(R2) -= asi64(R3);
	asu64(R3) = pr;
	R4 = 8;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asi64(R1) = mc_writeexe_getripoffset(asi64(R3), asi64(R2), asi64(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	asu64(R2) = offsetptr;
	*tou32p(R2) = asu32(R1);
	asu64(R1) = pr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pr = asu64(R1);
L4230:
	asu64(R1) = pr;
	if (asu64(R1)) goto L4227;
L4226:
	return;
}

static void mc_writeexe_genexe2(u64 outfile, i64 dodll) {
    u64 R1, R2, R3; 
	struct $B17 header;
	struct $B86 optheader;
	i64 offset;
	i64 i;
	i64 aa;
	asu64(R1) = outfile;
	asu64(R1) = mlib_extractfile(asu64(R1));
	mc_writeexe_dllfilename = asu64(R1);
	asi64(R1) = dodll;
	mc_writeexe_isdll = asi64(R1);
	asi64(R1) = mc_writeexe_filesize;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	R2 = R1;
	mc_writeexe_dataptr = asu64(R2);
	mc_writeexe_datastart = asu64(R1);
	mc_writeexe_writedosstub();
	mc_writeexe_writepesig();
	mc_writeexe_writefileheader();
	mc_writeexe_writeoptheader();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4234;
L4232:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	mc_writeexe_writesectionheader(asu64(R1));
	i += 1; if (i <= mc_writeexe_nsections) goto L4232;
L4234:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mc_writeexe_writepadding(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4237;
L4235:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	mc_writeexe_writesectiondata(asu64(R1));
	i += 1; if (i <= mc_writeexe_nsections) goto L4235;
L4237:
	asu8(R1) = pc_decls_pverbose;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4239;
	msysc_m$print_startcon();
	R1 = tou64("EXE size:  ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_writeexe_dataptr;
	asu64(R3) = mc_writeexe_datastart;
	asi64(R2) -= asi64(R3);
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
L4239:
	asu64(R1) = mc_writeexe_dataptr;
	asu64(R2) = mc_writeexe_datastart;
	asi64(R1) -= asi64(R2);
	asu64(R2) = mc_writeexe_datastart;
	asu64(R3) = outfile;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4241;
	msysc_m$print_startcon();
	R1 = tou64("Error writing exe file (possibly still running)");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L4241:
	return;
}

static void mc_writeexe_loadlibs() {
    u64 R1, R2, R3; 
	i64 i;
	i64 hinst;
	u64 file;
	struct $B15 filename;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4245;
L4243:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4247;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&filename;
	asi64(R1) = mwindows_os_getdllinst(asu64(R1));
	hinst = asi64(R1);
	asi64(R1) = hinst;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4249;
	msysc_m$print_startcon();
	R1 = tou64("File:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't load search lib");
	mc_libmcl_axerror(asu64(R1));
L4249:
	asi64(R1) = hinst;
	R2 = (u64)&mc_writeexe_libinsttable;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&filename;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeexe_libinstnames;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4247:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4243;
L4245:
	return;
}

static void mc_writeexe_initsectiontable() {
    u64 R1, R2, R3; 
	R1 = tou64(".text");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_code;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L4252;
	msysc_m$print_startcon();
	R1 = tou64("Code size: ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_decls_ss_code;
	asi64(R2) = mc_genss_bufferlength(asu64(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("bytes");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu8(R1) = pc_decls_pverbose;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4254;
	msysc_m$print_startcon();
	R1 = tou64("Idata size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_decls_ss_idata;
	asi64(R2) = mc_genss_bufferlength(asu64(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Code+Idata:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asu64(R2) = mc_decls_ss_code;
	asi64(R2) = mc_genss_bufferlength(asu64(R2));
	asu64(R3) = mc_decls_ss_idata;
	asi64(R3) = mc_genss_bufferlength(asu64(R3));
	asi64(R2) += asi64(R3);
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Zdata size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("10s,jr");
	asi64(R2) = mc_decls_ss_zdatalen;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4254:
L4252:
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4256;
	R1 = 0;
	asu64(R2) = mc_decls_ss_idata;
	mc_genss_addqword(asu64(R2), asi64(R1));
L4256:
	R1 = tou64(".data");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_idata;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_idatarelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 2;
	R2 += (i64)R3*72-72;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4258;
	R1 = 16;
	mc_decls_ss_zdatalen = asi64(R1);
L4258:
	R1 = tou64(".bss");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 3;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mc_decls_ss_ncoderelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_coderelocs;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = tou64(".idata");
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 5;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 4;
	mc_writeexe_nsections = asi64(R1);
	return;
}

static u64 mc_writeexe_extractlibname(u64 name, u64 libno, i64 moduleno) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 name2;
	struct $B16 str;
	struct $B16 str2;
	i64 i;
	i64 n;
	R1 = 0;
	name2 = asu64(R1);
// mc_writeexe.extractlibname.reenter:
	asu64(R1) = name;
	s = asu64(R1);
	R1 = 0;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	goto L4262;
L4261:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L4265;
	asu64(R1) = s;
	asu64(R2) = name;
	asu64(R1) -= asu64(R2);
	asu64(R2) = name;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R3) = s;
	asu64(R4) = name;
	asi64(R3) -= asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = tou64(".dll");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4268;
L4266:
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4270;
	asi64(R1) = i;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asu64(R2) = libno;
	asi64(R2) = *toi64p(R2);
	R1 += (i64)R2*48-40;
	(*toi64p(R1)) += 1;
	asu64(R1) = name2;
	if (!asu64(R1)) goto L4272;
	asu64(R1) = name2;
	goto L4271;
L4272:
	asu64(R1) = s;
	R2 = 1;
	R1 += (i64)R2;
L4271:
	goto L4259;
L4270:
	i += 1; if (i <= mc_writeexe_ndlls) goto L4266;
L4268:
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L4274;
	R1 = tou64("Too many libs");
	mc_libmcl_axerror(asu64(R1));
L4274:
	R1 = (u64)&mc_writeexe_ndlls;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = name2;
	if (!asu64(R1)) goto L4276;
	asu64(R1) = name2;
	goto L4275;
L4276:
	asu64(R1) = s;
	R2 = 1;
	R1 += (i64)R2;
L4275:
	goto L4259;
L4265:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L4262:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L4261;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4280;
L4277:
	R1 = (u64)&mc_writeexe_libinsttable;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (!asi64(R1)) goto L4282;
	asu64(R1) = name;
	R2 = (u64)&mc_writeexe_libinsttable;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mwindows_os_getdllprocaddr(asi64(R2), asu64(R1));
	if (!asu64(R1)) goto L4284;
	asi64(R1) = i;
	n = asi64(R1);
	goto L4279;
L4284:
L4282:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4277;
L4280:
	msysc_m$print_startcon();
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find external function");
	mc_libmcl_axerror(asu64(R1));
L4279:
	R1 = (u64)&mc_writeexe_libnotable;
	asi64(R2) = n;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = R1;
	asu64(R3) = libno;
	*toi64p(R3) = asi64(R2);
	if (!asi64(R1)) goto L4286;
	R1 = (u64)&mc_writeexe_dlltable;
	asu64(R2) = libno;
	asi64(R2) = *toi64p(R2);
	R1 += (i64)R2*48-40;
	(*toi64p(R1)) += 1;
	asu64(R1) = name;
	goto L4259;
L4286:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(".dll");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L4288;
	R1 = tou64("2:Too many libs");
	mc_libmcl_axerror(asu64(R1));
L4288:
	R1 = (u64)&mc_writeexe_ndlls;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = libno;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mc_writeexe_dlltable;
	asu64(R3) = libno;
	asi64(R3) = *toi64p(R3);
	R2 += (i64)R3*48-48;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = libno;
	asi64(R1) = *toi64p(R1);
	R2 = (u64)&mc_writeexe_libnotable;
	asi64(R3) = n;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = name;
	goto L4259;
L4259:
	return asu64(R1);
}

static void mc_writeexe_scanst() {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 libno;
	u64 d;
	u64 name;
	u64 libname;
	u64 basename;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4292;
L4290:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4294;
	asi64(R1) = mc_writeexe_nimports;
	R2 = 3000;
	if (asi64(R1) < asi64(R2)) goto L4296;
	R1 = tou64("genexe: Too many imports");
	mc_libmcl_axerror(asu64(R1));
L4296:
	R1 = (u64)&mc_writeexe_nimports;
	(*toi64p(R1)) += 1;
	R1 = 1;
	R2 = (u64)&libno;
	asu64(R3) = d;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R1) = mc_writeexe_extractlibname(asu64(R3), asu64(R2), asi64(R1));
	name = asu64(R1);
	asi64(R1) = libno;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = mc_writeexe_nimports;
	R2 += (i64)R3*48;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = name;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = mc_writeexe_nimports;
	R2 += (i64)R3*48;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = mc_writeexe_nimports;
	R2 += (i64)R3*48;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mc_writeexe_nimports;
	asu64(R2) = d;
	R3 = 98;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L4293;
L4294:
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4297;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	basename = asu64(R1);
	asu64(R1) = mc_writeexe_userentrypoint;
	if (!asu64(R1)) goto L4299;
	asu64(R1) = mc_writeexe_userentrypoint;
	asu64(R2) = basename;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4301;
	asu64(R1) = d;
	mc_writeexe_stentrypoint = asu64(R1);
L4301:
	goto L4298;
L4299:
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4303;
	asi64(R1) = mc_writeexe_isdll;
	if (asi64(R1)) goto L4303;
	asu64(R1) = d;
	mc_writeexe_stentrypoint = asu64(R1);
L4303:
L4298:
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L4305;
	R1 = tou64("gendll: Too many exports");
	mc_libmcl_axerror(asu64(R1));
L4305:
	R1 = (u64)&mc_writeexe_nexports;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = (u64)&mc_writeexe_exporttable;
	asi64(R3) = mc_writeexe_nexports;
	R2 += (i64)R3*16-16;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	R2 = (u64)&mc_writeexe_exporttable;
	asi64(R3) = mc_writeexe_nexports;
	R2 += (i64)R3*16-16;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4297:
L4293:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4290;
L4292:
	return;
}

static void mc_writeexe_relocdata(u64 s) {
    u64 R1, R2, R3, R4; 
	u64 u;
	u64 r;
	u64 p;
	u64 p32;
	u64 p64;
	u64 d;
	i64 offset;
	i64 index;
	i64 thunkoffset;
	i64 iatoffset;
	R1 = 0;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = s;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	goto L4308;
L4307:
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = r;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 98;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = index;
	R1 += (i64)R2*48;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	thunkoffset = asi64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4311;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4312;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4312;
	goto L4313;
L4311:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4315;
	R1 = tou64("rel32/not imported");
	mc_libmcl_axerror(asu64(R1));
L4315:
	asi64(R1) = thunkoffset;
	asu64(R2) = r;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 4;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	asu64(R3) = r;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4310;
L4312:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4317;
	asi64(R1) = mc_writeexe_imagebase;
	asi64(R2) = thunkoffset;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	asu64(R3) = r;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4316;
L4317:
	R1 = 0;
	u = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4319;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4320;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4321;
	goto L4322;
L4319:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 144;
	R1 += (i64)R2;
	u = asu64(R1);
	goto L4318;
L4320:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 72;
	R1 += (i64)R2;
	u = asu64(R1);
	goto L4318;
L4321:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 0;
	R1 += (i64)R2;
	u = asu64(R1);
	goto L4318;
L4322:
	msysc_m$print_startcon();
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("RELOCDATA/SEG?");
	mc_libmcl_axerror(asu64(R1));
L4318:
	asu64(R1) = p;
	asu64(R2) = r;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	p32 = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4324;
	asu64(R1) = p32;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	asu64(R2) = u;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_writeexe_imagebase;
	asi64(R1) += asi64(R2);
	asu64(R2) = p32;
	*tou32p(R2) = asu32(R1);
	goto L4323;
L4324:
	asu64(R1) = p32;
	p64 = asu64(R1);
	asu64(R1) = p64;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = u;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asi64(R2) = mc_writeexe_imagebase;
	asu64(R1) += asu64(R2);
	asu64(R2) = p64;
	*tou64p(R2) = asu64(R1);
L4323:
L4316:
	goto L4310;
L4313:
	msysc_m$print_startcon();
	R1 = (u64)&mc_objdecls_relocnames;
	asu64(R2) = r;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't do this rel type");
	mc_libmcl_axerror(asu64(R1));
L4310:
	asu64(R1) = r;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4308:
	asu64(R1) = r;
	if (asu64(R1)) goto L4307;
	return;
}

static void mc_writeexe_getbaserelocs(u64 s) {
    u64 R1, R2, R3, R4; 
	u64 r;
	u64 p;
	u64 d;
	i64 index;
	R1 = 0;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = s;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	goto L4327;
L4326:
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = r;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4330;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4330;
	goto L4331;
L4330:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4333;
	goto L4332;
L4333:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4335;
	goto L4334;
L4335:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R3) = r;
	R4 = 16;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R2) += asi64(R3);
	mc_writeexe_newbasereloc(asi64(R2), asi64(R1));
L4334:
L4332:
	goto L4329;
L4331:
L4329:
	asu64(R1) = r;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4327:
	asu64(R1) = r;
	if (asu64(R1)) goto L4326;
	return;
}

static void mc_writeexe_writerecordx(u64 r, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = r;
	asu64(R3) = mc_writeexe_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&mc_writeexe_dataptr;
	*tou64p(R2) += asu64(R1);
	return;
}

static void mc_writeexe_writedosstub() {
    u64 R1, R2; 
// PROC LOCAL STATICS GO HERE
	static struct $B21 mc_writeexe_writedosstub_stubdata = {{
12894362189,
	281470681743364,
	184,
	64,
	0,
	0,
	0,
	549755813888,
	-3672206108803850482,
	7517670843615393825,
	8243680180223112041,
	8029476550202125665,
	7959393399912669300,
	2329292586301155616,
	724249607997255533,
	36    }};
	R1 = 128;
	R2 = (u64)&mc_writeexe_writedosstub_stubdata;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writepesig() {
    u64 R1, R2, R3; 
	R1 = 80;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 69;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_dataptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mc_writeexe_writepadding(i64 offset) {
    u64 R1, R2; 
	asu64(R1) = mc_writeexe_datastart;
	asi64(R2) = offset;
	R1 += (i64)R2;
	mc_writeexe_dataptr = asu64(R1);
	return;
}

static void mc_writeexe_writefileheader() {
    u64 R1, R2, R3; 
	struct $B17 header;
	R1 = (u64)&header;
	memset(R1, 0, 20);
	R1 = 34404;
	R2 = (u64)&header;
	R3 = 0;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = (u64)&header;
	R3 = 2;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 240;
	R2 = (u64)&header;
	R3 = 16;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 559;
	R2 = (u64)&header;
	R3 = 18;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4342;
	R1 = 8750;
	R2 = (u64)&header;
	R3 = 18;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L4342:
	R1 = 20;
	R2 = (u64)&header;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writeoptheader() {
    u64 R1, R2, R3; 
	struct $B86 header;
	R1 = (u64)&header;
	memset(R1, 0, 240);
	R1 = 523;
	R2 = (u64)&header;
	R3 = 0;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&header;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&header;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&header;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 2;
	R1 += (i64)R2*72-72;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 4;
	R2 += (i64)R3*72-72;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	R2 = (u64)&header;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 512;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 3;
	R2 += (i64)R3*72-72;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&header;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = mc_writeexe_stentrypoint;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4345;
	asu64(R1) = mc_writeexe_stentrypoint2;
	mc_writeexe_stentrypoint = asu64(R1);
L4345:
	asu64(R1) = mc_writeexe_stentrypoint;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4347;
	asu64(R1) = mc_writeexe_userentrypoint;
	if (!asu64(R1)) goto L4349;
	msysc_m$print_startcon();
	asu64(R1) = mc_writeexe_userentrypoint;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("User entry point not found");
	mc_libmcl_axerror(asu64(R1));
	goto L4348;
L4349:
	asi64(R1) = mc_writeexe_isdll;
	if (asi64(R1)) goto L4351;
	R1 = tou64("Entry point not found: main");
	mc_libmcl_axerror(asu64(R1));
L4351:
L4348:
	goto L4346;
L4347:
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mc_writeexe_stentrypoint;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = (u64)&header;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L4346:
	R1 = 4096;
	R2 = (u64)&header;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_imagebase;
	R2 = (u64)&header;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4096;
	R2 = (u64)&header;
	R3 = 32;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 512;
	R2 = (u64)&header;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 4;
	R2 = (u64)&header;
	R3 = 40;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 0;
	R2 = (u64)&header;
	R3 = 42;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 5;
	R2 = (u64)&header;
	R3 = 48;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 2;
	R2 = (u64)&header;
	R3 = 50;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_imagesize;
	R2 = (u64)&header;
	R3 = 56;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&header;
	R3 = 60;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 3;
	R2 = (u64)&header;
	R3 = 68;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 4194304;
	R2 = (u64)&header;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2097152;
	R2 = (u64)&header;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1048576;
	R2 = (u64)&header;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4096;
	R2 = (u64)&header;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 16;
	R2 = (u64)&header;
	R3 = 108;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 4;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&header;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 4;
	R1 += (i64)R2*72-72;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeexe_exportdirvirtsize;
	asi64(R1) -= asi64(R2);
	asi64(R2) = mc_writeexe_blockdirvirtsize;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&header;
	R3 = 124;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4353;
	R1 = 64;
	R2 = (u64)&header;
	R3 = 70;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = mc_writeexe_exportdirvirtaddr;
	R2 = (u64)&header;
	R3 = 112;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_exportdirvirtsize;
	R2 = (u64)&header;
	R3 = 116;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_blockdirvirtaddr;
	R2 = (u64)&header;
	R3 = 152;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_blockdirvirtsize;
	R2 = (u64)&header;
	R3 = 156;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L4353:
	asi64(R1) = mc_writeexe_fileiatoffset;
	R2 = (u64)&header;
	R3 = 208;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_fileiatsize;
	R2 = (u64)&header;
	R3 = 212;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 240;
	R2 = (u64)&header;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writesectionheader(u64 s) {
    u64 R1, R2, R3; 
	struct $B69 sheader;
	i64 aa;
	R1 = (u64)&sheader;
	memset(R1, 0, 40);
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&sheader;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4356;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4357;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4358;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4359;
	goto L4360;
L4356:
	R1 = 3226468480;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4355;
L4357:
	R1 = 3226468416;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4355;
L4358:
	R1 = 1615855648;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4355;
L4359:
	R1 = 3224371264;
	aa = asi64(R1);
	asi64(R1) = aa;
	R2 = (u64)&sheader;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4355;
L4360:
L4355:
	R1 = 40;
	R2 = (u64)&sheader;
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	return;
}

static void mc_writeexe_writesectiondata(u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = s;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4363;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4364;
	goto L4365;
L4363:
	asu64(R1) = s;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L4367;
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mc_writeexe_dataptr;
	*tou64p(R2) += asu64(R1);
L4367:
	goto L4362;
L4364:
	goto L4362;
L4365:
	asu64(R1) = s;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R3) = s;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	mc_writeexe_writerecordx(asu64(R2), asi64(R1));
L4362:
	return;
}

static void mc_writeexe_writeexporttable(u64 pstart) {
    u64 R1, R2, R3; 
	struct $B50 sortindex;
	u64 phdr;
	u64 paddrtable;
	u64 pnametable;
	u64 pordtable;
	u64 pdllname;
	u64 pnames;
	i64 addrtableoffset;
	i64 nametableoffset;
	i64 ordtableoffset;
	i64 dllnameoffset;
	i64 namesoffset;
	i64 virtoffset;
	i64 sectionno;
	u64 d;
	u64 basename;
	i64 i;
	asu64(R1) = pstart;
	phdr = asu64(R1);
	R1 = 1602876664;
	asu64(R2) = phdr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = phdr;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_nexports;
	asu64(R2) = phdr;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeexe_nexports;
	asu64(R2) = phdr;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 40;
	addrtableoffset = asi64(R1);
	asi64(R1) = addrtableoffset;
	asi64(R2) = mc_writeexe_nexports;
	R3 = 4;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	nametableoffset = asi64(R1);
	asi64(R1) = nametableoffset;
	asi64(R2) = mc_writeexe_nexports;
	R3 = 4;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	ordtableoffset = asi64(R1);
	asi64(R1) = ordtableoffset;
	asi64(R2) = mc_writeexe_nexports;
	R3 = 2;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	dllnameoffset = asi64(R1);
	asi64(R1) = dllnameoffset;
	asu64(R2) = mc_writeexe_dllfilename;
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	namesoffset = asi64(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 4;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeexe_exportdiroffset;
	asi64(R1) += asi64(R2);
	virtoffset = asi64(R1);
	asu64(R1) = pstart;
	asi64(R2) = addrtableoffset;
	R1 += (i64)R2;
	paddrtable = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = nametableoffset;
	R1 += (i64)R2;
	pnametable = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = ordtableoffset;
	R1 += (i64)R2;
	pordtable = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = dllnameoffset;
	R1 += (i64)R2;
	pdllname = asu64(R1);
	asu64(R1) = pstart;
	asi64(R2) = namesoffset;
	R1 += (i64)R2;
	pnames = asu64(R1);
	asi64(R1) = dllnameoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = addrtableoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 28;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = nametableoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 32;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = ordtableoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = phdr;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = mc_writeexe_dllfilename;
	asu64(R2) = pdllname;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mc_writeexe_nexports;
	R2 = 2000;
	if (asi64(R1) <= asi64(R2)) goto L4370;
	R1 = tou64("Too many exports - can't sort");
	mc_libmcl_axerror(asu64(R1));
L4370:
	R1 = (u64)&sortindex;
	mc_writeexe_sortexports(asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4373;
L4371:
	R1 = (u64)&mc_writeexe_exporttable;
	R2 = (u64)&sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = (u64)&mc_writeexe_exporttable;
	R2 = (u64)&sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2*16-16;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	basename = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R1) = mc_writeexe_getsectionno(asi64(R1));
	sectionno = asi64(R1);
	asu64(R1) = basename;
	asu64(R2) = pnames;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = namesoffset;
	asi64(R2) = virtoffset;
	asi64(R1) += asi64(R2);
	asu64(R2) = pnametable;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&pnametable;
	(*tou64p(R1)) += 4;
	asu64(R1) = basename;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&namesoffset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = basename;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&pnames;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = sectionno;
	R2 += (i64)R3*72-72;
	R3 = 48;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = paddrtable;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&paddrtable;
	(*tou64p(R1)) += 4;
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = pordtable;
	*tou16p(R2) = asu16(R1);
	R1 = (u64)&pordtable;
	(*tou64p(R1)) += 2;
	i += 1; if (i <= mc_writeexe_nexports) goto L4371;
L4373:
	return;
}

static i64 mc_writeexe_getexporttablesize() {
    u64 R1, R2; 
	i64 size;
	i64 i;
	R1 = 40;
	size = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = mc_writeexe_dllfilename;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4377;
L4375:
	R1 = (u64)&mc_writeexe_exporttable;
	asi64(R2) = i;
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_nexports) goto L4375;
L4377:
	asi64(R1) = size;
	goto L4374;
L4374:
	return asi64(R1);
}

static void mc_writeexe_newbasereloc(i64 addr, i64 reltype) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	asi64(R1) = addr;
	asu64(R2) = p;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = reltype;
	asu64(R2) = p;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = mc_writeexe_basereloclist;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	mc_writeexe_basereloclist = asu64(R1);
	R1 = (u64)&mc_writeexe_nbaserelocs;
	(*toi64p(R1)) += 1;
	asi64(R1) = addr;
	R2 = (u64)&mc_writeexe_maxrelocaddr;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	return;
}

static void mc_writeexe_scanbaserelocs() {
    u64 R1, R2, R3; 
	i64 baseaddr;
	i64 addr;
	i64 nextblock;
	u64 p;
	i64 i;
	R1 = 4096;
	baseaddr = asi64(R1);
	R1 = 0;
	mc_writeexe_nbaseblocks = asi64(R1);
L4380:
	asi64(R1) = baseaddr;
	R2 = 4096;
	asi64(R1) += asi64(R2);
	nextblock = asi64(R1);
	asi64(R1) = mc_writeexe_nbaseblocks;
	R2 = 500;
	if (asi64(R1) < asi64(R2)) goto L4384;
	R1 = tou64("Too many blocks");
	mc_libmcl_axerror(asu64(R1));
L4384:
	R1 = (u64)&mc_writeexe_nbaseblocks;
	(*toi64p(R1)) += 1;
	asi64(R1) = baseaddr;
	R2 = (u64)&mc_writeexe_blockbases;
	asi64(R3) = mc_writeexe_nbaseblocks;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 0;
	R2 = (u64)&mc_writeexe_blockcounts;
	asi64(R3) = mc_writeexe_nbaseblocks;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	asu64(R1) = mc_writeexe_basereloclist;
	p = asu64(R1);
	goto L4386;
L4385:
	asu64(R1) = p;
	R2 = 8;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	addr = asi64(R1);
	asi64(R1) = addr;
	asi64(R2) = baseaddr;
	if (asi64(R1) < asi64(R2)) goto L4389;
	asi64(R1) = addr;
	asi64(R2) = nextblock;
	if (asi64(R1) >= asi64(R2)) goto L4389;
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = mc_writeexe_nbaseblocks;
	R1 += (i64)R2*4-4;
	(*toi32p(R1)) += 1;
L4389:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L4386:
	asu64(R1) = p;
	if (asu64(R1)) goto L4385;
	asi64(R1) = nextblock;
	baseaddr = asi64(R1);
	asi64(R1) = baseaddr;
	asi64(R2) = mc_writeexe_maxrelocaddr;
	if (asi64(R1) <= asi64(R2)) goto L4380;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nbaseblocks;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4392;
L4390:
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	if (!asi32(R1)) goto L4394;
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4396;
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	R1 += (i64)R2*4-4;
	(*toi32p(R1)) += 1;
	R1 = (u64)&mc_writeexe_blockpadding;
	asi64(R2) = i;
	R1 += (i64)R2-1;
	(*tou8p(R1)) += 1;
L4396:
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = 8;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeexe_blockbytes;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	R1 = (u64)&mc_writeexe_blockbytes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mc_writeexe_basetablesize;
	*toi64p(R2) += asi64(R1);
L4394:
	i += 1; if (i <= mc_writeexe_nbaseblocks) goto L4390;
L4392:
	return;
}

static void mc_writeexe_writebasereloctable(u64 pstart) {
    u64 R1, R2, R3; 
	u64 p32;
	u64 p16;
	i64 baseaddr;
	i64 addr;
	i64 nextblock;
	u64 q;
	i64 i;
	asu64(R1) = pstart;
	p32 = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nbaseblocks;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4400;
L4398:
	R1 = (u64)&mc_writeexe_blockcounts;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	if (!asi32(R1)) goto L4402;
	R1 = (u64)&mc_writeexe_blockbases;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p32;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&p32;
	(*tou64p(R1)) += 4;
	R1 = (u64)&mc_writeexe_blockbytes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	asu64(R2) = p32;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&p32;
	(*tou64p(R1)) += 4;
	asu64(R1) = p32;
	p16 = asu64(R1);
	asu64(R1) = mc_writeexe_basereloclist;
	q = asu64(R1);
	R1 = (u64)&mc_writeexe_blockbases;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	baseaddr = asi64(R1);
	asi64(R1) = baseaddr;
	R2 = 4096;
	asi64(R1) += asi64(R2);
	nextblock = asi64(R1);
	goto L4404;
L4403:
	asu64(R1) = q;
	R2 = 8;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	addr = asi64(R1);
	asi64(R1) = addr;
	asi64(R2) = baseaddr;
	if (asi64(R1) < asi64(R2)) goto L4407;
	asi64(R1) = addr;
	asi64(R2) = nextblock;
	if (asi64(R1) >= asi64(R2)) goto L4407;
	asi64(R1) = addr;
	asi64(R2) = baseaddr;
	asi64(R1) -= asi64(R2);
	asu64(R2) = q;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 2;
	if (asi64(R2) != asi64(R3)) goto L4409;
	R2 = 3;
	goto L4408;
L4409:
	R2 = 10;
L4408:
	R3 = 12;
	asi64(R2) <<= asi64(R3);
	asi64(R1) += asi64(R2);
	asu64(R2) = p16;
	*tou16p(R2) = asu16(R1);
	R1 = (u64)&p16;
	(*tou64p(R1)) += 2;
L4407:
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L4404:
	asu64(R1) = q;
	if (asu64(R1)) goto L4403;
	R1 = (u64)&mc_writeexe_blockpadding;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4411;
	R1 = 0;
	R2 = (u64)&p16;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 2; asu64(R2) = asu64(R3);
	*tou16p(R2) = asu16(R1);
L4411:
	asu64(R1) = p16;
	p32 = asu64(R1);
L4402:
	i += 1; if (i <= mc_writeexe_nbaseblocks) goto L4398;
L4400:
	return;
}

static void mc_writeexe_sortexports(u64 sortindex) {
    u64 R1, R2, R3; 
	u64 d;
	u64 e;
	i64 swapped;
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4415;
L4413:
	asi64(R1) = i;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	i += 1; if (i <= mc_writeexe_nexports) goto L4413;
L4415:
L4416:
	R1 = 0;
	swapped = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nexports;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4421;
L4419:
	R1 = (u64)&mc_writeexe_exporttable;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = (u64)&mc_writeexe_exporttable;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	R1 += (i64)R2*16-16;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4423;
	R1 = 1;
	swapped = asi64(R1);
	asu64(R1) = sortindex;
	asi64(R2) = i;
	R1 += (i64)R2*8-8;
	asu64(R2) = sortindex;
	asi64(R3) = i;
	R2 += (i64)R3*8;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
L4423:
	i += 1; if (i <= av_1) goto L4419;
L4421:
	asi64(R1) = swapped;
	if (asi64(R1)) goto L4416;
	return;
}

static i64 mc_writeexe_getsectionno(i64 segment) {
    u64 R1, R2; 
	asi64(R1) = segment;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4426;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4427;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4428;
	goto L4429;
L4426:
	R1 = 3;
	goto L4425;
L4427:
	R1 = 2;
	goto L4425;
L4428:
	R1 = 1;
	goto L4425;
L4429:
	R1 = tou64("GSN");
	mc_libmcl_axerror(asu64(R1));
	R1 = 0;
L4425:
	goto L4424;
L4424:
	return asi64(R1);
}

static void mc_writeexe_getoffsets() {
    u64 R1, R2, R3, R4; 
	i64 fileoffset;
	i64 imageoffset;
	i64 i;
	i64 diroffset;
	i64 impdirno;
	i64 hinttableoffset;
	i64 j;
	i64 n;
	i64 codesize;
	i64 length;
	i64 thunkoffset;
	i64 offset;
	i64 dirstartoffset;
	u64 pcode;
	u64 pimpdir;
	u64 pdir;
	u64 paddr;
	u64 pname;
	i64 iatoffset;
	u64 phint;
	u64 pextra;
	i64 xxx;
	i64 av_1;
	u64 thunkptr;
	u64 codebase;
	i64 thunkaddr;
	R1 = 392;
	fileoffset = asi64(R1);
	R1 = 40;
	asi64(R2) = mc_writeexe_nsections;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&fileoffset;
	*toi64p(R2) += asi64(R1);
	R1 = 512;
	asi64(R2) = fileoffset;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	fileoffset = asi64(R1);
	R1 = 4096;
	imageoffset = asi64(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	codesize = asi64(R1);
	asi64(R1) = codesize;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	pcode = asu64(R1);
	goto L4432;
L4431:
	R1 = 144;
	R2 = (u64)&pcode;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&codesize;
	(*toi64p(R1)) += 1;
L4432:
	asi64(R1) = codesize;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L4431;
	asi64(R1) = codesize;
	thunkoffset = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&codesize;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = codesize;
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	asi64(R2) = codesize;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	R3 = 1;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = codesize;
	asi64(R2) = thunkoffset;
	asi64(R1) -= asi64(R2);
	R2 = 16;
	asi64(R1) += asi64(R2);
	asu64(R2) = mc_decls_ss_code;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nsections;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4436;
L4434:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4438;
	asi64(R1) = fileoffset;
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = i;
	R2 += (i64)R3*72-72;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4438:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4440;
	R1 = 512;
	asi64(R2) = fileoffset;
	R3 = (u64)&mc_writeexe_sectiontable;
	asi64(R4) = i;
	R3 += (i64)R4*72-72;
	R4 = 40;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	fileoffset = asi64(R1);
L4440:
	asi64(R1) = imageoffset;
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = i;
	R2 += (i64)R3*72-72;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = i;
	R1 += (i64)R2*72-72;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4442;
	asi64(R1) = imageoffset;
	diroffset = asi64(R1);
	asi64(R1) = i;
	impdirno = asi64(R1);
L4442:
	R1 = 4096;
	asi64(R2) = imageoffset;
	R3 = (u64)&mc_writeexe_sectiontable;
	asi64(R4) = i;
	R3 += (i64)R4*72-72;
	R4 = 40;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	imageoffset = asi64(R1);
	i += 1; if (i <= mc_writeexe_nsections) goto L4434;
L4436:
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4444;
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 0;
	R1 += (i64)R2;
	mc_writeexe_getbaserelocs(asu64(R1));
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 72;
	R1 += (i64)R2;
	mc_writeexe_getbaserelocs(asu64(R1));
L4444:
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 20;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4447;
L4445:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_ndlls) goto L4445;
L4447:
	asi64(R1) = diroffset;
	mc_writeexe_fileiatoffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4450;
L4448:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_ndlls) goto L4448;
L4450:
	asi64(R1) = diroffset;
	asi64(R2) = mc_writeexe_fileiatoffset;
	asi64(R1) -= asi64(R2);
	mc_writeexe_fileiatsize = asi64(R1);
	asi64(R1) = diroffset;
	hinttableoffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4453;
L4451:
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = i;
	R1 += (i64)R2*48;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 3;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4455;
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
L4455:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_nimports) goto L4451;
L4453:
	R1 = 4;
	asi64(R2) = diroffset;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	diroffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4458;
L4456:
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L4460;
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
L4460:
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = diroffset;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	i += 1; if (i <= mc_writeexe_ndlls) goto L4456;
L4458:
	R1 = (u64)&mc_writeexe_sectiontable;
	asi64(R2) = impdirno;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	dirstartoffset = asi64(R1);
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4462;
	asi64(R1) = diroffset;
	mc_writeexe_exportdirvirtaddr = asi64(R1);
	asi64(R1) = diroffset;
	asi64(R2) = dirstartoffset;
	asi64(R1) -= asi64(R2);
	mc_writeexe_exportdiroffset = asi64(R1);
	asi64(R1) = mc_writeexe_getexporttablesize();
	mc_writeexe_exportdirvirtsize = asi64(R1);
	asi64(R1) = mc_writeexe_exportdirvirtsize;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
	mc_writeexe_scanbaserelocs();
	asi64(R1) = diroffset;
	mc_writeexe_blockdirvirtaddr = asi64(R1);
	asi64(R1) = diroffset;
	asi64(R2) = dirstartoffset;
	asi64(R1) -= asi64(R2);
	mc_writeexe_blockdiroffset = asi64(R1);
	asi64(R1) = mc_writeexe_basetablesize;
	mc_writeexe_blockdirvirtsize = asi64(R1);
	asi64(R1) = mc_writeexe_blockdirvirtsize;
	R2 = (u64)&diroffset;
	*toi64p(R2) += asi64(R1);
L4462:
	asi64(R1) = diroffset;
	asi64(R2) = dirstartoffset;
	asi64(R1) -= asi64(R2);
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = impdirno;
	R2 += (i64)R3*72-72;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	asi64(R2) = offset;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&mc_writeexe_sectiontable;
	asi64(R3) = impdirno;
	R2 += (i64)R3*72-72;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 512;
	asi64(R2) = fileoffset;
	asi64(R3) = offset;
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_writeexe_filesize = asi64(R1);
	R1 = 4096;
	asi64(R2) = imageoffset;
	asi64(R3) = diroffset;
	asi64(R4) = dirstartoffset;
	asi64(R3) -= asi64(R4);
	asi64(R2) += asi64(R3);
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_writeexe_imagesize = asi64(R1);
	asi64(R1) = offset;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	R2 = R1;
	R3 = (u64)&mc_writeexe_sectiontable;
	asi64(R4) = impdirno;
	R3 += (i64)R4*72-72;
	R4 = 0;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	pimpdir = asu64(R1);
	asu64(R1) = pimpdir;
	pdir = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4465;
L4463:
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pdir;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pdir;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pdir;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pdir;
	(*tou64p(R1)) += 20;
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	iatoffset = asi64(R1);
	asu64(R1) = pimpdir;
	asi64(R2) = iatoffset;
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	paddr = asu64(R1);
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	pname = asu64(R1);
	R1 = 1;
	j = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4468;
L4466:
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = j;
	R1 += (i64)R2*48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L4470;
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = j;
	R1 += (i64)R2*48;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	asu64(R3) = paddr;
	*toi64p(R3) = asi64(R2);
	asu64(R2) = pname;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = iatoffset;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = j;
	R2 += (i64)R3*48;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	R2 = (u64)&iatoffset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&pname;
	(*tou64p(R1)) += 8;
	R1 = (u64)&paddr;
	(*tou64p(R1)) += 8;
L4470:
	j += 1; if (j <= mc_writeexe_nimports) goto L4466;
L4468:
	i += 1; if (i <= mc_writeexe_ndlls) goto L4463;
L4465:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4473;
L4471:
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	phint = asu64(R1);
	R1 = 2;
	R2 = (u64)&phint;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&mc_writeexe_importtable;
	asi64(R2) = i;
	R1 += (i64)R2*48;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = phint;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	i += 1; if (i <= mc_writeexe_nimports) goto L4471;
L4473:
	asi64(R1) = dirstartoffset;
	xxx = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_ndlls;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4476;
L4474:
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 40;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	pextra = asu64(R1);
	R1 = 1;
	j = asi64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4479;
L4477:
	asi64(R1) = xxx;
	asu64(R2) = pextra;
	*tou32p(R2) = asu32(R1);
	R1 = (u64)&pextra;
	(*tou64p(R1)) += 4;
	j += 1; if (j <= av_1) goto L4477;
L4479:
	R1 = 20;
	R2 = (u64)&xxx;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pimpdir;
	R2 = (u64)&mc_writeexe_dlltable;
	asi64(R3) = i;
	R2 += (i64)R3*48-48;
	R3 = 32;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = dirstartoffset;
	R1 -= (i64)R2;
	phint = asu64(R1);
	R1 = (u64)&mc_writeexe_dlltable;
	asi64(R2) = i;
	R1 += (i64)R2*48-48;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = phint;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	i += 1; if (i <= mc_writeexe_ndlls) goto L4474;
L4476:
	asi64(R1) = mc_writeexe_isdll;
	if (!asi64(R1)) goto L4481;
	asu64(R1) = pimpdir;
	asi64(R2) = mc_writeexe_exportdiroffset;
	R1 += (i64)R2;
	mc_writeexe_writeexporttable(asu64(R1));
	asu64(R1) = pimpdir;
	asi64(R2) = mc_writeexe_blockdiroffset;
	R1 += (i64)R2;
	mc_writeexe_writebasereloctable(asu64(R1));
L4481:
	asi64(R1) = thunkoffset;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	thunkptr = asu64(R1);
	R1 = 0;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	codebase = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeexe_nimports;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4484;
L4482:
	asu64(R1) = thunkptr;
	asu64(R2) = codebase;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4486;
	R1 = 72;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 255;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 36;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 37;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = mc_writeexe_imagebase;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 32;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	thunkaddr = asi64(R1);
	asi64(R1) = thunkaddr;
	asu64(R2) = thunkptr;
	*toi32p(R2) = asi32(R1);
	R1 = 4;
	R2 = (u64)&thunkptr;
	*tou64p(R2) += asu64(R1);
	goto L4485;
L4486:
	R1 = 72;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 255;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 37;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = mc_writeexe_imagebase;
	R2 = (u64)&mc_writeexe_importtable;
	asi64(R3) = i;
	R2 += (i64)R3*48;
	R3 = 32;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	thunkaddr = asi64(R1);
	R1 = 0;
	asi64(R2) = thunkaddr;
	asi64(R3) = mc_writeexe_imagebase;
	asi64(R2) -= asi64(R3);
	asu64(R3) = thunkptr;
	asu64(R4) = codebase;
	asi64(R3) -= asi64(R4);
	asi64(R1) = mc_writeexe_getripoffset(asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = thunkptr;
	*toi32p(R2) = asi32(R1);
	R1 = 4;
	R2 = (u64)&thunkptr;
	*tou64p(R2) += asu64(R1);
	R1 = 144;
	R2 = (u64)&thunkptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L4485:
	i += 1; if (i <= mc_writeexe_nimports) goto L4482;
L4484:
	return;
}

static i64 mc_writeexe_getripoffset(i64 addr, i64 dest, i64 extra) {
    u64 R1, R2, R3; 
	R1 = (u64)&mc_writeexe_sectiontable;
	R2 = 1;
	R1 += (i64)R2*72-72;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&addr;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = dest;
	asi64(R2) = addr;
	R3 = 4;
	asi64(R2) += asi64(R3);
	asi64(R1) -= asi64(R2);
	asi64(R2) = extra;
	asi64(R1) -= asi64(R2);
	goto L4487;
L4487:
	return asi64(R1);
}

static void mc_writeobj_writecoff(u64 outfile) {
    u64 R1, R2, R3; 
	struct $B17 header;
	struct $B69 zsection;
	struct $B69 isection;
	struct $B69 csection;
	i64 offset;
	i64 aa;
	asu8(R1) = pc_decls_objdone;
	if (!asu8(R1)) goto L4490;
	goto L4488;
L4490:
	R1 = (u64)&header;
	memset(R1, 0, 20);
	R1 = (u64)&zsection;
	memset(R1, 0, 40);
	R1 = (u64)&isection;
	memset(R1, 0, 40);
	R1 = (u64)&csection;
	memset(R1, 0, 40);
	R1 = 34404;
	R2 = (u64)&header;
	R3 = 0;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 3;
	R2 = (u64)&header;
	R3 = 2;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = tou64(".bss");
	R2 = (u64)&zsection;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&zsection;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 3225419904;
	R2 = (u64)&zsection;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	R2 = 65536;
	if (asi64(R1) >= asi64(R2)) goto L4493;
	asi64(R1) = mc_decls_ss_ncoderelocs;
	R2 = 65536;
	if (asi64(R1) < asi64(R2)) goto L4492;
L4493:
	R1 = tou64("Too many relocs (exceeds 16-bit field)");
	mc_libmcl_axerror(asu64(R1));
L4492:
	R1 = tou64(".data");
	R2 = (u64)&isection;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&isection;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_decls_ss_nidatarelocs;
	R2 = (u64)&isection;
	R3 = 32;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 3226468416;
	R2 = (u64)&isection;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = tou64(".text");
	R2 = (u64)&csection;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&csection;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_decls_ss_ncoderelocs;
	R2 = (u64)&csection;
	R3 = 32;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1615855648;
	R2 = (u64)&csection;
	R3 = 36;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = outfile;
	mc_writeobj_initsymboltable(asu64(R1));
	mc_writeobj_convertsymboltable();
	R1 = 20;
	offset = asi64(R1);
	R1 = 120;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&isection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L4495;
	asi64(R1) = offset;
	R2 = (u64)&isection;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&isection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 10;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L4495:
	R1 = (u64)&csection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (!asu16(R1)) goto L4497;
	asi64(R1) = offset;
	R2 = (u64)&csection;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&csection;
	R2 = 32;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 10;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
L4497:
	asi64(R1) = offset;
	R2 = (u64)&isection;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&isection;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	R2 = (u64)&csection;
	R3 = 20;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&csection;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	R2 = (u64)&header;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 18;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = (u64)&header;
	R3 = 12;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mc_writeobj_nextstringoffset;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	asu64(R1) = malloc(asu64(R1));
	R2 = R1;
	mc_writeobj_dataptr = asu64(R2);
	mc_writeobj_datastart = asu64(R1);
	R1 = 20;
	R2 = (u64)&header;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	R1 = 40;
	R2 = (u64)&zsection;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	R1 = 40;
	R2 = (u64)&isection;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	R1 = 40;
	R2 = (u64)&csection;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asu64(R2) = mc_decls_ss_idatarelocs;
	mc_writeobj_writerelocs(asu64(R2), asi64(R1));
	asi64(R1) = mc_decls_ss_ncoderelocs;
	asu64(R2) = mc_decls_ss_coderelocs;
	mc_writeobj_writerelocs(asu64(R2), asi64(R1));
	asu64(R1) = mc_decls_ss_idata;
	mc_writeobj_writedata(asu64(R1));
	asu64(R1) = mc_decls_ss_code;
	mc_writeobj_writedata(asu64(R1));
	mc_writeobj_writesymboltable();
	mc_writeobj_writestringtable();
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L4499;
	msysc_m$print_startcon();
	R1 = tou64("Writing file:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = outfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4499:
	asu64(R1) = mc_writeobj_dataptr;
	asu64(R2) = mc_writeobj_datastart;
	asi64(R1) -= asi64(R2);
	asu64(R2) = mc_writeobj_datastart;
	asu64(R3) = outfile;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	pc_decls_objdone = asu8(R1);
L4488:
	return;
}

static void mc_writeobj_writerecord(u64 r, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = r;
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	return;
}

static void mc_writeobj_writerelocs(u64 r, i64 nrelocs) {
    u64 R1, R2, R3; 
	u64 d;
	asi64(R1) = nrelocs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4503;
	goto L4501;
L4503:
	goto L4505;
L4504:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4508;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4508;
	goto L4509;
L4508:
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = r;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4511;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4512;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4513;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4514;
	goto L4515;
L4511:
	R1 = 2;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4510;
L4512:
	R1 = 4;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4510;
L4513:
	R1 = 6;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4510;
L4514:
	asu64(R1) = r;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeobj_stoffset;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4510;
L4515:
	R1 = tou64("wrelocs/bad seg");
	mc_libmcl_axerror(asu64(R1));
L4510:
	goto L4507;
L4509:
	asu64(R1) = r;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = mc_writeobj_stoffset;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 4;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4507:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 8;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4517;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4518;
	goto L4519;
L4517:
	goto L4516;
L4518:
	asu64(R1) = r;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4521;
	R1 = 4;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 8;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 4;
	asu64(R2) = r;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4521:
	goto L4516;
L4519:
	R1 = tou64("OBJ/phighmem 1?");
	mc_libmcl_axerror(asu64(R1));
L4516:
	asu64(R1) = r;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mc_writeobj_writerelocs_s;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 10;
	R2 = (u64)&mc_writeobj_writerelocs_s;
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 10;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = r;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L4505:
	asu64(R1) = r;
	if (asu64(R1)) goto L4504;
L4501:
	return;
}

static void mc_writeobj_writedata(u64 data) {
    u64 R1, R2, R3; 
	asu64(R1) = data;
	asu64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = 0;
	asu64(R3) = data;
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = data;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	return;
}

static void mc_writeobj_writesymboltable() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4526;
L4524:
	R1 = 18;
	R2 = (u64)&mc_writeobj_symboltable;
	asi64(R3) = i;
	R2 += (i64)R3*18;
	mc_writeobj_writerecord(asu64(R2), asi64(R1));
	i += 1; if (i <= mc_writeobj_nsymbols) goto L4524;
L4526:
	return;
}

static void mc_writeobj_writestringtable() {
    u64 R1, R2, R3; 
	u64 p;
	i64 i;
	i64 n;
	asu64(R1) = mc_writeobj_dataptr;
	p = asu64(R1);
	asi64(R1) = mc_writeobj_nextstringoffset;
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	R1 = 4;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_writeobj_nstrings;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4530;
L4528:
	R1 = (u64)&mc_writeobj_stringlengths;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = (u64)&mc_writeobj_stringtable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = mc_writeobj_dataptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&mc_writeobj_dataptr;
	*tou64p(R2) += asu64(R1);
	i += 1; if (i <= mc_writeobj_nstrings) goto L4528;
L4530:
	return;
}

static u64 mc_writeobj_makesymbol(u64 name, i64 value, i64 sectionno, i64 symtype, i64 storage, i64 naux) {
    u64 R1, R2, R3, R4; 
	i64 length;
	i64 namelen;
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	namelen = asi64(R1);
	asi64(R1) = namelen;
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L4533;
	asu64(R1) = name;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4532;
L4533:
	asi64(R1) = namelen;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4534;
	asi64(R1) = namelen;
	asu64(R2) = name;
	R3 = (u64)&mc_writeobj_makesymbol_r;
	R4 = 0;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L4532;
L4534:
	R1 = 0;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = namelen;
	asu64(R2) = name;
	asi64(R1) = mc_writeobj_addstringentry(asu64(R2), asi64(R1));
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L4532:
	asi64(R1) = value;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = sectionno;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = symtype;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 14;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = storage;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = naux;
	R2 = (u64)&mc_writeobj_makesymbol_r;
	R3 = 17;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mc_writeobj_makesymbol_r;
	goto L4531;
L4531:
	return asu64(R1);
}

static void mc_writeobj_addsymbol(u64 r) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 13000;
	if (asi64(R1) < asi64(R2)) goto L4537;
	R1 = tou64("as:Too many symbols");
	mc_libmcl_axerror(asu64(R1));
L4537:
	R1 = 18;
	asu64(R2) = r;
	R3 = (u64)&mc_writeobj_symboltable;
	R4 = (u64)&mc_writeobj_nsymbols;
	asi64(R4) = *(toi64p(R4)) += 1;
	R3 += (i64)R4*18;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mc_writeobj_initsymboltable(u64 filename) {
    u64 R1, R2, R3, R4, R5, R6; 
	R1 = 0;
	mc_writeobj_nsymbols = asi64(R1);
	R1 = 1;
	R2 = 103;
	R3 = 0;
	R4 = -2;
	R5 = 0;
	R6 = tou64(".file");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	asu64(R1) = filename;
	asu64(R1) = mc_writeobj_strtoaux(asu64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 1;
	R2 = 3;
	R3 = 0;
	R4 = 1;
	R5 = 0;
	R6 = tou64(".bss");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R1) = mc_writeobj_sectiontoaux(asu64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 1;
	R2 = 3;
	R3 = 0;
	R4 = 2;
	R5 = 0;
	R6 = tou64(".data");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asu64(R2) = mc_decls_ss_idata;
	asu64(R1) = mc_writeobj_sectiontoaux(asu64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	R1 = 1;
	R2 = 3;
	R3 = 0;
	R4 = 3;
	R5 = 0;
	R6 = tou64(".text");
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	asi64(R1) = mc_decls_ss_ncoderelocs;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_writeobj_sectiontoaux(asu64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	return;
}

static u64 mc_writeobj_strtoaux(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	i64 n;
	R1 = (u64)&mc_writeobj_strtoaux_r;
	p = asu64(R1);
	R1 = 18;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 0;
	n = asi64(R1);
	goto L4541;
L4540:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
L4541:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4543;
	asi64(R1) = n;
	R2 = 18;
	if (asi64(R1) < asi64(R2)) goto L4540;
L4543:
	R1 = (u64)&mc_writeobj_strtoaux_r;
	goto L4539;
L4539:
	return asu64(R1);
}

static u64 mc_writeobj_sectiontoaux(u64 data, i64 nrelocs) {
    u64 R1, R2, R3; 
	R1 = (u64)&mc_writeobj_sectiontoaux_r;
	memset(R1, 0, 18);
	asu64(R1) = data;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4546;
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&mc_writeobj_sectiontoaux_r;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4545;
L4546:
	asu64(R1) = data;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&mc_writeobj_sectiontoaux_r;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4545:
	asi64(R1) = nrelocs;
	R2 = (u64)&mc_writeobj_sectiontoaux_r;
	R3 = 4;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = (u64)&mc_writeobj_sectiontoaux_r;
	goto L4544;
L4544:
	return asu64(R1);
}

static i64 mc_writeobj_addstringentry(u64 s, i64 length) {
    u64 R1, R2, R3; 
	i64 offset;
	asi64(R1) = mc_writeobj_nextstringoffset;
	offset = asi64(R1);
	asi64(R1) = mc_writeobj_nstrings;
	R2 = 5000;
	if (asi64(R1) <= asi64(R2)) goto L4549;
	R1 = tou64("W:too many strings");
	mc_libmcl_axerror(asu64(R1));
L4549:
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mc_writeobj_stringtable;
	R3 = (u64)&mc_writeobj_nstrings;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = length;
	R2 = (u64)&mc_writeobj_stringlengths;
	asi64(R3) = mc_writeobj_nstrings;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mc_writeobj_nextstringoffset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = offset;
	goto L4547;
L4547:
	return asi64(R1);
}

static void mc_writeobj_convertsymboltable() {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 s;
	u64 name;
	i64 i;
	i64 sect;
	i64 scope;
	asi64(R1) = mc_writeobj_nsymbols;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mc_writeobj_stoffset = asi64(R1);
	R1 = 0;
	mc_writeobj_nstrings = asi64(R1);
	R1 = 4;
	mc_writeobj_nextstringoffset = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4553;
L4551:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	s = asu64(R1);
	asu64(R1) = s;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = s;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4555;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4556;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4557;
	goto L4558;
L4555:
	R1 = 1;
	sect = asi64(R1);
	goto L4554;
L4556:
	R1 = 2;
	sect = asi64(R1);
	goto L4554;
L4557:
	R1 = 3;
	sect = asi64(R1);
	goto L4554;
L4558:
	R1 = 0;
	sect = asi64(R1);
L4554:
	asu64(R1) = s;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4560;
	R1 = 0;
	sect = asi64(R1);
L4560:
	R1 = 0;
	scope = asi64(R1);
	asu64(R1) = s;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4563;
	asu64(R1) = s;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4562;
L4563:
	R1 = 2;
	scope = asi64(R1);
	goto L4561;
L4562:
	R1 = 3;
	scope = asi64(R1);
L4561:
	asu64(R1) = s;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4565;
	asu64(R1) = name;
	asu64(R1) = pc_api_getbasename(asu64(R1));
	name = asu64(R1);
L4565:
	R1 = 0;
	asi64(R2) = scope;
	R3 = 0;
	asi64(R4) = sect;
	asu64(R5) = s;
	R6 = 76;
	asi32(R5) = *toi32p(((i64)R5+(i64)R6));
	R5 = toi64(toi32(R5));
	asu64(R6) = name;
	asu64(R1) = mc_writeobj_makesymbol(asu64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	mc_writeobj_addsymbol(asu64(R1));
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4551;
L4553:
	return;
}

static u64 mc_writess_dummy_writessdata(i64 fexe) {
    u64 R1; 
	R1 = 0;
	goto L4566;
L4566:
	return asu64(R1);
}

static u64 mx_run_writememlib(u64 filename) {
    u64 R1, R2, R3; 
	u64 plib;
	i64 n;
	i64 k;
	struct $B87 lib;
	i64 ndlls;
	i64 nlibs;
	i64 i;
	R1 = (u64)&lib;
	memset(R1, 0, 216);
	R1 = 8;
	asi64(R2) = mc_decls_ss_zdatalen;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_decls_ss_zdatalen = asi64(R1);
	R1 = 144;
	R2 = 8;
	asu64(R3) = mc_decls_ss_code;
	mx_run_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 8;
	asu64(R3) = mc_decls_ss_idata;
	mx_run_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64("0.1234");
	R2 = (u64)&lib;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	R2 = (u64)&lib;
	R3 = 184;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 192;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&lib;
	R3 = 208;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	mx_run_countsymbols();
	R1 = (u64)&lib;
	mx_run_writerelocs(asu64(R1));
	asi64(R1) = mc_decls_ss_zdatalen;
	R2 = (u64)&lib;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&lib;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = (u64)&lib;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 0;
	asu64(R2) = mc_decls_ss_code;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	R2 = (u64)&lib;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = mc_decls_ss_idata;
	asu64(R1) = mc_genss_bufferelemptr(asu64(R2), asi64(R1));
	R2 = (u64)&lib;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	ndlls = asi64(R1);
	R1 = 0;
	nlibs = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4570;
L4568:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4572;
	R1 = (u64)&ndlls;
	(*toi64p(R1)) += 1;
L4572:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4568;
L4570:
	asi64(R1) = ndlls;
	R2 = (u64)&lib;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = nlibs;
	R2 = (u64)&lib;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = ndlls;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asi64(R2) = nlibs;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 104;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4575;
L4573:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4577;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&lib;
	R3 = 96;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4577:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4573;
L4575:
	R1 = (u64)&lib;
	mx_run_addsymbols(asu64(R1));
	R1 = 216;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	plib = asu64(R1);
	R1 = 216;
	R2 = (u64)&lib;
	asu64(R3) = plib;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = plib;
	goto L4567;
L4567:
	return asu64(R1);
}

static void mx_run_roundsegment(u64 p, i64 align, i64 value) {
    u64 R1, R2, R3; 
	i64 length;
	i64 newlength;
	i64 av_1;
	asu64(R1) = p;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	length = asi64(R1);
	asi64(R1) = align;
	asi64(R2) = length;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	newlength = asi64(R1);
	asi64(R1) = align;
	asu64(R2) = p;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = newlength;
	asi64(R2) = length;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4581;
L4579:
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L4579;
L4581:
	return;
}

static void mx_run_writerelocs(u64 lib) {
    u64 R1, R2, R3; 
	u64 oldr;
	u64 newr;
	i64 n;
	i64 k;
	u64 d;
	u64 baseptr64;
	i64 i;
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asi64(R2) = mc_decls_ss_ncoderelocs;
	asi64(R1) += asi64(R2);
	asu64(R2) = lib;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = lib;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L4583:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4587;
	asu64(R1) = mc_decls_ss_idatarelocs;
	goto L4586;
L4587:
	asu64(R1) = mc_decls_ss_coderelocs;
L4586:
	oldr = asu64(R1);
	goto L4591;
L4588:
	R1 = (u64)&newr;
	memset(R1, 0, 8);
	asu64(R1) = oldr;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4593;
	R1 = 2;
	goto L4592;
L4593:
	R1 = 1;
L4592:
	R2 = (u64)&newr;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = oldr;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4595;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4596;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4596;
	goto L4597;
L4595:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4599;
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 5;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4598;
L4599:
	R1 = tou64("rel32/rel not imported");
	mc_libmcl_axerror(asu64(R1));
L4598:
	goto L4594;
L4596:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4601;
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4603;
	R1 = 3;
	goto L4602;
L4603:
	R1 = 4;
L4602:
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	goto L4600;
L4601:
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4605;
	R1 = 1;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4604;
L4605:
	R1 = 2;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4604:
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4600:
	goto L4594;
L4597:
	R1 = tou64("reloc?");
	mc_libmcl_axerror(asu64(R1));
L4594:
	asu64(R1) = newr;
	asu64(R2) = lib;
	R3 = 88;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = oldr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	oldr = asu64(R1);
L4591:
	asu64(R1) = oldr;
	if (asu64(R1)) goto L4588;
	i += 1; if (i <= 2) goto L4583;
	return;
}

static void mx_run_addsymbols(u64 lib) {
    u64 R1, R2, R3; 
	u64 d;
	u64 stentry;
	u64 epoffset;
	i64 n;
	i64 k;
	u64 name;
	i64 i;
	R1 = 0;
	stentry = asu64(R1);
	R1 = -1;
	epoffset = asu64(R1);
	asi64(R1) = mx_decls_nsymimports;
	asu64(R2) = lib;
	R3 = 56;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mx_decls_nsymexports;
	asu64(R2) = lib;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mx_decls_nsymimports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mx_decls_nsymexports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 120;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mx_decls_nsymexports;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mx_decls_nsymexports;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 136;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4609;
L4607:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L4611;
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 112;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4611:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4607;
L4609:
	R1 = 0;
	k = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4614;
L4612:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L4616;
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4618;
	asu64(R1) = d;
	stentry = asu64(R1);
L4618:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 120;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 128;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = k;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = lib;
	R3 = 136;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = k;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4616:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4612;
L4614:
	asu64(R1) = stentry;
	if (!asu64(R1)) goto L4620;
	asu64(R1) = stentry;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = lib;
	R3 = 144;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4619;
L4620:
	msysc_m$print_startcon();
	R1 = tou64("NO MAIN FOUND");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = -1;
	asu64(R2) = lib;
	R3 = 144;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4619:
	return;
}

static void mx_run_countsymbols() {
    u64 R1, R2, R3; 
	u64 d;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4624;
L4622:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 81;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4626;
	R1 = (u64)&mx_decls_nsymexports;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 118;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L4626:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4628;
	R1 = (u64)&mx_decls_nsymimports;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 116;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L4628:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4622;
L4624:
	return;
}

static void mx_run_runlibfile(u64 filename, i64 cmdskip) {
    u64 R1, R2; 
	u64 plib;
	asu64(R1) = filename;
	asu64(R1) = mx_run_writememlib(asu64(R1));
	plib = asu64(R1);
	asu64(R1) = plib;
	mx_lib_loadmemmcu(asu64(R1));
	asu64(R1) = plib;
	mx_lib_fixuplib(asu64(R1));
	asi64(R1) = cmdskip;
	asu64(R2) = plib;
	mx_lib_runprogram(asu64(R2), asi64(R1));
	return;
}

static u64 mx_lib_readlibfile(u64 filespec, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 plib;
	struct $B87 lib;
	u64 sig;
	i64 dir;
	i64 n;
	i64 tablesize;
	u64 q;
	i64 i;
	R1 = (u64)&lib;
	memset(R1, 0, 216);
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readu32(asu64(R1));
	sig = asu64(R1);
	asu64(R1) = sig;
	R2 = 441992013;
	if (asu64(R1) == asu64(R2)) goto L4632;
	msysc_m$print_startcon();
	R1 = tou64("Bad sig - not MCX file");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L4632:
	asu64(R1) = filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 184;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 192;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4633:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readbyte(asu64(R1));
	R2 = R1;
	dir = asi64(R2);
	switch (asi64(R1)) {
	case 0: goto L4668;
	case 1: goto L4637;
	case 2: goto L4640;
	case 3: goto L4639;
	case 4: goto L4638;
	case 5: goto L4665;
	case 6: goto L4641;
	case 7: goto L4645;
	case 8: goto L4649;
	case 9: goto L4653;
	case 10: goto L4657;
	case 11: goto L4661;
	case 12: goto L4666;
	case 13: goto L4667;
	default: goto L4636;
    };
// SWITCH
L4637:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4633;
L4638:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = (u64)&lib;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L4633;
L4639:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = (u64)&lib;
	R4 = 80;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	goto L4633;
L4640:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = (u64)&lib;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	goto L4633;
L4641:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 40;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4644;
L4642:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 96;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4642;
L4644:
	goto L4633;
L4645:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 104;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4648;
L4646:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 104;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4646;
L4648:
	goto L4633;
L4649:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 56;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4652;
L4650:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 112;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4650;
L4652:
	goto L4633;
L4653:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 64;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 120;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4656;
L4654:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readstring(asu64(R1));
	R2 = (u64)&lib;
	R3 = 120;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4654;
L4656:
	goto L4633;
L4657:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4660;
L4658:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readbyte(asu64(R1));
	R2 = (u64)&lib;
	R3 = 128;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L4658;
L4660:
	goto L4633;
L4661:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	n = asi64(R1);
	R1 = 8;
	asi64(R2) = n;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 136;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4664;
L4662:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readu32(asu64(R1));
	R2 = (u64)&lib;
	R3 = 136;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L4662;
L4664:
	goto L4633;
L4665:
	R1 = (u64)&p;
	asi64(R1) = mx_lib_readu32(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	R2 = (u64)&lib;
	R3 = 32;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&lib;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 8;
	asi64(R1) *= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&lib;
	R3 = 88;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = (u64)&lib;
	R4 = 88;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	goto L4633;
L4666:
	R1 = (u64)&p;
	asu64(R1) = mx_lib_readu32(asu64(R1));
	R2 = (u64)&lib;
	R3 = 144;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4633;
L4667:
	goto L4634;
	goto L4633;
L4668:
	goto L4633;
L4636:
	msysc_m$print_startcon();
	R1 = tou64("Unknown directive:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mx_decls_mcxdirnames;
	asi64(R2) = dir;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	exit(R1);
	goto L4633;
L4634:
	R1 = 216;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	plib = asu64(R1);
	R1 = 216;
	R2 = (u64)&lib;
	asu64(R3) = plib;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = plib;
	goto L4630;
L4630:
	return asu64(R1);
}

static i64 mx_lib_readbyte(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L4669;
L4669:
	return asi64(R1);
}

static u64 mx_lib_readu32(u64 p) {
    u64 R1, R2; 
	u64 x;
	asu64(R1) = p;
	asu64(R1) = *tou64p(R1);
	asu32(R1) = *tou32p(R1);
	R1 = tou64(tou32(R1));
	x = asu64(R1);
	R1 = 4;
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = x;
	goto L4670;
L4670:
	return asu64(R1);
}

static u64 mx_lib_readstring(u64 p) {
    u64 R1; 
	u64 s;
	asu64(R1) = p;
	asu64(R1) = *tou64p(R1);
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	s = asu64(R1);
	goto L4673;
L4672:
L4673:
	asu64(R1) = p;
	asu64(R1) = *(tou64p(R1)) += 1;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L4672;
	asu64(R1) = p;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	goto L4671;
L4671:
	return asu64(R1);
}

static void mx_lib_alloclibdata(u64 lib) {
    u64 R1, R2, R3, R4; 
	i64 tablesize;
	i64 n;
	u64 p;
	asu64(R1) = lib;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = lib;
	R3 = 152;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = lib;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) *= asi64(R2);
	tablesize = asi64(R1);
	asu64(R1) = lib;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	n = asi64(R1);
	asi64(R1) = n;
	asi64(R2) = tablesize;
	asi64(R1) += asi64(R2);
	asu64(R1) = mwindows_os_allocexecmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4677;
	R1 = tou64("");
	R2 = tou64("Can't alloc code memory");
	mx_lib_error(asu64(R2), asu64(R1));
L4677:
	asi64(R1) = n;
	asu64(R2) = lib;
	R3 = 72;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = tablesize;
	R2 = 0;
	asu64(R3) = p;
	asi64(R4) = n;
	R3 += (i64)R4;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = lib;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = tablesize;
	asu64(R2) = lib;
	R3 = 160;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 8;
	asu64(R2) = lib;
	R3 = 64;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 168;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = lib;
	R3 = 56;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = lib;
	R3 = 176;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = lib;
	R2 = 144;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4294967295;
	if (asi64(R1) == asi64(R2)) goto L4679;
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 144;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asu64(R2) = lib;
	R3 = 200;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4679:
	return;
}

static void mx_lib_error(u64 mess, u64 param) {
    u64 R1; 
	asu64(R1) = param;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L4682;
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L4681;
L4682:
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4681:
	msysc_m$print_startcon();
	R1 = tou64("Aborting");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void mx_lib_loadmemmcu(u64 lib) {
    u64 R1, R2, R3; 
	i64 newlib;
	u64 name;
	asu64(R1) = lib;
	R2 = 192;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = lib;
	R2 = 184;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = name;
	mx_lib_checknew(asu64(R2), asu64(R1));
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	newlib = asi64(R1);
	asu64(R1) = lib;
	R2 = (u64)&mx_decls_libtable;
	asi64(R3) = newlib;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = lib;
	mx_lib_loadimports(asu64(R1));
	return;
}

static void mx_lib_checknew(u64 name, u64 filename) {
    u64 R1, R2; 
	asu64(R1) = name;
	asi64(R1) = mx_lib_findlib(asu64(R1));
	if (!asi64(R1)) goto L4686;
	asu64(R1) = filename;
	R2 = tou64("Lib already exists:");
	mx_lib_error(asu64(R2), asu64(R1));
L4686:
	return;
}

static i64 mx_lib_findlib(u64 name) {
    u64 R1, R2; 
	i64 n;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nlibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4690;
L4688:
	R1 = (u64)&mx_decls_libnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4692;
	asi64(R1) = i;
	goto L4687;
L4692:
	i += 1; if (i <= mx_decls_nlibs) goto L4688;
L4690:
	R1 = 0;
	goto L4687;
L4687:
	return asi64(R1);
}

static i64 mx_lib_mxaddlib(u64 name) {
    u64 R1, R2, R3; 
	i64 n;
	asi64(R1) = mx_decls_nlibs;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L4695;
	R1 = tou64("");
	R2 = tou64("Too many libs");
	mx_lib_error(asu64(R2), asu64(R1));
L4695:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_libnametable;
	R3 = (u64)&mx_decls_nlibs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = mx_decls_nlibs;
	goto L4693;
L4693:
	return asi64(R1);
}

static void mx_lib_fixuplib(u64 lib) {
	mx_lib_loaddlls();
	mx_lib_checksymbols();
	mx_lib_dorelocations();
	return;
}

static void mx_lib_loaddlls() {
    u64 R1, R2, R3; 
	u64 inst;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4700;
L4698:
	R1 = (u64)&mx_decls_dllinsttable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (asu64(R1)) goto L4702;
	R1 = (u64)&mx_decls_dllnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mwindows_os_getdllinst(asu64(R1));
	inst = asu64(R1);
	asu64(R1) = inst;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4704;
	R1 = (u64)&mx_decls_dllnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Can't find DLL: #");
	mx_lib_error(asu64(R2), asu64(R1));
L4704:
	asu64(R1) = inst;
	R2 = (u64)&mx_decls_dllinsttable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4702:
	i += 1; if (i <= mx_decls_ndlllibs) goto L4698;
L4700:
	return;
}

static u64 mx_lib_finddllsymbol(u64 name, u64 dllindex) {
    u64 R1, R2, R3; 
	u64 p;
	i64 i;
	R1 = 0;
	asu64(R2) = dllindex;
	*toi64p(R2) = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4708;
L4706:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_dllinsttable;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mwindows_os_getdllprocaddr(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L4710;
	asi64(R1) = i;
	asu64(R2) = dllindex;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = p;
	goto L4705;
L4710:
	i += 1; if (i <= mx_decls_ndlllibs) goto L4706;
L4708:
	R1 = 0;
	goto L4705;
L4705:
	return asu64(R1);
}

static void mx_lib_checksymbols() {
    u64 R1, R2, R3; 
	i64 dllindex;
	i64 undef;
	u64 p;
	i64 i;
	R1 = 0;
	undef = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4714;
L4712:
	R1 = (u64)&mx_decls_symboldefined;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L4716;
	R1 = (u64)&dllindex;
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mx_lib_finddllsymbol(asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L4718;
	asu64(R1) = p;
	R2 = (u64)&mx_decls_symboladdress;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = dllindex;
	R2 = (u64)&mx_decls_symboldllindex;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mx_decls_symboldefined;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L4717;
L4718:
	msysc_m$print_startcon();
	R1 = tou64("Undef");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mx_decls_symbolnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&undef;
	(*toi64p(R1)) += 1;
L4717:
L4716:
	i += 1; if (i <= mx_decls_nsymbols) goto L4712;
L4714:
	asi64(R1) = undef;
	if (!asi64(R1)) goto L4720;
L4720:
	return;
}

static void mx_lib_dorelocations() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nlibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4724;
L4722:
	R1 = (u64)&mx_decls_librelocated;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L4726;
	R1 = (u64)&mx_decls_libtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_reloclib(asu64(R1));
L4726:
	i += 1; if (i <= mx_decls_nlibs) goto L4722;
L4724:
	return;
}

static void mx_lib_reloclib(u64 lib) {
    u64 R1, R2, R3, R4; 
	i64 index;
	i64 targetoffset;
	u64 name;
	u64 p;
	u64 q;
	u64 qaddr;
	u64 r;
	i64 av_1;
	i64 av_2;
	i64 i;
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = lib;
	R3 = 56;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R3 = 8;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	qaddr = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4730;
L4728:
	asu64(R1) = lib;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	name = asu64(R1);
	R1 = 72;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 255;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 36;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 37;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = qaddr;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	R1 = 4;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = lib;
	R2 = 176;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&qaddr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 8; asu64(R2) = asu64(R3);
	*tou64p(R2) = asu64(R1);
	i += 1; if (i <= av_1) goto L4728;
L4730:
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 32;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4733;
L4731:
	asu64(R1) = lib;
	R2 = 88;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	r = asu64(R1);
	R1 = (u64)&r;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4735;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4736;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4737;
	goto L4738;
L4735:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 0;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	p = asu64(R1);
	goto L4734;
L4736:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 0;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	p = asu64(R1);
	goto L4734;
L4737:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 0;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R1 += (i64)R2;
	p = asu64(R1);
	goto L4734;
L4738:
L4734:
	R1 = (u64)&r;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4740;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4741;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4742;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4743;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4744;
	goto L4745;
L4740:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	targetoffset = asi64(R1);
	R1 = (u64)&r;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4747;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4748;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4749;
	goto L4750;
L4747:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L4746;
L4748:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L4746;
L4749:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L4746;
L4750:
L4746:
	goto L4739;
L4741:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	targetoffset = asi64(R1);
	R1 = (u64)&r;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4752;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4753;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4754;
	goto L4755;
L4752:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	goto L4751;
L4753:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	goto L4751;
L4754:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = targetoffset;
	R1 += (i64)R2;
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	goto L4751;
L4755:
L4751:
	goto L4739;
L4742:
	asu64(R1) = lib;
	R2 = 176;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 4;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
	goto L4739;
L4743:
	asu64(R1) = lib;
	R2 = 176;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	R3 = 4;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	index = asi64(R1);
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	*tou32p(R2) += asu32(R1);
	goto L4739;
L4744:
	R1 = (u64)&r;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4757;
	R1 = tou64("");
	R2 = tou64("imprel32?");
	mx_lib_error(asu64(R2), asu64(R1));
L4757:
	R1 = (u64)&r;
	R2 = 4;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	index = asi64(R1);
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = lib;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2;
	asi64(R2) = index;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	R3 = 8;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 4;
	R2 += (i64)R3;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	*tou32p(R2) = asu32(R1);
	goto L4739;
L4745:
L4739:
	i += 1; if (i <= av_2) goto L4731;
L4733:
	R1 = 1;
	R2 = (u64)&mx_decls_librelocated;
	asu64(R3) = lib;
	R4 = 208;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mx_lib_loadimports(u64 plib) {
    u64 R1, R2; 
	u64 qlib;
	u64 name;
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = plib;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4761;
L4759:
	asu64(R1) = plib;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_dosublib(asu64(R1));
	i += 1; if (i <= av_1) goto L4759;
L4761:
	asu64(R1) = plib;
	mx_lib_alloclibdata(asu64(R1));
	asu64(R1) = plib;
	mx_lib_dosymbols(asu64(R1));
	return;
}

static void mx_lib_dosublib(u64 name) {
    u64 R1, R2, R3; 
	u64 qlib;
	i64 n;
	asu64(R1) = name;
	asi64(R1) = mx_lib_findlib(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	if (asi64(R1)) goto L4764;
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	n = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("Loading sublib");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = n;
	R2 = tou64("ml");
	asu64(R3) = name;
	asu64(R2) = mlib_addext(asu64(R3), asu64(R2));
	asu64(R1) = mx_lib_loadlibfile(asu64(R2), asi64(R1));
	qlib = asu64(R1);
	asu64(R1) = qlib;
	mx_lib_loadimports(asu64(R1));
L4764:
	return;
}

static u64 mx_lib_loadlibfile(u64 filename, i64 libno) {
    u64 R1, R2, R3, R4; 
	u64 plib;
	u64 p;
	asu64(R1) = filename;
	asu64(R1) = mx_lib_readmxfile(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4767;
	asu64(R1) = filename;
	R2 = tou64("Can't find #");
	mx_lib_error(asu64(R2), asu64(R1));
L4767:
	asu64(R1) = p;
	asu64(R2) = filename;
	asu64(R1) = mx_lib_readlibfile(asu64(R2), asu64(R1));
	plib = asu64(R1);
	asi64(R1) = libno;
	asu64(R2) = plib;
	R3 = 208;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = plib;
	R2 = R1;
	R3 = (u64)&mx_decls_libtable;
	asi64(R4) = libno;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	goto L4765;
L4765:
	return asu64(R1);
}

static void mx_lib_dosymbols(u64 lib) {
    u64 R1, R2, R3; 
	i64 ix;
	i64 libx;
	i64 dllx;
	u64 baseaddr;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 40;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4771;
L4769:
	asu64(R1) = lib;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_adddll(asu64(R1));
	i += 1; if (i <= av_1) goto L4769;
L4771:
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4774;
L4772:
	asu64(R1) = lib;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = mx_lib_addsymbol(asu64(R1));
	ix = asi64(R1);
	asi64(R1) = ix;
	asu64(R2) = lib;
	R3 = 176;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	*toi16p(((i64)R2+(i64)R3*2-2)) = asi16(R1);
	i += 1; if (i <= av_2) goto L4772;
L4774:
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = lib;
	R2 = 64;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4777;
L4775:
	asu64(R1) = lib;
	R2 = 120;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = mx_lib_addsymbol(asu64(R1));
	ix = asi64(R1);
	R1 = (u64)&mx_decls_symboldefined;
	asi64(R2) = ix;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4779;
	msysc_m$print_startcon();
	R1 = tou64("Dupl symbol:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = lib;
	R2 = 120;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L4776;
L4779:
	R1 = 1;
	R2 = (u64)&mx_decls_symboldefined;
	asi64(R3) = ix;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = lib;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4781;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4782;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4783;
	goto L4784;
L4781:
	asu64(R1) = lib;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	baseaddr = asu64(R1);
	goto L4780;
L4782:
	asu64(R1) = lib;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	baseaddr = asu64(R1);
	goto L4780;
L4783:
	asu64(R1) = lib;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	baseaddr = asu64(R1);
	goto L4780;
L4784:
	R1 = 0;
	baseaddr = asu64(R1);
L4780:
	asu64(R1) = baseaddr;
	asu64(R2) = lib;
	R3 = 136;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	R1 += (i64)R2;
	R2 = (u64)&mx_decls_symboladdress;
	asi64(R3) = ix;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = lib;
	R2 = 208;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mx_decls_symbollibindex;
	asi64(R3) = ix;
	*toi16p(((i64)R2+(i64)R3*2-2)) = asi16(R1);
L4776:
	i += 1; if (i <= av_3) goto L4775;
L4777:
	return;
}

static u64 mx_lib_readmxfile(u64 filename) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = filename;
	asu64(R1) = mlib_readfile(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4787;
	R1 = 0;
	goto L4785;
L4787:
	R1 = 13;
	asu64(R2) = p;
	asi64(R3) = mlib_rfsize;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L4785;
L4785:
	return asu64(R1);
}

static void mx_lib_adddll(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4791;
L4789:
	R1 = (u64)&mx_decls_dllnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4793;
	goto L4788;
L4793:
	i += 1; if (i <= mx_decls_ndlllibs) goto L4789;
L4791:
	asi64(R1) = mx_decls_ndlllibs;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L4795;
	R1 = tou64("");
	R2 = tou64("Too many DLLs");
	mx_lib_error(asu64(R2), asu64(R1));
L4795:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_dllnametable;
	R3 = (u64)&mx_decls_ndlllibs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4788:
	return;
}

static i64 mx_lib_addsymbol(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4799;
L4797:
	R1 = (u64)&mx_decls_symbolnametable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4801;
	asi64(R1) = i;
	goto L4796;
L4801:
	i += 1; if (i <= mx_decls_nsymbols) goto L4797;
L4799:
	asi64(R1) = mx_decls_nsymbols;
	R2 = 3000;
	if (asi64(R1) < asi64(R2)) goto L4803;
	R1 = tou64("");
	R2 = tou64("Too many Imports");
	mx_lib_error(asu64(R2), asu64(R1));
L4803:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_symbolnametable;
	R3 = (u64)&mx_decls_nsymbols;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = mx_decls_nsymbols;
	goto L4796;
L4796:
	return asi64(R1);
}

static void mx_lib_setspecialglobals(i64 cmdskip) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4807;
L4805:
	R1 = tou64("msys.$cmdskip");
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L4810;
	R1 = tou64("$cmdskip");
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4809;
L4810:
	asi64(R1) = cmdskip;
	R2 = (u64)&mx_decls_symboladdress;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	*tou8p(R2) = asu8(R1);
L4809:
	i += 1; if (i <= mx_decls_nsymbols) goto L4805;
L4807:
	return;
}

static void mx_lib_runprogram(u64 lib, i64 cmdskip) {
    u64 R1, R2, R3; 
	u64 fnptr;
	i64 libno;
	i64 i;
	asu64(R1) = lib;
	R2 = 208;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	libno = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nlibs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4814;
L4812:
	asi64(R1) = i;
	asi64(R2) = libno;
	if (asi64(R1) == asi64(R2)) goto L4816;
	R1 = (u64)&mx_decls_libinitdone;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L4816;
	R1 = (u64)&mx_decls_libtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_lib_calllibinit(asu64(R1));
L4816:
	i += 1; if (i <= mx_decls_nlibs) goto L4812;
L4814:
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4818;
	R1 = tou64("");
	R2 = tou64("No entry point found");
	mx_lib_error(asu64(R2), asu64(R1));
L4818:
	asi64(R1) = cmdskip;
	mx_lib_setspecialglobals(asi64(R1));
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnptr = asu64(R1);
	asu64(R1) = fnptr;
	((F20)R1)();
	R1 = 1;
	R2 = (u64)&mx_decls_libinitdone;
	asi64(R3) = libno;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mx_lib_calllibinit(u64 lib) {
    u64 R1, R2, R3, R4; 
	u64 fnptr;
	i64 libno;
	asu64(R1) = lib;
	R2 = 208;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	libno = asi64(R1);
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4821;
	asu64(R1) = lib;
	R2 = 200;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnptr = asu64(R1);
	asu64(R1) = fnptr;
	((F20)R1)();
L4821:
	R1 = 1;
	R2 = (u64)&mx_decls_libinitdone;
	asu64(R3) = lib;
	R4 = 208;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static u64 mx_lib_findsymbol(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mx_decls_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4825;
L4823:
	asu64(R1) = name;
	R2 = (u64)&mx_decls_symbolnametable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4827;
	R1 = (u64)&mx_decls_symboladdress;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L4822;
L4827:
	i += 1; if (i <= mx_decls_nsymbols) goto L4823;
L4825:
	R1 = 0;
	goto L4822;
L4822:
	return asu64(R1);
}

static u64 mx_lib_loadmx(u64 filename) {
    u64 R1, R2; 
	u64 plib;
	i64 newlib;
	u64 name;
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_convlcstring(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = filename;
	asu64(R2) = name;
	mx_lib_checknew(asu64(R2), asu64(R1));
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	newlib = asi64(R1);
	asi64(R1) = newlib;
	asu64(R2) = filename;
	asu64(R1) = mx_lib_loadlibfile(asu64(R2), asi64(R1));
	plib = asu64(R1);
	asu64(R1) = plib;
	mx_lib_loadimports(asu64(R1));
	asu64(R1) = plib;
	goto L4828;
L4828:
	return asu64(R1);
}

static u64 mx_lib_loadmemmcb(u64 filename, u64 p) {
    u64 R1, R2, R3; 
	u64 plib;
	i64 newlib;
	u64 name;
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_convlcstring(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = filename;
	asu64(R2) = name;
	mx_lib_checknew(asu64(R2), asu64(R1));
	asu64(R1) = name;
	asi64(R1) = mx_lib_mxaddlib(asu64(R1));
	newlib = asi64(R1);
	asu64(R1) = p;
	asu64(R2) = filename;
	asu64(R1) = mx_lib_readlibfile(asu64(R2), asu64(R1));
	plib = asu64(R1);
	asi64(R1) = newlib;
	asu64(R2) = plib;
	R3 = 208;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = plib;
	R2 = (u64)&mx_decls_libtable;
	asi64(R3) = newlib;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = plib;
	mx_lib_loadimports(asu64(R1));
	asu64(R1) = plib;
	goto L4829;
L4829:
	return asu64(R1);
}

static void mx_write_writemcx(u64 filename) {
    u64 R1, R2, R3; 
	i64 n;
	i64 ndlls;
	i64 nlibs;
	i64 i;
	R1 = 8;
	asi64(R2) = mc_decls_ss_zdatalen;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	mc_decls_ss_zdatalen = asi64(R1);
	R1 = 144;
	R2 = 8;
	asu64(R3) = mc_decls_ss_code;
	mx_write_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 8;
	asu64(R3) = mc_decls_ss_idata;
	mx_write_roundsegment(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1024;
	asu64(R1) = mc_genss_buffercreate(asi64(R1));
	mx_write_dest = asu64(R1);
	R1 = 441992013;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	mx_write_genbyte(asi64(R1));
	R1 = tou64("0.1234");
	mx_write_genstring(asu64(R1));
	mx_run_countsymbols();
	mx_write_writerelocs();
	R1 = 4;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mc_decls_ss_zdatalen;
	mx_write_genu32(asi64(R1));
	R1 = 2;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mc_decls_ss_code;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	mx_write_genu32(asi64(R1));
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = mc_decls_ss_code;
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	mx_write_genblock(asu64(R2), asi64(R1));
	R1 = 3;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mc_decls_ss_idata;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	R2 = R1;
	n = asi64(R2);
	mx_write_genu32(asi64(R1));
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = mc_decls_ss_idata;
	asu64(R2) = mc_genss_bufferelemptr(asu64(R3), asi64(R2));
	mx_write_genblock(asu64(R2), asi64(R1));
	R1 = 0;
	ndlls = asi64(R1);
	R1 = 0;
	nlibs = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4833;
L4831:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4835;
	R1 = (u64)&ndlls;
	(*toi64p(R1)) += 1;
L4835:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4831;
L4833:
	R1 = 6;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = ndlls;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4838;
L4836:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4840;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mx_write_genstring(asu64(R1));
L4840:
	i += 1; if (i <= pc_decls_nplibfiles) goto L4836;
L4838:
	mx_write_writesymbols();
	R1 = 13;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mx_write_dest;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mx_write_dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	asu64(R2) = mx_write_dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mx_write_writerelocs() {
    u64 R1, R2, R3; 
	u64 oldr;
	u64 newr;
	i64 n;
	i64 count;
	u64 d;
	u64 baseptr64;
	i64 i;
	R1 = 5;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mc_decls_ss_nidatarelocs;
	asi64(R2) = mc_decls_ss_ncoderelocs;
	asi64(R1) += asi64(R2);
	R2 = R1;
	n = asi64(R2);
	mx_write_genu32(asi64(R1));
	R1 = 0;
	count = asi64(R1);
	R1 = 1;
	i = asi64(R1);
L4842:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4846;
	asu64(R1) = mc_decls_ss_idatarelocs;
	goto L4845;
L4846:
	asu64(R1) = mc_decls_ss_coderelocs;
L4845:
	oldr = asu64(R1);
	goto L4850;
L4847:
	R1 = (u64)&count;
	(*toi64p(R1)) += 1;
	R1 = (u64)&newr;
	memset(R1, 0, 8);
	asu64(R1) = oldr;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4852;
	R1 = 2;
	goto L4851;
L4852:
	R1 = 1;
L4851:
	R2 = (u64)&newr;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mc_decls_ss_symboltable;
	asu64(R2) = oldr;
	R3 = 24;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4854;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4855;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4855;
	goto L4856;
L4854:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4858;
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 5;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4857;
L4858:
	R1 = tou64("rel32/rel not imported");
	mc_libmcl_axerror(asu64(R1));
L4857:
	goto L4853;
L4855:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4860;
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4862;
	R1 = 3;
	goto L4861;
L4862:
	R1 = 4;
L4861:
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	goto L4859;
L4860:
	asu64(R1) = oldr;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4864;
	R1 = 1;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4863;
L4864:
	R1 = 2;
	R2 = (u64)&newr;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4863:
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&newr;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4859:
	goto L4853;
L4856:
	R1 = tou64("reloc?");
	mc_libmcl_axerror(asu64(R1));
L4853:
	R1 = 8;
	R2 = (u64)&newr;
	mx_write_genblock(asu64(R2), asi64(R1));
	asu64(R1) = oldr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	oldr = asu64(R1);
L4850:
	asu64(R1) = oldr;
	if (asu64(R1)) goto L4847;
	i += 1; if (i <= 2) goto L4842;
	return;
}

static void mx_write_writesymbols() {
    u64 R1, R2; 
	u64 d;
	i64 n;
	u64 name;
	i64 i;
	R1 = 8;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymimports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4868;
L4866:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 116;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L4870;
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mx_write_genstring(asu64(R1));
L4870:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4866;
L4868:
	R1 = 9;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymexports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4873;
L4871:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L4875;
	asu64(R1) = d;
	R2 = 83;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4877;
	asu64(R1) = d;
	mx_write_entrypoint = asu64(R1);
L4877:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mx_write_genstring(asu64(R1));
L4875:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4871;
L4873:
	R1 = 10;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymexports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4880;
L4878:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L4882;
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mx_write_genbyte(asi64(R1));
L4882:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4878;
L4880:
	R1 = 11;
	mx_write_genbyte(asi64(R1));
	asi64(R1) = mx_decls_nsymexports;
	mx_write_genu32(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mc_decls_ss_nsymbols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4885;
L4883:
	asu64(R1) = mc_decls_ss_symboltable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 118;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L4887;
	asu64(R1) = d;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mx_write_genu32(asi64(R1));
L4887:
	i += 1; if (i <= mc_decls_ss_nsymbols) goto L4883;
L4885:
	R1 = 12;
	mx_write_genbyte(asi64(R1));
	asu64(R1) = mx_write_entrypoint;
	if (!asu64(R1)) goto L4889;
	asu64(R1) = mx_write_entrypoint;
	R2 = 76;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mx_write_genu32(asi64(R1));
	goto L4888;
L4889:
	R1 = 4294967295;
	mx_write_genu32(asi64(R1));
L4888:
	return;
}

static void mx_write_roundsegment(u64 p, i64 align, i64 value) {
    u64 R1, R2, R3; 
	i64 length;
	i64 newlength;
	i64 av_1;
	asu64(R1) = p;
	asi64(R1) = mc_genss_bufferlength(asu64(R1));
	length = asi64(R1);
	asi64(R1) = align;
	asi64(R2) = length;
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	newlength = asi64(R1);
	asi64(R1) = align;
	asu64(R2) = p;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = newlength;
	asi64(R2) = length;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4893;
L4891:
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	if (--asi64(av_1)) goto L4891;
L4893:
	return;
}

static void mx_write_genbyte(i64 x) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = mx_write_dest;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = x;
	asu64(R2) = mx_write_dest;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	return;
}

static void mx_write_genu32(i64 x) {
    u64 R1, R2, R3; 
	R1 = 4;
	asu64(R2) = mx_write_dest;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = x;
	asu64(R2) = mx_write_dest;
	R3 = 8;
	R2 += (i64)R3;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 4; asu64(R2) = asu64(R3);
	*tou32p(R2) = asu32(R1);
	return;
}

static void mx_write_genstring(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = s;
	mx_write_genblock(asu64(R2), asi64(R1));
	return;
}

static void mx_write_genblock(u64 p, i64 length) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	asu64(R2) = mx_write_dest;
	mc_genss_buffercheck(asu64(R2), asi64(R1));
	asi64(R1) = length;
	asu64(R2) = p;
	asu64(R3) = mx_write_dest;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	asu64(R2) = mx_write_dest;
	R3 = 8;
	R2 += (i64)R3;
	*tou64p(R2) += asu64(R1);
	return;
}

void cc_cli_main() {
    u64 R1, R2; 
	u64 file;
	pclpe_start();
	asi64(R1) = mwindows_os_clock();
	cc_cli_startclock = asi64(R1);
	asi64(R1) = cc_cli_startclock;
	pc_decls_pstartclock = asi64(R1);
	cc_cli_starttiming();
	cc_cli_initdata();
	cc_cli_getinputoptions();
	cc_cli_initsearchdirs();
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4900;
	cc_cli_showsearchdirs();
L4900:
	cc_cli_initlogfile();
	asi64(R1) = cc_cli_gettiming();
	cc_cli_inittime = asi64(R1);
	asu8(R1) = cc_cli_fverbose;
	if (!asu8(R1)) goto L4902;
	msysc_m$print_startcon();
	R1 = tou64("Compiling # to #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_cli_outfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4902:
	asu64(R1) = cc_decls_inputfile;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	pc_decls_$pmodulename = asu64(R1);
	cc_cli_do_loadmodule();
	cc_cli_do_preprocess();
	cc_cli_do_parsemodule();
	cc_cli_do_genpcl();
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4904;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4905;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4906;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4907;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4908;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4909;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4910;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4911;
	goto L4912;
L4904:
	pc_run_pcl_runpcl();
	goto L4903;
L4905:
	cc_cli_do_genmcl();
	goto L4903;
L4906:
	cc_cli_do_asm();
	goto L4903;
L4907:
	cc_cli_do_obj();
	goto L4903;
L4908:
	cc_cli_do_dll();
	goto L4903;
L4909:
	cc_cli_do_exe();
	goto L4903;
L4910:
	cc_cli_do_mx();
	goto L4903;
L4911:
	cc_cli_do_run();
	goto L4903;
L4912:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) < asi64(R2)) goto L4914;
	msysc_m$print_startcon();
	R1 = (u64)&cc_cli_passnames;
	asu8(R2) = cc_cli_cc_pass;
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("not ready");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4914:
L4903:
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L4916;
	msysc_m$print_startcon();
	R1 = tou64("Done.");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4916:
	asu8(R1) = cc_cli_fshowtiming;
	if (!asu8(R1)) goto L4918;
	cc_cli_showtiming();
L4918:
	cc_cli_closelogfile();
	R1 = 0;
	exit(R1);
	R1 = 0;
	exit(R1);
	return;
}

static void cc_cli_do_preprocess() {
    u64 R1, R2, R3; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L4921;
	asu8(R1) = cc_cli_fstdout;
	R1 = toi64(tou8(R1));
	asu64(R2) = cc_cli_outfile;
	asu64(R3) = cc_decls_inputfile;
	cc_lex_lex_preprocess_only(asu64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	exit(R1);
L4921:
	return;
}

static void cc_cli_do_loadmodule() {
    u64 R1, R2, R3; 
	u64 modulename;
	struct $B15 path;
	i64 status;
	i64 i;
	i64 flag;
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4924;
	msysc_m$print_startcon();
	R1 = tou64("Loading:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4924:
	cc_cli_starttiming();
	R1 = tou64("<dummy file>");
	R2 = (u64)&cc_decls_sourcefilenames;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("<dummy path>");
	R2 = (u64)&cc_decls_sourcefilepaths;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("<sourcefile0>");
	R2 = (u64)&cc_decls_sourcefiletext;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_decls_sourcefiletext;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilesizes;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 2;
	R2 = tou64("$prog");
	asu64(R2) = cc_lex_addnamestr(asu64(R2));
	R3 = 0;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	cc_decls_stprogram = asu64(R1);
	asu64(R1) = cc_decls_inputfile;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (asi64(R1)) goto L4926;
	asu64(R1) = cc_decls_inputfile;
	R2 = tou64("Can't load main module: #");
	cc_support_loaderror(asu64(R2), asu64(R1));
L4926:
	asu64(R1) = cc_decls_inputfile;
	asu64(R2) = cc_decls_inputfile;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	cc_decls_mainfileno = asi64(R1);
	asu64(R1) = cc_decls_inputfile;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	modulename = asu64(R1);
	R1 = 3;
	asu64(R2) = modulename;
	asu64(R2) = cc_lex_addnamestr(asu64(R2));
	asu64(R3) = cc_decls_stprogram;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	cc_decls_stmodule = asu64(R1);
	asu64(R1) = cc_decls_inputfile;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&path;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&path;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4928;
	R1 = (u64)&cc_decls_nsearchdirs;
	(*toi64p(R1)) += 1;
	asi64(R1) = cc_decls_nsearchdirs;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L4931;
L4929:
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = (u64)&cc_decls_searchdirs;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += -1; if (i >= 2) goto L4929;
L4931:
	R1 = (u64)&path;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_searchdirs;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4928:
	asi64(R1) = cc_cli_gettiming();
	cc_cli_loadtime = asi64(R1);
	return;
}

static void cc_cli_do_parsemodule() {
    u64 R1, R2; 
	i64 tt;
	cc_cli_starttiming();
	asi64(R1) = cc_parse_parsemodule();
	asi64(R1) = cc_cli_gettiming();
	R2 = R1;
	tt = asi64(R2);
	cc_cli_parsetime = asi64(R1);
	return;
}

static void cc_cli_do_genpcl() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) >= asi64(R2)) goto L4935;
	goto L4933;
L4935:
	cc_cli_starttiming();
	cc_genpcl_codegen_pcl();
	asi64(R1) = cc_cli_gettiming();
	cc_cli_pcltime = asi64(R1);
	asu8(R1) = pc_decls_fregoptim;
	if (asu8(R1)) goto L4938;
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L4937;
L4938:
	pc_reduce_pcl_reducetest();
L4937:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4940;
	asu64(R1) = cc_cli_outfile;
	asu64(R1) = pc_api_pcl_writepcl(asu64(R1));
L4940:
L4933:
	return;
}

static void cc_cli_do_genmcl() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) >= asi64(R2)) goto L4943;
	goto L4941;
L4943:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L4945;
	R1 = 16705;
	asu64(R2) = cc_cli_outfile;
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
L4945:
L4941:
	return;
}

static void cc_cli_do_asm() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) >= asi64(R2)) goto L4948;
	goto L4946;
L4948:
	R1 = 16705;
	asu64(R2) = cc_cli_outfile;
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
L4946:
	return;
}

static void cc_cli_do_obj() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4951;
	goto L4949;
L4951:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writeobj(asu64(R1));
L4949:
	return;
}

static void cc_cli_do_dll() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4954;
	goto L4952;
L4954:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writedll(asu64(R1));
L4952:
	return;
}

static void cc_cli_do_exe() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L4957;
	goto L4955;
L4957:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writeexe(asu64(R1));
L4955:
	return;
}

static void cc_cli_do_mx() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4960;
	goto L4958;
L4960:
	asu64(R1) = cc_cli_outfile;
	pc_api_pcl_writemx(asu64(R1));
L4958:
	return;
}

static void cc_cli_do_run() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L4963;
	goto L4961;
L4963:
	pc_api_pcl_exec();
L4961:
	return;
}

static void cc_cli_initlogfile() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_debugmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L4966;
	R1 = tou64("mcc.log");
	asi32(R1) = remove(asu64(R1));
	R1 = tou64("w");
	R2 = tou64("mcc.log");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	cc_decls_logdev = asu64(R1);
L4966:
	return;
}

static void cc_cli_closelogfile() {
    u64 R1, R2, R3; 
	struct $B5 str;
	i64 pos;
	asu8(R1) = cc_cli_debugmode;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L4969;
	goto L4967;
L4969:
	asu8(R1) = cc_cli_fshowmcl;
	if (!asu8(R1)) goto L4971;
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) < asi64(R2)) goto L4971;
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC ASM");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 16705;
	R2 = 0;
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4971:
	asu8(R1) = cc_cli_fshowpcl;
	if (!asu8(R1)) goto L4973;
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L4973;
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("!PROC PCL");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = 0;
	asu64(R1) = pc_api_pcl_writepcl(asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu8(R1) = cc_cli_fshowpst;
	if (!asu8(R1)) goto L4975;
	R1 = tou64("PSYMTAB");
	asu64(R1) = pc_api_pcl_writepst(asu64(R1));
	asu64(R1) = cc_decls_logdev;
	R2 = tou64("PSYMTAB");
	cc_lib_addtolog(asu64(R2), asu64(R1));
L4975:
L4973:
	cc_cli_showast();
	asu8(R1) = cc_cli_fshowst;
	if (!asu8(R1)) goto L4977;
	R1 = tou64("ST");
	cc_cli_showst(asu64(R1));
L4977:
	asu8(R1) = cc_cli_fshowstflat;
	if (!asu8(R1)) goto L4979;
	R1 = tou64("STFLAT");
	cc_cli_showstflat(asu64(R1));
L4979:
	asu8(R1) = cc_cli_fshowtypes;
	if (!asu8(R1)) goto L4981;
	asu64(R1) = cc_decls_logdev;
	cc_showdummy_printmodelist(asu64(R1));
L4981:
	asu64(R1) = cc_decls_logdev;
	asi32(R1) = fclose(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("PRESS KEY");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mwindows_os_getch();
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L4983;
	R1 = 0;
	exit(R1);
L4983:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("\\m\\scripts\\med.bat ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("mcc.log");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = tou64("cc.m");
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L4985;
	R1 = 0;
	R2 = 0;
	R3 = (u64)&str;
	asi64(R1) = mwindows_os_execwait(asu64(R3), asi64(R2), asu64(R1));
	goto L4984;
L4985:
	msysc_m$print_startcon();
	R1 = tou64("Diagnostic outputs written to");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("mcc.log");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4984:
L4967:
	return;
}

static void cc_cli_initdata() {
    u64 R1, R2, R3; 
	mlib_pcm_init();
	cc_lex_lexsetup();
	cc_lib_inittypetables();
	cc_lib_initcclib();
	R1 = 0;
	cc_decls_nlibfiles = asi64(R1);
	R1 = tou64("msvcrt");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("gdi32");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("user32");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = tou64("kernel32");
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_cli_cgetsourceinfo;
	pc_decls_igetmsourceinfo = asu64(R1);
	return;
}

static i64 cc_cli_cgetsourceinfo(i64 pos, u64 filename, u64 sourceline) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = pos;
	R3 = 24;
	R4 = 32;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = filename;
	*tou64p(R2) = asu64(R1);
	R1 = tou64("<line>");
	asu64(R2) = sourceline;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = pos;
	R2 = 0;
	R3 = 23;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	goto L4987;
L4987:
	return asi64(R1);
}

static void cc_cli_initsearchdirs() {
    u64 R1, R2, R3; 
	struct $B15 str1;
	struct $B15 str2;
	i64 i;
	R1 = tou64("");
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = tou64("c:/cx/headers/");
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mwindows_os_gethostname();
	asu64(R1) = mlib_extractpath(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nincludepaths;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4991;
L4989:
	R1 = (u64)&cc_decls_includepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L4993;
	R1 = (u64)&cc_decls_includepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&cc_decls_searchdirs;
	R3 = (u64)&cc_decls_nsearchdirs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L4993:
	i += 1; if (i <= cc_decls_nincludepaths) goto L4989;
L4991:
	return;
}

static void cc_cli_showsearchdirs() {
    u64 R1, R2; 
	i64 i;
	msysc_m$print_startcon();
	R1 = tou64("Include search paths:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu8(R1) = cc_cli_dointheaders;
	if (!asu8(R1)) goto L4996;
	msysc_m$print_startcon();
	R1 = tou64("0: Internal standard headers (disable with -ext)");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4996:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsearchdirs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4999;
L4997:
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L5001;
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L5000;
L5001:
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": .");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5000:
	i += 1; if (i <= cc_decls_nsearchdirs) goto L4997;
L4999:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showast() {
    u64 R1, R2; 
	asu8(R1) = cc_cli_fshowast;
	if (!asu8(R1)) goto L5004;
	R1 = tou64("PROC AST");
	asu64(R2) = cc_decls_logdev;
	cc_showdummy_printcode(asu64(R2), asu64(R1));
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5004:
	return;
}

static void cc_cli_showstflat(u64 caption) {
    u64 R1; 
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = cc_decls_logdev;
	cc_showdummy_printstflat(asu64(R1));
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showst(u64 caption) {
    u64 R1, R2, R3; 
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("PROC");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = cc_decls_stmodule;
	asu64(R3) = cc_decls_logdev;
	cc_showdummy_printst(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = cc_decls_logdev;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showfiles() {
    u64 R1, R2; 
	i64 i;
	msysc_m$print_startcon();
	R1 = tou64("Sourcefiles:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5010;
L5008:
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Size:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilesizes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= cc_decls_nsourcefiles) goto L5008;
L5010:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showtime(u64 caption, i64 t) {
    u64 R1, R2, R3; 
	msysc_m$print_startcon();
	R1 = tou64("# # ms # %");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("12jl");
	asu64(R2) = caption;
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("5");
	asi64(R2) = t;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("5.1jr");
	asi64(R2) = t;
	asr64(R2) = tor64(asi64(R2));
	asr64(R3) = 1.000000000000000000e+002;
	asr64(R2) *= asr64(R3);
	asi64(R3) = cc_cli_compiletime;
	asr64(R3) = tor64(asi64(R3));
	asr64(R2) /= asr64(R3);
	msysc_m$print_r64(asr64(R2), asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showtiming() {
    u64 R1, R2; 
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = cc_cli_startclock;
	asi64(R1) -= asi64(R2);
	cc_cli_compiletime = asi64(R1);
	asi64(R1) = cc_cli_inittime;
	R2 = tou64("Init:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = cc_cli_loadtime;
	R2 = tou64("Load:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = cc_cli_parsetime;
	R2 = tou64("Parse:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = cc_cli_pcltime;
	R2 = tou64("PCL:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_mcltime;
	R2 = tou64("MCL:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_sstime;
	R2 = tou64("SS:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	asi64(R1) = pc_decls_exetime;
	R2 = tou64("EXE:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	msysc_m$print_startcon();
	R1 = tou64("-----------------------------");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = cc_cli_compiletime;
	R2 = tou64("Total:");
	cc_cli_showtime(asu64(R2), asi64(R1));
	return;
}

static void cc_cli_getinputoptions() {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 j;
	i64 k;
	i64 paramno;
	i64 pmtype;
	i64 sw;
	i64 ncolons;
	u64 name;
	u64 value;
	u64 ext;
	i64 av_1;
	R1 = 1;
	paramno = asi64(R1);
	R1 = 0;
	ncolons = asi64(R1);
	asu8(R1) = pclpe_pc_userunpcl;
	if (!asu8(R1)) goto L5015;
	R1 = 6;
	cc_cli_cc_pass = asu8(R1);
	R1 = 0;
	cc_cli_fverbose = asu8(R1);
L5015:
	R1 = tou64("cs.exe");
	asu64(R2) = mwindows_os_gethostname();
	asu64(R2) = mlib_extractfile(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5017;
	R1 = 0;
	cc_cli_fverbose = asu8(R1);
	R1 = tou64("");
	R2 = 18;
	cc_cli_do_option(asi64(R2), asu64(R1));
L5017:
L5018:
	R1 = tou64(".c");
	R2 = (u64)&value;
	R3 = (u64)&name;
	R4 = (u64)&paramno;
	asi64(R1) = mlib_nextcmdparamnew(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	pmtype = asi64(R1);
	asi64(R1) = pmtype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5021;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5022;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5023;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5024;
	goto L5025;
L5021:
	asu64(R1) = name;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	sw = asi64(R1);
	R1 = 50;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5029;
L5026:
	R1 = (u64)&cc_cli_optionnames;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5031;
	asu64(R1) = value;
	asi64(R2) = sw;
	cc_cli_do_option(asi64(R2), asu64(R1));
	goto L5028;
L5031:
	sw += 1; if (sw <= av_1) goto L5026;
L5029:
	msysc_m$print_startcon();
	R1 = tou64("Unknown option:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L5028:
	goto L5020;
L5022:
	asu64(R1) = cc_decls_inputfile;
	if (!asu64(R1)) goto L5033;
	R1 = tou64("");
	R2 = tou64("One input file only");
	cc_support_loaderror(asu64(R2), asu64(R1));
L5033:
	asu64(R1) = name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_decls_inputfile = asu64(R1);
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5036;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5035;
L5036:
	asi64(R1) = paramno;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = msysc_$cmdskip;
	asi64(R1) += asi64(R2);
	cc_cli_cmdskip = asi64(R1);
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 6;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	cc_decls_pci_target = asu8(R1);
	goto L5019;
L5035:
	goto L5020;
L5023:
	asi64(R1) = cc_decls_nlibfiles;
	R2 = 200;
	if (asi64(R1) < asi64(R2)) goto L5038;
	R1 = tou64("");
	R2 = tou64("Too many lib files");
	cc_support_loaderror(asu64(R2), asu64(R1));
L5038:
	asu64(R1) = name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_libfiles;
	R3 = (u64)&cc_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L5020;
L5024:
	goto L5019;
	goto L5020;
L5025:
L5020:
	goto L5018;
L5019:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5040;
	R1 = 13;
	cc_cli_cc_pass = asu8(R1);
L5040:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5043;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5043;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5042;
L5043:
	R1 = 2;
	cc_cli_highmem = asu8(R1);
	goto L5041;
L5042:
	asu8(R1) = cc_cli_cc_pass;
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5045;
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L5044;
L5045:
	R1 = 0;
	cc_cli_highmem = asu8(R1);
L5044:
L5041:
	R1 = (u64)&cc_cli_extnames;
	asu8(R2) = cc_cli_cc_pass;
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	cc_cli_outext = asu64(R1);
	asu64(R1) = cc_decls_inputfile;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5047;
	asu8(R1) = cc_cli_fwriteheaders;
	if (asu8(R1)) goto L5047;
	cc_cli_showcaption();
	msysc_m$print_startcon();
	R1 = tou64("Usage:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("   prog[.c]          Compile prog.c to prog.exe");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("-r prog[.c]          Compile prog.c and run");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("-i prog[.c]          Compile prog.c and interpret");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("    ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("-help                Show all options");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L5047:
	asu8(R1) = cc_cli_fwriteheaders;
	if (!asu8(R1)) goto L5049;
	cc_headers_writeheaders();
	R1 = 20;
	exit(R1);
L5049:
	asu64(R1) = cc_cli_outfile;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5051;
	asu64(R1) = cc_cli_outext;
	asu64(R2) = cc_decls_inputfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_cli_outfile = asu64(R1);
L5051:
	asu8(R1) = cc_cli_fshortnames;
	R1 = toi64(tou8(R1));
	R2 = -1;
	asu8(R3) = cc_cli_highmem;
	R3 = toi64(tou8(R3));
	pc_api_pcl_setflags(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = cc_cli_cmdskip;
	pc_api_pcl_cmdskip(asi64(R2), asu64(R1));
	return;
}

static void cc_cli_do_option(i64 sw, u64 value) {
    u64 R1, R2, R3; 
	struct $B15 str;
	i64 length;
	u64 p;
	R1 = (u64)&cc_cli_optvars;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L5054;
	R1 = (u64)&cc_cli_optvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = sw;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5056;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L5056;
	R1 = 1;
	R2 = (u64)&cc_cli_debugmode;
	*tou8p(R2) |= asu8(R1);
L5056:
	asi64(R1) = sw;
	R2 = 26;
	if (asi64(R1) < asi64(R2)) goto L5058;
	R2 = 34;
	if (asi64(R1) > asi64(R2)) goto L5058;
	R1 = 2;
	R2 = (u64)&cc_cli_debugmode;
	*tou8p(R2) |= asu8(R1);
L5058:
	asi64(R1) = sw;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5060;
	asu64(R1) = cc_decls_inputfile;
	if (!asu64(R1)) goto L5060;
	R1 = tou64("");
	R2 = tou64("-RUNP OUT OF ORDER");
	cc_support_loaderror(asu64(R2), asu64(R1));
L5060:
	asi64(R1) = sw;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5063;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5062;
L5063:
	R1 = 1;
	cc_decls_pci_target = asu8(R1);
L5062:
	goto L5052;
L5054:
	asi64(R1) = sw;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L5065;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L5066;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L5066;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5067;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L5068;
	goto L5069;
L5065:
	asi64(R1) = cc_decls_nincludepaths;
	R2 = 20;
	if (asi64(R1) <= asi64(R2)) goto L5071;
	R1 = tou64("");
	R2 = tou64("Too many include paths");
	cc_support_loaderror(asu64(R2), asu64(R1));
L5071:
	asu64(R1) = value;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asu64(R1) = value;
	asi64(R2) = length;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L5073;
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L5073;
	goto L5074;
L5073:
	goto L5072;
L5074:
	asu64(R1) = value;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("/");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	value = asu64(R1);
L5072:
	asu64(R1) = value;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_includepaths;
	R3 = (u64)&cc_decls_nincludepaths;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L5064;
L5066:
	cc_cli_showhelp();
	goto L5064;
L5067:
	asu64(R1) = cc_cli_outext;
	asu64(R2) = value;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_cli_outfile = asu64(R1);
	goto L5064;
L5068:
	R1 = 0;
	R2 = R1;
	pc_decls_fpeephole = asu8(R2);
	pc_decls_fregoptim = asu8(R1);
	goto L5064;
L5069:
L5064:
L5052:
	return;
}

static void cc_cli_showincludepaths() {
    u64 R1, R2; 
	i64 i;
	msysc_m$print_startcon();
	R1 = tou64("Include paths");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_nincludepaths;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nincludepaths;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5078;
L5076:
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_includepaths;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= cc_decls_nincludepaths) goto L5076;
L5078:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_showhelp() {
    u64 R1; 
	cc_cli_showcaption();
	msysc_m$print_startcon();
	R1 = tou64("C Subset Compiler for 64-bit Windows\n\nNormal use:           Compiles prog.c to:\n\n    cc      prog      prog.exe (default)\n    cc -r   prog      in-memory native code then execute\n    cc -i   prog      in-memory IL then interpret\n\n    cc -exe prog      prog.exe\n    cc -dll prog      prog.dll\n    cc -obj prog      prog.obj\n    cc -a   prog      prog.asm\n    cc -n   prog      prog.nasm\n    cc -mx  prog      prog.mx\n    cc -p   prog      prog.pcl (textual IL)\n    cc -e   prog      prog.i   (preprocess only)\n\nOther options:\n\n    -incl:path        Add path to search for includes\n    -ext              Used std headers external to compiler\n    -opt              Optimise native code\n    -out:file         Name output file (extension can be added)\n    -rip              Use RIP address modes\n    -himem            Generate PIC code (automatic with -obj/-dll)\n    @file             Read files and options from a file\n    file.dll          Include one or more extra dynamic libs\n    -c                Same as -obj\n    -s                Same as -asm\n    -ei               Same as -e, but when result is interpreted\n\nNotes:\n\n    * Compiles single module only (use bcc driver program for multiple-modules)\n    * For -i and -r, options and any .dlls must appear before the C source file\n    * .c extension is optional on input file\n");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 23;
	exit(R1);
	return;
}

static void cc_cli_showextrainfo() {
    u64 R1; 
// PROC LOCAL STATICS GO HERE
	static u64 cc_cli_showextrainfo_infotext = (u64)"    The 'MCC' C Compiler comprises:\n\n    mcc.exe            Compiles to .asm files\n    aa.exe             Assembles .asm files to .obj files\n                       Assemblers and links .asm/.dll files to .exe\n    Standard headers   A minimal set inside mcc.exe\n    windows.h          As a standalone file\n\n    Input files:\n\n      prog             This is prog.c as the extension is optional\n      prog.c\n      lib.dll          Include .dll library when generating .exe\n      @file            Read parameters and optons from given file\n\n    Options:\n\n      -exe             (DEFAULT) Compile all modules to one .exe file via .asm files\n      -e               Preprocess each module to .i file\n      -s               Compile each module to .asm file\n      -c               Compile each module .obj via .asm\n\n      -out:file        Specify output file for -exe only\n\n    For .exe output, it will be named based on the first input file. Otherwise\n    use -out option\n\n    .obj files can be linked using gcc on Windows. This option is\n    needed to be able to generate .dll files. However, this will not\n    work on newer gcc versions because mcc's generated code is not position\n    independent, and will only work loaded in the low 2GB of address space.\n\n    Libraries msvcrt.dll, gdi32.dll, user32.dll and kernel32.dll are\n    automatically included as search libraries for imported functions.\n\n    Other kinds of binary libraries or files (.a, .lib, .obj etc) are not supported.\n\n    Omissions, Restrictions and Bugs (highlights only as there are dozens):\n\n      * No VLAs, compound literals, designated initialisers\n      * Restrictions on complexity of data initialisers\n";
	msysc_m$print_startcon();
	asu64(R1) = cc_cli_showextrainfo_infotext;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 24;
	exit(R1);
	return;
}

static void cc_cli_showcaption() {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("CC C Compiler");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("25-Sep-2025");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("18:52:41");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_cli_starttiming() {
    u64 R1; 
	asi64(R1) = mwindows_os_clock();
	cc_cli_ttt = asi64(R1);
	return;
}

static i64 cc_cli_gettiming() {
    u64 R1, R2; 
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = cc_cli_ttt;
	asi64(R1) -= asi64(R2);
	goto L5083;
L5083:
	return asi64(R1);
}

static void cc_lex_lex_preprocess_only(u64 infile, u64 outfile, i64 toconsole) {
    u64 R1, R2, R3; 
	u64 psource;
	i64 ntokens;
	i64 nlines;
	i64 fileno;
	i64 size;
	i64 length;
	i64 nchars;
	i64 t;
	i64 hashtot;
	i64 symtot;
	r64 tsecs;
	u64 f;
// PROC LOCAL STATICS GO HERE
	static u64 cc_lex_lex_preprocess_only_dest = (u64)&cc_lex_lex_preprocess_only_sbuffer;
	R1 = 1;
	cc_lex_dowhitespace = asi64(R1);
	asu64(R1) = infile;
	asu64(R2) = infile;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	fileno = asi64(R1);
	R1 = (u64)&cc_decls_sourcefiletext;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	psource = asu64(R1);
	R1 = (u64)&cc_decls_sourcefilesizes;
	asi64(R2) = fileno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	size = asi64(R1);
	R1 = 0;
	R2 = R1;
	ntokens = asi64(R2);
	nlines = asi64(R1);
	R1 = 0;
	R2 = R1;
	symtot = asi64(R2);
	hashtot = asi64(R1);
	asi64(R1) = mwindows_os_clock();
	t = asi64(R1);
	asu64(R1) = cc_lex_lex_preprocess_only_dest;
	cc_lex_destcopy = asu64(R1);
	asu64(R1) = cc_lex_lex_preprocess_only_dest;
	mlib_gs_init(asu64(R1));
	asu64(R1) = psource;
	cc_lex_lxsptr = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	cc_lex_lxstart = asu64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	cc_lex_setfileno(asi64(R1));
	R1 = 0;
	cc_lex_ifcondlevel = asi64(R1);
	R1 = 1;
	R2 = tou64("mcc.h");
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5085:
	cc_lex_lexm();
	R1 = (u64)&ntokens;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = cc_lex_lex_preprocess_only_dest;
	R3 = (u64)&cc_decls_nextlx;
	cc_lex_emittoken(asu64(R3), asu64(R2), asi64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L5085;
	asi64(R1) = cc_lex_ifcondlevel;
	if (!asi64(R1)) goto L5089;
	R1 = tou64("#endif missing");
	cc_lex_lxerror(asu64(R1));
L5089:
	R1 = (u64)&cc_lex_showtokens;
	if (!asu64(R1)) goto L5091;
	asi64(R1) = toconsole;
	if (!asi64(R1)) goto L5093;
	R1 = 0;
	asu64(R2) = cc_lex_lex_preprocess_only_dest;
	mlib_gs_println(asu64(R2), asu64(R1));
	goto L5092;
L5093:
	R1 = tou64("wb");
	asu64(R2) = outfile;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = cc_lex_lex_preprocess_only_dest;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L5092:
L5091:
	return;
}

static void cc_lex_lexreadtoken() {
    u64 R1, R2, R3, R4, R5; 
	u64 c;
	u64 csum;
	u64 hsum;
	u64 dodir;
	u64 p;
	u64 ss;
	u64 searchstr;
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 23;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5096;
L5095:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L5096:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L5095;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5095;
L5098:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L5235;
	case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 11: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 96: case 127: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 142: case 143: case 144: case 145: case 146: case 147: case 148: case 149: case 150: case 151: case 152: case 153: case 154: case 155: case 156: case 157: case 158: case 159: case 160: case 161: case 162: case 163: case 164: case 165: case 166: case 167: case 168: case 169: case 170: case 171: case 172: case 173: case 174: case 175: case 176: case 177: case 178: case 179: case 180: case 181: case 182: case 183: case 184: case 185: case 186: case 187: case 188: case 189: case 190: case 191: case 192: case 193: case 194: case 195: case 196: case 197: case 198: case 199: case 200: case 201: case 202: case 203: case 204: case 205: case 206: case 207: case 208: case 209: case 210: case 211: case 212: case 213: case 214: case 215: case 216: case 217: case 218: case 219: case 220: case 221: case 222: case 223: case 224: case 225: case 226: case 227: case 228: case 229: case 230: case 231: case 232: case 233: case 234: case 235: case 236: case 237: case 238: goto L5101;
	case 9: case 32: goto L5220;
	case 10: goto L5221;
	case 12: goto L5239;
	case 13: goto L5229;
	case 33: goto L5230;
	case 34: goto L5219;
	case 35: goto L5128;
	case 36: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: goto L5102;
	case 37: goto L5192;
	case 38: goto L5213;
	case 39: goto L5218;
	case 40: goto L5158;
	case 41: goto L5159;
	case 42: goto L5183;
	case 43: goto L5172;
	case 44: goto L5152;
	case 45: goto L5177;
	case 46: goto L5144;
	case 47: goto L5186;
	case 48: goto L5119;
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L5115;
	case 58: goto L5154;
	case 59: goto L5153;
	case 60: goto L5199;
	case 61: goto L5195;
	case 62: goto L5206;
	case 63: goto L5170;
	case 64: goto L5234;
	case 91: goto L5160;
	case 92: goto L5132;
	case 93: goto L5161;
	case 94: goto L5167;
	case 123: goto L5142;
	case 124: goto L5162;
	case 125: goto L5143;
	case 126: goto L5171;
	case 239: goto L5240;
	default: goto L5101;
    };
// SWITCH
L5102:
// cc_lex.lexreadtoken.doname:
L5103:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_lxsvalue = asu64(R1);
	asu64(R1) = cc_lex_lxsvalue;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	hsum = asu64(R1);
	goto L5105;
L5104:
	asu64(R1) = hsum;
	R2 = 4;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asu64(R1) -= asu64(R2);
	asu64(R2) = c;
	asu64(R1) += asu64(R2);
	hsum = asu64(R1);
L5105:
	R1 = (u64)&cc_lex_alphamap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	R3 = R2;
	c = asu64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5104;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 67;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = cc_lex_lxsvalue;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = c;
	R2 = 39;
	if (asu64(R1) == asu64(R2)) goto L5108;
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L5108;
	goto L5109;
L5108:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5111;
	asu64(R1) = cc_lex_lxsvalue;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 108;
	if (asu64(R1) == asu64(R2)) goto L5113;
	R2 = 76;
	if (asu64(R1) == asu64(R2)) goto L5113;
	R2 = 117;
	if (asu64(R1) == asu64(R2)) goto L5113;
	R2 = 85;
	if (asu64(R1) == asu64(R2)) goto L5113;
	goto L5114;
L5113:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 1;
	asu64(R2) = c;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L5094;
	goto L5112;
L5114:
L5112:
L5111:
	goto L5107;
L5109:
L5107:
	asu64(R1) = hsum;
	R2 = 5;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	cc_lex_lxhashvalue = asi64(R1);
	asi64(R1) = cc_lex_lookup();
	goto L5094;
	goto L5098;
L5115:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L5117;
	R2 = 41;
	if (asu64(R1) == asu64(R2)) goto L5117;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L5117;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L5117;
	R2 = 59;
	if (asu64(R1) == asu64(R2)) goto L5117;
	goto L5118;
L5117:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	goto L5116;
L5118:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_readdecimal(asu64(R1));
L5116:
	goto L5094;
	goto L5098;
L5119:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 10: case 13: case 32: case 38: case 41: case 44: case 58: case 59: case 61: case 63: case 93: case 125: goto L5127;
	case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 33: case 34: case 35: case 36: case 37: case 39: case 40: case 42: case 43: case 45: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 60: case 62: case 64: case 65: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 89: case 90: case 91: case 92: case 94: case 95: case 96: case 97: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 118: case 119: case 121: case 122: case 123: case 124: goto L5122;
	case 46: goto L5125;
	case 66: case 98: goto L5124;
	case 76: case 85: case 108: case 117: goto L5126;
	case 88: case 120: goto L5123;
	default: goto L5122;
    };
// SWITCH
L5123:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	R2 = 2;
	R1 -= (i64)R2;
	cc_lex_readhex(asu64(R1));
	goto L5094;
	goto L5120;
L5124:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	R2 = 2;
	R1 -= (i64)R2;
	cc_lex_readbinary(asu64(R1));
	goto L5094;
	goto L5120;
L5125:
	R1 = 10;
	R2 = 1;
	asu64(R3) = cc_lex_lxsptr;
	R4 = 1;
	R3 -= (i64)R4;
	asu64(R4) = cc_lex_lxsptr;
	R5 = 1;
	R4 -= (i64)R5;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5094;
	goto L5120;
L5126:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_readdecimal(asu64(R1));
	goto L5094;
	goto L5120;
L5127:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	goto L5094;
	goto L5120;
L5122:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	cc_lex_readoctal(asu64(R1));
	goto L5094;
L5120:
	goto L5098;
L5128:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L5130;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5129;
L5130:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) != asu64(R2)) goto L5131;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 7;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5129;
L5131:
	R1 = 5;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
L5129:
	goto L5098;
L5132:
L5133:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L5135;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L5135;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L5136;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L5136;
	goto L5137;
L5135:
	goto L5134;
	goto L5133;
L5136:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L5133;
L5137:
	R1 = 22;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5133;
L5134:
	R1 = 32;
	asu64(R2) = cc_lex_lxsptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L5139;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L5140;
	goto L5141;
L5139:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 32;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L5138;
L5140:
	R1 = 32;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L5138;
L5141:
L5138:
	goto L5098;
L5142:
	R1 = 17;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5098;
L5143:
	R1 = 18;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5098;
L5144:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 46: goto L5148;
	case 47: goto L5147;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L5151;
	default: goto L5147;
    };
// SWITCH
L5148:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L5150;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 21;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5149;
L5150:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 2;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
L5149:
	goto L5094;
	goto L5145;
L5151:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 10;
	R2 = 0;
	asu64(R3) = cc_lex_lxsptr;
	asu64(R4) = cc_lex_lxsptr;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5094;
	goto L5145;
L5147:
	R1 = 2;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
L5145:
	goto L5098;
L5152:
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5098;
L5153:
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5098;
L5154:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5156;
	goto L5157;
L5156:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5155;
L5157:
	R1 = 10;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5155:
	goto L5094;
	goto L5098;
L5158:
	R1 = 13;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5098;
L5159:
	R1 = 14;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5098;
L5160:
	R1 = 15;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5098;
L5161:
	R1 = 16;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5098;
L5162:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 124;
	if (asu64(R1) == asu64(R2)) goto L5164;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5165;
	goto L5166;
L5164:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 31;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5163;
L5165:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 51;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5163;
L5166:
	R1 = 28;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5163:
	goto L5094;
	goto L5098;
L5167:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L5169;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 53;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5168;
L5169:
	R1 = 30;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5168:
	goto L5094;
	goto L5098;
L5170:
	R1 = 19;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5098;
L5171:
	R1 = 35;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5098;
L5172:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L5174;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5175;
	goto L5176;
L5174:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 37;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5173;
L5175:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 46;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5173;
L5176:
	R1 = 23;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5173:
	goto L5094;
	goto L5098;
L5177:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L5179;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L5180;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5181;
	goto L5182;
L5179:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 38;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5178;
L5180:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5178;
L5181:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 47;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5178;
L5182:
	R1 = 24;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5178:
	goto L5094;
	goto L5098;
L5183:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L5185;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 48;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5184;
L5185:
	R1 = 25;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5184:
	goto L5094;
	goto L5098;
L5186:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L5188;
	R2 = 42;
	if (asu64(R1) == asu64(R2)) goto L5189;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5190;
	goto L5191;
L5188:
	cc_lex_readlinecomment();
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5094;
	goto L5187;
L5189:
	cc_lex_readblockcomment();
	goto L5187;
L5190:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 49;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5187;
L5191:
	R1 = 26;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
L5187:
	goto L5098;
L5192:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L5194;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 50;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5193;
L5194:
	R1 = 27;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5193:
	goto L5094;
	goto L5098;
L5195:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5197;
	goto L5198;
L5197:
	R1 = 40;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L5196;
L5198:
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5196:
	goto L5094;
	goto L5098;
L5199:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5201;
	R2 = 60;
	if (asu64(R1) == asu64(R2)) goto L5202;
	goto L5203;
L5201:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 43;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5200;
L5202:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L5205;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 54;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5204;
L5205:
	R1 = 33;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5204:
	goto L5200;
L5203:
	R1 = 42;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5200:
	goto L5094;
	goto L5098;
L5206:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5208;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L5209;
	goto L5210;
L5208:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 44;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5207;
L5209:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L5212;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 55;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5211;
L5212:
	R1 = 34;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5211:
	goto L5207;
L5210:
	R1 = 45;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5207:
	goto L5094;
	goto L5098;
L5213:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 38;
	if (asu64(R1) == asu64(R2)) goto L5215;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5216;
	goto L5217;
L5215:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 32;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5214;
L5216:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 52;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5214;
L5217:
	R1 = 29;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5214:
	goto L5094;
	goto L5098;
L5218:
	R1 = 0;
	R2 = 39;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L5094;
	goto L5098;
L5219:
	R1 = 0;
	R2 = 34;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L5094;
	goto L5098;
L5220:
	goto L5098;
L5221:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_lex_dowhitespace;
	if (!asi64(R1)) goto L5223;
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5224:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 9: case 32: goto L5228;
	case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: goto L5227;
	default: goto L5227;
    };
// SWITCH
L5228:
	goto L5224;
L5227:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L5225;
	goto L5224;
L5225:
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5223:
	goto L5094;
	goto L5098;
L5229:
	goto L5098;
L5230:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L5232;
	goto L5233;
L5232:
	R1 = 41;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L5231;
L5233:
	R1 = 36;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5231:
	goto L5094;
	goto L5098;
L5234:
	msysc_m$print_startcon();
	R1 = tou64("@ SEEN");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_lex_lx_stackindex;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L5098;
L5235:
// cc_lex.lexreadtoken.doeof:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asi64(R1) = cc_lex_lx_stackindex;
	if (!asi64(R1)) goto L5238;
	cc_lex_unstacksourcefile();
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5237;
L5238:
	R1 = 57;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5237:
	goto L5094;
	goto L5098;
L5239:
	goto L5098;
L5240:
	R1 = 2;
	R2 = (u64)&cc_lex_lxsptr;
	*tou64p(R2) += asu64(R1);
	goto L5098;
L5101:
	R1 = 128;
	asu64(R2) = cc_lex_lxsptr;
	R3 = 1;
	R2 -= (i64)R3;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L5242;
	R2 = 255;
	if (asi64(R1) > asi64(R2)) goto L5242;
	goto L5103;
L5242:
	msysc_m$print_startcon();
	R1 = tou64("ERROR CHAR");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = cc_lex_lxsptr;
	R3 = 1;
	R2 -= (i64)R3;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = cc_lex_lx_stackindex;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("ERROR CHAR");
	cc_lex_lxerror(asu64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5094;
	goto L5098;
L5094:
	return;
}

static void cc_lex_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base) {
    u64 R1, R2, R3, R4; 
	u64 fractstart;
	i64 fractlen;
	i64 expon;
	i64 i;
	i64 c;
	i64 badexpon;
	i64 n;
	i64 adj;
	r64 basex;
	r64 x;
	r64 expbase;
	r64 f;
	r64 y;
	r64 y2;
	r64 g;
	i64 aa;
	i64 cc;
	i64 pref;
	struct $B31 realstr;
	u64 rs;
	struct $B18 expstr;
	u64 xx1;
	u64 xx2;
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5245;
	asi64(R1) = base;
	asi64(R2) = intlen;
	asu64(R3) = intstart;
	asu64(R4) = pstart;
	cc_lex_old_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5243;
L5245:
	R1 = 0;
	fractstart = asu64(R1);
	R1 = 0;
	fractlen = asi64(R1);
	R1 = 0;
	expon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L5247;
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	fractstart = asu64(R1);
	asi64(R1) = base;
	asu64(R1) = cc_lex_scannumber(asi64(R1));
	asu64(R2) = fractstart;
	asi64(R1) -= asi64(R2);
	fractlen = asi64(R1);
L5247:
	R1 = 0;
	badexpon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 101;
	if (asu64(R1) == asu64(R2)) goto L5249;
	R2 = 69;
	if (asu64(R1) == asu64(R2)) goto L5249;
	R2 = 112;
	if (asu64(R1) == asu64(R2)) goto L5250;
	R2 = 80;
	if (asu64(R1) == asu64(R2)) goto L5250;
	goto L5251;
L5249:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L5253;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L5253:
	goto L5248;
L5250:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L5255;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L5255:
	goto L5248;
L5251:
L5248:
	asi64(R1) = badexpon;
	if (!asi64(R1)) goto L5257;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L5243;
L5257:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 102;
	if (asu64(R1) == asu64(R2)) goto L5259;
	R2 = 70;
	if (asu64(R1) == asu64(R2)) goto L5259;
	R2 = 108;
	if (asu64(R1) == asu64(R2)) goto L5259;
	R2 = 76;
	if (asu64(R1) == asu64(R2)) goto L5259;
	goto L5260;
L5259:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L5258;
L5260:
	R1 = (u64)&cc_lex_alphamap;
	asu64(R2) = cc_lex_lxsptr;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5262;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L5243;
L5262:
L5258:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L5264;
	R1 = 48;
	R2 = (u64)&realstr;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 120;
	R2 = (u64)&realstr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&realstr;
	R2 = 2;
	R1 += (i64)R2;
	rs = asu64(R1);
	R1 = 2;
	pref = asi64(R1);
	goto L5263;
L5264:
	R1 = (u64)&realstr;
	R2 = 0;
	R1 += (i64)R2;
	rs = asu64(R1);
	R1 = 0;
	pref = asi64(R1);
L5263:
	asi64(R1) = intlen;
	asi64(R2) = fractlen;
	asi64(R1) += asi64(R2);
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L5266;
	R1 = tou64("Real too long");
	cc_lex_lxerror(asu64(R1));
L5266:
	asi64(R1) = intlen;
	if (!asi64(R1)) goto L5268;
	asi64(R1) = intlen;
	asu64(R2) = intstart;
	asu64(R3) = rs;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L5268:
	asi64(R1) = fractlen;
	if (!asi64(R1)) goto L5270;
	asi64(R1) = fractlen;
	asu64(R2) = fractstart;
	asu64(R3) = rs;
	asi64(R4) = intlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L5270:
	asi64(R1) = base;
	asr64(R1) = tor64(asi64(R1));
	R2 = R1;
	basex = asr64(R2);
	expbase = asr64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5272;
	asi64(R1) = fractlen;
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	goto L5271;
L5272:
	asi64(R1) = fractlen;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	asr64(R1) = 2.000000000000000000e+000;
	expbase = asr64(R1);
L5271:
	R1 = 0;
	R2 = (u64)&realstr;
	asi64(R3) = pref;
	asi64(R4) = intlen;
	asi64(R3) += asi64(R4);
	asi64(R4) = fractlen;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&expstr;
	msysc_m$print_startstr(asu64(R1));
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5274;
	R1 = tou64("e");
	goto L5273;
L5274:
	R1 = tou64("p");
L5273:
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asi64(R1) = expon;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&expstr;
	R2 = (u64)&realstr;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5276;
	R1 = tou64("Non-base-10 floats temporarily unavailable");
	cc_lex_lxerror(asu64(R1));
L5276:
	R1 = 0;
	R2 = (u64)&realstr;
	asr64(R1) = strtod(asu64(R2), asu64(R1));
	x = asr64(R1);
	R1 = 60;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asu64(R1) = intstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = intstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5243:
	return;
}

static i64 cc_lex_readexponent(u64 badexpon) {
    u64 R1, R2; 
	u64 numstart;
	i64 length;
	i64 neg;
	i64 c;
	i64 a;
	i64 av_1;
	R1 = 0;
	neg = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L5279;
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L5280;
	goto L5281;
L5279:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L5278;
L5280:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 1;
	neg = asi64(R1);
	goto L5278;
L5281:
L5278:
	asu64(R1) = cc_lex_lxsptr;
	numstart = asu64(R1);
	R1 = 10;
	asu64(R1) = cc_lex_scannumber(asi64(R1));
	asu64(R2) = numstart;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5283;
	R1 = 1;
	asu64(R2) = badexpon;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	goto L5277;
L5283:
	R1 = 0;
	a = asi64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5286;
L5284:
	R1 = (u64)&numstart;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = a;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	a = asi64(R1);
	if (--asi64(av_1)) goto L5284;
L5286:
	asi64(R1) = neg;
	if (!asi64(R1)) goto L5288;
	asi64(R1) = a;
	asi64(R1) = -asi64(R1);
	goto L5287;
L5288:
	asi64(R1) = a;
L5287:
	goto L5277;
L5277:
	return asi64(R1);
}

static void cc_lex_lxerror(u64 mess) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	R1 = tou64("\nLex error");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = cc_lex_getfileno();
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("Line:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 11;
	exit(R1);
	return;
}

static void cc_lex_printsymbol(u64 lp) {
    u64 R1, R2, R3, R4; struct $B18 R1_B18; 
	struct $B18 l;
	asu64(R1) = lp;
	(R1_B18) = *(struct $B18*)(R1);
	l = (R1_B18);
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("%-18s");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = (u64)&l;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5292;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L5293;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L5294;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L5295;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L5296;
	goto L5297;
L5292:
	R1 = 0;
	R2 = (u64)&l;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 106;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = (u64)&l;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	goto L5291;
L5293:
	msysc_m$print_startcon();
	R1 = (u64)&l;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = lp;
	cc_lex_shownumberstr(asu64(R2), asu64(R1));
	goto L5291;
L5294:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = lp;
	cc_lex_shownumberstr(asu64(R2), asu64(R1));
	goto L5291;
L5295:
	msysc_m$print_startcon();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&l;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("\"");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L5291;
L5296:
	msysc_m$print_startcon();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&l;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&l;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("'");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L5291;
L5297:
	R1 = (u64)&l;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5299;
	msysc_m$print_startcon();
	R1 = tou64("#");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&l;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L5299:
L5291:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_lex_lexsetup() {
    u64 R1, R2, R3; 
	i64 i;
	cc_lex_inithashtable();
	cc_lex_fillhashtable();
	R1 = 0;
	i = asi64(R1);
L5301:
	asi64(R1) = i;
	switch (asi64(R1)) {
	case 36: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 142: case 143: case 144: case 145: case 146: case 147: case 148: case 149: case 150: case 151: case 152: case 153: case 154: case 155: case 156: case 157: case 158: case 159: case 160: case 161: case 162: case 163: case 164: case 165: case 166: case 167: case 168: case 169: case 170: case 171: case 172: case 173: case 174: case 175: case 176: case 177: case 178: case 179: case 180: case 181: case 182: case 183: case 184: case 185: case 186: case 187: case 188: case 189: case 190: case 191: case 192: case 193: case 194: case 195: case 196: case 197: case 198: case 199: case 200: case 201: case 202: case 203: case 204: case 205: case 206: case 207: case 208: case 209: case 210: case 211: case 212: case 213: case 214: case 215: case 216: case 217: case 218: case 219: case 220: case 221: case 222: case 223: case 224: case 225: case 226: case 227: case 228: case 229: case 230: case 231: case 232: case 233: case 234: case 235: case 236: case 237: case 238: case 239: case 240: case 241: case 242: case 243: case 244: case 245: case 246: case 247: case 248: case 249: case 250: case 251: case 252: case 253: case 254: case 255: goto L5307;
	case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 91: case 92: case 93: case 94: case 96: case 123: case 124: case 125: case 126: case 127: goto L5306;
	default: goto L5306;
    };
// SWITCH
L5307:
	R1 = 1;
	R2 = (u64)&cc_lex_alphamap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5304;
L5306:
L5304:
	asi64(R1) = i;
	switch (asi64(R1)) {
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L5311;
	default: goto L5310;
    };
// SWITCH
L5311:
	R1 = 1;
	R2 = (u64)&cc_lex_digitmap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5308;
L5310:
L5308:
	R1 = 1;
	R2 = (u64)&cc_lex_commentmap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&cc_lex_linecommentmap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_spacemap;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= 255) goto L5301;
	R1 = 0;
	R2 = (u64)&cc_lex_commentmap;
	R3 = 42;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_commentmap;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_commentmap;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_linecommentmap;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_linecommentmap;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_lex_linecommentmap;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&cc_lex_spacemap;
	R3 = 32;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&cc_lex_spacemap;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 56;
	R2 = (u64)&cc_lex_normaltkx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	cc_lex_npastedtokens = asi64(R1);
	return;
}

static void cc_lex_printstrn(u64 s, i64 length, u64 f) {
    u64 R1, R2; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L5314;
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5316;
	msysc_m$print_startcon();
	R1 = tou64("v");
	asi64(R2) = length;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".*");
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	goto L5315;
L5316:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("v");
	asi64(R2) = length;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".*");
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
L5315:
L5314:
	return;
}

static u64 cc_lex_scannumber(i64 base) {
    u64 R1, R2, R3; 
	u64 dest;
	i64 c;
	asu64(R1) = cc_lex_lxsptr;
	dest = asu64(R1);
L5318:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 39: case 95: case 96: goto L5328;
	case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: goto L5321;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L5322;
	case 65: case 66: case 67: case 68: case 69: case 70: case 97: case 98: case 99: case 100: case 101: case 102: goto L5325;
	default: goto L5321;
    };
// SWITCH
L5322:
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 48;
	asi64(R3) = base;
	asi64(R2) += asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L5324;
	R1 = tou64("Digit out of range");
	cc_lex_lxerror(asu64(R1));
L5324:
	goto L5318;
L5325:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L5327;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L5326;
L5327:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L5319;
L5326:
	goto L5318;
L5328:
	goto L5318;
L5321:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L5319;
	goto L5318;
L5319:
	asu64(R1) = dest;
	goto L5317;
L5317:
	return asu64(R1);
}

static i64 cc_lex_lookup() {
    u64 R1, R2, R3, R4; 
	i64 j;
	i64 wrapped;
	i64 length;
// cc_lex.lookup.retry:
L5330:
	asi64(R1) = cc_lex_lxhashvalue;
	asi64(R2) = cc_decls_hstmask;
	asi64(R1) &= asi64(R2);
	j = asi64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L5331:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	length = asi64(R1);
	asi64(R1) = length;
	if (asi64(R1)) goto L5334;
	goto L5332;
L5334:
	asi64(R1) = length;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) != asi64(R2)) goto L5336;
	asi64(R1) = length;
	asu64(R2) = cc_lex_lxsvalue;
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5338;
	R1 = 1;
	goto L5329;
L5338:
L5336:
	R1 = (u64)&j;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = cc_decls_hstsize;
	if (asi64(R1) < asi64(R2)) goto L5340;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L5342;
	R1 = tou64("HASHTABLE FULL");
	mlib_abortprogram(asu64(R1));
L5342:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	j = asi64(R1);
L5340:
	goto L5331;
L5332:
	asi64(R1) = cc_lex_nhstsymbols;
	asi64(R2) = cc_lex_hstthreshold;
	if (asi64(R1) < asi64(R2)) goto L5344;
	cc_lex_newhashtable();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = cc_lex_lxsvalue;
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	cc_lex_lxhashvalue = asi64(R1);
	goto L5330;
L5344:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = cc_lex_lxsvalue;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 106;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lex_nhstsymbols;
	(*toi64p(R1)) += 1;
	R1 = 0;
	goto L5329;
L5329:
	return asi64(R1);
}

static u64 cc_lex_gethashvalue(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 c;
	u64 hsum;
	i64 av_1;
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L5347;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L5347:
	R1 = 0;
	hsum = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5350;
L5348:
	asu64(R1) = hsum;
	R2 = 4;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asu64(R1) -= asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	asu64(R1) += asu64(R2);
	hsum = asu64(R1);
	if (--asi64(av_1)) goto L5348;
L5350:
	asu64(R1) = hsum;
	R2 = 5;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = hsum;
	asu64(R1) -= asu64(R2);
	goto L5345;
L5345:
	return asu64(R1);
}

static void cc_lex_inithashtable() {
    u64 R1, R2, R3; 
	i64 i;
	asi64(R1) = cc_decls_hstsize;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	cc_decls_hashtable = asu64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	cc_decls_hstmask = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L5354;
L5352:
	R1 = 128;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= cc_decls_hstmask) goto L5352;
L5354:
	R1 = 0;
	cc_lex_nhstsymbols = asi64(R1);
	R1 = 6;
	asi64(R2) = cc_decls_hstsize;
	asi64(R1) *= asi64(R2);
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	cc_lex_hstthreshold = asi64(R1);
	return;
}

static void cc_lex_fillhashtable() {
    u64 R1, R2, R3; 
	i64 i;
	i64 av_1;
	R1 = 1;
	i = asi64(R1);
	R1 = 63;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5358;
L5356:
	R1 = (u64)&cc_tables_stnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	cc_lex_lxsvalue = asu64(R1);
	R1 = (u64)&cc_tables_stsymbols;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	R2 = 68;
	if (asi64(R1) != asi64(R2)) goto L5360;
	asu64(R1) = cc_lex_lxsvalue;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	cc_lex_lxsvalue = asu64(R1);
L5360:
	asu64(R1) = cc_lex_lxsvalue;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = cc_lex_lxsvalue;
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	cc_lex_lxhashvalue = asi64(R1);
	asi64(R1) = cc_lex_lookup();
	if (!asi64(R1)) goto L5362;
	msysc_m$print_startcon();
	R1 = (u64)&cc_tables_stnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Duplicate symbol table entry");
	mlib_abortprogram(asu64(R1));
L5362:
	R1 = (u64)&cc_tables_stsymbols;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_tables_stsubcodes;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 100;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	i += 1; if (i <= av_1) goto L5356;
L5358:
	return;
}

static i64 cc_lex_dolexdirective() {
    u64 R1, R2, R3; 
	u64 symptr;
	u64 d;
	u64 p;
	u64 pstart;
	u64 s;
	i64 i;
	i64 cond;
	i64 c;
	i64 syshdr;
	i64 dir;
	i64 length;
	i64 allowmacros;
	struct $B15 filename;
	asu64(R1) = cc_lex_lxsptr;
	pstart = asu64(R1);
	asi64(R1) = cc_lex_getlexdirective();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5365;
	R1 = 0;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = pstart;
	asi64(R2) -= asi64(R3);
	asu64(R3) = pstart;
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Invalid # directive");
	cc_lex_lxerror(asu64(R1));
L5365:
	asi64(R1) = dir;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5367;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5368;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5369;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5370;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5371;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5372;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5373;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5373;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5374;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5375;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5376;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5377;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5378;
	goto L5379;
L5367:
	R1 = 1;
	cc_lex_isincludefile = asi64(R1);
	goto L5381;
L5380:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L5381:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L5380;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5380;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 60;
	asi64(R1) = asu64(R1)  !=  asu64(R2);
	allowmacros = asi64(R1);
	cc_lex_lexm();
	R1 = 0;
	cc_lex_isincludefile = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 42;
	if (asi64(R1) != asi64(R2)) goto L5384;
	R1 = 1;
	syshdr = asi64(R1);
	R1 = (u64)&filename;
	p = asu64(R1);
	asi64(R1) = allowmacros;
	if (!asi64(R1)) goto L5386;
L5387:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L5390;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5390;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L5391;
	goto L5392;
L5390:
	R1 = tou64("Bad include file");
	cc_lex_lxerror(asu64(R1));
	goto L5389;
L5391:
	goto L5388;
	goto L5389;
L5392:
	R1 = (u64)&length;
	R2 = (u64)&cc_decls_nextlx;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length;
	R2 = (u64)&p;
	*tou64p(R2) += asu64(R1);
L5389:
	goto L5387;
L5388:
	goto L5385;
L5386:
L5393:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L5396;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5397;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5397;
	goto L5398;
L5396:
	goto L5394;
	goto L5395;
L5397:
	R1 = tou64("include: > expected");
	cc_lex_lxerror(asu64(R1));
	goto L5395;
L5398:
	asi64(R1) = c;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L5395:
	goto L5393;
L5394:
L5385:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L5383;
L5384:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L5399;
	R1 = 0;
	syshdr = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L5383;
L5399:
	R1 = tou64("include?");
	cc_lex_lxerror(asu64(R1));
L5383:
	cc_lex_lexm();
	asu8(R1) = cc_cli_fshowincludes;
	if (!asu8(R1)) goto L5401;
	msysc_m$print_startcon();
	R1 = tou64("INCLUDE");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&filename;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("FROM");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = cc_lex_getfileno();
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("NSOURCEFILES=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = cc_decls_nsourcefiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5401:
	R1 = (u64)&cc_lex_nincludes;
	(*toi64p(R1)) += 1;
	asi64(R1) = syshdr;
	R2 = (u64)&filename;
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
	goto L5366;
L5368:
	cc_lex_dodefine();
	goto L5366;
L5369:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5403;
	R1 = tou64("undef: name expected");
	cc_lex_lxerror(asu64(R1));
L5403:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5405;
	goto L5404;
L5405:
	R1 = 0;
	asu64(R2) = d;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L5404:
	goto L5366;
L5370:
	asi64(R1) = cc_lex_getifdef();
	cond = asi64(R1);
	goto L5406;
	goto L5366;
L5371:
	asi64(R1) = cc_lex_getifdef();
	asi64(R1) = !asi64(R1);
	cond = asi64(R1);
	goto L5406;
	goto L5366;
L5372:
	asi64(R1) = cc_lex_getifexpr();
	cond = asi64(R1);
// cc_lex.dolexdirective.doif:
L5406:
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) += 1;
	asi64(R1) = cond;
	if (!asi64(R1)) goto L5408;
	R1 = 0;
	goto L5363;
	goto L5407;
L5408:
// cc_lex.dolexdirective.doskipcode:
L5409:
	asi64(R1) = cc_lex_skipcode();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5411;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5412;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5413;
	goto L5414;
L5411:
	asi64(R1) = cc_lex_getifexpr();
	cond = asi64(R1);
	asi64(R1) = cond;
	if (!asi64(R1)) goto L5416;
	R1 = 0;
	goto L5363;
L5416:
	goto L5409;
	goto L5410;
L5412:
	goto L5410;
L5413:
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) -=1;
	goto L5410;
L5414:
L5410:
L5407:
	goto L5366;
L5373:
	asi64(R1) = cc_lex_ifcondlevel;
	if (asi64(R1)) goto L5418;
	R1 = tou64("#if missing/elif/else");
	cc_lex_lxerror(asu64(R1));
L5418:
L5419:
	asi64(R1) = cc_lex_skipcode();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5419;
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) -=1;
	goto L5366;
L5374:
	asi64(R1) = cc_lex_ifcondlevel;
	if (asi64(R1)) goto L5423;
	R1 = tou64("#if missing/endif");
	cc_lex_lxerror(asu64(R1));
L5423:
	R1 = (u64)&cc_lex_ifcondlevel;
	(*toi64p(R1)) -=1;
	goto L5366;
L5375:
	goto L5366;
L5376:
L5424:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L5424;
	goto L5366;
L5377:
	cc_lex_lexm();
	msysc_m$print_startcon();
	R1 = tou64("#ERROR:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_nextlx;
	cc_lex_showtoken(asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("ABORTING");
	cc_lex_lxerror(asu64(R1));
	goto L5366;
L5378:
	cc_lex_dopragmadir();
	goto L5366;
L5379:
// cc_lex.dolexdirective.skip:
	msysc_m$print_startcon();
	R1 = tou64("DIRECTIVE NOT IMPL:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_sourcedirnames;
	asi64(R2) = dir;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = pstart;
	cc_lex_lxsptr = asu64(R1);
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	goto L5363;
	R1 = tou64("Directive not implemented");
	cc_lex_lxerror(asu64(R1));
L5366:
	R1 = 0;
	goto L5363;
L5363:
	return asi64(R1);
}

static i64 cc_lex_getlexdirective() {
    u64 R1, R2; 
	u64 d;
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5430;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5431;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L5432;
	goto L5433;
L5430:
	goto L5429;
L5431:
	R1 = 13;
	goto L5428;
	goto L5429;
L5432:
L5434:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5437;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L5434;
L5437:
	R1 = 13;
	goto L5428;
	goto L5429;
L5433:
	R1 = 0;
	goto L5428;
L5429:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L5439;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L5440;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L5441;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5442;
	goto L5443;
L5439:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 100;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L5428;
	goto L5438;
L5440:
	R1 = 3;
	goto L5428;
	goto L5438;
L5441:
	R1 = 5;
	goto L5428;
	goto L5438;
L5442:
	R1 = 13;
	goto L5428;
	goto L5438;
L5443:
L5438:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5445;
	asu64(R1) = d;
	R2 = 88;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 68;
	if (asi64(R1) != asi64(R2)) goto L5447;
	asu64(R1) = d;
	R2 = 100;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L5428;
L5447:
L5445:
	R1 = 0;
	goto L5428;
L5428:
	return asi64(R1);
}

static void cc_lex_startlex(u64 caption, i64 fileno) {
    u64 R1, R2, R3; 
	R1 = 0;
	cc_lex_ifcondlevel = asi64(R1);
	R1 = 0;
	cc_lex_lx_stackindex = asi64(R1);
	R1 = 0;
	cc_lex_noexpand = asi64(R1);
	R1 = (u64)&cc_lex_normaltkx;
	cc_lex_normaltk = asu64(R1);
	R1 = 0;
	cc_lex_lx_stackindex = asi64(R1);
	R1 = 0;
	cc_lex_ifcondlevel = asi64(R1);
	R1 = 1;
	cc_lex_firstsymbol = asi64(R1);
	R1 = 0;
	cc_lex_npastedtokens = asi64(R1);
	R1 = 0;
	cc_lex_isincludefile = asi64(R1);
	R1 = 0;
	cc_lex_tkptr = asu64(R1);
	R1 = (u64)&cc_decls_sourcefiletext;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	cc_lex_lxsptr = asu64(R2);
	cc_lex_lxstart = asu64(R1);
	asi64(R1) = fileno;
	cc_lex_setfileno(asi64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	cc_lex_lex();
	return;
}

static void cc_lex_endlex() {
    u64 R1; 
	asi64(R1) = cc_lex_ifcondlevel;
	if (!asi64(R1)) goto L5451;
	msysc_m$print_startcon();
	asi64(R1) = cc_lex_ifcondlevel;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("#endif missing");
	cc_lex_lxerror(asu64(R1));
L5451:
	return;
}

static void cc_lex_ps(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":::");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_lx;
	cc_lex_printsymbol(asu64(R1));
	return;
}

static void cc_lex_psnext(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(":##");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_nextlx;
	cc_lex_printsymbol(asu64(R1));
	return;
}

static i64 cc_lex_gethashtablesize() {
    u64 R1, R2; 
	i64 i;
	i64 n;
	R1 = 0;
	n = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L5457;
L5455:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5459;
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
L5459:
	i += 1; if (i <= cc_decls_hstmask) goto L5455;
L5457:
	asi64(R1) = n;
	goto L5454;
L5454:
	return asi64(R1);
}

static void cc_lex_readlinecomment() {
    u64 R1, R2; 
L5461:
	goto L5464;
L5463:
L5464:
	R1 = (u64)&cc_lex_linecommentmap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *(tou64p(R2)) += 1;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5463;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L5467;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5468;
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L5469;
	goto L5470;
L5467:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L5462;
	goto L5466;
L5468:
	goto L5462;
	goto L5466;
L5469:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L5472;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L5473;
	goto L5474;
L5472:
	R1 = 2;
	R2 = (u64)&cc_lex_lxsptr;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L5471;
L5473:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L5471;
L5474:
L5471:
	goto L5466;
L5470:
L5466:
	goto L5461;
L5462:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	return;
}

static void cc_lex_readblockcomment() {
    u64 R1, R2; 
L5476:
	goto L5479;
L5478:
L5479:
	R1 = (u64)&cc_lex_commentmap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *(tou64p(R2)) += 1;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5478;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L5482;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5483;
	R2 = 42;
	if (asu64(R1) == asu64(R2)) goto L5484;
	goto L5485;
L5482:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L5481;
L5483:
	R1 = tou64("block comment eof");
	cc_lex_lxerror(asu64(R1));
	goto L5481;
L5484:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) != asu64(R2)) goto L5487;
	R1 = 2;
	R2 = (u64)&cc_lex_lxsptr;
	*tou64p(R2) += asu64(R1);
	goto L5477;
L5487:
	goto L5481;
L5485:
L5481:
	goto L5476;
L5477:
	return;
}

static void cc_lex_readhex(u64 pstart) {
    u64 R1, R2, R3, R4; 
	u64 aa;
	u64 c;
	i64 length;
	i64 leading;
	i64 ll;
	i64 usigned;
	u64 p;
	R1 = 0;
	aa = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	p = asu64(R1);
	R1 = 1;
	leading = asi64(R1);
	R1 = 0;
	R2 = R1;
	usigned = asi64(R2);
	ll = asi64(R1);
	R1 = 0;
	length = asi64(R1);
L5489:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = R1;
	c = asu64(R2);
	switch (asi64(R1)) {
	case 46: case 80: case 112: goto L5499;
	case 47: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 113: case 114: case 115: case 116: goto L5492;
	case 48: goto L5494;
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L5493;
	case 65: case 66: case 67: case 68: case 69: case 70: goto L5497;
	case 76: case 108: goto L5500;
	case 85: case 117: goto L5503;
	case 97: case 98: case 99: case 100: case 101: case 102: goto L5498;
	default: goto L5492;
    };
// SWITCH
L5493:
	R1 = 0;
	leading = asi64(R1);
	asu64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = c;
	R3 = 48;
	asi64(R2) -= asi64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	goto L5489;
L5494:
	asi64(R1) = leading;
	if (!asi64(R1)) goto L5496;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L5495;
L5496:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = aa;
	R2 = 16;
	asu64(R1) *= asu64(R2);
	aa = asu64(R1);
L5495:
	goto L5489;
L5497:
	R1 = 0;
	leading = asi64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = c;
	R3 = 65;
	asi64(R2) -= asi64(R3);
	R3 = 10;
	asi64(R2) += asi64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	goto L5489;
L5498:
	R1 = 0;
	leading = asi64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = aa;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asu64(R2) = c;
	R3 = 97;
	asi64(R2) -= asi64(R3);
	R3 = 10;
	asi64(R2) += asi64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	goto L5489;
L5499:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 16;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = p;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	asu64(R4) = pstart;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5488;
	goto L5489;
L5500:
	R1 = (u64)&ll;
	(*toi64p(R1)) += 1;
	asi64(R1) = ll;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L5502;
	R1 = tou64("-LL?");
	cc_lex_lxerror(asu64(R1));
L5502:
	goto L5489;
L5503:
	asi64(R1) = usigned;
	if (!asi64(R1)) goto L5505;
	R1 = tou64("-U?");
	cc_lex_lxerror(asu64(R1));
L5505:
	R1 = 1;
	usigned = asi64(R1);
	goto L5489;
L5492:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L5490;
	goto L5489;
L5490:
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 16;
	if (asi64(R1) <= asi64(R2)) goto L5507;
	R1 = tou64("Overflow in hex number");
	cc_lex_lxerror(asu64(R1));
L5507:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = aa;
	R2 = 9223372036854775807;
	if (asu64(R1) <= asu64(R2)) goto L5509;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5508;
L5509:
	asu64(R1) = aa;
	R2 = 4294967295;
	if (asu64(R1) <= asu64(R2)) goto L5510;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5508;
L5510:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) <= asu64(R2)) goto L5511;
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5508;
L5511:
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5508:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = cc_lex_checknumbersuffix();
L5488:
	return;
}

static void cc_lex_readbinary(u64 pstart) {
    u64 R1, R2, R3; 
	u64 aa;
	i64 c;
	i64 length;
	i64 res;
	i64 leading;
	u64 p;
	i64 av_1;
	R1 = 0;
	aa = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	p = asu64(R1);
	R1 = 1;
	leading = asi64(R1);
L5513:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 46: goto L5522;
	case 47: goto L5516;
	case 48: goto L5518;
	case 49: goto L5517;
	case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L5521;
	default: goto L5516;
    };
// SWITCH
L5517:
	R1 = 0;
	leading = asi64(R1);
	goto L5513;
L5518:
	asi64(R1) = leading;
	if (!asi64(R1)) goto L5520;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L5520:
	goto L5513;
L5521:
	R1 = tou64("Binary bad digit");
	cc_lex_lxerror(asu64(R1));
	goto L5513;
L5522:
	R1 = tou64("Binary fp");
	cc_lex_lxerror(asu64(R1));
	goto L5513;
L5516:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L5514;
	goto L5513;
L5514:
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = p;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L5524;
	R1 = tou64("Overflow in binary number");
	cc_lex_lxerror(asu64(R1));
L5524:
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5527;
L5525:
	asu64(R1) = aa;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	aa = asu64(R1);
	if (--asi64(av_1)) goto L5525;
L5527:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L5529;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5529:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = cc_lex_checknumbersuffix();
	return;
}

static void cc_lex_readoctal(u64 pstart) {
    u64 R1, R2, R3, R4; 
	u64 aa;
	i64 c;
	i64 length;
	i64 res;
	i64 leading;
	i64 ll;
	i64 usigned;
	u64 p;
	i64 av_1;
	R1 = 0;
	aa = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	p = asu64(R1);
	R1 = 1;
	leading = asi64(R1);
	R1 = 0;
	R2 = R1;
	usigned = asi64(R2);
	ll = asi64(R1);
	R1 = 0;
	length = asi64(R1);
L5531:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 46: goto L5539;
	case 47: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: goto L5534;
	case 48: goto L5536;
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: goto L5535;
	case 76: case 108: goto L5540;
	case 85: case 117: goto L5543;
	default: goto L5534;
    };
// SWITCH
L5535:
	R1 = 0;
	leading = asi64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	goto L5531;
L5536:
	asi64(R1) = leading;
	if (!asi64(R1)) goto L5538;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L5537;
L5538:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
L5537:
	goto L5531;
L5539:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 10;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = p;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	asu64(R4) = pstart;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5530;
	goto L5531;
L5540:
	R1 = (u64)&ll;
	(*toi64p(R1)) += 1;
	asi64(R1) = ll;
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L5542;
	R1 = tou64("-LL?");
	cc_lex_lxerror(asu64(R1));
L5542:
	goto L5531;
L5543:
	asi64(R1) = usigned;
	if (!asi64(R1)) goto L5545;
	R1 = tou64("-U?");
	cc_lex_lxerror(asu64(R1));
L5545:
	R1 = 1;
	usigned = asi64(R1);
	goto L5531;
L5534:
	R1 = (u64)&cc_lex_alphamap;
	asi64(R2) = c;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5547;
// cc_lex.readoctal.doalpha:
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L5530;
L5547:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L5532;
	goto L5531;
L5532:
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 22;
	if (asi64(R1) > asi64(R2)) goto L5551;
	asi64(R1) = length;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L5550;
	R1 = 22;
	R2 = tou64("1777777777777777777777");
	asu64(R3) = p;
	asi64(R1) = mlib_cmpstringn(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5550;
L5551:
	R1 = tou64("Overflow in octal number");
	cc_lex_lxerror(asu64(R1));
L5550:
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5554;
L5552:
	asu64(R1) = aa;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	aa = asu64(R1);
	if (--asi64(av_1)) goto L5552;
L5554:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L5556;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5556:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = cc_lex_checknumbersuffix();
L5530:
	return;
}

static void cc_lex_readdecimal(u64 pstart) {
    u64 R1, R2, R3, R4; 
	u64 aa;
	i64 c;
	i64 length;
	i64 res;
	i64 leading;
	u8 ll;
	u8 usigned;
	u64 p;
	i64 av_1;
	R1 = 0;
	aa = asu64(R1);
	R1 = 0;
	R2 = R1;
	usigned = asu8(R2);
	ll = asu8(R1);
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) -= 1;
	p = asu64(R1);
	goto L5559;
L5558:
L5559:
	R1 = (u64)&cc_lex_digitmap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *(tou64p(R2)) += 1;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5558;
	goto L5562;
L5561:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L5562:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) == asu64(R2)) goto L5561;
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = p;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
L5564:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 46: case 69: case 101: goto L5568;
	case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 70: case 71: case 72: case 73: case 74: case 75: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: goto L5567;
	case 76: case 108: goto L5569;
	case 85: case 117: goto L5572;
	default: goto L5567;
    };
// SWITCH
L5568:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = 10;
	asu64(R2) = cc_lex_lxsptr;
	asu64(R3) = p;
	asi64(R2) -= asi64(R3);
	asu64(R3) = p;
	asu64(R4) = pstart;
	cc_lex_readrealnumber(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5557;
	goto L5564;
L5569:
	R1 = (u64)&ll;
	(*tou8p(R1)) += 1;
	asu8(R1) = ll;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) <= asi64(R2)) goto L5571;
	R1 = tou64("-LL?");
	cc_lex_lxerror(asu64(R1));
L5571:
	goto L5564;
L5572:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L5574;
	R1 = tou64("-U?");
	cc_lex_lxerror(asu64(R1));
L5574:
	R1 = 1;
	usigned = asu8(R1);
	goto L5564;
L5567:
	R1 = (u64)&cc_lex_alphamap;
	asi64(R2) = c;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5576;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L5557;
L5576:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L5565;
	goto L5564;
L5565:
	asu64(R1) = pstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) > asi64(R2)) goto L5579;
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L5578;
	R1 = 20;
	R2 = tou64("18446744073709551615");
	asu64(R3) = p;
	asi64(R1) = mlib_cmpstringn(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5578;
L5579:
	R1 = tou64("Overflow in decimal number");
	cc_lex_lxerror(asu64(R1));
L5578:
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5582;
L5580:
	asu64(R1) = aa;
	R2 = 10;
	asu64(R1) *= asu64(R2);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	R3 = 48;
	asu64(R2) -= asu64(R3);
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
	if (--asi64(av_1)) goto L5580;
L5582:
	R1 = 59;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu8(R1) = ll;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5584;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5585;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5586;
	goto L5587;
L5584:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asi64(R1) < asi64(R2)) goto L5589;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5588;
L5589:
	R1 = 3;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5588:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L5591;
	asu64(R1) = aa;
	R2 = 4294967295;
	if (asu64(R1) < asu64(R2)) goto L5593;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5592;
L5593:
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5592:
	goto L5590;
L5591:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L5595;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5595:
L5590:
	goto L5583;
L5585:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L5597;
	asu64(R1) = aa;
	R2 = 4294967295;
	if (asu64(R1) < asu64(R2)) goto L5599;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5598;
L5599:
	R1 = 8;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5598:
	goto L5596;
L5597:
	asu64(R1) = aa;
	R2 = 2147483647;
	if (asu64(R1) < asu64(R2)) goto L5601;
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5601:
L5596:
	goto L5583;
L5586:
	asu8(R1) = usigned;
	if (!asu8(R1)) goto L5603;
	R1 = 9;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5602;
L5603:
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5602:
	goto L5583;
L5587:
L5583:
	asu64(R1) = aa;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L5557:
	return;
}

static i64 cc_lex_checknumbersuffix() {
    u64 R1, R2; 
	u8 c;
L5605:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = R1;
	c = asu8(R2);
	switch (asi64(R1)) {
	case 76: case 85: case 108: case 117: goto L5609;
	case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: goto L5608;
	default: goto L5608;
    };
// SWITCH
L5609:
	goto L5605;
L5608:
	R1 = (u64)&cc_lex_alphamap;
	asu8(R2) = c;
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5611;
L5611:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L5606;
	goto L5605;
L5606:
	R1 = 3;
	goto L5604;
L5604:
	return asi64(R1);
}

static void cc_lex_stacksourcefile(u64 file, i64 syshdr) {
    u64 R1, R2, R3; struct $B8 R1_B8; 
	u64 sptr;
	i64 fileno;
	struct $B8 info;
	struct $B47 fullpath;
	asi64(R1) = syshdr;
	asu64(R2) = file;
	asi64(R1) = cc_lex_getsourcefile(asu64(R2), asi64(R1));
	fileno = asi64(R1);
	asi64(R1) = fileno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5614;
	msysc_m$print_startcon();
	asu64(R1) = file;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = file;
	asi64(R1) = strlen(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find include file");
	cc_lex_lxerror(asu64(R1));
L5614:
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L5616;
	R1 = tou64("Too many nested includes");
	cc_lex_lxerror(asu64(R1));
L5616:
	R1 = (u64)&cc_lex_lx_stackindex;
	(*toi64p(R1)) += 1;
	R1 = 0;
	R2 = (u64)&fullpath;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L5618;
	R1 = (u64)&cc_lex_headerpathlist;
	asi64(R2) = cc_lex_lx_stackindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	R2 = (u64)&fullpath;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L5618:
	R1 = (u64)&cc_lex_headerpath;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L5620;
	R1 = (u64)&cc_lex_headerpath;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&fullpath;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L5620:
	R1 = (u64)&fullpath;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_lex_headerpathlist;
	asi64(R3) = cc_lex_lx_stackindex;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = cc_lex_lxstart;
	R2 = (u64)&info;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&info;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&info;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_lex_getfileno();
	R2 = (u64)&info;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	(R1_B8) = info;
	R2 = (u64)&cc_lex_lx_stack;
	asi64(R3) = cc_lex_lx_stackindex;
	*(struct $B8*)(((i64)R2+(i64)R3*24-24)) = (R1_B8);
	R1 = (u64)&cc_decls_sourcefiletext;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	cc_lex_lxsptr = asu64(R2);
	cc_lex_lxstart = asu64(R1);
	asi64(R1) = fileno;
	cc_lex_setfileno(asi64(R1));
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	return;
}

static void cc_lex_unstacksourcefile() {
    u64 R1, R2, R3; struct $B8 R1_B8; 
	u64 path;
	struct $B8 info;
	R1 = (u64)&cc_lex_headerpathlist;
	asi64(R2) = cc_lex_lx_stackindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	path = asu64(R1);
	asu64(R1) = path;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = path;
	mlib_pcm_free(asu64(R2), asi64(R1));
	R1 = (u64)&cc_lex_lx_stack;
	R2 = (u64)&cc_lex_lx_stackindex;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	(R1_B8) = *(struct $B8*)(((i64)R1+(i64)R2*24-24));
	info = (R1_B8);
	R1 = (u64)&info;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_lxstart = asu64(R1);
	R1 = (u64)&info;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_lxsptr = asu64(R1);
	R1 = (u64)&info;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&info;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_lex_setfileno(asi64(R1));
	return;
}

static i64 cc_lex_getsourcefile(u64 file, i64 syshdr) {
    u64 R1, R2, R3; 
	struct $B15 filespec2;
	u64 hdrtext;
	i64 i;
	R1 = 0;
	R2 = (u64)&cc_lex_headerpath;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5625;
L5623:
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5627;
	asi64(R1) = i;
	goto L5622;
L5627:
	i += 1; if (i <= cc_decls_nsourcefiles) goto L5623;
L5625:
	asu8(R1) = cc_cli_dointheaders;
	if (!asu8(R1)) goto L5629;
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = cc_headers_findheader(asu64(R1));
	hdrtext = asu64(R1);
	asu64(R1) = hdrtext;
	if (!asu64(R1)) goto L5631;
	asu64(R1) = hdrtext;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadbuiltin(asu64(R2), asu64(R1));
	goto L5622;
L5631:
L5629:
	R1 = tou64("mcc.h");
	asu64(R2) = file;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5633;
	R1 = tou64("#define __attribute__(x)\n#define _WIN32\n#define WIN32\n#define __WIN32__\n#define __inline\n#define __dllimport(x)\n#define __declspec(x)\n#define __stdcall\n#define CALLBACK $callback\n#define __cdecl\n#define EXTERN_C extern\n#define DECLSPEC_IMPORT\n#define __32BIT__\n#define register\n#define __MCCC__\n\ntypedef signed char\t\ti8;\ntypedef short\t\t\ti16;\ntypedef int\t\t\t\ti32;\ntypedef long long int\ti64;\ntypedef unsigned char\t\t\tu8;\ntypedef unsigned short\t\t\tu16;\ntypedef unsigned int\t\t\tu32;\ntypedef unsigned long long int\tu64;\n\ntypedef unsigned char byte;\n\ntypedef float r32;\ntypedef double r64;\n\n");
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadbuiltin(asu64(R2), asu64(R1));
	goto L5622;
L5633:
	asu64(R1) = file;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&cc_lex_headerpath;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_headerpath;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L5635;
	R1 = (u64)&cc_lex_headerpath;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L5638;
	R1 = (u64)&cc_lex_headerpath;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L5637;
	R1 = (u64)&cc_lex_headerpath;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) != asu64(R2)) goto L5637;
L5638:
	asu64(R1) = file;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L5640;
	asu64(R1) = file;
	asu64(R2) = file;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	goto L5622;
L5640:
	R1 = 0;
	goto L5622;
L5637:
L5635:
	asi64(R1) = cc_lex_lx_stackindex;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5643;
L5641:
	R1 = (u64)&cc_lex_headerpathlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L5645;
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	goto L5622;
L5645:
	i += -1; if (i >= 1) goto L5641;
L5643:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nsearchdirs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5648;
L5646:
	R1 = (u64)&cc_decls_searchdirs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L5650;
	R1 = (u64)&cc_lex_getsourcefile_filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&cc_lex_headerpath;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&cc_lex_getsourcefile_filespec;
	asi64(R1) = cc_support_loadsourcefile(asu64(R2), asu64(R1));
	goto L5622;
L5650:
	i += 1; if (i <= cc_decls_nsearchdirs) goto L5646;
L5648:
	R1 = 0;
	goto L5622;
L5622:
	return asi64(R1);
}

static void cc_lex_lex() {
    u64 R1, R2, R3, R4; struct $B18 R1_B18; 
// cc_lex.lex.reenter:
	(R1_B18) = cc_decls_nextlx;
	cc_decls_lx = (R1_B18);
	cc_lex_lexm();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L5654;
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5654;
	R1 = 0;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&cc_decls_lx;
	R4 = 24;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5654:
L5655:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5657;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5658;
	goto L5659;
L5657:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 68;
	if (asi64(R1) != asi64(R2)) goto L5661;
	R1 = 67;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5661:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 100;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5651;
	goto L5655;
L5658:
	cc_lex_lexm();
	goto L5655;
L5659:
	goto L5651;
	goto L5655;
L5651:
	return;
}

static void cc_lex_shownumberstr(u64 l, u64 f) {
    u64 R1, R2, R3; 
	u64 s;
	asu64(R1) = l;
	asi64(R1) = cc_lex_getfilenox(asu64(R1));
	if (!asi64(R1)) goto L5664;
	R1 = (u64)&cc_decls_sourcefiletext;
	asu64(R2) = l;
	asi64(R2) = cc_lex_getfilenox(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = l;
	asi64(R2) = cc_lex_getnumberoffsetx(asu64(R2));
	R1 += (i64)R2;
	s = asu64(R1);
	goto L5663;
L5664:
	R1 = (u64)&cc_lex_pastedtokenlist;
	asu64(R2) = l;
	R3 = 28;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	s = asu64(R1);
L5663:
	asu64(R1) = f;
	asu64(R2) = l;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = s;
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	return;
}

static u64 cc_lex_addnamestr(u64 name) {
    u64 R1, R2, R3; struct $B18 R1_B18; 
	struct $B18 oldlx;
	u64 symptr;
	(R1_B18) = cc_decls_nextlx;
	oldlx = (R1_B18);
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = name;
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	cc_lex_lxhashvalue = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	cc_lex_lxsvalue = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asu64(R1) += asu64(R2);
	asu64(R2) = name;
	asu64(R3) = cc_lex_lxsvalue;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = cc_lex_lookup();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	symptr = asu64(R1);
	(R1_B18) = oldlx;
	cc_decls_nextlx = (R1_B18);
	asu64(R1) = symptr;
	goto L5665;
L5665:
	return asu64(R1);
}

static void cc_lex_lxreadstring(i64 termchar, i64 fwide) {
    u64 R1, R2, R3, R4; 
	struct $B93 str;
	u64 dest;
	u64 ws;
	u64 wd;
	u64 wd0;
	i64 c;
	i64 d;
	i64 length;
	i64 useheap;
	i64 av_1;
	i64 av_2;
	asi64(R1) = termchar;
	R2 = 34;
	if (asi64(R1) != asi64(R2)) goto L5668;
	asi64(R1) = fwide;
	if (!asi64(R1)) goto L5670;
	R1 = 64;
	goto L5669;
L5670:
	R1 = 63;
L5669:
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5667;
L5668:
	R1 = 61;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5667:
	asu64(R1) = cc_lex_lxsptr;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = cc_lex_lx_stackindex;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5672;
	asi64(R1) = fwide;
	if (asi64(R1)) goto L5672;
	asu64(R1) = cc_lex_lxsptr;
	dest = asu64(R1);
	asu64(R1) = dest;
	ws = asu64(R1);
	R1 = 0;
	useheap = asi64(R1);
	goto L5671;
L5672:
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	ws = asu64(R1);
	R1 = 1;
	useheap = asi64(R1);
L5671:
	R1 = 0;
	length = asi64(R1);
L5673:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L5676;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L5677;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5677;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5678;
	goto L5679;
L5676:
	asi64(R1) = cc_lex_isincludefile;
	if (!asi64(R1)) goto L5681;
	R1 = 47;
	c = asi64(R1);
	goto L5682;
L5681:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
// cc_lex.lxreadstring.reenter:
	asi64(R1) = c;
	switch (asi64(R1)) {
	case 10: goto L5716;
	case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 35: case 36: case 37: case 38: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 93: case 94: case 95: case 96: case 99: case 100: case 101: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 111: case 112: case 113: case 115: case 117: case 119: goto L5686;
	case 13: goto L5713;
	case 34: goto L5710;
	case 39: goto L5712;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: goto L5703;
	case 92: goto L5711;
	case 97: goto L5687;
	case 98: goto L5688;
	case 102: goto L5689;
	case 110: goto L5690;
	case 114: goto L5691;
	case 116: goto L5692;
	case 118: goto L5693;
	case 120: goto L5694;
	default: goto L5686;
    };
// SWITCH
L5687:
	R1 = 7;
	c = asi64(R1);
	goto L5684;
L5688:
	R1 = 8;
	c = asi64(R1);
	goto L5684;
L5689:
	R1 = 12;
	c = asi64(R1);
	goto L5684;
L5690:
	R1 = 10;
	c = asi64(R1);
	goto L5684;
L5691:
	R1 = 13;
	c = asi64(R1);
	goto L5684;
L5692:
	R1 = 9;
	c = asi64(R1);
	goto L5684;
L5693:
	R1 = 11;
	c = asi64(R1);
	goto L5684;
L5694:
	R1 = 0;
	c = asi64(R1);
L5695:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	d = asi64(R2);
	switch (asi64(R1)) {
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L5702;
	case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: goto L5699;
	case 65: case 66: case 67: case 68: case 69: case 70: goto L5700;
	case 97: case 98: case 99: case 100: case 101: case 102: goto L5701;
	default: goto L5699;
    };
// SWITCH
L5700:
	asi64(R1) = c;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	c = asi64(R1);
	goto L5697;
L5701:
	asi64(R1) = c;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	c = asi64(R1);
	goto L5697;
L5702:
	asi64(R1) = c;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	c = asi64(R1);
	goto L5697;
L5699:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L5696;
L5697:
	goto L5695;
L5696:
	goto L5684;
L5703:
	R1 = 48;
	R2 = (u64)&c;
	*toi64p(R2) -= asi64(R1);
	R1 = 2;
	av_1 = asi64(R1);
L5704:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	d = asi64(R2);
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L5708;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5708;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L5708;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L5708;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5708;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5708;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L5708;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5708;
	goto L5709;
L5708:
	asi64(R1) = c;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asi64(R2) = d;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	c = asi64(R1);
	goto L5707;
L5709:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L5706;
L5707:
	if (--asi64(av_1)) goto L5704;
L5706:
	goto L5684;
L5710:
	R1 = 34;
	c = asi64(R1);
	goto L5684;
L5711:
	R1 = 92;
	c = asi64(R1);
	goto L5684;
L5712:
	R1 = 39;
	c = asi64(R1);
	goto L5684;
L5713:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5715;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L5715:
	goto L5673;
	goto L5684;
L5716:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	goto L5673;
	goto L5684;
L5686:
L5684:
	goto L5675;
L5677:
	asi64(R1) = c;
	asi64(R2) = termchar;
	if (asi64(R1) != asi64(R2)) goto L5718;
	goto L5674;
L5718:
	goto L5675;
L5678:
	msysc_m$print_startcon();
	R1 = tou64("NEXTLX.LINENO=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("String not terminated");
	cc_lex_lxerror(asu64(R1));
	goto L5675;
L5679:
L5675:
// cc_lex.lxreadstring.normalchar:
L5682:
	asi64(R1) = useheap;
	if (asi64(R1)) goto L5720;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L5719;
L5720:
	R1 = (u64)&length;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 2048;
	if (asi64(R1) >= asi64(R2)) goto L5721;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L5719;
L5721:
	R1 = tou64("Local str too long");
	cc_lex_lxerror(asu64(R1));
L5719:
	goto L5673;
L5674:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = fwide;
	if (!asi64(R1)) goto L5723;
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = 2;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	wd = asu64(R2);
	wd0 = asu64(R1);
	asi64(R1) = length;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5726;
L5724:
	R1 = (u64)&ws;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = (u64)&wd;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 2; asu64(R2) = asu64(R3);
	*tou16p(R2) = asu16(R1);
	if (--asi64(av_2)) goto L5724;
L5726:
	R1 = 0;
	asu64(R2) = wd;
	*tou16p(R2) = asu16(R1);
	asu64(R1) = wd0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5722;
L5723:
	asi64(R1) = useheap;
	if (!asi64(R1)) goto L5727;
	asi64(R1) = length;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	R2 = 1;
	asu64(R1) += asu64(R2);
	R2 = (u64)&str;
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L5722;
L5727:
	asu64(R1) = dest;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5722:
	return;
}

static void cc_lex_addlisttoken(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5730;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L5729;
L5730:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5729:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_addlisttoken_copy(u64 ulist, u64 ulistx, u64 q) {
    u64 R1, R2, R3; struct $B18 R1_B18; 
	u64 p;
	asu64(R1) = cc_lex_alloctoken();
	p = asu64(R1);
	asu64(R1) = q;
	(R1_B18) = *(struct $B18*)(R1);
	asu64(R2) = p;
	*(struct $B18*)(R2) = (R1_B18);
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5733;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L5732;
L5733:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5732:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_addlist_nextlx(u64 ulist, u64 ulistx) {
    u64 R1, R2, R3; struct $B18 R1_B18; 
	u64 p;
	asu64(R1) = cc_lex_alloctoken();
	p = asu64(R1);
	(R1_B18) = cc_decls_nextlx;
	asu64(R2) = p;
	*(struct $B18*)(R2) = (R1_B18);
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5736;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L5735;
L5736:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5735:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_addlisttoken_seq(u64 ulist, u64 ulistx, u64 seq) {
    u64 R1, R2, R3; struct $B18 R1_B18; 
	u64 tk;
	goto L5739;
L5738:
	asu64(R1) = cc_lex_alloctoken();
	tk = asu64(R1);
	asu64(R1) = seq;
	(R1_B18) = *(struct $B18*)(R1);
	asu64(R2) = tk;
	*(struct $B18*)(R2) = (R1_B18);
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5742;
	asu64(R1) = tk;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L5741;
L5742:
	asu64(R1) = tk;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5741:
	R1 = 0;
	asu64(R2) = tk;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = tk;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
L5739:
	asu64(R1) = seq;
	if (asu64(R1)) goto L5738;
	return;
}

static void cc_lex_addlistmparam(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5745;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L5744;
L5745:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5744:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lex_dodefine() {
    u64 R1, R2, R3; struct $B18 R1_B18; 
	u64 stlist;
	u64 stlistx;
	u64 p;
	u64 q;
	u64 stname;
	u64 d;
	u64 tklist;
	u64 tklistx;
	u64 tk;
	i64 nparams;
	i64 ntokens;
	i64 paramno;
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5748;
	R1 = tou64("define: name expected");
	cc_lex_lxerror(asu64(R1));
L5748:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stname = asu64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	R3 = 92;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	R3 = 113;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stname;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = stname;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	nparams = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 40;
	if (asu64(R1) != asu64(R2)) goto L5750;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 0;
	R2 = R1;
	stlistx = asu64(R2);
	stlist = asu64(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	cc_lex_lexreadtoken();
L5751:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5754;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5755;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L5756;
	goto L5757;
L5754:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = stlist;
	p = asu64(R1);
	goto L5759;
L5758:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L5762;
	R1 = tou64("Dupl macro param");
	cc_lex_lxerror(asu64(R1));
L5762:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L5759:
	asu64(R1) = p;
	if (asu64(R1)) goto L5758;
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&stlistx;
	R3 = (u64)&stlist;
	cc_lex_addlistmparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&nparams;
	(*toi64p(R1)) += 1;
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5764;
	cc_lex_lexreadtoken();
L5764:
	goto L5753;
L5755:
	goto L5752;
	goto L5753;
L5756:
	R1 = tou64("__VA_ARGS__");
	asu64(R1) = cc_lex_addnamestr(asu64(R1));
	d = asu64(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5766;
	R1 = tou64("')' expected");
	cc_lex_lxerror(asu64(R1));
L5766:
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&stlistx;
	R3 = (u64)&stlist;
	cc_lex_addlistmparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&nparams;
	(*toi64p(R1)) += 1;
	goto L5752;
	goto L5753;
L5757:
	R1 = tou64("macro params?");
	cc_lex_lxerror(asu64(R1));
L5753:
	goto L5751;
L5752:
	asu64(R1) = stlist;
	asu64(R2) = stname;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5750:
	R1 = 0;
	R2 = R1;
	tklistx = asu64(R2);
	tklist = asu64(R1);
	R1 = 0;
	ntokens = asi64(R1);
L5767:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5770;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L5770;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5771;
	goto L5772;
L5770:
	goto L5768;
	goto L5769;
L5771:
	asu64(R1) = stname;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = 1;
	paramno = asi64(R1);
	goto L5774;
L5773:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L5777;
	R1 = 2;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
	asi64(R1) = paramno;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L5775;
L5777:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&paramno;
	(*toi64p(R1)) += 1;
L5774:
	asu64(R1) = p;
	if (asu64(R1)) goto L5773;
L5775:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	if (asu64(R1) != asu64(R2)) goto L5779;
	R1 = 1;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
L5779:
	goto L5769;
L5772:
L5769:
	R1 = (u64)&ntokens;
	(*toi64p(R1)) += 1;
	asu64(R1) = cc_lex_alloctoken();
	tk = asu64(R1);
	(R1_B18) = cc_decls_nextlx;
	asu64(R2) = tk;
	*(struct $B18*)(R2) = (R1_B18);
	asu64(R1) = tk;
	R2 = (u64)&tklistx;
	R3 = (u64)&tklist;
	cc_lex_addlisttoken(asu64(R3), asu64(R2), asu64(R1));
	goto L5767;
L5768:
	asu64(R1) = tklist;
	asu64(R2) = stname;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = nparams;
	asu64(R2) = stname;
	R3 = 111;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void cc_lex_readalphanumeric(u64 pstart) {
    u64 R1, R2, R3; 
	goto L5782;
L5781:
L5782:
	R1 = (u64)&cc_lex_alphamap;
	R2 = (u64)&cc_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5781;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = pstart;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 58;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static i64 cc_lex_inmacrostack(u64 d, u64 macrostack) {
    u64 R1, R2; 
	goto L5786;
L5785:
	asu64(R1) = macrostack;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L5789;
	R1 = 1;
	goto L5784;
L5789:
	asu64(R1) = macrostack;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	macrostack = asu64(R1);
L5786:
	asu64(R1) = macrostack;
	if (asu64(R1)) goto L5785;
	R1 = 0;
	goto L5784;
L5784:
	return asi64(R1);
}

static void cc_lex_showtokens(u64 caption, u64 tk) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("<");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L5792;
L5791:
	asu64(R1) = tk;
	cc_lex_showtoken(asu64(R1));
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
L5792:
	asu64(R1) = tk;
	if (asu64(R1)) goto L5791;
	msysc_m$print_startcon();
	R1 = tou64(">");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void cc_lex_lexa(u64 tk) {
    u64 R1, R2, R3; struct $B18 R1_B18; 
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = cc_lex_normaltk;
	if (asu64(R1) != asu64(R2)) goto L5796;
	cc_lex_lexreadtoken();
	goto L5794;
L5796:
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5798;
	R1 = 57;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5794;
L5798:
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	(R1_B18) = *(struct $B18*)(R1);
	cc_decls_nextlx = (R1_B18);
	asu64(R1) = tk;
	asu64(R1) = *tou64p(R1);
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = tk;
	*tou64p(R2) = asu64(R1);
L5794:
	return;
}

static void cc_lex_lexm() {
    u64 R1, R2, R3, R4, R5; struct $B18 R1_B18; 
	u64 d;
	i64 newlineno;
// PROC LOCAL STATICS GO HERE
	static i64 cc_lex_lexm_doreset = 0;
L5800:
	asu64(R1) = cc_lex_tkptr;
	if (!asu64(R1)) goto L5803;
	asu64(R1) = cc_lex_tkptr;
	(R1_B18) = *(struct $B18*)(R1);
	cc_decls_nextlx = (R1_B18);
	asu64(R1) = cc_lex_tkptr;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_tkptr = asu64(R1);
	asu64(R1) = cc_lex_tkptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5805;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L5807;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5807;
	asi64(R1) = cc_lex_peeklb();
	if (!asi64(R1)) goto L5807;
	asi64(R1) = cc_decls_sfileno;
	cc_lex_setfileno(asi64(R1));
	asi64(R1) = cc_decls_slineno;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	cc_lex_lexm_doreset = asi64(R1);
	goto L5808;
L5807:
	R1 = 1;
	cc_lex_lexm_doreset = asi64(R1);
L5805:
	goto L5799;
L5803:
	asi64(R1) = cc_lex_lexm_doreset;
	if (!asi64(R1)) goto L5810;
	asi64(R1) = cc_decls_sfileno;
	cc_lex_setfileno(asi64(R1));
	asi64(R1) = cc_decls_slineno;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	cc_lex_lexm_doreset = asi64(R1);
L5810:
	asi64(R1) = cc_lex_firstsymbol;
	if (!asi64(R1)) goto L5812;
	R1 = 0;
	cc_lex_firstsymbol = asi64(R1);
	cc_lex_dospecialinclude();
L5812:
	cc_lex_lexreadtoken();
// cc_lex.lexm.test1:
L5808:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5814;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5815;
	goto L5816;
L5814:
	asi64(R1) = cc_lex_dolexdirective();
	if (!asi64(R1)) goto L5818;
	goto L5799;
L5818:
	goto L5800;
	goto L5813;
L5815:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L5820;
	goto L5821;
L5820:
	asi64(R1) = cc_lex_getfileno();
	cc_decls_sfileno = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_slineno = asi64(R1);
	asi64(R1) = cc_decls_slineno;
	R2 = (u64)&cc_decls_nextlx;
	asu64(R3) = d;
	R4 = 100;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	cc_lex_expandpredefmacro(asi64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	cc_lex_lexm_doreset = asi64(R1);
	goto L5799;
	goto L5819;
L5821:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5824;
	asi64(R1) = cc_lex_noexpand;
	if (!asi64(R1)) goto L5823;
L5824:
	goto L5799;
L5823:
L5819:
	goto L5813;
L5816:
	goto L5799;
L5813:
	asi64(R1) = cc_lex_getfileno();
	cc_decls_sfileno = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_slineno = asi64(R1);
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5826;
	asi64(R1) = cc_lex_peeklb();
	if (asi64(R1)) goto L5828;
	goto L5799;
L5828:
	R1 = (u64)&newlineno;
	R2 = 1;
	R3 = (u64)&cc_lex_normaltk;
	R4 = 0;
	asu64(R5) = d;
	asu64(R1) = cc_lex_expandfnmacro(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	cc_lex_tkptr = asu64(R1);
	asi64(R1) = newlineno;
	cc_decls_slineno = asi64(R1);
	goto L5825;
L5826:
	R1 = 1;
	R2 = (u64)&cc_lex_normaltk;
	R3 = 0;
	asu64(R4) = d;
	asu64(R1) = cc_lex_expandobjmacro(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	cc_lex_tkptr = asu64(R1);
L5825:
	asu64(R1) = cc_lex_tkptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5830;
	R1 = 1;
	cc_lex_lexm_doreset = asi64(R1);
L5830:
	goto L5800;
L5799:
	return;
}

static i64 cc_lex_peeklb() {
    u64 R1, R2; 
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 40;
	if (asu64(R1) == asu64(R2)) goto L5834;
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) != asu64(R2)) goto L5833;
	asu64(R1) = cc_lex_lxsptr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 40;
	if (asu64(R1) != asu64(R2)) goto L5833;
L5834:
	R1 = 1;
	goto L5831;
L5833:
	R1 = 0;
	goto L5831;
L5831:
	return asi64(R1);
}

static i64 cc_lex_peektk(u64 tk) {
    u64 R1, R2; 
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
	asu64(R1) = tk;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5837;
	R1 = 0;
	goto L5835;
L5837:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5839;
	R1 = 1;
	goto L5835;
L5839:
	R1 = 0;
	goto L5835;
L5835:
	return asi64(R1);
}

static u64 cc_lex_expandobjmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel) {
    u64 R1, R2, R3, R4, R5; 
	u64 tk;
	u64 p;
	u64 repl;
	struct $B18 newmacro;
	i64 iscomplex;
	i64 useshh;
	i64 expanded;
	u64 d;
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	tk = asu64(R2);
	p = asu64(R1);
	R1 = 0;
	R2 = R1;
	useshh = asi64(R2);
	iscomplex = asi64(R1);
	goto L5842;
L5841:
	asu64(R1) = p;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L5845;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5848;
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L5847;
L5848:
	R1 = 1;
	iscomplex = asi64(R1);
	goto L5843;
L5847:
	goto L5844;
L5845:
	asu64(R1) = p;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5849;
	R1 = 1;
	R2 = R1;
	useshh = asi64(R2);
	iscomplex = asi64(R1);
	goto L5843;
L5849:
L5844:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L5842:
	asu64(R1) = p;
	if (asu64(R1)) goto L5841;
L5843:
	asi64(R1) = iscomplex;
	if (asi64(R1)) goto L5851;
	asu64(R1) = tk;
	goto L5840;
L5851:
	asu64(R1) = m;
	R2 = (u64)&newmacro;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = macrostack;
	R2 = (u64)&newmacro;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = useshh;
	if (!asi64(R1)) goto L5853;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	asu64(R5) = m;
	asu64(R1) = cc_lex_substituteargs(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	repl = asu64(R1);
	goto L5852;
L5853:
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	repl = asu64(R1);
L5852:
	R1 = (u64)&expanded;
	R2 = (u64)&newmacro;
	asu64(R3) = repl;
	asu64(R1) = cc_lex_scantokenseq(asu64(R3), asu64(R2), asu64(R1));
	tk = asu64(R1);
	asu64(R1) = tk;
	goto L5840;
L5840:
	return asu64(R1);
}

static u64 cc_lex_expandfnmacro(u64 m, u64 macrostack, u64 tksource, i64 frombaselevel, u64 endlineno) {
    u64 R1, R2, R3, R4, R5; 
	struct $B82 args;
	struct $B82 expargs;
	u64 repl;
	u64 tk;
	struct $B18 newmacro;
	i64 nargs;
	i64 i;
	i64 expanded;
	asu64(R1) = tksource;
	R2 = (u64)&args;
	asu64(R3) = m;
	asi64(R1) = cc_lex_readmacrocall(asu64(R3), asu64(R2), asu64(R1));
	nargs = asi64(R1);
	asi64(R1) = frombaselevel;
	if (!asi64(R1)) goto L5856;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = endlineno;
	*toi64p(R2) = asi64(R1);
L5856:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5859;
L5857:
	R1 = 0;
	R2 = (u64)&expargs;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= nargs) goto L5857;
L5859:
	asu64(R1) = macrostack;
	asi64(R2) = nargs;
	R3 = (u64)&expargs;
	R4 = (u64)&args;
	asu64(R5) = m;
	asu64(R1) = cc_lex_substituteargs(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	repl = asu64(R1);
	asu64(R1) = m;
	R2 = (u64)&newmacro;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = macrostack;
	R2 = (u64)&newmacro;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&expanded;
	R2 = (u64)&newmacro;
	asu64(R3) = repl;
	asu64(R1) = cc_lex_scantokenseq(asu64(R3), asu64(R2), asu64(R1));
	repl = asu64(R1);
	asu64(R1) = repl;
	goto L5854;
L5854:
	return asu64(R1);
}

static u64 cc_lex_scantokenseq(u64 tk, u64 macrostack, u64 expanded) {
    u64 R1, R2, R3, R4, R5; 
	u64 newtk;
	u64 newtkx;
	u64 expandtk;
	u64 oldtk;
	u64 m;
	struct $B18 newmacro;
	i64 noexpandflag;
	i64 simple;
	i64 dummy;
// cc_lex.scantokenseq.reenter:
L5861:
	R1 = 0;
	asu64(R2) = expanded;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = R1;
	newtkx = asu64(R2);
	newtk = asu64(R1);
	R1 = 0;
	noexpandflag = asi64(R1);
	R1 = 1;
	simple = asi64(R1);
	asu64(R1) = tk;
	oldtk = asu64(R1);
	goto L5863;
L5862:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5866;
	goto L5867;
L5866:
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5870;
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L5869;
L5870:
	R1 = 0;
	simple = asi64(R1);
	goto L5864;
L5869:
	goto L5865;
L5867:
L5865:
	asu64(R1) = tk;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5872;
	goto L5864;
L5872:
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
L5863:
	asu64(R1) = tk;
	if (asu64(R1)) goto L5862;
L5864:
	asi64(R1) = simple;
	if (!asi64(R1)) goto L5874;
	asu64(R1) = oldtk;
	goto L5860;
L5874:
	asu64(R1) = oldtk;
	tk = asu64(R1);
	goto L5876;
L5875:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5879;
	goto L5880;
L5879:
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5882;
	asi64(R1) = noexpandflag;
	if (asi64(R1)) goto L5882;
	asu64(R1) = tk;
	R2 = 23;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L5885;
	asi64(R1) = cc_lex_noexpand;
	if (!asi64(R1)) goto L5884;
L5885:
	goto L5886;
L5884:
	asu64(R1) = macrostack;
	asu64(R2) = m;
	asi64(R1) = cc_lex_inmacrostack(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5888;
	asu64(R1) = tk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 4;
	asu64(R2) = newtkx;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
	goto L5889;
L5888:
	R1 = 0;
	simple = asi64(R1);
	asu64(R1) = m;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5891;
	asu64(R1) = tk;
	asi64(R1) = cc_lex_peektk(asu64(R1));
	if (asi64(R1)) goto L5893;
	goto L5886;
L5893:
	R1 = (u64)&tk;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&dummy;
	R2 = 1;
	R3 = (u64)&tk;
	asu64(R4) = macrostack;
	asu64(R5) = m;
	asu64(R1) = cc_lex_expandfnmacro(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	expandtk = asu64(R1);
	asu64(R1) = expandtk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = expanded;
	*toi64p(R2) = asi64(R1);
	goto L5876;
	goto L5890;
L5891:
	R1 = 0;
	R2 = (u64)&tk;
	asu64(R3) = macrostack;
	asu64(R4) = m;
	asu64(R1) = cc_lex_expandobjmacro(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	expandtk = asu64(R1);
	R1 = 1;
	asu64(R2) = expanded;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = expandtk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
L5890:
	goto L5881;
L5882:
	asu64(R1) = m;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) != asi64(R2)) goto L5894;
	R1 = 1;
	noexpandflag = asi64(R1);
	goto L5886;
	goto L5881;
L5894:
	asu64(R1) = m;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L5895;
	asu64(R1) = cc_lex_alloctokenz();
	expandtk = asu64(R1);
	asi64(R1) = cc_decls_slineno;
	asu64(R2) = expandtk;
	asu64(R3) = m;
	R4 = 100;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	cc_lex_expandpredefmacro(asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = expandtk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
	goto L5896;
	goto L5881;
L5895:
	R1 = 0;
	noexpandflag = asi64(R1);
	goto L5886;
L5881:
	goto L5878;
L5880:
// cc_lex.scantokenseq.simpletoken:
L5886:
	asu64(R1) = tk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
L5878:
// cc_lex.scantokenseq.skip:
L5889:
	asu64(R1) = tk;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5898;
	goto L5877;
L5898:
// cc_lex.scantokenseq.skip2:
L5896:
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
L5876:
	asu64(R1) = tk;
	if (asu64(R1)) goto L5875;
L5877:
	asu64(R1) = expanded;
	asi64(R1) = *toi64p(R1);
	if (!asi64(R1)) goto L5900;
	asu64(R1) = newtk;
	tk = asu64(R1);
	goto L5861;
L5900:
	asu64(R1) = newtk;
	goto L5860;
L5860:
	return asu64(R1);
}

static i64 cc_lex_readmacrocall(u64 d, u64 args, u64 tksource) {
    u64 R1, R2, R3; 
	i64 nparams;
	i64 lbcount;
	i64 paramno;
	i64 nargs;
	i64 usesvargs;
	i64 varg;
	u64 tklist;
	u64 tklistx;
	asu64(R1) = tksource;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5903;
	R1 = tou64("rmc: no '('");
	cc_lex_lxerror(asu64(R1));
L5903:
	asu64(R1) = d;
	R2 = 111;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nparams = asi64(R1);
	R1 = 0;
	nargs = asi64(R1);
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5905;
	asu64(R1) = tksource;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5907;
	R1 = tou64("rmc: ')' expected");
	cc_lex_lxerror(asu64(R1));
L5907:
	R1 = 0;
	goto L5901;
L5905:
	R1 = 1;
	paramno = asi64(R1);
	R1 = 1;
	lbcount = asi64(R1);
	R1 = 0;
	R2 = R1;
	tklistx = asu64(R2);
	tklist = asu64(R1);
	asu64(R1) = d;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	usesvargs = asi64(R1);
	R1 = 0;
	varg = asi64(R1);
L5908:
	asi64(R1) = paramno;
	asi64(R2) = nparams;
	if (asi64(R1) != asi64(R2)) goto L5911;
	asi64(R1) = usesvargs;
	if (!asi64(R1)) goto L5911;
	R1 = 1;
	varg = asi64(R1);
L5911:
	asu64(R1) = tksource;
	cc_lex_lexa(asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5913;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L5914;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5915;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5916;
	goto L5917;
L5913:
	asi64(R1) = lbcount;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5919;
	asi64(R1) = varg;
	if (asi64(R1)) goto L5919;
	asu64(R1) = tklist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5921;
	asu64(R1) = cc_lex_alloctokenz();
	tklist = asu64(R1);
	asi64(R1) = cc_lex_getfileno();
	asu64(R2) = tklist;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	R1 = 66;
	asu64(R2) = tklist;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5921:
	asu64(R1) = tklist;
	asu64(R2) = args;
	asi64(R3) = paramno;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = R1;
	tklistx = asu64(R2);
	tklist = asu64(R1);
	R1 = (u64)&paramno;
	(*toi64p(R1)) += 1;
	goto L5918;
L5919:
	goto L5922;
L5918:
	goto L5912;
L5914:
	R1 = tou64("EOS in macro call");
	cc_lex_lxerror(asu64(R1));
	goto L5912;
L5915:
	R1 = (u64)&lbcount;
	(*toi64p(R1)) += 1;
	goto L5922;
	goto L5912;
L5916:
	asi64(R1) = lbcount;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L5924;
	R1 = (u64)&lbcount;
	(*toi64p(R1)) -=1;
	R1 = (u64)&tklistx;
	R2 = (u64)&tklist;
	cc_lex_addlist_nextlx(asu64(R2), asu64(R1));
	goto L5923;
L5924:
	asu64(R1) = tklist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5926;
	asu64(R1) = cc_lex_alloctokenz();
	tklist = asu64(R1);
	asi64(R1) = cc_lex_getfileno();
	asu64(R2) = tklist;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	R1 = 66;
	asu64(R2) = tklist;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5926:
	asu64(R1) = tklist;
	asu64(R2) = args;
	asi64(R3) = paramno;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L5909;
L5923:
	goto L5912;
L5917:
// cc_lex.readmacrocall.addtoken:
L5922:
	R1 = (u64)&tklistx;
	R2 = (u64)&tklist;
	cc_lex_addlist_nextlx(asu64(R2), asu64(R1));
L5912:
	goto L5908;
L5909:
	asi64(R1) = paramno;
	asi64(R2) = nparams;
	if (asi64(R1) == asi64(R2)) goto L5928;
	asi64(R1) = paramno;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R2) = nparams;
	if (asi64(R1) != asi64(R2)) goto L5930;
	asi64(R1) = usesvargs;
	if (!asi64(R1)) goto L5930;
	R1 = 0;
	asu64(R2) = args;
	asi64(R3) = nparams;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L5929;
L5930:
	R1 = tou64("Wrong # macro params");
	cc_lex_lxerror(asu64(R1));
L5929:
L5928:
	asi64(R1) = nparams;
	goto L5901;
L5901:
	return asi64(R1);
}

static u64 cc_lex_substituteargs(u64 m, u64 args, u64 expargs, i64 nargs, u64 macrostack) {
    u64 R1, R2, R3, R4; 
	u64 params;
	u64 seq;
	u64 seqstart;
	u64 lasttoken;
	u64 newtk;
	u64 newtkx;
	u64 niltk;
	u64 tkexp;
	struct $B18 tk;
	i64 n;
	i64 i;
	i64 expanded;
	struct $B46 hhpoints;
	i64 nhashhash;
	asu64(R1) = m;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	params = asu64(R1);
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	seqstart = asu64(R2);
	seq = asu64(R1);
	R1 = 0;
	R2 = R1;
	newtkx = asu64(R2);
	newtk = asu64(R1);
	R1 = 0;
	nhashhash = asi64(R1);
	R1 = 0;
	lasttoken = asu64(R1);
	goto L5933;
L5932:
	asu64(R1) = seq;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5936;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5937;
	goto L5938;
L5936:
	asi64(R1) = nargs;
	if (!asi64(R1)) goto L5940;
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
	asu64(R1) = seq;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5942;
	R1 = tou64("# at end");
	cc_lex_lxerror(asu64(R1));
L5942:
	asu64(R1) = seq;
	R2 = 23;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L5944;
	R1 = tou64("# not followed by param");
	cc_lex_lxerror(asu64(R1));
L5944:
	asu64(R1) = seq;
	R2 = 28;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	R1 = (u64)&tk;
	asu64(R2) = args;
	asi64(R3) = n;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	cc_lex_stringify(asu64(R2), asu64(R1));
	R1 = (u64)&tk;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
	goto L5939;
L5940:
	asu64(R1) = seq;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken(asu64(R3), asu64(R2), asu64(R1));
	R1 = 6;
	asu64(R2) = newtkx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5939:
	goto L5935;
L5937:
	asu64(R1) = seq;
	asu64(R2) = seqstart;
	if (asu64(R1) != asu64(R2)) goto L5946;
	R1 = tou64("## at start");
	cc_lex_lxerror(asu64(R1));
L5946:
	asi64(R1) = nhashhash;
	R2 = 250;
	if (asi64(R1) < asi64(R2)) goto L5948;
	R1 = tou64("Too many ##");
	cc_lex_lxerror(asu64(R1));
L5948:
	asu64(R1) = newtkx;
	R2 = (u64)&hhpoints;
	R3 = (u64)&nhashhash;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L5935;
L5938:
	asu64(R1) = seq;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L5950;
	asu64(R1) = seq;
	R2 = 23;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L5950;
	asi64(R1) = nargs;
	if (!asi64(R1)) goto L5950;
	asu64(R1) = seq;
	R2 = 28;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5954;
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5953;
L5954:
	asu64(R1) = lasttoken;
	if (!asu64(R1)) goto L5952;
	asu64(R1) = lasttoken;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5952;
L5953:
	asu64(R1) = args;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
	goto L5951;
L5952:
	asu64(R1) = expargs;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	tkexp = asu64(R1);
	asu64(R1) = tkexp;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5956;
	R1 = (u64)&expanded;
	asu64(R2) = macrostack;
	asu64(R3) = args;
	asi64(R4) = n;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	asu64(R1) = cc_lex_scantokenseq(asu64(R3), asu64(R2), asu64(R1));
	R2 = R1;
	asu64(R3) = expargs;
	asi64(R4) = n;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	tkexp = asu64(R1);
L5956:
	asu64(R1) = tkexp;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_seq(asu64(R3), asu64(R2), asu64(R1));
L5951:
	goto L5949;
L5950:
// cc_lex.substituteargs.doother:
	asu64(R1) = seq;
	R2 = (u64)&newtkx;
	R3 = (u64)&newtk;
	cc_lex_addlisttoken_copy(asu64(R3), asu64(R2), asu64(R1));
L5949:
L5935:
	asu64(R1) = seq;
	lasttoken = asu64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
L5933:
	asu64(R1) = seq;
	if (asu64(R1)) goto L5932;
	asi64(R1) = nhashhash;
	if (!asi64(R1)) goto L5959;
	R1 = 0;
	niltk = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nhashhash;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5962;
L5960:
	asi64(R1) = i;
	asi64(R2) = nhashhash;
	if (asi64(R1) >= asi64(R2)) goto L5964;
	R1 = (u64)&hhpoints;
	asi64(R2) = i;
	R1 += (i64)R2*8;
	goto L5963;
L5964:
	R1 = (u64)&niltk;
L5963:
	R2 = (u64)&hhpoints;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	cc_lex_pastetokens(asu64(R2), asu64(R1));
	i += 1; if (i <= nhashhash) goto L5960;
L5962:
L5959:
	asu64(R1) = newtk;
	goto L5931;
L5931:
	return asu64(R1);
}

static u64 cc_lex_strtoken(u64 lp, u64 length) {
    u64 R1, R2, R3, R4, R5; struct $B18 R1_B18; 
	u64 name;
	u64 s;
	struct $B18 l;
	asu64(R1) = lp;
	(R1_B18) = *(struct $B18*)(R1);
	l = (R1_B18);
	R1 = (u64)&l;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5967;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L5968;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L5968;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L5969;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L5970;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L5970;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L5971;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5972;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L5973;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L5974;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L5974;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L5974;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L5974;
	goto L5975;
L5967:
// cc_lex.strtoken.doname:
L5976:
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5965;
	goto L5966;
L5968:
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&l;
	asi64(R1) = cc_lex_getfilenox(asu64(R1));
	if (!asi64(R1)) goto L5978;
	R1 = (u64)&cc_decls_sourcefiletext;
	R2 = (u64)&l;
	asi64(R2) = cc_lex_getfilenox(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&l;
	asi64(R2) = cc_lex_getnumberoffsetx(asu64(R2));
	R1 += (i64)R2;
	goto L5965;
	goto L5977;
L5978:
	R1 = (u64)&cc_lex_pastedtokenlist;
	R2 = (u64)&l;
	R3 = 28;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L5965;
L5977:
	goto L5966;
L5969:
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&l;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5965;
	goto L5966;
L5970:
	R1 = 34;
	asu64(R2) = length;
	R3 = (u64)&l;
	R4 = 24;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	R4 = (u64)&l;
	R5 = 0;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = cc_lex_strstring(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	goto L5965;
	goto L5966;
L5971:
	R1 = 39;
	asu64(R2) = length;
	R3 = (u64)&l;
	R4 = 24;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	R4 = (u64)&l;
	R5 = 0;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = cc_lex_strstring(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	goto L5965;
	goto L5966;
L5972:
	asi64(R1) = cc_lex_dowhitespace;
	if (!asi64(R1)) goto L5980;
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = length;
	asi64(R1) = *toi64p(R1);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	R1 = 10;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&l;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	R2 = (u64)&l;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	R4 = 1;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L5979;
L5980:
	R1 = 1;
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = tou64("\n");
	goto L5965;
L5979:
	asu64(R1) = s;
	goto L5965;
	goto L5966;
L5973:
	R1 = 0;
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = tou64("");
	goto L5965;
	goto L5966;
L5974:
	goto L5976;
	goto L5966;
L5975:
	R1 = (u64)&cc_tables_shortsymbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	name = asu64(R1);
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	R2 = R1;
	asu64(R3) = length;
	*toi64p(R3) = asi64(R2);
	if (!asi64(R1)) goto L5982;
	asu64(R1) = name;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 107;
	if (asu64(R1) == asu64(R2)) goto L5984;
	asu64(R1) = name;
	goto L5965;
	goto L5983;
L5984:
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	R1 += (i64)R2;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = length;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&l;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	R1 += (i64)R2;
	goto L5965;
L5983:
	goto L5981;
L5982:
	R1 = tou64("");
	goto L5965;
L5981:
L5966:
	R1 = tou64("");
	goto L5965;
L5965:
	return asu64(R1);
}

static u64 cc_lex_strstring(u64 s, i64 length, u64 newlength, i64 quotechar) {
    u64 R1, R2, R3; 
	u64 t;
	u64 u;
	asi64(R1) = length;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = 4;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	u = asu64(R2);
	t = asu64(R1);
	asi64(R1) = quotechar;
	if (!asi64(R1)) goto L5987;
	asi64(R1) = quotechar;
	asu64(R2) = u;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&u;
	(*tou64p(R1)) += 1;
L5987:
	asi64(R1) = length;
	asu64(R2) = u;
	asu64(R3) = s;
	asi64(R1) = cc_lib_convertstringc(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = t;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = newlength;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = quotechar;
	if (!asi64(R1)) goto L5989;
	asi64(R1) = quotechar;
	asu64(R2) = t;
	asu64(R3) = newlength;
	asi64(R3) = *toi64p(R3);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = newlength;
	(*toi64p(R1)) += 1;
L5989:
	asu64(R1) = t;
	goto L5985;
L5985:
	return asu64(R1);
}

static void cc_lex_emittoken(u64 lp, u64 dest, i64 forcespace) {
    u64 R1, R2, R3; 
	i64 length;
	u64 s;
	asu64(R1) = lp;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L5992;
	asi64(R1) = cc_lex_lasttoken;
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L5992;
	goto L5990;
L5992:
	R1 = (u64)&length;
	asu64(R2) = lp;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	asi64(R1) = forcespace;
	if (asi64(R1)) goto L5995;
	asu64(R1) = lp;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = cc_lex_lasttoken;
	asi64(R1) = cc_lex_needspace(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L5994;
L5995:
	R1 = 32;
	asu64(R2) = dest;
	mlib_gs_char(asu64(R2), asi64(R1));
L5994:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_gs_strn(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = lp;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_lex_lasttoken = asi64(R1);
L5990:
	return;
}

static void cc_lex_showtoken(u64 lp) {
    u64 R1, R2, R3; 
// PROC LOCAL STATICS GO HERE
	static u64 cc_lex_showtoken_dest = (u64)&cc_lex_showtoken_buffer;
	asu64(R1) = cc_lex_showtoken_dest;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	asu64(R2) = cc_lex_showtoken_dest;
	asu64(R3) = lp;
	cc_lex_emittoken(asu64(R3), asu64(R2), asi64(R1));
	msysc_m$print_startcon();
	R1 = tou64("v");
	asu64(R2) = cc_lex_showtoken_dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(".*");
	asu64(R2) = cc_lex_showtoken_dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	return;
}

static void cc_lex_stringify(u64 seq, u64 dest) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	i64 addspace;
// PROC LOCAL STATICS GO HERE
	static u64 cc_lex_stringify_deststr = (u64)&cc_lex_stringify_buffer;
	R1 = 63;
	asu64(R2) = dest;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = dest;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5999;
	R1 = (u64)&length;
	asu64(R2) = seq;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = dest;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = s;
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5997;
L5999:
	asu64(R1) = cc_lex_stringify_deststr;
	mlib_gs_init(asu64(R1));
	R1 = 0;
	cc_lex_lasttoken = asi64(R1);
	R1 = 0;
	addspace = asi64(R1);
	goto L6001;
L6000:
	asi64(R1) = addspace;
	asu64(R2) = cc_lex_stringify_deststr;
	asu64(R3) = seq;
	cc_lex_emittoken(asu64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	addspace = asi64(R1);
	asu64(R1) = seq;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	seq = asu64(R1);
L6001:
	asu64(R1) = seq;
	if (asu64(R1)) goto L6000;
	asi64(R1) = length;
	asu64(R2) = dest;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = cc_lex_stringify_deststr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = cc_lex_stringify_deststr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5997:
	return;
}

static void cc_lex_pastetokens(u64 tk, u64 tknext) {
    u64 R1, R2, R3, R4; struct $B18 R1_B18; 
	u64 tk2;
	i64 length1;
	i64 length2;
	u64 s;
	u64 t;
	u64 u;
	struct $B18 oldtoken;
	struct $B18 token;
	u64 oldlxsptr;
	i64 oldlx_stackindex;
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk2 = asu64(R1);
	asu64(R1) = tk2;
	asu64(R2) = tknext;
	asu64(R2) = *tou64p(R2);
	if (asu64(R1) != asu64(R2)) goto L6005;
	asu64(R1) = tk;
	asu64(R2) = tknext;
	*tou64p(R2) = asu64(R1);
L6005:
	asu64(R1) = tk2;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = tk;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L6007;
	asu64(R1) = tk2;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L6009;
	goto L6008;
L6009:
	asu64(R1) = tk2;
	(R1_B18) = *(struct $B18*)(R1);
	asu64(R2) = tk;
	*(struct $B18*)(R2) = (R1_B18);
L6008:
	goto L6006;
L6007:
	asu64(R1) = tk2;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L6010;
	goto L6006;
L6010:
	R1 = (u64)&length1;
	asu64(R2) = tk;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	s = asu64(R1);
	R1 = (u64)&length2;
	asu64(R2) = tk2;
	asu64(R1) = cc_lex_strtoken(asu64(R2), asu64(R1));
	t = asu64(R1);
	asi64(R1) = length1;
	asi64(R2) = length2;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	u = asu64(R1);
	asi64(R1) = length1;
	asu64(R2) = s;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = length2;
	asu64(R2) = t;
	asu64(R3) = u;
	asi64(R4) = length1;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = u;
	asi64(R3) = length1;
	R2 += (i64)R3;
	asi64(R3) = length2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cc_lex_npastedtokens;
	R2 = 87000;
	if (asi64(R1) < asi64(R2)) goto L6012;
	R1 = tou64("Too many pasted tokens");
	cc_lex_lxerror(asu64(R1));
L6012:
	asu64(R1) = u;
	R2 = (u64)&cc_lex_pastedtokenlist;
	R3 = (u64)&cc_lex_npastedtokens;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	(R1_B18) = cc_decls_nextlx;
	oldtoken = (R1_B18);
	asu64(R1) = cc_lex_lxsptr;
	oldlxsptr = asu64(R1);
	asi64(R1) = cc_lex_lx_stackindex;
	oldlx_stackindex = asi64(R1);
	asu64(R1) = u;
	cc_lex_lxsptr = asu64(R1);
	R1 = 0;
	cc_lex_lx_stackindex = asi64(R1);
	R1 = 0;
	cc_lex_setfileno(asi64(R1));
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 16;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	cc_lex_lexreadtoken();
	(R1_B18) = cc_decls_nextlx;
	token = (R1_B18);
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L6014;
L6014:
	(R1_B18) = oldtoken;
	cc_decls_nextlx = (R1_B18);
	asu64(R1) = oldlxsptr;
	cc_lex_lxsptr = asu64(R1);
	asi64(R1) = oldlx_stackindex;
	cc_lex_lx_stackindex = asi64(R1);
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&token;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&token;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	asi64(R1) = cc_lex_npastedtokens;
	R2 = (u64)&token;
	R3 = 28;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 8;
	R2 = (u64)&token;
	R3 = 23;
	R2 += (i64)R3;
	*tou8p(R2) |= asu8(R1);
	(R1_B18) = token;
	asu64(R2) = tk;
	*(struct $B18*)(R2) = (R1_B18);
L6006:
	return;
}

static i64 cc_lex_getifexpr() {
    u64 R1, R2; 
	i64 sx;
	i64 x;
	cc_lex_lexm();
	R1 = (u64)&sx;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	x = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6017;
	R1 = tou64("#if:eol expected");
	cc_lex_lxerror(asu64(R1));
L6017:
	asi64(R1) = x;
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	goto L6015;
L6015:
	return asi64(R1);
}

static i64 cc_lex_evalcondexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 z;
	i64 sy;
	i64 sz;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalorexpr(asu64(R1));
	x = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L6020;
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	y = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6022;
	R1 = tou64(": expected");
	cc_lex_lxerror(asu64(R1));
L6022:
	cc_lex_lexm();
	R1 = (u64)&sz;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	z = asi64(R1);
	asi64(R1) = x;
	if (!asi64(R1)) goto L6024;
	asi64(R1) = sy;
	asu64(R2) = sx;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = y;
	x = asi64(R1);
	goto L6023;
L6024:
	asi64(R1) = sz;
	asu64(R2) = sx;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = z;
	x = asi64(R1);
L6023:
L6020:
	asi64(R1) = x;
	goto L6018;
L6018:
	return asi64(R1);
}

static i64 cc_lex_evalorexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalandexpr(asu64(R1));
	x = asi64(R1);
	goto L6027;
L6026:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalandexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = x;
	if (asi64(R1)) goto L6031;
	asi64(R1) = y;
	if (!asi64(R1)) goto L6030;
L6031:
	R1 = 1;
	goto L6029;
L6030:
	R1 = 0;
L6029:
	x = asi64(R1);
L6027:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L6026;
	asi64(R1) = x;
	goto L6025;
L6025:
	return asi64(R1);
}

static i64 cc_lex_evalandexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaliorexpr(asu64(R1));
	x = asi64(R1);
	goto L6034;
L6033:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaliorexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = x;
	if (!asi64(R1)) goto L6037;
	asi64(R1) = y;
	if (!asi64(R1)) goto L6037;
	R1 = 1;
	goto L6036;
L6037:
	R1 = 0;
L6036:
	x = asi64(R1);
L6034:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L6033;
	asi64(R1) = x;
	goto L6032;
L6032:
	return asi64(R1);
}

static i64 cc_lex_evaliorexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalixorexpr(asu64(R1));
	x = asi64(R1);
	goto L6040;
L6039:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalixorexpr(asu64(R1));
	R2 = (u64)&x;
	*toi64p(R2) |= asi64(R1);
L6040:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6039;
	asi64(R1) = x;
	goto L6038;
L6038:
	return asi64(R1);
}

static i64 cc_lex_evalixorexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaliandexpr(asu64(R1));
	x = asi64(R1);
	goto L6044;
L6043:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaliandexpr(asu64(R1));
	R2 = (u64)&x;
	*toi64p(R2) ^= asi64(R1);
L6044:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L6043;
	asi64(R1) = x;
	goto L6042;
L6042:
	return asi64(R1);
}

static i64 cc_lex_evaliandexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaleqexpr(asu64(R1));
	x = asi64(R1);
	goto L6048;
L6047:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaleqexpr(asu64(R1));
	R2 = (u64)&x;
	*toi64p(R2) &= asi64(R1);
L6048:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L6047;
	asi64(R1) = x;
	goto L6046;
L6046:
	return asi64(R1);
}

static i64 cc_lex_evaleqexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalcmpexpr(asu64(R1));
	x = asi64(R1);
	goto L6052;
L6051:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalcmpexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L6055;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L6056;
	goto L6057;
L6055:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	x = asi64(R1);
	goto L6054;
L6056:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	x = asi64(R1);
	goto L6054;
L6057:
L6054:
L6052:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L6051;
	asi64(R1) = opc;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L6051;
	asi64(R1) = x;
	goto L6050;
L6050:
	return asi64(R1);
}

static i64 cc_lex_evalcmpexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalshiftexpr(asu64(R1));
	x = asi64(R1);
	goto L6060;
L6059:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalshiftexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L6063;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6064;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L6065;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L6066;
	goto L6067;
L6063:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	x = asi64(R1);
	goto L6062;
L6064:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	x = asi64(R1);
	goto L6062;
L6065:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	x = asi64(R1);
	goto L6062;
L6066:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >  asi64(R2);
	x = asi64(R1);
	goto L6062;
L6067:
L6062:
L6060:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L6059;
	asi64(R1) = opc;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6059;
	asi64(R1) = opc;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L6059;
	asi64(R1) = opc;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L6059;
	asi64(R1) = x;
	goto L6058;
L6058:
	return asi64(R1);
}

static i64 cc_lex_evalshiftexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evaladdexpr(asu64(R1));
	x = asi64(R1);
	goto L6070;
L6069:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evaladdexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6073;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L6074;
	goto L6075;
L6073:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) >>= asi64(R2);
	x = asi64(R1);
	goto L6072;
L6074:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) <<= asi64(R2);
	x = asi64(R1);
	goto L6072;
L6075:
L6072:
L6070:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L6069;
	asi64(R1) = opc;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6069;
	asi64(R1) = x;
	goto L6068;
L6068:
	return asi64(R1);
}

static i64 cc_lex_evaladdexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalmulexpr(asu64(R1));
	x = asi64(R1);
	goto L6078;
L6077:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalmulexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = opc;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L6081;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6082;
	goto L6083;
L6081:
	asi64(R1) = y;
	R2 = (u64)&x;
	*toi64p(R2) += asi64(R1);
	goto L6080;
L6082:
	asi64(R1) = y;
	R2 = (u64)&x;
	*toi64p(R2) -= asi64(R1);
	goto L6080;
L6083:
L6080:
L6078:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L6077;
	asi64(R1) = opc;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6077;
	asi64(R1) = x;
	goto L6076;
L6076:
	return asi64(R1);
}

static i64 cc_lex_evalmulexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 y;
	i64 sy;
	i64 opc;
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalunaryexpr(asu64(R1));
	x = asi64(R1);
	goto L6086;
L6085:
	cc_lex_lexm();
	R1 = (u64)&sy;
	asi64(R1) = cc_lex_evalunaryexpr(asu64(R1));
	y = asi64(R1);
	asi64(R1) = y;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6089;
	asi64(R1) = opc;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6089;
	R1 = tou64("#if:div by zero");
	cc_lex_lxerror(asu64(R1));
L6089:
	asi64(R1) = opc;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6091;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L6092;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6093;
	goto L6094;
L6091:
	asi64(R1) = y;
	R2 = (u64)&x;
	*toi64p(R2) *= asi64(R1);
	goto L6090;
L6092:
	asi64(R1) = x;
	asi64(R2) = y;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	x = asi64(R1);
	goto L6090;
L6093:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) %= asi64(R2);
	x = asi64(R1);
	goto L6090;
L6094:
L6090:
L6086:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6085;
	asi64(R1) = opc;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L6085;
	asi64(R1) = opc;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6085;
	asi64(R1) = x;
	goto L6084;
L6084:
	return asi64(R1);
}

static i64 cc_lex_evalunaryexpr(u64 sx) {
    u64 R1, R2; 
	i64 x;
	i64 opc;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L6097;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6097;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6097;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6097;
	goto L6098;
L6097:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	cc_lex_lexm();
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalunaryexpr(asu64(R1));
	x = asi64(R1);
	asi64(R1) = opc;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L6100;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6101;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L6102;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L6103;
	goto L6104;
L6100:
	asi64(R1) = x;
	goto L6095;
	goto L6099;
L6101:
	asi64(R1) = x;
	asi64(R1) = -asi64(R1);
	goto L6095;
	goto L6099;
L6102:
	asi64(R1) = x;
	asi64(R1) = !asi64(R1);
	goto L6095;
	goto L6099;
L6103:
	asi64(R1) = x;
	asi64(R1) = ~asi64(R1);
	goto L6095;
	goto L6099;
L6104:
L6099:
	goto L6096;
L6098:
L6096:
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalterm(asu64(R1));
	goto L6095;
L6095:
	return asi64(R1);
}

static i64 cc_lex_evalterm(u64 sx) {
    u64 R1, R2, R3, R4; 
	i64 res;
	i64 lb;
	R1 = 1;
	asu64(R2) = sx;
	*toi64p(R2) = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6107;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L6108;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L6109;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6110;
	goto L6111;
L6107:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L6113;
	R2 = 91;
	if (asi64(R1) == asi64(R2)) goto L6114;
	goto L6115;
L6113:
	R1 = 1;
	cc_lex_noexpand = asi64(R1);
	R1 = 0;
	lb = asi64(R1);
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6117;
	R1 = 1;
	lb = asi64(R1);
	cc_lex_lexm();
L6117:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6119;
	R1 = tou64("defined?");
	cc_lex_lxerror(asu64(R1));
L6119:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	res = asi64(R1);
	cc_lex_lexm();
	asi64(R1) = lb;
	if (!asi64(R1)) goto L6121;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6123;
	R1 = tou64("')' expected");
	cc_lex_lxerror(asu64(R1));
L6123:
	cc_lex_lexm();
L6121:
	R1 = 0;
	cc_lex_noexpand = asi64(R1);
	goto L6112;
L6114:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6125;
	R1 = tou64("'(' expected");
	cc_lex_lxerror(asu64(R1));
L6125:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6127;
	R1 = tou64("name expected");
	cc_lex_lxerror(asu64(R1));
L6127:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L6129;
	goto L6130;
L6129:
	R1 = (u64)&cc_tables_typespecsizes;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 100;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	res = asi64(R1);
	goto L6128;
L6130:
	R1 = tou64("sizeof2");
	cc_lex_lxerror(asu64(R1));
L6128:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6132;
	R1 = tou64("')' expected");
	cc_lex_lxerror(asu64(R1));
L6132:
	cc_lex_lexm();
	goto L6112;
L6115:
	cc_lex_lexm();
	R1 = 0;
	goto L6105;
L6112:
	goto L6106;
L6108:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	res = asi64(R1);
	cc_lex_lexm();
	goto L6106;
L6109:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6134;
	R1 = 0;
	res = asi64(R1);
	goto L6133;
L6134:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	res = asi64(R1);
L6133:
	cc_lex_lexm();
	goto L6106;
L6110:
	cc_lex_lexm();
	asu64(R1) = sx;
	asi64(R1) = cc_lex_evalcondexpr(asu64(R1));
	res = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6136;
	R1 = tou64(") expected");
	cc_lex_lxerror(asu64(R1));
L6136:
	cc_lex_lexm();
	goto L6106;
L6111:
	R1 = (u64)&cc_decls_nextlx;
	cc_lex_printsymbol(asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	cc_lex_printstrn(asu64(R3), asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("evalterm?");
	cc_lex_lxerror(asu64(R1));
L6106:
	asi64(R1) = res;
	goto L6105;
L6105:
	return asi64(R1);
}

static i64 cc_lex_getifdef() {
    u64 R1, R2; 
	i64 res;
	u64 d;
	R1 = 1;
	cc_lex_noexpand = asi64(R1);
	cc_lex_lexreadtoken();
	R1 = 0;
	cc_lex_noexpand = asi64(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6139;
	R1 = tou64("Name expected");
	cc_lex_lxerror(asu64(R1));
L6139:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 0;
	res = asi64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6141;
	R1 = 1;
	res = asi64(R1);
	goto L6140;
L6141:
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 69;
	if (asi64(R1) != asi64(R2)) goto L6142;
	R1 = 1;
	res = asi64(R1);
L6142:
L6140:
	cc_lex_lexreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6144;
	R1 = tou64("EOL expected");
	cc_lex_lxerror(asu64(R1));
L6144:
	asi64(R1) = res;
	goto L6137;
L6137:
	return asi64(R1);
}

static i64 cc_lex_skipcode() {
    u64 R1, R2; 
	i64 level;
	i64 dir;
	u64 pp;
	R1 = 0;
	level = asi64(R1);
L6146:
	cc_lex_fastreadtoken();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6149;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L6150;
	goto L6151;
L6149:
	asi64(R1) = cc_lex_getlexdirective();
	dir = asi64(R1);
	asi64(R1) = dir;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6153;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6153;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6153;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6154;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6154;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6155;
	goto L6156;
L6153:
	R1 = (u64)&level;
	(*toi64p(R1)) += 1;
	goto L6152;
L6154:
	asi64(R1) = level;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6158;
	asi64(R1) = dir;
	goto L6145;
L6158:
	goto L6152;
L6155:
	asi64(R1) = level;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6160;
	asi64(R1) = dir;
	goto L6145;
L6160:
	R1 = (u64)&level;
	(*toi64p(R1)) -=1;
	goto L6152;
L6156:
L6152:
	goto L6148;
L6150:
	R1 = tou64("#if:Unexpected eof");
	cc_lex_lxerror(asu64(R1));
	goto L6148;
L6151:
L6148:
	goto L6146;
	R1 = 0;
	goto L6145;
L6145:
	return asi64(R1);
}

static void cc_lex_freetokens(u64 tk) {
    u64 R1, R2; 
	u64 nexttk;
	goto L6163;
L6162:
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nexttk = asu64(R1);
	asu64(R1) = nexttk;
	tk = asu64(R1);
L6163:
	asu64(R1) = tk;
	if (asu64(R1)) goto L6162;
	return;
}

static void cc_lex_fastreadtoken() {
    u64 R1, R2, R3; 
	i64 c;
	i64 csum;
	i64 hsum;
	i64 commentseen;
	i64 dodir;
	i64 j;
	u64 pstart;
	u64 p;
	u64 ss;
L6166:
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	switch (asi64(R1)) {
	case 0: goto L6191;
	case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 11: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 36: case 37: case 38: case 40: case 41: case 42: case 43: case 44: case 45: case 46: goto L6169;
	case 10: goto L6190;
	case 12: goto L6194;
	case 13: goto L6189;
	case 34: goto L6188;
	case 35: goto L6170;
	case 39: goto L6187;
	case 47: goto L6182;
	default: goto L6169;
    };
// SWITCH
L6170:
	asu64(R1) = cc_lex_lxsptr;
	R2 = 2;
	R1 -= (i64)R2;
	p = asu64(R1);
	R1 = 0;
	dodir = asi64(R1);
	goto L6172;
L6171:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L6175;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L6176;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L6176;
	goto L6177;
L6175:
	R1 = 1;
	dodir = asi64(R1);
	goto L6173;
	goto L6174;
L6176:
	goto L6174;
L6177:
	goto L6173;
L6174:
	R1 = (u64)&p;
	(*tou64p(R1)) -=1;
L6172:
	asu64(R1) = p;
	asu64(R2) = cc_lex_lxstart;
	if (asu64(R1) >= asu64(R2)) goto L6171;
L6173:
	asi64(R1) = dodir;
	if (asi64(R1)) goto L6180;
	asu64(R1) = p;
	asu64(R2) = cc_lex_lxstart;
	if (asu64(R1) >= asu64(R2)) goto L6179;
L6180:
	R1 = 4;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6165;
	goto L6178;
L6179:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) != asu64(R2)) goto L6181;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
L6181:
L6178:
	goto L6166;
L6182:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L6184;
	R2 = 42;
	if (asu64(R1) == asu64(R2)) goto L6185;
	goto L6186;
L6184:
	cc_lex_readlinecomment();
	goto L6183;
L6185:
	cc_lex_readblockcomment();
	goto L6183;
L6186:
L6183:
	goto L6166;
L6187:
	R1 = 0;
	R2 = 39;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L6166;
L6188:
	R1 = 0;
	R2 = 34;
	cc_lex_lxreadstring(asi64(R2), asi64(R1));
	goto L6166;
L6189:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L6166;
L6190:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 16;
	R1 += (i64)R2;
	(*tou32p(R1)) += 1;
	R1 = 56;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6166;
L6191:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asi64(R1) = cc_lex_lx_stackindex;
	if (!asi64(R1)) goto L6193;
	cc_lex_unstacksourcefile();
	goto L6192;
L6193:
	R1 = 57;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6165;
L6192:
	goto L6166;
L6194:
	goto L6166;
L6169:
	goto L6166;
L6165:
	return;
}

static u64 cc_lex_alloctoken() {
    u64 R1; 
	u64 tk;
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	tk = asu64(R1);
	asu64(R1) = tk;
	goto L6195;
L6195:
	return asu64(R1);
}

static u64 cc_lex_alloctokenz() {
    u64 R1, R2, R3; 
	u64 tk;
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	tk = asu64(R1);
	R1 = 0;
	asu64(R2) = tk;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = tk;
	goto L6196;
L6196:
	return asu64(R1);
}

static void cc_lex_expandpredefmacro(i64 pdmcode, u64 tk, i64 lineno) {
    u64 R1, R2, R3; 
	struct $B16 str;
	struct $B3 tm;
	u64 s;
	i64 fileno;
// PROC LOCAL STATICS GO HERE
	static struct $B29 cc_lex_expandpredefmacro_monthnames = {{
	(u64)"Jan",
	(u64)"Feb",
	(u64)"Mar",
	(u64)"Apr",
	(u64)"May",
	(u64)"Jun",
	(u64)"Jul",
	(u64)"Aug",
	(u64)"Sep",
	(u64)"Oct",
	(u64)"Nov",
	(u64)"Dec"    }};
	asi64(R1) = cc_lex_noexpand;
	if (!asi64(R1)) goto L6199;
	goto L6197;
L6199:
	asi64(R1) = pdmcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6201;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6202;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6203;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6204;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6205;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6206;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6207;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6208;
	goto L6209;
L6201:
	R1 = (u64)&tm;
	mwindows_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#-#-#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&tm;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_lex_expandpredefmacro_monthnames;
	R2 = (u64)&tm;
	R3 = 2;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("4");
	R2 = (u64)&tm;
	R3 = 0;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6200;
L6202:
	R1 = (u64)&tm;
	mwindows_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:#:#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("2");
	R2 = (u64)&tm;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 10;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 12;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6200;
L6203:
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = tk;
	asi64(R1) = cc_lex_getfilenox(asu64(R1));
	fileno = asi64(R1);
	asi64(R1) = fileno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6211;
	asi64(R1) = cc_decls_sfileno;
	fileno = asi64(R1);
L6211:
	asi64(R1) = cc_decls_sfileno;
	if (!asi64(R1)) goto L6213;
	R1 = (u64)&cc_decls_sourcefilenames;
	asi64(R2) = cc_decls_sfileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6212;
L6213:
	R1 = tou64("(File not available)");
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6212:
	goto L6200;
L6204:
	R1 = 63;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L6215;
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6214;
L6215:
	R1 = tou64("???");
	asu64(R2) = tk;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6214:
	goto L6200;
L6205:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = lineno;
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6200;
L6206:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6200;
L6207:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6200;
L6208:
	R1 = 59;
	asu64(R2) = tk;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu8(R1) = cc_decls_pci_target;
	R1 = toi64(tou8(R1));
	asu64(R2) = tk;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6200;
L6209:
	msysc_m$print_startcon();
	asi64(R1) = pdmcode;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("PDM");
	cc_lex_lxerror(asu64(R1));
L6200:
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L6217;
	asu64(R1) = tk;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = tk;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_decls_trefchar;
	asu64(R2) = tk;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6216;
L6217:
	R1 = 3;
	asu64(R2) = tk;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = tk;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_getstrint(asi64(R2), asu64(R1));
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = tk;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_lex_npastedtokens;
	R2 = 87000;
	if (asi64(R1) < asi64(R2)) goto L6219;
	R1 = tou64("2:Too many pasted tokens");
	cc_lex_lxerror(asu64(R1));
L6219:
	asu64(R1) = s;
	R2 = (u64)&cc_lex_pastedtokenlist;
	R3 = (u64)&cc_lex_npastedtokens;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	asu64(R2) = tk;
	cc_lex_setfilenox(asu64(R2), asi64(R1));
	asi64(R1) = cc_lex_npastedtokens;
	asu64(R2) = tk;
	R3 = 28;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L6216:
L6197:
	return;
}

static void cc_lex_dopragmadir() {
    u64 R1, R2, R3, R4; 
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6222;
	R1 = 4;
	R2 = tou64("pack");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6224;
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6226;
	R1 = tou64("'(' expected");
	cc_lex_lxerror(asu64(R1));
L6226:
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L6228;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6230;
	goto L6231;
L6230:
	R1 = 0;
	cc_decls_structpadding = asi64(R1);
	goto L6229;
L6231:
	goto L6232;
	R1 = tou64("Only pack(1) or () allowed");
	cc_lex_lxerror(asu64(R1));
L6229:
	cc_lex_lexm();
	goto L6227;
L6228:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L6233;
	R1 = 1;
	cc_decls_structpadding = asi64(R1);
L6233:
L6227:
	goto L6223;
L6224:
	R1 = 6;
	R2 = tou64("module");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6234;
	R1 = 77;
	cc_lex_addbuildinfo(asi64(R1));
	goto L6223;
L6234:
	R1 = 6;
	R2 = tou64("header");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6235;
	R1 = 72;
	cc_lex_addbuildinfo(asi64(R1));
	goto L6223;
L6235:
	R1 = 4;
	R2 = tou64("link");
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6236;
	R1 = 76;
	cc_lex_addbuildinfo(asi64(R1));
L6236:
L6223:
L6222:
// cc_lex.dopragmadir.finish:
L6232:
	goto L6238;
L6237:
	cc_lex_lexm();
L6238:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L6240;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L6237;
L6240:
	return;
}

static void cc_lex_addbuildinfo(i64 code) {
    u64 R1, R2, R3; 
	u64 file;
	i64 j;
	cc_lex_lexm();
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L6243;
	R1 = tou64("Str expected");
	cc_lex_lxerror(asu64(R1));
L6243:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	file = asu64(R1);
	asi64(R1) = code;
	R2 = 77;
	if (asi64(R1) == asi64(R2)) goto L6245;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L6246;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L6247;
	goto L6248;
L6245:
	asi64(R1) = cc_decls_npmodules;
	R2 = 199;
	if (asi64(R1) < asi64(R2)) goto L6250;
	R1 = tou64("TMM");
	cc_lex_lxerror(asu64(R1));
L6250:
	asu64(R1) = file;
	R2 = (u64)&cc_decls_pmodulelist;
	R3 = (u64)&cc_decls_npmodules;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6244;
L6246:
	asi64(R1) = cc_decls_npheaders;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L6252;
	R1 = tou64("TMH");
	cc_lex_lxerror(asu64(R1));
L6252:
	asu64(R1) = file;
	R2 = (u64)&cc_decls_pheaderlist;
	R3 = (u64)&cc_decls_npheaders;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6244;
L6247:
	asi64(R1) = cc_decls_nplibs;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L6254;
	R1 = tou64("TMLM");
	cc_lex_lxerror(asu64(R1));
L6254:
	asu64(R1) = file;
	R2 = (u64)&cc_decls_pliblist;
	R3 = (u64)&cc_decls_nplibs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6244;
L6248:
L6244:
	cc_lex_lexm();
	return;
}

static i64 cc_lex_needspace(i64 a, i64 b) {
    u64 R1, R2; 
	u64 aname;
	u64 bname;
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6257;
	R1 = 0;
	goto L6255;
L6257:
	R1 = (u64)&cc_tables_shortsymbolnames;
	asi64(R2) = a;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	aname = asu64(R1);
	R1 = (u64)&cc_tables_shortsymbolnames;
	asi64(R2) = b;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	bname = asu64(R1);
	asu64(R1) = bname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 110;
	if (asu64(R1) == asu64(R2)) goto L6259;
	R2 = 107;
	if (asu64(R1) == asu64(R2)) goto L6259;
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L6260;
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L6260;
	goto L6261;
L6259:
	asu64(R1) = aname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 110;
	if (asu64(R1) == asu64(R2)) goto L6263;
	R2 = 107;
	if (asu64(R1) == asu64(R2)) goto L6263;
	goto L6264;
L6263:
	R1 = 1;
	goto L6255;
	goto L6262;
L6264:
L6262:
	goto L6258;
L6260:
	asu64(R1) = aname;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L6266;
	R2 = 43;
	if (asu64(R1) == asu64(R2)) goto L6266;
	goto L6267;
L6266:
	R1 = 1;
	goto L6255;
	goto L6265;
L6267:
L6265:
	goto L6258;
L6261:
L6258:
	R1 = 0;
	goto L6255;
L6255:
	return asi64(R1);
}

static void cc_lex_dospecialinclude() {
    u64 R1, R2; 
	R1 = 1;
	R2 = tou64("mcc.h");
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
	asu64(R1) = cc_decls_dheaderfile;
	if (!asu64(R1)) goto L6270;
	R1 = 1;
	asu64(R2) = cc_decls_dheaderfile;
	cc_lex_stacksourcefile(asu64(R2), asi64(R1));
L6270:
	return;
}

static void cc_lex_setnumberoffset(i64 offset) {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_decls_nextlx;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 4278190080;
	asi64(R1) &= asi64(R2);
	asi64(R2) = offset;
	R3 = 16777215;
	asi64(R2) &= asi64(R3);
	asi64(R1) |= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void cc_lex_setfileno(i64 fileno) {
    u64 R1, R2, R3; 
	asi64(R1) = fileno;
	R2 = 255;
	asi64(R1) &= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 20;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_nextlx;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	asi64(R2) = fileno;
	R3 = 65280;
	asi64(R2) &= asi64(R3);
	R3 = 16;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void cc_lex_setfilenox(u64 tk, i64 fileno) {
    u64 R1, R2, R3; 
	asi64(R1) = fileno;
	R2 = 255;
	asi64(R1) &= asi64(R2);
	asu64(R2) = tk;
	R3 = 20;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = tk;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	asi64(R2) = fileno;
	R3 = 65280;
	asi64(R2) &= asi64(R3);
	R3 = 16;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asu64(R2) = tk;
	R3 = 28;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static i64 cc_lex_getfileno() {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_decls_nextlx;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 24;
	asi64(R1) >>= asi64(R2);
	R2 = 8;
	asi64(R1) <<= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	goto L6274;
L6274:
	return asi64(R1);
}

static i64 cc_lex_getfilenox(u64 tk) {
    u64 R1, R2, R3; 
	asu64(R1) = tk;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 24;
	asi64(R1) >>= asi64(R2);
	R2 = 8;
	asi64(R1) <<= asi64(R2);
	asu64(R2) = tk;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) |= asi64(R2);
	goto L6275;
L6275:
	return asi64(R1);
}

static i64 cc_lex_getnumberoffsetx(u64 tk) {
    u64 R1, R2; 
	asu64(R1) = tk;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	goto L6276;
L6276:
	return asi64(R1);
}

static void cc_lex_freehashtable() {
    u64 R1, R2, R3; 
	u64 d;
	u64 e;
	u64 f;
	i64 i;
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6280;
L6278:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6282;
	asu64(R1) = d;
	R2 = 107;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L6282;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6284;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_lex_freetokens(asu64(R1));
L6284:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	goto L6286;
L6285:
	asu64(R1) = f;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 128;
	asu64(R2) = f;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = e;
	f = asu64(R1);
L6286:
	asu64(R1) = f;
	if (asu64(R1)) goto L6285;
	R1 = 128;
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	goto L6281;
L6282:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6288;
	R1 = 0;
	asu64(R2) = d;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6288:
L6281:
	i += 1; if (i <= cc_decls_hstmask) goto L6278;
L6280:
	return;
}

static void cc_lex_regenlookup(u64 d) {
    u64 R1, R2, R3, R4; 
	i64 j;
	i64 wrapped;
	i64 length;
	u64 e;
	asu64(R1) = d;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = cc_lex_gethashvalue(asu64(R2), asi64(R1));
	asi64(R2) = cc_decls_hstmask;
	asi64(R1) &= asi64(R2);
	j = asi64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L6290:
	asu64(R1) = cc_decls_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	length = asi64(R1);
	asi64(R1) = length;
	if (asi64(R1)) goto L6293;
	R1 = 128;
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = j;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = d;
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = j;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_lex_nhstsymbols;
	(*toi64p(R1)) += 1;
	goto L6289;
L6293:
	asi64(R1) = length;
	asu64(R2) = d;
	R3 = 106;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L6295;
	asi64(R1) = length;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = e;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6297;
	R1 = tou64("regenhst dupl?");
	cc_lex_lxerror(asu64(R1));
L6297:
L6295:
	R1 = (u64)&j;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = cc_decls_hstsize;
	if (asi64(R1) < asi64(R2)) goto L6299;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L6301;
	R1 = tou64("REGENHST FULL?");
	mlib_abortprogram(asu64(R1));
L6301:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	j = asi64(R1);
L6299:
	goto L6290;
L6289:
	return;
}

static void cc_lex_newhashtable() {
    u64 R1, R2, R3; 
	u64 oldhashtable;
	i64 oldhstsize;
	u64 d;
	i64 av_1;
	i64 i;
	asu64(R1) = cc_decls_hashtable;
	oldhashtable = asu64(R1);
	asi64(R1) = cc_decls_hstsize;
	oldhstsize = asi64(R1);
	R1 = 2;
	R2 = (u64)&cc_decls_hstsize;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	cc_decls_hstmask = asi64(R1);
	R1 = 0;
	cc_lex_nhstsymbols = asi64(R1);
	R1 = 6;
	asi64(R2) = cc_decls_hstsize;
	asi64(R1) *= asi64(R2);
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	cc_lex_hstthreshold = asi64(R1);
	asi64(R1) = cc_decls_hstsize;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	cc_decls_hashtable = asu64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = cc_decls_hstmask;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6305;
L6303:
	R1 = 128;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = cc_decls_hashtable;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= cc_decls_hstmask) goto L6303;
L6305:
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = oldhstsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6308;
L6306:
	asu64(R1) = oldhashtable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6310;
	asu64(R1) = d;
	cc_lex_regenlookup(asu64(R1));
L6310:
	i += 1; if (i <= av_1) goto L6306;
L6308:
	asi64(R1) = oldhstsize;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = oldhashtable;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void cc_lex_old_readrealnumber(u64 pstart, u64 intstart, i64 intlen, i64 base) {
    u64 R1, R2, R3, R4; 
	u64 fractstart;
	i64 fractlen;
	i64 expon;
	i64 i;
	i64 c;
	i64 badexpon;
	r64 basex;
	r64 x;
	r64 expbase;
	struct $B47 realstr;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	R1 = 0;
	fractstart = asu64(R1);
	R1 = 0;
	fractlen = asi64(R1);
	R1 = 0;
	expon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L6313;
	R1 = (u64)&cc_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	fractstart = asu64(R1);
	asi64(R1) = base;
	asu64(R1) = cc_lex_scannumber(asi64(R1));
	asu64(R2) = fractstart;
	asi64(R1) -= asi64(R2);
	fractlen = asi64(R1);
L6313:
	R1 = 0;
	badexpon = asi64(R1);
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 101;
	if (asu64(R1) == asu64(R2)) goto L6315;
	R2 = 69;
	if (asu64(R1) == asu64(R2)) goto L6315;
	R2 = 112;
	if (asu64(R1) == asu64(R2)) goto L6316;
	R2 = 80;
	if (asu64(R1) == asu64(R2)) goto L6316;
	goto L6317;
L6315:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6319;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L6319:
	goto L6314;
L6316:
	asi64(R1) = base;
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L6321;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = (u64)&badexpon;
	asi64(R1) = cc_lex_readexponent(asu64(R1));
	expon = asi64(R1);
L6321:
	goto L6314;
L6317:
L6314:
	asi64(R1) = badexpon;
	if (!asi64(R1)) goto L6323;
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L6311;
L6323:
	asu64(R1) = cc_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 102;
	if (asu64(R1) == asu64(R2)) goto L6325;
	R2 = 70;
	if (asu64(R1) == asu64(R2)) goto L6325;
	R2 = 108;
	if (asu64(R1) == asu64(R2)) goto L6325;
	R2 = 76;
	if (asu64(R1) == asu64(R2)) goto L6325;
	goto L6326;
L6325:
	R1 = (u64)&cc_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L6324;
L6326:
	R1 = (u64)&cc_lex_alphamap;
	asu64(R2) = cc_lex_lxsptr;
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6328;
	asu64(R1) = pstart;
	cc_lex_readalphanumeric(asu64(R1));
	goto L6311;
L6328:
L6324:
	asi64(R1) = intlen;
	asi64(R2) = fractlen;
	asi64(R1) += asi64(R2);
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L6330;
	R1 = tou64("Real too long");
	cc_lex_lxerror(asu64(R1));
L6330:
	asi64(R1) = intlen;
	if (!asi64(R1)) goto L6332;
	asi64(R1) = intlen;
	asu64(R2) = intstart;
	R3 = (u64)&realstr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L6332:
	asi64(R1) = fractlen;
	if (!asi64(R1)) goto L6334;
	asi64(R1) = fractlen;
	asu64(R2) = fractstart;
	R3 = (u64)&realstr;
	R4 = 0;
	R3 += (i64)R4;
	asi64(R4) = intlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L6334:
	asi64(R1) = base;
	asr64(R1) = tor64(asi64(R1));
	R2 = R1;
	basex = asr64(R2);
	expbase = asr64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L6336;
	asi64(R1) = fractlen;
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	goto L6335;
L6336:
	asi64(R1) = fractlen;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	asr64(R1) = 2.000000000000000000e+000;
	expbase = asr64(R1);
L6335:
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = intlen;
	asi64(R2) = fractlen;
	asi64(R1) += asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6339;
L6337:
	R1 = (u64)&realstr;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L6341;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L6341;
	asr64(R1) = x;
	asr64(R2) = basex;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	R3 = 48;
	asi64(R2) -= asi64(R3);
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	x = asr64(R1);
	goto L6340;
L6341:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) <= asi64(R2)) goto L6342;
	asr64(R1) = x;
	asr64(R2) = basex;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	R2 = 97;
	asr64(R2) = tor64(asu64(R2));
	asr64(R1) -= asr64(R2);
	asr64(R2) = 1.000000000000000000e+001;
	asr64(R1) += asr64(R2);
	x = asr64(R1);
	goto L6340;
L6342:
	asr64(R1) = x;
	asr64(R2) = basex;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	R2 = 65;
	asr64(R2) = tor64(asu64(R2));
	asr64(R1) -= asr64(R2);
	asr64(R2) = 1.000000000000000000e+001;
	asr64(R1) += asr64(R2);
	x = asr64(R1);
L6340:
	i += 1; if (i <= av_1) goto L6337;
L6339:
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6344;
	asi64(R1) = expon;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6347;
L6345:
	asr64(R1) = expbase;
	R2 = (u64)&x;
	*tor64p(R2) *= asr64(R1);
	if (--asi64(av_2)) goto L6345;
L6347:
	goto L6343;
L6344:
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6350;
L6348:
	asr64(R1) = expbase;
	R2 = (u64)&x;
	*tor64p(R2) /= asr64(R1);
	if (--asi64(av_3)) goto L6348;
L6350:
L6343:
	R1 = 60;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 21;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asu64(R1) = intstart;
	asu64(R2) = cc_lex_lxstart;
	asi64(R1) -= asi64(R2);
	cc_lex_setnumberoffset(asi64(R1));
	asu64(R1) = cc_lex_lxsptr;
	asu64(R2) = intstart;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6311:
	return;
}

static i64 cc_lex_issimpleconstmacro(u64 m) {
    u64 R1, R2, R3; 
	u64 tk;
	i64 av_1;
	i64 i;
// PROC LOCAL STATICS GO HERE
	static struct $B8 cc_lex_issimpleconstmacro_specialnames = {{
	(u64)"stdin",
	(u64)"stdout",
	(u64)"stderr"    }};
	R1 = 1;
	i = asi64(R1);
	R1 = 3;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6354;
L6352:
	asu64(R1) = m;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_lex_issimpleconstmacro_specialnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L6356;
	R1 = 2;
	goto L6351;
L6356:
	i += 1; if (i <= av_1) goto L6352;
L6354:
	asu64(R1) = m;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	tk = asu64(R1);
	asu64(R1) = tk;
	if (!asu64(R1)) goto L6358;
	asu64(R1) = tk;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6358;
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L6361;
	asu64(R1) = tk;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) != asi64(R2)) goto L6360;
L6361:
	R1 = 1;
	goto L6351;
L6360:
L6358:
	R1 = 0;
	goto L6351;
L6351:
	return asi64(R1);
}

static void cc_parse_readmodule() {
    u64 R1, R2, R3, R4, R5; 
	i64 linkage;
	i64 m;
	i64 mbase;
	i64 commaseen;
	i64 wasdef;
	u64 p;
	u64 d;
	u64 pm;
	i64 t;
	i64 nitems;
	i64 wasenum;
	goto L6364;
L6363:
	R1 = 0;
	nitems = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6367;
	goto L6368;
L6367:
	R1 = tou64("Extra semicolon 2");
	cc_support_serror(asu64(R1));
	goto L6366;
L6368:
L6366:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	wasenum = asi64(R1);
	R1 = (u64)&linkage;
	asu64(R2) = cc_decls_stmodule;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
	R1 = 0;
	commaseen = asi64(R1);
L6369:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6371;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6371;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6371;
	goto L6372;
L6371:
	R1 = (u64)&nitems;
	(*toi64p(R1)) += 1;
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = cc_decls_stmodule;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6374;
	R1 = tou64("Var name expected");
	cc_support_serror(asu64(R1));
L6374:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L6376;
	asu64(R1) = pm;
	if (!asu64(R1)) goto L6378;
	asu64(R1) = pm;
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	m = asi64(R1);
L6378:
	asi64(R1) = m;
	asu64(R2) = d;
	asu64(R3) = cc_decls_stmodule;
	asu64(R1) = cc_parse_createtypedef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	goto L6375;
L6376:
	asu64(R1) = pm;
	if (!asu64(R1)) goto L6379;
// cc_parse.readmodule.readfn:
L6380:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6382;
	asi64(R1) = commaseen;
	if (!asi64(R1)) goto L6382;
	R1 = tou64("fn def after comma");
	cc_support_serror(asu64(R1));
L6382:
	R1 = (u64)&wasdef;
	asu64(R2) = pm;
	asi64(R3) = linkage;
	asi64(R4) = m;
	asu64(R5) = d;
	asu64(R1) = cc_parse_readfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	d = asu64(R1);
	asi64(R1) = wasdef;
	if (!asi64(R1)) goto L6384;
	goto L6370;
L6384:
	goto L6375;
L6379:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L6385;
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	goto L6380;
	goto L6375;
L6385:
	asi64(R1) = linkage;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R1) = cc_parse_readmodulevar(asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
L6375:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6387;
	goto L6388;
L6387:
	R1 = 1;
	commaseen = asi64(R1);
	cc_lex_lex();
	goto L6386;
L6388:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L6370;
L6386:
	goto L6369;
L6372:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6390;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6390;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6390;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6391;
	goto L6392;
L6390:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L6370;
	goto L6389;
L6391:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L6370;
	goto L6389;
L6392:
	asi64(R1) = mbase;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Decl error #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L6389:
	goto L6369;
L6370:
L6364:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L6363;
	return;
}

static i64 cc_parse_parsemodule() {
    u64 R1, R2, R3; 
	i64 size;
	i64 t;
	u64 owner;
	r64 tsecs;
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6395;
	msysc_m$print_startcon();
	R1 = tou64("Parsing:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L6395:
	R1 = 0;
	R2 = R1;
	cc_parse_ingeneric = asu8(R2);
	cc_parse_loopindex = asi64(R1);
	R1 = 0;
	cc_parse_ist_symptr = asu64(R1);
	R1 = 512;
	R2 = 0;
	R3 = (u64)&cc_parse_casevaluestack;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asi64(R1) = cc_decls_mainfileno;
	R2 = tou64("PARSETEST");
	cc_lex_startlex(asu64(R2), asi64(R1));
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
	R1 = 0;
	cc_decls_currproc = asu64(R1);
	R1 = 0;
	cc_parse_loopindex = asi64(R1);
	cc_lex_lex();
	cc_parse_readmodule();
	cc_lex_endlex();
	R1 = 1;
	goto L6393;
L6393:
	return asi64(R1);
}

static i64 cc_parse_readdeclspec(u64 owner, u64 linkage) {
    u64 R1, R2, R3; 
	struct $B72 d;
	u64 p;
	i64 t;
	i64 mod;
	i64 m;
	i64 fstruct;
	u64 pm;
	u64 e;
	R1 = 15;
	R2 = 0;
	R3 = (u64)&d;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 20;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = R1;
	mod = asi64(R2);
	fstruct = asi64(R1);
L6397:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 67: goto L6448;
	case 68: case 69: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 89: goto L6400;
	case 70: goto L6402;
	case 83: case 84: goto L6442;
	case 85: goto L6435;
	case 86: goto L6429;
	case 87: goto L6401;
	case 88: goto L6438;
	case 90: goto L6445;
	default: goto L6400;
    };
// SWITCH
L6401:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	cc_lex_lex();
	goto L6397;
L6402:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: case 2: case 5: case 6: case 7: case 10: goto L6406;
	case 3: goto L6412;
	case 4: goto L6416;
	case 8: goto L6421;
	case 9: goto L6425;
	default: goto L6405;
    };
// SWITCH
L6406:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6408;
	asi64(R1) = fstruct;
	if (!asi64(R1)) goto L6410;
	R1 = 9;
	cc_lib_checksymbol(asi64(R1));
	goto L6409;
L6410:
	goto L6411;
L6409:
L6408:
	R1 = (u64)&cc_tables_typespectypes;
	R2 = (u64)&cc_decls_lx;
	R3 = 22;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6403;
L6412:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6415;
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6415;
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6414;
L6415:
	goto L6411;
L6414:
	R1 = 1;
	R2 = R1;
	mod = asi64(R2);
	R2 = (u64)&d;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6403;
L6416:
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6419;
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6418;
L6419:
	goto L6411;
	goto L6417;
L6418:
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6420;
	R1 = 0;
	R2 = (u64)&d;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6417;
L6420:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6417:
	R1 = 1;
	mod = asi64(R1);
	goto L6403;
L6421:
	R1 = (u64)&d;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6424;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6423;
L6424:
	goto L6411;
L6423:
	R1 = 1;
	R2 = R1;
	mod = asi64(R2);
	R2 = (u64)&d;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6403;
L6425:
	R1 = (u64)&d;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6428;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6427;
L6428:
	goto L6411;
L6427:
	R1 = 1;
	R2 = R1;
	mod = asi64(R2);
	R2 = (u64)&d;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6403;
L6405:
// cc_parse.readdeclspec.tserror:
L6411:
	R1 = (u64)&cc_tables_typespecnames;
	R2 = (u64)&cc_decls_lx;
	R3 = 22;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("declspec/ts #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L6403:
	cc_lex_lex();
	goto L6397;
L6429:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6431;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6432;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6433;
	goto L6434;
L6431:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6430;
L6432:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6430;
L6433:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6430;
L6434:
L6430:
	cc_lex_lex();
	goto L6397;
L6435:
	R1 = (u64)&d;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6437;
	R1 = tou64("Dual storage spec");
	cc_support_serror(asu64(R1));
L6437:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&d;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	cc_lex_lex();
	goto L6397;
L6438:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6440;
	goto L6441;
L6440:
	R1 = 1;
	R2 = (u64)&d;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6439;
L6441:
L6439:
	cc_lex_lex();
	goto L6397;
L6442:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6444;
	R1 = tou64("struct?");
	cc_support_serror(asu64(R1));
L6444:
	asu64(R1) = owner;
	asi64(R1) = cc_parse_readstructdecl(asu64(R1));
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	fstruct = asi64(R1);
	goto L6397;
L6445:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6447;
	R1 = tou64("enum?");
	cc_support_serror(asu64(R1));
L6447:
	asu64(R1) = owner;
	asi64(R1) = cc_parse_readenumdecl(asu64(R1));
	R1 = 3;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6397;
L6448:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6450;
	asu64(R1) = owner;
	asi64(R1) = cc_parse_isusertype(asu64(R1));
	R2 = R1;
	m = asi64(R2);
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6450;
	asi64(R1) = mod;
	if (!asi64(R1)) goto L6452;
	R1 = 3;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6398;
L6452:
	asi64(R1) = m;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&d;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	cc_lex_lex();
	goto L6449;
L6450:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6454;
	asi64(R1) = mod;
	if (asi64(R1)) goto L6454;
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Implicit decls not allowed: #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L6454:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6456;
	R1 = 3;
	R2 = (u64)&d;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6456:
	goto L6398;
L6449:
	goto L6397;
L6400:
	goto L6398;
	goto L6397;
L6398:
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6458;
	R1 = (u64)&d;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L6457;
L6458:
	R1 = 3;
L6457:
	t = asi64(R1);
	R1 = (u64)&d;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6460;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6462;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6463;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6464;
	goto L6465;
L6462:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6467;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6469;
	R1 = 7;
	goto L6468;
L6469:
	R1 = 2;
L6468:
	t = asi64(R1);
	goto L6466;
L6467:
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6470;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6472;
	R1 = 8;
	goto L6471;
L6472:
	R1 = 3;
L6471:
	t = asi64(R1);
	goto L6466;
L6470:
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6473;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6475;
	R1 = 9;
	goto L6474;
L6475:
	R1 = 4;
L6474:
	t = asi64(R1);
	goto L6466;
L6473:
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6476;
	R1 = 8;
	t = asi64(R1);
L6476:
L6466:
	goto L6461;
L6463:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6479;
	R1 = (u64)&d;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6479;
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6478;
L6479:
	R1 = tou64("char decl?");
	cc_support_serror(asu64(R1));
L6478:
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6481;
	R1 = 6;
	goto L6480;
L6481:
	R1 = 1;
L6480:
	t = asi64(R1);
	goto L6461;
L6464:
	R1 = (u64)&d;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6484;
	R1 = (u64)&d;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6484;
	R1 = (u64)&d;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6484;
	R1 = (u64)&d;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6483;
L6484:
	R1 = tou64("dbl decl?");
	cc_support_serror(asu64(R1));
L6483:
	goto L6461;
L6465:
	asi64(R1) = mod;
	if (!asi64(R1)) goto L6486;
	R1 = tou64("declspec/float");
	cc_support_serror(asu64(R1));
L6486:
L6461:
L6460:
	R1 = (u64)&d;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6488;
	asi64(R1) = t;
	asi64(R1) = cc_lib_createconstmode(asi64(R1));
	t = asi64(R1);
L6488:
	R1 = (u64)&d;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = linkage;
	*toi64p(R2) = asi64(R1);
	asi64(R1) = t;
	goto L6396;
L6396:
	return asi64(R1);
}

static i64 cc_parse_istypestarter() {
    u64 R1, R2, R3, R4; 
	u64 d;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L6491;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L6491;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L6492;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6493;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L6494;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L6494;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L6494;
	goto L6495;
L6491:
	R1 = 1;
	goto L6489;
	goto L6490;
L6492:
	R1 = 1;
	goto L6489;
	goto L6490;
L6493:
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	if (!asu64(R4)) goto L6497;
	asu64(R4) = cc_decls_currproc;
	goto L6496;
L6497:
	asu64(R4) = cc_decls_stmodule;
L6496:
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L6499;
	asu64(R1) = d;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L6489;
L6499:
	goto L6490;
L6494:
	R1 = 1;
	goto L6489;
	goto L6490;
L6495:
L6490:
	R1 = 0;
	goto L6489;
L6489:
	return asi64(R1);
}

static i64 cc_parse_istypestarter_next() {
    u64 R1, R2, R3, R4; 
	u64 d;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L6502;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L6502;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L6503;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6504;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L6505;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L6505;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L6505;
	goto L6506;
L6502:
	R1 = 1;
	goto L6500;
	goto L6501;
L6503:
	R1 = 1;
	goto L6500;
	goto L6501;
L6504:
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_nextlx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	if (!asu64(R4)) goto L6508;
	asu64(R4) = cc_decls_currproc;
	goto L6507;
L6508:
	asu64(R4) = cc_decls_stmodule;
L6507:
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L6510;
	asu64(R1) = d;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L6500;
L6510:
	goto L6501;
L6505:
	R1 = 1;
	goto L6500;
	goto L6501;
L6506:
L6501:
	R1 = 0;
	goto L6500;
L6500:
	return asi64(R1);
}

static u64 cc_parse_readexpression() {
    u64 R1, R2, R3; 
	u64 p;
	u64 ulist;
	u64 ulistx;
	i64 t;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6513;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6513;
	goto L6514;
L6513:
	asu64(R1) = cc_parse_readterm();
	goto L6511;
	goto L6512;
L6514:
L6512:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L6516;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L6517:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6520;
	goto L6518;
L6520:
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	goto L6517;
L6518:
	asu64(R1) = ulist;
	R2 = 29;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = ulistx;
	if (!asu64(R1)) goto L6522;
	asu64(R1) = ulistx;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6522:
	asu64(R1) = p;
	goto L6511;
L6516:
	asu64(R1) = p;
	goto L6511;
L6511:
	return asu64(R1);
}

static u64 cc_parse_readassignexpr() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	u64 r;
	i64 opc;
	i64 oldpmode;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6525;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6525;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6525;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6526;
	goto L6527;
L6525:
	asu64(R1) = cc_parse_readterm();
	goto L6523;
	goto L6524;
L6526:
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	goto L6528;
	goto L6524;
L6527:
L6524:
	asu64(R1) = cc_parse_readcondexpr();
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	switch (asi64(R1)) {
	case 11: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: goto L6532;
	case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: goto L6531;
	default: goto L6531;
    };
// SWITCH
L6532:
// cc_parse.readassignexpr.gotp:
L6528:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	oldpmode = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	cc_parse_checklvalue(asu64(R2), asi64(R1));
	asu64(R1) = cc_parse_readassignexpr();
	q = asu64(R1);
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6534;
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = opc;
	asu64(R1) = cc_parse_createassignopref(asi64(R3), asu64(R2), asu64(R1));
	goto L6523;
L6534:
	asi64(R1) = oldpmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	q = asu64(R1);
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = oldpmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6536;
	R1 = tou64("Modifying read-only var");
	cc_support_terror(asu64(R1));
L6536:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L6538;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6538;
	R1 = tou64("Modifying constant?");
	cc_support_terror(asu64(R1));
L6538:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = (u64)&cc_tables_symboltojtag;
	asi64(R4) = opc;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	asi64(R1) = oldpmode;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	goto L6523;
	goto L6529;
L6531:
L6529:
	asu64(R1) = p;
	goto L6523;
L6523:
	return asu64(R1);
}

static u64 cc_parse_readcondexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	u64 pcond;
	i64 s;
	i64 t;
	i64 u;
	asu64(R1) = cc_parse_readorlexpr();
	pcond = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L6541;
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readexpression();
	x = asu64(R1);
	R1 = 10;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readcondexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	s = asi64(R3);
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L6543;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = pcond;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6545;
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6545;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6545;
	asu64(R1) = pcond;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L6547;
	asu64(R1) = x;
	goto L6546;
L6547:
	asu64(R1) = y;
L6546:
	goto L6539;
L6545:
	goto L6542;
L6543:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6548;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6548;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L6542;
L6548:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6549;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6549;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6549;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6549;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	goto L6542;
L6549:
	asi64(R1) = s;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6550;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6550;
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6550;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6550;
	asu64(R1) = y;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	goto L6542;
L6550:
	asi64(R1) = s;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L6551;
	asi64(R1) = t;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L6551;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L6542;
L6551:
	asi64(R1) = s;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L6552;
	asi64(R1) = t;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L6552;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L6542;
L6552:
	asi64(R1) = s;
	asi64(R2) = t;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6553;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6553;
	R1 = 0;
	u = asi64(R1);
	goto L6542;
L6553:
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("?: incompatible types");
	cc_support_terror(asu64(R1));
L6542:
	asu64(R1) = y;
	asu64(R2) = x;
	asu64(R3) = pcond;
	R4 = 31;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	pcond = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = pcond;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6541:
	asu64(R1) = pcond;
	goto L6539;
L6539:
	return asu64(R1);
}

static u64 cc_parse_readorlexpr() {
    u64 R1, R2, R3; 
	u64 x;
	u64 y;
	asu64(R1) = cc_parse_readandlexpr();
	x = asu64(R1);
	goto L6556;
L6555:
	cc_lex_lex();
	asu64(R1) = cc_parse_readandlexpr();
	y = asu64(R1);
	asu64(R1) = x;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = y;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6559;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6559;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1)) goto L6562;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L6561;
L6562:
	R1 = 1;
	goto L6560;
L6561:
	R1 = 0;
L6560:
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6556;
L6559:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 25;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6556:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L6555;
	asu64(R1) = x;
	goto L6554;
L6554:
	return asu64(R1);
}

static u64 cc_parse_readandlexpr() {
    u64 R1, R2, R3; 
	u64 x;
	u64 y;
	asu64(R1) = cc_parse_readiorexpr();
	x = asu64(R1);
	goto L6565;
L6564:
	cc_lex_lex();
	asu64(R1) = cc_parse_readiorexpr();
	y = asu64(R1);
	asu64(R1) = x;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = y;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6568;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6568;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L6570;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L6570;
	R1 = 1;
	goto L6569;
L6570:
	R1 = 0;
L6569:
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6565;
L6568:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 24;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6565:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L6564;
	asu64(R1) = x;
	goto L6563;
L6563:
	return asu64(R1);
}

static u64 cc_parse_readiorexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 u;
	asu64(R1) = cc_parse_readixorexpr();
	x = asu64(R1);
	goto L6573;
L6572:
	cc_lex_lex();
	asu64(R1) = cc_parse_readixorexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L6576;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L6578;
	R1 = tou64("float|float");
	cc_support_terror(asu64(R1));
L6578:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L6575;
L6576:
	R1 = tou64("invalid | operands");
	cc_support_terror(asu64(R1));
L6575:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6580;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6580;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6582;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6582;
	goto L6583;
L6582:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) |= asi64(R1);
	goto L6573;
	goto L6581;
L6583:
L6581:
L6580:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 45;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6573:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6572;
	asu64(R1) = x;
	goto L6571;
L6571:
	return asu64(R1);
}

static u64 cc_parse_readixorexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 u;
	asu64(R1) = cc_parse_readiandexpr();
	x = asu64(R1);
	goto L6586;
L6585:
	cc_lex_lex();
	asu64(R1) = cc_parse_readiandexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L6589;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L6591;
	R1 = tou64("float^float");
	cc_support_terror(asu64(R1));
L6591:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L6588;
L6589:
	R1 = tou64("invalid ^ operands");
	cc_support_terror(asu64(R1));
L6588:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6593;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6593;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6595;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6595;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6595;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6595;
	goto L6596;
L6595:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) ^= asi64(R1);
	goto L6586;
	goto L6594;
L6596:
L6594:
L6593:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 46;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6586:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L6585;
	asu64(R1) = x;
	goto L6584;
L6584:
	return asu64(R1);
}

static u64 cc_parse_readiandexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 u;
	asu64(R1) = cc_parse_readeqexpr();
	x = asu64(R1);
	goto L6599;
L6598:
	cc_lex_lex();
	asu64(R1) = cc_parse_readeqexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L6602;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L6604;
	R1 = tou64("float&float");
	cc_support_terror(asu64(R1));
L6604:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L6601;
L6602:
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("invalid & operands");
	cc_support_terror(asu64(R1));
L6601:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6606;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6606;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6608;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6608;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6608;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6608;
	goto L6609;
L6608:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) &= asi64(R1);
	goto L6599;
	goto L6607;
L6609:
L6607:
L6606:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 44;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6599:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L6598;
	asu64(R1) = x;
	goto L6597;
L6597:
	return asu64(R1);
}

static u64 cc_parse_readeqexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 opc;
	i64 s;
	i64 t;
	i64 u;
	i64 ss;
	i64 tt;
	asu64(R1) = cc_parse_readrelexpr();
	x = asu64(R1);
	goto L6612;
L6611:
	cc_lex_lex();
	asu64(R1) = cc_parse_readrelexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	s = asi64(R3);
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L6615;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L6614;
L6615:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6616;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6616;
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	ss = asi64(R2);
	R2 = (u64)&cc_decls_tttarget;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	tt = asi64(R3);
	if (asi64(R1) == asi64(R2)) goto L6618;
	asi64(R1) = ss;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6620;
	asi64(R1) = tt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6620;
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	if (asi64(R1)) goto L6622;
	R1 = tou64("Comparing distinct pointers/eq");
	cc_support_terror(asu64(R1));
L6622:
L6620:
L6618:
	goto L6614;
L6616:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6623;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6623;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6626;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6625;
L6626:
	R1 = tou64("Can't compare pointer to int");
	cc_support_terror(asu64(R1));
L6625:
	goto L6614;
L6623:
	asi64(R1) = s;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6627;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6627;
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6630;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6629;
L6630:
	R1 = tou64("Can't compare pointer to int2");
	cc_support_terror(asu64(R1));
L6629:
	goto L6614;
L6627:
	msysc_m$print_startcon();
	R1 = tou64("U=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = u;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("invalid == operands");
	cc_support_terror(asu64(R1));
L6614:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6632;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6632;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6634;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6634;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6634;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6634;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6634;
	goto L6635;
L6634:
	asi64(R1) = opc;
	R2 = 40;
	if (asi64(R1) != asi64(R2)) goto L6637;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6636;
L6637:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L6636:
	goto L6612;
	goto L6633;
L6635:
L6633:
L6632:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = (u64)&cc_tables_symboltojtag;
	asi64(R4) = opc;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6612:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L6611;
	asi64(R1) = opc;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L6611;
	asu64(R1) = x;
	goto L6610;
L6610:
	return asu64(R1);
}

static u64 cc_parse_readrelexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 opc;
	i64 s;
	i64 t;
	i64 u;
	i64 a;
	i64 b;
	i64 c;
	u64 aa;
	u64 bb;
	u64 cc;
	asu64(R1) = cc_parse_readshiftexpr();
	x = asu64(R1);
	goto L6640;
L6639:
	cc_lex_lex();
	asu64(R1) = cc_parse_readshiftexpr();
	y = asu64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	s = asi64(R3);
	R1 += (i64)R2*32;
	R2 = (u64)&cc_decls_ttbasetype;
	asu64(R3) = y;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L6643;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L6642;
L6643:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6644;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6644;
	R1 = 1;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = x;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	if (asi64(R1)) goto L6646;
	R1 = tou64("Comparing distinct pointers/rel");
	cc_support_terror(asu64(R1));
L6646:
	goto L6642;
L6644:
	R1 = tou64("invalid rel operands");
	cc_support_terror(asu64(R1));
L6642:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6648;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6648;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6650;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6650;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6651;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6651;
	goto L6652;
L6650:
	asi64(R1) = opc;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L6654;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6655;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L6656;
	goto L6657;
L6654:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	c = asi64(R1);
	goto L6653;
L6655:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	c = asi64(R1);
	goto L6653;
L6656:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	c = asi64(R1);
	goto L6653;
L6657:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = asi64(R1)  >  asi64(R2);
	c = asi64(R1);
L6653:
	asi64(R1) = c;
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6640;
	goto L6649;
L6651:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	aa = asu64(R1);
	asu64(R1) = y;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	bb = asu64(R1);
	asi64(R1) = opc;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L6659;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6660;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L6661;
	goto L6662;
L6659:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  <  asu64(R2);
	cc = asu64(R1);
	goto L6658;
L6660:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  <=  asu64(R2);
	cc = asu64(R1);
	goto L6658;
L6661:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  >=  asu64(R2);
	cc = asu64(R1);
	goto L6658;
L6662:
	asu64(R1) = aa;
	asu64(R2) = bb;
	asi64(R1) = asu64(R1)  >  asu64(R2);
	cc = asu64(R1);
L6658:
	asu64(R1) = cc;
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6640;
	goto L6649;
L6652:
L6649:
L6648:
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = (u64)&cc_tables_symboltojtag;
	asi64(R4) = opc;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6640:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L6639;
	asi64(R1) = opc;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6639;
	asi64(R1) = opc;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L6639;
	asi64(R1) = opc;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L6639;
	asu64(R1) = x;
	goto L6638;
L6638:
	return asu64(R1);
}

static u64 cc_parse_readshiftexpr() {
    u64 R1, R2, R3, R4; 
	u64 x;
	u64 y;
	i64 opc;
	i64 u;
	asu64(R1) = cc_parse_readaddexpr();
	x = asu64(R1);
	goto L6665;
L6664:
	cc_lex_lex();
	asu64(R1) = cc_parse_readaddexpr();
	y = asu64(R1);
	asu64(R1) = x;
	cc_parse_coercebasetype(asu64(R1));
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	u = asi64(R2);
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6669;
	asi64(R1) = u;
	R2 = 9;
	if (asi64(R1) <= asi64(R2)) goto L6668;
L6669:
	R1 = tou64("shift:Not an int");
	cc_support_terror(asu64(R1));
L6668:
	R1 = 3;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6671;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6671;
	asi64(R1) = u;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6673;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6673;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6674;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6674;
	goto L6675;
L6673:
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) != asi64(R2)) goto L6677;
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) <<= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L6676;
L6677:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) >>= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L6676:
	goto L6665;
	goto L6672;
L6674:
	asi64(R1) = opc;
	R2 = 33;
	if (asi64(R1) != asi64(R2)) goto L6679;
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) <<= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6678;
L6679:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) >>= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6678:
	goto L6665;
	goto L6672;
L6675:
L6672:
L6671:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	R4 = 33;
	if (asi64(R3) != asi64(R4)) goto L6681;
	R3 = 47;
	goto L6680;
L6681:
	R3 = 48;
L6680:
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6665:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L6664;
	asi64(R1) = opc;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L6664;
	asu64(R1) = x;
	goto L6663;
L6663:
	return asu64(R1);
}

static u64 cc_parse_readaddexpr() {
    u64 R1, R2; 
	u64 p;
	u64 q;
	i64 opc;
	asu64(R1) = cc_parse_readmulexpr();
	p = asu64(R1);
	goto L6684;
L6683:
	cc_lex_lex();
	asu64(R1) = cc_parse_readmulexpr();
	q = asu64(R1);
	asi64(R1) = opc;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L6687;
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createaddop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L6686;
L6687:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createsubop(asu64(R2), asu64(R1));
	p = asu64(R1);
L6686:
L6684:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L6683;
	asi64(R1) = opc;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6683;
	asu64(R1) = p;
	goto L6682;
L6682:
	return asu64(R1);
}

static u64 cc_parse_readmulexpr() {
    u64 R1, R2; 
	u64 p;
	u64 q;
	i64 opc;
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	goto L6690;
L6689:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	q = asu64(R1);
	asi64(R1) = opc;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6693;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L6694;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6695;
	goto L6696;
L6693:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createmulop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L6692;
L6694:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createdivop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L6692;
L6695:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createremop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L6692;
L6696:
L6692:
L6690:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6689;
	asi64(R1) = opc;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L6689;
	asi64(R1) = opc;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6689;
	asu64(R1) = p;
	goto L6688;
L6688:
	return asu64(R1);
}

static u64 cc_parse_readterm() {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 q;
	i64 t;
	i64 u;
	i64 opc;
	i64 shift;
	i64 newlen;
	i64 slength;
	i64 tbase;
	i64 fwide;
	i64 newmode;
	i64 tag;
	u64 pbyte;
	i64 a;
	u64 d;
	u64 ss;
	u64 s;
	u64 pm;
	i64 av_1;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 13: goto L6747;
	case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 26: case 27: case 28: case 30: case 31: case 33: case 34: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 62: case 65: case 66: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 92: goto L6700;
	case 23: goto L6734;
	case 24: goto L6735;
	case 25: goto L6744;
	case 29: goto L6740;
	case 32: goto L6743;
	case 35: goto L6739;
	case 36: goto L6736;
	case 37: case 38: goto L6745;
	case 39: goto L6746;
	case 59: case 60: goto L6701;
	case 61: goto L6726;
	case 63: case 64: goto L6720;
	case 67: goto L6702;
	case 91: goto L6752;
	case 93: goto L6763;
	case 94: goto L6764;
	case 95: goto L6765;
	default: goto L6700;
    };
// SWITCH
L6701:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L6698;
L6702:
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L6704;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	if (!asu64(R4)) goto L6706;
	asu64(R4) = cc_decls_currproc;
	goto L6705;
L6706:
	asu64(R4) = cc_decls_stmodule;
L6705:
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6708;
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_lib_getstname(asu64(R1));
	R2 = tou64("Undefined name \"#\"");
	cc_support_serror_s(asu64(R2), asu64(R1));
L6708:
	goto L6703;
L6704:
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L6703:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6710;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6711;
	goto L6712;
L6710:
	R1 = 3;
	asu64(R2) = d;
	R3 = 88;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = tou64(toi32(R2));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L6709;
L6711:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6714;
	R1 = 5;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6713;
L6714:
	goto L6715;
L6713:
	goto L6709;
L6712:
// cc_parse.readterm.doname:
L6715:
	asu64(R1) = d;
	asu64(R1) = cc_lib_createname(asu64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = R1;
	t = asi64(R2);
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6717;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R1) = cc_parse_createaddrofop(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6716;
L6717:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6718;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L6718;
	asu64(R1) = p;
	cc_parse_fixmemopnd(asu64(R1));
	goto L6716;
L6718:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L6719;
L6719:
L6716:
L6709:
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	cc_lex_lex();
	goto L6698;
L6720:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 64;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	fwide = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	slength = asi64(R1);
	goto L6722;
L6721:
	asi64(R1) = slength;
	R2 = (u64)&cc_decls_nextlx;
	R3 = 24;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	ss = asu64(R1);
	asi64(R1) = slength;
	asu64(R2) = s;
	asu64(R3) = ss;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_nextlx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	R2 = (u64)&cc_decls_nextlx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = ss;
	asi64(R4) = slength;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = ss;
	asi64(R3) = newlen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = ss;
	s = asu64(R1);
	asi64(R1) = newlen;
	slength = asi64(R1);
	cc_lex_lex();
L6722:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L6721;
	asi64(R1) = fwide;
	if (!asi64(R1)) goto L6725;
	asi64(R1) = slength;
	asu64(R2) = s;
	asu64(R1) = cc_lib_createwstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	asi64(R1) = slength;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_decls_trefwchar;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6724;
L6725:
	asi64(R1) = slength;
	asu64(R2) = s;
	asu64(R1) = cc_lib_createstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	asi64(R1) = slength;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_decls_trefchar;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6724:
	cc_lex_lex();
	goto L6698;
L6726:
	R1 = 0;
	a = asi64(R1);
	R1 = 0;
	shift = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pbyte = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L6728;
	R1 = tou64("char const too long");
	cc_support_serror(asu64(R1));
L6728:
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6731;
L6729:
	asi64(R1) = a;
	asu64(R2) = pbyte;
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	asi64(R3) = shift;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	a = asi64(R1);
	R1 = 8;
	R2 = (u64)&shift;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&pbyte;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L6729;
L6731:
	R1 = (u64)&cc_decls_lx;
	R2 = 24;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L6733;
	R1 = 3;
	goto L6732;
L6733:
	R1 = 4;
L6732:
	asi64(R2) = a;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L6698;
L6734:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	goto L6698;
L6735:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createnegop(asu64(R1));
	p = asu64(R1);
	goto L6698;
L6736:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	asu64(R1) = p;
	cc_parse_coercecond(asu64(R1));
	asu64(R1) = p;
	R2 = 26;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L6738;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L6738;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6738:
	goto L6698;
L6739:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createinotop(asu64(R1));
	p = asu64(R1);
	goto L6698;
L6740:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) != asi64(R2)) goto L6742;
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	goto L6741;
L6742:
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createaddrofop(asu64(R1));
	p = asu64(R1);
L6741:
	goto L6698;
L6743:
	R1 = tou64("rt/&&label");
	cc_support_serror(asu64(R1));
	goto L6698;
L6744:
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asu64(R1) = cc_parse_createptrop(asu64(R1));
	p = asu64(R1);
	goto L6698;
L6745:
	R1 = (u64)&cc_tables_symboltojtag;
	R2 = (u64)&cc_decls_lx;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	cc_lex_lex();
	asu64(R1) = cc_parse_readterm();
	asi64(R2) = opc;
	asu64(R1) = cc_parse_createincrop(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L6698;
L6746:
	cc_lex_lex();
	R1 = 13;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readexpression();
	asu64(R1) = cc_parse_createabsop(asu64(R1));
	p = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	goto L6698;
L6747:
	cc_lex_lex();
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L6749;
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6751;
	R1 = tou64("rt/compound lit");
	cc_support_serror(asu64(R1));
	goto L6750;
L6751:
	R1 = 0;
	R2 = 1;
	asi64(R3) = t;
	asu64(R4) = cc_parse_readterm();
	asu64(R1) = cc_parse_docast(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
L6750:
	goto L6748;
L6749:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
L6748:
	goto L6698;
L6752:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6754;
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6756;
	cc_lex_lex();
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L6758;
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 9;
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = t;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L6757;
L6758:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 1;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L6757:
	goto L6755;
L6756:
	R1 = 1;
	asu64(R2) = cc_parse_readterm();
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L6755:
	goto L6753;
L6754:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6760;
	asi64(R1) = cc_parse_istypestarter_next();
	if (!asi64(R1)) goto L6762;
	cc_lex_lex();
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 9;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = t;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L6761;
L6762:
	asu64(R1) = cc_parse_readterm();
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L6761:
	goto L6759;
L6760:
	R1 = 0;
	asu64(R2) = cc_parse_readterm();
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	p = asu64(R1);
L6759:
L6753:
	goto L6698;
L6763:
	asu64(R1) = cc_parse_readgeneric();
	p = asu64(R1);
	goto L6698;
L6764:
	R1 = tou64("rt/alignof");
	cc_support_serror(asu64(R1));
	goto L6698;
L6765:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	tag = asi64(R1);
	cc_lex_lex();
	R1 = 13;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = tag;
	R2 = 76;
	if (asi64(R1) != asi64(R2)) goto L6767;
	R1 = 8;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	q = asu64(R1);
	goto L6766;
L6767:
	R1 = 0;
	q = asu64(R1);
L6766:
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = tag;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 14;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	goto L6698;
L6700:
	R1 = tou64("RT");
	cc_lex_ps(asu64(R1));
	R1 = tou64("Readterm?");
	cc_support_serror(asu64(R1));
L6698:
L6768:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 2: case 3: goto L6773;
	case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 14: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: goto L6771;
	case 13: goto L6774;
	case 15: goto L6772;
	case 37: goto L6777;
	case 38: goto L6778;
	default: goto L6771;
    };
// SWITCH
L6772:
	cc_lex_lex();
	asu64(R1) = cc_parse_readexpression();
	q = asu64(R1);
	R1 = 16;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createindexop(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L6768;
L6773:
	R1 = (u64)&cc_tables_symboltojtag;
	R2 = (u64)&cc_decls_lx;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	cc_lex_lex();
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	cc_lex_lex();
	asu64(R1) = d;
	asu64(R2) = p;
	asi64(R3) = opc;
	asu64(R1) = cc_parse_createdotop(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L6768;
L6774:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L6776;
	R1 = 0;
	q = asu64(R1);
	cc_lex_lex();
	goto L6775;
L6776:
	R1 = 0;
	asu64(R1) = cc_parse_readexprlist(asu64(R1));
	q = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
L6775:
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createcall(asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L6768;
L6777:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 73;
	asu64(R1) = cc_parse_createincrop(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L6768;
L6778:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 74;
	asu64(R1) = cc_parse_createincrop(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L6768;
L6771:
	goto L6769;
	goto L6768;
L6769:
	asu64(R1) = p;
	goto L6697;
L6697:
	return asu64(R1);
}

static u64 cc_parse_readexprlist(u64 p) {
    u64 R1, R2, R3; 
	u64 ulist;
	u64 ulistx;
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L6780:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6783;
	goto L6781;
L6783:
	cc_lex_lex();
	goto L6780;
L6781:
	asu64(R1) = ulist;
	goto L6779;
L6779:
	return asu64(R1);
}

static u64 cc_parse_readmodulevar(u64 d, i64 m, i64 linkage) {
    u64 R1, R2, R3, R4; 
	u64 e;
	i64 scope;
	i64 emode;
	R1 = 0;
	R2 = 1;
	asu64(R3) = d;
	asu64(R4) = cc_decls_stmodule;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L6786;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6788;
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = e;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("var: name in use # #");
	cc_support_serror_ss(asu64(R3), asu64(R2), asu64(R1));
L6788:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	emode = asi64(R1);
	asi64(R1) = emode;
	asi64(R2) = m;
	if (asi64(R1) == asi64(R2)) goto L6790;
	asi64(R1) = m;
	asi64(R2) = emode;
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L6792;
// cc_parse.readmodulevar.redef:
L6793:
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("var: redefining #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L6792:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = emode;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6795;
	goto L6796;
L6795:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = emode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6798;
	asi64(R1) = m;
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	goto L6797;
L6798:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L6799;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = emode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = m;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) == asi64(R2)) goto L6799;
	goto L6793;
L6799:
L6797:
	goto L6794;
L6796:
L6794:
L6790:
	asu64(R1) = e;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	scope = asi64(R1);
	asi64(R1) = scope;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6803;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6802;
L6803:
	asi64(R1) = scope;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6804;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6802;
L6804:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6801;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6801;
L6802:
	goto L6800;
L6801:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6805;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6805;
	R1 = 4;
	scope = asi64(R1);
L6805:
L6800:
	goto L6785;
L6786:
	R1 = 7;
	asu64(R2) = d;
	asu64(R3) = cc_decls_stmodule;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6807;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6808;
	goto L6809;
L6807:
	R1 = 2;
	scope = asi64(R1);
	goto L6806;
L6808:
	R1 = 3;
	scope = asi64(R1);
	goto L6806;
L6809:
	R1 = 4;
	scope = asi64(R1);
L6806:
L6785:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6811;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6813;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init twice #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L6813:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6815;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init extern #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L6815:
	cc_lex_lex();
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = cc_decls_stmodule;
	asu64(R1) = cc_parse_readinitexpr(asu64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6811:
	asi64(R1) = scope;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	goto L6784;
L6784:
	return asu64(R1);
}

static u64 cc_parse_readframevar(u64 d, i64 m, i64 linkage) {
    u64 R1, R2, R3, R4; 
	u64 pm;
	u64 e;
	i64 scope;
	i64 id;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	asu64(R3) = d;
	asu64(R4) = cc_decls_currproc;
	asu64(R1) = cc_lib_checkdupl_inproc(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L6818;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("var: name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
	asu64(R1) = e;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	scope = asi64(R1);
	asi64(R1) = scope;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6822;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6821;
L6822:
	asi64(R1) = scope;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6823;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6821;
L6823:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6820;
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6820;
L6821:
	goto L6819;
L6820:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6824;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6824;
	R1 = 4;
	scope = asi64(R1);
L6824:
L6819:
	goto L6817;
L6818:
	R1 = 8;
	id = asi64(R1);
	R1 = 1;
	scope = asi64(R1);
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6826;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6827;
	goto L6828;
L6826:
	R1 = 7;
	id = asi64(R1);
	goto L6825;
L6827:
	R1 = 3;
	scope = asi64(R1);
	R1 = 7;
	id = asi64(R1);
	goto L6825;
L6828:
L6825:
	asi64(R1) = id;
	asu64(R2) = d;
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = d;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L6817:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6830;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6832;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init twice #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L6832:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L6834;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't init extern #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L6834:
	cc_lex_lex();
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = cc_decls_currproc;
	asu64(R1) = cc_parse_readinitexpr(asu64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6830:
	asi64(R1) = scope;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	goto L6816;
L6816:
	return asu64(R1);
}

static i64 cc_parse_readtype(u64 owner, u64 d, i64 m, u64 pm) {
    u64 R1, R2, R3, R4, R5; 
	struct $B16 modtype;
	struct $B16 modvalue;
	u64 pmx;
	i64 nmodifiers;
	i64 i;
	R1 = 0;
	nmodifiers = asi64(R1);
	R1 = 0;
	asu64(R2) = pm;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&nmodifiers;
	R2 = (u64)&modvalue;
	R3 = (u64)&modtype;
	asu64(R4) = d;
	asu64(R5) = owner;
	cc_parse_readnamedtype(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = nmodifiers;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6838;
L6836:
	R1 = (u64)&modtype;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L6840;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L6841;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6842;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L6843;
	goto L6844;
L6840:
	R1 = (u64)&modvalue;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = m;
	asi64(R1) = cc_lib_createarraymode(asi64(R2), asi64(R1));
	m = asi64(R1);
	goto L6839;
L6841:
	asi64(R1) = m;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
	goto L6839;
L6842:
	asi64(R1) = m;
	asi64(R1) = cc_lib_createconstmode(asi64(R1));
	m = asi64(R1);
	goto L6839;
L6843:
	R1 = (u64)&modvalue;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pmx = asu64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6846;
	asu64(R1) = pmx;
	asu64(R2) = pm;
	*tou64p(R2) = asu64(R1);
	goto L6845;
L6846:
	asu64(R1) = pmx;
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	m = asi64(R1);
L6845:
	goto L6839;
L6844:
L6839:
	i += -1; if (i >= 1) goto L6836;
L6838:
	asi64(R1) = m;
	goto L6835;
L6835:
	return asi64(R1);
}

static void cc_parse_readnamedtype(u64 owner, u64 d, u64 modtype, u64 modvalue, u64 nmodifiers) {
    u64 R1, R2, R3, R4, R5; 
	i64 length;
	struct $B16 fconst;
	i64 nrefs;
	u64 pdim;
	R1 = 0;
	asu64(R2) = d;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	nrefs = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 88;
	if (asi64(R1) != asi64(R2)) goto L6849;
	cc_lex_lex();
L6849:
	goto L6851;
L6850:
	R1 = (u64)&nrefs;
	(*toi64p(R1)) += 1;
	R1 = 0;
	R2 = (u64)&fconst;
	asi64(R3) = nrefs;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	cc_lex_lex();
	goto L6854;
L6853:
	R1 = (u64)&cc_decls_lx;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6857;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6858;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6858;
	goto L6859;
L6857:
	R1 = 1;
	R2 = (u64)&fconst;
	asi64(R3) = nrefs;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L6856;
L6858:
	goto L6856;
L6859:
	R1 = tou64("rnt1");
	cc_support_serror(asu64(R1));
L6856:
	cc_lex_lex();
L6854:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L6853;
L6851:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6850;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6861;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6862;
	goto L6863;
L6861:
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	*tou64p(R2) = asu64(R1);
	cc_lex_lex();
	goto L6860;
L6862:
	cc_lex_lex();
	asu64(R1) = nmodifiers;
	asu64(R2) = modvalue;
	asu64(R3) = modtype;
	asu64(R4) = d;
	asu64(R5) = owner;
	cc_parse_readnamedtype(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	goto L6860;
L6863:
L6860:
L6864:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6866;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6867;
	goto L6868;
L6866:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) != asi64(R2)) goto L6870;
	R1 = 0;
	length = asi64(R1);
	goto L6869;
L6870:
	asu64(R1) = cc_parse_readassignexpr();
	pdim = asu64(R1);
	asu64(R1) = pdim;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6872;
	asu64(R1) = pdim;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	length = asi64(R1);
	goto L6871;
L6872:
	R1 = tou64("Can't do VLAs");
	cc_support_serror(asu64(R1));
L6871:
	R1 = 16;
	cc_lib_checksymbol(asi64(R1));
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6874;
	R1 = tou64("ZERO LEN ARRAY");
	cc_support_serror(asu64(R1));
L6874:
L6869:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L6876;
	R1 = tou64("Negative array dim");
	cc_support_terror(asu64(R1));
L6876:
	cc_lex_lex();
	R1 = 65;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = length;
	asu64(R2) = modvalue;
	asu64(R3) = nmodifiers;
	asi64(R3) = *toi64p(R3);
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6864;
L6867:
	cc_lex_lex();
	R1 = 70;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = owner;
	asu64(R1) = cc_parse_readparams(asu64(R1));
	asu64(R2) = modvalue;
	asu64(R3) = nmodifiers;
	asi64(R3) = *toi64p(R3);
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6864;
L6868:
	goto L6865;
	goto L6864;
L6865:
	goto L6878;
L6877:
	R1 = (u64)&fconst;
	asi64(R2) = nrefs;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (!asi64(R1)) goto L6881;
	R1 = 67;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L6881:
	R1 = 82;
	asu64(R2) = modtype;
	asu64(R3) = nmodifiers;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&nrefs;
	(*toi64p(R1)) -=1;
L6878:
	asi64(R1) = nrefs;
	if (asi64(R1)) goto L6877;
	return;
}

static i64 cc_parse_readconstintexpr() {
    u64 R1, R2, R3; 
	u64 p;
	i64 val;
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6884;
	goto L6885;
L6884:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L6882;
	goto L6883;
L6885:
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("readconstint #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L6883:
	R1 = 0;
	goto L6882;
L6882:
	return asi64(R1);
}

static u64 cc_parse_readinitexpr(u64 owner, i64 m) {
    u64 R1, R2, R3; 
	i64 count;
	u64 p;
	R1 = 1;
	asi64(R2) = m;
	asu64(R3) = owner;
	asu64(R1) = cc_parse_readinitexpr2(asu64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L6886;
L6886:
	return asu64(R1);
}

static u64 cc_parse_readinitexpr2(u64 owner, i64 m, i64 istop) {
    u64 R1, R2, R3, R4; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	i64 mbase;
	i64 melem;
	i64 mm;
	i64 dim;
	i64 count;
	u64 d;
	u64 e;
	i64 braces;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	mbase = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6889;
	cc_lex_lex();
	R1 = 0;
	count = asi64(R1);
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6891;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6892;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6892;
	goto L6893;
L6891:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	dim = asi64(R1);
	asi64(R1) = istop;
	if (asi64(R1)) goto L6895;
	asi64(R1) = dim;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6895;
	R1 = tou64("init/0-size array");
	cc_support_terror(asu64(R1));
L6895:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	melem = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = melem;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6897;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) != asi64(R2)) goto L6897;
	R1 = 1;
	braces = asi64(R1);
	goto L6898;
L6897:
	goto L6890;
L6892:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6900;
	R1 = tou64("init/Empty struct");
	cc_support_terror(asu64(R1));
L6900:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	melem = asi64(R1);
	goto L6890;
L6893:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L6887;
L6890:
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L6901:
	R1 = 0;
	asi64(R2) = melem;
	asu64(R3) = owner;
	asu64(R1) = cc_parse_readinitexpr2(asu64(R3), asi64(R2), asi64(R1));
	p = asu64(R1);
	R1 = (u64)&count;
	(*toi64p(R1)) += 1;
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6904;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6905;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6906;
	goto L6907;
L6904:
	asi64(R1) = dim;
	if (!asi64(R1)) goto L6909;
	asi64(R1) = count;
	asi64(R2) = dim;
	if (asi64(R1) <= asi64(R2)) goto L6909;
	R1 = tou64("Too many array elems");
	cc_support_terror(asu64(R1));
L6909:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = melem;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6911;
	R1 = (u64)&cc_decls_ttbasetype;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = melem;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6911;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) != asi64(R2)) goto L6911;
	goto L6910;
L6911:
	asi64(R1) = melem;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L6910:
	goto L6903;
L6905:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	mm = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mm;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6913;
	R1 = (u64)&cc_decls_ttbasetype;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = mm;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6913;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) != asi64(R2)) goto L6913;
	goto L6912;
L6913:
	asi64(R1) = mm;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L6912:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6915;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L6917;
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6917;
	R1 = tou64("Too many struct elems");
	cc_support_terror(asu64(R1));
L6917:
	goto L6914;
L6915:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	melem = asi64(R1);
L6914:
	goto L6903;
L6906:
	asi64(R1) = melem;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	goto L6918;
	goto L6903;
L6907:
L6903:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6920;
	goto L6902;
L6920:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L6922;
	cc_lex_lex();
	goto L6902;
L6922:
	cc_lex_lex();
	goto L6901;
L6902:
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6924;
	asi64(R1) = dim;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6924;
	asi64(R1) = count;
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = count;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = melem;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
L6924:
// cc_parse.readinitexpr2.donestruct:
L6918:
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = ulist;
	R2 = 28;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = count;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6888;
L6889:
	R1 = 0;
	braces = asi64(R1);
	asi64(R1) = mbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6926;
	goto L6927;
L6926:
// cc_parse.readinitexpr2.doarraystring:
L6898:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L6929;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L6929;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6929;
	R1 = tou64("{} initialiser expected");
	cc_support_terror(asu64(R1));
L6929:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) == asi64(R2)) goto L6931;
	asi64(R2) = cc_decls_trefwchar;
	if (asi64(R1) == asi64(R2)) goto L6932;
	goto L6933;
L6931:
	goto L6930;
L6932:
	goto L6930;
L6933:
	R1 = tou64("Array init");
	cc_support_terror(asu64(R1));
L6930:
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	dim = asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6935;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = R1;
	R3 = (u64)&cc_decls_ttsize;
	asi64(R4) = m;
	*toi64p(((i64)R3+(i64)R4*8)) = asi64(R2);
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = m;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	goto L6934;
L6935:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = dim;
	if (asi64(R1) <= asi64(R2)) goto L6937;
	R1 = tou64("Init str too long");
	cc_support_terror(asu64(R1));
L6937:
L6934:
	asi64(R1) = braces;
	if (!asi64(R1)) goto L6939;
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
L6939:
	asu64(R1) = p;
	goto L6887;
	goto L6925;
L6927:
L6925:
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L6888:
	asu64(R1) = p;
	goto L6887;
L6887:
	return asu64(R1);
}

static void cc_parse_pushblock() {
    u64 R1, R2, R3, R4; 
	i64 n;
	i64 m;
	asi64(R1) = cc_decls_blocklevel;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L6942;
	R1 = tou64("Too many block levels");
	cc_support_serror(asu64(R1));
L6942:
	asi64(R1) = cc_decls_nextblockno;
	R2 = 2100;
	if (asi64(R1) < asi64(R2)) goto L6944;
	R1 = tou64("Too many blocks");
	cc_support_serror(asu64(R1));
L6944:
	R1 = (u64)&cc_decls_blocklevel;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_decls_nextblockno;
	(*toi64p(R1)) += 1;
	asi64(R1) = cc_decls_currblockno;
	n = asi64(R1);
	asi64(R1) = cc_decls_blocklevel;
	m = asi64(R1);
	goto L6946;
L6945:
	R1 = (u64)&m;
	(*toi64p(R1)) -=1;
	R1 = (u64)&cc_decls_blockstack;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
L6946:
	asi64(R1) = m;
	if (!asi64(R1)) goto L6948;
	R1 = (u64)&cc_decls_blockcounts;
	R2 = (u64)&cc_decls_blockstack;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6945;
L6948:
	asi64(R1) = n;
	R2 = (u64)&cc_decls_blockowner;
	asi64(R3) = cc_decls_nextblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = cc_decls_nextblockno;
	R2 = R1;
	R3 = (u64)&cc_decls_blockstack;
	asi64(R4) = cc_decls_blocklevel;
	*toi32p(((i64)R3+(i64)R4*4)) = asi32(R2);
	cc_decls_currblockno = asi64(R1);
	R1 = 0;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	return;
}

static void cc_parse_popblock() {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_blockstack;
	R2 = (u64)&cc_decls_blocklevel;
	asi64(R2) = *(toi64p(R2)) -= 1;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	cc_decls_currblockno = asi64(R1);
	return;
}

static u64 cc_parse_readcompoundstmt(i64 params) {
    u64 R1, R2, R3, R4; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 q;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	cc_lex_lex();
	cc_parse_pushblock();
	asi64(R1) = params;
	if (!asi64(R1)) goto L6952;
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	R3 = 1;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L6952:
	goto L6954;
L6953:
	asu64(R1) = cc_parse_readstatement();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6957;
	goto L6954;
L6957:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L6959;
L6960:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L6964;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6964;
	R1 = 8;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L6964:
	asu64(R1) = q;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6960;
	goto L6958;
L6959:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L6958:
L6954:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L6953;
	cc_lex_lex();
	cc_parse_popblock();
	asu64(R1) = ulistx;
	R2 = 0;
	asu64(R3) = ulist;
	R4 = 6;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L6950;
L6950:
	return asu64(R1);
}

static u64 cc_parse_readblock(i64 ifelse) {
    u64 R1, R2; 
	asu64(R1) = cc_parse_readstatement();
	goto L6965;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 71;
	if (asi64(R1) != asi64(R2)) goto L6967;
	asi64(R1) = ifelse;
	if (!asi64(R1)) goto L6967;
	asu64(R1) = cc_parse_readstatement();
	goto L6965;
L6967:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6969;
	R1 = tou64("{...} statement expected");
	cc_support_serror(asu64(R1));
L6969:
	R1 = 0;
	asu64(R1) = cc_parse_readcompoundstmt(asi64(R1));
	goto L6965;
L6965:
	return asu64(R1);
}

static u64 cc_parse_readstatement() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	u64 ss;
	u64 d;
	i64 index;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 9: goto L6996;
	case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 68: case 69: case 72: case 89: goto L6973;
	case 17: goto L6980;
	case 67: goto L6997;
	case 70: case 83: case 84: case 85: case 86: case 87: case 88: case 90: goto L7013;
	case 71: goto L6974;
	case 73: goto L6994;
	case 74: goto L6995;
	case 75: goto L6975;
	case 76: goto L6976;
	case 77: goto L6977;
	case 78: goto L6978;
	case 79: goto L6982;
	case 80: goto L6987;
	case 81: goto L6981;
	case 82: goto L6979;
	default: goto L6973;
    };
// SWITCH
L6974:
	asu64(R1) = cc_parse_readifstmt();
	goto L6970;
	goto L6971;
L6975:
	asu64(R1) = cc_parse_readforstmt();
	goto L6970;
	goto L6971;
L6976:
	asu64(R1) = cc_parse_readwhilestmt();
	goto L6970;
	goto L6971;
L6977:
	asu64(R1) = cc_parse_readdostmt();
	goto L6970;
	goto L6971;
L6978:
	asu64(R1) = cc_parse_readreturnstmt();
	goto L6970;
	goto L6971;
L6979:
	asu64(R1) = cc_parse_readswitchstmt();
	goto L6970;
	goto L6971;
L6980:
	R1 = 0;
	asu64(R1) = cc_parse_readcompoundstmt(asi64(R1));
	goto L6970;
	goto L6971;
L6981:
	asu64(R1) = cc_parse_readgotostmt();
	goto L6970;
	goto L6971;
L6982:
	asi64(R1) = cc_parse_loopindex;
	if (!asi64(R1)) goto L6984;
	R1 = (u64)&cc_parse_looptypestack;
	asi64(R2) = cc_parse_loopindex;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 76;
	if (asi64(R1) != asi64(R2)) goto L6986;
	R1 = 20;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L6985;
L6986:
	R1 = 23;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
L6985:
	goto L6983;
L6984:
	R1 = tou64("break outside loop/sw");
	cc_support_serror(asu64(R1));
L6983:
	goto L6971;
L6987:
	asi64(R1) = cc_parse_loopindex;
	index = asi64(R1);
	goto L6989;
L6988:
	R1 = (u64)&index;
	(*toi64p(R1)) -=1;
L6989:
	asi64(R1) = index;
	if (!asi64(R1)) goto L6991;
	R1 = (u64)&cc_parse_looptypestack;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 76;
	if (asi64(R1) != asi64(R2)) goto L6988;
L6991:
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6993;
	R1 = tou64("continue outside loop");
	cc_support_serror(asu64(R1));
L6993:
	R1 = 21;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	cc_lex_lex();
	goto L6971;
L6994:
	asu64(R1) = cc_parse_readcaselabel();
	goto L6970;
	goto L6971;
L6995:
	cc_lex_lex();
	R1 = 10;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readstatement();
	R2 = 19;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	goto L6970;
	goto L6971;
L6996:
	cc_lex_lex();
	R1 = 0;
	goto L6970;
	goto L6971;
L6997:
	R1 = (u64)&cc_decls_nextlx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L6999;
	R1 = 0;
	R2 = 17;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 0;
	R2 = 3;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L7001;
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L7003;
	msysc_m$print_startcon();
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("2:Duplicate label");
	cc_support_terror(asu64(R1));
L7003:
	goto L7000;
L7001:
	R1 = 14;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L7000:
	R1 = -1;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	cc_lex_lex();
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L7005;
	goto L7004;
L7005:
	asi64(R1) = cc_parse_istypestarter();
	if (asi64(R1)) goto L7007;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 85;
	if (asi64(R1) != asi64(R2)) goto L7006;
L7007:
	goto L7004;
L7006:
	asu64(R1) = cc_parse_readstatement();
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7004:
	asu64(R1) = p;
	goto L6970;
	goto L6998;
L6999:
	R1 = 0;
	cc_parse_ist_symptr = asu64(R1);
	asu64(R1) = cc_decls_currproc;
	asi64(R1) = cc_parse_isusertype(asu64(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L7009;
	goto L7010;
L7009:
	asu64(R1) = cc_parse_ist_symptr;
	if (!asu64(R1)) goto L7012;
	asu64(R1) = cc_parse_ist_symptr;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L7012:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
L6998:
	goto L6971;
L7013:
// cc_parse.readstatement.doreaddecl:
L7010:
	asu64(R1) = cc_parse_readlocaldecl();
	goto L6970;
	goto L6971;
L6973:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
L6971:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L6970;
L6970:
	return asu64(R1);
}

static u64 cc_parse_readifstmt() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 pcond;
	u64 pbody;
	u64 pelse;
	i64 lineno;
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	lineno = asi64(R1);
	asu64(R1) = cc_parse_readcond();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	pelse = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 72;
	if (asi64(R1) != asi64(R2)) goto L7016;
	cc_lex_lex();
	R1 = 1;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pelse = asu64(R1);
L7016:
	asu64(R1) = pelse;
	asu64(R2) = pbody;
	asu64(R3) = pcond;
	R4 = 12;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = lineno;
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pcond;
	asi64(R1) = cc_parse_iscondtrue(asu64(R1));
	if (!asi64(R1)) goto L7018;
	asu64(R1) = pbody;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7020;
	R1 = 6;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pbody = asu64(R1);
L7020:
	asu64(R1) = pbody;
	asu64(R2) = p;
	cc_parse_deleteunit(asu64(R2), asu64(R1));
	goto L7017;
L7018:
	asu64(R1) = pcond;
	asi64(R1) = cc_parse_iscondfalse(asu64(R1));
	if (!asi64(R1)) goto L7021;
	asu64(R1) = pelse;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7023;
	R1 = 6;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pelse = asu64(R1);
L7023:
	asu64(R1) = pelse;
	asu64(R2) = p;
	cc_parse_deleteunit(asu64(R2), asu64(R1));
L7021:
L7017:
	asu64(R1) = p;
	goto L7014;
L7014:
	return asu64(R1);
}

static i64 cc_parse_iscondtrue(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7025;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7025;
	R1 = 1;
	goto L7026;
L7025:
	R1 = 0;
L7026:
	goto L7024;
L7024:
	return asi64(R1);
}

static i64 cc_parse_iscondfalse(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7028;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7028;
	R1 = 1;
	goto L7029;
L7028:
	R1 = 0;
L7029:
	goto L7027;
L7027:
	return asi64(R1);
}

static void cc_parse_deleteunit(u64 p, u64 q) {
    u64 R1, R2, R3; struct $B32 R1_B32; 
	u64 r;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = q;
	(R1_B32) = *(struct $B32*)(R1);
	asu64(R2) = p;
	*(struct $B32*)(R2) = (R1_B32);
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 cc_parse_readforstmt() {
    u64 R1, R2, R3, R4; 
	u64 pinit;
	u64 pcond;
	u64 pincr;
	u64 pbody;
	u64 ulist;
	u64 ulistx;
	u64 p;
	i64 linkage;
	i64 hasblock;
	i64 m;
	i64 mbase;
	u64 pm;
	u64 d;
	cc_lex_lex();
	R1 = 13;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 0;
	hasblock = asi64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7033;
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L7035;
	R1 = 1;
	hasblock = asi64(R1);
	cc_parse_pushblock();
	R1 = (u64)&linkage;
	asu64(R2) = cc_decls_currproc;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L7036:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7038;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7038;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7038;
	goto L7039;
L7038:
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = cc_decls_currproc;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7041;
	R1 = tou64("Var name expected");
	cc_support_serror(asu64(R1));
L7041:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7044;
	asu64(R1) = pm;
	if (!asu64(R1)) goto L7043;
L7044:
	R1 = tou64("Not allowed in for stmt");
	cc_support_serror(asu64(R1));
L7043:
	asi64(R1) = linkage;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R1) = cc_parse_readframevar(asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7046;
	R1 = 8;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L7046:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7048;
	goto L7049;
L7048:
	cc_lex_lex();
	goto L7047;
L7049:
	goto L7037;
L7047:
	goto L7036;
L7039:
	R1 = tou64("For decl error");
	cc_support_serror(asu64(R1));
	goto L7036;
L7037:
	asu64(R1) = ulistx;
	R2 = 0;
	asu64(R3) = ulist;
	R4 = 6;
	asu64(R1) = cc_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	pinit = asu64(R1);
	goto L7034;
L7035:
	asu64(R1) = cc_parse_readexpression();
	pinit = asu64(R1);
L7034:
	goto L7032;
L7033:
	R1 = 2;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pinit = asu64(R1);
L7032:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7051;
	asu64(R1) = cc_parse_readexpression();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	goto L7050;
L7051:
	R1 = 2;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	pcond = asu64(R1);
L7050:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7053;
	asu64(R1) = cc_parse_readexprstmt();
	pincr = asu64(R1);
	goto L7052;
L7053:
	R1 = 0;
	pincr = asu64(R1);
L7052:
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	R1 = 76;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	cc_parse_poploop();
	asi64(R1) = hasblock;
	if (!asi64(R1)) goto L7055;
	cc_parse_popblock();
L7055:
	asu64(R1) = pcond;
	asu64(R2) = pinit;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pincr;
	asu64(R2) = pcond;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pinit;
	R3 = 13;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L7031;
L7031:
	return asu64(R1);
}

static u64 cc_parse_readwhilestmt() {
    u64 R1, R2, R3; 
	u64 pcond;
	u64 pbody;
	cc_lex_lex();
	asu64(R1) = cc_parse_readcond();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	R1 = 76;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	cc_parse_poploop();
	asu64(R1) = pbody;
	asu64(R2) = pcond;
	R3 = 14;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L7056;
L7056:
	return asu64(R1);
}

static u64 cc_parse_readdostmt() {
    u64 R1, R2, R3; 
	u64 pbody;
	u64 pcond;
	cc_lex_lex();
	R1 = 76;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pbody = asu64(R1);
	cc_parse_poploop();
	R1 = 76;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readcond();
	pcond = asu64(R1);
	asu64(R1) = pcond;
	cc_parse_coercecond(asu64(R1));
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = pcond;
	asu64(R2) = pbody;
	R3 = 15;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L7057;
L7057:
	return asu64(R1);
}

static u64 cc_parse_readreturnstmt() {
    u64 R1, R2; 
	u64 p;
	cc_lex_lex();
	R1 = 0;
	p = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7060;
	asu64(R1) = cc_decls_currproc;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7062;
	R1 = tou64("Can't return value in void function");
	cc_support_terror(asu64(R1));
L7062:
	asu64(R1) = cc_parse_readexpression();
	p = asu64(R1);
	asu64(R1) = cc_decls_currproc;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 9;
	cc_lib_checksymbol(asi64(R1));
	goto L7059;
L7060:
	asu64(R1) = cc_decls_currproc;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7063;
	R1 = tou64("Return value needed");
	cc_support_terror(asu64(R1));
L7063:
L7059:
	cc_lex_lex();
	asu64(R1) = p;
	R2 = 9;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	goto L7058;
L7058:
	return asu64(R1);
}

static u64 cc_parse_readgotostmt() {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 p;
	cc_lex_lex();
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = 0;
	R2 = 3;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = cc_decls_currproc;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7066;
	R1 = 14;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L7066:
	R1 = 0;
	R2 = 16;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	cc_lex_lex();
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = p;
	goto L7064;
L7064:
	return asu64(R1);
}

static u64 cc_parse_readswitchstmt() {
    u64 R1, R2, R3; 
	u64 pindex;
	u64 pstmt;
	u64 p;
	cc_lex_lex();
	asu64(R1) = cc_parse_readcond();
	pindex = asu64(R1);
	R1 = 3;
	asu64(R2) = pindex;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	R1 = 83;
	cc_parse_pushloop(asi64(R1));
	R1 = 0;
	asu64(R1) = cc_parse_readblock(asi64(R1));
	pstmt = asu64(R1);
	asu64(R1) = pstmt;
	asu64(R2) = pindex;
	R3 = 22;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&cc_parse_casevaluestack;
	asi64(R2) = cc_parse_loopindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	cc_parse_poploop();
	asu64(R1) = p;
	goto L7067;
L7067:
	return asu64(R1);
}

static u64 cc_parse_readcaselabel() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 value;
	cc_lex_lex();
	asi64(R1) = cc_parse_readconstintexpr();
	value = asi64(R1);
	R1 = 10;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readstatement();
	R2 = 18;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = value;
	cc_parse_addcasevalue(asi64(R1));
	asu64(R1) = p;
	goto L7068;
L7068:
	return asu64(R1);
}

static u64 cc_parse_readexprstmt() {
    u64 R1; 
	asu64(R1) = cc_parse_readexpression();
	goto L7069;
L7069:
	return asu64(R1);
}

static u64 cc_parse_readcond() {
    u64 R1; 
	u64 pcond;
	R1 = 13;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = cc_parse_readexpression();
	pcond = asu64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = pcond;
	goto L7070;
L7070:
	return asu64(R1);
}

static i64 cc_parse_isusertype(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = owner;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L7073;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L7075;
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L7071;
L7075:
	asu64(R1) = d;
	cc_parse_ist_symptr = asu64(R1);
L7073:
	R1 = 20;
	goto L7071;
L7071:
	return asi64(R1);
}

static u64 cc_parse_readlocaldecl() {
    u64 R1, R2, R3, R4, R5; 
	i64 m;
	i64 mbase;
	i64 linkage;
	i64 nitems;
	i64 wasenum;
	i64 wasdef;
	u64 d;
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 pm;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	wasenum = asi64(R1);
	R1 = (u64)&linkage;
	asu64(R2) = cc_decls_currproc;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
	R1 = 0;
	nitems = asi64(R1);
L7077:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7079;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7079;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7079;
	goto L7080;
L7079:
	R1 = (u64)&nitems;
	(*toi64p(R1)) += 1;
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = cc_decls_currproc;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7082;
	R1 = tou64("Var name expected");
	cc_support_serror(asu64(R1));
L7082:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L7084;
	asi64(R1) = m;
	asu64(R2) = d;
	asu64(R3) = cc_decls_currproc;
	asu64(R1) = cc_parse_createtypedef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	goto L7083;
L7084:
	asu64(R1) = pm;
	if (!asu64(R1)) goto L7085;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7087;
	R1 = tou64("Nested function");
	cc_support_serror(asu64(R1));
L7087:
	R1 = (u64)&wasdef;
	asu64(R2) = pm;
	asi64(R3) = linkage;
	asi64(R4) = m;
	asu64(R5) = d;
	asu64(R1) = cc_parse_readfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	d = asu64(R1);
	goto L7083;
L7085:
	asi64(R1) = linkage;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R1) = cc_parse_readframevar(asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	R1 = 7;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L7083:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7089;
	goto L7090;
L7089:
	cc_lex_lex();
	goto L7088;
L7090:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L7078;
L7088:
	goto L7077;
L7080:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7092;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7092;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7092;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7093;
	goto L7094;
L7092:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L7078;
	goto L7091;
L7093:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L7078;
	goto L7091;
L7094:
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Local decl error #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7091:
	goto L7077;
L7078:
	asu64(R1) = ulist;
	goto L7076;
L7076:
	return asu64(R1);
}

static u64 cc_parse_createtypedef(u64 owner, u64 symptr, i64 mode) {
    u64 R1, R2, R3, R4; 
	u64 d;
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	asu64(R3) = symptr;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L7097;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7099;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Typedef name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7099:
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R2) = mode;
	if (asi64(R1) == asi64(R2)) goto L7101;
	asi64(R1) = mode;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L7103;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Typedef redefined or can't match types #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7103:
L7101:
	asu64(R1) = d;
	goto L7095;
L7097:
	R1 = 5;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = mode;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = d;
	R2 = (u64)&cc_decls_tttypedef;
	asi64(R3) = mode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = d;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = d;
	goto L7095;
L7095:
	return asu64(R1);
}

static u64 cc_parse_readparams(u64 owner) {
    u64 R1, R2, R3, R4, R5; 
	u64 ulist;
	u64 ulistx;
	u64 pm;
	u64 q;
	i64 m;
	i64 lastbasetype;
	i64 nparams;
	i64 variadic;
	i64 flags;
	i64 nnames;
	u64 d;
	i64 names;
	i64 nonames;
	i64 reported;
	R1 = 0;
	d = asu64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	R2 = R1;
	nnames = asi64(R2);
	R2 = R1;
	nparams = asi64(R2);
	variadic = asi64(R1);
	R1 = 0;
	lastbasetype = asi64(R1);
	R1 = 0;
	names = asi64(R1);
	R1 = 0;
	nonames = asi64(R1);
	R1 = 0;
	reported = asi64(R1);
	goto L7106;
L7105:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L7109;
	R1 = 1;
	variadic = asi64(R1);
	cc_lex_lex();
	goto L7107;
L7109:
	asi64(R1) = cc_parse_istypestarter();
	if (!asi64(R1)) goto L7111;
	R1 = (u64)&lastbasetype;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 1;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = pm;
	if (!asu64(R1)) goto L7113;
	asu64(R1) = pm;
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
L7113:
	goto L7110;
L7111:
	asi64(R1) = lastbasetype;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7115;
	R1 = tou64("Param type missing or misspelt");
	cc_support_serror(asu64(R1));
L7115:
	R1 = 0;
	asi64(R2) = lastbasetype;
	R3 = (u64)&pm;
	R4 = 1;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
L7110:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7117;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7118;
	goto L7119;
L7117:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
	goto L7116;
L7118:
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R2) = m;
	asi64(R1) = cc_lib_createprocmode(asi64(R2), asu64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	m = asi64(R1);
	goto L7116;
L7119:
L7116:
	R1 = 24;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pm = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = pm;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = pm;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&nparams;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	if (!asu64(R1)) goto L7121;
	R1 = 1;
	names = asi64(R1);
	goto L7120;
L7121:
	R1 = 1;
	nonames = asi64(R1);
L7120:
	asi64(R1) = names;
	if (!asi64(R1)) goto L7123;
	asi64(R1) = nonames;
	if (!asi64(R1)) goto L7123;
	asi64(R1) = reported;
	if (asi64(R1)) goto L7123;
	R1 = 1;
	reported = asi64(R1);
L7123:
	asu64(R1) = d;
	if (!asu64(R1)) goto L7125;
	R1 = (u64)&nnames;
	(*toi64p(R1)) += 1;
	asu64(R1) = ulist;
	q = asu64(R1);
	goto L7127;
L7126:
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L7130;
	R1 = (u64)&cc_tables_namenames;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Param name reused # #");
	cc_support_serror_ss(asu64(R3), asu64(R2), asu64(R1));
L7130:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L7127:
	asu64(R1) = q;
	if (asu64(R1)) goto L7126;
L7125:
	asu64(R1) = pm;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7132;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L7133;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7133;
	goto L7134;
L7132:
	cc_lex_lex();
	goto L7131;
L7133:
	goto L7131;
L7134:
	R1 = tou64("bad symbol in paramlist");
	cc_support_serror(asu64(R1));
L7131:
L7106:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L7105;
L7107:
	R1 = 0;
	flags = asi64(R1);
	R1 = 14;
	cc_lib_skipsymbol(asi64(R1));
	asi64(R1) = variadic;
	if (!asi64(R1)) goto L7136;
	R1 = 3;
	flags = asi64(R1);
	goto L7135;
L7136:
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7137;
	R1 = 1;
	flags = asi64(R1);
	goto L7135;
L7137:
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7138;
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7138;
	R1 = 2;
	flags = asi64(R1);
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	asu64(R2) = ulist;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7138:
L7135:
	asu64(R1) = ulist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7140;
	R1 = 24;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	ulist = asu64(R1);
L7140:
	asi64(R1) = nparams;
	asu64(R2) = ulist;
	R3 = 20;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = flags;
	asu64(R2) = ulist;
	R3 = 22;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = ulist;
	goto L7104;
L7104:
	return asu64(R1);
}

static i64 cc_parse_readcasttype(u64 d, i64 allowname, u64 pm, i64 m, u64 mbase) {
    u64 R1, R2, R3, R4; 
	u64 owner;
	i64 linkage;
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L7143;
	asu64(R1) = cc_decls_currproc;
	goto L7142;
L7143:
	asu64(R1) = cc_decls_stmodule;
L7142:
	owner = asu64(R1);
	R1 = 0;
	linkage = asi64(R1);
	R1 = 0;
	asu64(R2) = d;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7145;
	R1 = (u64)&linkage;
	asu64(R2) = owner;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = mbase;
	if (!asu64(R1)) goto L7147;
	asi64(R1) = m;
	asu64(R2) = mbase;
	*toi64p(R2) = asi64(R1);
L7147:
L7145:
	R1 = 0;
	asu64(R2) = pm;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7149;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7149;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7149;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L7149;
	goto L7150;
L7149:
	asu64(R1) = pm;
	asi64(R2) = m;
	asu64(R3) = d;
	asu64(R4) = owner;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	asu64(R1) = *tou64p(R1);
	if (!asu64(R1)) goto L7152;
	asi64(R1) = allowname;
	if (asi64(R1)) goto L7152;
	asu64(R1) = d;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("NAME not allowed in cast type #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7152:
	goto L7148;
L7150:
L7148:
	asi64(R1) = m;
	goto L7141;
L7141:
	return asi64(R1);
}

static u64 cc_parse_readfunction(u64 d, i64 m, i64 linkage, u64 pm, u64 wasdef) {
    u64 R1, R2, R3, R4; 
	u64 f;
	u64 owner;
	i64 scope;
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
	R1 = 0;
	asu64(R2) = wasdef;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (!asu64(R1)) goto L7155;
	asu64(R1) = f;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7157;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("fn: name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7157:
	asu64(R1) = f;
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	scope = asi64(R1);
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7159;
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7159;
	R1 = 4;
	scope = asi64(R1);
	goto L7158;
L7159:
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7160;
	R1 = 2;
	scope = asi64(R1);
L7160:
L7158:
	goto L7154;
L7155:
	R1 = 6;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = linkage;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7162;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7163;
	goto L7164;
L7162:
	R1 = 2;
	scope = asi64(R1);
	goto L7161;
L7163:
	R1 = 3;
	scope = asi64(R1);
	goto L7161;
L7164:
	R1 = 4;
	scope = asi64(R1);
L7161:
L7154:
	asu64(R1) = pm;
	asu64(R2) = d;
	R3 = 80;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7166;
	R1 = 1;
	asu64(R2) = wasdef;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7168;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Can't define function twice #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7168:
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7170;
	R1 = 4;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7170:
	asu64(R1) = d;
	cc_parse_readfunctionbody(asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L7172;
	R1 = tou64("; after function def");
	cc_support_serror(asu64(R1));
L7172:
L7166:
	asu64(R1) = d;
	goto L7153;
L7153:
	return asu64(R1);
}

static void cc_parse_readfunctionbody(u64 f) {
    u64 R1, R2, R3; 
	u64 e;
	u64 p;
	u64 pm;
	i64 pmcount;
	i64 av_1;
	asu64(R1) = f;
	cc_decls_currproc = asu64(R1);
	R1 = 0;
	R2 = R1;
	cc_decls_currblockno = asi64(R2);
	cc_decls_nextblockno = asi64(R1);
	R1 = 0;
	pmcount = asi64(R1);
	asu64(R1) = f;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7176;
L7174:
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7178;
	goto L7177;
L7178:
	R1 = 9;
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = f;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) != asu64(R2)) goto L7180;
	R1 = 1;
	asu64(R2) = e;
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7180:
	R1 = 1;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = pm;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
L7177:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	R1 = 1;
	pmcount = asi64(R1);
	if (--asi64(av_1)) goto L7174;
L7176:
	asi64(R1) = pmcount;
	asu64(R1) = cc_parse_readcompoundstmt(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = cc_decls_currproc;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	cc_decls_currproc = asu64(R1);
	return;
}

static u64 cc_parse_createnegop(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7183;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7185;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7185;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7185;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7186;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7187;
	goto L7188;
L7185:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L7181;
	goto L7184;
L7186:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
	R2 = 4294967295;
	asi64(R1) &= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L7181;
	goto L7184;
L7187:
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asr64(R1) = -asr64(R1);
	asu64(R2) = p;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asu64(R1) = p;
	goto L7181;
	goto L7184;
L7188:
L7184:
L7183:
// cc_parse.createnegop.retry:
L7189:
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7191;
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) > asi64(R2)) goto L7191;
	asu64(R1) = p;
	cc_parse_coercebasetype(asu64(R1));
	asu64(R1) = p;
	R2 = 58;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	goto L7190;
L7191:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7192;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	goto L7189;
	goto L7190;
L7192:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("neg bad type");
	cc_support_terror(asu64(R1));
L7190:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L7181;
L7181:
	return asu64(R1);
}

static u64 cc_parse_createabsop(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7195;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7197;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7197;
	goto L7198;
L7197:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L7193;
	goto L7196;
L7198:
L7196:
L7195:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L7200;
	asu64(R1) = p;
	cc_parse_coercebasetype(asu64(R1));
	asu64(R1) = p;
	R2 = 59;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	goto L7199;
L7200:
	R1 = tou64("abs bad type");
	cc_support_terror(asu64(R1));
L7199:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L7193;
L7193:
	return asu64(R1);
}

static u64 cc_parse_createinotop(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7203;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7205;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7205;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7205;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7205;
	goto L7206;
L7205:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = ~asi64(R1);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L7201;
	goto L7204;
L7206:
L7204:
L7203:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L7208;
	asu64(R1) = p;
	cc_parse_coercebasetype(asu64(R1));
	asu64(R1) = p;
	R2 = 60;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	goto L7207;
L7208:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("! bad type");
	cc_support_terror(asu64(R1));
L7207:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L7201;
L7201:
	return asu64(R1);
}

static u64 cc_parse_createptrop(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 t;
	i64 m;
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = R2;
	t = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7211;
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_showdummy_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("* not pointer");
	cc_support_terror(asu64(R1));
L7211:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L7213;
	goto L7214;
L7213:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	cc_parse_fixmemopnd(asu64(R1));
	asu64(R1) = q;
	goto L7209;
	goto L7212;
L7214:
L7212:
	asu64(R1) = p;
	R2 = 52;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R1) = cc_parse_arraytopointer(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	cc_parse_fixmemopnd(asu64(R1));
	asu64(R1) = q;
	goto L7209;
L7209:
	return asu64(R1);
}

static u64 cc_parse_createincrop(i64 opc, u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	cc_parse_checklvalue(asu64(R2), asi64(R1));
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L7218;
	asi64(R1) = t;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L7217;
L7218:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7217;
	R1 = tou64("++ bad type");
	cc_support_terror(asu64(R1));
L7217:
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	goto L7215;
L7215:
	return asu64(R1);
}

static u64 cc_parse_createaddrofop(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 q;
	i64 t;
	i64 u;
	i64 alength;
	R1 = 0;
	alength = asi64(R1);
// cc_parse.createaddrofop.restartx:
L7220:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L7222;
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
L7222:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7224;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L7225;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L7226;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L7227;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7228;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7229;
	goto L7230;
L7224:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 108;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L7232;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	alength = asi64(R1);
L7232:
	goto L7223;
L7225:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7234;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L7234;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L7219;
L7234:
	goto L7223;
L7226:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L7236;
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7236;
	R1 = 3;
	asu64(R2) = p;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 0;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	asu64(R2) += asu64(R3);
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L7219;
L7236:
	goto L7237;
	goto L7223;
L7227:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L7239;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&cc_decls_tttarget;
	asu64(R3) = p;
	R4 = 52;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = cc_lib_createarraymode(asi64(R2), asi64(R1));
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L7219;
L7239:
	goto L7223;
L7228:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L7220;
	goto L7223;
L7229:
	asu64(R1) = p;
	goto L7219;
	goto L7223;
L7230:
// cc_parse.createaddrofop.cad1:
L7237:
	R1 = 0;
	asu64(R2) = p;
	cc_parse_checklvalue(asu64(R2), asi64(R1));
L7223:
	asu64(R1) = p;
	R2 = 55;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = t;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = alength;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L7219;
L7219:
	return asu64(R1);
}

static u64 cc_parse_createaddop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	i64 elemsize;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 39;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L7242;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L7241;
L7242:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7243;
// cc_parse.createaddop.doaddref:
L7244:
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = u;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7246;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7246;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	asu64(R2) = x;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = x;
	goto L7240;
L7246:
	R1 = 4;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 53;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemsize;
	asu64(R2) = z;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7240;
	goto L7241;
L7243:
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7247;
	R1 = (u64)&x;
	R2 = (u64)&y;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
	goto L7244;
	R1 = tou64("Sub bad types");
	cc_support_terror(asu64(R1));
L7247:
L7241:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7249;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7251;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_add(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L7240;
	goto L7250;
L7251:
	R1 = (u64)&x;
	R2 = (u64)&y;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L7250:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7253;
	asu64(R1) = x;
	goto L7240;
L7253:
L7249:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7240;
L7240:
	return asu64(R1);
}

static u64 cc_parse_createsubop(u64 x, u64 y) {
    u64 R1, R2, R3, R4, R5; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	i64 elemsize;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 40;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L7256;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L7255;
L7256:
	asi64(R1) = s;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7257;
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7259;
	asu64(R1) = x;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = u;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	elemsize = asi64(R1);
	R1 = 4;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	asu64(R1) = y;
	asu64(R2) = x;
	R3 = 54;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemsize;
	asu64(R2) = z;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7254;
	goto L7258;
L7259:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7261;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7261;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asu64(R4) = x;
	R5 = 52;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = x;
	*toi64p(R2) -= asi64(R1);
	R1 = 3;
	asu64(R2) = x;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = x;
	goto L7254;
	goto L7260;
L7261:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	R1 = 4;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = z;
	asu64(R1) = cc_parse_divunit(asu64(R2), asi64(R1));
	z = asu64(R1);
	R1 = 4;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7254;
L7260:
L7258:
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = y;
	asu64(R1) = cc_parse_mulunit(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L7255;
L7257:
	R1 = tou64("Sub bad types");
	cc_support_terror(asu64(R1));
L7255:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7263;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7263;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_sub(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L7254;
L7263:
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7265;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7265;
L7265:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7254;
L7254:
	return asu64(R1);
}

static u64 cc_parse_createmulop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 41;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L7268;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L7267;
L7268:
	R1 = tou64("Mul bad types");
	cc_support_terror(asu64(R1));
L7267:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7270;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7272;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_mul(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L7266;
	goto L7271;
L7272:
	R1 = (u64)&x;
	R2 = (u64)&y;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L7271:
L7270:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7266;
L7266:
	return asu64(R1);
}

static u64 cc_parse_createdivop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	asi64(R2) = cc_parse_getmemmode(asu64(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 42;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L7275;
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L7274;
L7275:
	R1 = tou64("Div bad types");
	cc_support_terror(asu64(R1));
L7274:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7277;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7277;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_div(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L7273;
	goto L7276;
L7277:
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7278;
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L7278;
	R1 = 41;
	opc = asi64(R1);
	asr64(R1) = 1.000000000000000000e+000;
	asu64(R2) = y;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asr64(R1) /= asr64(R2);
	asu64(R2) = y;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
L7278:
L7276:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7273;
L7273:
	return asu64(R1);
}

static u64 cc_parse_createremop(u64 x, u64 y) {
    u64 R1, R2, R3, R4; 
	u64 z;
	i64 s;
	i64 t;
	i64 u;
	i64 opc;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = x;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	R1 = 43;
	opc = asi64(R1);
	R1 = (u64)&cc_tables_dominantmode;
	asi64(R2) = s;
	R1 += (i64)R2*32;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	u = asi64(R2);
	if (!asi64(R1)) goto L7281;
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7284;
	asi64(R1) = u;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L7283;
L7284:
	R1 = 3;
	u = asi64(R1);
L7283:
	asi64(R1) = u;
	asu64(R2) = x;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	x = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	y = asu64(R1);
	goto L7280;
L7281:
	R1 = tou64("Rem bad types");
	cc_support_terror(asu64(R1));
L7280:
	asu64(R1) = x;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7286;
	asu64(R1) = y;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7286;
	asi64(R1) = u;
	asu64(R2) = y;
	asu64(R3) = x;
	asi64(R4) = opc;
	asu64(R1) = cc_parse_eval_rem(asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L7279;
L7286:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = u;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7279;
L7279:
	return asu64(R1);
}

static void cc_parse_insertunit(u64 p, i64 tag) {
    u64 R1, R2, R3, R4; struct $B32 R1_B32; 
	u64 q;
	R1 = 0;
	asu64(R1) = cc_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B32) = *(struct $B32*)(R1);
	asu64(R2) = q;
	*(struct $B32*)(R2) = (R1_B32);
	asi64(R1) = tag;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 32;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 56;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 cc_parse_eval_add(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3, R4; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7290;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7290;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7290;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7290;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7291;
	goto L7292;
L7290:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = x;
	goto L7288;
	goto L7289;
L7291:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) += asr64(R1);
	asu64(R1) = x;
	goto L7288;
	goto L7289;
L7292:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7294;
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	asu64(R2) = x;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = x;
	goto L7288;
L7294:
L7289:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7288;
L7288:
	return asu64(R1);
}

static u64 cc_parse_eval_sub(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7297;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7297;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7297;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7297;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7298;
	goto L7299;
L7297:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = x;
	goto L7295;
	goto L7296;
L7298:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) -= asr64(R1);
	asu64(R1) = x;
	goto L7295;
	goto L7296;
L7299:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7301;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = y;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7303;
	R1 = tou64("EVALSUB/REF");
	cc_support_terror(asu64(R1));
L7303:
	asu64(R1) = x;
	goto L7295;
L7301:
L7296:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7295;
L7295:
	return asu64(R1);
}

static u64 cc_parse_eval_mul(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7306;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7306;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7306;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7306;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7307;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7307;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7307;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7307;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7308;
	goto L7309;
L7306:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*toi64p(R2) *= asi64(R1);
	asu64(R1) = x;
	goto L7304;
	goto L7305;
L7307:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) *= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = x;
	goto L7304;
	goto L7305;
L7308:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) *= asr64(R1);
	asu64(R1) = x;
	goto L7304;
	goto L7305;
L7309:
L7305:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7304;
L7304:
	return asu64(R1);
}

static u64 cc_parse_eval_div(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7312;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7312;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7313;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7313;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7314;
	goto L7315;
L7312:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7317;
	R1 = tou64("div 0");
	cc_support_serror(asu64(R1));
L7317:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	goto L7310;
	goto L7311;
L7313:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7319;
	R1 = tou64("div 0");
	cc_support_serror(asu64(R1));
L7319:
	asu64(R1) = x;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	asu64(R2) = x;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = x;
	goto L7310;
	goto L7311;
L7314:
	asu64(R1) = y;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asu64(R2) = x;
	*tor64p(R2) /= asr64(R1);
	asu64(R1) = x;
	goto L7310;
	goto L7311;
L7315:
L7311:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7310;
L7310:
	return asu64(R1);
}

static u64 cc_parse_eval_rem(i64 opc, u64 x, u64 y, i64 t) {
    u64 R1, R2, R3; 
	u64 z;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7322;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7322;
	goto L7323;
L7322:
	asu64(R1) = y;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7325;
	R1 = tou64("rem 0");
	cc_support_serror(asu64(R1));
L7325:
	asu64(R1) = x;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = y;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) %= asi64(R2);
	asu64(R2) = x;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = x;
	goto L7320;
	goto L7321;
L7323:
L7321:
	asu64(R1) = y;
	asu64(R2) = x;
	asi64(R3) = opc;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	z = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = z;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = z;
	goto L7320;
L7320:
	return asu64(R1);
}

static i64 cc_parse_eval_convert(u64 p, i64 t, i64 opc) {
    u64 R1, R2, R3; 
	i64 s;
	asi64(R1) = opc;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7328;
// cc_parse.eval_convert.dosoft:
L7329:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L7326;
L7328:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L7331;
	R1 = 1;
	goto L7326;
L7331:
	asi64(R1) = s;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7333;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7333;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7333;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7333;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7334;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7334;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7334;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7334;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7335;
	goto L7336;
L7333:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7338;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7338;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7339;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7339;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7339;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7339;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7339;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7339;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7339;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7339;
	goto L7340;
L7338:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = p;
	R3 = 0;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L7326;
	goto L7337;
L7339:
// cc_parse.eval_convert.dotrunc:
L7341:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7343;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7344;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7345;
	goto L7346;
L7343:
	R1 = 255;
	asu64(R2) = p;
	*toi64p(R2) &= asi64(R1);
	R1 = (u64)&cc_tables_stdsigned;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7348;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = toi64(toi8(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7348:
	goto L7342;
L7344:
	R1 = 65535;
	asu64(R2) = p;
	*toi64p(R2) &= asi64(R1);
	R1 = (u64)&cc_tables_stdsigned;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7350;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = toi64(toi16(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7350:
	goto L7342;
L7345:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 4294967295;
	asi64(R1) &= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&cc_tables_stdsigned;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7352;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L7352:
	goto L7342;
L7346:
L7342:
	goto L7329;
	goto L7337;
L7340:
L7337:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7354;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L7326;
L7354:
	goto L7332;
L7334:
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7356;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7356;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7357;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7357;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7357;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7357;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7357;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7357;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7357;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7357;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7357;
	goto L7358;
L7356:
	R1 = 0;
	goto L7326;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L7326;
	goto L7355;
L7357:
	goto L7341;
	goto L7355;
L7358:
L7355:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7360;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L7326;
L7360:
	goto L7332;
L7335:
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7362;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7362;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7363;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7363;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7364;
	goto L7365;
L7362:
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L7326;
	goto L7361;
L7363:
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L7326;
	goto L7361;
L7364:
	R1 = 10;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L7326;
	goto L7361;
L7365:
L7361:
	goto L7332;
L7336:
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7367;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7369;
	asi64(R1) = t;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7371;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7371;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7371;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7371;
	goto L7372;
L7371:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	goto L7326;
	goto L7370;
L7372:
L7370:
L7369:
L7367:
L7332:
	R1 = 0;
	goto L7326;
L7326:
	return asi64(R1);
}

static void cc_parse_coercecond(u64 p) {
    u64 R1, R2, R3; 
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	t = asi64(R2);
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7375;
	goto L7373;
L7375:
// cc_parse.coercecond.retry:
L7376:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7378;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7378;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7378;
	goto L7379;
L7378:
	goto L7380;
	goto L7377;
L7379:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L7382;
// cc_parse.coercecond.doint:
L7380:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7384;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L7384;
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7383;
L7384:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7385;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (asi64(R1)) goto L7385;
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7383;
L7385:
	R1 = 27;
	asu64(R2) = p;
	cc_parse_insertunit(asu64(R2), asi64(R1));
L7383:
	goto L7381;
L7382:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7386;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	goto L7376;
	goto L7381;
L7386:
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	R2 = tou64("Invalid condition #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7381:
L7377:
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7373:
	return;
}

static void cc_parse_coercebasetype(u64 p) {
    u64 R1, R2; 
	i64 t;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	t = asi64(R2);
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7389;
	asi64(R1) = t;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L7389;
	R1 = 3;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L7388;
L7389:
	asi64(R1) = t;
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L7390;
	asi64(R1) = t;
	R2 = 7;
	if (asi64(R1) > asi64(R2)) goto L7390;
	R1 = 8;
	asu64(R2) = p;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	p = asu64(R1);
L7390:
L7388:
	return;
}

static void cc_parse_checklvalue(u64 p, i64 assign) {
    u64 R1, R2, R3, R4; struct $B32 R1_B32; 
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7393;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L7394;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7395;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7396;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L7397;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7398;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L7399;
	goto L7400;
L7393:
	goto L7392;
L7394:
	goto L7392;
L7395:
	asi64(R1) = assign;
	if (!asi64(R1)) goto L7402;
	goto L7403;
L7402:
	goto L7392;
L7396:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7405;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L7405;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L7405;
	goto L7406;
L7405:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	(R1_B32) = *(struct $B32*)(R1);
	asu64(R2) = p;
	*(struct $B32*)(R2) = (R1_B32);
	goto L7404;
L7406:
	R1 = tou64("CHECKLV/WIDEN");
	cc_support_terror(asu64(R1));
L7404:
	goto L7392;
L7397:
	goto L7392;
L7398:
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7408;
	goto L7403;
L7408:
	goto L7392;
L7399:
	asi64(R1) = assign;
	if (!asi64(R1)) goto L7410;
	goto L7403;
L7410:
	goto L7392;
L7400:
// cc_parse.checklvalue.notlv:
L7403:
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_showdummy_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("value: #");
	cc_support_terror_s(asu64(R2), asu64(R1));
L7392:
	return;
}

static u64 cc_parse_createcall(u64 p, u64 q) {
    u64 R1, R2, R3, R4; 
	u64 r;
	u64 s;
	u64 u;
	u64 d;
	u64 pm;
	i64 i;
	i64 nparams;
	i64 aparams;
	i64 retmode;
	i64 mproc;
	i64 m;
	i64 c;
	struct $B42 str;
	u64 ss;
	u64 tt;
	u64 uu;
	u64 exprstr;
	R1 = 0;
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L7413;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7414;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7414;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L7415;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L7415;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L7415;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L7415;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L7415;
	goto L7416;
L7413:
// cc_parse.createcall.doptr:
L7417:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mproc = asi64(R1);
	goto L7419;
L7418:
	asu64(R1) = p;
	R2 = 52;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	r = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	mproc = asi64(R1);
	asi64(R1) = mproc;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	p = asu64(R1);
L7419:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7418;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L7422;
	asi64(R1) = mproc;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Not function pointer: #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7422:
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = mproc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = mproc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	retmode = asi64(R1);
	goto L7412;
L7414:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L7424;
	asu64(R1) = d;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	retmode = asi64(R1);
	goto L7423;
L7424:
	goto L7417;
L7423:
	goto L7412;
L7415:
	asu64(R1) = p;
	R2 = 52;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	r = asu64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	p = asu64(R1);
	goto L7417;
	goto L7412;
L7416:
	msysc_m$print_startcon();
	R1 = tou64("JTAGNAMES[P.TAG]=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_jtagnames;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_showdummy_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("ccall?");
	cc_support_serror(asu64(R1));
L7412:
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nparams = asi64(R1);
	R1 = 0;
	aparams = asi64(R1);
	asu64(R1) = q;
	s = asu64(R1);
	goto L7426;
L7425:
	R1 = (u64)&aparams;
	(*toi64p(R1)) += 1;
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
L7426:
	asu64(R1) = s;
	if (asu64(R1)) goto L7425;
	asi64(R1) = aparams;
	asi64(R2) = nparams;
	if (asi64(R1) >= asi64(R2)) goto L7429;
	R1 = tou64("1:Too few args");
	cc_support_terror(asu64(R1));
	goto L7428;
L7429:
	asi64(R1) = aparams;
	asi64(R2) = nparams;
	if (asi64(R1) <= asi64(R2)) goto L7430;
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7430;
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7430;
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7432;
	msysc_m$print_startcon();
	asi64(R1) = aparams;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Too many args");
	cc_support_terror(asu64(R1));
L7432:
L7430:
L7428:
	asu64(R1) = q;
	s = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = aparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7435;
L7433:
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L7437;
	asu64(R1) = pm;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = s;
	cc_parse_coercemode_inplace(asu64(R2), asi64(R1));
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	goto L7436;
L7437:
	asu64(R1) = s;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7439;
	R1 = tou64("Variadic param is void");
	cc_support_terror(asu64(R1));
L7439:
	asu64(R1) = s;
	cc_parse_coercebasetype(asu64(R1));
L7436:
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	i += 1; if (i <= aparams) goto L7433;
L7435:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 30;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	asi64(R1) = retmode;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	cc_parse_fixmemopnd(asu64(R1));
	asi64(R1) = aparams;
	asu64(R2) = r;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	goto L7411;
L7411:
	return asu64(R1);
}

static u64 cc_parse_arraytopointer(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 offset;
	i64 t;
	i64 elemmode;
	i64 refmode;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemmode = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7442;
	asi64(R1) = elemmode;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	refmode = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L7444;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L7445;
	goto L7446;
L7444:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L7443;
L7445:
	asu64(R1) = p;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	R1 = 53;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 55;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asi64(R1) = refmode;
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 3;
	asi64(R2) = offset;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7443;
L7446:
	msysc_m$print_startcon();
	R1 = tou64("ATP:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_showdummy_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("ATP?");
	cc_support_terror(asu64(R1));
L7443:
	asi64(R1) = refmode;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7442:
	asu64(R1) = p;
	goto L7440;
L7440:
	return asu64(R1);
}

static u64 cc_parse_createindexop(u64 p, u64 q) {
    u64 R1, R2; 
	u64 a;
	asu64(R1) = q;
	asu64(R2) = p;
	asu64(R1) = cc_parse_createaddop(asu64(R2), asu64(R1));
	a = asu64(R1);
	asu64(R1) = a;
	asu64(R1) = cc_parse_createptrop(asu64(R1));
	goto L7447;
L7447:
	return asu64(R1);
}

static i64 cc_parse_readstructdecl(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 currrecord;
	u64 ulist;
	u64 ulistx;
	u64 tagowner;
	i64 funion;
	i64 linkage;
	i64 mbase;
	i64 m;
	i64 offset;
	i64 recsize;
	i64 maxsize;
	i64 maxalignment;
	i64 alignment;
	i64 size;
	u64 pm;
	u64 fieldlist;
	u64 fl;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	funion = asi64(R1);
	cc_lex_lex();
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L7450;
	asu64(R1) = cc_decls_currproc;
	goto L7449;
L7450:
	asu64(R1) = cc_decls_stmodule;
L7449:
	tagowner = asu64(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7452;
	asu64(R1) = cc_lib_nextautotype();
	asu64(R1) = cc_lex_addnamestr(asu64(R1));
	d = asu64(R1);
	goto L7451;
L7452:
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7454;
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = tagowner;
	asu64(R1) = cc_lib_resolvename(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L7456;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7458;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Struct tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7458:
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L7448;
L7456:
	R1 = 13;
	asu64(R2) = d;
	asu64(R3) = tagowner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asi64(R1) = funion;
	if (!asi64(R1)) goto L7460;
	R1 = 19;
	goto L7459;
L7460:
	R1 = 18;
L7459:
	asu64(R2) = e;
	asi64(R1) = cc_lib_createstructmode(asu64(R2), asi64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L7448;
L7454:
L7451:
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = tagowner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L7462;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7464;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Struct tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7464:
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7466;
	msysc_m$print_startcon();
	R1 = tou64("Prev");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = e;
	R2 = 92;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1677215;
	asi64(R1) &= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	asu64(R2) = e;
	R3 = 92;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	asi64(R2) >>= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asu64(R2) = e;
	R3 = 92;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	asi64(R2) >>= asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Redefining struct #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7466:
	goto L7461;
L7462:
	R1 = 13;
	asu64(R2) = d;
	asu64(R3) = tagowner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asi64(R1) = funion;
	if (!asi64(R1)) goto L7468;
	R1 = 19;
	goto L7467;
L7468:
	R1 = 18;
L7467:
	asu64(R2) = e;
	asi64(R1) = cc_lib_createstructmode(asu64(R2), asi64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L7461:
	cc_lex_lex();
	asu64(R1) = e;
	currrecord = asu64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	R2 = R1;
	recsize = asi64(R2);
	R2 = R1;
	maxsize = asi64(R2);
	offset = asi64(R1);
	R1 = 1;
	maxalignment = asi64(R1);
	R1 = 0;
	fieldlist = asu64(R1);
	R1 = -1;
	m = asi64(R1);
	goto L7470;
L7469:
	R1 = (u64)&linkage;
	asu64(R2) = currrecord;
	asi64(R1) = cc_parse_readdeclspec(asu64(R2), asu64(R1));
	mbase = asi64(R1);
L7472:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7474;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L7474;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L7474;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7475;
	goto L7476;
L7474:
	R1 = (u64)&pm;
	asi64(R2) = mbase;
	R3 = (u64)&d;
	asu64(R4) = currrecord;
	asi64(R1) = cc_parse_readtype(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	m = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7478;
	R1 = tou64("Field name expected");
	cc_support_serror(asu64(R1));
L7478:
	asi64(R1) = linkage;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7481;
	asu64(R1) = pm;
	if (!asu64(R1)) goto L7480;
L7481:
	R1 = tou64("typedef or function inside struct");
	cc_support_serror(asu64(R1));
L7480:
	R1 = 0;
	R2 = 4;
	asu64(R3) = d;
	asu64(R4) = currrecord;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L7483;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("member name in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7483:
	asi64(R1) = linkage;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7485;
	R1 = tou64("Can't use ss in struct");
	cc_support_serror(asu64(R1));
L7485:
// cc_parse.readstructdecl.addanonfield:
L7486:
	R1 = 10;
	asu64(R2) = d;
	R3 = 0;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = d;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = d;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	cc_lib_addlistdef(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = ulist;
	asu64(R2) = currrecord;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ulistx;
	asu64(R2) = currrecord;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = currrecord;
	asu64(R2) = d;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	asi64(R1) = cc_lib_getalignment(asi64(R1));
	alignment = asi64(R1);
	asi64(R1) = alignment;
	asi64(R2) = maxalignment;
	if (asi64(R1) <= asi64(R2)) goto L7488;
	asi64(R1) = alignment;
	maxalignment = asi64(R1);
L7488:
	asi64(R1) = alignment;
	asi64(R2) = offset;
	asi64(R1) = cc_parse_roundoffset(asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&recsize;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	asi64(R1) = offset;
	asu64(R2) = d;
	R3 = (u64)&fieldlist;
	cc_parse_addnewfield(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = funion;
	if (!asi64(R1)) goto L7490;
	asi64(R1) = maxsize;
	asi64(R2) = size;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	maxsize = asi64(R1);
	goto L7489;
L7490:
	asi64(R1) = size;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&recsize;
	*toi64p(R2) += asi64(R1);
L7489:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L7492;
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
L7492:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7494;
	goto L7495;
L7494:
	cc_lex_lex();
	goto L7493;
L7495:
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L7473;
L7493:
	goto L7472;
L7475:
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	R1 = 9;
	cc_lib_skipsymbol(asi64(R1));
	goto L7473;
	goto L7472;
L7476:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = mbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7497;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7497;
	goto L7498;
L7497:
	asu64(R1) = cc_lib_getautofieldname();
	d = asu64(R1);
	asi64(R1) = mbase;
	m = asi64(R1);
	goto L7486;
	goto L7496;
L7498:
	asi64(R1) = m;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L7500;
	R1 = tou64("Struct decl error");
	cc_support_serror(asu64(R1));
	goto L7499;
L7500:
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	R2 = tou64("Struct decl error #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7499:
L7496:
	goto L7472;
L7473:
L7470:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L7469;
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	asu64(R1) = fieldlist;
	asu64(R2) = currrecord;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = maxalignment;
	asi64(R2) = funion;
	if (!asi64(R2)) goto L7502;
	asi64(R2) = maxsize;
	goto L7501;
L7502:
	asi64(R2) = recsize;
L7501:
	asi64(R1) = cc_parse_roundoffset(asi64(R2), asi64(R1));
	R2 = (u64)&cc_decls_ttsize;
	asu64(R3) = currrecord;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = maxalignment;
	asu64(R2) = currrecord;
	R3 = 112;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = currrecord;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7505;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7505;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7505;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L7504;
L7505:
	R1 = 0;
	R2 = (u64)&cc_decls_ttisblock;
	asu64(R3) = currrecord;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7504:
	asu64(R1) = currrecord;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L7448;
L7448:
	return asi64(R1);
}

static i64 cc_parse_checkpointertypes(i64 s, i64 t, i64 hard) {
    u64 R1, R2, R3; 
	i64 starget;
	i64 ttarget;
	i64 sbase;
	i64 tbase;
	i64 sconst;
	i64 tconst;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	starget = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	ttarget = asi64(R1);
	R1 = 0;
	sconst = asi64(R1);
	R1 = 0;
	tconst = asi64(R1);
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = starget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7508;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = starget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	starget = asi64(R1);
	R1 = 1;
	sconst = asi64(R1);
L7508:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = ttarget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7510;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = ttarget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	ttarget = asi64(R1);
	R1 = 1;
	tconst = asi64(R1);
L7510:
	asi64(R1) = hard;
	if (asi64(R1)) goto L7512;
	asi64(R1) = sconst;
	if (!asi64(R1)) goto L7512;
	asi64(R1) = tconst;
	if (asi64(R1)) goto L7512;
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = s;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("const to non-const pointer");
	cc_support_terror(asu64(R1));
L7512:
	asi64(R1) = starget;
	asi64(R2) = ttarget;
	if (asi64(R1) != asi64(R2)) goto L7514;
	R1 = 1;
	goto L7506;
L7514:
	asi64(R1) = starget;
	s = asi64(R1);
	asi64(R1) = ttarget;
	t = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	sbase = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	tbase = asi64(R1);
	asi64(R1) = sbase;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7516;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L7516;
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7516;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L7516;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = sbase;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = tbase;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) != asi64(R2)) goto L7518;
	R1 = 1;
	goto L7506;
L7518:
L7516:
	asi64(R1) = sbase;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7521;
	asi64(R1) = tbase;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7520;
L7521:
	R1 = 1;
	goto L7506;
L7520:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7523;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7523;
	asi64(R1) = hard;
	asi64(R2) = t;
	asi64(R3) = s;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	goto L7506;
	goto L7522;
L7523:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7524;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7524;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = t;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) == asi64(R2)) goto L7526;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L7528;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L7528;
	msysc_m$print_startcon();
	R1 = tou64("BAD REF[]");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	goto L7506;
	R1 = 0;
	goto L7506;
L7528:
L7526:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	starget = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	ttarget = asi64(R1);
	asi64(R1) = starget;
	asi64(R2) = ttarget;
	if (asi64(R1) != asi64(R2)) goto L7530;
	R1 = 1;
	goto L7506;
L7530:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = starget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7532;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = ttarget;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7532;
	asi64(R1) = hard;
	asi64(R2) = ttarget;
	asi64(R3) = starget;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	goto L7506;
L7532:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = starget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7534;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = ttarget;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7534;
	asi64(R1) = hard;
	asi64(R2) = ttarget;
	asi64(R3) = starget;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	goto L7506;
L7534:
	goto L7522;
L7524:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L7535;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L7535;
	R1 = 1;
	goto L7506;
L7535:
L7522:
	R1 = 0;
	goto L7506;
L7506:
	return asi64(R1);
}

static i64 cc_parse_comparemode(i64 s, i64 t) {
    u64 R1, R2, R3; 
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L7538;
	R1 = 1;
	goto L7536;
L7538:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7540;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7540;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = s;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7542;
	R1 = 0;
	goto L7536;
L7542:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7545;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L7545;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = t;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	if (asi64(R1) != asi64(R2)) goto L7544;
L7545:
	R1 = 1;
	goto L7536;
L7544:
L7540:
	R1 = 0;
	goto L7536;
L7536:
	return asi64(R1);
}

static i64 cc_parse_readenumdecl(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7548;
	asu64(R1) = owner;
	cc_parse_readenumnames(asu64(R1));
	R1 = 12;
	goto L7546;
L7548:
	R1 = 67;
	cc_lib_checksymbol(asi64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L7550;
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L7552;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7554;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Enum tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7554:
L7552:
	R1 = 12;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asi64(R1) = cc_lib_createenummode(asu64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L7546;
L7550:
	asi64(R1) = cc_decls_currblockno;
	R2 = 2;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L7556;
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L7558;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Enum tag in use #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7558:
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7560;
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Redefining enum #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7560:
	goto L7555;
L7556:
	R1 = 12;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asi64(R1) = cc_lib_createenummode(asu64(R1));
	asu64(R2) = e;
	R3 = 102;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = e;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L7555:
	asu64(R1) = owner;
	cc_parse_readenumnames(asu64(R1));
	asu64(R1) = e;
	R2 = (u64)&cc_decls_ttnamedef;
	asu64(R3) = e;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = e;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	goto L7546;
L7546:
	return asi64(R1);
}

static void cc_parse_readenumnames(u64 owner) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 ulist;
	u64 ulistx;
	i64 enumseq;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	enumseq = asi64(R1);
	cc_lex_lex();
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7563;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7563;
	goto L7564;
L7563:
	goto L7562;
L7564:
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L7566;
	asu64(R1) = cc_decls_currproc;
	goto L7565;
L7566:
	asu64(R1) = cc_decls_stmodule;
L7565:
	owner = asu64(R1);
L7562:
	goto L7568;
L7567:
	asi64(R1) = cc_decls_currblockno;
	R2 = 1;
	R3 = (u64)&cc_decls_lx;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = owner;
	asu64(R1) = cc_lib_checkdupl(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L7571;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("enum name reused #");
	cc_support_serror_s(asu64(R2), asu64(R1));
L7571:
	R1 = 11;
	R2 = (u64)&cc_decls_lx;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	d = asu64(R1);
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L7573;
	cc_lex_lex();
	asi64(R1) = cc_parse_readconstintexpr();
	enumseq = asi64(R1);
L7573:
	asi64(R1) = enumseq;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = cc_decls_currblockno;
	asu64(R2) = d;
	R3 = 96;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_blockcounts;
	asi64(R3) = cc_decls_currblockno;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&enumseq;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L7575;
	cc_lex_lex();
L7575:
L7568:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L7567;
	R1 = 18;
	cc_lib_skipsymbol(asi64(R1));
	return;
}

static u64 cc_parse_createdotop(i64 opc, u64 p, u64 d) {
    u64 R1, R2, R3; 
	u64 q;
	u64 r;
	u64 poffset;
	u64 pb;
	u64 pc;
	u64 e;
	u64 f;
	u64 prec;
	u64 panon;
	u64 pfield;
	u64 gend;
	i64 m;
	i64 offset;
	i64 scale;
	u64 fl;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asi64(R1) = opc;
	R2 = 50;
	if (asi64(R1) != asi64(R2)) goto L7578;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L7580;
	R1 = tou64("-> needs pointer");
	cc_support_serror(asu64(R1));
L7580:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
L7578:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L7582;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L7582;
	goto L7583;
L7582:
	goto L7581;
L7583:
	R1 = tou64(". -> not a struct");
	cc_support_serror(asu64(R1));
L7581:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	prec = asu64(R1);
	asu64(R1) = d;
	f = asu64(R1);
	goto L7585;
L7584:
	asu64(R1) = f;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = prec;
	if (asu64(R1) != asu64(R2)) goto L7588;
	asu64(R1) = f;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset = asi64(R1);
	goto L7586;
L7588:
L7585:
	asu64(R1) = f;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	f = asu64(R2);
	if (asu64(R1)) goto L7584;
L7586:
	asu64(R1) = f;
	if (asu64(R1)) goto L7590;
	asu64(R1) = d;
	gend = asu64(R1);
	goto L7592;
L7591:
	asu64(R1) = gend;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	gend = asu64(R1);
L7592:
	asu64(R1) = gend;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L7591;
	asu64(R1) = prec;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fl = asu64(R1);
	goto L7595;
L7594:
	asu64(R1) = fl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = gend;
	if (asu64(R1) != asu64(R2)) goto L7598;
	asu64(R1) = fl;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	f = asu64(R1);
	asu64(R1) = fl;
	R2 = 24;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	offset = asi64(R1);
	goto L7596;
L7598:
	asu64(R1) = fl;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fl = asu64(R1);
L7595:
	asu64(R1) = fl;
	if (asu64(R1)) goto L7594;
L7596:
L7590:
	asu64(R1) = f;
	if (asu64(R1)) goto L7600;
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Not a field of struct # #");
	cc_support_terror_ss(asu64(R3), asu64(R2), asu64(R1));
L7600:
	R1 = 3;
	asi64(R2) = offset;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	poffset = asu64(R1);
	asi64(R1) = opc;
	R2 = 50;
	if (asi64(R1) != asi64(R2)) goto L7602;
	asu64(R1) = p;
	asu64(R1) = cc_parse_createptrop(asu64(R1));
	p = asu64(R1);
L7602:
	asu64(R1) = p;
	R2 = 49;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = p;
	R3 = 0;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = f;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R1) = cc_parse_arraytopointer(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	cc_parse_fixmemopnd(asu64(R1));
	asu64(R1) = p;
	goto L7576;
L7576:
	return asu64(R1);
}

static u64 cc_parse_mulunit(u64 p, i64 elemtype) {
    u64 R1, R2, R3; 
	i64 elemsize;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	elemsize = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7605;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7607;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7606;
L7607:
	asu64(R1) = p;
	R2 = 57;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = elemsize;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7606:
L7605:
	asu64(R1) = p;
	goto L7603;
L7603:
	return asu64(R1);
}

static u64 cc_parse_divunit(u64 p, i64 elemtype) {
    u64 R1, R2, R3; 
	i64 elemsize;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = elemtype;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	elemsize = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7610;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7612;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = elemsize;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L7611;
L7612:
	asu64(R1) = p;
	R2 = 57;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = elemsize;
	asi64(R1) = -asi64(R1);
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7611:
L7610:
	asu64(R1) = p;
	goto L7608;
L7608:
	return asu64(R1);
}

static u64 cc_parse_createassignopref(i64 opc, u64 p, u64 q) {
    u64 R1, R2, R3, R4; 
	i64 pmode;
	i64 qmode;
	i64 rmode;
	i64 elemmode;
	u64 r;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = R1;
	rmode = asi64(R2);
	pmode = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = pmode;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	elemmode = asi64(R1);
	asu64(R1) = q;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qmode = asi64(R1);
	asi64(R1) = opc;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7615;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L7616;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L7617;
	goto L7618;
L7615:
	asi64(R1) = pmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 11;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	goto L7614;
L7616:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = qmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7620;
	R1 = tou64("ptr+=ptr");
	cc_support_serror(asu64(R1));
L7620:
	R1 = 4;
	asu64(R2) = q;
	asu64(R1) = cc_parse_coercemode(asu64(R2), asi64(R1));
	q = asu64(R1);
	asi64(R1) = elemmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_mulunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 61;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	goto L7614;
L7617:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = qmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7622;
	asi64(R1) = qmode;
	asi64(R2) = pmode;
	asi64(R1) = cc_parse_comparemode(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L7624;
	R1 = tou64("-= refs don't match");
	cc_support_serror(asu64(R1));
L7624:
	asi64(R1) = elemmode;
	asu64(R2) = q;
	asu64(R3) = p;
	R4 = 40;
	asu64(R2) = cc_lib_createunit2(asi64(R4), asu64(R3), asu64(R2));
	asu64(R1) = cc_parse_divunit(asu64(R2), asi64(R1));
	r = asu64(R1);
	R1 = 3;
	rmode = asi64(R1);
	goto L7621;
L7622:
	asi64(R1) = elemmode;
	asu64(R2) = q;
	asu64(R1) = cc_parse_mulunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 62;
	asu64(R1) = cc_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
L7621:
	goto L7614;
L7618:
	R1 = tou64("Not allowed on ptrs");
	cc_support_serror(asu64(R1));
L7614:
	asi64(R1) = rmode;
	asu64(R2) = r;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	goto L7613;
L7613:
	return asu64(R1);
}

static void cc_parse_addnewfield(u64 flist, u64 d, i64 offset) {
    u64 R1, R2, R3; 
	u64 e;
	u64 f;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L7627;
	R1 = 32;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	f = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = f;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L7629;
L7628:
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7629:
	asu64(R1) = d;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L7628;
	asu64(R1) = d;
	asu64(R2) = f;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = offset;
	asu64(R2) = f;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = flist;
	asu64(R1) = *tou64p(R1);
	asu64(R2) = f;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = flist;
	*tou64p(R2) = asu64(R1);
	goto L7626;
L7627:
	R1 = (u64)&cc_decls_ttnamedef;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L7632;
L7631:
	asi64(R1) = offset;
	asu64(R2) = e;
	R3 = 88;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = e;
	asu64(R3) = flist;
	cc_parse_addnewfield(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L7632:
	asu64(R1) = e;
	if (asu64(R1)) goto L7631;
L7626:
	return;
}

static void cc_parse_pushloop(i64 looptype) {
    u64 R1, R2, R3; 
	asi64(R1) = cc_parse_loopindex;
	R2 = 64;
	if (asi64(R1) < asi64(R2)) goto L7636;
	R1 = tou64("Too many nested loop or switch");
	cc_support_serror(asu64(R1));
L7636:
	R1 = (u64)&cc_parse_loopindex;
	(*toi64p(R1)) += 1;
	asi64(R1) = looptype;
	R2 = (u64)&cc_parse_looptypestack;
	asi64(R3) = cc_parse_loopindex;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cc_parse_casevaluestack;
	asi64(R3) = cc_parse_loopindex;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static void cc_parse_poploop() {
    u64 R1; 
	asi64(R1) = cc_parse_loopindex;
	if (!asi64(R1)) goto L7639;
	R1 = (u64)&cc_parse_loopindex;
	(*toi64p(R1)) -=1;
	goto L7638;
L7639:
	R1 = tou64("poploop?");
	cc_support_serror(asu64(R1));
L7638:
	return;
}

static void cc_parse_addcasevalue(i64 value) {
    u64 R1, R2, R3; 
	u64 p;
	i64 index;
	asi64(R1) = cc_parse_loopindex;
	index = asi64(R1);
	goto L7642;
L7641:
	R1 = (u64)&index;
	(*toi64p(R1)) -=1;
L7642:
	asi64(R1) = index;
	if (!asi64(R1)) goto L7644;
	R1 = (u64)&cc_parse_looptypestack;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L7641;
L7644:
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7646;
	R1 = tou64("case not inside switch stmt");
	cc_support_serror(asu64(R1));
L7646:
	R1 = 16;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = value;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = (u64)&cc_parse_casevaluestack;
	asi64(R2) = index;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&cc_parse_casevaluestack;
	asi64(R3) = index;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static i64 cc_parse_roundoffset(i64 offset, i64 alignment) {
    u64 R1, R2; 
	i64 mask;
	asi64(R1) = cc_decls_structpadding;
	if (!asi64(R1)) goto L7649;
	asi64(R1) = alignment;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7651;
	asi64(R1) = offset;
	goto L7647;
L7651:
	asi64(R1) = alignment;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mask = asi64(R1);
	goto L7653;
L7652:
	R1 = (u64)&offset;
	(*toi64p(R1)) += 1;
L7653:
	asi64(R1) = offset;
	asi64(R2) = mask;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L7652;
L7649:
	asi64(R1) = offset;
	goto L7647;
L7647:
	return asi64(R1);
}

static void cc_parse_fixmemopnd(u64 p) {
    u64 R1, R2, R3; 
	i64 t;
	asu8(R1) = cc_parse_ingeneric;
	if (!asu8(R1)) goto L7657;
	goto L7655;
L7657:
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = R1;
	t = asi64(R2);
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7659;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7659;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7659;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7659;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7659;
	goto L7660;
L7659:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 56;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L7658;
L7660:
L7658:
L7655:
	return;
}

static u64 cc_parse_docast(u64 p, i64 t, i64 hard, i64 inplace) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 s;
	i64 opc;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
// cc_parse.docast.retry:
L7662:
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L7664;
	asu64(R1) = p;
	goto L7661;
L7664:
	R1 = 0;
	opc = asi64(R1);
	asi64(R1) = s;
	R2 = 16;
	if (asi64(R1) >= asi64(R2)) goto L7666;
	asi64(R1) = t;
	R2 = 16;
	if (asi64(R1) >= asi64(R2)) goto L7666;
	R1 = (u64)&cc_tables_conversionops;
	asi64(R2) = s;
	R1 += (i64)R2*16;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	goto L7665;
L7666:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7667;
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7667;
	asi64(R1) = hard;
	asi64(R2) = t;
	asi64(R3) = s;
	asi64(R1) = cc_parse_checkpointertypes(asi64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L7669;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L7661;
L7669:
	goto L7665;
L7667:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7670;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	goto L7662;
	goto L7665;
L7670:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7671;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	goto L7662;
	goto L7665;
L7671:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7672;
	asi64(R1) = s;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (!asi64(R1)) goto L7672;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7672;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7672;
	R1 = 1;
	opc = asi64(R1);
L7672:
L7665:
	asi64(R1) = opc;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7674;
	asi64(R1) = hard;
	if (asi64(R1)) goto L7676;
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = s;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_showdummy_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = t;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asi64(R2) = s;
	asu64(R2) = cc_lib_typename(asi64(R2));
	R3 = tou64("Can't do conversion # => #");
	cc_support_terror_ss(asu64(R3), asu64(R2), asu64(R1));
L7676:
	R1 = 2;
	opc = asi64(R1);
L7674:
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7678;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7679;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7680;
	goto L7681;
L7678:
	asi64(R1) = opc;
	asi64(R2) = t;
	asu64(R3) = p;
	asi64(R1) = cc_parse_eval_convert(asu64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L7683;
	asu64(R1) = p;
	goto L7661;
L7683:
	goto L7677;
L7679:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L7661;
	goto L7677;
L7680:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7685;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7685;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	goto L7661;
L7685:
	goto L7677;
L7681:
L7677:
	asi64(R1) = inplace;
	if (!asi64(R1)) goto L7687;
	R1 = 56;
	asu64(R2) = p;
	cc_parse_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 58;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = t;
	asi64(R1) = cc_parse_getpromotedtype(asi64(R1));
	asu64(R2) = p;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	goto L7661;
	goto L7686;
L7687:
	asu64(R1) = p;
	R2 = 56;
	asu64(R1) = cc_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = q;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = t;
	asu64(R2) = q;
	R3 = 58;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = t;
	asi64(R1) = cc_parse_getpromotedtype(asi64(R1));
	asu64(R2) = q;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7686:
	asu64(R1) = q;
	goto L7661;
L7661:
	return asu64(R1);
}

static u64 cc_parse_coercemode(u64 p, i64 t) {
    u64 R1, R2, R3, R4; 
	i64 s;
	i64 opc;
	u64 q;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L7690;
	asu64(R1) = p;
	goto L7688;
L7690:
	R1 = 1;
	R2 = 0;
	asi64(R3) = t;
	asu64(R4) = p;
	asu64(R1) = cc_parse_docast(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	goto L7688;
L7688:
	return asu64(R1);
}

static void cc_parse_coercemode_inplace(u64 p, i64 t) {
    u64 R1, R2, R3, R4; 
	i64 s;
	i64 opc;
	u64 q;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L7693;
	goto L7691;
L7693:
	R1 = 1;
	R2 = 0;
	asi64(R3) = t;
	asu64(R4) = p;
	asu64(R1) = cc_parse_docast(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
L7691:
	return;
}

static u64 cc_parse_createsizeofop(u64 p, i64 islength) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 t;
	i64 size;
	asi64(R1) = islength;
	if (!asi64(R1)) goto L7696;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L7696;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L7696;
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_showdummy_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	R1 = tou64("Not array");
	cc_support_serror(asu64(R1));
L7696:
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7698;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7699;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L7700;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L7701;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L7702;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7703;
	goto L7704;
L7698:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L7706;
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	size = asi64(R1);
	goto L7705;
L7706:
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L7705:
	goto L7697;
L7699:
	asi64(R1) = t;
	asi64(R2) = cc_decls_trefchar;
	if (asi64(R1) == asi64(R2)) goto L7708;
	asi64(R2) = cc_decls_trefwchar;
	if (asi64(R1) == asi64(R2)) goto L7709;
	goto L7710;
L7708:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	size = asi64(R1);
	goto L7707;
L7709:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 2;
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
	goto L7707;
L7710:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L7707:
	goto L7697;
L7700:
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7712;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L7712;
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = t;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
	goto L7711;
L7712:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L7711:
	goto L7697;
L7701:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L7714;
	asi64(R1) = islength;
	if (!asi64(R1)) goto L7716;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	size = asi64(R1);
	goto L7715;
L7716:
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = t;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
L7715:
	goto L7713;
L7714:
	goto L7717;
L7713:
	goto L7697;
L7702:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7719;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L7719;
	asi64(R1) = islength;
	if (!asi64(R1)) goto L7721;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	size = asi64(R1);
	goto L7720;
L7721:
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L7720:
	goto L7718;
L7719:
	R1 = 8;
	size = asi64(R1);
L7718:
	goto L7697;
L7703:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = cc_parse_createsizeofop(asu64(R2), asi64(R1));
	goto L7694;
	goto L7697;
L7704:
// cc_parse.createsizeofop.cad1:
L7717:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
L7697:
	R1 = 9;
	asi64(R2) = size;
	asu64(R1) = cc_lib_createconstunit(asu64(R2), asi64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	goto L7694;
L7694:
	return asu64(R1);
}

static u64 cc_parse_readgeneric() {
    u64 R1, R2, R3, R4, R5; 
	u64 pexpr;
	u64 pmatch;
	u64 p;
	u64 pm;
	i64 m;
	i64 t;
	i64 def;
	i64 oldingeneric;
	i64 count;
	u64 d;
	cc_lex_lex();
	R1 = 13;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu8(R1) = cc_parse_ingeneric;
	R1 = toi64(tou8(R1));
	oldingeneric = asi64(R1);
	R1 = 1;
	cc_parse_ingeneric = asu8(R1);
	asu64(R1) = cc_parse_readassignexpr();
	pexpr = asu64(R1);
	asi64(R1) = oldingeneric;
	cc_parse_ingeneric = asu8(R1);
	asu64(R1) = pexpr;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = 0;
	pmatch = asu64(R1);
	R1 = 0;
	def = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	R1 = 8;
	cc_lib_checksymbol(asi64(R1));
L7723:
	cc_lex_lex();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 74;
	if (asi64(R1) != asi64(R2)) goto L7727;
	asi64(R1) = def;
	if (!asi64(R1)) goto L7729;
	R1 = tou64("generic/default twice");
	cc_support_serror(asu64(R1));
L7729:
	R1 = 1;
	def = asi64(R1);
	asi64(R1) = count;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7731;
	R1 = -1;
	t = asi64(R1);
	goto L7730;
L7731:
	R1 = -2;
	t = asi64(R1);
L7730:
	cc_lex_lex();
	goto L7726;
L7727:
	R1 = 0;
	R2 = 0;
	R3 = (u64)&pm;
	R4 = 0;
	R5 = (u64)&d;
	asi64(R1) = cc_parse_readcasttype(asu64(R5), asi64(R4), asu64(R3), asi64(R2), asu64(R1));
	t = asi64(R1);
L7726:
	R1 = 10;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = cc_parse_readassignexpr();
	p = asu64(R1);
	asi64(R1) = t;
	R2 = -1;
	if (asi64(R1) == asi64(R2)) goto L7734;
	asi64(R1) = t;
	asi64(R2) = m;
	if (asi64(R1) != asi64(R2)) goto L7733;
L7734:
	asu64(R1) = p;
	pmatch = asu64(R1);
	R1 = (u64)&count;
	(*toi64p(R1)) += 1;
L7733:
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7723;
	R1 = 14;
	cc_lib_checksymbol(asi64(R1));
	cc_lex_lex();
	asu64(R1) = pmatch;
	if (asu64(R1)) goto L7736;
	R1 = tou64("Generic: no type match");
	cc_support_serror(asu64(R1));
L7736:
	asi64(R1) = count;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L7738;
	R1 = tou64("Generic: multiple types match");
	cc_support_serror(asu64(R1));
L7738:
	asu64(R1) = pmatch;
	goto L7722;
L7722:
	return asu64(R1);
}

static i64 cc_parse_getmemmode(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L7741;
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	goto L7740;
L7741:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
L7740:
	goto L7739;
L7739:
	return asi64(R1);
}

static i64 cc_parse_getpromotedtype(i64 t) {
    u64 R1, R2; 
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7744;
	R1 = 0;
	goto L7742;
L7744:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L7746;
	R1 = 3;
	goto L7742;
L7746:
	asi64(R1) = t;
	goto L7742;
L7742:
	return asi64(R1);
}

static void cc_genpcl_codegen_pcl() {
    u64 R1, R2, R3; 
	u64 d;
	u64 e;
	u64 pp;
	asu8(R1) = cc_cli_fverbose;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7749;
	msysc_m$print_startcon();
	R1 = tou64("GenPCL:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L7749:
	asi64(R1) = cc_decls_nunits;
	R2 = 0;
	asu64(R1) = pc_api_pcl_start(asu64(R2), asi64(R1));
	cc_genpcl_dolibs();
	R1 = tou64("1:Start of code");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = cc_decls_stmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L7751;
L7750:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7754;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7755;
	goto L7756;
L7754:
	asu64(R1) = d;
	cc_genpcl_dostaticvar(asu64(R1));
	goto L7753;
L7755:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L7758;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L7759;
	goto L7760;
L7758:
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7762;
	R1 = 3;
	asu64(R2) = d;
	R3 = 110;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L7762:
	goto L7757;
L7759:
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L7764;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Static fn not defined: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L7764:
	goto L7757;
L7760:
L7757:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L7766;
L7765:
	asu64(R1) = e;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7769;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7770;
	goto L7771;
L7769:
	asu64(R1) = e;
	cc_genpcl_dostaticvar(asu64(R1));
	goto L7768;
L7770:
	asu64(R1) = e;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7773;
	asu64(R1) = e;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L7776;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = e;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7775;
	asu64(R1) = e;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7775;
L7776:
	asu64(R1) = e;
	cc_genpcl_dostaticvar(asu64(R1));
L7775:
L7773:
	goto L7768;
L7771:
L7768:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L7766:
	asu64(R1) = e;
	if (asu64(R1)) goto L7765;
	goto L7753;
L7756:
L7753:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7751:
	asu64(R1) = d;
	if (asu64(R1)) goto L7750;
	R1 = tou64("");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = cc_decls_stmodule;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L7778;
L7777:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7781;
	goto L7782;
L7781:
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7784;
	asu64(R1) = d;
	cc_genpcl_genprocdef(asu64(R1));
L7784:
	goto L7780;
L7782:
L7780:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7778:
	asu64(R1) = d;
	if (asu64(R1)) goto L7777;
	pc_api_pcl_end();
	return;
}

static void cc_genpcl_genprocdef(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	u64 d;
	u64 e;
	u64 pm;
	i64 ismain;
	R1 = 0;
	ismain = asi64(R1);
	R1 = tou64("main");
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L7787;
	R1 = 1;
	ismain = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L7787:
	asu64(R1) = p;
	cc_decls_currproc = asu64(R1);
	R1 = 0;
	asi64(R2) = ismain;
	R3 = 0;
	asu64(R4) = p;
	asu64(R4) = cc_libpcl_getpsymbol(asu64(R4));
	R5 = R4;
	e = asu64(R5);
	pc_api_pc_defproc(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 3;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = e;
	R3 = 113;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L7791;
L7788:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L7793;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L7794;
	goto L7795;
L7793:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addparam(asu64(R1));
	goto L7792;
L7794:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addlocal(asu64(R1));
	goto L7792;
L7795:
L7792:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L7791:
	asu64(R1) = d;
	if (asu64(R1)) goto L7788;
	asi64(R1) = cc_libpcl_createfwdlabel();
	cc_genpcl_retindex = asi64(R1);
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_stmt(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asi64(R1) = cc_genpcl_retindex;
	cc_libpcl_definefwdlabel(asi64(R1));
	asi64(R1) = ismain;
	if (!asi64(R1)) goto L7797;
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 32;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L7797:
	R1 = 0;
	asu64(R2) = p;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	R3 = 0;
	if (asi64(R2) == asi64(R3)) goto L7799;
	R2 = 23;
	goto L7798;
L7799:
	R2 = 20;
L7798:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	pc_api_pc_endproc();
	R1 = tou64("");
	pc_api_gencomment(asu64(R1));
	return;
}

static void cc_genpcl_dostaticvar(u64 d) {
    u64 R1, R2, R3, R4, R5; 
	struct $B16 str;
	i64 align;
	u64 e;
	u64 p;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7802;
	goto L7800;
L7802:
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R1) = cc_lib_getalignment(asi64(R1));
	align = asi64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L7804;
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L7806;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$#.#.#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = 7;
	R2 = (u64)&str;
	asu64(R2) = cc_lex_addnamestr(asu64(R2));
	R3 = 0;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = d;
	R3 = 114;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L7805;
L7806:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L7805:
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = align;
	pc_api_pc_setalign(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 1;
	asu64(R4) = d;
	R5 = 72;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L7803;
L7804:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 124;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = align;
	pc_api_pc_setalign(asi64(R1));
L7803:
L7800:
	return;
}

static void cc_genpcl_genidata(u64 p, i64 doterm, i64 am, i64 offset) {
    u64 R1, R2, R3, R4, R5; 
	i64 t;
	i64 length;
	i64 n;
	i64 i;
	i64 j;
	i64 nwords;
	i64 offset1;
	i64 offset2;
	i64 size;
	i64 padding;
	i64 isunion;
	u64 q;
	u64 a;
	u64 b;
	u64 d;
	r32 sx;
	struct $B16 str;
	struct $B3 str2;
	i64 av_1;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L7809;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7810;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L7811;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L7811;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L7812;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L7813;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L7814;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L7814;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L7815;
	goto L7816;
L7809:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7818;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	length = asi64(R1);
	asu64(R1) = a;
	q = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7821;
L7819:
	R1 = 0;
	R2 = 1;
	R3 = 1;
	asu64(R4) = q;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	i += 1; if (i <= n) goto L7819;
L7821:
	asi64(R1) = n;
	asi64(R2) = length;
	if (asi64(R1) >= asi64(R2)) goto L7823;
	asi64(R1) = length;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	cc_genpcl_doresb(asi64(R1));
L7823:
	goto L7817;
L7818:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 19;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	isunion = asi64(R1);
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	size = asi64(R1);
	R1 = 0;
	R2 = R1;
	offset2 = asi64(R2);
	offset1 = asi64(R1);
	asu64(R1) = a;
	q = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7826;
L7824:
	R1 = 0;
	R2 = 1;
	R3 = 0;
	asu64(R4) = q;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = q;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&offset1;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L7828;
	asi64(R1) = isunion;
	if (asi64(R1)) goto L7828;
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	offset2 = asi64(R1);
	goto L7827;
L7828:
	asi64(R1) = size;
	offset2 = asi64(R1);
L7827:
	asi64(R1) = offset2;
	asi64(R2) = offset1;
	asi64(R1) -= asi64(R2);
	padding = asi64(R1);
	asi64(R1) = padding;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7830;
	asi64(R1) = offset2;
	asi64(R2) = offset1;
	asi64(R1) -= asi64(R2);
	cc_genpcl_doresb(asi64(R1));
	asi64(R1) = offset2;
	offset1 = asi64(R1);
L7830:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	i += 1; if (i <= n) goto L7824;
L7826:
	asi64(R1) = offset2;
	asi64(R2) = size;
	if (asi64(R1) >= asi64(R2)) goto L7832;
	asi64(R1) = size;
	asi64(R2) = offset2;
	asi64(R1) -= asi64(R2);
	cc_genpcl_doresb(asi64(R1));
L7832:
L7817:
	goto L7807;
	goto L7808;
L7810:
	asi64(R1) = t;
	asi64(R1) = cc_lib_isintcc(asi64(R1));
	if (asi64(R1)) goto L7835;
	asi64(R1) = t;
	asi64(R1) = cc_lib_isrealcc(asi64(R1));
	if (!asi64(R1)) goto L7834;
L7835:
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L7837;
	asu64(R1) = p;
	R2 = 0;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
    asr32(R1) = tor32(asr64(R1));
	sx = asr32(R1);
	R1 = (u64)&sx;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L7836;
L7837:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L7836:
	asi64(R1) = t;
	cc_libpcl_setmode(asi64(R1));
	goto L7833;
L7834:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7838;
	R1 = 0;
	padding = asi64(R1);
// cc_genpcl.genidata.doref:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7841;
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L7840;
L7841:
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7842;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genstring(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L7840;
L7842:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7843;
	R1 = 0;
	R2 = tou64("GENIDATA/WSTRING2");
	cc_support_gerror(asu64(R2), asu64(R1));
	asi64(R1) = padding;
	cc_genpcl_doresb(asi64(R1));
	goto L7840;
L7843:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L7840:
	asi64(R1) = t;
	cc_libpcl_setmode(asi64(R1));
	goto L7833;
L7838:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = t;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L7844;
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 48;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = t;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	padding = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7847;
L7845:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R2) = i;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 6;
	cc_libpcl_setmode(asi64(R1));
	i += 1; if (i <= av_1) goto L7845;
L7847:
	asi64(R1) = padding;
	cc_genpcl_doresb(asi64(R1));
	goto L7833;
L7844:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("IDATA/SCALAR");
	cc_support_gerror(asu64(R2), asu64(R1));
L7833:
	goto L7807;
	goto L7808;
L7811:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7849;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L7849;
	goto L7850;
L7849:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	goto L7848;
L7850:
	asu64(R1) = p;
	R2 = tou64("Idata &frame");
	cc_support_gerror(asu64(R2), asu64(R1));
L7848:
	goto L7807;
	goto L7808;
L7812:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L7852;
	asu64(R1) = b;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7852;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L7854;
	goto L7855;
L7854:
	R1 = tou64("`");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7857;
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(",");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L7857:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("+");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str2;
	asu64(R2) = b;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_getstrint(asi64(R2), asu64(R1));
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = pc_api_genname(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L7853;
L7855:
	R1 = 0;
	R2 = tou64("Add/Idata &frame");
	cc_support_gerror(asu64(R2), asu64(R1));
L7853:
	goto L7851;
L7852:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7858;
	asu64(R1) = b;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L7858;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7858;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_nogap();
	R1 = tou64("+");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = pc_api_genname(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L7851;
L7858:
	R1 = 0;
	R2 = tou64("1:Runtime or unsupported expr in static data");
	cc_support_gerror(asu64(R2), asu64(R1));
L7851:
	goto L7807;
	goto L7808;
L7813:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L7860;
	asi64(R1) = offset;
	R2 = 1;
	R3 = 1;
	asu64(R4) = a;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L7859;
L7860:
	asi64(R1) = offset;
	R2 = 0;
	R3 = 1;
	asu64(R4) = a;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
L7859:
	goto L7808;
L7814:
	asu64(R1) = b;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L7862;
	R1 = 0;
	R2 = tou64("Complex ptr expr in static data");
	cc_support_gerror(asu64(R2), asu64(R1));
L7862:
	asu64(R1) = b;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	asi64(R2) = offset;
	asi64(R1) += asi64(R2);
	R2 = 1;
	R3 = 1;
	asu64(R4) = a;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L7808;
L7815:
	asi64(R1) = offset;
	R2 = 1;
	R3 = 1;
	asu64(R4) = a;
	cc_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L7808;
L7816:
	R1 = tou64("*");
	R2 = 0;
	asu64(R3) = p;
	R4 = 0;
	cc_showdummy_printunit(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = tou64("2:Runtime expr in static data");
	cc_support_gerror(asu64(R2), asu64(R1));
L7808:
L7807:
	return;
}

static void cc_genpcl_doresb(i64 n) {
    u64 R1, R2; 
	i64 av_1;
	goto L7865;
L7864:
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	R2 = (u64)&n;
	*toi64p(R2) -= asi64(R1);
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
L7865:
	asi64(R1) = n;
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L7864;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L7869;
L7867:
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 6;
	cc_libpcl_setmode(asi64(R1));
	if (--asi64(av_1)) goto L7867;
L7869:
	return;
}

static void cc_genpcl_pushint(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_genpcl_dolibs() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7874;
L7872:
	R1 = (u64)&cc_decls_libfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pc_api_pc_addplib(asu64(R1));
	i += 1; if (i <= cc_decls_nlibfiles) goto L7872;
L7874:
	return;
}

static void cc_blockpcl_do_stmt(u64 p) {
    u64 R1, R2, R3, R4; 
	i64 oldclineno;
	u64 a;
	u64 b;
	u64 d;
	asu64(R1) = p;
	if (asu64(R1)) goto L7877;
	goto L7875;
L7877:
	asi64(R1) = cc_decls_clineno;
	oldclineno = asi64(R1);
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_clineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_decls_cfileno = asi64(R1);
	asi64(R1) = cc_decls_cfileno;
	R2 = 24;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = cc_decls_clineno;
	asi64(R1) += asi64(R2);
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 6: goto L7881;
	case 7: case 10: case 24: case 25: case 26: case 27: case 28: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: goto L7880;
	case 8: goto L7885;
	case 9: goto L7887;
	case 11: goto L7888;
	case 12: case 31: goto L7889;
	case 13: goto L7890;
	case 14: goto L7891;
	case 15: goto L7892;
	case 16: goto L7893;
	case 17: goto L7894;
	case 18: goto L7895;
	case 19: goto L7896;
	case 20: goto L7898;
	case 21: goto L7899;
	case 22: goto L7900;
	case 23: goto L7897;
	case 29: goto L7915;
	case 30: goto L7886;
	case 61: goto L7901;
	case 62: goto L7902;
	case 63: goto L7903;
	case 64: goto L7904;
	case 65: goto L7907;
	case 66: goto L7908;
	case 67: goto L7909;
	case 68: goto L7910;
	case 69: goto L7911;
	case 70: goto L7912;
	case 71: case 73: goto L7913;
	case 72: case 74: goto L7914;
	default: goto L7880;
    };
// SWITCH
L7881:
	goto L7883;
L7882:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L7883:
	asu64(R1) = a;
	if (asu64(R1)) goto L7882;
	goto L7878;
L7885:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_decl(asu64(R1));
	goto L7878;
L7886:
	R1 = 0;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_call(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L7878;
L7887:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_do_return(asu64(R2), asu64(R1));
	goto L7878;
L7888:
	R1 = 0;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_do_assign(asu64(R3), asu64(R2), asi64(R1));
	goto L7878;
L7889:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_do_if(asu64(R3), asu64(R2), asu64(R1));
	goto L7878;
L7890:
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_for(asu64(R2), asu64(R1));
	goto L7878;
L7891:
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_while(asu64(R2), asu64(R1));
	goto L7878;
L7892:
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_dowhile(asu64(R2), asu64(R1));
	goto L7878;
L7893:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_goto(asu64(R1));
	goto L7878;
L7894:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_blockpcl_do_labeldef(asu64(R1));
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	goto L7878;
L7895:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_do_casestmt(asu64(R2), asu64(R1));
	goto L7878;
L7896:
	R1 = 1;
	cc_blockpcl_sw_defaultseen = asu8(R1);
	asi64(R1) = cc_blockpcl_sw_defaultlabel;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	goto L7878;
L7897:
	asi64(R1) = cc_blockpcl_sw_breaklabel;
	cc_blockpcl_genjumpl(asi64(R1));
	goto L7878;
L7898:
	R1 = (u64)&cc_blockpcl_breakstack;
	asi64(R2) = cc_blockpcl_loopindex;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	cc_blockpcl_genjumpl(asi64(R1));
	goto L7878;
L7899:
	R1 = (u64)&cc_blockpcl_continuestack;
	asi64(R2) = cc_blockpcl_loopindex;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	cc_blockpcl_genjumpl(asi64(R1));
	goto L7878;
L7900:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_do_switch(asu64(R3), asu64(R2), asu64(R1));
	goto L7878;
L7901:
	R1 = 0;
	R2 = 90;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7878;
L7902:
	R1 = 0;
	R2 = 91;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7878;
L7903:
	R1 = 0;
	R2 = 92;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7878;
L7904:
	R1 = 0;
	asu64(R2) = a;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = cc_lib_isrealcc(asi64(R2));
	if (!asi64(R2)) goto L7906;
	R2 = 93;
	goto L7905;
L7906:
	R2 = 94;
L7905:
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7878;
L7907:
	R1 = 0;
	R2 = 95;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7878;
L7908:
	R1 = 0;
	R2 = 96;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7878;
L7909:
	R1 = 0;
	R2 = 97;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7878;
L7910:
	R1 = 0;
	R2 = 98;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7878;
L7911:
	R1 = 0;
	R2 = 99;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7878;
L7912:
	R1 = 0;
	R2 = 100;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7878;
L7913:
	R1 = 84;
	asu64(R2) = a;
	cc_blockpcl_do_preincr(asu64(R2), asi64(R1));
	goto L7878;
L7914:
	R1 = 85;
	asu64(R2) = a;
	cc_blockpcl_do_preincr(asu64(R2), asi64(R1));
	goto L7878;
L7915:
	goto L7917;
L7916:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L7917:
	asu64(R1) = a;
	if (asu64(R1)) goto L7916;
	goto L7878;
L7880:
	R1 = 0;
	asu64(R2) = p;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	if (!asu64(R1)) goto L7920;
	asu64(R1) = a;
	goto L7919;
L7920:
	asu64(R1) = p;
L7919:
	cc_libpcl_setmode_u(asu64(R1));
L7878:
L7875:
	return;
}

static void cc_blockpcl_dx_expr(u64 p, i64 am) {
    u64 R1, R2, R3, R4, R5; 
	i64 oldclineno;
	i64 value;
	i64 m;
	u64 a;
	u64 b;
	struct $B16 str;
	u64 d;
	asu64(R1) = p;
	if (asu64(R1)) goto L7923;
	goto L7921;
L7923:
	asi64(R1) = cc_decls_clineno;
	oldclineno = asi64(R1);
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	cc_decls_clineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	cc_decls_cfileno = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 1: goto L7927;
	case 2: case 6: case 7: case 8: case 9: case 10: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 28: case 32: case 50: case 51: case 59: goto L7926;
	case 3: goto L7928;
	case 4: goto L7929;
	case 5: goto L7930;
	case 11: goto L7931;
	case 24: case 25: goto L7932;
	case 26: goto L7933;
	case 27: goto L7936;
	case 29: goto L7937;
	case 30: goto L7948;
	case 31: goto L7949;
	case 33: case 34: case 35: case 36: case 37: case 38: goto L7950;
	case 39: goto L7951;
	case 40: goto L7954;
	case 41: goto L7955;
	case 42: goto L7956;
	case 43: goto L7959;
	case 44: goto L7960;
	case 45: goto L7961;
	case 46: goto L7962;
	case 47: goto L7963;
	case 48: goto L7964;
	case 49: goto L7987;
	case 52: goto L7965;
	case 53: goto L7966;
	case 54: goto L7967;
	case 55: goto L7986;
	case 56: goto L7968;
	case 57: goto L7971;
	case 58: goto L7972;
	case 60: goto L7973;
	case 61: goto L7976;
	case 62: goto L7977;
	case 63: goto L7978;
	case 64: goto L7979;
	case 65: goto L7980;
	case 66: goto L7981;
	case 67: goto L7982;
	case 68: goto L7983;
	case 69: goto L7984;
	case 70: goto L7985;
	case 71: case 72: goto L7974;
	case 73: case 74: goto L7975;
	case 75: goto L7988;
	case 76: goto L7989;
	default: goto L7926;
    };
// SWITCH
L7927:
	asu64(R1) = p;
	cc_blockpcl_dx_const(asu64(R1));
	goto L7924;
L7928:
	asi64(R1) = am;
	asu64(R2) = p;
	cc_blockpcl_dx_name(asu64(R2), asi64(R1));
	goto L7924;
L7929:
	asi64(R1) = am;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	goto L7924;
L7930:
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	goto L7924;
L7931:
	R1 = 1;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_do_assign(asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7932:
	asu64(R1) = p;
	cc_blockpcl_dx_andorl(asu64(R1));
	goto L7924;
L7933:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L7935;
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 64;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode2(asi64(R1));
	goto L7934;
L7935:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 63;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
L7934:
	goto L7924;
L7936:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 64;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode2(asi64(R1));
	goto L7924;
L7937:
	goto L7941;
L7938:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L7943;
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7944;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L7944;
	R2 = 31;
	if (asi64(R1) != asi64(R2)) goto L7943;
L7944:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	goto L7942;
L7943:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = b;
	if (!asu64(R1)) goto L7946;
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7947;
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 56;
	if (asi64(R1) != asi64(R2)) goto L7946;
L7947:
	R1 = 0;
	R2 = 134;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L7946:
L7942:
	asu64(R1) = b;
	a = asu64(R1);
L7941:
	asu64(R1) = a;
	if (asu64(R1)) goto L7938;
	goto L7924;
L7948:
	R1 = 1;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_call(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7949:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_ifx(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L7924;
L7950:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_eq(asu64(R3), asu64(R2), asu64(R1));
	goto L7924;
L7951:
	R1 = (u64)&cc_decls_ttisref;
	asu64(R2) = a;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L7953;
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = b;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L7953;
	R1 = 9;
	asu64(R2) = b;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L7953:
	R1 = 43;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7954:
	R1 = 44;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7955:
	R1 = 45;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7956:
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = cc_lib_isrealcc(asi64(R1));
	if (!asi64(R1)) goto L7958;
	R1 = 46;
	goto L7957;
L7958:
	R1 = 47;
L7957:
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7959:
	R1 = 48;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7960:
	R1 = 50;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7961:
	R1 = 51;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7962:
	R1 = 52;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7963:
	R1 = 53;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7964:
	R1 = 54;
	asu64(R2) = b;
	asu64(R3) = a;
	cc_blockpcl_dx_bin(asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7965:
	asi64(R1) = am;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_ptr(asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7966:
	asi64(R1) = am;
	R2 = 57;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	cc_blockpcl_dx_addptr(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7924;
L7967:
	asi64(R1) = am;
	R2 = 58;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	cc_blockpcl_dx_addptr(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7924;
L7968:
	asu64(R1) = p;
	R2 = 58;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L7970;
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	goto L7969;
L7970:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 58;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_convert(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
L7969:
	goto L7924;
L7971:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_scale(asu64(R3), asu64(R2), asu64(R1));
	goto L7924;
L7972:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 60;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	goto L7924;
L7973:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 62;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	goto L7924;
L7974:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_dx_preincrx(asu64(R2), asu64(R1));
	goto L7924;
L7975:
	asu64(R1) = a;
	asu64(R2) = p;
	cc_blockpcl_dx_postincrx(asu64(R2), asu64(R1));
	goto L7924;
L7976:
	R1 = 1;
	R2 = 90;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7924;
L7977:
	R1 = 1;
	R2 = 91;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7924;
L7978:
	R1 = 1;
	R2 = 92;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7924;
L7979:
	R1 = 1;
	R2 = 93;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7924;
L7980:
	R1 = 1;
	R2 = 95;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7924;
L7981:
	R1 = 1;
	R2 = 96;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7924;
L7982:
	R1 = 1;
	R2 = 97;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7924;
L7983:
	R1 = 1;
	R2 = 98;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7924;
L7984:
	R1 = 1;
	R2 = 99;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7924;
L7985:
	R1 = 1;
	R2 = 100;
	asu64(R3) = b;
	asu64(R4) = a;
	cc_blockpcl_dx_binto(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L7924;
L7986:
	asi64(R1) = am;
	asu64(R2) = a;
	asu64(R3) = p;
	cc_blockpcl_dx_addrof(asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7987:
	asi64(R1) = am;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	cc_blockpcl_dx_dot(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L7924;
L7988:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 129;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L7924;
L7989:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 130;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L7924;
L7926:
	R1 = 0;
	R2 = (u64)&cc_tables_jtagnames;
	asu64(R3) = p;
	R4 = 40;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("DX-EXPR: can't do tag: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L7924:
	asi64(R1) = oldclineno;
	cc_decls_clineno = asi64(R1);
L7921:
	return;
}

static void cc_blockpcl_dx_const(u64 p) {
    u64 R1, R2, R3; 
	i64 t;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 52;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L7992;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L7992;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L7991;
L7992:
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L7994;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L7995;
	goto L7996;
L7994:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L7993;
L7995:
	R1 = 2;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L7993;
L7996:
	asi64(R1) = t;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L7998;
	asi64(R1) = t;
	R2 = 11;
	if (asi64(R1) > asi64(R2)) goto L7998;
	R1 = 2;
	asu64(R2) = p;
	R3 = 0;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L7997;
L7998:
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L7999;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8001;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genstring(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8000;
L8001:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8002;
	R1 = 0;
	R2 = tou64("CONST/WSTRING");
	cc_support_gerror(asu64(R2), asu64(R1));
	goto L8000;
L8002:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8000:
	goto L7997;
L7999:
	R1 = 0;
	R2 = tou64("const?");
	cc_support_gerror(asu64(R2), asu64(R1));
L7997:
L7993:
L7991:
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	return;
}

static void cc_blockpcl_dx_name(u64 p, i64 am) {
    u64 R1, R2; 
	u64 d;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8005;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8005;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8005;
	goto L8006;
L8005:
	asi64(R1) = am;
	if (!asi64(R1)) goto L8008;
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	goto L8007;
L8008:
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
L8007:
	goto L8004;
L8006:
	R1 = 0;
	R2 = tou64("dxname");
	cc_support_gerror(asu64(R2), asu64(R1));
L8004:
	return;
}

static void cc_blockpcl_dx_bin(u64 a, u64 b, i64 opc) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	return;
}

static void cc_blockpcl_dx_binto(u64 a, u64 b, i64 opc, i64 res) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = res;
	if (asi64(R1)) goto L8012;
	asi64(R1) = opc;
	R2 = 94;
	if (asi64(R1) == asi64(R2)) goto L8012;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L8012;
	cc_blockpcl_do_setinplace();
L8012:
	asi64(R1) = res;
	if (!asi64(R1)) goto L8014;
	R1 = 0;
	R2 = 8;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	R2 = 3;
	R3 = 2;
	R4 = 10;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
L8014:
	R1 = 0;
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = res;
	if (!asi64(R1)) goto L8016;
	R1 = 0;
	R2 = 2;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
L8016:
	return;
}

static void cc_blockpcl_do_assign(u64 a, u64 b, i64 res) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_fixwiden(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = res;
	if (!asi64(R1)) goto L8019;
	R1 = 0;
	R2 = 9;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8019:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8021;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L8022;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L8023;
	goto L8024;
L8021:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L8020;
L8022:
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 5;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L8020;
L8023:
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 5;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L8020;
L8024:
	R1 = 0;
	R2 = (u64)&cc_tables_jtagnames;
	asu64(R3) = a;
	R4 = 40;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("DOASSIGN not ready: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L8020:
	return;
}

static void cc_blockpcl_dx_ptr(u64 p, u64 a, i64 am) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = am;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8027;
	R1 = 0;
	R2 = 1;
	R3 = 2;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
L8027:
	return;
}

static void cc_blockpcl_dx_addptr(u64 p, u64 a, u64 b, i64 opc, i64 am) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	asi64(R3) = opc;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 0;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	return;
}

static void cc_blockpcl_dx_addrof(u64 p, u64 a, i64 am) {
    u64 R1, R2; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	return;
}

static void cc_blockpcl_dx_convert(u64 p, u64 a, i64 t, i64 opc) {
    u64 R1, R2, R3; 
	i64 s;
	i64 ssize;
	i64 tsize;
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = s;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	ssize = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	tsize = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = opc;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8032;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8033;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8034;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8034;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8035;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8035;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L8036;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8036;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L8037;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8038;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L8039;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8039;
	goto L8040;
L8032:
	goto L8030;
	goto L8031;
L8033:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = s;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8043;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L8042;
L8043:
	R1 = 0;
	R2 = tou64("Bad cast");
	cc_support_gerror(asu64(R2), asu64(R1));
L8042:
	asi64(R1) = tsize;
	asi64(R2) = ssize;
	if (asi64(R1) <= asi64(R2)) goto L8045;
	R1 = 0;
	R2 = 114;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8044;
L8045:
	asi64(R1) = tsize;
	asi64(R2) = ssize;
	if (asi64(R1) >= asi64(R2)) goto L8046;
	goto L8047;
	goto L8030;
L8046:
L8044:
	goto L8031;
L8034:
	asi64(R1) = ssize;
	asi64(R2) = tsize;
	if (asi64(R1) != asi64(R2)) goto L8049;
	goto L8030;
L8049:
	R1 = 0;
	R2 = 114;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8031;
L8035:
	R1 = 0;
	R2 = 111;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8031;
L8036:
	R1 = 0;
	R2 = 112;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8031;
L8037:
	R1 = 0;
	R2 = 115;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8031;
L8038:
	R1 = 0;
	R2 = 116;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8031;
L8039:
// cc_blockpcl.dx_convert.dotruncate:
L8047:
	R1 = 0;
	R2 = 113;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = t;
	cc_libpcl_setmode2(asi64(R1));
	goto L8030;
	goto L8031;
L8040:
	R1 = 0;
	R2 = (u64)&cc_tables_convnames;
	asi64(R3) = opc;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("Convert op not implem: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L8031:
	asi64(R1) = t;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = s;
	cc_libpcl_setmode2(asi64(R1));
L8030:
	return;
}

static void cc_blockpcl_do_if(u64 a, u64 b, u64 c) {
    u64 R1, R2, R3; 
	i64 lab1;
	i64 lab2;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab1 = asi64(R1);
	asi64(R1) = lab1;
	asu64(R2) = a;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asu64(R1) = b;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = c;
	if (!asu64(R1)) goto L8052;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = c;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	goto L8051;
L8052:
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
L8051:
	return;
}

static void cc_blockpcl_genjumpcond(i64 opc, u64 p, i64 lab) {
    u64 R1, R2, R3, R4, R5; 
	u64 q;
	u64 r;
	i64 lab2;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 24: goto L8057;
	case 25: goto L8062;
	case 26: goto L8067;
	case 27: goto L8072;
	case 28: case 30: case 31: case 32: goto L8056;
	case 29: goto L8074;
	case 33: case 34: case 35: case 36: case 37: case 38: goto L8073;
	default: goto L8056;
    };
// SWITCH
L8057:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L8059;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L8060;
	goto L8061;
L8059:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L8058;
L8060:
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	goto L8058;
L8061:
L8058:
	goto L8054;
L8062:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L8064;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L8065;
	goto L8066;
L8064:
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	goto L8063;
L8065:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L8063;
L8066:
L8063:
	goto L8054;
L8067:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L8069;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L8070;
	goto L8071;
L8069:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L8068;
L8070:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L8068;
L8071:
L8068:
	goto L8054;
L8072:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L8054;
L8073:
	asi64(R1) = lab;
	asu64(R2) = r;
	asu64(R3) = q;
	asu64(R4) = p;
	asi64(R5) = opc;
	cc_blockpcl_gcomparejump(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L8054;
L8074:
	goto L8076;
L8075:
	asu64(R1) = q;
	cc_blockpcl_do_stmt(asu64(R1));
	asu64(R1) = r;
	q = asu64(R1);
L8076:
	asu64(R1) = q;
	if (!asu64(R1)) goto L8078;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	r = asu64(R2);
	if (asu64(R1)) goto L8075;
L8078:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L8054;
L8056:
	R1 = 0;
	asu64(R2) = p;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
L8054:
	return;
}

static void cc_blockpcl_gcomparejump(i64 jumpopc, u64 p, u64 lhs, u64 rhs, i64 lab) {
    u64 R1, R2, R3; 
	i64 cond;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = cc_blockpcl_getpclcond(asi64(R1));
	cond = asi64(R1);
	asi64(R1) = jumpopc;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L8081;
	asi64(R1) = cond;
	asi64(R1) = cc_blockpcl_reversecond(asi64(R1));
	cond = asi64(R1);
L8081:
	asu64(R1) = rhs;
	asu64(R2) = lhs;
	cc_blockpcl_do_fixwiden(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = lhs;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = rhs;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 26;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = cond;
	asu64(R2) = pc_api_pccurr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = lhs;
	cc_libpcl_setmode_u(asu64(R1));
	return;
}

static i64 cc_blockpcl_getpclcond(i64 op) {
    u64 R1, R2; 
	asi64(R1) = op;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L8084;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L8085;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L8086;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L8087;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L8088;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L8089;
	goto L8090;
L8084:
	R1 = 1;
	goto L8082;
	goto L8083;
L8085:
	R1 = 2;
	goto L8082;
	goto L8083;
L8086:
	R1 = 3;
	goto L8082;
	goto L8083;
L8087:
	R1 = 4;
	goto L8082;
	goto L8083;
L8088:
	R1 = 5;
	goto L8082;
	goto L8083;
L8089:
	R1 = 6;
	goto L8082;
	goto L8083;
L8090:
L8083:
	R1 = 0;
	goto L8082;
L8082:
	return asi64(R1);
}

static i64 cc_blockpcl_reversecond(i64 cc) {
    u64 R1, R2; 
	asi64(R1) = cc;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8093;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8094;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8095;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8096;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L8097;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8098;
	goto L8099;
L8093:
	R1 = 2;
	cc = asi64(R1);
	goto L8092;
L8094:
	R1 = 1;
	cc = asi64(R1);
	goto L8092;
L8095:
	R1 = 5;
	cc = asi64(R1);
	goto L8092;
L8096:
	R1 = 6;
	cc = asi64(R1);
	goto L8092;
L8097:
	R1 = 3;
	cc = asi64(R1);
	goto L8092;
L8098:
	R1 = 4;
	cc = asi64(R1);
	goto L8092;
L8099:
L8092:
	asi64(R1) = cc;
	goto L8091;
L8091:
	return asi64(R1);
}

static void cc_blockpcl_genjumpl(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_blockpcl_do_while(u64 pcond, u64 pbody) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asu64(R1) = pcond;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8103;
	asu64(R1) = pcond;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	if (!asi64(R1)) goto L8103;
	asu64(R1) = pbody;
	cc_blockpcl_do_while1(asu64(R1));
	goto L8101;
L8103:
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = lab_c;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
L8101:
	return;
}

static void cc_blockpcl_do_while1(u64 pbody) {
    u64 R1, R2; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void cc_blockpcl_do_dowhile(u64 pbody, u64 pcond) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pcond;
	asi64(R1) = cc_parse_iscondfalse(asu64(R1));
	if (asi64(R1)) goto L8107;
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
L8107:
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void cc_blockpcl_stacklooplabels(i64 a, i64 b) {
    u64 R1, R2, R3; 
	asi64(R1) = a;
	R2 = (u64)&cc_blockpcl_continuestack;
	R3 = (u64)&cc_blockpcl_loopindex;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&cc_blockpcl_breakstack;
	asi64(R3) = cc_blockpcl_loopindex;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	return;
}

static void cc_blockpcl_do_return(u64 p, u64 a) {
    u64 R1, R2; 
	u64 e;
	asu64(R1) = a;
	if (!asu64(R1)) goto L8111;
	asu64(R1) = cc_decls_currproc;
	R2 = 108;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L8113;
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 32;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8112;
L8113:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = cc_genpcl_retindex;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 29;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
L8112:
	goto L8110;
L8111:
	asi64(R1) = cc_genpcl_retindex;
	cc_blockpcl_genjumpl(asi64(R1));
L8110:
	return;
}

static void cc_blockpcl_dx_call(u64 p, u64 a, u64 b, i64 res) {
    u64 R1, R2, R3, R4; 
	u64 pm;
	i64 isfnptr;
	i64 variadic;
	i64 nparams;
	i64 retmode;
	i64 nbytes;
	i64 retsize;
	i64 m;
	i64 nvariadics;
	i64 nfixedparams;
	i64 isfn;
	i64 blockret;
	struct $B31 paramlist;
	struct $B32 paramconst;
	struct $B32 argattr;
	i64 iparams;
	i64 fparams;
	u64 dblock;
	u64 dtemp;
	u64 q;
	i64 i;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	retmode = asi64(R1);
	asi64(R1) = retmode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8116;
	R1 = 3;
	retmode = asi64(R1);
L8116:
	R1 = 0;
	isfn = asi64(R1);
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L8118;
	goto L8119;
L8118:
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	goto L8121;
L8120:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
L8121:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8120;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	isfn = asi64(R1);
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	R1 = 1;
	isfnptr = asi64(R1);
	goto L8117;
L8119:
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	R1 = 0;
	isfnptr = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	isfn = asi64(R1);
L8117:
	asu64(R1) = pm;
	R2 = 22;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 3;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	variadic = asi64(R1);
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	nfixedparams = asi64(R1);
	R1 = 0;
	R2 = R1;
	nvariadics = asi64(R2);
	nparams = asi64(R1);
	asu64(R1) = b;
	q = asu64(R1);
	goto L8126;
L8123:
	asi64(R1) = nparams;
	R2 = 64;
	if (asi64(R1) < asi64(R2)) goto L8128;
	R1 = 0;
	R2 = tou64("maxparams");
	cc_support_gerror(asu64(R2), asu64(R1));
L8128:
	asu64(R1) = q;
	R2 = (u64)&paramlist;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&paramconst;
	asi64(R3) = nparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = variadic;
	if (!asi64(R1)) goto L8130;
	asi64(R1) = nparams;
	asi64(R2) = nfixedparams;
	if (asi64(R1) <= asi64(R2)) goto L8130;
	asi64(R1) = nparams;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L8130;
	asi64(R1) = nvariadics;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8130;
	asi64(R1) = nparams;
	nvariadics = asi64(R1);
L8130:
	asi64(R1) = nparams;
	asi64(R2) = nfixedparams;
	if (asi64(R1) > asi64(R2)) goto L8132;
	R1 = (u64)&cc_decls_ttconst;
	asu64(R2) = pm;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&paramconst;
	asi64(R3) = nparams;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
L8132:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L8126:
	asu64(R1) = q;
	if (asu64(R1)) goto L8123;
	R1 = 0;
	R2 = 131;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = nparams;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = R1;
	fparams = asi64(R2);
	iparams = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8135;
L8133:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L8138;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L8137;
L8138:
	R1 = (u64)&fparams;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R1) = -asi64(R1);
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
	goto L8136;
L8137:
	R1 = (u64)&iparams;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
L8136:
	i += 1; if (i <= nparams) goto L8133;
L8135:
	asi64(R1) = nparams;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8141;
L8139:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = nvariadics;
	if (!asi64(R1)) goto L8143;
	asi64(R1) = i;
	asi64(R2) = nvariadics;
	if (asi64(R1) < asi64(R2)) goto L8143;
	asu64(R1) = pc_api_pccurr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8143;
	R1 = 0;
	R2 = 115;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 2;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L8143:
	R1 = 0;
	R2 = 132;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = q;
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = i;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&argattr;
	asi64(R2) = i;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2-1));
	R1 = toi64(toi8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	i += -1; if (i >= 1) goto L8139;
L8141:
	asi64(R1) = isfnptr;
	if (asi64(R1)) goto L8145;
	asu64(R1) = a;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_genmemaddr_d(asu64(R1));
	asi64(R2) = isfn;
	if (!asi64(R2)) goto L8147;
	R2 = 21;
	goto L8146;
L8147:
	R2 = 18;
L8146:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8144;
L8145:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = isfn;
	if (!asi64(R2)) goto L8149;
	R2 = 22;
	goto L8148;
L8149:
	R2 = 19;
L8148:
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8144:
	asi64(R1) = nparams;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = nvariadics;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = isfn;
	if (!asi64(R1)) goto L8151;
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = res;
	if (asi64(R1)) goto L8153;
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L8152;
L8153:
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
L8152:
L8151:
	return;
}

static void cc_blockpcl_do_decl(u64 d) {
    u64 R1, R2, R3; 
	u64 a;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8156;
	R1 = 1;
	asu64(R2) = d;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8156:
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L8158;
	R1 = (u64)&cc_decls_ttbasetype;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L8160;
	asu64(R1) = a;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8160;
	goto L8161;
L8160:
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L8154;
L8158:
// cc_blockpcl.do_decl.copyl:
L8161:
	asu64(R1) = d;
	R2 = 114;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	cc_libpcl_setmode(asi64(R1));
L8154:
	return;
}

static void cc_blockpcl_do_for(u64 pinit, u64 pbody) {
    u64 R1, R2, R3; 
	u64 pcond;
	u64 pincr;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_cond;
	asu64(R1) = pinit;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcond = asu64(R1);
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pincr = asu64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab_cond = asi64(R1);
	asu64(R1) = pinit;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8164;
	asu64(R1) = pinit;
	cc_blockpcl_do_stmt(asu64(R1));
L8164:
	asi64(R1) = lab_cond;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	cc_blockpcl_stacklooplabels(asi64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_definelabel();
	lab_b = asi64(R1);
	asu64(R1) = pbody;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_c;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pincr;
	cc_blockpcl_do_stmt(asu64(R1));
	asi64(R1) = lab_cond;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pcond;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8166;
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L8165;
L8166:
	asi64(R1) = lab_b;
	cc_blockpcl_genjumpl(asi64(R1));
L8165:
	asi64(R1) = lab_d;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&cc_blockpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void cc_blockpcl_do_preincr(u64 a, i64 incrop) {
    u64 R1, R2; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	cc_blockpcl_do_setinplace();
	R1 = 0;
	asi64(R2) = incrop;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_blockpcl_setincrstep(asi64(R1));
	return;
}

static void cc_blockpcl_setincrstep(i64 m) {
    u64 R1, R2, R3; 
	R1 = 1;
	pc_api_pc_setincr(asi64(R1));
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8170;
	R1 = (u64)&cc_decls_ttsize;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	pc_api_pc_setincr(asi64(R1));
L8170:
	return;
}

static void cc_blockpcl_dx_preincrx(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	cc_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 71;
	if (asi64(R2) != asi64(R3)) goto L8173;
	R2 = 86;
	goto L8172;
L8173:
	R2 = 87;
L8172:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_blockpcl_setincrstep(asi64(R1));
	asu64(R1) = a;
	cc_blockpcl_widen(asu64(R1));
	return;
}

static void cc_blockpcl_dx_postincrx(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	cc_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 40;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 73;
	if (asi64(R2) != asi64(R3)) goto L8176;
	R2 = 88;
	goto L8175;
L8176:
	R2 = 89;
L8175:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_blockpcl_setincrstep(asi64(R1));
	asu64(R1) = a;
	cc_blockpcl_widen(asu64(R1));
	return;
}

static void cc_blockpcl_dx_dot(u64 p, u64 a, u64 b, i64 am) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 9;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = am;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8179;
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 2;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	cc_blockpcl_widen(asu64(R1));
	goto L8178;
L8179:
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
L8178:
	return;
}

static void cc_blockpcl_dx_eq(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	asu64(R2) = a;
	cc_blockpcl_do_fixwiden(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 31;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = cc_blockpcl_getpclcond(asi64(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	return;
}

static void cc_blockpcl_do_labeldef(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L8183;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8183:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_api_gencomment(asu64(R1));
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_blockpcl_do_goto(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8186;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Label not defined: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L8185;
L8186:
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L8187;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 88;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8187:
L8185:
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void cc_blockpcl_dx_ifx(u64 p, u64 a, u64 b, u64 c) {
    u64 R1, R2, R3; 
	i64 lab1;
	i64 lab2;
	i64 ismult;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	ismult = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab1 = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L8190;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8190:
	asi64(R1) = lab1;
	asu64(R2) = a;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = b;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L8192;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
L8192:
	asi64(R1) = lab2;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = c;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L8194;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	cc_libpcl_setmode_u(asu64(R1));
L8194:
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	return;
}

static void cc_blockpcl_do_casestmt(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 value;
	i64 i;
	asi64(R1) = cc_blockpcl_sw_ncases;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8197;
	asu64(R1) = cc_blockpcl_sw_labeltable;
	asu64(R2) = p;
	R3 = 0;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R3) = cc_blockpcl_sw_lower;
	asi64(R2) -= asi64(R3);
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8196;
L8197:
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	value = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = cc_blockpcl_sw_ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8201;
L8198:
	asu64(R1) = cc_blockpcl_sw_valuetable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asi64(R2) = value;
	if (asi64(R1) != asi64(R2)) goto L8203;
	asu64(R1) = cc_blockpcl_sw_labeltable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8200;
L8203:
	i += 1; if (i <= cc_blockpcl_sw_ncases) goto L8198;
L8201:
	R1 = 0;
	R2 = tou64("case: serial switch not found");
	cc_support_gerror(asu64(R2), asu64(R1));
L8200:
L8196:
	asu64(R1) = a;
	cc_blockpcl_do_stmt(asu64(R1));
	return;
}

static void cc_blockpcl_do_switch(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	struct $B46 labeltable;
	struct $B46 valuetable;
	struct $B47 flags;
	i64 defaultlabel;
	i64 breakswlabel;
	i64 switchlabel;
	i64 lower;
	i64 upper;
	i64 length;
	i64 value;
	i64 ncases;
	u8 serialsw;
	i64 i;
	i64 index;
	u64 pcase;
	u64 old_labeltable;
	u64 old_valuetable;
	i64 old_ncases;
	i64 old_lower;
	u8 old_defaultseen;
	i64 old_defaultlabel;
	i64 old_breaklabel;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcase = asu64(R1);
	R1 = 0;
	R2 = R1;
	length = asi64(R2);
	ncases = asi64(R1);
	goto L8206;
L8205:
	R1 = (u64)&ncases;
	(*toi64p(R1)) += 1;
	asi64(R1) = ncases;
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L8209;
	R1 = 0;
	R2 = tou64("Too many cases on one switch");
	cc_support_gerror(asu64(R2), asu64(R1));
L8209:
	asu64(R1) = pcase;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	value = asi64(R2);
	R2 = (u64)&valuetable;
	asi64(R3) = ncases;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8211;
	asi64(R1) = value;
	R2 = R1;
	upper = asi64(R2);
	lower = asi64(R1);
	goto L8210;
L8211:
	asi64(R1) = lower;
	asi64(R2) = value;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	lower = asi64(R1);
	asi64(R1) = upper;
	asi64(R2) = value;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	upper = asi64(R1);
L8210:
	asu64(R1) = pcase;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcase = asu64(R1);
L8206:
	asu64(R1) = pcase;
	if (asu64(R1)) goto L8205;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8213;
	asi64(R1) = upper;
	asi64(R2) = lower;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	goto L8212;
L8213:
	R1 = 0;
	length = asi64(R1);
L8212:
	asi64(R1) = cc_libpcl_createfwdlabel();
	defaultlabel = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	breakswlabel = asi64(R1);
	asi64(R1) = length;
	R2 = 500;
	if (asi64(R1) > asi64(R2)) goto L8216;
	asi64(R1) = ncases;
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L8215;
L8216:
	R1 = 1;
	serialsw = asu8(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8219;
L8217:
	asi64(R1) = cc_libpcl_createfwdlabel();
	R2 = (u64)&labeltable;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	R1 = (u64)&valuetable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = (u64)&labeltable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 26;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = i;
	asi64(R2) = ncases;
	if (asi64(R1) >= asi64(R2)) goto L8221;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8221:
	i += 1; if (i <= ncases) goto L8217;
L8219:
	asi64(R1) = defaultlabel;
	cc_blockpcl_genjumpl(asi64(R1));
	goto L8214;
L8215:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8222;
	asi64(R1) = defaultlabel;
	cc_blockpcl_genjumpl(asi64(R1));
	goto L8214;
L8222:
	R1 = 0;
	serialsw = asu8(R1);
	asi64(R1) = length;
	R2 = 0;
	R3 = (u64)&flags;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8225;
L8223:
	asi64(R1) = defaultlabel;
	R2 = (u64)&labeltable;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	i += 1; if (i <= length) goto L8223;
L8225:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8228;
L8226:
	R1 = (u64)&valuetable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	value = asi64(R1);
	asi64(R1) = value;
	asi64(R2) = lower;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	index = asi64(R1);
	asi64(R1) = cc_libpcl_createfwdlabel();
	R2 = (u64)&labeltable;
	asi64(R3) = index;
	*toi32p(((i64)R2+(i64)R3*4-4)) = asi32(R1);
	R1 = (u64)&flags;
	asi64(R2) = index;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L8230;
	R1 = 0;
	R2 = 0;
	asi64(R3) = value;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Dupl case value: #");
	cc_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L8230:
	R1 = 1;
	R2 = (u64)&flags;
	asi64(R3) = index;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= ncases) goto L8226;
L8228:
	asi64(R1) = cc_libpcl_createfwdlabel();
	switchlabel = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asi64(R1) = switchlabel;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 37;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = lower;
	asi64(R2) = length;
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = lower;
	pc_api_pc_setxy(asi64(R2), asi64(R1));
	asi64(R1) = defaultlabel;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = switchlabel;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8233;
L8231:
	R1 = (u64)&labeltable;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 39;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	i += 1; if (i <= length) goto L8231;
L8233:
	R1 = 0;
	R2 = 40;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8214:
	asu64(R1) = cc_blockpcl_sw_labeltable;
	old_labeltable = asu64(R1);
	asu64(R1) = cc_blockpcl_sw_valuetable;
	old_valuetable = asu64(R1);
	asi64(R1) = cc_blockpcl_sw_lower;
	old_lower = asi64(R1);
	asi64(R1) = cc_blockpcl_sw_ncases;
	old_ncases = asi64(R1);
	asu8(R1) = cc_blockpcl_sw_defaultseen;
	old_defaultseen = asu8(R1);
	asi64(R1) = cc_blockpcl_sw_defaultlabel;
	old_defaultlabel = asi64(R1);
	asi64(R1) = cc_blockpcl_sw_breaklabel;
	old_breaklabel = asi64(R1);
	R1 = (u64)&labeltable;
	cc_blockpcl_sw_labeltable = asu64(R1);
	R1 = (u64)&valuetable;
	cc_blockpcl_sw_valuetable = asu64(R1);
	asi64(R1) = lower;
	cc_blockpcl_sw_lower = asi64(R1);
	asu8(R1) = serialsw;
	if (!asu8(R1)) goto L8235;
	asi64(R1) = ncases;
	goto L8234;
L8235:
	R1 = 0;
L8234:
	cc_blockpcl_sw_ncases = asi64(R1);
	R1 = 0;
	cc_blockpcl_sw_defaultseen = asu8(R1);
	asi64(R1) = defaultlabel;
	cc_blockpcl_sw_defaultlabel = asi64(R1);
	asi64(R1) = breakswlabel;
	cc_blockpcl_sw_breaklabel = asi64(R1);
	asu64(R1) = b;
	cc_blockpcl_do_stmt(asu64(R1));
	asu8(R1) = cc_blockpcl_sw_defaultseen;
	if (asu8(R1)) goto L8237;
	asi64(R1) = defaultlabel;
	cc_libpcl_definefwdlabel(asi64(R1));
L8237:
	asi64(R1) = breakswlabel;
	cc_libpcl_definefwdlabel(asi64(R1));
	asu64(R1) = old_labeltable;
	cc_blockpcl_sw_labeltable = asu64(R1);
	asu64(R1) = old_valuetable;
	cc_blockpcl_sw_valuetable = asu64(R1);
	asi64(R1) = old_lower;
	cc_blockpcl_sw_lower = asi64(R1);
	asi64(R1) = old_ncases;
	cc_blockpcl_sw_ncases = asi64(R1);
	asu8(R1) = old_defaultseen;
	cc_blockpcl_sw_defaultseen = asu8(R1);
	asi64(R1) = old_defaultlabel;
	cc_blockpcl_sw_defaultlabel = asi64(R1);
	asi64(R1) = old_breaklabel;
	cc_blockpcl_sw_breaklabel = asi64(R1);
	return;
}

static void cc_blockpcl_dx_andorl(u64 p) {
    u64 R1, R2, R3; 
	i64 lab1;
	i64 lab2;
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab1 = asi64(R1);
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = lab1;
	asu64(R2) = p;
	R3 = 28;
	cc_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = cc_libpcl_createfwdlabel();
	lab2 = asi64(R1);
	R1 = 1;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = lab2;
	cc_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab1;
	cc_libpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cc_libpcl_setmode_u(asu64(R1));
	asi64(R1) = lab2;
	cc_libpcl_definefwdlabel(asi64(R1));
	return;
}

static void cc_blockpcl_dx_scale(u64 p, u64 a, u64 b) {
    u64 R1, R2; 
	i64 opc;
	i64 scale;
	i64 n;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	scale = asi64(R1);
	R1 = 0;
	asu64(R2) = a;
	cc_blockpcl_dx_expr(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8241;
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 45;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L8240;
L8241:
	asu64(R1) = p;
	R2 = 48;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	cc_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 47;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L8240:
	asu64(R1) = a;
	cc_libpcl_setmode_u(asu64(R1));
	return;
}

static void cc_blockpcl_widen(u64 p) {
    u64 R1, R2; 
	i64 mode;
	asu64(R1) = p;
	R2 = 56;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8244;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	cc_libpcl_setmode(asi64(R1));
	goto L8242;
L8244:
	asu64(R1) = p;
	asi64(R1) = cc_parse_getmemmode(asu64(R1));
	mode = asi64(R1);
	asi64(R1) = mode;
	cc_libpcl_setmode(asi64(R1));
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = mode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 4;
	if (asi64(R1) >= asi64(R2)) goto L8246;
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8247;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8247;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8247;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L8247;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L8247;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L8247;
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L8247;
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L8246;
L8247:
	R1 = 0;
	R2 = 114;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8250;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L8249;
L8250:
	R1 = 3;
	goto L8248;
L8249:
	R1 = 8;
L8248:
	cc_libpcl_setmode(asi64(R1));
	asi64(R1) = mode;
	cc_libpcl_setmode2(asi64(R1));
L8246:
L8242:
	return;
}

static void cc_blockpcl_do_setinplace() {
    u64 R1, R2, R3; 
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8253;
	asu64(R1) = pc_api_pccurr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L8253;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8253:
	return;
}

static void cc_blockpcl_do_fixwiden(u64 a, u64 b) {
	goto L8254;
L8254:
	return;
}

static u64 cc_libpcl_getpsymbol(u64 d) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 e;
	u64 name;
	struct $B16 str;
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8257;
	R1 = 0;
	goto L8255;
L8257:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8259;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L8255;
L8259:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8262;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L8261;
L8262:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L8264;
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = d;
	R3 = 96;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L8264:
	goto L8260;
L8261:
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L8265;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8265;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8265;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 96;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L8267;
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = d;
	R3 = 96;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L8267:
	goto L8260;
L8265:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L8260:
	R1 = (u64)&cc_tables_name2pid;
	asu64(R2) = d;
	R3 = 109;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&str;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	R2 = R1;
	p = asu64(R2);
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 102;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	asi64(R1) = cc_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_ttsize;
	asu64(R2) = d;
	R3 = 102;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8269;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8269;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L8269:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L8271;
	R1 = 1;
	asu64(R2) = p;
	R3 = 81;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8271:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8273;
	R1 = 1;
	asu64(R2) = p;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8273:
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 88;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 100;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8275;
	R1 = tou64("main");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8275;
	R1 = 1;
	R2 = R1;
	asu64(R3) = p;
	R4 = 110;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	asu64(R2) = d;
	R3 = 108;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L8275:
	asu64(R1) = p;
	goto L8255;
L8255:
	return asu64(R1);
}

static void cc_libpcl_setmode(i64 mode) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = mode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asi64(R2) = mode;
	asi64(R2) = cc_lib_getpclmode(asi64(R2));
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	return;
}

static void cc_libpcl_setmode2(i64 mode) {
    u64 R1; 
	asi64(R1) = mode;
	asi64(R1) = cc_lib_getpclmode(asi64(R1));
	pc_api_pc_setmode2(asi64(R1));
	return;
}

static void cc_libpcl_setmode_u(u64 p) {
    u64 R1, R2; 
	i64 mode;
	asu64(R1) = p;
	R2 = 52;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mode = asi64(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = mode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asi64(R2) = mode;
	asi64(R2) = cc_lib_getpclmode(asi64(R2));
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	return;
}

static u64 cc_libpcl_genmem_d(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L8279;
L8279:
	return asu64(R1);
}

static u64 cc_libpcl_genmemaddr_d(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	asu64(R1) = cc_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	goto L8280;
L8280:
	return asu64(R1);
}

static i64 cc_libpcl_definelabel() {
    u64 R1, R2; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = pc_api_mlabelno;
	goto L8281;
L8281:
	return asi64(R1);
}

static i64 cc_libpcl_createfwdlabel() {
    u64 R1; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	goto L8282;
L8282:
	return asi64(R1);
}

static void cc_libpcl_definefwdlabel(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static u64 cc_lib_newstrec() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 128;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	memset(R1, 0, 128);
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 92;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 113;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L8284;
L8284:
	return asu64(R1);
}

static void cc_lib_initcclib() {
	return;
}

static u64 cc_lib_createname(u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 3;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L8286;
L8286:
	return asu64(R1);
}

static u64 cc_lib_createunit0(i64 tag) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = u;
	goto L8287;
L8287:
	return asu64(R1);
}

static u64 cc_lib_createunit1(i64 tag, u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L8288;
L8288:
	return asu64(R1);
}

static u64 cc_lib_createunit2(i64 tag, u64 p, u64 q) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L8289;
L8289:
	return asu64(R1);
}

static u64 cc_lib_createunit3(i64 tag, u64 p, u64 q, u64 r) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = r;
	asu64(R2) = u;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L8290;
L8290:
	return asu64(R1);
}

static u64 cc_lib_createconstunit(u64 a, i64 t) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	asu64(R2) = u;
	R3 = 0;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = u;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = u;
	goto L8291;
L8291:
	return asu64(R1);
}

static u64 cc_lib_createstringconstunit(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = s;
	asu64(R2) = u;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = cc_decls_trefchar;
	asu64(R2) = u;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L8294;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = u;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L8293;
L8294:
	asi64(R1) = length;
	asu64(R2) = u;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L8293:
	R1 = 1;
	asu64(R2) = u;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L8292;
L8292:
	return asu64(R1);
}

static u64 cc_lib_createwstringconstunit(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = cc_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = s;
	asu64(R2) = u;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = cc_decls_trefwchar;
	asu64(R2) = u;
	R3 = 52;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = length;
	asu64(R2) = u;
	R3 = 48;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L8295;
L8295:
	return asu64(R1);
}

static i64 cc_lib_getoptocode(i64 opc) {
    u64 R1, R2, R3; 
	i64 n;
	i64 opcto;
	i64 i;
	struct $B17 str;
	i64 av_1;
	R1 = (u64)&cc_lib_getoptocode_opctotable;
	asi64(R2) = opc;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	opcto = asi64(R1);
	asi64(R1) = opcto;
	if (!asi64(R1)) goto L8298;
	asi64(R1) = opcto;
	goto L8296;
L8298:
	R1 = (u64)&cc_tables_jtagnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("to");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	i = asi64(R1);
	R1 = 77;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8301;
L8299:
	R1 = (u64)&str;
	R2 = (u64)&cc_tables_jtagnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8303;
	asi64(R1) = i;
	R2 = (u64)&cc_lib_getoptocode_opctotable;
	asi64(R3) = opc;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = i;
	goto L8296;
L8303:
	i += 1; if (i <= av_1) goto L8299;
L8301:
	msysc_m$print_startcon();
	R1 = (u64)&cc_tables_jtagnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find -to version");
	cc_support_serror(asu64(R1));
	R1 = 0;
	goto L8296;
L8296:
	return asi64(R1);
}

static i64 cc_lib_getconstvalue(u64 p, i64 id) {
    u64 R1, R2; 
	asu64(R1) = p;
	if (!asu64(R1)) goto L8306;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L8306;
	asu64(R1) = p;
	R2 = 0;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L8304;
L8306:
	R1 = tou64("GCV Not constant");
	cc_support_serror(asu64(R1));
	R1 = 0;
	goto L8304;
L8304:
	return asi64(R1);
}

static u64 cc_lib_nextautotype() {
    u64 R1; 
	R1 = (u64)&cc_lib_nextautotype_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_lib_autotypeno;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_lib_nextautotype_str;
	goto L8307;
L8307:
	return asu64(R1);
}

static i64 cc_lib_createconstmode(i64 m) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8310;
	asi64(R1) = m;
	goto L8308;
L8310:
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	if (!asi16(R1)) goto L8312;
	R1 = (u64)&cc_decls_ttconsttype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	goto L8308;
L8312:
	asi64(R1) = m;
	asi64(R1) = cc_lib_copymode(asi64(R1));
	newm = asi64(R1);
	asi64(R1) = newm;
	R2 = (u64)&cc_decls_ttconsttype;
	asi64(R3) = m;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttconst;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_ttconsttype;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = newm;
	goto L8308;
L8308:
	return asi64(R1);
}

static i64 cc_lib_createrefmode(i64 m) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = (u64)&cc_decls_ttreftype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	if (!asi16(R1)) goto L8315;
	R1 = (u64)&cc_decls_ttshared;
	R2 = (u64)&cc_decls_ttreftype;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	R1 += (i64)R2*4;
	(*toi32p(R1)) += 1;
	R1 = (u64)&cc_decls_ttreftype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	goto L8313;
L8315:
	R1 = 13;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asi64(R1) = newm;
	R2 = (u64)&cc_decls_ttreftype;
	asi64(R3) = m;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttisref;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newm;
	goto L8313;
L8313:
	return asi64(R1);
}

static i64 cc_lib_createprocmode(i64 m, u64 pm) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = 14;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asu64(R1) = pm;
	R2 = (u64)&cc_decls_ttparams;
	asi64(R3) = newm;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = newm;
	goto L8316;
L8316:
	return asi64(R1);
}

static i64 cc_lib_createarraymode(i64 m, i64 length) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = 17;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asi64(R1) = m;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = newm;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	asi64(R1) = length;
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = newm;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = length;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = m;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = newm;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newm;
	goto L8317;
L8317:
	return asi64(R1);
}

static i64 cc_lib_createenummode(u64 e) {
    u64 R1, R2, R3; 
	i64 newm;
	R1 = 12;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asu64(R1) = e;
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = newm;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = newm;
	goto L8318;
L8318:
	return asi64(R1);
}

static i64 cc_lib_createstructmode(u64 s, i64 smode) {
    u64 R1, R2, R3; 
	i64 newm;
	asi64(R1) = smode;
	asi64(R1) = cc_lib_createnewmode(asi64(R1));
	newm = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = newm;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = newm;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newm;
	goto L8319;
L8319:
	return asi64(R1);
}

static void cc_lib_setnameptr(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 cc_lib_getautofieldname() {
    u64 R1; 
	struct $B18 str;
	u64 name;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$F");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&cc_lib_nextafindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = name;
	asu64(R1) = cc_lex_addnamestr(asu64(R1));
	goto L8321;
L8321:
	return asu64(R1);
}

static i64 cc_lib_convertstringc(u64 s, u64 t, i64 length) {
    u64 R1, R2, R3; 
	i64 c;
	struct $B17 str;
	u64 t0;
	i64 av_1;
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L8324;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L8324:
	asu64(R1) = t;
	t0 = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L8327;
L8325:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	switch (asi64(R1)) {
	case 7: goto L8337;
	case 8: goto L8338;
	case 9: goto L8335;
	case 10: goto L8333;
	case 11: goto L8340;
	case 12: goto L8339;
	case 13: goto L8334;
	case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 35: case 36: case 37: case 38: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: goto L8330;
	case 34: goto L8331;
	case 39: goto L8332;
	case 92: goto L8336;
	default: goto L8330;
    };
// SWITCH
L8331:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L8328;
L8332:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 39;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L8328;
L8333:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L8328;
L8334:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 114;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L8328;
L8335:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L8328;
L8336:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L8328;
L8337:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 97;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L8328;
L8338:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 98;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L8328;
L8339:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 102;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L8328;
L8340:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 118;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L8328;
L8330:
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L8343;
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) < asi64(R2)) goto L8342;
L8343:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("\\#o");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("z3");
	asi64(R2) = c;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L8341;
L8342:
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L8341:
L8328:
	if (--asi64(av_1)) goto L8325;
L8327:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = t;
	asu64(R2) = t0;
	asi64(R1) -= asi64(R2);
	goto L8322;
L8322:
	return asi64(R1);
}

static u64 cc_lib_getopcjname(i64 opc) {
    u64 R1, R2, R3, R4; 
	u64 name;
	u64 s;
	R1 = (u64)&cc_tables_jtagnames;
	asi64(R2) = opc;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	name = asu64(R1);
	R1 = 32;
	asu64(R2) = name;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (!asu64(R1)) goto L8346;
	asu64(R1) = s;
	asu64(R2) = name;
	asu64(R1) -= asu64(R2);
	asu64(R2) = name;
	R3 = (u64)&cc_lib_getopcjname_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_lib_getopcjname_str;
	asu64(R3) = s;
	asu64(R4) = name;
	asi64(R3) -= asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lib_getopcjname_str;
	goto L8345;
L8346:
	asu64(R1) = name;
L8345:
	goto L8344;
L8344:
	return asu64(R1);
}

static u64 cc_lib_strmode(i64 m, i64 expand) {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_lib_strmode_str;
	asi64(R2) = expand;
	asi64(R3) = m;
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&cc_lib_strmode_str;
	goto L8347;
L8347:
	return asu64(R1);
}

static u64 cc_lib_strmode2(i64 m, i64 expand) {
    u64 R1, R2, R3; 
	R1 = (u64)&cc_lib_strmode2_str;
	asi64(R2) = expand;
	asi64(R3) = m;
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&cc_lib_strmode2_str;
	goto L8348;
L8348:
	return asu64(R1);
}

static void cc_lib_istrmode(i64 m, i64 expand, u64 dest) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 q;
	i64 value;
	i64 needcomma;
	i64 x;
	i64 i;
	i64 target;
	i64 t;
	i64 n;
	struct $B3 sxx;
	u64 xx;
	u64 sdim;
	u64 slength;
	struct $B5 strdim;
	struct $B5 strlength;
	u64 pm;
	R1 = (u64)&sxx;
	xx = asu64(R1);
	asi64(R1) = m;
	R2 = 21;
	if (asi64(R1) >= asi64(R2)) goto L8351;
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8349;
L8351:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	t = asi64(R1);
	asi64(R1) = t;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8353;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8354;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8355;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L8356;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L8356;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L8357;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L8358;
	goto L8359;
L8353:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8361;
	R1 = tou64("const ref ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8360;
L8361:
	R1 = tou64("ref ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L8360:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	target = asi64(R1);
	asi64(R1) = target;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8363;
	R1 = (u64)&cc_decls_ttbasetype;
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = m;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L8363;
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L8362;
L8363:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
L8362:
	goto L8352;
L8354:
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	if (!asi64(R1)) goto L8365;
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L8364;
L8365:
	R1 = tou64("[]");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L8364:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L8352;
L8355:
	R1 = tou64("enum ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L8352;
L8356:
	asi64(R1) = expand;
	if (asi64(R1)) goto L8367;
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8349;
L8367:
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("(");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 0;
	needcomma = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L8369;
L8368:
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L8372;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L8372:
	R1 = 1;
	needcomma = asi64(R1);
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = q;
	R4 = 102;
	asu16(R3) = *tou16p(((i64)R3+(i64)R4));
	R3 = toi64(tou16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L8369:
	asu64(R1) = q;
	if (asu64(R1)) goto L8368;
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L8352;
L8357:
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8352;
L8358:
	R1 = tou64("proc(");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8375;
L8373:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = pm;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = n;
	if (asi64(R1) == asi64(R2)) goto L8377;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L8377:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	i += 1; if (i <= n) goto L8373;
L8375:
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&cc_decls_tttarget;
	asi64(R4) = m;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4*2));
	R3 = toi64(toi16(R3));
	cc_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L8352;
L8359:
	asi64(R1) = t;
	R2 = 21;
	if (asi64(R1) >= asi64(R2)) goto L8379;
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L8349;
	goto L8378;
L8379:
	msysc_m$print_startcon();
	asi64(R1) = m;
	asu64(R1) = cc_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("NEWSTRMODE");
	cc_support_mcerror(asu64(R1));
L8378:
L8352:
L8349:
	return;
}

static u64 cc_lib_typename(i64 m) {
    u64 R1, R2, R3; 
	i64 basem;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	basem = asi64(R1);
	asi64(R1) = basem;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L8382;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L8382;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8383;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L8384;
	goto L8385;
L8382:
	asi64(R1) = basem;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L8387;
	R1 = tou64("struct ");
	goto L8386;
L8387:
	R1 = tou64("union ");
L8386:
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L8389;
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 96;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L8389:
	R1 = (u64)&cc_lib_typename_str;
	goto L8380;
	goto L8381;
L8383:
	R1 = tou64("<array>");
	goto L8380;
	goto L8381;
L8384:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L8391;
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L8380;
L8391:
	R1 = tou64("<enum>");
	goto L8380;
	goto L8381;
L8385:
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L8393;
	R1 = tou64("const ");
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&cc_tables_stdtypenames;
	asi64(R2) = basem;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_lib_typename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_lib_typename_str;
	goto L8380;
L8393:
	R1 = (u64)&cc_tables_stdtypenames;
	asi64(R2) = basem;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L8380;
L8381:
	R1 = tou64("");
	goto L8380;
L8380:
	return asu64(R1);
}

static u64 cc_lib_allocunitrec() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	i64 nwords;
	R1 = (u64)&cc_decls_nunits;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_lib_remainingunits;
	asi64(R2) = *toi64p(R1); *(toi64p(R1)) -= 1; asi64(R1) = asi64(R2);
	if (!asi64(R1)) goto L8396;
	asu64(R1) = cc_lib_unitheapptr;
	p = asu64(R1);
	R1 = (u64)&cc_lib_unitheapptr;
	(*tou64p(R1)) += 64;
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 255;
	if (asi64(R1) > asi64(R2)) goto L8398;
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8398:
	asu64(R1) = p;
	goto L8394;
L8396:
	R1 = 3200000;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	cc_lib_unitheapptr = asu64(R2);
	p = asu64(R1);
	R1 = 3200000;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 49999;
	cc_lib_remainingunits = asi64(R1);
	R1 = (u64)&cc_lib_unitheapptr;
	(*tou64p(R1)) += 64;
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 255;
	if (asi64(R1) > asi64(R2)) goto L8400;
	R1 = (u64)&cc_decls_lx;
	R2 = 20;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8400:
	asu64(R1) = p;
	goto L8394;
L8394:
	return asu64(R1);
}

static i64 cc_lib_copymode(i64 m) {
    u64 R1, R2, R3; 
	asi64(R1) = cc_decls_ntypes;
	R2 = 80000;
	if (asi64(R1) < asi64(R2)) goto L8403;
	R1 = tou64("Too many types");
	cc_support_serror(asu64(R1));
L8403:
	R1 = (u64)&cc_decls_ntypes;
	(*toi64p(R1)) += 1;
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttnamedef;
	asi64(R3) = cc_decls_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = cc_decls_ntypes;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_decls_ttlength;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttlength;
	asi64(R3) = cc_decls_ntypes;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = (u64)&cc_decls_ttconst;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttconst;
	asi64(R3) = cc_decls_ntypes;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = cc_decls_ntypes;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R2 = (u64)&cc_decls_tttarget;
	asi64(R3) = cc_decls_ntypes;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_decls_ttparams;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttparams;
	asi64(R3) = cc_decls_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&cc_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttisref;
	asi64(R3) = cc_decls_ntypes;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_decls_ttisblock;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = cc_decls_ntypes;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cc_decls_ntypes;
	goto L8401;
L8401:
	return asi64(R1);
}

static i64 cc_lib_createnewmode(i64 m) {
    u64 R1, R2, R3; 
	asi64(R1) = cc_decls_ntypes;
	R2 = 80000;
	if (asi64(R1) < asi64(R2)) goto L8406;
	msysc_m$print_startcon();
	R1 = tou64("STRMODE(M)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Too many types/cnm");
	cc_support_serror(asu64(R1));
L8406:
	R1 = (u64)&cc_decls_ntypes;
	(*toi64p(R1)) += 1;
	asi64(R1) = m;
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = cc_decls_ntypes;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = cc_decls_ntypes;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = cc_decls_ntypes;
	goto L8404;
L8404:
	return asi64(R1);
}

static void cc_lib_addlistunit(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8409;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L8408;
L8409:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L8408:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lib_addlistdef(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8412;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L8411;
L8412:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L8411:
	R1 = 0;
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lib_addlistparam(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8415;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L8414;
L8415:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L8414:
	R1 = 0;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static void cc_lib_checksymbol(i64 symbol) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = symbol;
	if (asi64(R1) == asi64(R2)) goto L8418;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# expected, not #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&cc_tables_symbolnames;
	asi64(R2) = symbol;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_tables_symbolnames;
	R2 = (u64)&cc_decls_lx;
	R3 = 21;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L8420;
	R1 = tou64(" \"");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = cc_lib_getstname(asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("\"");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L8420:
	R1 = (u64)&str;
	cc_support_serror(asu64(R1));
L8418:
	return;
}

static void cc_lib_skipsymbol(i64 symbol) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_lx;
	R2 = 21;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = symbol;
	if (asi64(R1) == asi64(R2)) goto L8423;
	asi64(R1) = symbol;
	cc_lib_checksymbol(asi64(R1));
L8423:
	cc_lex_lex();
	return;
}

static void cc_lib_inittypetables() {
    u64 R1, R2, R3; 
	i64 i;
	i64 j;
	i64 size;
	i64 bitsize;
	i64 s;
	i64 t;
	i64 u;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	R1 = 0;
	i = asi64(R1);
	R1 = 20;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L8427;
L8425:
	asi64(R1) = i;
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = i;
	*toi16p(((i64)R2+(i64)R3*2)) = asi16(R1);
	R1 = (u64)&cc_tables_stdtypewidths;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	bitsize = asi64(R1);
	asi64(R1) = bitsize;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&cc_decls_ttsize;
	asi64(R3) = i;
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	asi64(R1) = i;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8430;
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L8429;
L8430:
	R1 = 1;
	R2 = (u64)&cc_decls_ttisblock;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L8429:
	i += 1; if (i <= av_1) goto L8425;
L8427:
	R1 = 20;
	cc_decls_ntypes = asi64(R1);
	R1 = 1;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	cc_decls_trefchar = asi64(R1);
	R1 = 7;
	asi64(R1) = cc_lib_createrefmode(asi64(R1));
	cc_decls_trefwchar = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = 121;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8433;
L8431:
	R1 = (u64)&cc_tables_dominantsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	R1 = (u64)&cc_tables_dominantsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	R1 = (u64)&cc_tables_dominantsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = (u64)&cc_tables_dominantmode;
	asi64(R3) = s;
	R2 += (i64)R3*32;
	asi64(R3) = t;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_2) goto L8431;
L8433:
	R1 = 1;
	i = asi64(R1);
	R1 = 121;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8436;
L8434:
	R1 = (u64)&cc_tables_convsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	R1 = (u64)&cc_tables_convsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	R1 = (u64)&cc_tables_convsetuptable;
	asi64(R2) = i;
	R1 += (i64)R2*3-3;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = (u64)&cc_tables_conversionops;
	asi64(R3) = s;
	R2 += (i64)R3*16;
	asi64(R3) = t;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_3) goto L8434;
L8436:
	return;
}

static u64 cc_lib_createdupldef(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	asu64(R1) = cc_lib_newstrec();
	p = asu64(R1);
	asu64(R1) = symptr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 106;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = p;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = owner;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = id;
	asu64(R2) = p;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_tables_namespaces;
	asi64(R2) = id;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 98;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = symptr;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	q = asu64(R2);
	if (!asu64(R1)) goto L8439;
	asu64(R1) = p;
	asu64(R2) = q;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L8439:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	asu64(R2) = p;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = symptr;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = owner;
	if (!asu64(R1)) goto L8441;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8443;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = owner;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = owner;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L8442;
L8443:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L8442:
L8441:
	asu64(R1) = p;
	goto L8437;
L8437:
	return asu64(R1);
}

static u64 cc_lib_createnewmoduledef(u64 owner, u64 symptr) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	R1 = 3;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L8444;
L8444:
	return asu64(R1);
}

static u64 cc_lib_createnewproc(u64 owner, u64 symptr) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	R1 = 6;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = cc_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	q = asu64(R1);
	goto L8447;
L8446:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L8450;
	msysc_m$print_startcon();
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Dupl proc name");
	cc_support_serror(asu64(R1));
L8450:
L8447:
	asu64(R1) = q;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	q = asu64(R2);
	if (asu64(R1)) goto L8446;
	asu64(R1) = p;
	goto L8445;
L8445:
	return asu64(R1);
}

static u64 cc_lib_resolvename(u64 owner, u64 symptr, i64 ns, i64 blockno) {
    u64 R1, R2; 
	i64 nsblock;
	u64 d;
	asu64(R1) = symptr;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L8453;
	asu64(R1) = symptr;
	goto L8451;
L8453:
	asi64(R1) = ns;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8455;
	asu64(R1) = symptr;
	asu64(R2) = owner;
	asu64(R1) = cc_lib_resolvelabel(asu64(R2), asu64(R1));
	goto L8451;
L8455:
	asi64(R1) = blockno;
	if (!asi64(R1)) goto L8457;
	R1 = (u64)&cc_decls_blockcounts;
	asi64(R2) = blockno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8457;
	R1 = (u64)&cc_decls_blockowner;
	asi64(R2) = blockno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	blockno = asi64(R1);
L8457:
L8458:
	asi64(R1) = ns;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = blockno;
	asi64(R1) |= asi64(R2);
	nsblock = asi64(R1);
	asu64(R1) = symptr;
	d = asu64(R1);
	goto L8461;
L8460:
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8464;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L8464;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8464;
	goto L8462;
L8464:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L8466;
	asu64(R1) = d;
	R2 = 96;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nsblock;
	if (asi64(R1) != asi64(R2)) goto L8466;
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 255;
	if (asi64(R1) >= asi64(R2)) goto L8468;
	asu64(R1) = d;
	R2 = 122;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
L8468:
	asu64(R1) = d;
	goto L8451;
L8466:
L8461:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (asu64(R1)) goto L8460;
L8462:
	asi64(R1) = blockno;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8470;
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L8472;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L8473;
	goto L8474;
L8472:
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
	goto L8458;
	goto L8471;
L8473:
	asu64(R1) = owner;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8476;
	R1 = 0;
	goto L8451;
L8476:
	goto L8471;
L8474:
	R1 = 0;
	goto L8451;
L8471:
	goto L8469;
L8470:
	R1 = (u64)&cc_decls_blockowner;
	asi64(R2) = blockno;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = R1;
	blockno = asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8477;
	asu64(R1) = cc_decls_stmodule;
	owner = asu64(R1);
L8477:
L8469:
	goto L8458;
	R1 = 0;
	goto L8451;
L8451:
	return asu64(R1);
}

static u64 cc_lib_resolvelabel(u64 owner, u64 symptr) {
    u64 R1, R2; 
	u64 d;
	asu64(R1) = symptr;
	d = asu64(R1);
	goto L8480;
L8479:
	asu64(R1) = owner;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8483;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L8483;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8483;
	goto L8481;
L8483:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L8485;
	asu64(R1) = d;
	R2 = 98;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8485;
	asu64(R1) = d;
	goto L8478;
L8485:
L8480:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (asu64(R1)) goto L8479;
L8481:
	R1 = 0;
	goto L8478;
L8478:
	return asu64(R1);
}

static u64 cc_lib_checkdupl(u64 owner, u64 symptr, i64 ns, i64 blockno) {
    u64 R1, R2; 
	i64 nsblock;
	u64 d;
	asu64(R1) = symptr;
	d = asu64(R1);
	asi64(R1) = ns;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = blockno;
	asi64(R1) |= asi64(R2);
	nsblock = asi64(R1);
	goto L8488;
L8487:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L8491;
	asu64(R1) = d;
	R2 = 96;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nsblock;
	if (asi64(R1) != asi64(R2)) goto L8491;
	asu64(R1) = d;
	goto L8486;
L8491:
L8488:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (asu64(R1)) goto L8487;
	R1 = 0;
	goto L8486;
L8486:
	return asu64(R1);
}

static u64 cc_lib_checkdupl_inproc(u64 owner, u64 symptr, i64 ns, i64 blockno) {
    u64 R1, R2; 
	i64 nsblock;
	u64 d;
	asu64(R1) = symptr;
	d = asu64(R1);
	asi64(R1) = ns;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = blockno;
	asi64(R1) |= asi64(R2);
	nsblock = asi64(R1);
	goto L8494;
L8493:
	asu64(R1) = d;
	R2 = 96;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nsblock;
	if (asi64(R1) != asi64(R2)) goto L8497;
	asu64(R1) = d;
	goto L8492;
L8497:
L8494:
	asu64(R1) = d;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	if (!asu64(R1)) goto L8498;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L8493;
L8498:
	R1 = 0;
	goto L8492;
L8492:
	return asu64(R1);
}

static i64 cc_lib_getalignment(i64 m) {
    u64 R1, R2; 
	i64 a;
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L8501;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L8502;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L8502;
	goto L8503;
L8501:
	R1 = (u64)&cc_decls_tttarget;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	asi64(R1) = cc_lib_getalignment(asi64(R1));
	goto L8499;
	goto L8500;
L8502:
	R1 = (u64)&cc_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8505;
	R1 = 16;
	goto L8499;
L8505:
	asi64(R1) = a;
	goto L8499;
	goto L8500;
L8503:
L8500:
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = m;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8507;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8507;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8507;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8507;
	goto L8508;
L8507:
	asi64(R1) = a;
	goto L8499;
	goto L8506;
L8508:
L8506:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = cc_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = a;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("GETALIGN SIZE NOT 1248");
	cc_support_serror(asu64(R1));
	R1 = 0;
	goto L8499;
L8499:
	return asi64(R1);
}

static i64 cc_lib_isexported(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8511;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L8513;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8514;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L8513;
L8514:
	R1 = 1;
	goto L8509;
L8513:
	goto L8510;
L8511:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L8516;
	R1 = 1;
	goto L8509;
L8516:
L8510:
	R1 = 0;
	goto L8509;
L8509:
	return asi64(R1);
}

static i64 cc_lib_isimported(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L8519;
	asu64(R1) = d;
	R2 = 72;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8521;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L8522;
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L8521;
L8522:
	R1 = 1;
	goto L8517;
L8521:
	goto L8518;
L8519:
	asu64(R1) = d;
	R2 = 110;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L8524;
	R1 = 1;
	goto L8517;
L8524:
L8518:
	R1 = 0;
	goto L8517;
L8517:
	return asi64(R1);
}

static u64 cc_lib_getstname(u64 d) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = d;
	R2 = 106;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&cc_lib_getstname_name;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&cc_lib_getstname_name;
	asu64(R3) = d;
	R4 = 106;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&cc_lib_getstname_name;
	goto L8525;
L8525:
	return asu64(R1);
}

static i64 cc_lib_isrealcc(i64 m) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	R1 = 10;
	asi64(R2) = m;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L8527;
	R2 = 11;
	if (asi64(R1) > asi64(R2)) goto L8527;
	R1 = 1;
	goto L8528;
L8527:
	R1 = 0;
L8528:
	goto L8526;
L8526:
	return asi64(R1);
}

static i64 cc_lib_isintcc(i64 m) {
    u64 R1, R2; 
	R1 = (u64)&cc_decls_ttbasetype;
	asi64(R2) = m;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2));
	R1 = toi64(toi16(R1));
	m = asi64(R1);
	R1 = 1;
	asi64(R2) = m;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) < asi64(R2)) goto L8530;
	R2 = 9;
	if (asi64(R1) > asi64(R2)) goto L8530;
	R1 = 1;
	goto L8531;
L8530:
	R1 = 0;
L8531:
	goto L8529;
L8529:
	return asi64(R1);
}

static i64 cc_lib_ispoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	i64 n;
	i64 av_1;
	R1 = 1;
	a = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 60;
	av_1 = asi64(R1);
L8533:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = a;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	a = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) != asi64(R2)) goto L8537;
	asi64(R1) = n;
	goto L8532;
L8537:
	if (--asi64(av_1)) goto L8533;
	R1 = 0;
	goto L8532;
L8532:
	return asi64(R1);
}

static void cc_lib_writegsfile(u64 filename, u64 d) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = d;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	return;
}

static void cc_lib_pause(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asi64(R1) = mwindows_os_getch();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static i64 cc_lib_getpclmode(i64 t) {
    u64 R1, R2, R3; 
	i64 u;
	R1 = (u64)&cc_tables_stdpcl;
	R2 = (u64)&cc_decls_ttbasetype;
	asi64(R3) = t;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3*2));
	R2 = toi64(toi16(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L8542;
	R1 = (u64)&cc_decls_ttsize;
	asi64(R2) = t;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L8544;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L8545;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L8546;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L8547;
	goto L8548;
L8544:
	R1 = 6;
	u = asi64(R1);
	goto L8543;
L8545:
	R1 = 5;
	u = asi64(R1);
	goto L8543;
L8546:
	R1 = 4;
	u = asi64(R1);
	goto L8543;
L8547:
	R1 = 3;
	u = asi64(R1);
	goto L8543;
L8548:
L8543:
L8542:
	asi64(R1) = u;
	goto L8540;
L8540:
	return asi64(R1);
}

static void cc_lib_addtolog(u64 filename, u64 logdest) {
    u64 R1, R2; 
	u64 f;
	i64 c;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L8551;
	msysc_m$print_startcon();
	R1 = tou64("ATL ERROR");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L8549;
L8551:
L8552:
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L8555;
	goto L8553;
L8555:
	asu64(R1) = logdest;
	asi64(R2) = c;
	asi32(R1) = fputc(asi32(R2), asu64(R1));
	goto L8552;
L8553:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L8549:
	return;
}

static void cc_support_stopcompiler(u64 filename, i64 lineno) {
    u64 R1, R2; 
	u64 f;
	asu8(R1) = cc_cli_fwriteerrors;
	if (!asu8(R1)) goto L8558;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L8558:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void cc_support_mcerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("\nMC Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 40;
	exit(R1);
	return;
}

static void cc_support_serror(u64 mess) {
    u64 R1; 
	asu64(R1) = mess;
	cc_support_serror_gen(asu64(R1));
	return;
}

static void cc_support_serror_gen(u64 mess) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L8563;
	msysc_m$print_startcon();
	R1 = tou64("\nIn function");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L8562;
L8563:
	msysc_m$print_startcon();
	R1 = tou64("OUTSIDE PROC");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L8562:
	msysc_m$print_startcon();
	R1 = tou64("On line");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in file");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	R2 = (u64)&cc_decls_lx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilenames;
	R2 = (u64)&cc_decls_lx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	cc_support_showmacrolineno();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("**** Syntax Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("****");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&cc_decls_sourcefilepaths;
	R3 = (u64)&cc_decls_lx;
	R4 = 20;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	cc_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void cc_support_serror_ss(u64 mess, u64 a, u64 b) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = b;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_serror_gen(asu64(R1));
	return;
}

static void cc_support_serror_s(u64 mess, u64 a) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_serror_gen(asu64(R1));
	return;
}

static void cc_support_terror_gen(u64 mess) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L8568;
	msysc_m$print_startcon();
	R1 = tou64("\nIn function");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L8568:
	msysc_m$print_startcon();
	R1 = tou64("Type error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("on line");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	R2 = (u64)&cc_decls_lx;
	R3 = 20;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	cc_support_showmacrolineno();
	R1 = (u64)&cc_decls_lx;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&cc_decls_sourcefilepaths;
	R3 = (u64)&cc_decls_lx;
	R4 = 20;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	cc_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void cc_support_terror(u64 mess) {
    u64 R1; 
	asu64(R1) = mess;
	cc_support_terror_gen(asu64(R1));
	return;
}

static void cc_support_terror_s(u64 mess, u64 a) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_terror_gen(asu64(R1));
	return;
}

static void cc_support_terror_ss(u64 mess, u64 a, u64 b) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = b;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	cc_support_terror_gen(asu64(R1));
	return;
}

static void cc_support_gerror_gen(u64 mess, u64 p) {
    u64 R1, R2, R3; 
	i64 lineno;
	i64 fileno;
	asu64(R1) = p;
	if (!asu64(R1)) goto L8574;
	asu64(R1) = p;
	R2 = 44;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	lineno = asi64(R1);
	asu64(R1) = p;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	fileno = asi64(R1);
	goto L8573;
L8574:
	asi64(R1) = cc_decls_clineno;
	lineno = asi64(R1);
	asi64(R1) = cc_decls_cfileno;
	fileno = asi64(R1);
L8573:
	asu64(R1) = cc_decls_currproc;
	if (!asu64(R1)) goto L8576;
	msysc_m$print_startcon();
	R1 = tou64("In function");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = cc_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L8576:
	msysc_m$print_startcon();
	R1 = tou64("On line");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	R2 = 16777215;
	asi64(R1) &= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in file");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_decls_sourcefilepaths;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("**** Code Gen Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("****");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = lineno;
	R2 = (u64)&cc_decls_sourcefilepaths;
	asi64(R3) = fileno;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	cc_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void cc_support_gerror(u64 mess, u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	asu64(R2) = mess;
	cc_support_gerror_gen(asu64(R2), asu64(R1));
	return;
}

static void cc_support_gerror_s(u64 mess, u64 s, u64 p) {
    u64 R1, R2; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = (u64)&str;
	cc_support_gerror_gen(asu64(R2), asu64(R1));
	return;
}

static i64 cc_support_nextpoweroftwo(i64 x) {
    u64 R1, R2; 
	i64 a;
	asi64(R1) = x;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L8581;
	R1 = 0;
	goto L8579;
L8581:
	R1 = 1;
	a = asi64(R1);
	goto L8583;
L8582:
	R1 = 1;
	R2 = (u64)&a;
	*toi64p(R2) <<= asi64(R1);
L8583:
	asi64(R1) = a;
	asi64(R2) = x;
	if (asi64(R1) < asi64(R2)) goto L8582;
	asi64(R1) = a;
	goto L8579;
L8579:
	return asi64(R1);
}

static void cc_support_loaderror(u64 mess, u64 mess2) {
    u64 R1; 
	struct $B31 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess2;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Load Error:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Stopping");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 45;
	exit(R1);
	return;
}

static i64 cc_support_loadsourcefile(u64 file, u64 shortfile) {
    u64 R1, R2, R3; 
	u64 s;
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 200;
	if (asi64(R1) <= asi64(R2)) goto L8588;
	R1 = tou64("");
	R2 = tou64("Too many source files");
	cc_support_loaderror(asu64(R2), asu64(R1));
L8588:
	R1 = (u64)&cc_decls_nsourcefiles;
	(*toi64p(R1)) += 1;
	asu64(R1) = file;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilepaths;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = shortfile;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilenames;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = file;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (asu64(R1)) goto L8590;
	asu64(R1) = file;
	R2 = tou64("LSF can't load ");
	cc_support_loaderror(asu64(R2), asu64(R1));
L8590:
	asu64(R1) = s;
	R2 = (u64)&cc_decls_sourcefiletext;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = mlib_rfsize;
	R2 = (u64)&cc_decls_sourcefilesizes;
	asi64(R3) = cc_decls_nsourcefiles;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = mlib_rfsize;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	goto L8586;
L8586:
	return asi64(R1);
}

static u64 cc_support_splicelines(u64 s) {
    u64 R1, R2, R3; 
	u64 t;
	u64 u;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	u = asu64(R2);
	t = asu64(R1);
	goto L8593;
L8592:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L8596;
	asu64(R1) = s;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8596;
	R1 = 2;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	goto L8595;
L8596:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L8597;
	asu64(R1) = s;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L8597;
	asu64(R1) = s;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L8597;
	R1 = 3;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	goto L8595;
L8597:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L8595:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L8593:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L8592;
	asu64(R1) = u;
	goto L8591;
L8591:
	return asu64(R1);
}

static i64 cc_support_loadbuiltin(u64 shortfile, u64 hdrtext) {
    u64 R1, R2, R3; 
	u64 s;
	asi64(R1) = cc_decls_nsourcefiles;
	R2 = 200;
	if (asi64(R1) <= asi64(R2)) goto L8600;
	R1 = tou64("");
	R2 = tou64("Too many source files");
	cc_support_loaderror(asu64(R2), asu64(R1));
L8600:
	R1 = (u64)&cc_decls_nsourcefiles;
	(*toi64p(R1)) += 1;
	R1 = tou64("<builtin>");
	R2 = (u64)&cc_decls_sourcefilepaths;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = shortfile;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilenames;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = hdrtext;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&cc_decls_sourcefiletext;
	asi64(R3) = cc_decls_nsourcefiles;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = hdrtext;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&cc_decls_sourcefilesizes;
	asi64(R3) = cc_decls_nsourcefiles;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = cc_decls_nsourcefiles;
	goto L8598;
L8598:
	return asi64(R1);
}

static void cc_support_gs_copytostr(u64 source, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = source;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L8603;
	asu64(R1) = source;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = source;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = s;
	asu64(R3) = source;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L8602;
L8603:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
L8602:
	return;
}

static void cc_support_gs_additem(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	u64 d;
	i64 lastchar;
	i64 nextchar;
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L8606;
	asu64(R1) = d;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	lastchar = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	nextchar = asi64(R1);
	asi64(R1) = lastchar;
	asi64(R1) = cc_support_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L8608;
	asi64(R1) = nextchar;
	asi64(R1) = cc_support_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L8608;
	R1 = -1;
	R2 = tou64(" ");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
L8608:
L8606:
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 cc_support_isalphanum(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L8613;
	asi64(R1) = c;
	R2 = 90;
	if (asi64(R1) <= asi64(R2)) goto L8612;
L8613:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L8614;
	asi64(R1) = c;
	R2 = 122;
	if (asi64(R1) <= asi64(R2)) goto L8612;
L8614:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L8611;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L8611;
L8612:
	R1 = 1;
	goto L8609;
L8611:
	R1 = 0;
	goto L8609;
L8609:
	return asi64(R1);
}

static void cc_support_showmacrolineno() {
    u64 R1; 
	asi64(R1) = cc_decls_slineno;
	if (!asi64(R1)) goto L8617;
L8617:
	return;
}

static u64 cc_headers_findheader(u64 name) {
    u64 R1, R2, R3; 
	i64 i;
	struct $B16 newname;
	u64 s;
	u64 t;
	i64 av_1;
	R1 = 92;
	asu64(R2) = name;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	if (!asu64(R1)) goto L8620;
	asu64(R1) = name;
	s = asu64(R1);
	R1 = (u64)&newname;
	t = asu64(R1);
	goto L8622;
L8621:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L8625;
	R1 = 47;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L8624;
L8625:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L8624:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L8622:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L8621;
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&newname;
	name = asu64(R1);
L8620:
	R1 = 1;
	i = asi64(R1);
	R1 = 40;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8628;
L8626:
	R1 = (u64)&cc_headers_stdhdrnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8630;
	R1 = (u64)&cc_headers_stdhdrtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = *tou64p(R1);
	goto L8618;
L8630:
	i += 1; if (i <= av_1) goto L8626;
L8628:
	R1 = 0;
	goto L8618;
L8618:
	return asu64(R1);
}

static void cc_headers_writeheaders() {
    u64 R1, R2, R3, R4, R5; 
	u64 f;
	u64 ifile;
	i64 i;
	i64 av_1;
	R1 = 1;
	i = asi64(R1);
	R1 = 40;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8634;
L8632:
	R1 = tou64("hdr");
	R2 = (u64)&cc_headers_stdhdrnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	ifile = asu64(R1);
	msysc_m$print_startcon();
	R1 = tou64("Writing internal");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&cc_headers_stdhdrnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("as");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ifile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("wb");
	asu64(R2) = ifile;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = (u64)&cc_headers_stdhdrtext;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R2) = *tou64p(R2);
	asu64(R2) = strlen(asu64(R2));
	R3 = 1;
	R4 = (u64)&cc_headers_stdhdrtext;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	asu64(R4) = *tou64p(R4);
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	i += 1; if (i <= av_1) goto L8632;
L8634:
	return;
}

static i64 cc_headers_isheaderfile(u64 file) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 40;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L8638;
L8636:
	asu64(R1) = file;
	R2 = (u64)&cc_headers_stdhdrnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L8640;
	R1 = 1;
	goto L8635;
L8640:
	i += 1; if (i <= av_1) goto L8636;
L8638:
	R1 = 0;
	goto L8635;
L8635:
	return asi64(R1);
}

static void cc_showdummy_printcode(u64 f, u64 caption) {
	return;
}

static void cc_showdummy_printunit(u64 dev, u64 p, i64 level, u64 prefix) {
	return;
}

static void cc_showdummy_printmodelist(u64 f) {
	return;
}

static u64 cc_showdummy_strexpr(u64 p) {
    u64 R1; 
	R1 = 0;
	goto L8644;
L8644:
	return asu64(R1);
}

static void cc_showdummy_printst(u64 f, u64 p, i64 level) {
	return;
}

static void cc_showdummy_printstflat(u64 f) {
	return;
}

static u64 cc_showdummy_writeallpcl() {
    u64 R1; 
	R1 = 0;
	goto L8647;
L8647:
	return asu64(R1);
}

static u64 cc_showdummy_strpclstr(u64 p) {
    u64 R1; 
	R1 = 0;
	goto L8648;
L8648:
	return asu64(R1);
}

static u64 cc_showdummy_stropndstack(i64 indent) {
    u64 R1; 
	R1 = 0;
	goto L8649;
L8649:
	return asu64(R1);
}

static void cc_showdummy_showopndstack() {
	return;
}

static void cc_showdummy_printfilelist(u64 f) {
	return;
}

static void pclpe_start() {
	mc_genss_start();
	mc_decls_start();
	mc_writenasm_start();
	return;
}

static struct $B88 $procaddr = {{
(u64)&mc_genmcl_px_nop,
(u64)&mc_genmcl_px_dupl,
(u64)&mc_genmcl_px_double,
(u64)&mc_genmcl_px_opnd,
(u64)&mc_genmcl_px_type,
(u64)&mc_genmcl_px_comment,
(u64)&mc_genmcl_px_proc,
(u64)&mc_genmcl_px_endproc,
(u64)&mc_genmcl_px_endprog,
(u64)&mc_genmcl_px_istatic,
(u64)&mc_genmcl_px_zstatic,
(u64)&mc_genmcl_px_data,
(u64)&mc_genmcl_px_label,
(u64)&mc_genmcl_px_load,
(u64)&mc_genmcl_px_store,
(u64)&mc_genmcl_px_add,
(u64)&mc_genmcl_px_sub,
(u64)&mc_genmcl_px_mul,
(u64)&mc_genmcl_px_div,
(u64)&mc_genmcl_px_eval,
(u64)&mc_genmcl_px_widen,
(u64)&mc_genmcl_px_jump,
(u64)&mc_genmcl_px_ijump,
(u64)&mc_genmcl_px_neg,
(u64)&mc_genmcl_px_abs,
(u64)&mc_genmcl_px_bitnot,
(u64)&mc_genmcl_px_not,
(u64)&mc_genmcl_px_toboolt,
(u64)&mc_genmcl_px_sqr,
(u64)&mc_genmcl_px_sqrt,
(u64)&mc_genmcl_px_jumpcc,
(u64)&mc_genmcl_px_jumpt,
(u64)&mc_genmcl_px_jumpf,
(u64)&mc_genmcl_px_bitand,
(u64)&mc_genmcl_px_bitor,
(u64)&mc_genmcl_px_bitxor,
(u64)&mc_genmcl_px_shl,
(u64)&mc_genmcl_px_shr,
(u64)&mc_genmcl_px_retproc,
(u64)&mc_genmcl_px_retfn,
(u64)&mc_genmcl_px_setcall,
(u64)&mc_genmcl_px_setarg,
(u64)&mc_genmcl_px_callp,
(u64)&mc_genmcl_px_jumpret,
(u64)&mc_genmcl_px_jumpretm,
(u64)&mc_genmcl_px_startmx,
(u64)&mc_genmcl_px_resetmx,
(u64)&mc_genmcl_px_stop,
(u64)&mc_genmcl_px_incrto,
(u64)&mc_genmcl_px_decrto,
(u64)&mc_genmcl_px_incrload,
(u64)&mc_genmcl_px_decrload,
(u64)&mc_genmcl_px_loadincr,
(u64)&mc_genmcl_px_loaddecr,
(u64)&mc_genmcl_px_forup,
(u64)&mc_genmcl_px_fordown,
(u64)&mc_genmcl_px_iload,
(u64)&mc_genmcl_px_iloadx,
(u64)&mc_genmcl_px_istore,
(u64)&mc_genmcl_px_istorex,
(u64)&mc_genmcl_px_storem,
(u64)&mc_genmcl_px_addpx,
(u64)&mc_genmcl_px_subpx,
(u64)&mc_genmcl_px_to,
(u64)&mc_genmcl_px_iswap,
(u64)&mc_genmcl_px_swapstk,
(u64)&mc_genmcl_px_labeldef,
(u64)&mc_genmcl_px_addto,
(u64)&mc_genmcl_px_subto,
(u64)&mc_genmcl_px_multo,
(u64)&mc_genmcl_px_bitandto,
(u64)&mc_genmcl_px_bitorto,
(u64)&mc_genmcl_px_bitxorto,
(u64)&mc_genmcl_px_shlto,
(u64)&mc_genmcl_px_shrto,
(u64)&mc_genmcl_px_fix,
(u64)&mc_genmcl_px_float,
(u64)&mc_genmcl_px_idiv,
(u64)&mc_genmcl_px_irem,
(u64)&mc_genmcl_px_idivrem,
(u64)&mc_genmcl_px_clear,
(u64)&mc_genmcl_px_subp,
(u64)&mc_genmcl_px_switch,
(u64)&mc_genmcl_px_switchu,
(u64)&mc_genmcl_px_swlabel,
(u64)&mc_genmcl_px_endsw,
(u64)&mc_genmcl_px_fwiden,
(u64)&mc_genmcl_px_fnarrow,
(u64)&mc_genmcl_px_truncate,
(u64)&mc_genmcl_px_typepun,
(u64)&mc_genmcl_px_unload,
(u64)&mc_genmcl_px_loadbit,
(u64)&mc_genmcl_px_assem,
(u64)&mc_genmcl_px_sin,
(u64)&mc_genmcl_px_cos,
(u64)&mc_genmcl_px_tan,
(u64)&mc_genmcl_px_asin,
(u64)&mc_genmcl_px_acos,
(u64)&mc_genmcl_px_atan,
(u64)&mc_genmcl_px_log,
(u64)&mc_genmcl_px_log10,
(u64)&mc_genmcl_px_exp,
(u64)&mc_genmcl_px_round,
(u64)&mc_genmcl_px_floor,
(u64)&mc_genmcl_px_ceil,
(u64)&mc_genmcl_px_atan2,
(u64)&mc_genmcl_px_fmod,
(u64)&mc_genmcl_px_setcc,
(u64)&mc_genmcl_px_min,
(u64)&mc_genmcl_px_max,
(u64)&mc_genmcl_px_power,
(u64)&mc_genmcl_px_minto,
(u64)&mc_genmcl_px_maxto,
(u64)&mc_genmcl_px_negto,
(u64)&mc_genmcl_px_absto,
(u64)&mc_genmcl_px_addpxto,
(u64)&mc_genmcl_px_subpxto,
(u64)&mc_genmcl_px_divto,
(u64)&mc_genmcl_px_bitnotto,
(u64)&mc_genmcl_px_notto,
(u64)&mc_genmcl_px_toboolto,
(u64)&mc_genmcl_px_sign,
(u64)&mc_genmcl_px_loadbf,
(u64)&mc_genmcl_px_storebit,
(u64)&mc_genmcl_px_storebf,
(u64)&mc_genmcl_px_loadall,
(u64)&mc_genmcl_px_setjmp,
(u64)&mc_genmcl_px_longjmp,
(u64)&mc_genmcl_px_initdswx,
(u64)&mc_auxmcl_do_addrmode}};

static struct $B88 $procname = {{
(u64)"px_nop",
(u64)"px_dupl",
(u64)"px_double",
(u64)"px_opnd",
(u64)"px_type",
(u64)"px_comment",
(u64)"px_proc",
(u64)"px_endproc",
(u64)"px_endprog",
(u64)"px_istatic",
(u64)"px_zstatic",
(u64)"px_data",
(u64)"px_label",
(u64)"px_load",
(u64)"px_store",
(u64)"px_add",
(u64)"px_sub",
(u64)"px_mul",
(u64)"px_div",
(u64)"px_eval",
(u64)"px_widen",
(u64)"px_jump",
(u64)"px_ijump",
(u64)"px_neg",
(u64)"px_abs",
(u64)"px_bitnot",
(u64)"px_not",
(u64)"px_toboolt",
(u64)"px_sqr",
(u64)"px_sqrt",
(u64)"px_jumpcc",
(u64)"px_jumpt",
(u64)"px_jumpf",
(u64)"px_bitand",
(u64)"px_bitor",
(u64)"px_bitxor",
(u64)"px_shl",
(u64)"px_shr",
(u64)"px_retproc",
(u64)"px_retfn",
(u64)"px_setcall",
(u64)"px_setarg",
(u64)"px_callp",
(u64)"px_jumpret",
(u64)"px_jumpretm",
(u64)"px_startmx",
(u64)"px_resetmx",
(u64)"px_stop",
(u64)"px_incrto",
(u64)"px_decrto",
(u64)"px_incrload",
(u64)"px_decrload",
(u64)"px_loadincr",
(u64)"px_loaddecr",
(u64)"px_forup",
(u64)"px_fordown",
(u64)"px_iload",
(u64)"px_iloadx",
(u64)"px_istore",
(u64)"px_istorex",
(u64)"px_storem",
(u64)"px_addpx",
(u64)"px_subpx",
(u64)"px_to",
(u64)"px_iswap",
(u64)"px_swapstk",
(u64)"px_labeldef",
(u64)"px_addto",
(u64)"px_subto",
(u64)"px_multo",
(u64)"px_bitandto",
(u64)"px_bitorto",
(u64)"px_bitxorto",
(u64)"px_shlto",
(u64)"px_shrto",
(u64)"px_fix",
(u64)"px_float",
(u64)"px_idiv",
(u64)"px_irem",
(u64)"px_idivrem",
(u64)"px_clear",
(u64)"px_subp",
(u64)"px_switch",
(u64)"px_switchu",
(u64)"px_swlabel",
(u64)"px_endsw",
(u64)"px_fwiden",
(u64)"px_fnarrow",
(u64)"px_truncate",
(u64)"px_typepun",
(u64)"px_unload",
(u64)"px_loadbit",
(u64)"px_assem",
(u64)"px_sin",
(u64)"px_cos",
(u64)"px_tan",
(u64)"px_asin",
(u64)"px_acos",
(u64)"px_atan",
(u64)"px_log",
(u64)"px_log10",
(u64)"px_exp",
(u64)"px_round",
(u64)"px_floor",
(u64)"px_ceil",
(u64)"px_atan2",
(u64)"px_fmod",
(u64)"px_setcc",
(u64)"px_min",
(u64)"px_max",
(u64)"px_power",
(u64)"px_minto",
(u64)"px_maxto",
(u64)"px_negto",
(u64)"px_absto",
(u64)"px_addpxto",
(u64)"px_subpxto",
(u64)"px_divto",
(u64)"px_bitnotto",
(u64)"px_notto",
(u64)"px_toboolto",
(u64)"px_sign",
(u64)"px_loadbf",
(u64)"px_storebit",
(u64)"px_storebf",
(u64)"px_loadall",
(u64)"px_setjmp",
(u64)"px_longjmp",
(u64)"px_initdswx",
(u64)"do_addrmode"}};

static i64 $nprocs = 130;

// ***** PCL Support Library *****

i64 Getdotindex(u64 a, int i) {
	return (a & (1LL<<i))>>i;
}

u64 Setdotindex(u64 a, i64 i, i64 x) {
	return (a & ~(1LL<<i)) | ((u64)(x)<<i);
}

i64 Getdotslice(u64 a, i64 i, i64 j) {
	if (i>=j)
		return (a>>j) & ~(0xFFFFFFFFFFFFFFFF<<(i-j+1));
	else
		return (a>>i) & ~(0xFFFFFFFFFFFFFFFF<<(j-i+1));
}

u64 Setdotslice(u64 a, i64 i, i64 j, u64 x) {
	u64 mask64;
	if (i>j) {i64 t=i; i=j; j=t;}

	mask64=~((0xFFFFFFFFFFFFFFFF<<(j-i+1)))<<i;
	return (a & ~mask64) ^ (x<<i);
}

i64 Poweri64(i64 a, i64 n) {
	if (n<0)
		return 0;
	else if (n==0)
		return 1;
	else if ((n&1)==0)
		return Poweri64(a*a, n/2);
	else
		return Poweri64(a*a, (n-1)/2)*a;
}

// End of C Code

