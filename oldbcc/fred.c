/* MCC Experimental C Compiler

   Early upload that translates one .c source file to .asm64 output file

   Compile mcc64.c as a 64-bit C program, or mcc32.c (when uploaded)
   as a 32-bit one. Examples:

   gcc -m64 -O3 mcc64.c -omcc.exe             # Windows
   gcc -m64 -O3 mcc64.c -omcc -lm             # Linux

   Under Windows, it should compile with no warnings. Under Linux, or with
   warning levels increased, there will be a few more.

   (I haven't yet managed to incorporate the changes suggested by Tim on
   comp.lang.c to reduce the number of warnings.)

   Run the compiler as follows:

        mcc hello                             # compile hello.c to hello.asm64
        mcc -help                             # show options

   The compiler is incomplete, has many omissions, and will have bugs.
   It is also Part I of the project. Part II was intended to compile all modules
   of a project and to link and run them in-memory.

   Any comments to bart4858@gmail.com.
*/

/* Generated by M compiler in 'one-file' format then collated*/
/* Target: C64 */
/* Target OS: 'None */

#include <stdint.h>
#if INTPTR_MAX < 50000000000
	#error "Must be compiled for 64 bits"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

#pragma pack(1)

typedef int8_t int8;
typedef int16_t int16;
typedef int32_t int32;
typedef int64_t int64;

typedef uint8_t uint8;
typedef uint16_t uint16;
typedef uint32_t uint32;
typedef uint64_t uint64;

typedef unsigned char byte;
typedef unsigned char uchar;
typedef char* ichar;

#ifdef __GNUC__
#define gcc_callback __attribute__ ((force_align_arg_pointer))
#else
#define gcc_callback
#endif

int64 m_imin(int64,int64);
int64 m_imax(int64,int64);
uint64 m_min(uint64,uint64);
uint64 m_max(uint64,uint64);

// From module: mm_clib
/* Named Constants */
enum {c_eof = -1};
enum {seek_set = 0};
enum {seek_curr = 1};
enum {seek_end = 2};

// From module: mm_mainc
/* Named Constants */
enum {maxparam = 32};

// From module: mm_mlib
/* Named Constants */
enum {mem_check = 0};
enum {threshold = 33554432};
enum {alloc_step = 33554432};
enum {maxmemalloc = 100000};
enum {pcheapsize = 2097152};
enum {maxblockindex = 8};
enum {maxblocksize = 2048};
enum {size16 = 1};
enum {size32 = 2};
enum {size64 = 3};
enum {size128 = 4};
enum {size256 = 5};
enum {size512 = 6};
enum {size1024 = 7};
enum {size2048 = 8};

// From module: mm_nos

// From module: cc_tables
/* Named Constants */
enum {tnone = 0};
enum {tvoid = 1};
enum {tschar = 2};
enum {tsshort = 3};
enum {tsint = 4};
enum {tsllong = 5};
enum {tbool = 6};
enum {tuchar = 7};
enum {tushort = 8};
enum {tuint = 9};
enum {tullong = 10};
enum {tfloat = 11};
enum {tdouble = 12};
enum {tldouble = 13};
enum {tcomplex = 14};
enum {tenum = 15};
enum {tref = 16};
enum {tproc = 17};
enum {tlabel = 18};
enum {tarray = 19};
enum {tstruct = 20};
enum {tunion = 21};
enum {tlast = 22};
enum {tfirstnum = tschar};
enum {tlastnum = tldouble};
enum {tfirstint = tschar};
enum {tlastint = tullong};
enum {tfirstreal = tfloat};
enum {tlastreal = tldouble};
enum {tptroffset = tsllong};
enum {ts_void = 1};
enum {ts_char = 2};
enum {ts_short = 3};
enum {ts_long = 4};
enum {ts_int = 5};
enum {ts_float = 6};
enum {ts_double = 7};
enum {ts_signed = 8};
enum {ts_unsigned = 9};
enum {ts_bool = 10};
enum {ts_complex = 11};
enum {ts_user = 12};
enum {ts_struct = 13};
enum {ts_union = 14};
enum {ts_enum = 15};
enum {ts_atomic = 16};
enum {pm_normal = 0};
enum {pm_notset = 1};
enum {pm_empty = 2};
enum {pm_variadic = 3};
enum {no_scope = 0};
enum {function_scope = 1};
enum {local_scope = 2};
enum {imported_scope = 3};
enum {exported_scope = 4};
enum {open_cc = 0};
enum {own_cc = 1};
enum {clang_cc = 2};
enum {stdcall_cc = 3};
enum {callback_cc = 4};
enum {dummy_cc = 5};
enum {none_ss = 0};
enum {static_ss = 1};
enum {auto_ss = 2};
enum {register_ss = 3};
enum {extern_ss = 4};
enum {typedef_ss = 5};
enum {const_qual = 1};
enum {volatile_qual = 2};
enum {restrict_qual = 3};
enum {atomic_qual = 4};
enum {inline_fnspec = 1};
enum {noreturn_fnspec = 2};
enum {pdm_date = 1};
enum {pdm_time = 2};
enum {pdm_file = 3};
enum {pdm_line = 4};
enum {pdm_cdecl = 5};
enum {pdm_mcc = 6};
enum {pdm_stdc = 7};
enum {j_none = 0};
enum {j_const = 1};
enum {j_null = 2};
enum {j_name = 3};
enum {j_nameaddr = 4};
enum {j_widenmem = 5};
enum {j_funcname = 6};
enum {j_block = 7};
enum {j_tempdecl = 8};
enum {j_decl = 9};
enum {j_callproc = 10};
enum {j_return = 11};
enum {j_returnx = 12};
enum {j_assign = 13};
enum {j_if = 14};
enum {j_for = 15};
enum {j_while = 16};
enum {j_dowhile = 17};
enum {j_goto = 18};
enum {j_labelstmt = 19};
enum {j_casestmt = 20};
enum {j_defaultstmt = 21};
enum {j_break = 22};
enum {j_continue = 23};
enum {j_switch = 24};
enum {j_breaksw = 25};
enum {j_andl = 26};
enum {j_orl = 27};
enum {j_notl = 28};
enum {j_istruel = 29};
enum {j_makelist = 30};
enum {j_exprlist = 31};
enum {j_callfn = 32};
enum {j_ifx = 33};
enum {j_andand = 34};
enum {j_eq = 35};
enum {j_ne = 36};
enum {j_lt = 37};
enum {j_le = 38};
enum {j_gt = 39};
enum {j_ge = 40};
enum {j_add = 41};
enum {j_sub = 42};
enum {j_mul = 43};
enum {j_div = 44};
enum {j_rem = 45};
enum {j_iand = 46};
enum {j_ior = 47};
enum {j_ixor = 48};
enum {j_shl = 49};
enum {j_shr = 50};
enum {j_dot = 51};
enum {j_idot = 52};
enum {j_dotref = 53};
enum {j_index = 54};
enum {j_deref = 55};
enum {j_derefoffset = 56};
enum {j_addoffset = 57};
enum {j_convert = 58};
enum {j_scale = 59};
enum {j_neg = 60};
enum {j_abs = 61};
enum {j_inot = 62};
enum {j_preincrx = 63};
enum {j_predecrx = 64};
enum {j_postincrx = 65};
enum {j_postdecrx = 66};
enum {j_addto = 67};
enum {j_subto = 68};
enum {j_multo = 69};
enum {j_divto = 70};
enum {j_remto = 71};
enum {j_iandto = 72};
enum {j_iorto = 73};
enum {j_ixorto = 74};
enum {j_shlto = 75};
enum {j_shrto = 76};
enum {j_preincr = 77};
enum {j_predecr = 78};
enum {j_postincr = 79};
enum {j_postdecr = 80};
enum {j_dummy = 81};
enum {errorsym = 1};
enum {dotsym = 2};
enum {idotsym = 3};
enum {lexhashsym = 4};
enum {hashsym = 5};
enum {lithashsym = 6};
enum {hashhashsym = 7};
enum {commasym = 8};
enum {semisym = 9};
enum {colonsym = 10};
enum {assignsym = 11};
enum {lbracksym = 12};
enum {rbracksym = 13};
enum {lsqsym = 14};
enum {rsqsym = 15};
enum {lcurlysym = 16};
enum {rcurlysym = 17};
enum {questionsym = 18};
enum {curlsym = 19};
enum {ellipsissym = 20};
enum {addsym = 21};
enum {subsym = 22};
enum {mulsym = 23};
enum {divsym = 24};
enum {remsym = 25};
enum {iorsym = 26};
enum {iandsym = 27};
enum {ixorsym = 28};
enum {orlsym = 29};
enum {andlsym = 30};
enum {shlsym = 31};
enum {shrsym = 32};
enum {inotsym = 33};
enum {notlsym = 34};
enum {incrsym = 35};
enum {decrsym = 36};
enum {abssym = 37};
enum {eqsym = 38};
enum {nesym = 39};
enum {ltsym = 40};
enum {lesym = 41};
enum {gesym = 42};
enum {gtsym = 43};
enum {addtosym = 44};
enum {subtosym = 45};
enum {multosym = 46};
enum {divtosym = 47};
enum {remtosym = 48};
enum {iortosym = 49};
enum {iandtosym = 50};
enum {ixortosym = 51};
enum {shltosym = 52};
enum {shrtosym = 53};
enum {eolsym = 54};
enum {eofsym = 55};
enum {rawnumbersym = 56};
enum {intconstsym = 57};
enum {realconstsym = 58};
enum {charconstsym = 59};
enum {wcharconstsym = 60};
enum {stringconstsym = 61};
enum {wstringconstsym = 62};
enum {whitespacesym = 63};
enum {placeholdersym = 64};
enum {namesym = 65};
enum {ksourcedirsym = 66};
enum {predefmacrosym = 67};
enum {ktypespecsym = 68};
enum {kifsym = 69};
enum {kelsesym = 70};
enum {kcasesym = 71};
enum {kdefaultsym = 72};
enum {kforsym = 73};
enum {kwhilesym = 74};
enum {kdosym = 75};
enum {kreturnsym = 76};
enum {kbreaksym = 77};
enum {kcontinuesym = 78};
enum {kgotosym = 79};
enum {kswitchsym = 80};
enum {kstructsym = 81};
enum {kunionsym = 82};
enum {klinkagesym = 83};
enum {ktypequalsym = 84};
enum {kfnspecsym = 85};
enum {kalignassym = 86};
enum {kenumsym = 87};
enum {kcallconvsym = 88};
enum {ksizeofsym = 89};
enum {kdefinedsym = 90};
enum {kgenericsym = 91};
enum {kalignofsym = 92};
enum {kshowmodesym = 93};
enum {kshowtypesym = 94};
enum {ktypeofsym = 95};
enum {kstrtypesym = 96};
enum {kmccassertsym = 97};
enum {kdummysym = 98};
enum {definedir = 1};
enum {emitdir = 2};
enum {ifdir = 3};
enum {elifdir = 4};
enum {elsedir = 5};
enum {endifdir = 6};
enum {includedir = 7};
enum {ifdefdir = 8};
enum {ifndefdir = 9};
enum {undefdir = 10};
enum {errordir = 11};
enum {warningdir = 12};
enum {messagedir = 13};
enum {pausedir = 14};
enum {debugondir = 15};
enum {debugoffdir = 16};
enum {showmacrodir = 17};
enum {blankdir = 18};
enum {linedir = 19};
enum {pragmadir = 20};
enum {ns_none = 1};
enum {ns_general = 2};
enum {ns_tags = 3};
enum {ns_labels = 4};
enum {ns_fields = 5};
enum {nullid = 0};
enum {macroid = 1};
enum {programid = 2};
enum {moduleid = 3};
enum {extmoduleid = 4};
enum {typeid = 5};
enum {procid = 6};
enum {staticid = 7};
enum {frameid = 8};
enum {paramid = 9};
enum {fieldid = 10};
enum {enumid = 11};
enum {enumtagid = 12};
enum {structtagid = 13};
enum {labelid = 14};
enum {no_conv = 0};
enum {soft_c = 1};
enum {hard_c = 2};
enum {swiden_c = 3};
enum {uwiden_c = 4};
enum {sfloat_c = 5};
enum {ufloat_c = 6};
enum {sfix_c = 7};
enum {ufix_c = 8};
enum {fwiden_c = 9};
enum {fnarrow_c = 10};
enum {narrow_c = 11};
enum {truncate_c = 12};
enum {bool_c = 13};

// From module: cc_decls
/* Named Constants */
enum {maxmodule = 50};
enum {maxlibfile = 50};
enum {maxsourcefile = 600};
enum {tk_macromask = 1};
enum {tk_parammask = 2};
enum {tk_macrolit = 4};
enum {tk_pasted = 8};
enum {maxtype = 25000};
enum {maxsearchdirs = 20};
enum {maxincludepaths = 20};
enum {maxdlllib = 50};
enum {maxdllproc = 500};
enum {maxcmdparam = 32};
enum {hstsize = 65536};
enum {hstmask = 65535};
enum {maxblock = 2100};
enum {maxblockstack = 100};
enum {maxnestedloops = 100};

// From module: cc_support

// From module: cc_headers

// From module: cc_lex
/* Named Constants */
enum {doinclude = 1};
enum {domacros = 1};
enum {maxmacroargs = 20};
enum {maxnesting = 20};
enum {cr = 13};
enum {lf = 10};
enum {tab = 9};
enum {maxpastedtokens = 3500};

// From module: cc_lib
/* Named Constants */
enum {unitheapsize = 50000};

// From module: cc_parse
/* Named Constants */
enum {maxtypemods = 20};

// From module: cc_libtcl
/* Named Constants */
enum {ptrsize = 8};
enum {t_comment = 1};
enum {t_blank = 2};
enum {t_source = 3};
enum {t_end = 4};
enum {t_tempdata = 5};
enum {t_setret = 6};
enum {t_stmt = 7};
enum {t_assem = 8};
enum {t_param = 9};
enum {t_eval = 10};
enum {t_move = 11};
enum {t_copylist = 12};
enum {t_copyblock = 13};
enum {t_clearblock = 14};
enum {t_getptr = 15};
enum {t_index = 16};
enum {t_indexlv = 17};
enum {t_indexref = 18};
enum {t_getaddr = 19};
enum {t_label = 20};
enum {t_jumplabel = 21};
enum {t_labelname = 22};
enum {t_switch = 23};
enum {t_jump = 24};
enum {t_jumpcc = 25};
enum {t_jumptrue = 26};
enum {t_jumpfalse = 27};
enum {t_decrjumpnz = 28};
enum {t_setcc = 29};
enum {t_andl = 30};
enum {t_orl = 31};
enum {t_notl = 32};
enum {t_istruel = 33};
enum {t_makelist = 34};
enum {t_callfn = 35};
enum {t_callproc = 36};
enum {t_return = 37};
enum {t_returnx = 38};
enum {t_hardret = 39};
enum {t_add = 40};
enum {t_sub = 41};
enum {t_mul = 42};
enum {t_div = 43};
enum {t_rem = 44};
enum {t_iand = 45};
enum {t_ior = 46};
enum {t_ixor = 47};
enum {t_shl = 48};
enum {t_shr = 49};
enum {t_neg = 50};
enum {t_abs = 51};
enum {t_inot = 52};
enum {t_addto = 53};
enum {t_subto = 54};
enum {t_multo = 55};
enum {t_divto = 56};
enum {t_remto = 57};
enum {t_iorto = 58};
enum {t_iandto = 59};
enum {t_ixorto = 60};
enum {t_shlto = 61};
enum {t_shrto = 62};
enum {t_incrto = 63};
enum {t_decrto = 64};
enum {t_preincrx = 65};
enum {t_predecrx = 66};
enum {t_postincrx = 67};
enum {t_postdecrx = 68};
enum {t_softconv = 69};
enum {t_float = 70};
enum {t_fix = 71};
enum {t_truncate = 72};
enum {t_widen = 73};
enum {t_fwiden = 74};
enum {t_narrow = 75};
enum {t_fnarrow = 76};
enum {t_convert = 77};
enum {t_typepun = 78};
enum {t_last = 79};
enum {no_opnd = 0};
enum {mem_opnd = 1};
enum {temp_opnd = 2};
enum {int_opnd = 3};
enum {real_opnd = 4};
enum {string_opnd = 5};
enum {regvar_opnd = 6};
enum {imem_opnd = 7};
enum {itemp_opnd = 8};
enum {label_opnd = 9};
enum {ptr_opnd = 10};
enum {memaddr_opnd = 11};
enum {tempaddr_opnd = 12};
enum {no_type = 0};
enum {signed_type = 1};
enum {unsigned_type = 2};
enum {float_type = 3};
enum {pointer_type = 4};
enum {block_type = 5};
enum {maxopnd = 1000};
enum {maxtemp = 2000};

// From module: cc_genasm
/* Named Constants */
enum {fshowline = 0};
enum {rnone = 0};
enum {r0 = 1};
enum {r1 = 2};
enum {r2 = 3};
enum {r3 = 4};
enum {r4 = 5};
enum {r5 = 6};
enum {r6 = 7};
enum {r7 = 8};
enum {r8 = 9};
enum {r9 = 10};
enum {r10 = 11};
enum {r11 = 12};
enum {r12 = 13};
enum {r13 = 14};
enum {r14 = 15};
enum {rstack = 16};
enum {rcx = r10};
enum {rdx = r11};
enum {rframe = r14};
enum {r15 = rstack};
enum {xnone = 0};
enum {xr0 = 1};
enum {xr1 = 2};
enum {xr2 = 3};
enum {xr3 = 4};
enum {xr4 = 5};
enum {xr5 = 6};
enum {xr6 = 7};
enum {xr7 = 8};
enum {xr8 = 9};
enum {xr9 = 10};
enum {xr10 = 11};
enum {xr11 = 12};
enum {xr12 = 13};
enum {xr13 = 14};
enum {xr14 = 15};
enum {xr15 = 16};
enum {maxstringtable = 5000};
enum {maxrealtable = 2000};
enum {maxparam_asm = 100};

// From module: cc_gentcl
/* Named Constants */
enum {tintptr = tullong};
enum {targetsize = 8};
enum {kjumpt = 1};
enum {kjumpf = 0};
enum {maxparams = 100};
enum {maxswitchrange = 500};
enum {maxcases = maxswitchrange};
enum {maxswitchdepth = 20};

// From module: cc_start
/* Named Constants */
enum {mload = 1};
enum {mpreprocess = 2};
enum {mparse = 4};
enum {mgen1 = 8};
enum {mgen2 = 16};
enum {mlink = 32};
enum {mrun = 64};
enum {pm_end = 0};
enum {pm_option = 1};
enum {pm_sourcefile = 2};
enum {pm_libfile = 3};
enum {load_sw = 1};
enum {preprocess_sw = 2};
enum {parse_sw = 3};
enum {gen1_sw = 4};
enum {gen2_sw = 5};
enum {link_sw = 6};
enum {run_sw = 7};
enum {asm_sw = 8};
enum {bin_sw = 9};
enum {options_sw = 10};
enum {modules_sw = 11};
enum {files_sw = 12};
enum {e_sw = 13};
enum {ast_sw = 14};
enum {st_sw = 15};
enum {stflat_sw = 16};
enum {dis_sw = 17};
enum {paths_sw = 18};
enum {headers_sw = 19};
enum {types_sw = 20};
enum {tcl_sw = 21};
enum {showasm_sw = 22};
enum {compile_sw = 23};
enum {s_sw = 24};
enum {d_sw = 25};
enum {inclpath_sw = 26};
enum {time_sw = 27};
enum {v_sw = 28};
enum {v2_sw = 29};
enum {quiet_sw = 30};
enum {help_sw = 31};
enum {help2_sw = 32};
enum {ext_sw = 33};
enum {writeheaders_sw = 34};

// From module: mm_clib

// From module: mm_mainc

// From module: mm_mlib

// From module: mm_nos
/* Struct Definitions */

typedef struct _rec {
    char *	name;
    void *	addr;
} rec;


// From module: cc_tables

// From module: cc_decls
/* Struct Definitions */
typedef struct _caserec caserec;
typedef struct _fieldrec fieldrec;
typedef struct _mparamrec mparamrec;
typedef struct _paramrec paramrec;
typedef struct _attribrec attribrec;
typedef struct _tokenrec tokenrec;
typedef struct _strec strec;
typedef struct _unitrec unitrec;

struct _caserec {
    struct _caserec* nextcase;
    int32	value;
};

struct _fieldrec {
    strec *	def;
    strec *	gendef;
    struct _fieldrec* nextfield;
    int32	offset;
};

struct _mparamrec {
    strec *	def;
    struct _mparamrec* nextmparam;
};

struct _paramrec {
    strec *	def;
    struct _paramrec* nextparam;
    int32	mode;
    int16	nparams;
    int16	flags;
};

struct _attribrec {
    byte	ax_static;
    byte	ax_equals;
    byte	ax_varparams;
    byte	ax_used;
    byte	ax_forward;
    byte	ax_frame;
    byte	ax_autovar;
    byte	ax_nparams;
    byte	ax_callback;
    byte	ax_moduleno;
    byte	ax_spare;
    union {
        byte	ax_align;
        byte	ax_dllindex;
        byte	ax_extmodno;
        byte	ax_flmacro;
    };
};

struct _tokenrec {
    union {
        int64	value;
        double	xvalue;
        uint64	uvalue;
        byte *	svalue;
        strec *	symptr;
    };
    struct _tokenrec* nexttoken;
    union {
        struct {
            byte	subcode;
            byte	flags;
        };
        uint16	subcodex;
    };
    byte	symbol;
    byte	fileno;
    int32	lineno;
    int32	length;
    union {
        int32	numberoffset;
        int32	paramno;
        int32	pasteno;
    };
};

struct _strec {
    char *	name;
    struct _strec* owner;
    struct _strec* deflist;
    struct _strec* deflistx;
    struct _strec* nextdef;
    struct _strec* nextdupl;
    struct _strec* prevdupl;
    union {
        void *	tclcode;
        void *	opnd;
    };
    union {
        paramrec *	nextparam;
        unitrec *	callchain;
        struct _strec* nextmacro;
        fieldrec *	nextfield;
    };
    union {
        unitrec *	code;
        tokenrec *	tokenlist;
    };
    union {
        paramrec *	paramlist;
        mparamrec *	mparamlist;
        char *	macrovalue;
    };
    union {
        void *	address;
        int32	offset;
        byte	oldsymbol;
    };
    int32	lineno;
    int32	index;
    union {
        struct {
            uint16	blockno;
            uint16	namespace;
        };
        uint32	nsblock;
    };
    int16	subcode;
    int16	mode;
    byte	namelen;
    byte	symbol;
    byte	nameid;
    byte	scope;
    attribrec	attribs;
};

struct _unitrec {
    union {
        strec *	def;
        int64	value;
        uint64	uvalue;
        double	xvalue;
        char *	svalue;
        strec *	labeldef;
        caserec *	nextcase;
        int32	ptrscale;
    };
    struct _unitrec* nextunit;
    struct _unitrec* a;
    struct _unitrec* b;
    struct _unitrec* c;
    int32	tag;
    int32	lineno;
    union {
        int32	opcode;
        int32	index;
        int32	slength;
        int32	alength;
        int32	scale;
        int32	aparams;
        int32	count;
    };
    int32	mode;
    byte	simple;
    byte	fileno;
    union {
        byte	callconv;
        byte	convmem;
        byte	isstrconst;
    };
    union {
        byte	strarray;
        byte	convtomem;
    };
    uint16	spare4;
};

typedef struct _modulerec {
    char *	name;
    strec *	stmodule;
    int32	fileno;
    char *	asmstr;
    byte	importmap[50];
} modulerec;

typedef struct _dllprocrec {
    char *	name;
    void (*address)	(void);
    int32	dllindex;
} dllprocrec;

typedef struct _procrec {
    strec *	def;
    struct _procrec* nextproc;
} procrec;

typedef struct _strbuffer {
    char *	strptr;
    int32	length;
    int32	allocated;
} strbuffer;


// From module: cc_support

// From module: cc_headers

// From module: cc_lex
/* Struct Definitions */

typedef struct _stackinforec {
    byte *	startptr;
    byte *	sptr;
    int32	lineno;
    int32	fileno;
} stackinforec;


// From module: cc_lib

// From module: cc_parse
/* Struct Definitions */

typedef struct _declrec {
    int32	typeno;
    byte	isconst;
    byte	isvolatile;
    byte	isrestrict;
    byte	linkage;
    byte	isinline;
    byte	isshort;
    byte	islong;
    byte	isllong;
    byte	issigned;
    byte	isunsigned;
    byte	isusertype;
} declrec;


// From module: cc_libtcl
/* Struct Definitions */

typedef struct _opndrec {
    union {
        strec *	def;
        int64	value;
        double	xvalue;
        uint64	uvalue;
        char *	svalue;
        int32	tempno;
        int32	labelno;
        int32	regno;
        byte (*tempsizes)[];
        byte (*temptypes)[];
    };
    byte	fmt;
    byte	typecode;
    union {
        uint16	slength;
        int16	offset;
    };
    int32	size;
} opndrec;

typedef struct _tclrec {
    opndrec	a;
    opndrec	b;
    opndrec	c;
    struct _tclrec* nexttcl;
    int32	lineno;
    byte	opcode;
    union {
        uint16	cond;
        uint16	paramno;
        uint16	scale;
        uint16	index;
        uint16	ntemps;
        uint16	nlabels;
        uint16	isvariadic;
    };
    byte	spare;
} tclrec;


// From module: cc_genasm

// From module: cc_gentcl

// From module: cc_start
/* Imported Functions */
extern void	start	(void);


// From module: mm_clib

// From module: mm_mainc
/* Local Function Prototypes */
       int32	main	(int32,char * *);
       uint64	m_dotslice	(uint64,int32,int32);
       uint64	m_anddotslice	(uint64,int32,int32);
       int64	m_imin	(int64,int64);
       int64	m_imax	(int64,int64);
       uint64	m_min	(uint64,uint64);
       uint64	m_max	(uint64,uint64);

// From module: mm_mlib
/* Local Function Prototypes */
       void *	pcm_alloc	(int32);
       void	pcm_free	(void *,int32);
       void	pcm_freeac	(void *,int32);
       void	pcm_copymem4	(void *,void *,int32);
       void	pcm_clearmem	(void *,int32);
       void	pcm_init	(void);
       int32	pcm_getac	(int32);
       uint32 *	pcm_newblock	(int32);
       int32	pcm_round	(int32);
       int32	pcm_array	(int32);
       void	pcm_printfreelist	(int32,uint32 *);
       void	pcm_diags	(char *);
       void *	pcm_allocz	(int32);
       char *	pcm_copyheapstring	(char *);
static void	addtomemalloc	(int32 *,int32);
static void	removefrommemalloc	(int32 *,int32);
       void *	allocmem	(int32);
       void *	reallocmem	(void *,int32);
       void	abortprogram	(char *);
       int32	getfilesize	(void *);
       void	readrandom	(void *,byte *,int32,int32);
       void	writerandom	(void *,byte *,int32,int32);
       byte *	readfile	(char *);
       int32	writefile	(char *,byte *,int32);
       int32	checkfile	(char *);
       void	readlinen	(void *,char *,int32);
       void	iconvlcn	(char *,int32);
       void	iconvucn	(char *,int32);
       void	convlcstring	(char *);
       void	convucstring	(char *);
       char *	changeext	(char *,char *);
       char *	extractext	(char *,int32);
       char *	extractpath	(char *);
       char *	extractfile	(char *);
       char *	extractbasefile	(char *);
       char *	addext	(char *,char *);
       void *	alloctable	(int32,int32);
       void *	zalloctable	(int32,int32);
       void	checkfreelists	(char *);
       void *	pcm_alloc32	(void);
       void	pcm_free32	(void *);
       void	outbyte	(void *,int32);
       void	outword16	(void *,uint32);
       void	outword	(void *,uint32);
       void	outdword	(void *,uint64);
       int32	myeof	(void *);
       void *	pcm_smallallocz	(int32);
       void *	pcm_fastalloc	(int32);

// From module: mm_nos
/* Local Function Prototypes */
       void	os_init	(void);
       int32	os_execwait	(char *,int32,char *);
       int32	os_execcmd	(char *,int32);
       int32	os_getch	(void);
       int32	os_kbhit	(void);
       void	os_flushkeys	(void);
       void *	os_getconsolein	(void);
       void *	os_getconsoleout	(void);
       void *	os_proginstance	(void);
       uint64	os_getdllinst	(char *);
       void (*os_getdllprocaddr	(int64,char *))	(void);
       void	os_initwindows	(void);
       int32	os_getchx	(void);
       char *	os_getos	(void);
       int32	os_getoscode	(void);
       int32	os_iswindows	(void);
       int32	os_shellexec	(char *,char *);
       void	os_sleep	(int32);
       void *	os_getstdin	(void);
       void *	os_getstdout	(void);
       char *	os_gethostname	(void);
       int32	os_gethostsize	(void);
       char *	os_getmpath	(void);
       void	os_exitprocess	(int32);
       int64	os_gettimestamp	(void);
       int64	os_gettickcount	(void);
       int64	os_clock	(void);
       int64	os_getclockspersec	(void);
       void	os_setmesshandler	(void *);
       int64	os_filelastwritetime	(char *);

// From module: cc_tables

// From module: cc_decls

// From module: cc_support
/* Local Function Prototypes */
       void	mcerror	(char *);
       void	serror	(char *);
       void	serror_gen	(char *);
       void	serror_ss	(char *,char *,char *);
       void	serror_s	(char *,char *);
       void	terror_gen	(char *);
       void	terror	(char *);
       void	terror_s	(char *,char *);
       void	terror_ss	(char *,char *,char *);
       void	gerror_gen	(char *,unitrec *);
       void	gerror	(char *,unitrec *);
       void	gerror_s	(char *,char *,unitrec *);
       void	nxerror	(char *,unitrec *);
       int32	testelem	(byte (*)[],int32);
       void	setelem	(byte (*)[],int32);
       int32	nextpoweroftwo	(int32);
       void	loaderror	(char *,char *);
       int32	loadsourcefile	(char *,char *);
       int32	loadbuiltin	(char *,char *);
       void	gs_init	(strbuffer *);
       void	gs_str	(strbuffer *,char *);
       void	gs_strn	(strbuffer *,char *,int32);
       void	gs_strvar	(strbuffer *,strbuffer *);
       void	gs_strint	(strbuffer *,int64);
       void	gs_strln	(strbuffer *,char *);
       void	gs_strsp	(strbuffer *,char *);
       void	gs_line	(strbuffer *);
       int32	gs_getcol	(strbuffer *);
       void	gs_leftstr	(strbuffer *,char *,int32,int32);
       void	gs_leftint	(strbuffer *,int32,int32,int32);
       void	gs_padto	(strbuffer *,int32,int32);
       void	gs_println	(strbuffer *,void *);
static void	gs_copytostr	(strbuffer *,char *);
       void	gs_additem	(strbuffer *,char *);
       void	strbuffer_add	(strbuffer *,char *,int32);
static int32	isalphanum	(int32);
static void	showmacrolineno	(void);

// From module: cc_headers
/* Local Function Prototypes */
       char *	findheader	(char *);
       void	writeheaders	(void);

// From module: cc_lex
/* Local Function Prototypes */
       void	lex_preprocess_only	(char *,int32);
       void	lexreadtoken	(void);
static void	readrealnumber	(byte *,byte *,int32,int32);
static int32	readexponent	(int32 *);
static void	lxerror	(char *);
       void	printsymbol	(tokenrec *);
       void	lexsetup	(void);
       void	printstrn	(char *,int32,void *);
static byte *	scannumber	(int32);
static int32	lookup	(void);
static int32	gethashvalue	(char *,int32);
static void	inithashtable	(void);
static int32	dolexdirective	(void);
static int32	getlexdirective	(void);
       void	startlex	(char *,int32);
       void	endlex	(void);
       void	PS	(char *);
       void	PSNEXT	(char *);
       void	showhashtablesize	(void);
static void	readlinecomment	(void);
static void	readblockcomment	(void);
static void	readhex	(byte *);
static void	readbinary	(byte *);
static void	readoctal	(byte *);
static void	readdecimal	(byte *);
static int32	checknumbersuffix	(void);
static void	stacksourcefile	(char *,int32);
static void	unstacksourcefile	(void);
static int32	getsourcefile	(char *,int32);
       void	lex	(void);
static void	shownumberstr	(tokenrec *,void *);
       strec *	addnamestr	(char *);
       char *	getstname	(strec *);
static void	lxreadstring	(int32,int32);
static void	addlisttoken	(tokenrec * *,tokenrec * *,tokenrec *);
static void	addlisttoken_copy	(tokenrec * *,tokenrec * *,tokenrec *);
static void	addlist_nextlx	(tokenrec * *,tokenrec * *);
static void	addlisttoken_seq	(tokenrec * *,tokenrec * *,tokenrec *);
static void	addlistmparam	(mparamrec * *,mparamrec * *,mparamrec *);
static void	dodefine	(void);
static void	readalphanumeric	(byte *);
static int32	inmacrostack	(strec *,tokenrec *);
static void	showtokens	(char *,tokenrec *);
static void	lexa	(tokenrec * *);
static void	lexm	(void);
static int32	peeklb	(void);
static int32	peektk	(tokenrec *);
static tokenrec *	expandobjmacro	(strec *,tokenrec *,tokenrec * *,int32);
static tokenrec *	expandfnmacro	(strec *,tokenrec *,tokenrec * *,int32,int32 *);
static tokenrec *	scantokenseq	(tokenrec *,tokenrec *,int32 *);
static int32	readmacrocall	(strec *,tokenrec * (*)[],tokenrec * *);
static tokenrec *	substituteargs	(strec *,tokenrec * (*)[],tokenrec * (*)[],int32,tokenrec *);
static char *	strtoken	(tokenrec *,int32 *);
static char *	strstring	(char *,int32,int32 *,int32);
static void	emittoken	(tokenrec *,strbuffer *);
       void	showtoken	(tokenrec *);
static void	stringify	(tokenrec *,tokenrec *);
static void	pastetokens	(tokenrec *,tokenrec * *);
static int32	getifexpr	(void);
static int64	evalcondexpr	(int32 *);
static int64	evalorexpr	(int32 *);
static int64	evalandexpr	(int32 *);
static int64	evaliorexpr	(int32 *);
static int64	evalixorexpr	(int32 *);
static int64	evaliandexpr	(int32 *);
static int64	evaleqexpr	(int32 *);
static int64	evalcmpexpr	(int32 *);
static int64	evalshiftexpr	(int32 *);
static int64	evaladdexpr	(int32 *);
static int64	evalmulexpr	(int32 *);
static int64	evalunaryexpr	(int32 *);
static int64	evalterm	(int32 *);
static int32	getifdef	(void);
static int32	skipcode	(void);
static void	freetokens	(tokenrec *);
       void	fastreadtoken	(void);
static tokenrec *	alloctoken	(void);
static tokenrec *	alloctokenz	(void);
static void	expandpredefmacro	(int32,tokenrec *,int32);
static void	dopragmadir	(void);
static int32	needspace	(int32,int32);

// From module: cc_lib
/* Local Function Prototypes */
static strec *	newstrec	(void);
       void	initcclib	(void);
       void	printst	(void *,strec *,int32);
static void	printstrec	(void *,strec *,int32);
       void	printstflat	(void *);
       unitrec *	createname	(strec *);
       unitrec *	createunit0	(int32);
       unitrec *	createunit1	(int32,unitrec *);
       unitrec *	createunit2	(int32,unitrec *,unitrec *);
       unitrec *	createunit3	(int32,unitrec *,unitrec *,unitrec *);
       unitrec *	createconstunit	(uint64,int32);
       unitrec *	createstringconstunit	(char *,int32);
       int32	getoptocode	(int32);
       int64	getconstvalue	(unitrec *,int32);
       char *	nextautotype	(void);
       int32	createconstmode	(int32);
       int32	createrefmode	(int32);
       int32	createprocmode	(int32,paramrec *);
       int32	createarraymode	(int32,int32);
       int32	createenummode	(strec *);
       int32	createstructmode	(strec *,int32);
       void	setnameptr	(unitrec *);
       void	printcode_all	(void *,char *);
       void	printcode	(void *,char *,int32);
       void	printunit	(void *,unitrec *,int32,char *);
static void	printunitlist	(void *,unitrec *,int32,char *);
static char *	getprefix	(int32,char *,unitrec *);
       char *	getdottedname	(strec *);
static char *	getlineinfok	(void);
       strec *	getautofieldname	(void);
       void	convertstring	(char *,char *,int32);
       strbuffer *	strexpr	(unitrec *);
static void	jeval	(strbuffer *,unitrec *);
       char *	getopcjname	(int32);
       char *	Strmode	(int32,int32);
       char *	Strmode2	(int32,int32);
       void	istrmode	(int32,int32,char *);
       int32	countunits	(unitrec *);
static void	purgesymbol	(strec *,strec *,int32);
       void	purgesymbollist	(strec *,int32,int32);
       void	purgeprocs	(strec *,int32);
       void	purgeproc	(strec *,int32);
       void	printmodelist	(void *);
       void	addtoproclist	(strec *);
       char *	typename	(int32);
       unitrec *	allocunitrec	(void);
static int32	copymode	(int32);
static int32	createnewmode	(int32);
       void	addlistunit	(unitrec * *,unitrec * *,unitrec *);
       void	addlistdef	(strec * *,strec * *,strec *);
       void	addlistparam	(paramrec * *,paramrec * *,paramrec *);
       void	checksymbol	(int32);
       void	skipsymbol	(int32);
       void	inittypetables	(void);
       strec *	createdupldef	(strec *,strec *,int32);
       strec *	createnewmoduledef	(strec *,strec *);
       strec *	createnewproc	(strec *,strec *);
       strec *	resolvename	(strec *,strec *,int32,int32);
       strec *	checkdupl	(strec *,strec *,int32,int32);
       strec *	checkdupl_inproc	(strec *,strec *,int32,int32);
       int32	getalignment	(int32);

// From module: cc_parse
/* Local Function Prototypes */
static void	readmodule	(void);
       int32	parsemodule	(int32);
static int32	readdeclspec	(strec *,int32 *);
static int32	istypestarter	(void);
static unitrec *	readexpression	(void);
static unitrec *	readassignexpr	(void);
static unitrec *	readcondexpr	(void);
static unitrec *	readorlexpr	(void);
static unitrec *	readandlexpr	(void);
static unitrec *	readiorexpr	(void);
static unitrec *	readixorexpr	(void);
static unitrec *	readiandexpr	(void);
static unitrec *	readeqexpr	(void);
static unitrec *	readrelexpr	(void);
static unitrec *	readshiftexpr	(void);
static unitrec *	readaddexpr	(void);
static unitrec *	readmulexpr	(void);
static unitrec *	readterm	(void);
static unitrec *	readexprlist	(unitrec *);
static strec *	readmodulevar	(strec *,int32,int32);
static strec *	readframevar	(strec *,int32,int32);
static int32	readtype	(strec *,strec * *,int32,paramrec * *);
static void	readnamedtype	(strec *,strec * *,int32 (*)[],void * (*)[],int32 *);
static int32	readconstintexpr	(void);
static unitrec *	readinitexpr	(strec *,int32);
static unitrec *	readinitexpr2	(strec *,int32,int32);
static void	pushblock	(void);
static void	popblock	(void);
static unitrec *	readcompoundstmt	(int32);
static unitrec *	readstatement	(void);
static unitrec *	readifstmt	(void);
static unitrec *	readforstmt	(void);
static unitrec *	readwhilestmt	(void);
static unitrec *	readdostmt	(void);
static unitrec *	readreturnstmt	(void);
static unitrec *	readgotostmt	(void);
static unitrec *	readswitchstmt	(void);
static unitrec *	readcaselabel	(void);
static unitrec *	readexprstmt	(void);
static unitrec *	readcond	(void);
static int32	isusertype	(strec *);
static unitrec *	readlocaldecl	(void);
static strec *	createtypedef	(strec *,strec *,int32);
static paramrec *	readparams	(strec *);
static int32	readcasttype	(strec * *,int32,paramrec * *);
static strec *	readfunction	(strec *,int32,int32,paramrec *,int32 *);
static void	readfunctionbody	(strec *);
static unitrec *	createnegop	(unitrec *);
static unitrec *	createabsop	(unitrec *);
static unitrec *	createinotop	(unitrec *);
static unitrec *	createderefop	(unitrec *);
static unitrec *	createincrop	(int32,unitrec *);
static unitrec *	createsizeofop	(unitrec *);
static unitrec *	createaddrofop	(unitrec *);
static unitrec *	createaddop	(unitrec *,unitrec *);
static unitrec *	createsubop	(unitrec *,unitrec *);
static unitrec *	createmulop	(unitrec *,unitrec *);
static unitrec *	createdivop	(unitrec *,unitrec *);
static unitrec *	createremop	(unitrec *,unitrec *);
static void	insertunit	(unitrec *,int32);
static unitrec *	eval_add	(int32,unitrec *,unitrec *,int32);
static unitrec *	eval_sub	(int32,unitrec *,unitrec *,int32);
static unitrec *	eval_mul	(int32,unitrec *,unitrec *,int32);
static unitrec *	eval_div	(int32,unitrec *,unitrec *,int32);
static unitrec *	eval_rem	(int32,unitrec *,unitrec *,int32);
static int32	eval_convert	(unitrec *,int32,int32);
static void	coercecond	(unitrec *);
static void	coercebasetype	(unitrec *);
static void	checklvalue	(unitrec *);
static unitrec *	createcall	(unitrec *,unitrec *);
static unitrec *	arraytopointer	(unitrec *);
static unitrec *	createindexop	(unitrec *,unitrec *);
static int32	readstructdecl	(strec *);
static int32	checkpointertypes	(int32,int32,int32);
static int32	comparemode	(int32,int32);
static int32	readenumdecl	(strec *);
static void	readenumnames	(strec *);
static unitrec *	createdotop	(int32,unitrec *,strec *);
static unitrec *	mulunit	(unitrec *,int32);
static unitrec *	divunit	(unitrec *,int32);
static unitrec *	createassignopref	(int32,unitrec *,unitrec *);
static void	addnewfield	(fieldrec * *,strec *,int32);
static void	pushloop	(int32);
static void	poploop	(void);
static void	addcasevalue	(int32);
static int32	roundoffset	(int32,int32);
static void	fixmemopnd	(unitrec *);
static unitrec *	docast	(unitrec *,int32,int32,int32);
static unitrec *	coercemode	(unitrec *,int32);
static void	coercemode_inplace	(unitrec *,int32);
static void	dostaticassert	(void);

// From module: cc_libtcl
/* Local Function Prototypes */
static void	printtcl	(tclrec *);
       void	settcdest	(int32);
       void	inittc	(void);
       void	inittccode	(void);
       void	gentc	(int32);
       void	gentc1	(int32,opndrec *);
       void	gentc2	(int32,opndrec *,opndrec *);
       void	gentc3	(int32,opndrec *,opndrec *,opndrec *);
       void	gentc_label	(int32,int32);
       void	gentc_int	(int32,int32);
static tclrec *	newtclrec	(int32);
static void	addtclrec	(tclrec *);
static opndrec *	getnextopnd	(void);
       opndrec *	gen_int	(int64,int32);
       opndrec *	gen_real	(double,int32);
       opndrec *	gen_label	(int32);
       opndrec *	gen_string	(char *,int32);
       opndrec *	gen_mem	(strec *,int32);
       opndrec *	gen_addr	(strec *);
       opndrec *	gen_dest	(opndrec *,int32);
       opndrec *	gen_destax	(opndrec *,opndrec *);
       opndrec *	gen_temp	(int32);
       opndrec *	gen_tempax	(opndrec *);
       opndrec *	gen_imem	(strec *,int32);
       opndrec *	gen_itemp	(int32);
       opndrec *	makeindirect	(opndrec *,int32);
       void	gencomment	(char *);
       void	make_int_opnd	(opndrec *,int64,int32);
static void	writetclproc	(strec *);
static void	writetclinstr	(tclrec *);
       char *	strtclopnd	(opndrec *);
static char *	getsizestr	(tclrec *);
       strbuffer *	writetccode	(char *,int32,int32);
       int32	checkblockreturn	(unitrec *);
       int32	gettypecode	(int32);
       opndrec *	fixopnd	(opndrec *);
       char *	getshorttypecode	(int32,int32);
       int32	roundoffsetdown	(int32,int32);

// From module: cc_genasm
/* Local Function Prototypes */
       int32	codegen_asm	(int32,char *);
static void	doprocdef	(strec *);
static void	writetables	(void);
static void	translate	(tclrec *);
static int32	nextstringindex	(char *,int32);
static int32	nextrealindex	(double,int32);
static void	genstrconst	(char *,int32);
static void	genrealconst	(uint64,int32);
static void	asmstr	(char *);
static void	asmstrln	(char *);
static void	asmline	(void);
static void	asmln	(void);
static void	asmint	(int64);
static void	asmchar	(int32);
static void	initasmdest	(void);
static void	expandasmdest	(void);
static void	setcodeseg	(void);
static void	setzdataseg	(int32);
static void	setidataseg	(int32);
static void	genidata	(unitrec *);
static void	dostaticvar	(strec *);
static void	dostaticvar_fn	(strec *);
static void	addvarcomment	(strec *,int32);
static void	addtempcomment	(int32,int32);
static void	asmreg	(int32,int32);
static void	asmxreg	(int32);
static void	asmxmove	(opndrec *);
static void	asmexch	(int32,int32,int32);
static void	asmbuffercheck	(int32);
static void	genmainprelude	(void);
static int32	roundoffsetdown_size	(int32,int32);
static void	asmopnd	(opndrec *);
static void	pushopnd	(opndrec *);
static void	loadopnd	(opndrec *,int32);
static void	storeopnd	(opndrec *,int32);
static void	floadopnd	(opndrec *,int32);
static void	fstoreopnd	(opndrec *,int32);
static void	gloadopnd	(opndrec *,int32);
static void	gstoreopnd	(opndrec *,int32);
static void	loadaddr	(opndrec *,int32);
static void	domove	(opndrec *,opndrec *);
static void	doblockmove	(opndrec *,opndrec *);
static void	doincr	(opndrec *,int32);
static char *	getasmcondcode	(int32,int32);
static void	dojumpcc	(int32,opndrec *,opndrec *,opndrec *);
static void	docallproc	(tclrec *,opndrec *,opndrec *);
static void	doadd	(opndrec *,opndrec *,opndrec *);
static void	dosub	(opndrec *,opndrec *,opndrec *);
static void	dofadd	(opndrec *,opndrec *,opndrec *,int32);
static void	domul	(opndrec *,opndrec *,opndrec *);
static void	dodiv	(opndrec *,opndrec *,opndrec *,int32);
static void	doiand	(opndrec *,opndrec *,opndrec *,int32);
static void	doshl	(opndrec *,opndrec *,opndrec *,int32);
static void	doshlto	(opndrec *,opndrec *,int32);
static void	dojumptrue	(opndrec *,opndrec *,int32);
static void	dogetptr	(opndrec *,opndrec *);
static void	doblockgetptr	(opndrec *,opndrec *);
static void	dogetaddr	(opndrec *,opndrec *);
static opndrec *	getlvopnd	(opndrec *,int32);
static void	dowiden	(opndrec *,opndrec *);
static void	donarrow	(opndrec *,opndrec *);
static void	dotruncate	(opndrec *,opndrec *);
static void	docopylist	(opndrec *);
static void	doindex	(opndrec *,opndrec *,opndrec *,int32,int32);
static void	doblockindex	(opndrec *,opndrec *,opndrec *,int32,int32);
static void	dopreincrx	(opndrec *,opndrec *,int32,int32);
static void	dopostincrx	(opndrec *,opndrec *,int32,int32);
static void	dofloat	(opndrec *,opndrec *);
static void	dofix	(opndrec *,opndrec *);
static void	dosoftconv	(opndrec *,opndrec *);
static void	doaddto	(opndrec *,opndrec *);
static void	dofaddto	(opndrec *,opndrec *,int32);
static void	dosubto	(opndrec *,opndrec *);
static void	domulto	(opndrec *,opndrec *);
static void	dodivto	(opndrec *,opndrec *,int32);
static void	doiandto	(opndrec *,opndrec *,int32);
static void	doneg	(opndrec *,opndrec *);
static void	doabs	(opndrec *,opndrec *);
static void	doinot	(opndrec *,opndrec *);
static void	docopyblock	(opndrec *,opndrec *);
static void	domemcpy	(int32);
static void	doswitchop	(tclrec *,opndrec *,opndrec *,opndrec *);
static void	dosetcc	(int32,opndrec *,opndrec *,opndrec *);
static void	pushfloatparam	(opndrec *);
static void	loadfloatparam	(opndrec *,int32);
static void	dofwiden	(opndrec *,opndrec *);
static void	dofnarrow	(opndrec *,opndrec *);
static void	saveretvalue	(opndrec *);

// From module: cc_gentcl
/* Local Function Prototypes */
       int32	codegen_tcl	(int32);
static void	do_stmt	(unitrec *);
static opndrec *	do_expr	(unitrec *,opndrec *);
static opndrec *	do_exprlv	(unitrec *,opndrec *);
static void	loneexpr	(unitrec *);
static opndrec *	dx_const	(unitrec *);
static void	do_assign	(unitrec *,unitrec *);
static opndrec *	dx_assign	(unitrec *,unitrec *);
static void	do_labeldef	(strec *);
static void	do_goto	(strec *);
static void	do_if	(unitrec *,unitrec *,unitrec *);
static int32	definelabel	(void);
       int32	createfwdlabel	(void);
       void	definefwdlabel	(int32);
static void	genjumpl	(int32);
static void	genjumpcond	(int32,unitrec *,int32);
static void	gcomparejump	(int32,unitrec *,unitrec *,unitrec *,int32);
static int32	reversecond	(int32);
static void	stacklooplabels	(int32,int32);
static void	do_while	(unitrec *,unitrec *);
static void	do_dowhile	(unitrec *,unitrec *);
static void	do_for	(unitrec *,unitrec *);
static void	do_incr	(unitrec *,int32,int32);
static opndrec *	dx_preincr	(unitrec *,int32);
static void	do_return	(unitrec *);
static opndrec *	dx_neg	(unitrec *,int32);
static opndrec *	dx_add	(unitrec *,unitrec *,int32,opndrec *);
static opndrec *	dx_convert	(unitrec *,int32,int32);
static opndrec *	dx_andorl	(unitrec *);
static opndrec *	getindex	(unitrec *,int32 *);
static opndrec *	dx_deref	(unitrec *,unitrec *);
static opndrec *	dx_dereflv	(unitrec *,unitrec *);
static void	do_switch	(unitrec *,unitrec *,unitrec *);
static opndrec *	dx_addto	(unitrec *,unitrec *,int32,int32);
static opndrec *	dx_call	(unitrec *,unitrec *,unitrec *,int32);
static opndrec *	dx_ifx	(unitrec *,unitrec *,unitrec *);
static opndrec *	dx_eq	(unitrec *,unitrec *,int32);
static void	do_procdef	(strec *);
static opndrec *	dx_derefoffset	(unitrec *,unitrec *,unitrec *,unitrec *,int32,opndrec *);
static opndrec *	dx_widen	(unitrec *,int32,opndrec *);
static int32	isstructunion	(int32);

// From module: cc_start
/* Local Function Prototypes */
       void	start	(void);
static void	showoutput	(void);
static void	do_loadmodules	(void);
static void	do_preprocess	(void);
static void	do_parsemodules	(void);
static int32	do_linkmodules	(void);
static void	do_gen1	(void);
static void	do_gen2	(void);
static void	do_runprog	(void);
static int32	loadmainmodule	(char *);
static int32	addmodule	(char *,int32,int32);
static void	initlogfile	(void);
static void	closelogfile	(void);
static void	initdata	(void);
static void	initsearchdirs	(void);
static void	showsearchdirs	(void);
static void	showast	(int32);
static void	showstflat	(char *);
static void	showsttree	(char *,int32);
static void	showtcl	(char *,int32);
static void	showasm	(int32);
static void	showmodules	(void);
static void	showfiles	(void);
static void	starttiming	(void);
static void	showtiming	(void);
       void	showlps	(char *,int32,int32);
static void	getinputoptions	(void);
static void	do_option	(int32,char *);
static int32	nextparam	(int32 *,char * *,char * *);
static int32	readnextfileitem	(char * *,char * *);
static void	showoptions	(void);
static void	showincludepaths	(void);
static void	showhelp	(void);
static void	showcaption	(void);

// From module: mm_clib

// From module: mm_mainc
/* Local Static Variables */
       int32	nsysparams;
       char *	sysparams[32];

// From module: mm_mlib
/* Local Static Variables */
       uint32	allocupper[256];
       int32	alloccode;
       int32	allocbytes;
       int32	fdebug=0;
       int32	rfsize;
static uint32	maxmemory;
static int32	maxalloccode;
static int32	show=0;
       int32	memtotal=0;
       int64	smallmemtotal=0;
       int32	smallmemobjs=0;
       int32	maxmemtotal=0;
static int32 *	memalloctable[100001];
static int32	memallocsize[100001];
static byte *	pcheapstart;
static byte *	pcheapend;
static byte *	pcheapptr;
static byte	sizeindextable[2049];
static uint64 *	freelist[9];

// From module: mm_nos
/* Local Static Variables */
static int32	init_flag=0;

// From module: cc_tables
/* Local Static Variables */
       char *	stdtypenames[23]={"none",
"void",
"schar",
"short",
"int",
"llong",
"bool",
"uchar",
"ushort",
"uint",
"ullong",
"float",
"double",
"ldouble",
"complex",
"enum",
"ref",
"proc",
"label",
"array",
"struct",
"union",
"tlast"
};
       byte	stdtypewidths[23]={0,
0,
8,
16,
32,
64,
8,
8,
16,
32,
64,
32,
64,
128,
128,
0,
64,
64,
64,
0,
0,
0,
0
};
       byte	stdtypesigned[23]={0,
0,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0
};
       byte	stdexpandtypes[23]={0,
0,
tsint,
tsint,
0,
0,
tuint,
tuint,
tuint,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0
};
       char *	typespecnames[16]={"ts_void",
"ts_char",
"ts_short",
"ts_long",
"ts_int",
"ts_float",
"ts_double",
"ts_signed",
"ts_unsigned",
"ts_bool",
"ts_complex",
"ts_user",
"ts_struct",
"ts_union",
"ts_enum",
"ts_atomic"
};
       int32	typespectypes[16]={tvoid,
tuchar,
0,
0,
tsint,
tfloat,
tdouble,
0,
0,
tbool,
tcomplex,
0,
0,
0,
0,
0
};
       byte	typespecsizes[16]={0,
1,
2,
4,
4,
4,
8,
0,
0,
1,
0,
0,
0,
0,
4,
0
};
       char *	pmflagnames[4]={"pm_normal","pm_notset","pm_empty","pm_variadic"};
       char *	scopenames[5]={"-","Fn","Loc","Imp","Exp"};
       char *	ccnames[6]={"open_cc","own_cc","clang_cc","stdcall_cc","callback_cc","dummy_cc"};
       char *	linkagenames[6]={"none_ss","static_ss","auto_ss","register_ss","extern_ss","typedef_ss"};
       char *	typequalnames[4]={"const_qual","volatile_qual","restrict_qual","atomic_qual"};
       char *	fnspecnames[2]={"inline_fnspec","noreturn_fnspec"};
       char *	jtagnames[82]={"j_none",
"j_const",
"j_null",
"j_name",
"j_nameaddr",
"j_widenmem",
"j_funcname",
"j_block",
"j_tempdecl",
"j_decl",
"j_callproc",
"j_return",
"j_returnx",
"j_assign",
"j_if",
"j_for",
"j_while",
"j_dowhile",
"j_goto",
"j_labelstmt",
"j_casestmt",
"j_defaultstmt",
"j_break",
"j_continue",
"j_switch",
"j_breaksw",
"&& andl",
"|| orl",
"! notl",
"j_istruel",
"j_makelist",
"j_exprlist",
"j_callfn",
"j_ifx",
"&&",
"==",
"!=",
"<",
"<=",
">",
">=",
"+ add",
"- sub",
"* mul",
"/ div",
"% mod",
"& iand",
"| ior",
"^ ixor",
"<<",
">>",
"j_dot",
"j_idot",
"j_dotref",
"j_index",
"* deref",
"* derefoffset",
"&* addoffset",
"j_convert",
"j_scale",
"- neg",
"abs",
"~ inot",
"++ preincrx",
"-- predecrx",
"++ postincrx",
"-- postdecrx",
"+=",
"-=",
"*=",
"/=",
"%=",
"&=",
"|=",
"^=",
"<<=",
">>=",
"++ preincr",
"-- preincr",
"++ postincr",
"-- postdecr",
"j_dummy"
};
       char *	symbolnames[98]={"errorsym",
"dotsym",
"idotsym",
"lexhashsym",
"hashsym",
"lithashsym",
"hashhashsym",
"commasym",
"semisym",
"colonsym",
"assignsym",
"lbracksym",
"rbracksym",
"lsqsym",
"rsqsym",
"lcurlysym",
"rcurlysym",
"questionsym",
"curlsym",
"ellipsissym",
"addsym",
"subsym",
"mulsym",
"divsym",
"remsym",
"iorsym",
"iandsym",
"ixorsym",
"orlsym",
"andlsym",
"shlsym",
"shrsym",
"inotsym",
"notlsym",
"incrsym",
"decrsym",
"abssym",
"eqsym",
"nesym",
"ltsym",
"lesym",
"gesym",
"gtsym",
"addtosym",
"subtosym",
"multosym",
"divtosym",
"remtosym",
"iortosym",
"iandtosym",
"ixortosym",
"shltosym",
"shrtosym",
"eolsym",
"eofsym",
"rawnumbersym",
"intconstsym",
"realconstsym",
"charconstsym",
"wcharconstsym",
"stringconstsym",
"wstringconstsym",
"whitespacesym",
"placeholdersym",
"namesym",
"ksourcedirsym",
"predefmacrosym",
"ktypespecsym",
"kifsym",
"kelsesym",
"kcasesym",
"kdefaultsym",
"kforsym",
"kwhilesym",
"kdosym",
"kreturnsym",
"kbreaksym",
"kcontinuesym",
"kgotosym",
"kswitchsym",
"kstructsym",
"kunionsym",
"klinkagesym",
"ktypequalsym",
"kfnspecsym",
"kalignassym",
"kenumsym",
"kcallconvsym",
"ksizeofsym",
"kdefinedsym",
"kgenericsym",
"kalignofsym",
"kshowmodesym",
"kshowtypesym",
"ktypeofsym",
"kstrtypesym",
"kmccassertsym",
"kdummysym"
};
       char *	shortsymbolnames[98]={"",
".",
"->",
"#",
"#",
"#",
"##",
",",
";",
":",
"=",
"(",
")",
"[",
"]",
"{",
"}",
"?",
"~",
"...",
"+",
"-",
"*",
"/",
"%",
"|",
"&",
"^",
"||",
"&&",
"<<",
">>",
"~",
"!",
"++",
"--",
"abs",
"==",
"!=",
"<",
"<=",
">=",
">",
"+=",
"-=",
"*=",
"/=",
"%=",
"|=",
"&=",
"^=",
"<<=",
">>=",
"",
"",
"n",
"n",
"n",
"s",
"s",
"s",
"s",
"w",
"<PH>",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
"k",
""
};
       byte	symboltojtag[98]={0,
j_dot,
j_idot,
0,
0,
0,
0,
0,
0,
0,
j_assign,
0,
0,
0,
0,
0,
0,
0,
0,
0,
j_add,
j_sub,
j_mul,
j_div,
j_rem,
j_ior,
j_iand,
j_ixor,
j_orl,
j_andl,
j_shl,
j_shr,
j_inot,
j_notl,
j_preincr,
j_predecr,
j_abs,
j_eq,
j_ne,
j_lt,
j_le,
j_ge,
j_gt,
j_addto,
j_subto,
j_multo,
j_divto,
j_remto,
j_iorto,
j_iandto,
j_ixorto,
j_shlto,
j_shrto,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0
};
       char *	sourcedirnames[20]={"definedir",
"emitdir",
"ifdir",
"elifdir",
"elsedir",
"endifdir",
"includedir",
"ifdefdir",
"ifndefdir",
"undefdir",
"errordir",
"warningdir",
"messagedir",
"pausedir",
"debugondir",
"debugoffdir",
"showmacrodir",
"blankdir",
"linedir",
"pragmadir"
};
       char *	namespacenames[5]={"ns_none","ns_general","ns_tags","ns_labels","ns_fields"};
       char *	namenames[15]={"nullid",
"macroid",
"programid",
"moduleid",
"extmoduleid",
"typeid",
"procid",
"staticid",
"frameid",
"paramid",
"fieldid",
"enumid",
"enumtagid",
"structtagid",
"labelid"
};
       int32	namespaces[15]={ns_none,
ns_none,
ns_none,
ns_none,
ns_none,
ns_general,
ns_general,
ns_general,
ns_general,
ns_general,
ns_fields,
ns_general,
ns_tags,
ns_tags,
ns_labels
};
       char *	stnames[75]={"if",
"else",
"case",
"default",
"for",
"do",
"while",
"return",
"break",
"continue",
"goto",
"switch",
"struct",
"union",
"include",
"define",
"elif",
"ifdef",
"ifndef",
"endif",
"undef",
"error",
"warning",
"message",
"MESSAGE",
"pragma",
"line",
"pause",
"debugon",
"debugoff",
"showmacro",
"auto",
"register",
"static",
"extern",
"typedef",
"const",
"volatile",
"restrict",
"_Atomic",
"inline",
"_Noreturn",
"_Alignas",
"abs",
"enum",
"$stdcall",
"$callback",
"$windows",
"void",
"char",
"short",
"long",
"int",
"float",
"double",
"signed",
"unsigned",
"_Bool",
"_Complex",
"__DATE__",
"__FILE__",
"__LINE__",
"__TIME__",
"__MCC__",
"not",
"sizeof",
"defined",
"_Generic",
"_Alignof",
"showmode",
"showtype",
"typeof",
"strtype",
"_Static_assert",
"$$dummy"
};
       int32	stsymbols[75]={kifsym,
kelsesym,
kcasesym,
kdefaultsym,
kforsym,
kdosym,
kwhilesym,
kreturnsym,
kbreaksym,
kcontinuesym,
kgotosym,
kswitchsym,
kstructsym,
kunionsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
ksourcedirsym,
klinkagesym,
klinkagesym,
klinkagesym,
klinkagesym,
klinkagesym,
ktypequalsym,
ktypequalsym,
ktypequalsym,
ktypequalsym,
kfnspecsym,
kfnspecsym,
kalignassym,
abssym,
kenumsym,
kcallconvsym,
kcallconvsym,
kcallconvsym,
ktypespecsym,
ktypespecsym,
ktypespecsym,
ktypespecsym,
ktypespecsym,
ktypespecsym,
ktypespecsym,
ktypespecsym,
ktypespecsym,
ktypespecsym,
ktypespecsym,
predefmacrosym,
predefmacrosym,
predefmacrosym,
predefmacrosym,
predefmacrosym,
notlsym,
ksizeofsym,
kdefinedsym,
kgenericsym,
kalignofsym,
kshowmodesym,
kshowtypesym,
ktypeofsym,
kstrtypesym,
kmccassertsym,
0
};
       int32	stsubcodes[75]={j_if,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
includedir,
definedir,
elifdir,
ifdefdir,
ifndefdir,
endifdir,
undefdir,
errordir,
warningdir,
messagedir,
messagedir,
pragmadir,
linedir,
pausedir,
debugondir,
debugoffdir,
showmacrodir,
auto_ss,
register_ss,
static_ss,
extern_ss,
typedef_ss,
const_qual,
volatile_qual,
restrict_qual,
atomic_qual,
inline_fnspec,
noreturn_fnspec,
0,
0,
0,
stdcall_cc,
callback_cc,
stdcall_cc,
ts_void,
ts_char,
ts_short,
ts_long,
ts_int,
ts_float,
ts_double,
ts_signed,
ts_unsigned,
ts_char,
ts_complex,
pdm_date,
pdm_file,
pdm_line,
pdm_time,
pdm_mcc,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0
};
       char *	convnames[14]={"no_conv",
"soft_c",
"hard_c",
"swiden_c",
"uwiden_c",
"sfloat_c",
"ufloat_c",
"sfix_c",
"ufix_c",
"fwiden_c",
"fnarrow_c",
"narrow_c",
"truncate_c",
"bool_c"
};
       byte	dominantmode[32][32];
       byte	conversionops[16][16];
       byte	dominantsetuptable[144][3]={{tschar,tschar,tsint},
{tschar,tsshort,tsint},
{tschar,tsint,tsint},
{tschar,tsllong,tsllong},
{tschar,tbool,tsint},
{tschar,tuchar,tsint},
{tschar,tushort,tsint},
{tschar,tuint,tsint},
{tschar,tullong,tsllong},
{tschar,tfloat,tfloat},
{tschar,tdouble,tdouble},
{tschar,tldouble,tldouble},
{tsshort,tschar,tsint},
{tsshort,tsshort,tsint},
{tsshort,tsint,tsint},
{tsshort,tsllong,tsllong},
{tsshort,tbool,tsint},
{tsshort,tuchar,tsint},
{tsshort,tushort,tsint},
{tsshort,tuint,tsint},
{tsshort,tullong,tsllong},
{tsshort,tfloat,tfloat},
{tsshort,tdouble,tdouble},
{tsshort,tldouble,tldouble},
{tsint,tschar,tsint},
{tsint,tsshort,tsint},
{tsint,tsint,tsint},
{tsint,tsllong,tsllong},
{tsint,tbool,tsint},
{tsint,tuchar,tsint},
{tsint,tushort,tsint},
{tsint,tuint,tuint},
{tsint,tullong,tsllong},
{tsint,tfloat,tfloat},
{tsint,tdouble,tdouble},
{tsint,tldouble,tldouble},
{tsllong,tschar,tsllong},
{tsllong,tsshort,tsllong},
{tsllong,tsint,tsllong},
{tsllong,tsllong,tsllong},
{tsllong,tbool,tsllong},
{tsllong,tuchar,tsllong},
{tsllong,tushort,tsllong},
{tsllong,tuint,tsllong},
{tsllong,tullong,tullong},
{tsllong,tfloat,tfloat},
{tsllong,tdouble,tdouble},
{tsllong,tldouble,tldouble},
{tbool,tschar,tsint},
{tbool,tsshort,tsint},
{tbool,tsint,tsint},
{tbool,tsllong,tsllong},
{tbool,tbool,tuint},
{tbool,tuchar,tuint},
{tbool,tushort,tuint},
{tbool,tuint,tuint},
{tbool,tullong,tullong},
{tbool,tfloat,tfloat},
{tbool,tdouble,tdouble},
{tbool,tldouble,tldouble},
{tuchar,tschar,tsint},
{tuchar,tsshort,tsint},
{tuchar,tsint,tsint},
{tuchar,tsllong,tsllong},
{tuchar,tbool,tnone},
{tuchar,tuchar,tuint},
{tuchar,tushort,tuint},
{tuchar,tuint,tuint},
{tuchar,tullong,tullong},
{tuchar,tfloat,tfloat},
{tuchar,tdouble,tdouble},
{tuchar,tldouble,tldouble},
{tushort,tschar,tsint},
{tushort,tsshort,tsint},
{tushort,tsint,tsint},
{tushort,tsllong,tsllong},
{tushort,tbool,tuint},
{tushort,tuchar,tuint},
{tushort,tushort,tuint},
{tushort,tuint,tuint},
{tushort,tullong,tullong},
{tushort,tfloat,tfloat},
{tushort,tdouble,tdouble},
{tushort,tldouble,tldouble},
{tuint,tschar,tsint},
{tuint,tsshort,tsint},
{tuint,tsint,tuint},
{tuint,tsllong,tsllong},
{tuint,tbool,tuint},
{tuint,tuchar,tuint},
{tuint,tushort,tuint},
{tuint,tuint,tuint},
{tuint,tullong,tullong},
{tuint,tfloat,tfloat},
{tuint,tdouble,tdouble},
{tuint,tldouble,tldouble},
{tullong,tschar,tullong},
{tullong,tsshort,tullong},
{tullong,tsint,tullong},
{tullong,tsllong,tullong},
{tullong,tbool,tullong},
{tullong,tuchar,tullong},
{tullong,tushort,tullong},
{tullong,tuint,tullong},
{tullong,tullong,tullong},
{tullong,tfloat,tfloat},
{tullong,tdouble,tdouble},
{tullong,tldouble,tldouble},
{tfloat,tschar,tdouble},
{tfloat,tsshort,tdouble},
{tfloat,tsint,tdouble},
{tfloat,tsllong,tdouble},
{tfloat,tbool,tdouble},
{tfloat,tuchar,tdouble},
{tfloat,tushort,tdouble},
{tfloat,tuint,tdouble},
{tfloat,tullong,tdouble},
{tfloat,tfloat,tfloat},
{tfloat,tdouble,tdouble},
{tfloat,tldouble,tldouble},
{tdouble,tschar,tdouble},
{tdouble,tsshort,tdouble},
{tdouble,tsint,tdouble},
{tdouble,tsllong,tdouble},
{tdouble,tbool,tdouble},
{tdouble,tuchar,tdouble},
{tdouble,tushort,tdouble},
{tdouble,tuint,tdouble},
{tdouble,tullong,tdouble},
{tdouble,tfloat,tdouble},
{tdouble,tdouble,tdouble},
{tdouble,tldouble,tldouble},
{tldouble,tschar,tdouble},
{tldouble,tsshort,tdouble},
{tldouble,tsint,tdouble},
{tldouble,tsllong,tdouble},
{tldouble,tbool,tdouble},
{tldouble,tuchar,tdouble},
{tldouble,tushort,tdouble},
{tldouble,tuint,tdouble},
{tldouble,tullong,tdouble},
{tldouble,tfloat,tdouble},
{tldouble,tdouble,tdouble},
{tldouble,tldouble,tldouble}
};
       byte	convsetuptable[144][3]={{tschar,tschar,swiden_c},
{tschar,tsshort,swiden_c},
{tschar,tsint,swiden_c},
{tschar,tsllong,swiden_c},
{tschar,tbool,bool_c},
{tschar,tuchar,soft_c},
{tschar,tushort,swiden_c},
{tschar,tuint,swiden_c},
{tschar,tullong,swiden_c},
{tschar,tfloat,sfloat_c},
{tschar,tdouble,sfloat_c},
{tschar,tldouble,sfloat_c},
{tsshort,tschar,truncate_c},
{tsshort,tsshort,no_conv},
{tsshort,tsint,swiden_c},
{tsshort,tsllong,swiden_c},
{tsshort,tbool,bool_c},
{tsshort,tuchar,truncate_c},
{tsshort,tushort,soft_c},
{tsshort,tuint,swiden_c},
{tsshort,tullong,swiden_c},
{tsshort,tfloat,sfloat_c},
{tsshort,tdouble,sfloat_c},
{tsshort,tldouble,sfloat_c},
{tsint,tschar,truncate_c},
{tsint,tsshort,truncate_c},
{tsint,tsint,no_conv},
{tsint,tsllong,swiden_c},
{tsint,tbool,bool_c},
{tsint,tuchar,truncate_c},
{tsint,tushort,truncate_c},
{tsint,tuint,soft_c},
{tsint,tullong,swiden_c},
{tsint,tfloat,sfloat_c},
{tsint,tdouble,sfloat_c},
{tsint,tldouble,sfloat_c},
{tsllong,tschar,truncate_c},
{tsllong,tsshort,truncate_c},
{tsllong,tsint,truncate_c},
{tsllong,tsllong,no_conv},
{tsllong,tbool,bool_c},
{tsllong,tuchar,truncate_c},
{tsllong,tushort,truncate_c},
{tsllong,tuint,truncate_c},
{tsllong,tullong,truncate_c},
{tsllong,tfloat,sfloat_c},
{tsllong,tdouble,sfloat_c},
{tsllong,tldouble,sfloat_c},
{tbool,tschar,soft_c},
{tbool,tsshort,uwiden_c},
{tbool,tsint,uwiden_c},
{tbool,tsllong,uwiden_c},
{tbool,tbool,no_conv},
{tbool,tuchar,soft_c},
{tbool,tushort,uwiden_c},
{tbool,tuint,uwiden_c},
{tbool,tullong,uwiden_c},
{tbool,tfloat,ufloat_c},
{tbool,tdouble,ufloat_c},
{tbool,tldouble,ufloat_c},
{tuchar,tschar,soft_c},
{tuchar,tsshort,uwiden_c},
{tuchar,tsint,uwiden_c},
{tuchar,tsllong,uwiden_c},
{tuchar,tbool,bool_c},
{tuchar,tuchar,soft_c},
{tuchar,tushort,uwiden_c},
{tuchar,tuint,uwiden_c},
{tuchar,tullong,uwiden_c},
{tuchar,tfloat,ufloat_c},
{tuchar,tdouble,ufloat_c},
{tuchar,tldouble,ufloat_c},
{tushort,tschar,truncate_c},
{tushort,tsshort,soft_c},
{tushort,tsint,uwiden_c},
{tushort,tsllong,uwiden_c},
{tushort,tbool,bool_c},
{tushort,tuchar,truncate_c},
{tushort,tushort,no_conv},
{tushort,tuint,uwiden_c},
{tushort,tullong,uwiden_c},
{tushort,tfloat,ufloat_c},
{tushort,tdouble,ufloat_c},
{tushort,tldouble,ufloat_c},
{tuint,tschar,truncate_c},
{tuint,tsshort,truncate_c},
{tuint,tsint,soft_c},
{tuint,tsllong,uwiden_c},
{tuint,tbool,bool_c},
{tuint,tuchar,truncate_c},
{tuint,tushort,truncate_c},
{tuint,tuint,no_conv},
{tuint,tullong,uwiden_c},
{tuint,tfloat,ufloat_c},
{tuint,tdouble,ufloat_c},
{tuint,tldouble,ufloat_c},
{tullong,tschar,truncate_c},
{tullong,tsshort,truncate_c},
{tullong,tsint,truncate_c},
{tullong,tsllong,soft_c},
{tullong,tbool,bool_c},
{tullong,tuchar,truncate_c},
{tullong,tushort,truncate_c},
{tullong,tuint,truncate_c},
{tullong,tullong,no_conv},
{tullong,tfloat,ufloat_c},
{tullong,tdouble,ufloat_c},
{tullong,tldouble,ufloat_c},
{tfloat,tschar,sfix_c},
{tfloat,tsshort,sfix_c},
{tfloat,tsint,sfix_c},
{tfloat,tsllong,sfix_c},
{tfloat,tbool,ufix_c},
{tfloat,tuchar,ufix_c},
{tfloat,tushort,ufix_c},
{tfloat,tuint,ufix_c},
{tfloat,tullong,ufix_c},
{tfloat,tfloat,no_conv},
{tfloat,tdouble,fwiden_c},
{tfloat,tldouble,fwiden_c},
{tdouble,tschar,sfix_c},
{tdouble,tsshort,sfix_c},
{tdouble,tsint,sfix_c},
{tdouble,tsllong,sfix_c},
{tdouble,tbool,ufix_c},
{tdouble,tuchar,ufix_c},
{tdouble,tushort,ufix_c},
{tdouble,tuint,ufix_c},
{tdouble,tullong,ufix_c},
{tdouble,tfloat,fnarrow_c},
{tdouble,tdouble,no_conv},
{tdouble,tldouble,no_conv},
{tldouble,tschar,sfix_c},
{tldouble,tsshort,sfix_c},
{tldouble,tsint,sfix_c},
{tldouble,tsllong,sfix_c},
{tldouble,tbool,ufix_c},
{tldouble,tuchar,ufix_c},
{tldouble,tushort,ufix_c},
{tldouble,tuint,ufix_c},
{tldouble,tullong,ufix_c},
{tldouble,tfloat,fnarrow_c},
{tldouble,tdouble,no_conv},
{tldouble,tldouble,no_conv}
};

// From module: cc_decls
/* Local Static Variables */
       int32	ntypes;
       strec *	ttnamedef[25000];
       int32	ttbasetype[25000];
       int32	ttlength[25000];
       byte	ttconst[25000];
       byte	ttrestrict[25000];
       byte	ttvolatile[25000];
       int32	ttusertype[25000];
       int32	tttarget[25000];
       int32	ttreftype[25000];
       int32	ttconsttype[25000];
       int32	ttsize[25000];
       int32	ttbitwidth[25000];
       byte	ttisref[25000];
       paramrec *	ttparams[25000];
       int32	trefchar;
       int32	trefwchar;
       modulerec	moduletable[51];
       char *	inputfiles[51];
       char *	libfiles[51];
       char *	sourcefilenames[601];
       char *	sourcefilepaths[601];
       char *	sourcefiletext[601];
       int32	sourcefilesizes[601];
       int32	nmodules;
       int32	nsourcefiles;
       int32	ninputfiles;
       int32	nlibfiles;
       int32	currmoduleno;
       modulerec *	currmodule;
       char *	searchdirs[20];
       int32	nsearchdirs=0;
       char *	includepaths[20];
       int32	nincludepaths=0;
       strec *	stprogram;
       strec *	stmodule;
       strec *	stsysmodule;
       strec *	alldeflist;
       void *	logdev;
       int32	optflag=0;
       unitrec *	nullunit;
       int32	fverbose=0;
       int32	fquiet=0;
       int32	foptimise=0;
       int32	wintarget=1;
       int32	lintarget=0;
       int32	nostarget=0;
       int32	clineno=0;
       tokenrec	lx;
       tokenrec	nextlx;
       int32	tlex=0;
       int32	debug=0;
       int32	ndlltable;
       int32	ndllproctable;
       char *	dlltable[50];
       uint64	dllinsttable[50];
       dllprocrec	dllproctable[500];
       int32	ncmdparams;
       char *	cmdparamtable[33];
       procrec *	proclist;
       int32	nproclist;
       int32	NUNITNAME;
       int32	NUNIT0;
       int32	NUNIT1;
       int32	NUNIT2;
       int32	NUNIT3;
       int32	NEXPRS;
       int32	NSIMPLEEXPRS;
       int32	NNAMEEXPRS;
       int32	NCONSTEXPRS;
       int32	NALLFNMACROS;
       int32	NALLOBJMACROS;
       int32	NALLSIMPLEMACROS;
       int32	NALLSIMPLEMACROS1;
       int32	NALLSIMPLEMACROS0;
       int32	NALLSIMPLEMACROSNUM;
       int32	NALLLINES;
       int32	NSKIPPEDTOKENS;
       int32	NSKIPPEDLINES;
       int32	NIFS;
       int32	NALLCHARS;
       int32	NSUBST;
       int32	NSIMPLESUBST;
       int32	NLEXTOKENS;
       strec	hashtable[65536];
       int32	blockowner[2101];
       int32	blockcounts[2101];
       int32	blockstack[101];
       int32	currblockno;
       int32	nextblockno;
       int32	blocklevel;
       strec *	currproc;
       int32	progstart;
       int32	progend;
       int32	loadstart;
       int32	loadend;
       int32	parsestart;
       int32	parseend;
       int32	gen1start;
       int32	gen1end;
       int32	gen2start;
       int32	gen2end;
       int32	asmwstart;
       int32	asmwend;
       int32	ntclinstructions;
       int32	labelno=0;
       int32	dointheaders=1;
       int32	structpadding=1;
       int32	callbackflag=0;
       int32	slineno;
       int32	sfileno;

// From module: cc_support
/* Local Static Variables */
       byte	bytemasks[8]={1,2,4,8,16,32,64,128};

// From module: cc_headers
/* Local Static Variables */
static char *	h_assert="/* Header assert.h */\r\n\r\n#define assert(x) 0\r\n";
static char *	h_ctype="/* Header ctype.h */\r\n\r\nint tolower(int);\r\nint toupper(int);\r\nint isalpha(int);\r\nint isdigit(int);\r\nint isspace(int);\r\nint isalnum(int);\r\nint isupper(int);\r\nint islower(int);\r\n\r\nint isxdigit(int);\r\nint iscntrl(int);\r\nint isgraph(int);\r\nint ispunct(int);\r\n";
static char *	h_errno="/* Header errno.h */\r\n\r\n#ifndef $errno\r\n#define $errno\r\n\r\nextern int* _errno(void);\r\n#define errno (*_errno())\r\n\r\n#define EPERM 1\r\n#define ENOENT 2\r\n#define ESRCH 3\r\n#define EINTR 4\r\n#define EIO 5\r\n#define ENXIO 6\r\n#define E2BIG 7\r\n#define ENOEXEC 8\r\n#define EBADF 9\r\n#define ECHILD 10\r\n#define EAGAIN 11\r\n#define ENOMEM 12\r\n#define EACCES 13\r\n#define EFAULT 14\r\n#define ENOTBLK 15\r\n#define EBUSY 16\r\n#define EEXIST 17\r\n#define EXDEV 18\r\n#define ENODEV 19\r\n#define ENOTDIR 20\r\n#define EISDIR 21\r\n#define EINVAL 22\r\n#define ENFILE 23\r\n#define EMFILE 24\r\n#define ENOTTY 25\r\n#define ETXTBSY 26\r\n#define EFBIG 27\r\n#define ENOSPC 28\r\n#define ESPIPE 29\r\n#define EROFS 30\r\n#define EMLINK 31\r\n#define EPIPE 32\r\n#define EDOM 33\r\n#define ERANGE 34\r\n#define ENOMSG 35\r\n#define EIDRM 36\r\n#define ECHRNG 37\r\n#define EL2NSYNC 38\r\n#define EL3HLT 39\r\n#define EL3RST 40\r\n#define ELNRNG 41\r\n#define EUNATCH 42\r\n#define ENOCSI 43\r\n#define EL2HLT 44\r\n#define EDEADLK 45\r\n#define ENOLCK 46\r\n#define EBADE 50\r\n#define EBADR 51\r\n#define EXFULL 52\r\n#define ENOANO 53\r\n#define EBADRQC 54\r\n#define EBADSLT 55\r\n#define EDEADLOCK 56\r\n#define EBFONT 57\r\n#define ENOSTR 60\r\n#define ENODATA 61\r\n#define ETIME 62\r\n#define ENOSR 63\r\n#define ENONET 64\r\n#define ENOPKG 65\r\n#define EREMOTE 66\r\n#define ENOLINK 67\r\n#define EADV 68\r\n#define ESRMNT 69\r\n#define ECOMM 70\r\n#define EPROTO 71\r\n#define EMULTIHOP 74\r\n#define ELBIN 75\r\n#define EOVERFLOW 76\r\n#define EBADMSG 77\r\n#define ENOTUNIQ 80\r\n#define EBADFD 81\r\n#define EREMCHG 82\r\n#define ELIBACC 83\r\n#define ELIBBAD 84\r\n#define ELIBSCN 85\r\n#define ELIBMAX 86\r\n#define ELIBEXEC 87\r\n#define ENOSYS 88\r\n#define ENMFILE 89\r\n#define ENOTEMPTY 90\r\n#define ENAMETOOLONG 91\r\n#define EILSEQ 92\r\n#define __ELASTERROR 2000\r\n\r\n#endif\r\n";
static char *	h_fenv="/* Header fenv.h */\r\n";
static char *	h_float="/* Header float.h */\r\n\r\n//#define DBL_MAX_10_EXP 308\r\n//#define DBL_MANT_DIG 53\r\n\r\n#define FLT_RADIX 2\r\n\r\n#define FLT_DIG 6\r\n#define FLT_MIN_EXP -125\r\n#define FLT_MIN 1.17549435E-38F // decimal constant\r\n#define FLT_MIN 0X1P-126F // hex constant\r\n#define FLT_TRUE_MIN 1.40129846E-45F // decimal constant\r\n#define FLT_TRUE_MIN 0X1P-149F // hex constant\r\n#define FLT_HAS_SUBNORM 1\r\n#define FLT_MIN_10_EXP -37\r\n#define FLT_MAX_EXP +128\r\n#define FLT_MAX 3.40282347E+38F // decimal constant\r\n#define FLT_MAX 0X1.fffffeP127F // hex constant\r\n#define FLT_MAX_10_EXP +38\r\n\r\n#define FLT_MANT_DIG 23\r\n\r\n#define DBL_MANT_DIG 53\r\n#define DBL_EPSILON 2.2204460492503131E-16 // decimal constant\r\n#define DBL_EPSILON 0X1P-52 // hex constant\r\n#define DBL_DECIMAL_DIG 17\r\n#define DBL_DIG 15\r\n#define DBL_MIN_EXP -1021\r\n#define DBL_MIN 2.2250738585072014E-308 // decimal constant\r\n#define DBL_MIN 0X1P-1022 // hex constant\r\n#define DBL_TRUE_MIN 4.9406564584124654E-324 // decimal constant\r\n#define DBL_TRUE_MIN 0X1P-1074 // hex constant\r\n#define DBL_HAS_SUBNORM 1\r\n#define DBL_MIN_10_EXP -307\r\n#define DBL_MAX_EXP +1024\r\n#define DBL_MAX 1.7976931348623157E+308 // decimal constant\r\n#define DBL_MAX 0X1.fffffffffffffP1023 // hex constant\r\n#define DBL_MAX_10_EXP +308\r\n\r\nint     _isnan(double);\r\n#define isnan _isnan\r\n";
static char *	h_inttypes="/* Header inttypes.h */\r\n\r\n#include <stdint.h>\r\n";
static char *	h_stdint="/* Header stdint.h */\r\n\r\n#ifndef $stdint\r\n#define $stdint\r\n\r\ntypedef signed char int8_t;\r\ntypedef short int16_t;\r\ntypedef int int32_t;\r\ntypedef long long int int64_t;\r\n\r\ntypedef unsigned char uint8_t;\r\ntypedef unsigned short uint16_t;\r\ntypedef unsigned int uint32_t;\r\ntypedef unsigned long long int uint64_t;\r\n\r\ntypedef long long int intptr_t;\r\ntypedef unsigned long long int uintptr_t;\r\n\r\n#define INT8_MIN -128\r\n#define INT8_MAX 127\r\n#define INT16_MIN -32768\r\n#define INT16_MAX 32767\r\n#define INT32_MIN 0x80000000\r\n#define INT32_MAX 0x7FFFFFFF\r\n#define INT64_MIN 0x8000000000000000\r\n#define INT64_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define UINT8_MAX 255\r\n#define UINT16_MAX 65535\r\n#define UINT32_MAX 0xFFFFFFFF\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define INTPTR_MIN\t0x8000000000000000\r\n#define INTPTR_MAX\t0x7FFFFFFFFFFFFFFF\r\n#define UINTPTR_MAX\t0xFFFFFFFFFFFFFFFF\r\n\r\n#define UINT64_MAX\t0xFFFFFFFFFFFFFFFF\r\n#define SIZE_MAX\t0xFFFFFFFFFFFFFFFF\r\n\r\n#define PTRDIFF_MIN\t0x8000000000000000\r\n#define PTRDIFF_MAX\t0x7FFFFFFFFFFFFFFF\r\n\r\n#define WCHAR_MIN 0\r\n#define WCHAR_MAX 65535\r\n\r\n#define WINT_MIN 0\r\n#define WINT_MAX 65535\r\n\r\n#endif\r\n";
static char *	h_limits="/* Header limits.h */\r\n\r\n#define CHAR_BIT 8\r\n\r\n#define CHAR_MIN 0\r\n#define CHAR_MAX 255\r\n\r\n//#define UCHAR_MIN 0\r\n#define UCHAR_MAX 255\r\n\r\n#define SCHAR_MIN -128\r\n#define SCHAR_MAX 127\r\n\r\n#define SHRT_MIN 0x8000\r\n#define SHRT_MAX 0x7FFF\r\n\r\n//#define USHRT_MIN 0x0000\r\n#define USHRT_MAX 0xFFFF\r\n\r\n#define INT_MIN 0x80000000\r\n#define INT_MAX 0x7FFFFFFF\r\n\r\n//#define UINT_MIN 0x00000000\r\n#define UINT_MAX 0xFFFFFFFF\r\n\r\n//#define LONG_MIN 0x80000000\r\n#define LONG_MAX 0x7FFFFFFF\r\n\r\n//#define ULONG_MIN 0x00000000\r\n#define ULONG_MAX 0xFFFFFFFF\r\n\r\n#define LLONG_MIN 0x8000000000000000\r\n#define LLONG_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n//#define ULLONG_MIN 0x0000000000000000\r\n#define ULLONG_MAX 0xFFFFFFFFFFFFFFFF\r\n";
static char *	h_locale="/* Header locale.h */\r\n\r\n#define LC_ALL 0\r\n#define LC_COLLATE 1\r\n#define LC_CTYPE 2\r\n#define LC_MONETARY 3\r\n#define LC_NUMERIC 4\r\n#define LC_TIME 5\r\n\r\nstruct lconv {\r\n\tchar *decimal_point;\r\n\tchar *thousands_sep;\r\n\tchar *grouping;\r\n\tchar *int_curr_symbol;\r\n\tchar *currency_symbol;\r\n\tchar *mon_decimal_point;\r\n\tchar *mon_thousands_sep;\r\n\tchar *mon_grouping;\r\n\tchar *positive_sign;\r\n\tchar *negative_sign;\r\n\tchar int_frac_digits;\r\n\tchar frac_digits;\r\n\tchar p_cs_precedes;\r\n\tchar p_sep_by_space;\r\n\tchar n_cs_precedes;\r\n\tchar n_sep_by_space;\r\n\tchar p_sign_posn;\r\n\tchar n_sign_posn;\r\n};\r\nchar *setlocale(int category, const char *locale);\r\n\r\nstruct lconv *localeconv(void);\r\n\r\nchar * setlocale(int,const char *);\r\n";
static char *	h__ansi="/* Header _ansi.h */\r\n";
static char *	h_math="/* Header math.h */\r\n\r\n#define HUGE_VAL 1.7976931348623156e+308\r\n\r\ndouble floor(double);\r\ndouble ceil(double);\r\ndouble sqrt(double);\r\ndouble sin(double);\r\ndouble cos(double);\r\ndouble tan(double);\r\ndouble fmod(double,double);\r\ndouble asin(double);\r\ndouble acos(double);\r\ndouble atan(double);\r\ndouble log(double);\r\ndouble log10(double);\r\ndouble exp(double);\r\ndouble modf(double,double*);\r\ndouble atan2(double,double);\r\ndouble pow(double,double);\r\ndouble fabs(double);\r\ndouble sinh(double);\r\ndouble cosh(double);\r\ndouble tanh(double);\r\ndouble frexp(double,int*);\r\ndouble ldexp(double,int);\r\n\r\n//double log2(double);\r\n#define log2(x) (log(x)*1.442695041)\r\n\r\nint isinf(double);\r\n";
static char *	h_setjmp="/* Header setjmp.h */\r\n\r\n#ifndef $setjmp\r\n#define $setjmp 1\r\n\r\ntypedef int jmp_buf[128];\r\n\r\n//void longjmp(char*, int);\r\n\r\n//void $mcclongjmp(char*, int);\r\nvoid $mcclongjmp(jmp_buf, int);\r\n\r\n//int $mccsetjmp(char*);\r\nint $mccsetjmp(jmp_buf);\r\n\r\n\r\n//int\t_setjmp(char*);\r\n//int\tsetjmp(char*);\r\n\r\n#define setjmp $mccsetjmp\r\n#define longjmp $mcclongjmp\r\n\r\n#endif\r\n\r\n";
static char *	h_signal="/* Header signal.h */\r\n\r\n#define SIGINT    2\r\n#define SIGILL    4\r\n#define SIGFPE    8\r\n#define SIGSEGV  11\r\n#define SIGTERM  15\r\n#define SIGBREAK 21\r\n#define SIGABRT  22\r\n\r\n#define SIG_DFL (void (*)(int))0\r\n#define SIG_IGN (void (*)(int))1\r\n#define SIG_SGE (void (*)(int))3\r\n#define SIG_ACK (void (*)(int))4\r\n\r\n#define SIG_ERR (void (*)(int))-1\r\n\r\nextern void (*signal(int, void (*)(int)))(int);\r\n\r\nextern int raise(int);\r\n\r\n\r\ntypedef int sig_atomic_t;\r\n";
static char *	h_stdarg="/* Header stdarg.h */\r\n\r\n#ifndef $STDARG\r\n #define $STDARG\r\n\r\n//coded for x64 target as used by mcc (with first four params also on stack)\r\n\r\n typedef char *\tva_list;\r\n #define va_start(ap,v) ap=((va_list)&v+8)\r\n #define va_arg(ap,t) *(t*)((ap+=8)-8)\r\n #define va_copy(dest,src) (dest=src)\r\n #define va_end(ap)\t( ap = (va_list)0 )\r\n#endif\r\n";
static char *	h_stdbool="/* Header stdbool.h */\r\n\r\n#define bool unsigned char\r\n#define true 1\r\n#define false 0\r\n\r\n\r\n";
static char *	h_stddef="/* Header stddef.h */\r\n\r\n#ifndef $stddef\r\n#define $stddef\r\n\r\ntypedef unsigned long long int size_t;\r\ntypedef unsigned short wchar_t;\r\n\r\n#define NULL ((void*)0)\r\n\r\n#define offsetof(a,b) (size_t) &( ((a*)0) -> b)\r\n\r\ntypedef long long int ptrdiff_t;\r\n\r\n#endif // stddef\r\n";
static char *	h_stdio="/* Header stdio.h */\r\n\r\n#ifndef $stdio\r\n#define $stdio 1\r\n\r\n//#message \"STDIO included\"\r\n\r\n#ifndef $valist\r\n\ttypedef char* va_list;\r\n\t#define $valist\r\n#endif\r\n\r\n#include <stddef.h>\r\n\r\n#define SEEK_SET 0\r\n#define SEEK_CUR 1\r\n#define SEEK_END 2\r\n\r\n#define EOF (-1)\r\n\r\n#define L_tmpnam 10\r\n\r\ntypedef struct {\r\n\tchar *_ptr;\r\n\tint   _cnt;\r\n\tchar *_base;\r\n\tint   _flag;\r\n\tint   _file;\r\n\tint   _charbuf;\r\n\tint   _bufsiz;\r\n\tchar *_tmpfname;\r\n\t} FILE;\r\n\r\n// _iob-based \r\n//extern FILE _iob[];\r\n//#define stdin (&_iob[0])\r\n//#define stdout (&_iob[1])\r\n//#define stderr (&_iob[2])\r\n//\r\n\r\n// __iob_func-based\r\nextern char* __iob_func(void);\r\n\r\n#define stdin ((FILE*)(__iob_func()))\r\n#define stdout ((FILE*)(__iob_func()+sizeof(FILE)))\r\n#define stderr ((FILE*)(__iob_func()+sizeof(FILE)*2))\r\n\r\n#define _IOREAD 0x0001\r\n#define _IOWRT 0x0002\r\n\r\n#define _IOFBF 0x0000\r\n#define _IOLBF 0x0040\r\n#define _IONBF 0x0004\r\n\r\n#define _IOMYBUF 0x0008\r\n#define _IOEOF 0x0010\r\n#define _IOERR 0x0020\r\n#define _IOSTRG 0x0040\r\n#define _IORW 0x0080\r\n\r\n#define BUFSIZ 512\r\n\r\nFILE* fopen(const char*, const char*);\r\nint fclose(FILE*);\r\nlong ftell(FILE*);\r\nlong long int _ftelli64(FILE*);\r\nint fseek(FILE*,long,int);\r\nint _fseeki64(FILE*,long long int,int);\r\n\r\nsize_t fread(void*, size_t, size_t, FILE*);\r\nsize_t fwrite(const void*, size_t, size_t, FILE*);\r\nint remove(const char*);\r\nint rename(const char *,const char *);\r\nFILE* freopen(const char*, const char*, FILE*);\r\nFILE* _wfopen(const wchar_t*,const wchar_t *);\r\n\r\nint printf(const char*, ...);\r\nint sprintf(char*,const char*, ...);\r\nint fprintf(FILE*,const char*, ...);\r\nint sscanf(const char*, const char*, ...);\r\nint scanf(const char*, ...);\r\nint fscanf(FILE *,const char *, ...);\r\nint _snprintf(char *,size_t,const char*,...);\r\n#define snprintf _snprintf\r\nint _vsnprintf(char*, size_t, const char*, va_list);\r\nint vsnprintf(char*,size_t,const char*,va_list);\r\nint vsprintf(char*, const char*, va_list);\r\nint _wremove(const wchar_t*);\r\nint _wrename(const wchar_t*,const wchar_t*);\r\n\r\ntypedef char* va_list;\r\n\r\nint vfprintf(FILE*, const char*, va_list);\r\nint vprintf(const char*, va_list);\r\n\r\nint puts(const char*);\r\nchar* fgets(char*, int, FILE*);\r\nint fputs(const char*, FILE*);\r\nint fgetc(FILE*);\r\nint fputc(int, FILE*);\r\nint ungetc(int, FILE*);\r\nint getchar(void);\r\nint putchar(int);\r\nint fflush(FILE *);\r\nint getc(FILE *);\r\nint putc(int, FILE *);\r\n\r\nint feof(FILE*);\r\nint ferror(FILE*);\r\nvoid clearerr(FILE*);\r\n\r\nint fileno(FILE*);\r\nint _fileno(FILE*);\r\nint setvbuf(FILE*,char*,int,size_t);\r\nFILE* _popen(const char*, const char*);\r\nint _pclose(FILE*);\r\nint _unlink(const char *);\r\n#define unlink _unlink;\r\nFILE* _fdopen(int, const char *);\r\n#define fdopen _fdopen\r\n\r\nvoid rewind(FILE*);\r\n\r\nFILE* tmpfile(void);\r\n\r\nchar* tmpnam(char*);\r\n\r\nextern void* _wenviron;\r\n\r\n#endif\r\n\r\n";
static char *	h_stdlib="/* Header stdlib.h */\r\n\r\n#ifndef $stdlib\r\n#define $stdlib 1\r\n\r\n#include <stddef.h>\r\n\r\n#define EXIT_FAILURE 1\r\n#define EXIT_SUCCESS 0\r\n\r\n#define RAND_MAX 32767\r\n\r\nvoid* malloc(size_t);\r\nvoid* realloc(void*, size_t);\r\nvoid* calloc(size_t, size_t);\r\n\r\nvoid free(void*);\r\n\r\nvoid exit(int);\r\n\r\nint system(const char*);\r\nint _wsystem(const wchar_t*);\r\n\r\n//int abs(int);\r\nlong labs(long);\r\nint rand(void);\r\nvoid srand(unsigned int);\r\nint atoi(const char*);\r\nlong atol(const char*);\r\ndouble atof(const char *);\r\nint\tatexit(void (*)(void));\r\n\r\nvoid qsort(void*, size_t, size_t, int (*)(void*, void*));\r\n\r\ntypedef struct {\r\n\tlong long int quot;\r\n\tlong long int rem;\r\n} lldiv_t;\r\n\r\nlldiv_t lldiv(long long int, long long int);\r\n\r\nchar* getenv(const char*);\r\nwchar_t* _wgetenv(const wchar_t*);\r\nint _wputenv(const wchar_t*);\r\n\r\n\r\ndouble strtod(const char*, char**);\r\nfloat strtof(const char *, char**);\r\nlong double strtold(const char*, char**);\r\nvoid abort(void);\r\nlong int strtol(const char*, char**, int);\r\nlong long int strtoll(const char*, char**,int);\r\nunsigned long long int strtoull(const char*, char**, int);\r\nunsigned long strtoul(const char*, char**, int);\r\n\r\n\r\n#endif\r\n";
static char *	h__syslist="/* Header _syslist.h */\r\n";
static char *	h_string="/* Header string.h */\r\n\r\n#include <stddef.h>\r\n\r\nvoid* memcpy(void*, const void*, size_t);\r\nvoid* memmove(void*, void*, size_t);\r\nvoid* memset(void*, int, size_t);\r\nint memcmp(const void*, const void*, size_t);\r\nvoid* memchr(const void *, int, size_t);\r\n\r\nsize_t strlen(const char*);\r\nchar* strcpy(char*, const char*);\r\nchar* strncpy(char*, const char*, size_t);\r\nchar* strcat(char*, const char*);\r\nint strcmp(const char*, const char*);\r\nint strncmp(const char*, const char*, size_t);\r\nchar* strchr(const char*, int);\r\nchar* strstr(const char*, const char*);\r\nchar* strrchr(const char*, int);\r\nint _stricmp(const char*, const char*);\r\n#define stricmp _stricmp\r\n\r\nint strnicmp(const char*, const char*, size_t);\r\n\r\nsize_t strcspn(const char*, const char*);\r\nsize_t strspn(const char*, const char*);\r\nint strcoll(const char *, const char *);\r\n\r\nunsigned long strtoul(const char*, char**, int);\r\n\r\nchar* strerror(int);\r\nchar* strpbrk(const char*, const char*);\r\n\r\nchar*strupr(char*);\r\nchar* _strlwr(char*);\r\n#define strlwr _strlwr\r\n\r\nchar*strnupr(char*,size_t);\r\nchar*strnlwr(char*,size_t);\r\nint strtrim(char*);\r\nchar*strrev(char*);\r\n\r\nchar* _strdup(const char*);\r\n#define strdup _strdup\r\n";
static char *	h_time="/* Header time.h */\r\n\r\n#ifndef $time\r\n#define $time\r\n\r\n#include <stddef.h>\r\n\r\nunsigned int clock(void);\r\ntypedef unsigned long clock_t;\r\ntypedef unsigned long time_t;\r\n\r\nstruct tm\r\n{\r\n  int\ttm_sec;\r\n  int\ttm_min;\r\n  int\ttm_hour;\r\n  int\ttm_mday;\r\n  int\ttm_mon;\r\n  int\ttm_year;\r\n  int\ttm_wday;\r\n  int\ttm_yday;\r\n  int\ttm_isdst;\r\n};\r\n\r\n//struct tm *localtime(time_t*);\r\nstruct tm* _localtime32(time_t*);\r\n#define localtime _localtime32\r\n\r\ntime_t _time64(time_t *_timer);\r\n#define time _time64\r\n\r\n#define CLOCKS_PER_SEC 1000\r\n\r\nstruct tm *gmtime(const time_t*);\r\nsize_t strftime(char *, size_t, const char *, const struct tm *);\r\ntime_t mktime(struct tm *);\r\ndouble difftime(time_t, time_t);\r\n\r\n#endif\r\n";
static char *	h_utime="/* utime.h header */\r\n\r\n#include <sys/utime.h>\r\n";
static char *	h_unistd="/* unistd.h header */\r\n";
static char *	h_safelib="/* Header safelib.h */\r\n";
static char *	h_wchar="/* Header wchar.h */\r\n\r\n#include <stddef.h>\r\n\r\ntypedef unsigned short wint_t;\r\ntypedef unsigned short wchar_t;\r\n\r\nsize_t wcslen(const wchar_t*);\r\nwchar_t* wcscpy(wchar_t*,const wchar_t*);\r\n//wchar_t* _wgetenv(constwchar_t*);\r\nwchar_t* wcstok(wchar_t*,wchar_t*,wchar_t**);\r\nwchar_t* wcstok_s(wchar_t*,wchar_t*,wchar_t**);\r\n\r\nwchar_t* wcschr(wchar_t*,wchar_t);\r\n\r\n\r\nint wcscmp(const wchar_t*,const wchar_t*);\r\n";
static char *	h_wctype="/* Header wctype.h */\r\n";
static char *	h_systypes="/* types.h */\r\n";
static char *	h_sysstat="/* stat.h */\r\n\r\n#ifndef $sysstat\r\n#define $sysstat\r\n\r\ntypedef unsigned short ushort;\r\ntypedef long long int dint;\r\n\r\nstruct _stat {\r\n\tushort\t\tst_dev;\r\n\tushort\t\tst_ino;\r\n\tushort\t\tst_mode;\r\n\tshort\t\tst_nlink;\r\n\tshort\t\tst_uid;\r\n\tshort\t\tst_gid;\r\n\tushort\t\tst_rdev;\r\n\tdint\t\tst_size;\r\n\tdint\t\tst_atime;\r\n\tdint\t\tst_mtime;\r\n\tdint\t\tst_ctime;\r\n};\r\n\r\n#define stat _stat\r\n#define _stati64 _stat\r\n\r\n#define _S_IFMT 0xF000\r\n#define _S_IFDIR 0x4000\r\n#define _S_IFCHR 0x2000\r\n#define _S_IFIFO 0x1000\r\n#define _S_IFREG 0x8000\r\n#define _S_IREAD 0x0100\r\n#define _S_IWRITE 0x0080\r\n#define _S_IEXEC 0x0040\r\n\r\n#define S_IFMT 0xF000\r\n#define S_IFDIR 0x4000\r\n#define S_IFCHR 0x2000\r\n#define S_IFIFO 0x1000\r\n#define S_IFREG 0x8000\r\n#define S_IREAD 0x0100\r\n#define S_IWRITE 0x0080\r\n#define S_IEXEC 0x0040\r\n\r\nint stat(const char *, struct stat*);\r\n//int stat(const char *, struct stat*);\r\n\r\n\r\nint _fstati64(int, struct stat*);\r\n\r\n#endif\r\n";
static char *	h_systimeb="/* timeb.h */\r\n\r\n#ifndef $timeb\r\n#define $timeb\r\n\r\n#include <time.h>\r\n\r\nstruct _timeb {\r\n\ttime_t time;\r\n\tunsigned short millitm;\r\n\tshort timezone;\r\n\tshort dstflag;\r\n};\r\n#define timeb _timeb\r\n\r\nvoid _ftime64(struct _timeb*);\r\n#define _ftime _ftime64\r\n#define ftime _ftime64\r\n\r\n#endif\r\n";
static char *	h_sysutime="/* sys/utime.h header */\r\n\r\n#ifndef $utime\r\n#define $utime\r\n\r\nstruct _utimbuf {\r\n\tlong actime;\r\n\tlong modtime;\r\n};\r\n\r\n\r\n#endif\r\n";
static char *	h_memory="#include <malloc.h>\r\n";
static char *	h_windows="#ifndef $windows\r\n#define $windows 1\r\n\r\n#include <stdarg.h>\r\n\r\n#define CALLBACK\r\n#define WINAPI\t\r\n\r\n#define STILL_ACTIVE\t0x103\r\n\r\n#define PS_GEOMETRIC\t65536\r\n#define PS_COSMETIC\t0\r\n#define PS_ALTERNATE\t8\r\n#define PS_SOLID\t0\r\n#define PS_DASH\t1\r\n#define PS_DOT\t2\r\n#define PS_DASHDOT\t3\r\n#define PS_DASHDOTDOT\t4\r\n#define PS_NULL\t5\r\n#define PS_USERSTYLE\t7\r\n#define PS_INSIDEFRAME\t6\r\n#define PS_ENDCAP_ROUND\t0\r\n#define PS_ENDCAP_SQUARE\t256\r\n#define PS_ENDCAP_FLAT\t512\r\n#define PS_JOIN_BEVEL\t4096\r\n#define PS_JOIN_MITER\t8192\r\n#define PS_JOIN_ROUND\t0\r\n#define PS_STYLE_MASK\t15\r\n#define PS_ENDCAP_MASK\t3840\r\n#define PS_TYPE_MASK\t983040\r\n\r\n#define HTBOTTOM\t15\r\n#define HTBOTTOMLEFT\t16\r\n#define HTBOTTOMRIGHT\t17\r\n#define HTCAPTION\t2\r\n#define HTCLIENT\t1\r\n#define HTERROR\t(-2)\r\n#define HTGROWBOX\t4\r\n#define HTHSCROLL\t6\r\n#define HTLEFT\t10\r\n#define HTMENU\t5\r\n#define HTNOWHERE\t0\r\n#define HTREDUCE\t8\r\n#define HTRIGHT\t11\r\n#define HTSIZE\t4\r\n#define HTSYSMENU\t3\r\n#define HTTOP\t12\r\n#define HTTOPLEFT\t13\r\n#define HTTOPRIGHT\t14\r\n#define HTTRANSPARENT\t(-1)\r\n#define HTVSCROLL\t7\r\n#define HTZOOM\t9\r\n#define HTOBJECT\t19\r\n#define HTCLOSE\t20\r\n#define HTHELP\t21\r\n#define HTBORDER\t18\r\n#define HTMINBUTTON 8\r\n#define HTMAXBUTTON 9\r\n\r\n#define VK_LBUTTON\t1\r\n#define VK_RBUTTON\t2\r\n#define VK_CANCEL\t3\r\n#define VK_MBUTTON\t4\r\n#define VK_BACK\t8\r\n#define VK_TAB\t9\r\n#define VK_CLEAR\t12\r\n#define VK_RETURN\t13\r\n#define VK_SHIFT\t16\r\n#define VK_CONTROL\t17\r\n#define VK_MENU\t18\r\n#define VK_PAUSE\t19\r\n#define VK_PRINT\t42\r\n#define VK_CAPITAL\t20\r\n#define VK_KANA\t0x15\r\n#define VK_HANGEUL\t0x15\r\n#define VK_HANGUL\t0x15\r\n#define VK_JUNJA\t0x17\r\n#define VK_FINAL\t0x18\r\n#define VK_HANJA\t0x19\r\n#define VK_KANJI\t0x19\r\n#define VK_CONVERT\t0x1C\r\n#define VK_NONCONVERT\t0x1D\r\n#define VK_ACCEPT\t0x1E\r\n#define VK_MODECHANGE\t0x1F\r\n#define VK_ESCAPE\t27\r\n#define VK_SPACE\t32\r\n#define VK_PRIOR\t33\r\n#define VK_NEXT\t34\r\n#define VK_END\t35\r\n#define VK_HOME\t36\r\n#define VK_LEFT\t37\r\n#define VK_UP\t38\r\n#define VK_RIGHT\t39\r\n#define VK_DOWN\t40\r\n#define VK_SELECT\t41\r\n#define VK_EXECUTE\t43\r\n#define VK_SNAPSHOT\t44\r\n#define VK_INSERT\t45\r\n#define VK_DELETE\t46\r\n#define VK_HELP\t47\r\n#define VK_0\t48\r\n#define VK_1\t49\r\n#define VK_2\t50\r\n#define VK_3\t51\r\n#define VK_4\t52\r\n#define VK_5\t53\r\n#define VK_6\t54\r\n#define VK_7\t55\r\n#define VK_8\t56\r\n#define VK_9\t57\r\n#define VK_A\t65\r\n#define VK_B\t66\r\n#define VK_C\t67\r\n#define VK_D\t68\r\n#define VK_E\t69\r\n#define VK_F\t70\r\n#define VK_G\t71\r\n#define VK_H\t72\r\n#define VK_I\t73\r\n#define VK_J\t74\r\n#define VK_K\t75\r\n#define VK_L\t76\r\n#define VK_M\t77\r\n#define VK_N\t78\r\n#define VK_O\t79\r\n#define VK_P\t80\r\n#define VK_Q\t81\r\n#define VK_R\t82\r\n#define VK_S\t83\r\n#define VK_T\t84\r\n#define VK_U\t85\r\n#define VK_V\t86\r\n#define VK_W\t87\r\n#define VK_X\t88\r\n#define VK_Y\t89\r\n#define VK_Z\t90\r\n#define VK_LWIN\t0x5B\r\n#define VK_RWIN\t0x5C\r\n#define VK_APPS\t0x5D\r\n#define VK_NUMPAD0\t96\r\n#define VK_NUMPAD1\t97\r\n#define VK_NUMPAD2\t98\r\n#define VK_NUMPAD3\t99\r\n#define VK_NUMPAD4\t100\r\n#define VK_NUMPAD5\t101\r\n#define VK_NUMPAD6\t102\r\n#define VK_NUMPAD7\t103\r\n#define VK_NUMPAD8\t104\r\n#define VK_NUMPAD9\t105\r\n#define VK_MULTIPLY\t106\r\n#define VK_ADD\t107\r\n#define VK_SEPARATOR\t108\r\n#define VK_SUBTRACT\t109\r\n#define VK_DECIMAL\t110\r\n#define VK_DIVIDE\t111\r\n#define VK_F1\t112\r\n#define VK_F2\t113\r\n#define VK_F3\t114\r\n#define VK_F4\t115\r\n#define VK_F5\t116\r\n#define VK_F6\t117\r\n#define VK_F7\t118\r\n#define VK_F8\t119\r\n#define VK_F9\t120\r\n#define VK_F10\t121\r\n#define VK_F11\t122\r\n#define VK_F12\t123\r\n#define VK_F13\t124\r\n#define VK_F14\t125\r\n#define VK_F15\t126\r\n#define VK_F16\t127\r\n#define VK_F17\t128\r\n#define VK_F18\t129\r\n#define VK_F19\t130\r\n#define VK_F20\t131\r\n#define VK_F21\t132\r\n#define VK_F22\t133\r\n#define VK_F23\t134\r\n#define VK_F24\t135\r\n#define VK_NUMLOCK\t144\r\n#define VK_SCROLL\t145\r\n#define VK_LSHIFT\t160\r\n#define VK_LCONTROL\t162\r\n#define VK_LMENU\t164\r\n#define VK_RSHIFT\t161\r\n#define VK_RCONTROL\t163\r\n#define VK_RMENU\t165\r\n\r\n#define FILE_TYPE_UNKNOWN\t0\r\n#define FILE_TYPE_DISK\t1\r\n#define FILE_TYPE_CHAR\t2\r\n#define FILE_TYPE_PIPE\t3\r\n#define FILE_TYPE_REMOTE 0x8000\r\n\r\n#define PM_NOREMOVE\t0\r\n#define PM_REMOVE\t1\r\n#define PM_NOYIELD\t2\r\n\r\n#define LOWORD(l) (((WORD) (l)) & 0xFFFF)\r\n#define HIWORD(l) ((WORD) (((DWORD) (l) >> 16) & 0xFFFF))\r\n\r\n#define ERROR_BROKEN_PIPE 109\r\n\r\n#define WM_NULL\t0\r\n#define WM_APP\t0x8000\r\n#define WM_ACTIVATE\t6\r\n#define WM_ACTIVATEAPP\t28\r\n#define WM_ASKCBFORMATNAME\t780\r\n#define WM_CANCELJOURNAL\t75\r\n#define WM_CANCELMODE\t31\r\n#define WM_CAPTURECHANGED\t533\r\n#define WM_CHANGECBCHAIN\t781\r\n#define WM_CHAR\t258\r\n#define WM_CHARTOITEM\t47\r\n#define WM_CHILDACTIVATE\t34\r\n#define WM_CHOOSEFONT_GETLOGFONT\t1025\r\n#define WM_CHOOSEFONT_SETLOGFONT\t1125\r\n#define WM_CHOOSEFONT_SETFLAGS\t1126\r\n#define WM_CLEAR\t771\r\n#define WM_CLOSE\t16\r\n\r\n//!========"
"=========\r\n\r\n#define WM_COMMAND\t273\r\n#define WM_COMPACTING\t65\r\n#define WM_COMPAREITEM\t57\r\n#define WM_CONTEXTMENU\t123\r\n#define WM_COPY\t769\r\n#define WM_COPYDATA\t74\r\n#define WM_CREATE\t1\r\n#define WM_CTLCOLORBTN\t309\r\n#define WM_CTLCOLORDLG\t310\r\n#define WM_CTLCOLOREDIT\t307\r\n#define WM_CTLCOLORLISTBOX\t308\r\n#define WM_CTLCOLORMSGBOX\t306\r\n#define WM_CTLCOLORSCROLLBAR\t311\r\n#define WM_CTLCOLORSTATIC\t312\r\n#define WM_CUT\t768\r\n#define WM_DEADCHAR\t259\r\n#define WM_DELETEITEM\t45\r\n#define WM_DESTROY\t2\r\n#define WM_DESTROYCLIPBOARD\t775\r\n#define WM_DEVICECHANGE\t537\r\n#define WM_DEVMODECHANGE\t27\r\n#define WM_DISPLAYCHANGE\t126\r\n#define WM_DRAWCLIPBOARD\t776\r\n#define WM_DRAWITEM\t43\r\n#define WM_DROPFILES\t563\r\n#define WM_ENABLE\t10\r\n#define WM_ENDSESSION\t22\r\n#define WM_ENTERIDLE\t289\r\n#define WM_ENTERMENULOOP\t529\r\n#define WM_ENTERSIZEMOVE\t561\r\n#define WM_ERASEBKGND\t20\r\n#define WM_EXITMENULOOP\t530\r\n#define WM_EXITSIZEMOVE\t562\r\n#define WM_FONTCHANGE\t29\r\n#define WM_GETDLGCODE\t135\r\n#define WM_GETFONT\t49\r\n#define WM_GETHOTKEY\t51\r\n#define WM_GETICON\t127\r\n#define WM_GETMINMAXINFO\t36\r\n#define WM_GETTEXT\t13\r\n#define WM_GETTEXTLENGTH\t14\r\n#define WM_HELP\t83\r\n#define WM_HOTKEY\t786\r\n#define WM_HSCROLL\t276\r\n#define WM_HSCROLLCLIPBOARD\t782\r\n#define WM_ICONERASEBKGND\t39\r\n#define WM_IME_CHAR\t646\r\n#define WM_IME_COMPOSITION\t271\r\n#define WM_IME_COMPOSITIONFULL\t644\r\n#define WM_IME_CONTROL\t643\r\n#define WM_IME_ENDCOMPOSITION\t270\r\n#define WM_IME_KEYDOWN\t656\r\n#define WM_IME_KEYUP\t657\r\n#define WM_IME_NOTIFY\t642\r\n#define WM_IME_SELECT\t645\r\n#define WM_IME_SETCONTEXT\t641\r\n#define WM_IME_STARTCOMPOSITION\t269\r\n#define WM_INITDIALOG\t272\r\n#define WM_INITMENU\t278\r\n#define WM_INITMENUPOPUP\t279\r\n#define WM_INPUTLANGCHANGE\t81\r\n#define WM_INPUTLANGCHANGEREQUEST\t80\r\n#define WM_INPUT 0xff\r\n#define WM_KEYDOWN\t256\r\n#define WM_KEYUP\t257\r\n#define WM_KILLFOCUS\t8\r\n#define WM_LBUTTONDBLCLK\t515\r\n#define WM_LBUTTONDOWN\t513\r\n#define WM_LBUTTONUP\t514\r\n#define WM_MBUTTONDBLCLK\t521\r\n#define WM_MBUTTONDOWN\t519\r\n#define WM_MBUTTONUP\t520\r\n#define WM_MDIACTIVATE\t546\r\n#define WM_MDICASCADE\t551\r\n#define WM_MDICREATE\t544\r\n#define WM_MDIDESTROY\t545\r\n#define WM_MDIGETACTIVE\t553\r\n#define WM_MDIICONARRANGE\t552\r\n#define WM_MDIMAXIMIZE\t549\r\n#define WM_MDINEXT\t548\r\n#define WM_MDIREFRESHMENU\t564\r\n#define WM_MDIRESTORE\t547\r\n#define WM_MDISETMENU\t560\r\n#define WM_MDITILE\t550\r\n#define WM_MEASUREITEM\t44\r\n#define WM_MENUCHAR\t288\r\n#define WM_MENUSELECT\t287\r\n#define WM_MENURBUTTONUP 0x0122\r\n#define WM_MENUDRAG\t0x0123\r\n#define WM_MENUGETOBJECT 0x0124\r\n#define WM_UNINITMENUPOPUP 0x0125\r\n#define WM_MENUCOMMAND\t0x0126\r\n#define WM_CHANGEUISTATE 0x0127\r\n#define WM_UPDATEUISTATE 0x0128\r\n#define WM_QUERYUISTATE\t0x0129\r\n#define UIS_SET\t1\r\n#define UIS_CLEAR\t2\r\n#define UIS_INITIALIZE  3\r\n#define WM_MOUSEACTIVATE\t33\r\n#define WM_MOUSEMOVE\t512\r\n#define WM_MOUSEHOVER\t0x2a1\r\n#define WM_MOUSELEAVE\t0x2a3\r\n#define WM_MOUSEWHEEL\t0x20A\r\n#define WM_MOVE\t3\r\n#define WM_MOVING\t534\r\n#define WM_NCACTIVATE\t134\r\n#define WM_NCCALCSIZE\t131\r\n#define WM_NCCREATE\t129\r\n#define WM_NCDESTROY\t130\r\n#define WM_NCHITTEST\t132\r\n#define WM_NCLBUTTONDBLCLK\t163\r\n#define WM_NCLBUTTONDOWN\t161\r\n#define WM_NCLBUTTONUP\t162\r\n#define WM_NCMBUTTONDBLCLK\t169\r\n#define WM_NCMBUTTONDOWN\t167\r\n#define WM_NCMBUTTONUP\t168\r\n#define WM_NCMOUSEMOVE\t160\r\n#define WM_NCPAINT\t133\r\n#define WM_NCRBUTTONDBLCLK\t166\r\n#define WM_NCRBUTTONDOWN\t164\r\n#define WM_NCRBUTTONUP\t165\r\n#define WM_NEXTDLGCTL\t40\r\n#define WM_NOTIFY\t78\r\n#define WM_NOTIFYFORMAT\t85\r\n#define WM_PAINT\t15\r\n#define WM_PAINTCLIPBOARD\t777\r\n#define WM_PAINTICON\t38\r\n#define WM_PALETTECHANGED\t785\r\n#define WM_PALETTEISCHANGING\t784\r\n#define WM_PARENTNOTIFY\t528\r\n#define WM_PASTE\t770\r\n#define WM_PENWINFIRST\t896\r\n#define WM_SYNCPAINT\t0x0088\r\n#define WM_AFXFIRST\t0x0360\r\n#define WM_AFXLAST\t0x037F\r\n#define WM_HANDHELDFIRST 0x0358\r\n#define WM_HANDHELDLAST 0x035F\r\n#define WM_PENWINLAST\t911\r\n#define WM_POWER\t72\r\n#define WM_POWERBROADCAST\t536\r\n#define WM_PRINT\t791\r\n#define WM_PRINTCLIENT\t792\r\n#define WM_PSD_ENVSTAMPRECT\t1029\r\n#define WM_PSD_FULLPAGERECT\t1025\r\n#define WM_PSD_GREEKTEXTRECT\t1028\r\n#define WM_PSD_MARGINRECT\t1027\r\n#define WM_PSD_MINMARGINRECT\t1026\r\n#define WM_PSD_PAGESETUPDLG\t1024\r\n#define WM_PSD_YAFULLPAGERECT\t1030\r\n#define WM_QUERYDRAGICON\t55\r\n#define WM_QUERYENDSESSION\t17\r\n#define WM_QUERYNEWPALETTE\t783\r\n#define WM_QUERYOPEN\t19\r\n#define WM_QUEUESYNC\t35\r\n#define WM_QUIT\t18\r\n#define WM_RBUTTONDBLCLK\t518\r\n#define WM_RBUTTONDOWN\t516\r\n#define WM_RBUTTONUP\t517\r\n#define WM_RENDERALLFORMATS\t774\r\n#define WM_RENDERFORMAT\t773\r\n#define WM_SETCURSOR\t32\r\n#define WM_SETFOCUS\t7\r\n#define WM_SETFONT\t48\r\n#define WM_SETHOTKEY\t50\r\n#define WM_SETICON\t128\r\n#define WM_SETREDRAW\t11\r\n#define WM_SETTEXT\t12\r\n#define WM_SETTINGCHANGE\t26\r\n#define WM_SHOWWINDOW\t24\r\n#define WM_SIZE\t5\r\n#define WM_SIZECLIPBOARD\t779\r\n#define WM_SIZING\t532\r\n#define WM_SPOOLERSTATUS\t42\r\n#define WM_STYLECHANGED\t125\r\n#define WM_STYLECHANGING\t124\r\n#define WM_SYSCHAR\t262\r\n#define WM_SYSCOLORCHANGE\t21\r\n#define WM_SYSCOMMAND\t274\r\n#define WM_SYSDEADCHAR\t263\r\n#define WM_SYSKEYDOWN\t260\r\n#define WM_SYSKEYUP\t261\r\n#define WM_TCARD\t82\r\n#define WM_TIMECHANGE\t30\r\n#define WM_TIMER\t275\r\n#define WM_UNDO\t772\r\n#define WM_USER\t1024\r\n#define WM_USERCHANGED\t84\r\n#define WM_VKEYTOITEM\t46\r\n#define WM_VSCROLL\t277\r\n#define WM_VSCROLLCLIPBOARD\t778\r\n#define WM_WINDOWPOSCHANGED\t71\r\n#define WM_WINDOWPOSCHANGING\t70\r\n#define WM_XBUTTONDOWN\t0x020B\r\n#define WM_XBUTTONUP\t0x020C\r\n#define WM_XBUTTONDBLCLK\t0x020D\r\n#define WM_WININICHANGE\t26\r\n#define WM_KEYFIRST\t256\r\n#define WM_KEYLAST\t264\r\n#define WM_MOUSEFIRST\t512\r\n#define WM_MOUSELAST 0x020D\r\n#define WM_NEXTMENU\t0x0213\r\n#define WM_CHANGEUISTATE\t0x0127\r\n#define WM_UPDATEUISTATE\t0x0128\r\n#define WM_QUERYUISTATE\t0x0129\r\n#define WM_WTSSESSION_CHANGE 0x02B1\r\n#define WM_LBTRACKPOINT\t0x0131\r\n#define WM_GETOBJECT 0x003D\r\n#define WM_COMMNOTIFY 0x0044\r\n#define WM_TABLET_FIRST\t0x02c0\r\n#define WM_TABLET_LAST\t0x02df\r\n#define WM_IME_REQUEST\t0x0288\r\n#define WM_IME_KEYLAST  0x010F\r\n#define WM_NCMOUSEHOVER\t0x02A0\r\n#define WM_NCMOUSELEAVE 0x02A2\r\n\r\n//!========"
"=========\r\n\r\n\r\n#define INVALID_HANDLE_VALUE (HANDLE)(0xffffffff)\r\n#define MEM_RESERVE 8192\r\n#define MEM_COMMIT 4096\r\n#define PAGE_READWRITE 4\r\n#define PAGE_WRITECOPY 8\r\n#define PAGE_EXECUTE_READ\t32\r\n#define MEM_TOP_DOWN 1048576\r\n#define MEM_RELEASE\t32768\r\n#define MAX_PATH 260\r\n#define FORMAT_MESSAGE_IGNORE_INSERTS 512\r\n#define FORMAT_MESSAGE_FROM_SYSTEM 4096\r\n#define WAIT_OBJECT_0 0\r\n#define MAX_PATH 260\r\n#define STD_INPUT_HANDLE\t(DWORD)(0xfffffff6)\r\n#define STD_OUTPUT_HANDLE\t(DWORD)(0xfffffff5)\r\n#define STD_ERROR_HANDLE\t(DWORD)(0xfffffff4)\r\n#define ENABLE_LINE_INPUT\t2\r\n#define ENABLE_ECHO_INPUT\t4\r\n#define ENABLE_PROCESSED_INPUT\t1\r\n#define ENABLE_WINDOW_INPUT\t8\r\n#define ENABLE_MOUSE_INPUT\t16\r\n#define ENABLE_PROCESSED_OUTPUT\t1\r\n#define CONST const\r\n\r\n#define CAPSLOCK_ON\t128\r\n#define ENHANCED_KEY\t256\r\n#define LEFT_ALT_PRESSED\t2\r\n#define LEFT_CTRL_PRESSED\t8\r\n#define NUMLOCK_ON\t32\r\n#define RIGHT_ALT_PRESSED\t1\r\n#define RIGHT_CTRL_PRESSED\t4\r\n#define SCROLLLOCK_ON\t64\r\n#define SHIFT_PRESSED\t16\r\n#define FROM_LEFT_1ST_BUTTON_PRESSED\t1\r\n#define RIGHTMOST_BUTTON_PRESSED\t2\r\n#define FROM_LEFT_2ND_BUTTON_PRESSED\t4\r\n#define FROM_LEFT_3RD_BUTTON_PRESSED\t8\r\n#define FROM_LEFT_4TH_BUTTON_PRESSED\t16\r\n#define DOUBLE_CLICK\t2\r\n#define MOUSE_MOVED\t1\r\n#define KEY_EVENT\t1\r\n#define MOUSE_EVENT\t2\r\n#define WINDOW_BUFFER_SIZE_EVENT\t4\r\n#define MENU_EVENT\t8\r\n#define FOCUS_EVENT\t16\r\n\r\n/*\r\nproc\r\n*/\r\n\r\ntypedef unsigned char BYTE;\r\ntypedef BYTE* LPBYTE;\r\ntypedef struct {int dummy;} *HWND;\r\ntypedef const char *LPCSTR;\r\ntypedef char *LPSTR;\r\ntypedef unsigned int UINT;\r\ntypedef void* HANDLE;\r\ntypedef void* HINSTANCE;\r\ntypedef void* HMODULE;\r\ntypedef void* HLOCAL;\r\ntypedef void* LPVOID;\r\ntypedef void* LPWSTR;\r\ntypedef const void* LPCWSTR;\r\ntypedef const void* LPCVOID;\r\ntypedef void* PVOID;\r\ntypedef int LONG;\r\ntypedef unsigned int ULONG;\r\ntypedef unsigned short WORD;\r\ntypedef unsigned int DWORD;\r\ntypedef DWORD* PDWORD;\r\ntypedef DWORD* LPDWORD;\r\ntypedef int BOOL;\r\ntypedef void VOID;\r\ntypedef long long LONG_PTR;\r\ntypedef unsigned long long ULONG_PTR;\r\ntypedef ULONG_PTR DWORD_PTR;\r\ntypedef char CHAR;\r\ntypedef unsigned short WCHAR;\r\ntypedef short int SHORT;\r\ntypedef WORD* LPWORD;\r\ntypedef BOOL (CALLBACK *PHANDLER_ROUTINE) (DWORD);\r\ntypedef unsigned long long UINT_PTR;\r\ntypedef UINT_PTR WPARAM;\r\ntypedef LONG_PTR LPARAM;\r\ntypedef BYTE *PBYTE;\r\ntypedef unsigned long COLORREF;\r\n\r\ntypedef HANDLE HDC;\r\ntypedef HANDLE HBITMAP;\r\ntypedef HANDLE HPEN;\r\ntypedef HANDLE HBRUSH;\r\ntypedef HANDLE *PHANDLE;\r\ntypedef HANDLE HMENU;\r\ntypedef HANDLE HGDIOBJ;\r\n\r\n/*\r\nproc\r\n*/\r\n\r\ntypedef struct tagPOINT {\r\n\tLONG x;\r\n\tLONG y;\r\n} POINT,*PPOINT;\r\n\r\ntypedef struct tagMSG {\r\n\tHWND hwnd;\r\n\tUINT message;\r\n\tWPARAM wParam;\r\n\tLPARAM lParam;\r\n\tDWORD time;\r\n\tPOINT pt;\r\n} MSG,*LPMSG,*PMSG;\r\n\r\ntypedef struct _LIST_ENTRY {\r\n\tstruct _LIST_ENTRY *Flink;\r\n\tstruct _LIST_ENTRY *Blink;\r\n} LIST_ENTRY,*PLIST_ENTRY;\r\n\r\ntypedef struct _CONSOLE_CURSOR_INFO {\r\n\tDWORD dwSize;\r\n\tBOOL bVisible;\r\n} CONSOLE_CURSOR_INFO,*PCONSOLE_CURSOR_INFO;\r\n\r\ntypedef struct {\r\n\tPVOID BaseAddress;\r\n\tPVOID AllocationBase;\r\n\tDWORD AllocationProtect;\r\n\tDWORD RegionSize;\r\n\tDWORD State;\r\n\tDWORD Protect;\r\n\tDWORD Type;\r\n} MEMORY_BASIC_INFORMATION;\r\n\r\ntypedef struct _RTL_CRITICAL_SECTION_DEBUG {\r\n\tWORD Type;\r\n\tWORD CreatorBackTraceIndex;\r\n\tstruct _RTL_CRITICAL_SECTION *CriticalSection;\r\n\tLIST_ENTRY ProcessLocksList;\r\n\tDWORD EntryCount;\r\n\tDWORD ContentionCount;\r\n\tDWORD Spare[ 2];\r\n} RTL_CRITICAL_SECTION_DEBUG,*PRTL_CRITICAL_SECTION_DEBUG;\r\n\r\ntypedef struct {\r\n\tPRTL_CRITICAL_SECTION_DEBUG DebugInfo;\r\n\tLONG LockCount;\r\n\tLONG RecursionCount;\r\n\tHANDLE OwningThread;\r\n\tHANDLE LockSemaphore;\r\n\tULONG_PTR SpinCount;\r\n} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;\r\n\r\ntypedef RTL_CRITICAL_SECTION CRITICAL_SECTION,*LPCRITICAL_SECTION;\r\n\r\ntypedef struct _SECURITY_ATTRIBUTES {\r\n\tDWORD nLength;\r\n\tLPVOID lpSecurityDescriptor;\r\n\tBOOL bInheritHandle;\r\n} SECURITY_ATTRIBUTES,*LPSECURITY_ATTRIBUTES;\r\n\r\ntypedef enum _GET_FILEEX_INFO_LEVELS { GetFileExInfoStandard, GetFileExMaxInfoLevel } GET_FILEEX_INFO_LEVELS;\r\n\r\ntypedef struct tagFILETIME {\r\n\tDWORD dwLowDateTime;\r\n\tDWORD dwHighDateTime;\r\n} FILETIME,*LPFILETIME,*PFILETIME;\r\n\r\ntypedef struct _WIN32_FIND_DATAA {\r\n\tDWORD dwFileAttributes;\r\n\tFILETIME ftCreationTime;\r\n\tFILETIME ftLastAccessTime;\r\n\tFILETIME ftLastWriteTime;\r\n\tDWORD nFileSizeHigh;\r\n\tDWORD nFileSizeLow;\r\n\tDWORD dwReserved0;\r\n\tDWORD dwReserved1;\r\n\tCHAR   cFileName[ MAX_PATH ];\r\n\tCHAR   cAlternateFileName[ 14 ];\r\n} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;\r\n\r\ntypedef struct _WIN32_FIND_DATAW {\r\n\tDWORD dwFileAttributes;\r\n\tFILETIME ftCreationTime;\r\n\tFILETIME ftLastAccessTime;\r\n\tFILETIME ftLastWriteTime;\r\n\tDWORD nFileSizeHigh;\r\n\tDWORD nFileSizeLow;\r\n\tDWORD dwReserved0;\r\n\tDWORD dwReserved1;\r\n\tWCHAR  cFileName[ MAX_PATH ];\r\n\tWCHAR  cAlternateFileName[ 14 ];\r\n} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;\r\n\r\ntypedef struct _COORD {\r\n\tSHORT X;\r\n\tSHORT Y;\r\n} COORD;\r\n//!========"
"=========\r\n\r\ntypedef struct _CHAR_INFO {\r\n\tunion { WCHAR UnicodeChar; CHAR AsciiChar; } Char;\r\n\tWORD Attributes;\r\n} CHAR_INFO,*PCHAR_INFO;\r\n\r\ntypedef struct _SMALL_RECT {\r\n\tSHORT Left;\r\n\tSHORT Top;\r\n\tSHORT Right;\r\n\tSHORT Bottom;\r\n} SMALL_RECT,*PSMALL_RECT;\r\n\r\ntypedef struct _FOCUS_EVENT_RECORD {\r\n\tBOOL bSetFocus;\r\n} FOCUS_EVENT_RECORD;\r\n\r\ntypedef struct _CONSOLE_SCREEN_BUFFER_INFO {\r\n\tCOORD dwSize;\r\n\tCOORD dwCursorPosition;\r\n\tWORD wAttributes;\r\n\tSMALL_RECT srWindow;\r\n\tCOORD dwMaximumWindowSize;\r\n} CONSOLE_SCREEN_BUFFER_INFO,*PCONSOLE_SCREEN_BUFFER_INFO;\r\n\r\ntypedef struct _KEY_EVENT_RECORD {\r\n\tBOOL bKeyDown;\r\n\tWORD wRepeatCount;\r\n\tWORD wVirtualKeyCode;\r\n\tWORD wVirtualScanCode;\r\n\tunion { WCHAR UnicodeChar; CHAR AsciiChar; } uChar;\r\n\tDWORD dwControlKeyState;\r\n} KEY_EVENT_RECORD;\r\n\r\ntypedef struct _MOUSE_EVENT_RECORD {\r\n\tCOORD dwMousePosition;\r\n\tDWORD dwButtonState;\r\n\tDWORD dwControlKeyState;\r\n\tDWORD dwEventFlags;\r\n} MOUSE_EVENT_RECORD;\r\n\r\ntypedef struct _WINDOW_BUFFER_SIZE_RECORD {\r\n\tCOORD dwSize;\r\n} WINDOW_BUFFER_SIZE_RECORD;\r\n\r\ntypedef struct _MENU_EVENT_RECORD {\r\n\tUINT dwCommandId;\r\n} MENU_EVENT_RECORD,*PMENU_EVENT_RECORD;\r\n\r\ntypedef struct _INPUT_RECORD {\r\n\tWORD EventType;\r\n\tWORD __alignmentDummy;\r\n\tunion {\r\n\t\tKEY_EVENT_RECORD KeyEvent;\r\n\t\tMOUSE_EVENT_RECORD MouseEvent;\r\n\t\tWINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;\r\n\t\tMENU_EVENT_RECORD MenuEvent;\r\n\t\tFOCUS_EVENT_RECORD FocusEvent;\r\n\t} Event;\r\n} INPUT_RECORD,*PINPUT_RECORD;\r\n\r\ntypedef struct _STARTUPINFOW {\r\n\tDWORD cb;\r\n\tLPWSTR lpReserved;\r\n\tLPWSTR lpDesktop;\r\n\tLPWSTR lpTitle;\r\n\tDWORD dwX;\r\n\tDWORD dwY;\r\n\tDWORD dwXSize;\r\n\tDWORD dwYSize;\r\n\tDWORD dwXCountChars;\r\n\tDWORD dwYCountChars;\r\n\tDWORD dwFillAttribute;\r\n\tDWORD dwFlags;\r\n\tWORD wShowWindow;\r\n\tWORD cbReserved2;\r\n\tLPBYTE lpReserved2;\r\n\tHANDLE hStdInput;\r\n\tHANDLE hStdOutput;\r\n\tHANDLE hStdError;\r\n} STARTUPINFOW, *LPSTARTUPINFOW;\r\n\r\ntypedef struct _PROCESS_INFORMATION {\r\n\tHANDLE hProcess;\r\n\tHANDLE hThread;\r\n\tDWORD dwProcessId;\r\n\tDWORD dwThreadId;\r\n} PROCESS_INFORMATION,*LPPROCESS_INFORMATION;\r\n\r\ntypedef struct _WIN32_FILE_ATTRIBUTE_DATA {\r\n\tDWORD dwFileAttributes;\r\n\tFILETIME ftCreationTime;\r\n\tFILETIME ftLastAccessTime;\r\n\tFILETIME ftLastWriteTime;\r\n\tDWORD nFileSizeHigh;\r\n\tDWORD nFileSizeLow;\r\n} WIN32_FILE_ATTRIBUTE_DATA,*LPWIN32_FILE_ATTRIBUTE_DATA;\r\n\r\n#define _FILETIME\r\n\r\n\r\n/*\r\nproc\r\n*/\r\n\r\n#ifdef UNICODE\r\n\ttypedef WIN32_FIND_DATAW WIN32_FIND_DATA;\r\n\ttypedef PWIN32_FIND_DATAW PWIN32_FIND_DATA;\r\n\ttypedef LPWIN32_FIND_DATAW LPWIN32_FIND_DATA;\r\n#else\r\n\ttypedef WIN32_FIND_DATAA WIN32_FIND_DATA;\r\n\ttypedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;\r\n\ttypedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;\r\n#endif\r\n\r\nint MessageBoxA(HWND,LPCSTR,LPCSTR,UINT);\r\n#define MessageBox MessageBoxA\r\n\r\ntypedef int (*FARPROC)();\r\n\r\nFARPROC GetProcAddress(HINSTANCE,const char*);\r\nHINSTANCE LoadLibraryA(LPCSTR);\r\nHMODULE GetModuleHandleA(char*);\r\n\r\nLPVOID VirtualAlloc(LPVOID,DWORD,DWORD,DWORD);\r\nBOOL VirtualFree(LPVOID,DWORD,DWORD);\r\nBOOL VirtualProtect(LPVOID,DWORD,DWORD,PDWORD);\r\nDWORD VirtualQuery(LPCVOID,MEMORY_BASIC_INFORMATION*,DWORD);\r\nHLOCAL LocalFree(HLOCAL);\r\nLPWSTR GetCommandLineW(VOID);\r\nLPWSTR* CommandLineToArgvW(LPCWSTR,int*);\r\nDWORD GetModuleFileNameA(HINSTANCE,LPSTR,DWORD);\r\nDWORD GetModuleFileNameW(HINSTANCE,LPWSTR,DWORD);\r\nDWORD GetLastError(VOID);\r\n\r\nDWORD FormatMessageA(DWORD,LPCVOID,DWORD,DWORD,LPSTR,DWORD,va_list *);\r\nLONG InterlockedCompareExchange(LONG volatile*, LONG, LONG);\r\nVOID InitializeCriticalSection(LPCRITICAL_SECTION);\r\nVOID DeleteCriticalSection(LPCRITICAL_SECTION);\r\nVOID EnterCriticalSection(LPCRITICAL_SECTION);\r\nVOID LeaveCriticalSection(LPCRITICAL_SECTION);\r\nDWORD GetCurrentThreadId(VOID);\r\nBOOL CloseHandle(HANDLE);\r\nBOOL FreeLibrary(HINSTANCE);\r\nBOOL AreFileApisANSI(VOID);\r\nVOID OutputDebugStringA(LPCSTR);\r\nHANDLE CreateFileA(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);\r\nHANDLE CreateFileW(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);\r\nHANDLE CreateFileMappingW(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCWSTR);\r\nHANDLE CreateFileMappingA(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCSTR);\r\nHANDLE CreateMutexW(LPSECURITY_ATTRIBUTES,BOOL,LPCWSTR);\r\nHANDLE CreateMutexA(LPSECURITY_ATTRIBUTES,BOOL,LPCSTR);\r\nBOOL DeleteFileA(LPCSTR);\r\nBOOL DeleteFileW(LPCWSTR);\r\nBOOL FlushFileBuffers(HANDLE);\r\nDWORD FormatMessageW(DWORD,LPCVOID,DWORD,DWORD,LPWSTR,DWORD,va_list *);\r\n//DWORD FormatMessageA(DWORD,LPCVOID,DWORD,DWORD,LPSTR,DWORD,va_list *);\r\nDWORD GetCurrentProcessId(VOID);\r\nBOOL GetDiskFreeSpaceW(LPCWSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD);\r\nBOOL GetDiskFreeSpaceA(LPCSTR,LPDWORD,LPDWORD,LPDWORD,LPDWORD);\r\nDWORD GetFileAttributesW(LPCWSTR);\r\nDWORD GetFileAttributesA(LPCSTR);\r\nBOOL GetFileAttributesExA(LPCSTR,GET_FILEEX_INFO_LEVELS,LPVOID);\r\nBOOL GetFileAttributesExW(LPCWSTR,GET_FILEEX_INFO_LEVELS,LPVOID);\r\nDWORD GetFileSize(HANDLE,LPDWORD);\r\nBOOL SetConsoleMode(HANDLE,DWORD);\r\nBOOL GetConsoleMode(HANDLE,LPDWORD);\r\nHANDLE GetStdHandle(DWORD);\r\nBOOL PeekConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);\r\nBOOL ReadConsoleInputW(HANDLE,PINPUT_RECORD,DWORD,LPDWORD);\r\nBOOL WriteConsoleInputW(HANDLE,CONST INPUT_RECORD *,DWORD,LPDWORD);\r\nBOOL ReadConsoleOutputW(HANDLE,PCHAR_INFO,COORD,COORD,PSMALL_RECT);\r\nBOOL WriteConsoleOutputW(HANDLE,CONST CHAR_INFO *,COORD,COORD,PSMALL_RECT);\r\nBOOL ReadConsoleOutputCharacterW(HANDLE,LPWSTR,DWORD,COORD,LPDWORD);\r\nBOOL WriteConsoleOutputCharacterW(HANDLE,LPCWSTR,DWORD,COORD,LPDWORD);\r\nBOOL FillConsoleOutputCharacterW(HANDLE,WCHAR,DWORD,COORD,LPDWORD);\r\nBOOL ScrollConsoleScreenBufferW(HANDLE,CONST SMALL_RECT *,CONST SMALL_RECT *,COORD,CONST CHAR_INFO *);\r\nDWORD GetConsoleTitleW(LPWSTR,DWORD);\r\nBOOL SetConsoleTitleW(LPCWSTR);\r\nBOOL ReadConsoleW(HANDLE,LPVOID,DWORD,LPDWORD,LPVOID);\r\nBOOL WriteConsoleW(HANDLE,CONST VOID *,DWORD,LPDWORD,LPVOID);\r\nBOOL ReadConsoleOutputAttribute(HANDLE,LPWORD,DWORD,COORD,LPDWORD);\r\nBOOL WriteConsoleOutputAttribute(HANDLE,CONST WORD *,DWORD,COORD,LPDWORD);\r\nBOOL FillConsoleOutputAttribute(HANDLE,WORD,DWORD,COORD,LPDWORD);\r\nBOOL GetConsoleMode(HANDLE,LPDWORD);\r\nBOOL GetNumberOfConsoleInputEvents(HANDLE,LPDWORD);\r\nBOOL GetConsoleScreenBufferInfo(HANDLE,PCONSOLE_SCREEN_BUFFER_INFO);\r\nCOORD GetLargestConsoleWindowSize(HANDLE);\r\nBOOL GetConsoleCursorInfo(HANDLE,PCONSOLE_CURSOR_INFO);\r\nBOOL GetNumberOfConsoleMouseButtons(LPDWORD);\r\nBOOL SetConsoleMode(HANDLE,DWORD);\r\nBOOL SetConsoleActiveScreenBuffer(HANDLE);\r\nBOOL FlushConsoleInputBuffer(HANDLE);\r\nBOOL SetConsoleScreenBufferSize(HANDLE,COORD);\r\nBOOL SetConsoleCursorPosition(HANDLE,COORD);\r\nBOOL SetConsoleCursorInfo(HANDLE,CONST CONSOLE_CURSOR_INFO *);\r\nBOOL SetConsoleWindowInfo(HANDLE,BOOL,CONST SMALL_RECT *);\r\nBOOL SetConsoleTextAttribute(HANDLE,WORD);\r\nBOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE,BOOL);\r\nBOOL GenerateConsoleCtrlEvent(DWORD,DWORD);\r\nBOOL AllocConsole(VOID);\r\nBOOL FreeConsole(VOID);\r\nHANDLE CreateConsoleScreenBuffer(DWORD,DWORD,CONST SECURITY_ATTRIBUTES *,DWORD,LPVOID);\r\nDWORD GetFileType(HANDLE);\r\nDWORD WaitForSingleObject(HANDLE,DWORD);\r\nBOOL PeekNamedPipe(HANDLE,LPVOID,DWORD,LPDWORD,LPDWORD,LPDWORD);\r\nBOOL CreatePipe(PHANDLE,PHANDLE,LPSECURITY_ATTRIBUTES,DWORD);\r\nBOOL GetMessageA(LPMSG,HWND,UINT,UINT);\r\nSHORT GetKeyState(int);\r\nBOOL TranslateMessage(CONST MSG *);\r\nBOOL PeekMessageA(LPMSG,HWND,UINT,UINT,UINT);\r\nLONG DispatchMessageA(CONST MSG *);\r\nBOOL IsWindow(HWND);\r\nBOOL IsMenu(HMENU);\r\nBOOL IsChild(HWND,HWND);\r\nBOOL DestroyWindow(HWND);\r\nBOOL ShowWindow(HWND,int);\r\nSHORT GetKeyState(int);\r\nSHORT GetAsyncKeyState(int);\r\nBOOL GetKeyboardState(PBYTE);\r\nBOOL SetKeyboardState(LPBYTE);\r\nint GetKeyboardType(int);\r\nBOOL GetExitCodeProcess(HANDLE,LPDWORD);\r\nBOOL TerminateProcess(HANDLE,UINT);\r\nBOOL SetHandleInformation(HANDLE,DWORD,DWORD);\r\nHANDLE FindFirstFileA(LPCSTR,LPWIN32_FIND_DATA);\r\nHPEN CreatePen(int,int,COLORREF);\r\nHBRUSH CreateSolidBrush(COLORREF);\r\nHGDIOBJ  SelectObject(HDC,HGDIOBJ);\r\n\r\n\r\n//!========"
"=========\r\n\r\n/*\r\nproc\r\n*/\r\n\r\n#ifdef UNICODE\r\n\t#define GetModuleHandle GetModuleHandleW\r\n\t#define LoadLibrary LoadLibraryW\r\n\t#define OutputDebugString OutputDebugStringW\r\n\t#define GetMessage GetMessageW\r\n\t#define PeekMessage PeekMessageW\r\n\t#define DispatchMessage DispatchMessageW\r\n#else\r\n\t#define GetModuleHandle GetModuleHandleA\r\n\t#define LoadLibrary LoadLibraryA\r\n\t#define OutputDebugString OutputDebugStringA\r\n\t#define GetMessage GetMessageA\r\n\t#define PeekMessage PeekMessageA\r\n\t#define DispatchMessage DispatchMessageA\r\n#endif\r\n\r\n#endif // windows.h\r\n";
static char *	h_fcntl="/* FCNTL.H */\r\n\r\nint _setmode(int,int);\r\n\r\n#ifndef _INC_FCNTL\r\n#define _INC_FCNTL\r\n\r\n#define _O_RDONLY 0x0000\r\n#define _O_WRONLY 0x0001\r\n#define _O_RDWR 0x0002\r\n#define _O_APPEND 0x0008\r\n#define _O_CREAT 0x0100\r\n#define _O_TRUNC 0x0200\r\n#define _O_EXCL 0x0400\r\n#define _O_TEXT 0x4000\r\n#define _O_BINARY 0x8000\r\n#define _O_WTEXT 0x10000\r\n#define _O_U16TEXT 0x20000\r\n#define _O_U8TEXT 0x40000\r\n#define _O_ACCMODE (_O_RDONLY|_O_WRONLY|_O_RDWR)\r\n\r\n#define _O_RAW _O_BINARY\r\n#define _O_NOINHERIT 0x0080\r\n#define _O_TEMPORARY 0x0040\r\n#define _O_SHORT_LIVED 0x1000\r\n\r\n#define _O_SEQUENTIAL 0x0020\r\n#define _O_RANDOM 0x0010\r\n\r\n#if !defined(NO_OLDNAMES) || defined(_POSIX)\r\n#define O_RDONLY _O_RDONLY\r\n#define O_WRONLY _O_WRONLY\r\n#define O_RDWR _O_RDWR\r\n#define O_APPEND _O_APPEND\r\n#define O_CREAT _O_CREAT\r\n#define O_TRUNC _O_TRUNC\r\n#define O_EXCL _O_EXCL\r\n#define O_TEXT _O_TEXT\r\n#define O_BINARY _O_BINARY\r\n#define O_RAW _O_BINARY\r\n#define O_TEMPORARY _O_TEMPORARY\r\n#define O_NOINHERIT _O_NOINHERIT\r\n#define O_SEQUENTIAL _O_SEQUENTIAL\r\n#define O_RANDOM _O_RANDOM\r\n#define O_ACCMODE _O_ACCMODE\r\n#endif\r\n\r\n#endif\r\n";
static char *	h_io="#include <stdint.h>\r\n\r\n#ifndef $io\r\n#define $io\r\n\r\n/* io.h */\r\n\r\n//#message \"IO included\"\r\n\r\nint _isatty(int);\r\n\r\nint _read(int, void*, unsigned int);\r\n#define read _read\r\n\r\nint _open(const char*, int, ...);\r\n#define open _open\r\n\r\nlong _lseek(int, long, int);\r\n#define lseek _lseek\r\n\r\nint _close(int);\r\n#define close _close\r\n\r\nintptr_t _get_osfhandle(int);\r\nint _open_osfhandle(intptr_t,int);\r\n\r\nint _setmode(int,int);\r\n#define setmode _setmode\r\n\r\nint _wchmod(const wchar_t*, int);\r\n\r\n#endif\r\n";
static char *	h_direct="#ifndef $direct\r\n#define $direct\r\n\r\ntypedef struct {\r\n unsigned int total_clusters;\r\n unsigned int avail_clusters;\r\n unsigned int sectors_per_cluster;\r\n unsigned int bytes_per_sector;\r\n} diskfree_t;\r\n\r\nint chdir(const char *);\r\nchar* _getcwd(char *, int);\r\n#define getcwd _getcwd\r\nint mkdir(const char *);\r\nint rmdir(const char *);\r\nint _wrmdir(const wchar_t*);\r\nint _wmkdir(const wchar_t*);\r\n\r\nint _chdrive(int);\r\nchar* _getdcwd(int, char *, int);\r\nwchar_t* _wgetcwd(wchar_t*, int);\r\nint _wchdir(const wchar_t*);\r\nint _getdrive(void);\r\n\r\nunsigned long _getdrives(void);\r\nunsigned int _getdiskfree(unsigned int, diskfree_t*);\r\n\r\n#endif\r\n\r\n";
static char *	h_process="/* Header process.h */\r\n#ifndef $process\r\n#define $process\r\n\r\n#define P_WAIT\t\t0\r\n#define P_NOWAIT\t1\r\n#define P_OVERLAY\t2\r\n#define P_DETACH\t4\r\n#define WAIT_CHILD 0\r\n#define _P_WAIT P_WAIT\r\n#define _P_NOWAIT P_NOWAIT\r\n#define _P_OVERLAY P_OVERLAY\r\n\r\nint _spawnvp(int, const char*, char*const*);\r\n#define spawnvp _spawnvp\r\n\r\nvoid endthread(void);\r\nunsigned long _beginthreadex(void *,unsigned,unsigned (*)(void *),void *,unsigned,unsigned *);\r\nvoid _endthreadex(unsigned);\r\nint _cwait(int*, int, int);\r\n#define cwait _cwait\r\n//int _System(const char *cmd,int nCmdShow);\r\n\r\n//#define _WAIT_CHILD\t0\r\n//#endif\r\n#endif\r\n\r\n";
static char *	h_malloc="#include <stddef.h>\r\n\r\nvoid* malloc(size_t);\r\nvoid* realloc(void *, size_t);\r\nvoid  free(void *);\r\n";
       char *	stdhdrnames[37]={"assert.h",
"ctype.h",
"errno.h",
"fenv.h",
"float.h",
"inttypes.h",
"stdint.h",
"limits.h",
"locale.h",
"_ansi.h",
"math.h",
"setjmp.h",
"signal.h",
"stdarg.h",
"stdbool.h",
"stddef.h",
"stdio.h",
"stdlib.h",
"_syslist.h",
"string.h",
"time.h",
"utime.h",
"unistd.h",
"safelib.h",
"wchar.h",
"wctype.h",
"sys/types.h",
"sys/stat.h",
"sys/timeb.h",
"sys/utime.h",
"malloc.h",
"windows.h",
"fcntl.h",
"io.h",
"direct.h",
"process.h",
"memory.h"
};
       char * *	stdhdrtext[37]={&h_assert,
&h_ctype,
&h_errno,
&h_fenv,
&h_float,
&h_inttypes,
&h_stdint,
&h_limits,
&h_locale,
&h__ansi,
&h_math,
&h_setjmp,
&h_signal,
&h_stdarg,
&h_stdbool,
&h_stddef,
&h_stdio,
&h_stdlib,
&h__syslist,
&h_string,
&h_time,
&h_utime,
&h_unistd,
&h_safelib,
&h_wchar,
&h_wctype,
&h_systypes,
&h_sysstat,
&h_systimeb,
&h_sysutime,
&h_malloc,
&h_windows,
&h_fcntl,
&h_io,
&h_direct,
&h_process,
&h_memory
};

// From module: cc_lex
/* Local Static Variables */
static int32	longestname=0;
static int32	DEPTH=0;
static int32	MAXLEN=0;
static tokenrec *	tkptr=0;
static int32	dowhitespace=0;
static strec *	globalmacrolist;
static int32	NIFDEFS;
static tokenrec	normaltkx;
static tokenrec *	normaltk=&normaltkx;
static int32	noexpand=0;
static stackinforec	lx_stack[20];
static int32	lx_stackindex;
static int32	ifcondlevel=0;
static byte *	lxstart;
static byte *	lxsptr;
static int32	lxhashvalue;
static byte *	lxsvalue;
static char	alphamap[256];
static char	digitmap[256];
static char	commentmap[256];
static char	linecommentmap[256];
static char	spacemap[256];
static strbuffer *	destcopy;
static char *	pastedtokenlist[3500];
static int32	npastedtokens=0;

// From module: cc_lib
/* Local Static Variables */
static int32	autotypeno=0;
static int32	currlineno;
       int32	nextafindex=0;
static strbuffer	exprstrvar;
static strbuffer *	exprstr=&exprstrvar;
static byte *	unitheapptr=0;
static int32	remainingunits=0;

// From module: cc_parse
/* Local Static Variables */
static int32	NALLEXPRS;
static int32	NSMALLEXPRS;
static strec *	ist_symptr;
static byte	looptypestack[100];
static int32	loopindex;
static caserec *	casevaluestack[100];
static byte	iscallbackfn;

// From module: cc_libtcl
/* Local Static Variables */
       char *	tclnames[79]={"t_comment",
"t_blank",
"t_source",
"t_end",
"t_tempdata",
"t_setret",
"t_stmt",
"t_assem",
"t_param",
"t_eval",
"t_move",
"t_copylist",
"t_copyblock",
"t_clearblock",
"t_getptr",
"t_index",
"t_indexlv",
"t_indexref",
"t_getaddr",
"t_label",
"t_jumplabel",
"t_labelname",
"t_switch",
"t_jump",
"t_jumpcc",
"t_jumptrue",
"t_jumpfalse",
"t_decrjumpnz",
"t_setcc",
"t_andl",
"t_orl",
"t_notl",
"t_istruel",
"t_makelist",
"t_callfn",
"t_callproc",
"t_return",
"t_returnx",
"t_hardret",
"t_add",
"t_sub",
"t_mul",
"t_div",
"t_rem",
"t_iand",
"t_ior",
"t_ixor",
"t_shl",
"t_shr",
"t_neg",
"t_abs",
"t_inot",
"t_addto",
"t_subto",
"t_multo",
"t_divto",
"t_remto",
"t_iorto",
"t_iandto",
"t_ixorto",
"t_shlto",
"t_shrto",
"t_incrto",
"t_decrto",
"t_preincrx",
"t_predecrx",
"t_postincrx",
"t_postdecrx",
"t_softconv",
"t_float",
"t_fix",
"t_truncate",
"t_widen",
"t_fwiden",
"t_narrow",
"t_fnarrow",
"t_convert",
"t_typepun",
"t_last"
};
       char *	opndnames[13]={"no_opnd",
"mem_opnd",
"temp_opnd",
"int_opnd",
"real_opnd",
"string_opnd",
"regvar_opnd",
"imem_opnd",
"itemp_opnd",
"label_opnd",
"ptr_opnd",
"memaddr_opnd",
"tempaddr_opnd"
};
       char *	shorttypenames[6]={"?","I","U","F","P","D"};
       char *	opndtypenames[6]={"no_type","signed_type","unsigned_type","float_type","pointer_type","block_type"};
       tclrec *	tccode;
       tclrec *	tccodex;
       tclrec * *	itccode;
       tclrec * *	itccodex;
       opndrec *	rxstack;
static strbuffer	tclbuffer;
static strbuffer *	tcl=&tclbuffer;
static tclrec	zerotcl;
static opndrec	zeroopnd;
       opndrec *	opndtable[1000];
       byte	opndsizes[2000];
       byte	opndtypes[2000];
       int32	topopnd;
       int32	currtempno;

// From module: cc_genasm
/* Local Static Variables */
static char *	asmstart;
static char *	asmptr;
static char *	asmend;
static int32	asmalloc;
       char *	regnames[17]={"rnone",
"r0",
"r1",
"r2",
"r3",
"r4",
"r5",
"r6",
"r7",
"r8",
"r9",
"r10",
"r11",
"r12",
"r13",
"r14",
"rstack"
};
       char *	xregnames[17]={"xnone",
"xr0",
"xr1",
"xr2",
"xr3",
"xr4",
"xr5",
"xr6",
"xr7",
"xr8",
"xr9",
"xr10",
"xr11",
"xr12",
"xr13",
"xr14",
"xr15"
};
static char	regnameprefix[8]={'B','W',0,'A',0,0,0,'D'};
static char	regname1[10]={'0','1','2','3','4','5','6','7','8','9'};
static char *	stringtable[5000];
static int32	stringlentable[5000];
static int32	nstrings;
static uint64	realtable[2000];
static byte	realsizetable[2000];
static int32	nreals;
static int32	currseg;
static char	opndcomment1[100];
static char	opndcomment2[100];
static byte	doopndsize;
static char *	sizeprefixes[8]={"byte ","word ","","dword","","","","qword"};
static opndrec	temp;
static opndrec *	tx=&temp;
static byte (*tempsizes)[];
static byte (*temptypes)[];
static int32	tempoffsets[2000];
static int32	ntemps;
static opndrec *	txreturn;
static opndrec *	paramlist[100];
static int32	ncallparams;

// From module: cc_gentcl
/* Local Static Variables */
static int32	continuestack[100];
static int32	breakstack[100];
static int32	loopindex;
static int32	retindex;
static int32 (*sw_labeltable)[];
static int32 (*sw_valuetable)[];
static int32	sw_lower;
static int32	sw_ncases;
static byte	sw_defaultseen;
static int32	sw_defaultlabel;
static int32	sw_breaklabel;

// From module: cc_start
/* Local Static Variables */
static int32	gen1target=4997972;
static int32	gen2target=5067585;
static char *	pmnames[4]={"end","option","sourcefile","libfile"};
static int32	passes=0;
static byte	fshowoptions;
static byte	fshowmodules;
static byte	fshowfiles;
static byte	fshowtokens;
static byte	fshowast;
static byte	fshowst;
static byte	fshowstflat;
static byte	fshowtypes;
static byte	fshowtcl;
static byte	fshowasm;
static byte	fshowdis;
static byte	fshowtiming;
static byte	fshowpaths;
static byte	fshowheaders;
static byte	fwriteheaders;
static byte	fshowlog;
static byte	fgenasm;
static byte	fgenbin;
static char *	optionnames[34]={"load",
"pp",
"parse",
"gen1",
"gen2",
"link",
"run",
"asm",
"bin",
"options",
"modules",
"files",
"e",
"ast",
"st",
"stflat",
"dis",
"paths",
"headers",
"types",
"tcl",
"showasm",
"c",
"s",
"d",
"i",
"time",
"v",
"v2",
"q",
"h",
"help",
"ext",
"writeheaders"
};
static byte	loadstatus;
static byte	parsestatus;
static byte	gen1status;
static byte	gen2status;
static byte	linkstatus;
static int32	logdest=0;
static int32	dopause=0;
static int32	totallines=0;
static int32	nstringobjects=0;
static int32	modulelevel;
static char *	outfile;

// From module: mm_clib

// From module: mm_mainc
int32 main	(int32 nparams,char * * params0) {
int32	t;
int32	i;
char * (*params)[];
    params = (char * (*)[])params0;
    nsysparams = nparams;
    if (nsysparams > maxparam) {
        printf("%s\n","Too many params");
        exit(0);
    }
    for (i=1; i<=nparams; ++i) {
        sysparams[i-1] = (*params)[i-1];
    }
    t = clock();
    start();
    printf("%s %d\n","Time=",clock()-t);
    exit(0);
    return 0;
}

uint64 m_dotslice	(uint64 a,int32 i,int32 j) {
    if (i >= j) {
        return a>>j&~(18446744073709551615ull<<(i-j)+1);
    }
    else {
        return a>>i&~(18446744073709551615ull<<(j-i)+1);
    }
}

uint64 m_anddotslice	(uint64 a,int32 i,int32 j) {
    if (i >= j) {
        return (a>>j&~(18446744073709551615ull<<(i-j)+1))<<j;
    }
    else {
        return (a>>i&~(18446744073709551615ull<<(j-i)+1))<<i;
    }
}

int64 m_imin	(int64 a,int64 b) {
    if (a <= b) {
        return a;
    }
    else {
        return b;
    }
}

int64 m_imax	(int64 a,int64 b) {
    if (a >= b) {
        return a;
    }
    else {
        return b;
    }
}

uint64 m_min	(uint64 a,uint64 b) {
    if (a <= b) {
        return a;
    }
    else {
        return b;
    }
}

uint64 m_max	(uint64 a,uint64 b) {
    if (a >= b) {
        return a;
    }
    else {
        return b;
    }
}


// From module: mm_mlib
void * pcm_alloc	(int32 n) {
byte *	p;
int32	i;
    if (n > maxblocksize) {
        alloccode = pcm_getac(n);
        allocbytes = allocupper[alloccode];
        p = (byte *)allocmem(allocbytes);
        if (!p) {
            abortprogram("pcm_alloc failure");
        }
        return p;
    }
    alloccode = sizeindextable[n];
    if (alloccode == 0) {
        alloccode = 1;
    }
    allocbytes = allocupper[alloccode];
    if (!!(p = (byte *)freelist[alloccode])) {
        freelist[alloccode] = (uint64 *)*freelist[alloccode];
        return p;
    }
    p = pcheapptr;
    pcheapptr += allocbytes;
    if (pcheapptr >= pcheapend) {
        p = (byte *)pcm_newblock(allocbytes);
        return p;
    }
    return p;
}

void pcm_free	(void * p,int32 n) {
int32	acode;
    if (n > maxblocksize) {
        free(p);
        return;
    }
    if (p) {
        acode = sizeindextable[n];
        smallmemtotal -= allocupper[acode];
        *(uint64 *)p = (uint64)freelist[acode];
        freelist[acode] = (uint64 *)p;
    }
}

void pcm_freeac	(void * p,int32 alloc) {
    pcm_free(p,allocupper[alloc]);
}

void pcm_copymem4	(void * p,void * q,int32 n) {
    memcpy((int32 *)p,(int32 *)q,n);
}

void pcm_clearmem	(void * p,int32 n) {
    memset((int32 *)p,0,n);
}

void pcm_init	(void) {
int32	i;
int32	j;
int32	k;
int32	k1;
int32	k2;
int64	size;
static int64	limit=2147483648ll;
static int32	finit=0;
    if (finit) {
        return;
    }
    pcm_newblock(0);
    for (i=1; i<=maxblocksize; ++i) {
        j = 1;
        k = 16;
        while (i > k) {
            k = k<<1;
            ++j;
        }
        sizeindextable[i] = j;
    }
    allocupper[1] = 16;
    size = 16;
    for (i=2; i<=27; ++i) {
        size *= 2;
        allocupper[i] = size;
        if (size >= threshold) {
            k = i;
            goto L11;
        }
    }
L11:;
    for (i=k+1; i<=255; ++i) {
        size += alloc_step;
        if (size < limit) {
            allocupper[i] = size;
            maxmemory = size;
        }
        else {
            maxalloccode = i-1;
            goto L15;
        }
    }
L15:;
    finit = 1;
}

int32 pcm_getac	(int32 size) {
    if (size <= maxblocksize) {
        return sizeindextable[size];
    }
    size = size+255>>8;
    if (size <= maxblocksize) {
        return sizeindextable[size]+8;
    }
    size = size+63>>6;
    if (size <= maxblocksize) {
        return sizeindextable[size]+14;
    }
    size = ((size-2048)+2047)/ 2048+22;
    return size;
}

uint32 * pcm_newblock	(int32 itemsize) {
static int32	totalheapsize;
byte *	p;
    totalheapsize += pcheapsize;
    p = (byte *)allocmem(pcheapsize);
    if (p == 0) {
        abortprogram("Can't alloc pc heap");
    }
    pcheapptr = p;
    pcheapend = p+pcheapsize;
    if (pcheapstart == 0) {
        pcheapstart = p;
    }
    pcheapptr += itemsize;
    return (uint32 *)p;
}

int32 pcm_round	(int32 n) {
static int32	allocbytes[9]={0,16,32,64,128,256,512,1024,2048};
    if (n > maxblocksize) {
        return n;
    }
    else {
        return allocbytes[sizeindextable[n]];
    }
}

int32 pcm_array	(int32 n) {
int32	m;
    if (n <= maxblocksize) {
        return pcm_round(n);
    }
    else {
        m = 2048;
        while (n > m) {
            m <<= 1;
        }
        return m;
    }
}

void pcm_printfreelist	(int32 size,uint32 * p) {
    printf("%s %d\n","Size: ",size);
    while (p) {
        printf(" %X",(uint32)(int64)p);
        p = (uint32 *)(int64)*p;
    }
    puts("");
}

void pcm_diags	(char * caption) {
int32	i;
int32	m;
    printf("%s %s\n","HEAP FREELISTS:",caption);
    m = 16;
    for (i=1; i<=8; ++i) {
        pcm_printfreelist(m,(uint32 *)freelist[i]);
        m <<= 1;
    }
}

void * pcm_allocz	(int32 n) {
void *	p;
    p = pcm_alloc(n);
    memset((int32 *)p,0,n);
    return p;
}

char * pcm_copyheapstring	(char * s) {
char *	q;
int32	n;
    n = strlen(s)+1;
    q = (char *)pcm_alloc(n);
    memcpy((int32 *)q,(int32 *)s,n);
    return q;
}

static void addtomemalloc	(int32 * ptr,int32 size) {
int32	i;
    printf("%s %p %d\n","***************ADD TO ALLOC:",(void*)(ptr),size);
    for (i=1; i<=maxmemalloc; ++i) {
        if (memalloctable[i-1] == ptr) {
            printf("%s %p %s\n","ALLOC ERROR:",(void*)(ptr),"ALREADY ALLOCATED\n\n\n");
            exit(1);
        }
        if (memalloctable[i-1] == 0) {
            memalloctable[i-1] = ptr;
            memallocsize[i-1] = size;
            return;
        }
    }
    exit(1);
}

static void removefrommemalloc	(int32 * ptr,int32 size) {
int32	i;
    printf("%s %p %d\n","------------------************REMOVE FROM ALLOC:",(void*)(ptr),size);
    for (i=1; i<=maxmemalloc; ++i) {
        if (memalloctable[i-1] == ptr) {
            if (memallocsize[i-1] != size) {
                printf("%s %p %s %d %s %d\n","REMOVE:FOUND",(void*)(ptr),"IN MEMALLOCTABLE, FREESIZE=",size,", BUT STORED AS BLOCK SIZE:",memallocsize[i-1]);
                abortprogram("MEMSIZE");
            }
            memalloctable[i-1] = 0;
            return;
        }
    }
    printf("%s %p %s %d\n","CAN'T FIND",(void*)(ptr),"IN MEMALLOCTABLE",size);
    abortprogram("MEM");
    exit(1);
}

void * allocmem	(int32 n) {
void *	p;
    p = malloc(n);
    if (p) {
        return p;
    }
    printf("%d %d\n",n,memtotal);
    abortprogram("Alloc mem failure");
    return 0;
}

void * reallocmem	(void * p,int32 n) {
    p = realloc(p,n);
    if (p) {
        return p;
    }
    printf("%d\n",n);
    abortprogram("Realloc mem failure");
    return 0;
}

void abortprogram	(char * s) {
    printf("%s\n",s);
    printf("%s","ABORTING: Press key...");
    exit(1);
}

int32 getfilesize	(void * handlex) {
uint32	p;
uint32	size;
    p = ftell(handlex);
    fseek(handlex,0,2);
    size = ftell(handlex);
    fseek(handlex,p,seek_set);
    return size;
}

void readrandom	(void * handlex,byte * mem,int32 offset,int32 size) {
    fseek(handlex,offset,seek_set);
    fread((int32 *)mem,1,size,handlex);
}

void writerandom	(void * handlex,byte * mem,int32 offset,int32 size) {
    fseek(handlex,offset,seek_set);
    fwrite((int32 *)mem,1,size,handlex);
}

byte * readfile	(char * filename) {
void *	f;
int32	size;
byte *	m;
byte *	p;
    f = fopen(filename,"rb");
    if (f == 0) {
        return 0;
    }
    rfsize = size = getfilesize(f);
    m = (byte *)malloc(size+4);
    if (m == 0) {
        return 0;
    }
    readrandom(f,m,0,size);
    p = m+size;
    *p = 26;
    *(p+1) = 0;
    fclose(f);
    return m;
}

int32 writefile	(char * filename,byte * data,int32 size) {
void *	f;
    f = fopen(filename,"wb");
    if (f == 0) {
        return 0;
    }
    writerandom(f,data,0,size);
    return fclose(f);
}

int32 checkfile	(char * file) {
void *	f;
    if (!!(f = fopen(file,"rb"))) {
        fclose(f);
        return 1;
    }
    return 0;
}

void readlinen	(void * handlex,char * buffer,int32 size) {
char *	p;
int32	n;
char	buff[100];
byte	crseen;
    if (handlex == 0) {
    }
    *buffer = 0;
    if (fgets(buffer,size-2,handlex) == 0) {
        return;
    }
    n = strlen(buffer);
    if (n == 0) {
        return;
    }
    p = buffer+n-1;
    crseen = 0;
    while (p >= buffer && ((uchar)*p == 13 || (uchar)*p == 10)) {
        if ((uchar)*p == 13 || (uchar)*p == 10) {
            crseen = 1;
        }
        *p-- = 0;
    }
    if (!crseen && n+4 > size) {
        printf("%d %d\n",size,n);
        abortprogram("line too long");
    }
}

void iconvlcn	(char * s,int32 n) {
int32	av_1;
    av_1 = n;
    while (av_1--) {
        *s = tolower((uchar)*s);
        ++s;
    }
}

void iconvucn	(char * s,int32 n) {
int32	av_2;
    av_2 = n;
    while (av_2--) {
        *s = toupper((uchar)*s);
        ++s;
    }
}

void convlcstring	(char * s) {
    while ((uchar)*s) {
        *s = tolower((uchar)*s);
        ++s;
    }
}

void convucstring	(char * s) {
    while ((uchar)*s) {
        *s = toupper((uchar)*s);
        ++s;
    }
}

char * changeext	(char * s,char * newext) {
static char	newfile[260];
char	newext2[32];
char *	sext;
int32	n;
    strcpy((char *)&newfile,s);
    if (((uchar)*newext==0)) {
        newext2[1-1] = 0;
        newext2[2-1] = 0;
    } else if (((uchar)*newext=='.')) {
        strcpy((char *)&newext2,newext);
    }
    else {
        strcpy((char *)&newext2,".");
        strcat((char *)&newext2,newext);
    }
    sext = extractext(s,1);
    if (((uchar)*sext==0)) {
        strcat((char *)&newfile,(char *)&newext2);
    } else if (((uchar)*sext=='.')) {
        strcat((char *)&newfile,&newext2[2-1]);
    }
    else {
        n = (sext-s)-2;
        strcpy((char *)&newfile+n+1,(char *)&newext2);
    }
    return (char *)&newfile;
}

char * extractext	(char * s,int32 period) {
char *	t;
char *	u;
    t = extractfile(s);
    if ((uchar)*t == 0) {
        return "";
    }
    u = t+strlen(t)-1;
    while (u >= t) {
        if ((uchar)*u == '.') {
            if ((uchar)*(u+1) == 0) {
                return (period?".":"");
            }
            return u+1;
        }
        --u;
    }
    return "";
}

char * extractpath	(char * s) {
static char	str[260];
char *	t;
int32	n;
    t = s+strlen(s)-1;
    while (t >= s) {
        switch ((uchar)*t) {
        case '\\':
        case '/':
        case ':':
            n = (t-s)+1;
            memcpy((int32 *)&str,(int32 *)s,n);
            str[n] = 0;
            return (char *)&str;
            break;
        default:;
        }
        --t;
    }
    return "";
}

char * extractfile	(char * s) {
char *	t;
    t = extractpath(s);
    if ((uchar)*t == 0) {
        return s;
    }
    return s+strlen(t);
}

char * extractbasefile	(char * s) {
static char	str[100];
char *	f;
char *	e;
int32	n;
int32	flen;
    f = extractfile(s);
    flen = strlen(f);
    if (flen == 0) {
        return "";
    }
    e = extractext(f,0);
    if (!!(uchar)*e) {
        n = (flen-strlen(e))-1;
        memcpy((int32 *)&str,(int32 *)f,n);
        str[n] = 0;
        return (char *)&str;
    }
    if ((uchar)*(f+flen-1) == '.') {
        memcpy((int32 *)&str,(int32 *)f,flen-1);
        str[flen-1] = 0;
        return (char *)&str;
    }
    return f;
}

char * addext	(char * s,char * newext) {
char *	sext;
    sext = extractext(s,1);
    if ((uchar)*sext == 0) {
        return changeext(s,newext);
    }
    return s;
}

void * alloctable	(int32 n,int32 size) {
void *	p;
    p = malloc((n+1)*size);
    if (!p) {
        abortprogram("Alloctable failure");
    }
    return p;
}

void * zalloctable	(int32 n,int32 size) {
int32 *	p;
    p = (int32 *)alloctable(n,size);
    pcm_clearmem(p,(n+1)*size);
    return p;
}

void checkfreelists	(char * s) {
int32	i;
uint64 *	p;
uint64 *	q;
int64	aa;
    for (i=2; i<=2; ++i) {
        p = freelist[i];
        while (p) {
            aa = (int64)p;
            if ((aa&18446744073441116160ull) != 0 || aa < 1048576) {
                printf("%s %s %d %p %p\n",s,"FREE LIST ERROR",i,(void*)(p),(void*)(q));
            }
            q = p;
            p = (uint64 *)*p;
        }
    }
}

void * pcm_alloc32	(void) {
byte *	p;
int32	i;
    allocbytes = 32;
    if (!!(p = (byte *)freelist[2])) {
        freelist[2] = (uint64 *)*freelist[2];
        return p;
    }
    return pcm_alloc(32);
}

void pcm_free32	(void * p) {
int32	acode;
    *(uint64 *)p = (uint64)freelist[2];
    freelist[2] = (uint64 *)p;
}

void outbyte	(void * f,int32 x) {
    fwrite(&x,1,1,f);
}

void outword16	(void * f,uint32 x) {
    fwrite((int32 *)&x,2,1,f);
}

void outword	(void * f,uint32 x) {
    fwrite((int32 *)&x,4,1,f);
}

void outdword	(void * f,uint64 x) {
    fwrite((int32 *)&x,8,1,f);
}

int32 myeof	(void * f) {
int32	c;
    c = fgetc(f);
    if (c == c_eof) {
        return 1;
    }
    ungetc(c,f);
    return 0;
}

void * pcm_smallallocz	(int32 n) {
byte *	p;
int32	i;
    if ((alloccode = sizeindextable[n]) == 0) {
        alloccode = 1;
    }
    allocbytes = allocupper[alloccode];
    p = pcheapptr;
    pcheapptr += allocbytes;
    if (pcheapptr >= pcheapend) {
        p = (byte *)pcm_newblock(allocbytes);
        memset((int32 *)p,0,n);
        return p;
    }
    memset((int32 *)p,0,n);
    return p;
}

void * pcm_fastalloc	(int32 n) {
byte *	p;
int32	i;
    if ((alloccode = sizeindextable[n]) == 0) {
        alloccode = 1;
    }
    allocbytes = allocupper[alloccode];
    p = pcheapptr;
    pcheapptr += allocbytes;
    if (pcheapptr >= pcheapend) {
        p = (byte *)pcm_newblock(allocbytes);
        return p;
    }
    return p;
}


// From module: mm_nos
void os_init	(void) {
    init_flag = 1;
}

int32 os_execwait	(char * cmdline,int32 newconsole,char * workdir) {
    system(cmdline);
    return 0;
}

int32 os_execcmd	(char * cmdline,int32 newconsole) {
    abortprogram("exitcmd");
    return 0;
}

int32 os_getch	(void) {
    return 0;
}

int32 os_kbhit	(void) {
    abortprogram("kbhit");
    return 0;
}

void os_flushkeys	(void) {
    abortprogram("flushkeys");
}

void * os_getconsolein	(void) {
    return 0;
}

void * os_getconsoleout	(void) {
    return 0;
}

void * os_proginstance	(void) {
    abortprogram("PROGINST");
    return 0;
}

uint64 os_getdllinst	(char * name) {
    return 0;
}

void (*os_getdllprocaddr	(int64 hinst,char * name))	(void) {
static rec	table[23]={{"malloc",(void (*)	(void))&malloc},
{"realloc",(void (*)	(void))&realloc},
{"free",(void (*)	(void))&free},
{"printf",(void (*)	(void))&printf},
{"puts",(void (*)	(void))&puts},
{"fgetc",(void (*)	(void))&fgetc},
{"fputc",(void (*)	(void))&fputc},
{"getchar",(void (*)	(void))&getchar},
{"fopen",(void (*)	(void))&fopen},
{"fclose",(void (*)	(void))&fclose},
{"fseek",(void (*)	(void))&fseek},
{"ftell",(void (*)	(void))&ftell},
{"fread",(void (*)	(void))&fread},
{"fwrite",(void (*)	(void))&fwrite},
{"clock",(void (*)	(void))&clock},
{"isalpha",(void (*)	(void))&isalpha},
{"tolower",(void (*)	(void))&tolower},
{"feof",(void (*)	(void))&feof},
{"memset",(void (*)	(void))&memset},
{"memcpy",(void (*)	(void))&memcpy},
{"ungetc",(void (*)	(void))&ungetc},
{"remove",(void (*)	(void))&remove},
{"system",(void (*)	(void))&system}
};
int32	i;
    for (i=1; i<=23; ++i) {
        if (strcmp(table[i-1].name,name) == 0) {
            return (void (*)	(void))table[i-1].addr;
        }
    }
    return 0;
}

void os_initwindows	(void) {
}

int32 os_getchx	(void) {
    abortprogram("getchx");
    return 0;
}

char * os_getos	(void) {
    return "NO-OS";
}

int32 os_getoscode	(void) {
    return 'N';
}

int32 os_iswindows	(void) {
static int32	iswindows=-1;
void *	f;
    if (iswindows == -1) {
        f = fopen("c:/windows/notepad.exe","rb");
        if (f) {
            fclose(f);
            iswindows = 1;
        }
        else {
            iswindows = 0;
        }
    }
    return iswindows;
}

int32 os_shellexec	(char * opc,char * file) {
    abortprogram("SHELL EXEC");
    return 0;
}

void os_sleep	(int32 a) {
    abortprogram("sleep");
}

void * os_getstdin	(void) {
    return fopen("con","rb");
}

void * os_getstdout	(void) {
    return fopen("con","rb");
}

char * os_gethostname	(void) {
    return "";
}

int32 os_gethostsize	(void) {
    return 64;
}

char * os_getmpath	(void) {
    return "";
}

void os_exitprocess	(int32 x) {
    exit(0);
}

int64 os_gettimestamp	(void) {
    return clock();
}

int64 os_gettickcount	(void) {
    return clock();
}

int64 os_clock	(void) {
    if (!!os_iswindows()) {
        return clock();
    }
    else {
        return (clock()/ 1000);
    }
}

int64 os_getclockspersec	(void) {
    return (!!os_iswindows()?1000:1000000);
}

void os_setmesshandler	(void * addr) {
    abortprogram("SETMESSHANDLER");
}

int64 os_filelastwritetime	(char * filename) {
    return 0;
}


// From module: cc_tables

// From module: cc_decls

// From module: cc_support
void mcerror	(char * mess) {
    printf("%s %s\n","MC Error:",mess);
    os_getch();
    exit(1);
}

void serror	(char * mess) {
    serror_gen(mess);
}

void serror_gen	(char * mess) {
    if (currproc) {
        printf("%s %s%s","In function",currproc->name," ");
    }
    printf("%s %d %s %s %s\n","On line",lx.lineno,"in file",sourcefilepaths[lx.fileno],sourcefilenames[lx.fileno]);
    showmacrolineno();
    printf("\n");
    printf("%s %s %s\n","**** Syntax Error:",mess,"****");
    printf("\n");
    printf("\n");
    printf("\n");
    printf("\n");
    printf("\n");
    printf("\n");
    printf("%s\n","--");
    exit(1);
}

void serror_ss	(char * mess,char * a,char * b) {
char	str[256];
    sprintf((char *)&str,mess,a,b);
    serror_gen((char *)&str);
}

void serror_s	(char * mess,char * a) {
char	str[256];
    sprintf((char *)&str,mess,a);
    serror_gen((char *)&str);
}

void terror_gen	(char * mess) {
    if (currproc) {
        printf("%s %s\n","In function",currproc->name);
    }
    printf("%s %s %s %d %s\n","Type error:",mess,"on line",lx.lineno,sourcefilepaths[lx.fileno]);
    showmacrolineno();
    printf("\n");
    printf("\n");
    printf("\n");
    exit(1);
}

void terror	(char * mess) {
    terror_gen(mess);
}

void terror_s	(char * mess,char * a) {
char	str[256];
    sprintf((char *)&str,mess,a);
    terror_gen((char *)&str);
}

void terror_ss	(char * mess,char * a,char * b) {
char	str[256];
    sprintf((char *)&str,mess,a,b);
    terror_gen((char *)&str);
}

void gerror_gen	(char * mess,unitrec * p) {
int32	lineno;
    if (p) {
        lineno = p->lineno;
    }
    else {
        lineno = clineno;
    }
    if (currproc) {
        printf("%s %s%s","In function",currproc->name," ");
    }
    printf("%s %d %s %s\n","On line",lineno&16777215,"in file",sourcefilepaths[lineno>>24]);
    printf("\n");
    printf("%s %s %s\n","**** Code Gen Error:",mess,"****");
    printf("\n");
    printf("\n");
    printf("\n");
    exit(1);
}

void gerror	(char * mess,unitrec * p) {
    gerror_gen(mess,p);
}

void gerror_s	(char * mess,char * s,unitrec * p) {
char	str[256];
    sprintf((char *)&str,mess,s);
    gerror_gen((char *)&str,p);
}

void nxerror	(char * mess,unitrec * p) {
int32	lineno;
    if (p) {
        lineno = p->lineno;
    }
    else {
        lineno = 0;
    }
    printf("%s %s %s %d %s\n","NX error:",mess,"on line",lineno,stmodule->name);
    os_getch();
    exit(1);
}

int32 testelem	(byte (*p)[],int32 n) {
    return (!!((*p)[n>>3]&bytemasks[n&7])?1:0);
}

void setelem	(byte (*p)[],int32 n) {
    (*p)[n>>3] |= bytemasks[n&7];
}

int32 nextpoweroftwo	(int32 x) {
int32	a=1;
    if (x == 0) {
        return 0;
    }
    while (a < x) {
        a <<= 1;
    }
    return a;
}

void loaderror	(char * mess,char * mess2) {
char	str[512];
    sprintf((char *)&str,mess,mess2);
    printf("%s %s\n","Load Error:",(char*)(&str));
    printf("%s\n","Stopping");
    exit(1);
}

int32 loadsourcefile	(char * file,char * shortfile) {
char *	s;
    if (nsourcefiles > maxsourcefile) {
        loaderror("Too many source files","");
    }
    ++nsourcefiles;
    sourcefilepaths[nsourcefiles] = pcm_copyheapstring(file);
    sourcefilenames[nsourcefiles] = pcm_copyheapstring(shortfile);
    s = (char *)readfile(file);
    if (!s) {
        loaderror("LSF can't load ",file);
    }
    sourcefiletext[nsourcefiles] = s;
    sourcefilesizes[nsourcefiles] = rfsize;
    *(s+rfsize) = 0;
    return nsourcefiles;
}

int32 loadbuiltin	(char * shortfile,char * hdrtext) {
char *	s;
    if (nsourcefiles > maxsourcefile) {
        loaderror("Too many source files","");
    }
    ++nsourcefiles;
    sourcefilepaths[nsourcefiles] = "<builtin>";
    sourcefilenames[nsourcefiles] = pcm_copyheapstring(shortfile);
    sourcefiletext[nsourcefiles] = pcm_copyheapstring(hdrtext);
    sourcefilesizes[nsourcefiles] = strlen(hdrtext);
    return nsourcefiles;
}

void gs_init	(strbuffer * dest) {
    pcm_clearmem(dest,16);
}

void gs_str	(strbuffer * dest,char * s) {
    strbuffer_add(dest,s,-1);
}

void gs_strn	(strbuffer * dest,char * s,int32 length) {
    strbuffer_add(dest,s,length);
}

void gs_strvar	(strbuffer * dest,strbuffer * s) {
    strbuffer_add(dest,s->strptr,-1);
}

void gs_strint	(strbuffer * dest,int64 a) {
char	str[256];
    sprintf((char *)&str,"%lld",a);
    strbuffer_add(dest,(char *)&str,-1);
}

void gs_strln	(strbuffer * dest,char * s) {
    gs_str(dest,s);
    gs_line(dest);
}

void gs_strsp	(strbuffer * dest,char * s) {
    gs_str(dest,s);
    gs_str(dest," ");
}

void gs_line	(strbuffer * dest) {
    strbuffer_add(dest,"\r\n",-1);
}

int32 gs_getcol	(strbuffer * dest) {
    return dest->length;
}

void gs_leftstr	(strbuffer * dest,char * s,int32 w,int32 padch) {
int32	col;
int32	i;
int32	n;
int32	slen;
char	str[256];
    col = dest->length;
    strcpy((char *)&str,s);
    slen = strlen(s);
    n = w-slen;
    if (n > 0) {
        for (i=1; i<=n; ++i) {
            str[slen+i-1] = padch;
        }
        str[slen+n+1-1] = 0;
    }
    gs_str(dest,(char *)&str);
}

void gs_leftint	(strbuffer * dest,int32 a,int32 w,int32 padch) {
char	str[256];
    sprintf((char *)&str,"%d",a);
    gs_leftstr(dest,(char *)&str,w,padch);
}

void gs_padto	(strbuffer * dest,int32 col,int32 ch) {
int32	i;
int32	n;
char	str[256];
    n = col-dest->length;
    if (n <= 0) {
        return;
    }
    for (i=1; i<=n; ++i) {
        str[i-1] = ch;
    }
    str[n+1-1] = 0;
    gs_str(dest,(char *)&str);
}

void gs_println	(strbuffer * dest,void * f) {
    if (f == 0) {
        printf("%.*s\r\n",dest->length,dest->strptr);
    }
    else {
        fprintf(f,"%.*s\r\n",dest->length,dest->strptr);
    }
}

static void gs_copytostr	(strbuffer * source,char * s) {
    if (!!source->length) {
        memcpy((int32 *)s,(int32 *)source->strptr,source->length);
        *(s+source->length) = 0;
    }
    else {
        *s = 0;
    }
}

void gs_additem	(strbuffer * dest,char * s) {
char *	d;
int32	lastchar;
int32	nextchar;
    d = dest->strptr;
    if (!!dest->length) {
        lastchar = (uchar)*(d+dest->length-1);
        nextchar = (uchar)*s;
        if (!!isalphanum(lastchar) && !!isalphanum(nextchar)) {
            strbuffer_add(dest," ",-1);
        }
    }
    strbuffer_add(dest,s,-1);
}

void strbuffer_add	(strbuffer * dest,char * s,int32 n) {
int32	newlen;
int32	oldlen;
char *	newptr;
    if (n == -1) {
        n = strlen(s);
    }
    oldlen = dest->length;
    if (oldlen == 0) {
        dest->strptr = (char *)pcm_alloc(n+1);
        dest->allocated = allocbytes;
        dest->length = n;
        memcpy((int32 *)dest->strptr,(int32 *)s,n);
        *(dest->strptr+n) = 0;
        return;
    }
    newlen = oldlen+n;
    if (newlen+1 > dest->allocated) {
        newptr = (char *)pcm_alloc(newlen+1);
        memcpy((int32 *)newptr,(int32 *)dest->strptr,newlen+1);
        dest->strptr = newptr;
        dest->allocated = allocbytes;
    }
    memcpy((int32 *)(dest->strptr+oldlen),(int32 *)s,n);
    *(dest->strptr+newlen) = 0;
    dest->length = newlen;
}

static int32 isalphanum	(int32 c) {
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c >= '0' && c <= '9') {
        return 1;
    }
    return 0;
}

static void showmacrolineno	(void) {
    if (slineno) {
        printf("%s %d %s %s%s\n","\t(Last macro invoked near line",slineno,"in file",sourcefilenames[sfileno],")");
    }
}


// From module: cc_headers
char * findheader	(char * name) {
int32	i;
    for (i=1; i<=37; ++i) {
        if (strcmp(name,stdhdrnames[i-1]) == 0) {
            return *stdhdrtext[i-1];
        }
    }
    return 0;
}

void writeheaders	(void) {
void *	f;
char *	ifile;
int32	i;
    for (i=1; i<=37; ++i) {
        ifile = changeext(stdhdrnames[i-1],"hdr");
        printf("%s %s %s %s\n","Writing internal",stdhdrnames[i-1],"as",ifile);
        f = fopen(ifile,"w");
        fwrite((int32 *)*stdhdrtext[i-1],1,strlen(*stdhdrtext[i-1]),f);
        fclose(f);
    }
}


// From module: cc_lex
void lex_preprocess_only	(char * infile,int32 showtokens) {
byte *	psource;
int32	ntokens;
int32	nlines;
int32	fileno;
int32	size;
int64	nchars;
int64	nn;
int64	t;
int64	hashtot;
int64	symtot;
double	tsecs;
static strbuffer	sbuffer;
static strbuffer *	dest=&sbuffer;
void *	f;
char	outfile[300];
    dowhitespace = 1;
    fileno = loadsourcefile(infile,infile);
    strcpy((char *)&outfile,changeext(infile,"i"));
    psource = (byte *)sourcefiletext[fileno];
    size = sourcefilesizes[fileno];
    NALLCHARS += size;
    nlines = ntokens = 0;
    hashtot = symtot = 0;
    t = os_clock();
    destcopy = dest;
    gs_init(dest);
    NALLLINES = 0;
    printf("%s %s\n","Preprocessing",infile);
    lxsptr = psource;
    lxstart = lxsptr;
    nextlx.lineno = 1;
    nextlx.fileno = 1;
    ifcondlevel = 0;
    nextlx.symbol = errorsym;
    do {
        lexm();
        ++ntokens;
        if (showtokens) {
            emittoken(&nextlx,dest);
        }
    } while (!(nextlx.symbol == eofsym));
    if (ifcondlevel) {
        lxerror("#endif missing");
    }
    nlines += NALLLINES;
    printf("\n");
    printf("%s\n","Finished tokenising");
    if (showtokens) {
        printf("%s %s\n","Writing output to",(char*)(&outfile));
        f = fopen((char *)&outfile,"wb");
        gs_println(dest,f);
        fclose(f);
    }
    printf("\n");
    printf("\n");
    printf("\n");
    printf("\n");
}

void lexreadtoken	(void) {
int32	c;
int32	csum;
int32	hsum;
int32	dodir;
byte *	p;
byte *	ss;
char *	searchstr;
    nextlx.subcodex = 0;
L4:;
    switch (*lxsptr++) {
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z':
    case 'a':
    case 'b':
    case 'c':
    case 'd':
    case 'e':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'j':
    case 'k':
    case 'l':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'q':
    case 'r':
    case 's':
    case 't':
    case 'u':
    case 'v':
    case 'w':
    case 'x':
    case 'y':
    case 'z':
    case '$':
    case '_':
        lxsvalue = lxsptr-1;
        hsum = csum = *lxsvalue;
        while ((uchar)alphamap[c = *lxsptr++]) {
            csum += c;
            hsum = (hsum<<3)+csum;
        }
        --lxsptr;
        nextlx.symbol = namesym;
        nextlx.length = lxsptr-lxsvalue;
        if ((c=='\'') || (c=='"')) {
            if (nextlx.length == 1) {
                if ((*lxsvalue=='l') || (*lxsvalue=='L') || (*lxsvalue=='u') || (*lxsvalue=='U')) {
                    ++lxsptr;
                    lxreadstring(c,1);
                    return;
                }
            }
        }
        lxhashvalue = hsum<<5^csum;
        ss = (byte *)pcm_alloc(nextlx.length+1);
        memcpy((int32 *)ss,(int32 *)lxsvalue,nextlx.length);
        *(ss+nextlx.length) = 0;
        lxsvalue = ss;
        nextlx.symptr = &hashtable[lxhashvalue&hstmask];
        if ((nextlx.symptr->namelen==0)) {
            nextlx.symptr->name = (char *)lxsvalue;
            nextlx.symptr->namelen = nextlx.length;
            nextlx.symptr->symbol = namesym;
            return;
        } else if ((nextlx.symptr->namelen==nextlx.length)) {
            if (memcmp(nextlx.symptr->name,lxsvalue,nextlx.length) == 0) {
                return;
            }
        }
        lookup();
        return;
        break;
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        if ((*lxsptr==' ') || (*lxsptr==')') || (*lxsptr==cr) || (*lxsptr==',') || (*lxsptr==';')) {
            nextlx.symbol = intconstsym;
            nextlx.subcode = tsint;
            nextlx.value = (*(lxsptr-1)-'0');
            nextlx.length = 1;
            nextlx.numberoffset = (lxsptr-1)-lxstart;
        }
        else {
            readdecimal(lxsptr-1);
        }
        return;
        break;
    case '0':
        switch (*lxsptr) {
        case 'x':
        case 'X':
            ++lxsptr;
            readhex(lxsptr-2);
            return;
            break;
        case 'b':
        case 'B':
            ++lxsptr;
            readbinary(lxsptr-2);
            return;
            break;
        case '.':
            readrealnumber(lxsptr-1,lxsptr-1,1,10);
            return;
            break;
        case 'u':
        case 'U':
        case 'l':
        case 'L':
            readdecimal(lxsptr-1);
            return;
            break;
        case ',':
        case ')':
        case ']':
        case '}':
        case ';':
        case ':':
            nextlx.symbol = intconstsym;
            nextlx.subcode = tsint;
            nextlx.value = 0;
            nextlx.length = 1;
            nextlx.numberoffset = (lxsptr-1)-lxstart;
            return;
            break;
        default:;
            readoctal(lxsptr-1);
            return;
        }
        break;
    case '#':
        if (nextlx.symbol == eolsym) {
            nextlx.symbol = lexhashsym;
            return;
        }
        else if (*lxsptr == '#') {
            ++lxsptr;
            nextlx.symbol = hashhashsym;
            return;
        }
        else {
            nextlx.symbol = hashsym;
            return;
        }
        break;
    case '\\':
        *(lxsptr-1) = ' ';
        ++nextlx.lineno;
        ++NALLLINES;
        if ((*lxsptr==cr)) {
            ++lxsptr;
            *lxsptr++ = ' ';
        } else if ((*lxsptr==lf)) {
            *lxsptr++ = ' ';
        }
        break;
    case '{':
        nextlx.symbol = lcurlysym;
        return;
        break;
    case '}':
        nextlx.symbol = rcurlysym;
        return;
        break;
    case '.':
        switch (*lxsptr) {
        case '.':
            ++lxsptr;
            if (*lxsptr == '.') {
                ++lxsptr;
                nextlx.symbol = ellipsissym;
            }
            else {
                --lxsptr;
                nextlx.symbol = dotsym;
                return;
            }
            return;
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            --lxsptr;
            readrealnumber(lxsptr,lxsptr,0,10);
            return;
            break;
        default:;
            nextlx.symbol = dotsym;
            return;
        }
        break;
    case ',':
        nextlx.symbol = commasym;
        return;
        break;
    case ';':
        nextlx.symbol = semisym;
        return;
        break;
    case ':':
        nextlx.symbol = colonsym;
        return;
        break;
    case '(':
        nextlx.symbol = lbracksym;
        return;
        break;
    case ')':
        nextlx.symbol = rbracksym;
        return;
        break;
    case '[':
        nextlx.symbol = lsqsym;
        return;
        break;
    case ']':
        nextlx.symbol = rsqsym;
        return;
        break;
    case '|':
        if ((*lxsptr=='|')) {
            ++lxsptr;
            nextlx.symbol = orlsym;
        } else if ((*lxsptr=='=')) {
            ++lxsptr;
            nextlx.symbol = iortosym;
        }
        else {
            nextlx.symbol = iorsym;
        }
        return;
        break;
    case '^':
        if (*lxsptr == '=') {
            ++lxsptr;
            nextlx.symbol = ixortosym;
        }
        else {
            nextlx.symbol = ixorsym;
        }
        return;
        break;
    case '?':
        nextlx.symbol = questionsym;
        return;
        break;
    case '~':
        nextlx.symbol = inotsym;
        return;
        break;
    case '+':
        if ((*lxsptr=='+')) {
            ++lxsptr;
            nextlx.symbol = incrsym;
        } else if ((*lxsptr=='=')) {
            ++lxsptr;
            nextlx.symbol = addtosym;
        }
        else {
            nextlx.symbol = addsym;
        }
        return;
        break;
    case '-':
        if ((*lxsptr=='-')) {
            ++lxsptr;
            nextlx.symbol = decrsym;
        } else if ((*lxsptr=='>')) {
            ++lxsptr;
            nextlx.symbol = idotsym;
        } else if ((*lxsptr=='=')) {
            ++lxsptr;
            nextlx.symbol = subtosym;
        }
        else {
            nextlx.symbol = subsym;
        }
        return;
        break;
    case '*':
        if (*lxsptr == '=') {
            ++lxsptr;
            nextlx.symbol = multosym;
        }
        else {
            nextlx.symbol = mulsym;
        }
        return;
        break;
    case '/':
        if ((*lxsptr=='/')) {
            readlinecomment();
            nextlx.symbol = eolsym;
            nextlx.length = 0;
            return;
        } else if ((*lxsptr=='*')) {
            readblockcomment();
        } else if ((*lxsptr=='=')) {
            ++lxsptr;
            nextlx.symbol = divtosym;
            return;
        }
        else {
            nextlx.symbol = divsym;
            return;
        }
        break;
    case '%':
        if (*lxsptr == '=') {
            ++lxsptr;
            nextlx.symbol = remtosym;
        }
        else {
            nextlx.symbol = remsym;
        }
        return;
        break;
    case '=':
        if ((*lxsptr=='=')) {
            nextlx.symbol = eqsym;
            ++lxsptr;
        }
        else {
            nextlx.symbol = assignsym;
        }
        return;
        break;
    case '<':
        switch (*lxsptr) {
        case '=':
            ++lxsptr;
            nextlx.symbol = lesym;
            break;
        case '<':
            if (*++lxsptr == '=') {
                ++lxsptr;
                nextlx.symbol = shltosym;
            }
            else {
                nextlx.symbol = shlsym;
            }
            break;
        default:;
            nextlx.symbol = ltsym;
        }
        return;
        break;
    case '>':
        switch (*lxsptr) {
        case '=':
            ++lxsptr;
            nextlx.symbol = gesym;
            break;
        case '>':
            if (*++lxsptr == '=') {
                ++lxsptr;
                nextlx.symbol = shrtosym;
            }
            else {
                nextlx.symbol = shrsym;
            }
            break;
        default:;
            nextlx.symbol = gtsym;
        }
        return;
        break;
    case '&':
        if ((*lxsptr=='&')) {
            ++lxsptr;
            nextlx.symbol = andlsym;
        } else if ((*lxsptr=='=')) {
            ++lxsptr;
            nextlx.symbol = iandtosym;
        }
        else {
            nextlx.symbol = iandsym;
        }
        return;
        break;
    case '\'':
        lxreadstring('\'',0);
        return;
        break;
    case '"':
        lxreadstring('"',0);
        return;
        break;
    case ' ':
    case tab:
        break;
    case cr:
        ++NALLLINES;
        ++nextlx.lineno;
        nextlx.symbol = eolsym;
        nextlx.length = 0;
        if (dowhitespace) {
            nextlx.svalue = lxsptr+1;
L35:;
            switch (*++lxsptr) {
            case ' ':
            case tab:
                break;
            default:;
                goto L36;
            }
            goto L35;
L36:;
            nextlx.length = lxsptr-nextlx.svalue;
        }
        else {
            ++lxsptr;
        }
        return;
        break;
    case lf:
        ++nextlx.lineno;
        ++NALLLINES;
        nextlx.symbol = eolsym;
        nextlx.length = 0;
        return;
        break;
    case '!':
        if ((*lxsptr=='=')) {
            nextlx.symbol = nesym;
            ++lxsptr;
        }
        else {
            nextlx.symbol = notlsym;
        }
        return;
        break;
    case '@':
        printf("%s %d %s %d\n","@ SEEN",nextlx.lineno,sourcefilenames[nextlx.fileno],lx_stackindex);
        break;
    case 0:
doeof:
        --lxsptr;
        if (lx_stackindex) {
            unstacksourcefile();
            nextlx.symbol = eolsym;
        }
        else {
            nextlx.symbol = eofsym;
        }
        return;
        break;
    case 12:
        break;
    default:;
        printf("%s %u %d\n","ERROR CHAR",*(lxsptr-1),lx_stackindex);
        lxerror("ERROR CHAR");
        nextlx.symbol = errorsym;
        nextlx.value = c;
        return;
    }
    goto L4;
}

static void readrealnumber	(byte * pstart,byte * intstart,int32 intlen,int32 base) {
byte *	fractstart;
int32	fractlen;
int32	expon;
int32	i;
int32	c;
int32	badexpon;
double	basex;
double	x;
double	expbase;
enum {maxrealdigits = 500};
char	realstr[500];
int32	av_1;
int32	av_2;
int32	av_3;
    fractstart = 0;
    fractlen = 0;
    expon = 0;
    if (*lxsptr == '.') {
        fractstart = ++lxsptr;
        fractlen = scannumber(base)-fractstart;
    }
    badexpon = 0;
    if ((*lxsptr=='e') || (*lxsptr=='E')) {
        if (base != 16) {
            ++lxsptr;
            expon = readexponent(&badexpon);
        }
    } else if ((*lxsptr=='p') || (*lxsptr=='P')) {
        if (base == 16) {
            ++lxsptr;
            expon = readexponent(&badexpon);
        }
    }
    if (badexpon) {
        --lxsptr;
        readalphanumeric(pstart);
        return;
    }
    if ((*lxsptr=='f') || (*lxsptr=='F')) {
        ++lxsptr;
    }
    else {
        if (!!(uchar)alphamap[*lxsptr]) {
            readalphanumeric(pstart);
            return;
        }
    }
    if (intlen+fractlen > maxrealdigits) {
        lxerror("Real too long");
    }
    if (intlen) {
        memcpy((int32 *)&realstr,(int32 *)intstart,intlen);
    }
    if (fractlen) {
        memcpy((int32 *)(&realstr[1-1]+intlen),(int32 *)fractstart,fractlen);
    }
    expbase = basex = base;
    if (base == 10) {
        expon -= fractlen;
    }
    else {
        expon -= fractlen*4;
        expbase = 2.0;
    }
    x = 0.0;
    for (i=1; i<=intlen+fractlen; ++i) {
        c = (uchar)realstr[i-1];
        if (c >= '0' && c <= '9') {
            x = x*basex+c-48.0;
        }
        else if (c > 'a') {
            x = (x*basex+c-97.0)+10.0;
        }
        else {
            x = (x*basex+c-65.0)+10.0;
        }
    }
    if (expon >= 0) {
        av_2 = expon;
        while (av_2--) {
            x *= expbase;
        }
    }
    else {
        av_3 = -expon;
        while (av_3--) {
            x /= expbase;
        }
    }
    nextlx.symbol = realconstsym;
    nextlx.subcode = tdouble;
    nextlx.xvalue = x;
    nextlx.numberoffset = intstart-lxstart;
    nextlx.length = lxsptr-intstart;
}

static int32 readexponent	(int32 * badexpon) {
byte *	numstart;
int32	length;
int32	neg;
int32	c;
int64	a;
int32	av_4;
    neg = 0;
    if ((*lxsptr=='+')) {
        ++lxsptr;
    } else if ((*lxsptr=='-')) {
        ++lxsptr;
        neg = 1;
    }
    numstart = lxsptr;
    length = scannumber(10)-numstart;
    if (length == 0) {
        *badexpon = 1;
        return 0;
    }
    a = 0;
    av_4 = length;
    while (av_4--) {
        c = *numstart++;
        a = a*10+c-'0';
    }
    return (neg?(-a):(a));
}

static void lxerror	(char * mess) {
    printf("%s %s %s%s %s %d\n","Lex error",mess,"in:",sourcefilepaths[nextlx.fileno],"Line:",nextlx.lineno);
    printf("\n");
    printf("\n");
    printf("\n");
    exit(1);
}

void printsymbol	(tokenrec * lp) {
tokenrec	l;
    l = *lp;
    printf("%-18s",symbolnames[l.symbol-1]);
    if ((l.symbol==namesym)) {
        printstrn(l.symptr->name,l.symptr->namelen,0);
    } else if ((l.symbol==intconstsym)) {
        printf("%lld%s",l.value," ");
        shownumberstr(lp,0);
    } else if ((l.symbol==realconstsym)) {
        printf("%f%s",l.xvalue," ");
        shownumberstr(lp,0);
    } else if ((l.symbol==stringconstsym)) {
        printf("%s","\"");
        printstrn((char *)l.svalue,l.length,0);
        printf("%s","\"");
    } else if ((l.symbol==charconstsym)) {
        printf("%s","'");
        printstrn((char *)l.svalue,l.length,0);
        printf("%s","'");
    }
    else {
        if (!!l.subcode) {
            printf("%s %u","#",l.subcode);
        }
    }
    printf("\n");
}

void lexsetup	(void) {
int32	i;
static int32	n;
    inithashtable();
    n = 0;
    for (i=0; i<=hstmask; ++i) {
        if (!!hashtable[i].name) {
            ++n;
        }
    }
    for (i=0; i<=255; ++i) {
        switch (i) {
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
        case '$':
        case '_':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            alphamap[i] = 1;
            break;
        default:;
        }
        switch (i) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            digitmap[i] = 1;
            break;
        default:;
        }
        commentmap[i] = 1;
        linecommentmap[i] = 1;
        spacemap[i] = 0;
    }
    commentmap['*'] = 0;
    commentmap[0] = 0;
    commentmap[lf] = 0;
    linecommentmap[0] = 0;
    linecommentmap['\\'] = 0;
    linecommentmap[lf] = 0;
    spacemap[' '] = 1;
    spacemap[tab] = 1;
    normaltkx.symbol = eolsym;
    npastedtokens = 0;
}

void printstrn	(char * s,int32 length,void * f) {
    if (length) {
        if (f == 0) {
            printf("%.*s",length,s);
        }
        else {
            fprintf(f,"%.*s",length,s);
        }
    }
}

static byte * scannumber	(int32 base) {
byte *	dest;
int32	c;
    dest = lxsptr;
L76:;
    switch (c = *lxsptr++) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        *dest++ = c;
        if (c >= '0'+base) {
            lxerror("Digit out of range");
        }
        break;
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'a':
    case 'b':
    case 'c':
    case 'd':
    case 'e':
    case 'f':
        if (base == 16) {
            *dest++ = c;
        }
        else {
            --lxsptr;
            goto L77;
        }
        break;
    case '_':
    case '\'':
    case '`':
        break;
    default:;
        --lxsptr;
        goto L77;
    }
    goto L76;
L77:;
    return dest;
}

static int32 lookup	(void) {
int32	j;
int32	wrapped;
int32	length;
    j = lxhashvalue&hstmask;
    nextlx.symptr = &hashtable[j];
    wrapped = 0;
    while (1) {
        length = nextlx.symptr->namelen;
        if (!length) {
            goto L79;
        }
        if (length == nextlx.length) {
            if (memcmp(nextlx.symptr->name,lxsvalue,length) == 0) {
                return 1;
            }
        }
        ++nextlx.symptr;
        if (++j >= hstsize) {
            if (wrapped) {
                abortprogram("HASHTABLE FULL");
            }
            wrapped = 1;
            nextlx.symptr = &hashtable[0];
            j = 0;
        }
    }
L79:;
    nextlx.symptr->name = (char *)lxsvalue;
    nextlx.symptr->namelen = nextlx.length;
    nextlx.symptr->symbol = namesym;
    return 0;
}

static int32 gethashvalue	(char * s,int32 length) {
int32	c;
int32	csum;
int32	hsum;
int32	av_5;
    if (length == -1) {
        length = strlen(s);
    }
    hsum = csum = 0;
    av_5 = length;
    while (av_5--) {
        c = (uchar)*s++;
        csum += c;
        hsum = (hsum<<3)+csum;
    }
    return hsum<<5^csum;
}

static void inithashtable	(void) {
int32	i;
    memset((int32 *)&hashtable,0,8388608);
    for (i=1; i<=75; ++i) {
        lxsvalue = (byte *)stnames[i-1];
        if (stsymbols[i-1] == ksourcedirsym) {
            lxsvalue = (byte *)pcm_copyheapstring((char *)lxsvalue);
        }
        nextlx.length = strlen((char *)lxsvalue);
        lxhashvalue = gethashvalue((char *)lxsvalue,nextlx.length);
        if (!!lookup()) {
            printf("%s\n",stnames[i-1]);
            abortprogram("Duplicate symbol table entry");
        }
        nextlx.symptr->symbol = stsymbols[i-1];
        nextlx.symptr->subcode = stsubcodes[i-1];
    }
}

static int32 dolexdirective	(void) {
strec *	symptr;
strec *	d;
byte *	p;
byte *	pstart;
int32	i;
int32	cond;
int32	c;
int32	syshdr;
int32	dir;
char	filename[300];
static int32	nincludes;
    pstart = lxsptr;
    dir = getlexdirective();
    if (dir == 0) {
        printstrn((char *)pstart,lxsptr-pstart,0);
        printf("\n");
        lxerror("Invalid # directive");
    }
    if ((dir==includedir)) {
        if (!doinclude) {
            goto L88;
        }
        lexm();
        if (nextlx.symbol == ltsym) {
            syshdr = 1;
            p = (byte *)&filename[1-1];
            while (1) {
                c = *lxsptr++;
                if ((c=='>')) {
                    goto L92;
                } else if ((c==lf) || (c==0)) {
                    lxerror("include: > expected");
                }
                else {
                    *p++ = c;
                }
            }
L92:;
            *p = 0;
        }
        else if (nextlx.symbol == stringconstsym) {
            syshdr = 0;
            strcpy((char *)&filename,(char *)nextlx.svalue);
        }
        else {
            lxerror("include?");
        }
        lexm();
        stacksourcefile((char *)&filename,syshdr);
    } else if ((dir==definedir)) {
        dodefine();
    } else if ((dir==undefdir)) {
        lexreadtoken();
        if (nextlx.symbol != namesym) {
            lxerror("undef: name expected");
        }
        if (nextlx.symptr->nameid != macroid) {
        }
        else {
            nextlx.symptr->nameid = nullid;
            nextlx.symptr->symbol = nextlx.symptr->oldsymbol;
        }
    } else if ((dir==ifdefdir)) {
        ++NIFDEFS;
        cond = getifdef();
        goto L100;
    } else if ((dir==ifndefdir)) {
        ++NIFDEFS;
        cond = (int32)!getifdef();
        goto L100;
    } else if ((dir==ifdir)) {
        ++NIFS;
        cond = getifexpr();
doif:
L100:;
        ++ifcondlevel;
        if (cond) {
            return 0;
        }
        else {
doskipcode:
L103:;
            dir = skipcode();
            if ((dir==elifdir)) {
                cond = getifexpr();
                if (cond) {
                    return 0;
                }
                goto L103;
            } else if ((dir==elsedir)) {
            } else if ((dir==endifdir)) {
                --ifcondlevel;
            }
        }
    } else if ((dir==elifdir) || (dir==elsedir)) {
        if (!ifcondlevel) {
            lxerror("#if missing/elif/else");
        }
        do {
            dir = skipcode();
        } while (!(dir == endifdir));
        --ifcondlevel;
    } else if ((dir==endifdir)) {
        if (!ifcondlevel) {
            lxerror("#if missing/endif");
        }
        --ifcondlevel;
    } else if ((dir==blankdir)) {
    } else if ((dir==linedir)) {
        do {
            lexreadtoken();
        } while (!(nextlx.symbol == eolsym));
    } else if ((dir==errordir)) {
        lexm();
        printf("%s","#ERROR:");
        showtoken(&nextlx);
        printf("\n");
        goto L119;
    } else if ((dir==messagedir)) {
        lexm();
        printf("%s","#MESSAGE");
        if (nextlx.symbol == eolsym) {
            printf("%s %d %s\n"," Line",nextlx.lineno+1,sourcefilenames[nextlx.fileno]);
        }
        else {
            showtoken(&nextlx);
            printf("\n");
        }
        goto L119;
    } else if ((dir==warningdir) || (dir==pausedir)) {
        lexm();
        printf("%s","#WARNING:");
        showtoken(&nextlx);
        printf("\n");
dowarning2:
L119:;
        while (nextlx.symbol != eolsym && nextlx.symbol != eofsym) {
            lexm();
        }
        if (dir == pausedir) {
            printf("%s","Press key...");
            os_getch();
            printf("\n");
        }
    } else if ((dir==pragmadir)) {
        dopragmadir();
    } else if ((dir==debugondir)) {
        debug = 1;
    } else if ((dir==debugoffdir)) {
        debug = 0;
    } else if ((dir==showmacrodir)) {
        lexreadtoken();
        if (nextlx.symbol == namesym) {
            d = nextlx.symptr;
            printf("%d %s %s",nextlx.lineno,sourcefilenames[nextlx.fileno],":");
            printf("%s %s %s","SHOW MACRO",getstname(d),":");
            if (d->nameid == macroid) {
                showtokens("tokens:",d->tokenlist);
                printf("\n");
            }
            else {
                printf("%s\n","not a macro");
            }
        }
        else {
            printf("%s\n","Not a name");
        }
    }
    else {
skip:
L88:;
        printf("%s %s\n","DIRECTIVE NOT IMPL:",sourcedirnames[dir-1]);
        lxsptr = pstart;
        nextlx.symbol = lexhashsym;
        return 1;
        lxerror("Directive not implemented");
    }
    return 0;
}

static int32 getlexdirective	(void) {
strec *	d;
    lexreadtoken();
    if ((nextlx.symbol==namesym)) {
    } else if ((nextlx.symbol==eolsym)) {
        return blankdir;
    } else if ((nextlx.symbol==intconstsym)) {
        do {
            lexreadtoken();
        } while (!(nextlx.symbol == eolsym || nextlx.symbol == eofsym));
        return blankdir;
    }
    else {
        return 0;
    }
    if ((nextlx.symptr->symbol==ksourcedirsym)) {
        return nextlx.symptr->subcode;
    } else if ((nextlx.symptr->symbol==kifsym)) {
        return ifdir;
    } else if ((nextlx.symptr->symbol==kelsesym)) {
        return elsedir;
    } else if ((nextlx.symptr->symbol==eolsym)) {
        return blankdir;
    }
    d = nextlx.symptr;
    if (d->nameid == macroid) {
        if (d->oldsymbol == ksourcedirsym) {
            return d->subcode;
        }
    }
    return 0;
}

void startlex	(char * caption,int32 fileno) {
    ifcondlevel = 0;
    lx_stackindex = 0;
    lxstart = lxsptr = (byte *)sourcefiletext[fileno];
    nextlx.fileno = fileno;
    nextlx.lineno = 1;
    nextlx.symbol = eolsym;
    nextlx.subcode = 0;
    lex();
}

void endlex	(void) {
    if (ifcondlevel) {
        printf("%d\n",ifcondlevel);
        lxerror("#endif missing");
    }
}

void PS	(char * caption) {
    printf("%s%s",caption,":::");
    printsymbol(&lx);
}

void PSNEXT	(char * caption) {
    printf("%s%s",caption,":##");
    printsymbol(&nextlx);
}

void showhashtablesize	(void) {
int32	i;
int32	n;
    n = 0;
    for (i=0; i<=hstmask; ++i) {
        if (!!hashtable[i].name) {
            printf("%s\n",getstname(&hashtable[i]));
            ++n;
        }
    }
    printf("%s %d %d\n","FINAL HASHTABLE",n,hstsize);
}

static void readlinecomment	(void) {
    while (1) {
        while ((uchar)linecommentmap[*++lxsptr]) {
        }
        if ((*lxsptr==lf)) {
            ++lxsptr;
            goto L145;
        } else if ((*lxsptr==0)) {
            goto L145;
        } else if ((*lxsptr=='\\')) {
            ++lxsptr;
            if ((*lxsptr==cr)) {
                lxsptr += 2;
                ++NALLLINES;
                ++nextlx.lineno;
            } else if ((*lxsptr==lf)) {
                ++lxsptr;
                ++NALLLINES;
                ++nextlx.lineno;
            }
        }
    }
L145:;
    ++NALLLINES;
    ++nextlx.lineno;
}

static void readblockcomment	(void) {
    while (1) {
        while ((uchar)commentmap[*++lxsptr]) {
        }
        if ((*lxsptr==lf)) {
            ++NALLLINES;
            ++nextlx.lineno;
        } else if ((*lxsptr==0)) {
            lxerror("block comment eof");
        } else if ((*lxsptr=='*')) {
            if (*(lxsptr+1) == '/') {
                lxsptr += 2;
                goto L155;
            }
        }
    }
L155:;
}

static void readhex	(byte * pstart) {
uint64	aa;
int32	c;
int32	length;
int32	leading;
int32	ll;
int32	usigned;
byte *	p;
    aa = 0;
    p = lxsptr;
    leading = 1;
    ll = usigned = 0;
    length = 0;
L162:;
    switch (c = *lxsptr++) {
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        leading = 0;
        aa = (aa*16+(c-'0'));
        ++length;
        break;
    case '0':
        if (leading) {
            ++p;
        }
        else {
            ++length;
            aa = (aa*16);
        }
        break;
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
        leading = 0;
        ++length;
        aa = (aa*16+((c-'A')+10));
        break;
    case 'a':
    case 'b':
    case 'c':
    case 'd':
    case 'e':
    case 'f':
        leading = 0;
        ++length;
        aa = (aa*16+((c-'a')+10));
        break;
    case '.':
    case 'P':
    case 'p':
        --lxsptr;
        readrealnumber(pstart,p,lxsptr-p,16);
        return;
        break;
    case 'L':
    case 'l':
        ++ll;
        if (ll > 2) {
            lxerror("-LL?");
        }
        break;
    case 'U':
    case 'u':
        if (usigned) {
            lxerror("-U?");
        }
        usigned = 1;
        break;
    default:;
        --lxsptr;
        goto L163;
    }
    goto L162;
L163:;
    nextlx.numberoffset = pstart-lxstart;
    nextlx.length = lxsptr-pstart;
    if (length > 16) {
        lxerror("Overflow in hex number");
    }
    nextlx.symbol = intconstsym;
    if (aa >= 9223372036854775807u) {
        nextlx.subcode = tullong;
    }
    else if (aa >= 4294967295ll) {
        nextlx.subcode = tsllong;
    }
    else if (aa >= 2147483647) {
        nextlx.subcode = tuint;
    }
    else {
        nextlx.subcode = tsint;
    }
    nextlx.value = aa;
    checknumbersuffix();
}

static void readbinary	(byte * pstart) {
uint64	aa;
int32	c;
int32	length;
int32	res;
int32	leading;
byte *	p;
int32	av_6;
    aa = 0;
    p = lxsptr;
    leading = 1;
L168:;
    switch (c = *lxsptr++) {
    case '1':
        leading = 0;
        break;
    case '0':
        if (leading) {
            ++p;
        }
        break;
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        lxerror("Binary bad digit");
        break;
    case '.':
        lxerror("Binary fp");
        break;
    default:;
        --lxsptr;
        goto L169;
    }
    goto L168;
L169:;
    length = lxsptr-p;
    nextlx.numberoffset = pstart-lxstart;
    nextlx.length = lxsptr-pstart;
    if (length > 64) {
        lxerror("Overflow in binary number");
    }
    av_6 = length;
    while (av_6--) {
        aa = (aa*2+*p++-'0');
    }
    nextlx.symbol = intconstsym;
    nextlx.subcode = tsint;
    if (aa >= 2147483647) {
        nextlx.subcode = tsllong;
    }
    nextlx.value = aa;
    checknumbersuffix();
}

static void readoctal	(byte * pstart) {
uint64	aa;
int32	c;
int32	length;
int32	res;
int32	leading;
int32	ll;
int32	usigned;
byte *	p;
int32	av_7;
    aa = 0;
    p = lxsptr;
    leading = 1;
    ll = usigned = 0;
    length = 0;
L173:;
    switch (c = *lxsptr++) {
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
        leading = 0;
        ++length;
        break;
    case '0':
        if (leading) {
            ++p;
        }
        else {
            ++length;
        }
        break;
    case '.':
        --lxsptr;
        readrealnumber(pstart,p,lxsptr-p,10);
        return;
        break;
    case 'L':
    case 'l':
        ++ll;
        if (ll > 2) {
            lxerror("-LL?");
        }
        break;
    case 'U':
    case 'u':
        if (usigned) {
            lxerror("-U?");
        }
        usigned = 1;
        break;
    default:;
        if (!!(uchar)alphamap[c]) {
doalpha:
            readalphanumeric(pstart);
            return;
        }
        --lxsptr;
        goto L174;
    }
    goto L173;
L174:;
    nextlx.numberoffset = pstart-lxstart;
    nextlx.length = lxsptr-pstart;
    if (length > 22 || length == 22 && (res = strncmp((char *)p,"1777777777777777777777",22)) > 0) {
        lxerror("Overflow in octal number");
    }
    av_7 = length;
    while (av_7--) {
        aa = (aa*8+*p++-'0');
    }
    nextlx.symbol = intconstsym;
    nextlx.subcode = tsint;
    if (aa >= 2147483647) {
        nextlx.subcode = tsllong;
    }
    nextlx.value = aa;
    checknumbersuffix();
}

static void readdecimal	(byte * pstart) {
uint64	aa;
int32	c;
int32	length;
int32	res;
int32	leading;
byte	ll;
byte	usigned;
byte *	p;
int32	av_8;
    aa = 0;
    ll = (usigned = 0);
    p = --lxsptr;
    while ((uchar)digitmap[*++lxsptr]) {
    }
    while (*p == '0') {
        ++p;
    }
    length = lxsptr-p;
L185:;
    switch (c = *lxsptr++) {
    case '.':
    case 'E':
    case 'e':
        --lxsptr;
        readrealnumber(pstart,p,lxsptr-p,10);
        return;
        break;
    case 'L':
    case 'l':
        ++ll;
        if (ll > 2) {
            lxerror("-LL?");
        }
        break;
    case 'U':
    case 'u':
        if (!!usigned) {
            lxerror("-U?");
        }
        usigned = 1;
        break;
    default:;
        if (!!(uchar)alphamap[c]) {
            readalphanumeric(pstart);
            return;
        }
        --lxsptr;
        goto L186;
    }
    goto L185;
L186:;
    nextlx.numberoffset = pstart-lxstart;
    nextlx.length = lxsptr-pstart;
    if (length > 20 || length == 20 && (res = strncmp((char *)p,"18446744073709551615",20)) > 0) {
        lxerror("Overflow in decimal number");
    }
    av_8 = length;
    while (av_8--) {
        aa = (aa*10+*p++-'0');
    }
    nextlx.symbol = intconstsym;
    nextlx.subcode = tsint;
    if ((ll==0) || (ll==1)) {
        if (!!usigned) {
            if (aa >= 4294967295ll) {
                nextlx.subcode = tullong;
            }
            else {
                nextlx.subcode = tuint;
            }
        }
        else {
            if (aa >= 2147483647) {
                nextlx.subcode = tsllong;
            }
        }
    }
    else {
        if (!!usigned) {
            nextlx.subcode = tullong;
        }
        else {
            nextlx.subcode = tsllong;
        }
    }
    nextlx.value = aa;
}

static int32 checknumbersuffix	(void) {
char	c;
L192:;
    switch ((c = *lxsptr++)) {
    case 'L':
    case 'l':
    case 'u':
    case 'U':
        break;
    default:;
        if (!!(uchar)alphamap[(uchar)c]) {
        }
        --lxsptr;
        goto L193;
    }
    goto L192;
L193:;
    return tsint;
}

static void stacksourcefile	(char * file,int32 syshdr) {
char *	sptr;
int32	fileno;
stackinforec	info;
    fileno = getsourcefile(file,syshdr);
    if (fileno == 0) {
        printf("%s\n",file);
        lxerror("Can't find include file");
    }
    NALLCHARS += sourcefilesizes[fileno];
    if (lx_stackindex > maxnesting) {
        lxerror("Too many nested includes");
    }
    ++lx_stackindex;
    info.startptr = lxstart;
    info.sptr = lxsptr;
    info.lineno = nextlx.lineno;
    info.fileno = nextlx.fileno;
    lx_stack[lx_stackindex-1] = info;
    lxstart = lxsptr = (byte *)sourcefiletext[fileno];
    nextlx.fileno = fileno;
    nextlx.lineno = 1;
}

static void unstacksourcefile	(void) {
stackinforec	info;
    info = lx_stack[lx_stackindex---1];
    lxstart = info.startptr;
    lxsptr = info.sptr;
    nextlx.lineno = info.lineno;
    nextlx.fileno = info.fileno;
}

static int32 getsourcefile	(char * file,int32 syshdr) {
static char	filespec[300];
char *	hdrtext;
int32	i;
    for (i=1; i<=nsourcefiles; ++i) {
        if (strcmp(file,sourcefilenames[i]) == 0) {
            return i;
        }
    }
    if (dointheaders) {
        hdrtext = findheader(file);
        if (hdrtext) {
            return loadbuiltin(file,hdrtext);
        }
    }
    for (i=1; i<=nsearchdirs; ++i) {
        strcpy((char *)&filespec,searchdirs[i-1]);
        strcat((char *)&filespec,file);
        if (!!checkfile((char *)&filespec)) {
            return loadsourcefile((char *)&filespec,file);
        }
    }
    return 0;
}

void lex	(void) {
    lx = nextlx;
    lexm();
    if (lx.symbol == namesym && lx_stackindex == 0) {
        *(lx.symptr->name+lx.length) = 0;
    }
L202:;
    if ((nextlx.symbol==namesym)) {
        nextlx.symbol = nextlx.symptr->symbol;
        if (nextlx.symbol == ksourcedirsym) {
            nextlx.symbol = namesym;
        }
        nextlx.subcode = nextlx.symptr->subcode;
        return;
    } else if ((nextlx.symbol==eolsym)) {
        lexm();
    }
    else {
        return;
    }
    goto L202;
}

static void shownumberstr	(tokenrec * l,void * f) {
char *	s;
int32	i;
    if (!!l->fileno) {
        s = sourcefiletext[l->fileno]+l->numberoffset;
    }
    else {
        s = pastedtokenlist[l->pasteno-1];
    }
    printstrn(s,l->length,f);
}

strec * addnamestr	(char * name) {
tokenrec	oldlx;
strec *	symptr;
    oldlx = nextlx;
    nextlx.length = strlen(name);
    lxhashvalue = gethashvalue(name,nextlx.length);
    lxsvalue = (byte *)pcm_alloc(nextlx.length+1);
    memcpy((int32 *)lxsvalue,(int32 *)name,nextlx.length+1);
    lookup();
    symptr = nextlx.symptr;
    nextlx = oldlx;
    return symptr;
}

char * getstname	(strec * d) {
static char	name[256];
    memcpy((int32 *)&name,(int32 *)d->name,d->namelen);
    name[d->namelen+1-1] = 0;
    return (char *)&name;
}

static void lxreadstring	(int32 termchar,int32 fwide) {
enum {maxlocalstr = 1024};
char	str[1024];
byte *	dest;
int32	c;
int32	d;
int32	length;
int32	av_9;
int32	av_10;
    if (termchar == '"') {
        nextlx.symbol = (fwide?wstringconstsym:stringconstsym);
    }
    else {
        nextlx.symbol = charconstsym;
    }
    nextlx.svalue = lxsptr;
    if (lx_stackindex == 0) {
        dest = lxsptr;
    }
    else {
        dest = (byte *)&str;
    }
    length = 0;
L206:;
    while (1) {
        switch (c = *lxsptr++) {
        case '\\':
            c = *lxsptr++;
            switch (c) {
            case 'a':
                c = 7;
                break;
            case 'b':
                c = 8;
                break;
            case 'f':
                c = 12;
                break;
            case 'n':
                c = lf;
                break;
            case 'r':
                c = cr;
                break;
            case 't':
                c = tab;
                break;
            case 'v':
                c = 11;
                break;
            case 'x':
                c = 0;
                av_9 = 2;
                while (av_9--) {
                    switch (d = *lxsptr++) {
                    case 'A':
                    case 'B':
                    case 'C':
                    case 'D':
                    case 'E':
                    case 'F':
                        c = (c*16+d-'A')+10;
                        break;
                    case 'a':
                    case 'b':
                    case 'c':
                    case 'd':
                    case 'e':
                    case 'f':
                        c = (c*16+d-'a')+10;
                        break;
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                        c = c*16+d-'0';
                        break;
                    default:;
                        lxerror("Bad \\x code");
                    }
                }
                break;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
                c -= '0';
                av_10 = 2;
                while (av_10--) {
                    switch (d = *lxsptr++) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                        c = c*8+d-'0';
                        break;
                    default:;
                        --lxsptr;
                        goto L213;
                    }
                }
L213:;
                break;
            case '"':
                c = '"';
                break;
            case '\\':
                c = '\\';
                break;
            case '\'':
                c = '\'';
                break;
            case cr:
                ++NALLLINES;
                ++nextlx.lineno;
                if (*lxsptr == lf) {
                    ++lxsptr;
                }
                goto L206;
                break;
            case lf:
                goto L206;
                break;
            default:;
            }
            break;
        case '"':
        case '\'':
            if (c == termchar) {
                goto L207;
            }
            break;
        case lf:
        case 0:
            printf("%s %d\n","NEXTLX.LINENO=",nextlx.lineno);
            lxerror("String not terminated");
            break;
        default:;
        }
        if (lx_stackindex == 0) {
            *dest++ = c;
        }
        else if (++length < maxlocalstr) {
            *dest++ = c;
        }
        else {
            lxerror("Local str too long");
        }
    }
L207:;
    *dest = 0;
    if (lx_stackindex == 0) {
        nextlx.length = dest-nextlx.svalue;
    }
    else {
        nextlx.length = length;
        nextlx.svalue = (byte *)pcm_alloc(length+1);
        memcpy((int32 *)nextlx.svalue,(int32 *)&str,length+1);
    }
}

static void addlisttoken	(tokenrec * * ulist,tokenrec * * ulistx,tokenrec * p) {
    if (*ulist == 0) {
        *ulist = *ulistx = p;
    }
    else {
        (*ulistx)->nexttoken = p;
    }
    p->nexttoken = 0;
    *ulistx = p;
}

static void addlisttoken_copy	(tokenrec * * ulist,tokenrec * * ulistx,tokenrec * q) {
tokenrec *	p;
    p = alloctoken();
    *p = *q;
    p->nexttoken = 0;
    if (*ulist == 0) {
        *ulist = *ulistx = p;
    }
    else {
        (*ulistx)->nexttoken = p;
    }
    p->nexttoken = 0;
    *ulistx = p;
}

static void addlist_nextlx	(tokenrec * * ulist,tokenrec * * ulistx) {
tokenrec *	p;
    p = alloctoken();
    *p = nextlx;
    p->nexttoken = 0;
    if (*ulist == 0) {
        *ulist = *ulistx = p;
    }
    else {
        (*ulistx)->nexttoken = p;
    }
    p->nexttoken = 0;
    *ulistx = p;
}

static void addlisttoken_seq	(tokenrec * * ulist,tokenrec * * ulistx,tokenrec * seq) {
tokenrec *	tk;
    while (seq) {
        tk = alloctoken();
        *tk = *seq;
        if (*ulist == 0) {
            *ulist = *ulistx = tk;
        }
        else {
            (*ulistx)->nexttoken = tk;
        }
        tk->nexttoken = 0;
        *ulistx = tk;
        seq = seq->nexttoken;
    }
}

static void addlistmparam	(mparamrec * * ulist,mparamrec * * ulistx,mparamrec * p) {
    if (*ulist == 0) {
        *ulist = *ulistx = p;
    }
    else {
        (*ulistx)->nextmparam = p;
    }
    *ulistx = p;
}

static void dodefine	(void) {
mparamrec *	stlist;
mparamrec *	stlistx;
mparamrec *	p;
mparamrec *	q;
strec *	stname;
strec *	d;
tokenrec *	tklist;
tokenrec *	tklistx;
tokenrec *	tk;
int32	nparams;
int32	ntokens;
int32	paramno;
    lexreadtoken();
    if (nextlx.symbol != namesym) {
        lxerror("define: name expected");
    }
    stname = nextlx.symptr;
    if (nextlx.symptr->nameid == macroid) {
    }
    stname->oldsymbol = stname->symbol;
    stname->symbol = namesym;
    stname->nameid = macroid;
    nparams = 0;
    if (*lxsptr == '(') {
        ++lxsptr;
        stlist = stlistx = 0;
        stname->attribs.ax_flmacro = 1;
        lexreadtoken();
        while (1) {
            if ((nextlx.symbol==namesym)) {
                d = nextlx.symptr;
                p = stlist;
                while (p) {
                    if (p->def == d) {
                        lxerror("Dupl macro param");
                    }
                    p = p->nextmparam;
                }
                q = (mparamrec *)pcm_alloc(16);
                q->def = d;
                q->nextmparam = 0;
                addlistmparam(&stlist,&stlistx,q);
                ++nparams;
                lexreadtoken();
                *(d->name+d->namelen) = 0;
                if (nextlx.symbol == commasym) {
                    lexreadtoken();
                }
            } else if ((nextlx.symbol==rbracksym)) {
                goto L221;
            } else if ((nextlx.symbol==ellipsissym)) {
                d = addnamestr("__VA_ARGS__");
                stname->attribs.ax_varparams = 1;
                lexreadtoken();
                if (nextlx.symbol != rbracksym) {
                    lxerror("')' expected");
                }
                q = (mparamrec *)pcm_alloc(16);
                q->def = d;
                q->nextmparam = 0;
                addlistmparam(&stlist,&stlistx,q);
                ++nparams;
                goto L221;
            }
            else {
                lxerror("macro params?");
            }
        }
L221:;
        stname->mparamlist = stlist;
    }
    tklist = tklistx = 0;
    ntokens = 0;
    while (1) {
        lexreadtoken();
        if ((nextlx.symbol==eolsym) || (nextlx.symbol==eofsym)) {
            goto L229;
        } else if ((nextlx.symbol==namesym)) {
            p = stname->mparamlist;
            paramno = 1;
            while (p) {
                if (p->def == nextlx.symptr) {
                    nextlx.flags |= tk_parammask;
                    nextlx.paramno = paramno;
                    goto L235;
                }
                p = p->nextmparam;
                ++paramno;
            }
L235:;
            if (nextlx.symptr == stname) {
                nextlx.flags |= tk_macromask;
            }
        }
        ++ntokens;
        tk = alloctoken();
        *tk = nextlx;
        addlisttoken(&tklist,&tklistx,tk);
    }
L229:;
    stname->tokenlist = tklist;
    stname->attribs.ax_nparams = nparams;
}

static void readalphanumeric	(byte * pstart) {
    while ((uchar)alphamap[*lxsptr++]) {
    }
    --lxsptr;
    nextlx.svalue = pstart;
    nextlx.symbol = rawnumbersym;
    nextlx.length = lxsptr-pstart;
}

static int32 inmacrostack	(strec * d,tokenrec * macrostack) {
    while (macrostack) {
        if (macrostack->symptr == d) {
            return 1;
        }
        macrostack = macrostack->nexttoken;
    }
    return 0;
}

static void showtokens	(char * caption,tokenrec * tk) {
    printf("%s%s",caption,"<");
    while (tk) {
        showtoken(tk);
        tk = tk->nexttoken;
    }
    printf("%s\n",">");
}

static void lexa	(tokenrec * * tk) {
    if (*tk == normaltk) {
        lexreadtoken();
        return;
    }
    if (*tk == 0) {
        nextlx.symbol = eofsym;
        return;
    }
    nextlx = **tk;
    *tk = (*tk)->nexttoken;
}

static void lexm	(void) {
strec *	d;
static int32	doreset=0;
int32	newlineno;
L245:;
    while (1) {
        if (tkptr) {
            nextlx = *tkptr;
            tkptr = tkptr->nexttoken;
            if (tkptr == 0) {
                if (nextlx.symbol == namesym && nextlx.symptr->nameid == macroid && !!peeklb()) {
                    nextlx.fileno = sfileno;
                    nextlx.lineno = slineno;
                    doreset = 0;
                    goto L247;
                }
                doreset = 1;
            }
            return;
        }
        if (doreset) {
            nextlx.fileno = sfileno;
            nextlx.lineno = slineno;
            doreset = 0;
        }
        lexreadtoken();
TEST1:
L247:;
        if ((nextlx.symbol==lexhashsym)) {
            if (!!dolexdirective()) {
                return;
            }
            goto L245;
        } else if ((nextlx.symbol==namesym)) {
            d = nextlx.symptr;
            if ((d->symbol==predefmacrosym)) {
                sfileno = nextlx.fileno;
                slineno = nextlx.lineno;
                expandpredefmacro(d->subcode,&nextlx,nextlx.lineno);
                doreset = 1;
                return;
            }
            else {
                if (d->nameid != macroid || noexpand) {
                    return;
                }
            }
        }
        else {
            return;
        }
        sfileno = nextlx.fileno;
        slineno = nextlx.lineno;
        if (!!d->attribs.ax_flmacro) {
            if (!peeklb()) {
                return;
            }
            tkptr = expandfnmacro(d,0,&normaltk,1,&newlineno);
            slineno = newlineno;
        }
        else {
            tkptr = expandobjmacro(d,0,&normaltk,1);
        }
        if (tkptr == 0) {
            doreset = 1;
        }
    }
}

static int32 peeklb	(void) {
    if (*lxsptr == '(' || *lxsptr == ' ' && *(lxsptr+1) == '(') {
        return 1;
    }
    return 0;
}

static int32 peektk	(tokenrec * tk) {
    tk = tk->nexttoken;
    if (tk == 0) {
        return 0;
    }
    if (tk->symbol == lbracksym) {
        return 1;
    }
    return 0;
}

static tokenrec * expandobjmacro	(strec * m,tokenrec * macrostack,tokenrec * * tksource,int32 frombaselevel) {
tokenrec *	tk;
tokenrec *	p;
tokenrec *	repl;
tokenrec	newmacro;
int32	complex;
int32	useshh;
int32	expanded;
strec *	d;
    p = tk = m->tokenlist;
    complex = useshh = 0;
    while (p) {
        if (p->symbol == namesym) {
            d = p->symptr;
            if (d->nameid == macroid || d->symbol == predefmacrosym) {
                complex = 1;
                goto L253;
            }
        }
        else if (p->symbol == hashhashsym) {
            complex = useshh = 1;
            goto L253;
        }
        p = p->nexttoken;
    }
L253:;
    if (!complex) {
        return tk;
    }
    newmacro.symptr = m;
    newmacro.nexttoken = macrostack;
    if (useshh) {
        repl = substituteargs(m,0,0,0,0);
    }
    else {
        repl = m->tokenlist;
    }
    tk = scantokenseq(repl,&newmacro,&expanded);
    return tk;
}

static tokenrec * expandfnmacro	(strec * m,tokenrec * macrostack,tokenrec * * tksource,int32 frombaselevel,int32 * endlineno) {
tokenrec *	args[20];
tokenrec *	expargs[20];
tokenrec *	repl;
tokenrec *	tk;
tokenrec	newmacro;
int32	nargs;
int32	i;
int32	expanded;
    nargs = readmacrocall(m,(tokenrec * (*)[])&args,tksource);
    if (frombaselevel) {
        *endlineno = nextlx.lineno;
    }
    for (i=1; i<=nargs; ++i) {
        expargs[i-1] = 0;
    }
    repl = substituteargs(m,(tokenrec * (*)[])&args,(tokenrec * (*)[])&expargs,nargs,macrostack);
    newmacro.symptr = m;
    newmacro.nexttoken = macrostack;
    repl = scantokenseq(repl,&newmacro,&expanded);
    return repl;
}

static tokenrec * scantokenseq	(tokenrec * tk,tokenrec * macrostack,int32 * expanded) {
tokenrec *	newtk;
tokenrec *	newtkx;
tokenrec *	expandtk;
tokenrec *	oldtk;
strec *	m;
tokenrec	newmacro;
int32	noexpandflag;
int32	simple;
int32	dummy;
reenter:
L261:;
    *expanded = 0;
    newtk = newtkx = 0;
    noexpandflag = 0;
    simple = 1;
    oldtk = tk;
    while (tk) {
        if ((tk->symbol==namesym)) {
            if (tk->symptr->nameid == macroid || tk->symptr->symbol == predefmacrosym) {
                simple = 0;
                goto L264;
            }
        }
        if (tk == 0) {
            goto L264;
        }
        tk = tk->nexttoken;
    }
L264:;
    if (simple) {
        return oldtk;
    }
    tk = oldtk;
    while (tk) {
        if ((tk->symbol==namesym)) {
            m = tk->symptr;
            if (m->nameid == macroid && !noexpandflag) {
                if (!!(tk->flags&tk_macrolit) || noexpand) {
                    goto L272;
                }
                if (!!inmacrostack(m,macrostack)) {
                    addlisttoken_copy(&newtk,&newtkx,tk);
                    newtkx->flags |= tk_macrolit;
                    goto L273;
                }
                simple = 0;
                if (!!m->attribs.ax_flmacro) {
                    if (!peektk(tk)) {
                        goto L272;
                    }
                    lexa(&tk);
                    expandtk = expandfnmacro(m,macrostack,&tk,1,&dummy);
                    addlisttoken_seq(&newtk,&newtkx,expandtk);
                    *expanded = 1;
                    goto L267;
                }
                else {
                    expandtk = expandobjmacro(m,macrostack,&tk,0);
                    *expanded = 1;
                    addlisttoken_seq(&newtk,&newtkx,expandtk);
                }
            }
            else if (m->symbol == kdefinedsym) {
                noexpandflag = 1;
                goto L272;
            }
            else if (m->symbol == predefmacrosym) {
                expandtk = alloctokenz();
                expandpredefmacro(m->subcode,expandtk,nextlx.lineno);
                addlisttoken_copy(&newtk,&newtkx,expandtk);
                goto L276;
            }
            else {
                noexpandflag = 0;
                goto L272;
            }
        }
        else {
simpletoken:
L272:;
            addlisttoken_copy(&newtk,&newtkx,tk);
        }
skip:
L273:;
        if (tk == 0) {
            goto L268;
        }
skip2:
L276:;
        tk = tk->nexttoken;
L267:;
    }
L268:;
    if (!!*expanded) {
        tk = newtk;
        goto L261;
    }
    return newtk;
}

static int32 readmacrocall	(strec * d,tokenrec * (*args)[],tokenrec * * tksource) {
int32	nparams;
int32	lbcount;
int32	paramno;
int32	nargs;
int32	usesvargs;
int32	varg;
tokenrec *	tklist;
tokenrec *	tklistx;
    lexa(tksource);
    if (nextlx.symbol != lbracksym) {
        lxerror("rmc: no '('");
    }
    nparams = d->attribs.ax_nparams;
    nargs = 0;
    if (nparams == 0) {
        lexa(tksource);
        if (nextlx.symbol != rbracksym) {
            lxerror("rmc: ')' expected");
        }
        return 0;
    }
    paramno = 1;
    lbcount = 1;
    tklist = tklistx = 0;
    usesvargs = d->attribs.ax_varparams;
    varg = 0;
    while (1) {
        if (paramno == nparams && usesvargs) {
            varg = 1;
        }
        lexa(tksource);
        if ((nextlx.symbol==commasym)) {
            if (lbcount == 1 && !varg) {
                if (tklist == 0) {
                    tklist = alloctokenz();
                    tklist->fileno = nextlx.fileno;
                    tklist->symbol = placeholdersym;
                }
                (*args)[paramno-1] = tklist;
                tklist = tklistx = 0;
                ++paramno;
            }
            else {
                goto L280;
            }
        } else if ((nextlx.symbol==eofsym)) {
            lxerror("EOS in macro call");
        } else if ((nextlx.symbol==lbracksym)) {
            ++lbcount;
            goto L280;
        } else if ((nextlx.symbol==rbracksym)) {
            if (lbcount > 1) {
                --lbcount;
                addlist_nextlx(&tklist,&tklistx);
            }
            else {
                if (tklist == 0) {
                    tklist = alloctokenz();
                    tklist->fileno = nextlx.fileno;
                    tklist->symbol = placeholdersym;
                }
                (*args)[paramno-1] = tklist;
                goto L278;
            }
        }
        else {
addtoken:
L280:;
            addlist_nextlx(&tklist,&tklistx);
        }
    }
L278:;
    if (paramno != nparams) {
        if (paramno+1 == nparams && usesvargs) {
            (*args)[nparams-1] = 0;
        }
        else {
            lxerror("Wrong # macro params");
        }
    }
    return nparams;
}

static tokenrec * substituteargs	(strec * m,tokenrec * (*args)[],tokenrec * (*expargs)[],int32 nargs,tokenrec * macrostack) {
mparamrec *	params;
tokenrec *	seq;
tokenrec *	seqstart;
tokenrec *	lasttoken;
tokenrec *	newtk;
tokenrec *	newtkx;
tokenrec *	niltk;
tokenrec *	tkexp;
tokenrec	tk;
int32	n;
int32	i;
int32	expanded;
enum {maxhashhash = 100};
tokenrec *	hhpoints[100];
int32	nhashhash;
    params = m->mparamlist;
    seq = seqstart = m->tokenlist;
    newtk = newtkx = 0;
    nhashhash = 0;
    lasttoken = 0;
    while (seq) {
        if ((seq->symbol==hashsym)) {
            if (nargs) {
                seq = seq->nexttoken;
                if (seq == 0) {
                    lxerror("# at end");
                }
                if (!(seq->flags&tk_parammask)) {
                    lxerror("# not followed by param");
                }
                n = seq->paramno;
                stringify((*args)[n-1],&tk);
                addlisttoken_copy(&newtk,&newtkx,&tk);
            }
            else {
                addlisttoken(&newtk,&newtkx,seq);
                newtkx->symbol = lithashsym;
            }
        } else if ((seq->symbol==hashhashsym)) {
            if (seq == seqstart) {
                lxerror("## at start");
            }
            if (nhashhash >= maxhashhash) {
                lxerror("Too many ##");
            }
            hhpoints[++nhashhash-1] = newtkx;
        }
        else {
            if (seq->symbol == namesym && !!(seq->flags&tk_parammask) && nargs) {
                n = seq->paramno;
                if (!!seq->nexttoken && seq->nexttoken->symbol == hashhashsym || lasttoken && lasttoken->symbol == hashhashsym) {
                    addlisttoken_seq(&newtk,&newtkx,(*args)[n-1]);
                }
                else {
                    tkexp = (*expargs)[n-1];
                    if (tkexp == 0) {
                        tkexp = (*expargs)[n-1] = scantokenseq((*args)[n-1],macrostack,&expanded);
                    }
                    addlisttoken_seq(&newtk,&newtkx,tkexp);
                }
            }
            else {
doother:
                addlisttoken_copy(&newtk,&newtkx,seq);
            }
        }
        lasttoken = seq;
        seq = seq->nexttoken;
    }
    if (nhashhash) {
        niltk = 0;
        for (i=1; i<=nhashhash; ++i) {
            pastetokens(hhpoints[i-1],((i < nhashhash)?&hhpoints[i+1-1]:&niltk));
        }
    }
    return newtk;
}

static char * strtoken	(tokenrec * lp,int32 * length) {
char *	name;
char *	s;
tokenrec	l;
    l = *lp;
    if ((l.symbol==namesym)) {
doname:
L295:;
        *length = l.symptr->namelen;
        return l.symptr->name;
    } else if ((l.symbol==intconstsym) || (l.symbol==realconstsym)) {
        *length = l.length;
        if (!!l.fileno) {
            return sourcefiletext[l.fileno]+l.numberoffset;
        }
        else {
            return pastedtokenlist[l.pasteno-1];
        }
    } else if ((l.symbol==rawnumbersym)) {
        *length = l.length;
        return (char *)l.svalue;
    } else if ((l.symbol==stringconstsym) || (l.symbol==wstringconstsym)) {
        s = strstring((char *)l.svalue,l.length,length,'"');
        return s;
    } else if ((l.symbol==charconstsym)) {
        s = strstring((char *)l.svalue,l.length,length,'\'');
        return s;
    } else if ((l.symbol==eolsym)) {
        if (dowhitespace) {
            *length = l.length+1;
            s = (char *)pcm_alloc(*length);
            *s = 10;
            memcpy((int32 *)(s+1),(int32 *)l.svalue,l.length);
        }
        else {
            *length = 1;
            return "\n";
        }
        return s;
    } else if ((l.symbol==eofsym)) {
        *length = 0;
        return "";
    } else if ((l.symbol==ktypespecsym) || (l.symbol==ktypequalsym) || (l.symbol==klinkagesym) || (l.symbol==kfnspecsym)) {
        goto L295;
    }
    else {
        name = shortsymbolnames[l.symbol-1];
        if (!!(*length = strlen(name))) {
            if ((uchar)*name != 'k') {
                return name;
            }
            else {
                *length = strlen(symbolnames[l.symbol-1]+1);
                return symbolnames[l.symbol-1]+1;
            }
        }
        else {
            printf("%s%s%s","<",symbolnames[l.symbol-1],">");
            lxerror("STRTOKEN: can't do this symbol");
        }
    }
    return "";
}

static char * strstring	(char * s,int32 length,int32 * newlength,int32 quotechar) {
char *	t;
char *	u;
    t = u = (char *)pcm_alloc(length*2+4);
    if (quotechar) {
        *u = quotechar;
        ++u;
    }
    convertstring(s,u,length);
    *newlength = strlen(t);
    if (quotechar) {
        *(t+*newlength) = quotechar;
        ++*newlength;
    }
    return t;
}

static void emittoken	(tokenrec * lp,strbuffer * dest) {
static int32	lasttoken=0;
int32	length;
char *	s;
    if (lp->symbol == eolsym && lasttoken == eolsym) {
        return;
    }
    s = strtoken(lp,&length);
    if (!!needspace(lasttoken,lp->symbol)) {
        gs_strn(dest," ",1);
    }
    gs_strn(dest,s,length);
    lasttoken = lp->symbol;
}

void showtoken	(tokenrec * lp) {
static strbuffer	buffer;
static strbuffer *	dest=&buffer;
    gs_init(dest);
    emittoken(lp,dest);
    printf("%.*s",dest->length,dest->strptr);
}

static void stringify	(tokenrec * seq,tokenrec * dest) {
char *	s;
int32	length;
static strbuffer	buffer;
static strbuffer *	deststr=&buffer;
    dest->symbol = stringconstsym;
    dest->nexttoken = 0;
    if (seq->nexttoken == 0) {
        s = strtoken(seq,&length);
        dest->length = length;
        dest->svalue = (byte *)s;
        return;
    }
    gs_init(deststr);
    while (seq) {
        emittoken(seq,deststr);
        seq = seq->nexttoken;
    }
    dest->length = length;
    dest->svalue = (byte *)deststr->strptr;
    dest->length = deststr->length;
}

static void pastetokens	(tokenrec * tk,tokenrec * * tknext) {
tokenrec *	tk2;
int32	length1;
int32	length2;
char *	s;
char *	t;
char *	u;
tokenrec	oldtoken;
tokenrec	token;
byte *	oldlxsptr;
int32	oldlx_stackindex;
    tk2 = tk->nexttoken;
    if (tk2 == *tknext) {
        *tknext = tk;
    }
    tk->nexttoken = tk2->nexttoken;
    if (tk->symbol == placeholdersym) {
        if (tk2->symbol == placeholdersym) {
        }
        else {
            *tk = *tk2;
        }
    }
    else if (tk2->symbol == placeholdersym) {
    }
    else {
        s = strtoken(tk,&length1);
        t = strtoken(tk2,&length2);
        u = (char *)pcm_alloc(length1+length2);
        memcpy((int32 *)u,(int32 *)s,length1);
        memcpy((int32 *)(u+length1),(int32 *)t,length2);
        *(u+length1+length2) = 0;
        if (npastedtokens >= maxpastedtokens) {
            lxerror("Too many pasted tokens");
        }
        pastedtokenlist[++npastedtokens-1] = u;
        oldtoken = nextlx;
        oldlxsptr = lxsptr;
        oldlx_stackindex = lx_stackindex;
        lxsptr = (byte *)u;
        lx_stackindex = 0;
        nextlx.fileno = 0;
        nextlx.fileno = 0;
        lexreadtoken();
        token = nextlx;
        lexreadtoken();
        if (nextlx.symbol != eofsym) {
        }
        nextlx = oldtoken;
        lxsptr = oldlxsptr;
        lx_stackindex = oldlx_stackindex;
        token.nexttoken = tk->nexttoken;
        token.fileno = 0;
        token.pasteno = npastedtokens;
        token.flags |= tk_pasted;
        *tk = token;
    }
}

static int32 getifexpr	(void) {
int32	sx;
int32	x;
    lexm();
    x = evalcondexpr(&sx);
    if (nextlx.symbol != eolsym) {
        lxerror("#if:eol expected");
    }
    return (int32)(x != 0);
}

static int64 evalcondexpr	(int32 * sx) {
int64	x;
int64	y;
int64	z;
int32	sy;
int32	sz;
    x = evalorexpr(sx);
    if (nextlx.symbol == questionsym) {
        lexm();
        y = evalcondexpr(&sy);
        if (nextlx.symbol != colonsym) {
            lxerror(": expected");
        }
        lexm();
        z = evalcondexpr(&sz);
        if (x) {
            *sx = sy;
            x = y;
        }
        else {
            *sx = sz;
            x = z;
        }
    }
    return x;
}

static int64 evalorexpr	(int32 * sx) {
int64	x;
int64	y;
int32	sy;
int32	opc;
    x = evalandexpr(sx);
    while (nextlx.symbol == orlsym) {
        lexm();
        y = evalandexpr(&sy);
        x = ((x || y)?1:0);
    }
    return x;
}

static int64 evalandexpr	(int32 * sx) {
int64	x;
int64	y;
int32	sy;
int32	opc;
    x = evaliorexpr(sx);
    while (nextlx.symbol == andlsym) {
        lexm();
        y = evaliorexpr(&sy);
        x = ((x && y)?1:0);
    }
    return x;
}

static int64 evaliorexpr	(int32 * sx) {
int64	x;
int64	y;
int32	sy;
int32	opc;
    x = evalixorexpr(sx);
    while (nextlx.symbol == iorsym) {
        lexm();
        x |= evalixorexpr(&sy);
    }
    return x;
}

static int64 evalixorexpr	(int32 * sx) {
int64	x;
int64	y;
int32	sy;
int32	opc;
    x = evaliandexpr(sx);
    while (nextlx.symbol == ixorsym) {
        lexm();
        x ^= evaliandexpr(&sy);
    }
    return x;
}

static int64 evaliandexpr	(int32 * sx) {
int64	x;
int64	y;
int32	sy;
int32	opc;
    x = evaleqexpr(sx);
    while (nextlx.symbol == iandsym) {
        lexm();
        x &= evaleqexpr(&sy);
    }
    return x;
}

static int64 evaleqexpr	(int32 * sx) {
int64	x;
int64	y;
int32	sy;
int32	opc;
    x = evalcmpexpr(sx);
    while ((opc = nextlx.symbol) == eqsym || opc == nesym) {
        lexm();
        y = evalcmpexpr(&sy);
        if ((opc==eqsym)) {
            x = (int64)(x == y);
        } else if ((opc==nesym)) {
            x = (int64)(x != y);
        }
    }
    return x;
}

static int64 evalcmpexpr	(int32 * sx) {
int64	x;
int64	y;
int32	sy;
int32	opc;
    x = evalshiftexpr(sx);
    while ((opc = nextlx.symbol) == ltsym || opc == lesym || opc == gesym || opc == gtsym) {
        lexm();
        y = evalshiftexpr(&sy);
        if ((opc==ltsym)) {
            x = (int64)(x < y);
        } else if ((opc==lesym)) {
            x = (int64)(x <= y);
        } else if ((opc==gesym)) {
            x = (int64)(x >= y);
        } else if ((opc==gtsym)) {
            x = (int64)(x > y);
        }
    }
    return x;
}

static int64 evalshiftexpr	(int32 * sx) {
int64	x;
int64	y;
int32	sy;
int32	opc;
    x = evaladdexpr(sx);
    while ((opc = nextlx.symbol) == shlsym || opc == shrsym) {
        lexm();
        y = evaladdexpr(&sy);
        if ((opc==shrsym)) {
            x = x>>y;
        } else if ((opc==shlsym)) {
            x = x<<y;
        }
    }
    return x;
}

static int64 evaladdexpr	(int32 * sx) {
int64	x;
int64	y;
int32	sy;
int32	opc;
    x = evalmulexpr(sx);
    while ((opc = nextlx.symbol) == addsym || opc == subsym) {
        lexm();
        y = evalmulexpr(&sy);
        if ((opc==addsym)) {
            x += y;
        } else if ((opc==subsym)) {
            x -= y;
        }
    }
    return x;
}

static int64 evalmulexpr	(int32 * sx) {
int64	x;
int64	y;
int32	sy;
int32	opc;
    x = evalunaryexpr(sx);
    while ((opc = nextlx.symbol) == mulsym || opc == divsym || opc == remsym) {
        lexm();
        y = evalunaryexpr(&sy);
        if (y == 0 && opc != mulsym) {
            lxerror("#if:div by zero");
        }
        if ((opc==mulsym)) {
            x *= y;
        } else if ((opc==divsym)) {
            x = x/ y;
        } else if ((opc==remsym)) {
            x = x% y;
        }
    }
    return x;
}

static int64 evalunaryexpr	(int32 * sx) {
int64	x;
int32	opc;
    if ((nextlx.symbol==addsym) || (nextlx.symbol==subsym) || (nextlx.symbol==notlsym) || (nextlx.symbol==inotsym)) {
        opc = nextlx.symbol;
        lexm();
        x = evalunaryexpr(sx);
        if ((opc==addsym)) {
            return x;
        } else if ((opc==subsym)) {
            return -x;
        } else if ((opc==notlsym)) {
            return (int64)!x;
        } else if ((opc==inotsym)) {
            return ~x;
        }
    }
    return evalterm(sx);
}

static int64 evalterm	(int32 * sx) {
int64	res;
int32	lb;
    *sx = 1;
    if ((nextlx.symbol==namesym)) {
        if ((nextlx.symptr->symbol==kdefinedsym)) {
            noexpand = 1;
            lb = 0;
            lexm();
            if (nextlx.symbol == lbracksym) {
                lb = 1;
                lexm();
            }
            if (nextlx.symbol != namesym) {
                lxerror("defined?");
            }
            res = (int64)(nextlx.symptr->nameid == macroid);
            lexm();
            if (lb) {
                if (nextlx.symbol != rbracksym) {
                    lxerror("')' expected");
                }
                lexm();
            }
            noexpand = 0;
        } else if ((nextlx.symptr->symbol==ksizeofsym)) {
            lexm();
            if (nextlx.symbol != lbracksym) {
                lxerror("'(' expected");
            }
            lexm();
            if (nextlx.symbol != namesym) {
                lxerror("name expected");
            }
            if ((nextlx.symptr->symbol==ktypespecsym)) {
                res = typespecsizes[nextlx.symptr->subcode-1];
            }
            else {
                lxerror("sizeof2");
            }
            lexm();
            if (nextlx.symbol != rbracksym) {
                lxerror("')' expected");
            }
            lexm();
        }
        else {
            lexm();
            return 0;
        }
    } else if ((nextlx.symbol==intconstsym)) {
        res = nextlx.value;
        lexm();
    } else if ((nextlx.symbol==charconstsym)) {
        if (nextlx.length == 0) {
            res = 0;
        }
        else {
            res = *nextlx.svalue;
        }
        lexm();
    } else if ((nextlx.symbol==lbracksym)) {
        lexm();
        res = evalcondexpr(sx);
        if (nextlx.symbol != rbracksym) {
            lxerror(") expected");
        }
        lexm();
    }
    else {
        printsymbol(&nextlx);
        printstrn((char *)nextlx.svalue,nextlx.length,0);
        printf("\n");
        lxerror("evalterm?");
    }
    return res;
}

static int32 getifdef	(void) {
int32	res;
strec *	d;
    noexpand = 1;
    lexreadtoken();
    noexpand = 0;
    if (nextlx.symbol != namesym) {
        lxerror("Name expected");
    }
    d = nextlx.symptr;
    res = 0;
    if (d->nameid == macroid) {
        res = 1;
    }
    else if (d->symbol == predefmacrosym) {
        res = 1;
    }
    lexreadtoken();
    if (nextlx.symbol != eolsym) {
        lxerror("EOL expected");
    }
    return res;
}

static int32 skipcode	(void) {
int32	level;
int32	dir;
byte *	pp;
    level = 0;
    while (1) {
        fastreadtoken();
        if ((nextlx.symbol==lexhashsym)) {
            dir = getlexdirective();
            if ((dir==ifdir) || (dir==ifdefdir) || (dir==ifndefdir)) {
                ++level;
            } else if ((dir==elifdir) || (dir==elsedir)) {
                if (level == 0) {
                    return dir;
                }
            } else if ((dir==endifdir)) {
                if (level == 0) {
                    return dir;
                }
                --level;
            }
        } else if ((nextlx.symbol==eofsym)) {
            lxerror("#if:Unexpected eof");
        }
    }
    return 0;
}

static void freetokens	(tokenrec * tk) {
tokenrec *	nexttk;
    while (tk) {
        nexttk = tk->nexttoken;
        pcm_free(tk,32);
        tk = nexttk;
    }
}

void fastreadtoken	(void) {
int32	c;
int32	csum;
int32	hsum;
int32	commentseen;
int32	dodir;
int32	j;
byte *	pstart;
byte *	p;
char *	ss;
    nextlx.subcodex = 0;
L383:;
    switch (*lxsptr++) {
    case '#':
        p = lxsptr-2;
        dodir = 0;
        while (p >= lxstart) {
            if ((*p==lf)) {
                dodir = 1;
                goto L387;
            } else if ((*p==tab) || (*p==' ')) {
            }
            else {
                goto L387;
            }
            --p;
        }
L387:;
        if (dodir || p < lxstart) {
            nextlx.symbol = lexhashsym;
            return;
        }
        else if (*lxsptr == '#') {
            ++lxsptr;
        }
        break;
    case '/':
        if ((*lxsptr=='/')) {
            readlinecomment();
        } else if ((*lxsptr=='*')) {
            readblockcomment();
        }
        break;
    case '\'':
        lxreadstring('\'',0);
        break;
    case '"':
        lxreadstring('"',0);
        break;
    case cr:
        ++NALLLINES;
        ++nextlx.lineno;
        nextlx.symbol = eolsym;
        nextlx.length = 0;
        ++lxsptr;
        break;
    case lf:
        ++nextlx.lineno;
        ++NALLLINES;
        nextlx.symbol = eolsym;
        nextlx.length = 0;
        break;
    case 0:
        --lxsptr;
        if (lx_stackindex) {
            unstacksourcefile();
        }
        else {
            nextlx.symbol = eofsym;
            return;
        }
        break;
    case 12:
        break;
    default:;
    }
    goto L383;
}

static tokenrec * alloctoken	(void) {
tokenrec *	tk;
    tk = (tokenrec *)pcm_alloc(32);
    return tk;
}

static tokenrec * alloctokenz	(void) {
tokenrec *	tk;
    tk = (tokenrec *)pcm_alloc(32);
    tk->nexttoken = 0;
    return tk;
}

static void expandpredefmacro	(int32 pdmcode,tokenrec * tk,int32 lineno) {
char *	s;
int32	fileno;
    if (noexpand) {
        return;
    }
    if ((pdmcode==pdm_date)) {
        tk->symbol = stringconstsym;
        tk->svalue = (byte *)"<Date>";
    } else if ((pdmcode==pdm_time)) {
        tk->symbol = stringconstsym;
        tk->svalue = (byte *)"<Time>";
    } else if ((pdmcode==pdm_file)) {
        tk->symbol = stringconstsym;
        fileno = tk->fileno;
        if (fileno == 0) {
            fileno = sfileno;
        }
        if (sfileno) {
            tk->svalue = (byte *)sourcefilenames[sfileno];
        }
        else {
            tk->svalue = (byte *)"(File not available)";
        }
    } else if ((pdmcode==pdm_line)) {
        tk->symbol = intconstsym;
        tk->value = lineno;
    } else if ((pdmcode==pdm_stdc)) {
        tk->symbol = intconstsym;
        tk->value = 1;
    } else if ((pdmcode==pdm_mcc)) {
        tk->symbol = intconstsym;
        tk->value = 1;
    }
    else {
        printf("%d\n",pdmcode);
        lxerror("PDM");
    }
    if (tk->symbol == stringconstsym) {
        tk->length = strlen((char *)tk->svalue);
        tk->subcode = trefchar;
    }
    else {
        tk->subcode = tsint;
        s = (char *)pcm_alloc(16);
        sprintf(s,"%lld",tk->value);
        tk->length = strlen(s);
        pastedtokenlist[++npastedtokens-1] = s;
        tk->fileno = 0;
        tk->pasteno = npastedtokens;
    }
}

static void dopragmadir	(void) {
    lexm();
    if (nextlx.symbol == namesym) {
        if (memcmp(nextlx.symptr->name,"pack",4) == 0) {
            lexm();
            if (nextlx.symbol != lbracksym) {
                lxerror("'(' expected");
            }
            lexm();
            if (nextlx.symbol == intconstsym) {
                if ((nextlx.value==1)) {
                    structpadding = 0;
                }
                else {
                    goto L407;
                    lxerror("Only pack(1) or () allowed");
                }
                lexm();
            }
            else if (nextlx.symbol == rbracksym) {
                structpadding = 1;
            }
        }
        else if (memcmp(nextlx.symptr->name,"$callback",9) == 0) {
            callbackflag = 1;
        }
    }
finish:
L407:;
    while (nextlx.symbol != eolsym && nextlx.symbol != eofsym) {
        lexm();
    }
}

static int32 needspace	(int32 a,int32 b) {
char *	aname;
char *	bname;
    aname = shortsymbolnames[a-1];
    bname = shortsymbolnames[b-1];
    if (((uchar)*bname=='n') || ((uchar)*bname=='k')) {
        if (((uchar)*aname=='n') || ((uchar)*aname=='k')) {
            return 1;
        }
    } else if (((uchar)*bname=='-') || ((uchar)*bname=='+')) {
        if (((uchar)*aname=='-') || ((uchar)*aname=='+')) {
            return 1;
        }
    }
    return 0;
}


// From module: cc_lib
static strec * newstrec	(void) {
strec *	p;
    p = (strec *)pcm_alloc(128);
    memset((int32 *)p,0,128);
    p->lineno = lx.lineno+(lx.fileno<<24);
    p->attribs.ax_moduleno = currmoduleno;
    return p;
}

void initcclib	(void) {
int32	i;
}

void printst	(void * f,strec * p,int32 level) {
strec *	q;
    if (p->symbol != namesym) {
        mcerror("PRINTST not name");
    }
    printstrec(f,p,level);
    q = p->deflist;
    while (q != 0) {
        printst(f,q,level+1);
        q = q->nextdef;
    }
}

static void printstrec	(void * f,strec * p,int32 level) {
attribrec	attrs;
byte *	q;
strbuffer	v;
strbuffer *	d=&v;
int32	col;
int32	offset;
char	str[256];
int32	scope;
paramrec *	pm;
int32	av_1;
    gs_init(d);
    offset = 0;
    av_1 = level;
    while (av_1--) {
        gs_str(d,"    ");
        offset += 4;
    }
    gs_str(d,":");
    if (!!p->blockno) {
        sprintf((char *)&str,"%s.%d",p->name,p->blockno);
        gs_leftstr(d,(char *)&str,28-offset,'-');
    }
    else {
        gs_leftstr(d,p->name,28-offset,'-');
    }
    gs_leftstr(d,namenames[p->nameid],12,'.');
    col = gs_getcol(d);
    attrs = p->attribs;
    gs_str(d,"[");
    gs_str(d,scopenames[p->scope]);
    gs_str(d," ");
    if (!!attrs.ax_static) {
        gs_str(d,"Stat");
    }
    if (!!attrs.ax_align) {
        gs_str(d,"@@");
        gs_strint(d,attrs.ax_align);
        gs_str(d," ");
    }
    if (!!attrs.ax_varparams) {
        gs_str(d,"Var ");
    }
    if (!!attrs.ax_used) {
        gs_str(d,"Used ");
    }
    if (!!attrs.ax_forward) {
        gs_str(d,"Fwd ");
    }
    if (!!attrs.ax_frame) {
        gs_str(d,"Frm ");
    }
    if (!!attrs.ax_autovar) {
        gs_str(d,"AV ");
    }
    if (!!attrs.ax_nparams) {
        sprintf((char *)&str,"Pm:%d ",attrs.ax_nparams);
        gs_str(d,(char *)&str);
    }
    if (!!attrs.ax_moduleno) {
        sprintf((char *)&str,"M#%d ",attrs.ax_moduleno);
        gs_str(d,(char *)&str);
    }
    if (!!attrs.ax_equals) {
        gs_str(d,"= ");
    }
    gs_str(d,"]");
    gs_padto(d,col+10,'=');
    if (!!p->owner) {
        sprintf((char *)&str,"(%s)",p->owner->name);
        gs_leftstr(d,(char *)&str,18,' ');
    }
    else {
        gs_leftstr(d,"()",18,' ');
    }
    if ((p->mode==tvoid)) {
        gs_str(d,"Void ");
    }
    else {
        gs_strsp(d,Strmode(p->mode,1));
    }
    if ((p->nameid==fieldid)) {
        gs_str(d,"Offset:");
        gs_strint(d,p->offset);
    } else if ((p->nameid==frameid) || (p->nameid==paramid)) {
        if (!!p->code) {
            gs_str(d,"=");
            gs_strvar(d,strexpr(p->code));
        }
        gs_str(d," Offset: ");
        gs_strint(d,p->offset);
    } else if ((p->nameid==procid)) {
        gs_str(d,"Index:");
        gs_strint(d,p->index);
        gs_str(d," Address:");
        sprintf((char *)&str,"%p",p->address);
        gs_str(d,(char *)&str);
        if (!!p->attribs.ax_callback) {
            gs_str(d,"<callback fn>");
        }
    } else if ((p->nameid==enumid)) {
        gs_str(d,"Enum:");
        gs_strint(d,p->index);
    } else if ((p->nameid==staticid)) {
        if (!!p->code) {
            gs_str(d,"=");
            gs_strvar(d,strexpr(p->code));
        }
        gs_str(d,"STATIC********");
    }
    gs_str(d," ");
    gs_str(d,"Lineno:");
    gs_strint(d,(p->lineno&16777215));
    gs_str(d," ");
    gs_str(d,sourcefilenames[p->lineno>>24]);
NEXT:
    if (p->nameid == procid) {
        gs_line(d);
        pm = p->paramlist;
        while (pm) {
            gs_str(d,"\t\tParam: ");
            gs_leftstr(d,(!!pm->def?(pm->def)->name:"Anon"),10,'-');
            gs_leftstr(d,Strmode(pm->mode,1),16,' ');
            gs_str(d,pmflagnames[pm->flags]);
            gs_line(d);
            pm = pm->nextparam;
        }
    }
    gs_println(d,f);
}

void printstflat	(void * f) {
int32	i;
strec *	p;
tokenrec *	lx;
    fprintf(f,"%s\n","GLOBAL SYMBOL TABLE:");
    for (i=0; i<=65534; ++i) {
        p = &hashtable[i];
        if (!!p->name) {
            if ((p->symbol==namesym)) {
                fprintf(f,"%d %p %s %s %s %s\n",i,(void*)(p),":",getstname(p),symbolnames[p->symbol-1],namenames[p->nameid]);
                p = p->nextdupl;
                while (p) {
                    fprintf(f,"%s %p %s %s %s %p","\t",(void*)(p),getstname(p),symbolnames[p->symbol-1],namenames[p->nameid],(void*)(p->prevdupl));
                    fprintf(f,"%s %s%s\n","(From",(!!p->owner?getstname(p->owner):"-"),")");
                    p = p->nextdupl;
                }
            }
        }
    }
}

unitrec * createname	(strec * p) {
unitrec *	u;
    u = allocunitrec();
    u->tag = j_name;
    u->def = p;
    u->simple = 1;
    return u;
}

unitrec * createunit0	(int32 tag) {
unitrec *	u;
    u = allocunitrec();
    u->tag = tag;
    return u;
}

unitrec * createunit1	(int32 tag,unitrec * p) {
unitrec *	u;
    u = allocunitrec();
    u->tag = tag;
    u->a = p;
    return u;
}

unitrec * createunit2	(int32 tag,unitrec * p,unitrec * q) {
unitrec *	u;
    u = allocunitrec();
    u->tag = tag;
    u->a = p;
    u->b = q;
    return u;
}

unitrec * createunit3	(int32 tag,unitrec * p,unitrec * q,unitrec * r) {
unitrec *	u;
    u = allocunitrec();
    u->tag = tag;
    u->a = p;
    u->b = q;
    u->c = r;
    return u;
}

unitrec * createconstunit	(uint64 a,int32 t) {
unitrec *	u;
    u = allocunitrec();
    u->tag = j_const;
    u->value = a;
    u->mode = t;
    u->simple = 1;
    return u;
}

unitrec * createstringconstunit	(char * s,int32 length) {
unitrec *	u;
    u = allocunitrec();
    u->tag = j_const;
    u->svalue = s;
    u->mode = trefchar;
    if (length == -1) {
        u->slength = strlen(s);
    }
    else {
        u->slength = length;
    }
    u->isstrconst = 1;
    u->simple = 1;
    return u;
}

int32 getoptocode	(int32 opc) {
static int16	opctotable[82];
int32	n;
int32	opcto;
int32	i;
char	str[20];
    opcto = opctotable[opc];
    if (opcto) {
        return opcto;
    }
    strcpy((char *)&str,jtagnames[opc]);
    strcat((char *)&str,"to");
    for (i=0; i<=81; ++i) {
        if (strcmp(jtagnames[i],(char *)&str) == 0) {
            opctotable[opc] = i;
            return i;
        }
    }
    printf("%s\n",jtagnames[opc]);
    serror("Can't find -to version");
    return 0;
}

int64 getconstvalue	(unitrec * p,int32 ID) {
    if (p && p->tag == j_const) {
        return p->value;
    }
    serror("GCV Not constant");
    return 0;
}

char * nextautotype	(void) {
static char	str[32];
    sprintf((char *)&str,"$T%d",++autotypeno);
    return (char *)&str;
}

int32 createconstmode	(int32 m) {
int32	newm;
    if (!!ttconst[m]) {
        return m;
    }
    if (!!ttconsttype[m]) {
        return ttconsttype[m];
    }
    newm = copymode(m);
    ttconsttype[m] = newm;
    ttconst[newm] = 1;
    ttconsttype[newm] = m;
    return newm;
}

int32 createrefmode	(int32 m) {
int32	newm;
    if (!!ttreftype[m]) {
        return ttreftype[m];
    }
    newm = createnewmode(tref);
    ttreftype[m] = newm;
    tttarget[newm] = m;
    ttisref[newm] = 1;
    return newm;
}

int32 createprocmode	(int32 m,paramrec * pm) {
int32	newm;
    newm = createnewmode(tproc);
    ttparams[newm] = pm;
    tttarget[newm] = m;
    return newm;
}

int32 createarraymode	(int32 m,int32 length) {
int32	newm;
    newm = createnewmode(tarray);
    tttarget[newm] = m;
    ttlength[newm] = length;
    ttsize[newm] = length*ttsize[m];
    return newm;
}

int32 createenummode	(strec * e) {
int32	newm;
    newm = createnewmode(tenum);
    ttnamedef[newm] = e;
    return newm;
}

int32 createstructmode	(strec * s,int32 smode) {
int32	newm;
    newm = createnewmode(smode);
    ttnamedef[newm] = s;
    return newm;
}

void setnameptr	(unitrec * p) {
    p->def->code = p;
}

void printcode_all	(void * f,char * caption) {
int32	i;
strec *	p;
    for (i=1; i<=nmodules; ++i) {
        printcode(f,caption,i);
    }
}

void printcode	(void * f,char * caption,int32 n) {
int32	i;
strec *	p;
    p = moduletable[n].stmodule->deflist;
    fprintf(f,"%s %s %s\n",caption,"MODULE:",moduletable[n].name);
    while (p) {
        if ((p->nameid==procid)) {
            if (p->scope != imported_scope && !!p->code) {
                fprintf(f,"%s%s %s\n",p->name,"=",scopenames[p->scope]);
                printunit(f,p->code,0,"1");
                fprintf(f,"\n");
            }
        }
        p = p->nextdef;
    }
}

void printunit	(void * dev,unitrec * p,int32 level,char * prefix) {
unitrec *	q;
strec *	d;
int32	t;
int32	n;
char *	idname;
caserec *	pc;
    if (p == 0) {
        return;
    }
    if (p->tag >= j_dummy) {
        printf("%s %d\n","print unit: bad tag",p->tag);
        os_getch();
        exit(0);
    }
    if (!!p->lineno) {
        currlineno = p->lineno;
    }
    fprintf(dev,"%s",getprefix(level,prefix,p));
    idname = jtagnames[p->tag];
    if ((uchar)*idname == 'j') {
        idname += 2;
    }
    fprintf(dev,"%s%s",idname,": ");
    if (fdebug) {
        printf("%s %s\n","IDNAME=",idname);
    }
    if ((p->tag==j_name) || (p->tag==j_nameaddr)) {
        d = p->def;
        fprintf(dev,"%s %s",d->name,namenames[d->nameid]);
        if (!!d->code) {
            fprintf(dev,"%s%s%s"," {",jtagnames[d->code->tag],"}");
        }
        fprintf(dev,"%s%s"," ",getdottedname(d));
        if (!!p->c) {
            fprintf(dev,"%s %p"," Lastcall:",(void*)(p->c));
        }
    } else if ((p->tag==j_tempdecl) || (p->tag==j_decl) || (p->tag==j_goto)) {
        d = p->def;
        fprintf(dev,"%s %s",d->name,namenames[d->nameid]);
        fprintf(dev,"\n");
        printunit(dev,d->code,level+1,"1");
        return;
    } else if ((p->tag==j_goto)) {
        d = p->def;
        fprintf(dev,"%s %s",d->name,namenames[d->nameid]);
    } else if ((p->tag==j_labelstmt)) {
        fprintf(dev,"%s",p->def->name);
    } else if ((p->tag==j_casestmt)) {
        fprintf(dev,"%s %d","Index:",p->index);
    } else if ((p->tag==j_const)) {
        t = p->mode;
        if (t == trefchar) {
            if (!p->isstrconst) {
                goto L48;
            }
dostring:
L49:;
            if (p->slength > 256) {
                fprintf(dev,"%s%s %s%d","\"","(LONGSTR)","\" *",p->slength);
            }
            else {
                fprintf(dev,"%s%s%s%d","\"",p->svalue,"\" *",p->slength);
            }
        }
        else if (t >= tschar && t <= tsllong) {
            fprintf(dev,"%lld",p->value);
        }
        else if (t >= tuchar && t <= tullong) {
            fprintf(dev,"%llu",p->uvalue);
        }
        else if (t >= tfirstreal && t <= tlastreal) {
            fprintf(dev,"%f",p->xvalue);
        }
        else if (ttbasetype[t] == tref) {
            if (!!p->isstrconst) {
                goto L49;
            }
doref:
L48:;
            fprintf(dev,"%p",(void *)p->value);
        }
        else {
            printf("%s\n",typename(t));
            serror("PRINTUNIT BAD CONST");
        }
        fprintf(dev,"%s%s"," ",Strmode(t,1));
        if (!!p->isstrconst) {
            fprintf(dev,"%s","<STRCONST>");
        }
    } else if ((p->tag==j_convert)) {
        fprintf(dev,"%s",convnames[p->opcode]);
        fprintf(dev,"%s"," ");
        if (!!p->convmem) {
            fprintf(dev,"%s","Mem:");
        }
        fprintf(dev,"%s",typename(p->a->mode));
        fprintf(dev,"%s"," => ");
        if (!!p->convtomem) {
            fprintf(dev,"%s","Mem:");
        }
        fprintf(dev,"%s",typename(p->mode));
    } else if ((p->tag==j_scale)) {
        fprintf(dev,"%s %d","Scale:",p->scale);
    } else if ((p->tag==j_derefoffset) || (p->tag==j_addoffset)) {
        fprintf(dev,"%s %d","Ptrscale:",p->ptrscale);
    } else if ((p->tag==j_switch)) {
        pc = p->nextcase;
        n = 0;
        while (pc) {
            ++n;
            pc = pc->nextcase;
        }
        fprintf(dev,"%p %d",(void*)(p->nextcase),n);
    } else if ((p->tag==j_callfn)) {
        fprintf(dev,"%s %d"," Aparams:",p->aparams);
    } else if ((p->tag==j_deref)) {
    }
    if (!!p->simple) {
        fprintf(dev,"%s"," <simple>");
    }
    fprintf(dev,"\n");
    printunitlist(dev,p->a,level+1,"1");
    printunitlist(dev,p->b,level+1,"2");
    if (p->tag != j_block) {
        printunitlist(dev,p->c,level+1,"3");
    }
}

static void printunitlist	(void * dev,unitrec * p,int32 level,char * prefix) {
    if (p == 0) {
        return;
    }
    while (p) {
        printunit(dev,p,level,prefix);
        p = p->nextunit;
    }
}

static char * getprefix	(int32 level,char * prefix,unitrec * p) {
static char	str[512];
char	indentstr[512];
char *	modestr;
int32	length;
int32	av_2;
    indentstr[1-1] = 0;
    if (level > 10) {
        level = 10;
    }
    strcpy((char *)&indentstr,"-----------------");
    modestr = Strmode(p->mode,0);
    length = strlen(modestr);
    if (length < strlen((char *)&indentstr)) {
        memcpy((int32 *)&indentstr,(int32 *)modestr,length);
    }
    else {
        strcpy((char *)&indentstr,modestr);
    }
    av_2 = level;
    while (av_2--) {
        strcat((char *)&indentstr,"|---");
    }
    strcpy((char *)&str,getlineinfok());
    strcat((char *)&str,(char *)&indentstr);
    strcat((char *)&str,prefix);
    if (!!(uchar)*prefix) {
        strcat((char *)&str," ");
    }
    return (char *)&str;
}

char * getdottedname	(strec * p) {
static char	str[256];
char	str2[256];
strec *	owner;
    strcpy((char *)&str,p->name);
    owner = p->owner;
    while (owner && owner->nameid != programid) {
        strcpy((char *)&str2,(char *)&str);
        strcpy((char *)&str,owner->name);
        strcat((char *)&str,".");
        strcat((char *)&str,(char *)&str2);
        owner = owner->owner;
    }
    if (!!p->blockno) {
        sprintf((char *)&str2,".%d",p->blockno);
        strcat((char *)&str,(char *)&str2);
    }
    return (char *)&str;
}

static char * getlineinfok	(void) {
static char	str[40];
    sprintf((char *)&str,"%05d ",currlineno);
    return (char *)&str;
}

strec * getautofieldname	(void) {
char	str[32];
char *	name;
    sprintf((char *)&str,"$F%d",++nextafindex);
    name = pcm_copyheapstring((char *)&str);
    return addnamestr(name);
}

void convertstring	(char * s,char * t,int32 length) {
int32	c;
char	str[20];
char *	t0;
int32	av_3;
    if (length == -1) {
        length = strlen(s);
    }
    t0 = t;
    av_3 = length;
    while (av_3--) {
        c = (uchar)*s++;
        switch (c) {
        case '"':
            *t++ = '\\';
            *t++ = '"';
            break;
        case '\'':
            *t++ = '\\';
            *t++ = '\'';
            break;
        case 10:
            *t++ = '\\';
            *t++ = 'n';
            break;
        case 13:
            *t++ = '\\';
            *t++ = 'r';
            break;
        case 9:
            *t++ = '\\';
            *t++ = 't';
            break;
        case '\\':
            *t++ = '\\';
            *t++ = '\\';
            break;
        case 7:
            *t++ = '\\';
            *t++ = 'a';
            break;
        case 8:
            *t++ = '\\';
            *t++ = 'b';
            break;
        case 12:
            *t++ = '\\';
            *t++ = 'f';
            break;
        case 11:
            *t++ = '\\';
            *t++ = 'v';
            break;
        default:;
            if (c < 32 || c >= 127) {
                sprintf((char *)&str,"\\%03o",c);
                *t++ = (uchar)str[1-1];
                *t++ = (uchar)str[2-1];
                *t++ = (uchar)str[3-1];
                *t++ = (uchar)str[4-1];
            }
            else {
                *t++ = c;
            }
        }
    }
    *t = 0;
}

strbuffer * strexpr	(unitrec * p) {
    gs_init(exprstr);
    jeval(exprstr,p);
    return exprstr;
}

static void jeval	(strbuffer * dest,unitrec * p) {
unitrec *	q;
char	str[16000];
int32	lb;
int32	t;
    if ((p->tag==j_const)) {
        if ((t = p->mode) == trefchar) {
            if (p->slength == 0) {
                goto L79;
            }
            if (!p->isstrconst) {
                goto L79;
            }
            if (p->slength > 8000) {
                strcpy((char *)&str,"LONGSTR)");
            }
            else {
                convertstring(p->svalue,(char *)&str,-1);
            }
            gs_additem(dest,"\"");
            gs_additem(dest,(char *)&str);
            gs_additem(dest,"\"");
            return;
        }
        else if (t >= tschar && t <= tsllong) {
            sprintf((char *)&str,"%lld",p->value);
        }
        else if (t >= tuchar && t <= tullong) {
            sprintf((char *)&str,"%llu",p->uvalue);
        }
        else if (t == tdouble || t == tfloat) {
            sprintf((char *)&str,"%f",p->xvalue);
        }
        else {
            if (ttbasetype[p->mode] == tref) {
doref:
L79:;
                sprintf((char *)&str,"%p",p->value);
            }
            else {
                printf("%s\n",typename(p->mode));
                nxerror("EVAL/CONST",p);
            }
        }
        gs_additem(dest,(char *)&str);
    } else if ((p->tag==j_name)) {
        gs_additem(dest,p->def->name);
    } else if ((p->tag==j_nameaddr) || (p->tag==j_funcname)) {
        gs_str(dest,"&");
        gs_additem(dest,p->def->name);
    } else if ((p->tag==j_andl) || (p->tag==j_orl) || (p->tag==j_andand) || (p->tag==j_eq) || (p->tag==j_ne) || (p->tag==j_lt) || (p->tag==j_le) || (p->tag==j_gt) || (p->tag==j_ge) || (p->tag==j_add) || (p->tag==j_sub) || (p->tag==j_mul) || (p->tag==j_div) || (p->tag==j_rem) || (p->tag==j_iand) || (p->tag==j_ior) || (p->tag==j_ixor) || (p->tag==j_shl) || (p->tag==j_shr) || (p->tag==j_addto) || (p->tag==j_subto) || (p->tag==j_multo) || (p->tag==j_divto) || (p->tag==j_remto) || (p->tag==j_iandto) || (p->tag==j_iorto) || (p->tag==j_ixorto) || (p->tag==j_shlto) || (p->tag==j_shrto)) {
        strcpy((char *)&str,getopcjname(p->tag));
        gs_additem(dest,"(");
        jeval(dest,p->a);
        gs_additem(dest,(char *)&str);
        jeval(dest,p->b);
        gs_additem(dest,")");
    } else if ((p->tag==j_neg) || (p->tag==j_abs) || (p->tag==j_inot) || (p->tag==j_notl) || (p->tag==j_istruel)) {
        strcpy((char *)&str,getopcjname(p->tag));
        gs_additem(dest,(char *)&str);
        gs_additem(dest,"(");
        jeval(dest,p->a);
        gs_additem(dest,")");
    } else if ((p->tag==j_callfn)) {
        jeval(dest,p->a);
        gs_additem(dest,"(");
        q = p->b;
        while (q) {
            jeval(dest,q);
            q = q->nextunit;
            if (q) {
                gs_additem(dest,",");
            }
        }
        gs_additem(dest,")");
    } else if ((p->tag==j_dot)) {
        jeval(dest,p->a);
        gs_additem(dest,".");
        jeval(dest,p->b);
    } else if ((p->tag==j_idot)) {
        jeval(dest,p->a);
        gs_additem(dest,"->");
        jeval(dest,p->b);
    } else if ((p->tag==j_makelist) || (p->tag==j_exprlist)) {
        lb = (int32)(p->tag == j_exprlist);
        gs_additem(dest,(lb?"(":"{"));
        q = p->a;
        while (q) {
            jeval(dest,q);
            q = q->nextunit;
            if (q) {
                gs_additem(dest,",");
            }
        }
        gs_additem(dest,(lb?")":"}"));
    } else if ((p->tag==j_assign)) {
        jeval(dest,p->a);
        gs_additem(dest,"=");
        jeval(dest,p->b);
    } else if ((p->tag==j_ifx)) {
        jeval(dest,p->a);
        gs_additem(dest,"?");
        jeval(dest,p->b);
        gs_additem(dest,":");
        jeval(dest,p->c);
    } else if ((p->tag==j_convert)) {
        gs_additem(dest,Strmode(p->mode,1));
        gs_additem(dest,"(");
        jeval(dest,p->a);
        gs_additem(dest,")");
    } else if ((p->tag==j_deref)) {
        gs_additem(dest,"*(");
        jeval(dest,p->a);
        if (!!p->b) {
            gs_additem(dest,"+");
            jeval(dest,p->b);
        }
        gs_additem(dest,")");
    } else if ((p->tag==j_block)) {
        gs_additem(dest,"<JBLOCK>");
    } else if ((p->tag==j_preincr)) {
        gs_additem(dest,"++");
        jeval(dest,p->a);
    } else if ((p->tag==j_predecr)) {
        gs_additem(dest,"--");
        jeval(dest,p->a);
    } else if ((p->tag==j_postincr)) {
        jeval(dest,p->a);
        gs_additem(dest,"++");
    } else if ((p->tag==j_postdecr)) {
        jeval(dest,p->a);
        gs_additem(dest,"--");
    } else if ((p->tag==j_null)) {
        gs_str(dest,"<nullunit>");
    } else if ((p->tag==j_scale)) {
        gs_str(dest,"scale((");
        jeval(dest,p->a);
        if (p->scale > 0) {
            gs_str(dest,")*");
            gs_strint(dest,p->scale);
        }
        else {
            gs_str(dest,")/");
            gs_strint(dest,-p->scale);
        }
        gs_str(dest,")");
    }
    else {
        gs_str(dest,"<CAN'T DO JEVAL>");
    }
}

char * getopcjname	(int32 opc) {
static char	str[20];
char *	name;
char *	s;
    name = jtagnames[opc];
    s = strchr(name,' ');
    if (s) {
        memcpy((int32 *)&str,(int32 *)name,s-name);
        str[(s-name)+1-1] = 0;
        return (char *)&str;
    }
    else {
        return name;
    }
}

char * Strmode	(int32 m,int32 expand) {
static char	str[16384];
    istrmode(m,expand,(char *)&str);
    return (char *)&str;
}

char * Strmode2	(int32 m,int32 expand) {
static char	str[16384];
    istrmode(m,expand,(char *)&str);
    return (char *)&str;
}

void istrmode	(int32 m,int32 expand,char * dest) {
strec *	d;
strec *	q;
int32	value;
int32	needcomma;
int32	x;
int32	i;
int32	target;
int32	t;
int32	n;
strbuffer	sxx;
strbuffer *	xx=&sxx;
strbuffer *	sdim;
strbuffer *	slength;
char	strdim[100];
char	strlength[100];
paramrec *	pm;
    if (m < tlast) {
        strcpy(dest,typename(m));
        return;
    }
    t = ttbasetype[m];
    if ((t==tref)) {
        if (!!ttconst[m]) {
            strcpy(dest,"const ref ");
        }
        else {
            strcpy(dest,"ref ");
        }
        target = tttarget[m];
        if (target >= 0 && ttbasetype[tttarget[m]] == tstruct) {
            strcat(dest,typename(tttarget[m]));
        }
        else {
            istrmode(tttarget[m],0,dest+strlen(dest));
        }
    } else if ((t==tarray)) {
        if (!!ttlength[m]) {
            sprintf(dest,"[%d]",ttlength[m]);
        }
        else {
            sprintf(dest,"[]");
        }
        istrmode(tttarget[m],0,dest+strlen(dest));
    } else if ((t==tenum)) {
        strcpy(dest,"enum ");
        strcat(dest,typename(m));
    } else if ((t==tstruct) || (t==tunion)) {
        if (!expand) {
            strcpy(dest,typename(m));
            return;
        }
        strcpy(dest,typename(ttbasetype[m]));
        strcat(dest,"(");
        d = ttnamedef[m];
        needcomma = 0;
        q = d->deflist;
        while (q) {
            if (needcomma) {
                strcat(dest,",");
            }
            needcomma = 1;
            istrmode(q->mode,0,dest+strlen(dest));
            strcat(dest," ");
            strcat(dest,q->name);
            q = q->nextdef;
        }
        strcat(dest,")");
    } else if ((t==tvoid)) {
        strcpy(dest,typename(m));
    } else if ((t==tproc)) {
        strcpy(dest,"proc[PM](");
        pm = ttparams[m];
        n = pm->nparams;
        for (i=1; i<=n; ++i) {
            istrmode(pm->mode,0,dest+strlen(dest));
            if (i != n) {
                strcat(dest,",");
            }
            pm = pm->nextparam;
        }
        strcat(dest,")");
        istrmode(tttarget[m],0,dest+strlen(dest));
    }
    else {
        if (t < tlast) {
            strcpy(dest,typename(m));
            return;
        }
        else {
            printf("%s\n",typename(m));
            mcerror("NEWSTRMODE");
        }
    }
}

int32 countunits	(unitrec * p) {
int32	n;
    n = 0;
    while (p) {
        ++n;
        p = p->nextunit;
    }
    return n;
}

static void purgesymbol	(strec * p,strec * prev,int32 del) {
strec *	q;
    if ((p->nameid==fieldid)) {
        return;
    }
    purgesymbollist(p->deflist,0,del);
    if (prev) {
        prev->nextdef = p->nextdef;
    }
    else {
        p->owner->deflist = p->nextdef;
    }
    q = p->prevdupl;
    q->nextdupl = p->nextdupl;
    if (del) {
        pcm_free(p,128);
    }
}

void purgesymbollist	(strec * p,int32 ismodule,int32 del) {
strec *	q;
strec *	prev;
    serror("PURGESYMBOL");
}

void purgeprocs	(strec * p,int32 del) {
    while (p) {
        if (p->nameid == procid) {
            purgeproc(p,del);
        }
        p = p->nextdef;
    }
}

void purgeproc	(strec * p,int32 del) {
strec *	q;
strec *	prev;
strec *	r;
    q = p->deflist;
    prev = 0;
    while (q) {
        r = q->nextdef;
        if (q->nameid == frameid) {
            purgesymbol(q,prev,del);
        }
        else {
            prev = q;
        }
        q = r;
    }
}

void printmodelist	(void * f) {
enum {wtypeno = 4};
enum {wname = 13};
enum {wbasetype = 13};
enum {wbitsize = 3};
enum {wtarget = 14};
enum {wlength = 4};
enum {wsize = 5};
enum {wconst = 3};
enum {wrest = 3};
enum {wvolatile = 3};
enum {wused = 3};
enum {wconsttype = 5};
enum {wreftype = 5};
enum {wnamedef = 8};
enum {wmode = 32};
char	str[256];
char *	mstr;
strbuffer	destv;
strbuffer *	dest=&destv;
int32	m;
    fprintf(f,"%s %d\n","MODELIST",ntypes);
    gs_init(dest);
    gs_leftstr(dest,"#",wtypeno,32);
    gs_leftstr(dest,"Name",wname,32);
    gs_leftstr(dest,"Base",wbasetype,32);
    gs_leftstr(dest,"Bit",wbitsize,32);
    gs_leftstr(dest,"Target",wtarget,32);
    gs_leftstr(dest,"Len",wlength,32);
    gs_leftstr(dest,"Size",wsize,32);
    gs_leftstr(dest,"C",wconst,32);
    gs_leftstr(dest,"R",wrest,32);
    gs_leftstr(dest,"V",wvolatile,32);
    gs_leftstr(dest,"@Cnst",wconsttype,32);
    gs_leftstr(dest,"@Ref",wreftype,32);
    gs_leftstr(dest,"Tag",wnamedef,32);
    gs_leftstr(dest,"Mode",wmode,32);
    gs_println(dest,f);
    for (m=0; m<=ntypes; ++m) {
        gs_init(dest);
        gs_leftint(dest,m,wtypeno,32);
        gs_leftstr(dest,typename(m),wname,32);
        gs_leftstr(dest,typename(ttbasetype[m]),wbasetype,32);
        gs_leftint(dest,ttbitwidth[m],wbitsize,32);
        if (!!tttarget[m]) {
            gs_leftint(dest,tttarget[m],3,32);
            gs_leftstr(dest,typename(tttarget[m]),11,32);
        }
        else {
            gs_leftstr(dest,"-",wtarget,32);
        }
        if ((ttbasetype[m]==tarray) || (ttbasetype[m]==tstruct) || (ttbasetype[m]==tunion)) {
            gs_leftint(dest,ttlength[m],wlength,32);
        }
        else {
            gs_leftstr(dest,"",wlength,32);
        }
        gs_leftint(dest,ttsize[m],wsize,32);
        gs_leftint(dest,ttconst[m],wconst,32);
        gs_leftint(dest,ttrestrict[m],wrest,32);
        gs_leftint(dest,ttvolatile[m],wvolatile,32);
        gs_leftint(dest,ttconsttype[m],wconsttype,32);
        gs_leftint(dest,ttreftype[m],wreftype,32);
        if (!!ttnamedef[m]) {
            gs_leftstr(dest,ttnamedef[m]->name,wnamedef,32);
        }
        else {
            gs_leftstr(dest,"-",wnamedef,32);
        }
        mstr = Strmode(m,1);
        if (strlen(mstr) < 16) {
            gs_str(dest,mstr);
        }
        else {
            gs_println(dest,f);
            gs_init(dest);
            gs_str(dest,"\t\t");
            gs_str(dest,mstr);
        }
        gs_println(dest,f);
    }
    fprintf(f,"\n");
}

void addtoproclist	(strec * d) {
procrec *	pp;
    ++nproclist;
    pp = (procrec *)pcm_alloc(16);
    pp->nextproc = proclist;
    proclist = pp;
    pp->def = d;
}

char * typename	(int32 m) {
int32	basem;
static char	str[300];
    basem = ttbasetype[m];
    if ((basem==tstruct) || (basem==tunion)) {
        if (!!ttnamedef[m]) {
            return ttnamedef[m]->name;
        }
        return ((basem == tstruct)?"struct":"union");
    } else if ((basem==tarray)) {
        return "<array>";
    } else if ((basem==tenum)) {
        if (!!ttnamedef[m]) {
            return ttnamedef[m]->name;
        }
        return "<enum>";
    }
    else {
        if (!!ttconst[m]) {
            strcpy((char *)&str,"const ");
            strcat((char *)&str,stdtypenames[basem]);
            return (char *)&str;
        }
        return stdtypenames[basem];
    }
    return "";
}

unitrec * allocunitrec	(void) {
unitrec *	p;
int64 *	q;
int32	nwords;
    if (!!remainingunits--) {
        p = (unitrec *)unitheapptr;
        unitheapptr += 62;
        p->lineno = lx.lineno;
        if (lx.fileno <= 255) {
            p->fileno = lx.fileno;
        }
        return p;
    }
    p = (unitrec *)(unitheapptr = (byte *)pcm_alloc(3100000));
    memset((int32 *)p,0,3100000);
    remainingunits = 49999;
    unitheapptr += 62;
    p->lineno = lx.lineno;
    if (lx.fileno <= 255) {
        p->fileno = lx.fileno;
    }
    return p;
}

static int32 copymode	(int32 m) {
    if (ntypes >= maxtype) {
        serror("Too many types");
    }
    ++ntypes;
    ttnamedef[ntypes] = ttnamedef[m];
    ttbasetype[ntypes] = ttbasetype[m];
    ttlength[ntypes] = ttlength[m];
    ttconst[ntypes] = ttconst[m];
    ttrestrict[ntypes] = ttrestrict[m];
    ttvolatile[ntypes] = ttvolatile[m];
    ttusertype[ntypes] = ttusertype[m];
    ttsize[ntypes] = ttsize[m];
    ttbitwidth[ntypes] = ttbitwidth[m];
    tttarget[ntypes] = tttarget[m];
    ttparams[ntypes] = ttparams[m];
    ttisref[ntypes] = ttisref[m];
    return ntypes;
}

static int32 createnewmode	(int32 m) {
    if (ntypes >= maxtype) {
        printf("%s %d\n","MAXTYPE=",maxtype);
        serror("Too many types/cnm");
    }
    ++ntypes;
    ttbasetype[ntypes] = m;
    ttsize[ntypes] = ttsize[m];
    ttbitwidth[ntypes] = ttbitwidth[m];
    return ntypes;
}

void addlistunit	(unitrec * * ulist,unitrec * * ulistx,unitrec * p) {
    if (*ulist == 0) {
        *ulist = *ulistx = p;
    }
    else {
        (*ulistx)->nextunit = p;
    }
    p->nextunit = 0;
    *ulistx = p;
}

void addlistdef	(strec * * ulist,strec * * ulistx,strec * p) {
    if (*ulist == 0) {
        *ulist = *ulistx = p;
    }
    else {
        (*ulistx)->nextdef = p;
    }
    p->nextdef = 0;
    *ulistx = p;
}

void addlistparam	(paramrec * * ulist,paramrec * * ulistx,paramrec * p) {
    if (*ulist == 0) {
        *ulist = *ulistx = p;
    }
    else {
        (*ulistx)->nextparam = p;
    }
    p->nextparam = 0;
    *ulistx = p;
}

void checksymbol	(int32 symbol) {
char	str[256];
    if (lx.symbol != symbol) {
        sprintf((char *)&str,"%s expected, not %s",symbolnames[symbol-1],symbolnames[lx.symbol-1]);
        if (lx.symbol == namesym) {
            strcat((char *)&str," \"");
            strcat((char *)&str,getstname(lx.symptr));
            strcat((char *)&str,"\"");
        }
        serror((char *)&str);
    }
}

void skipsymbol	(int32 symbol) {
    if (lx.symbol != symbol) {
        checksymbol(symbol);
    }
    lex();
}

void inittypetables	(void) {
int32	i;
int32	j;
int32	size;
int32	bitsize;
int32	s;
int32	t;
int32	u;
    for (i=0; i<=21; ++i) {
        ttbasetype[i] = i;
        bitsize = stdtypewidths[i];
        size = bitsize/ 8;
        ttsize[i] = size;
        ttbitwidth[i] = bitsize;
    }
    ntypes = 21;
    trefchar = createrefmode(tuchar);
    trefwchar = createrefmode(tushort);
    for (i=1; i<=144; ++i) {
        s = dominantsetuptable[i-1][1-1];
        t = dominantsetuptable[i-1][2-1];
        u = dominantsetuptable[i-1][3-1];
        dominantmode[s][t] = u;
    }
    for (i=1; i<=144; ++i) {
        s = convsetuptable[i-1][1-1];
        t = convsetuptable[i-1][2-1];
        u = convsetuptable[i-1][3-1];
        conversionops[s][t] = u;
    }
}

strec * createdupldef	(strec * owner,strec * symptr,int32 id) {
strec *	p;
strec *	q;
    p = newstrec();
    p->name = symptr->name;
    p->namelen = symptr->namelen;
    p->symbol = namesym;
    p->owner = owner;
    p->nameid = id;
    p->namespace = namespaces[id];
    if (!!(q = symptr->nextdupl)) {
        q->prevdupl = p;
    }
    p->nextdupl = q;
    p->prevdupl = symptr;
    symptr->nextdupl = p;
    if (owner) {
        if (owner->deflist == 0) {
            owner->deflist = owner->deflistx = p;
        }
        else {
            owner->deflistx->nextdef = p;
            owner->deflistx = p;
        }
    }
    return p;
}

strec * createnewmoduledef	(strec * owner,strec * symptr) {
strec *	p;
strec *	q;
    p = createdupldef(owner,symptr,moduleid);
    return p;
}

strec * createnewproc	(strec * owner,strec * symptr) {
strec *	p;
strec *	q;
    p = createdupldef(owner,symptr,procid);
    q = p;
    while (q = q->nextdupl) {
        if (q->owner == owner) {
            printf("%s %s %s\n",q->name,"in",owner->name);
            serror("Dupl proc name");
        }
    }
    return p;
}

strec * resolvename	(strec * owner,strec * symptr,int32 ns,int32 blockno) {
static int32	NNN=0;
int32	nsblock;
strec *	d;
    if (symptr->nameid > macroid) {
        return symptr;
    }
    if (blockno && blockcounts[blockno] == 0) {
        blockno = blockowner[blockno];
    }
L161:;
    while (1) {
        nsblock = ns<<16|blockno;
        d = symptr;
        while (d = d->nextdupl) {
            if (d->owner == owner && d->nsblock == nsblock) {
                return d;
            }
        }
        if (blockno == 0) {
            if ((owner->nameid==procid)) {
                owner = stmodule;
                goto L161;
            } else if ((owner->nameid==structtagid)) {
                owner = owner->owner;
                if (owner == 0) {
                    return 0;
                }
            }
            else {
                return 0;
            }
        }
        else if ((blockno = blockowner[blockno]) == 0) {
            owner = stmodule;
        }
    }
    return 0;
}

strec * checkdupl	(strec * owner,strec * symptr,int32 ns,int32 blockno) {
int32	nsblock;
strec *	d;
    d = symptr;
    nsblock = ns<<16|blockno;
    while (d = d->nextdupl) {
        if (d->owner == owner && d->nsblock == nsblock) {
            return d;
        }
    }
    return 0;
}

strec * checkdupl_inproc	(strec * owner,strec * symptr,int32 ns,int32 blockno) {
int32	nsblock;
strec *	d;
    d = symptr;
    nsblock = ns<<16|blockno;
    while (!!(d = d->nextdupl) && d->owner == owner) {
        if (d->nsblock == nsblock) {
            return d;
        }
    }
    return 0;
}

int32 getalignment	(int32 m) {
int32	a;
    if ((ttbasetype[m]==tarray)) {
        return getalignment(tttarget[m]);
    } else if ((ttbasetype[m]==tstruct) || (ttbasetype[m]==tunion)) {
        a = ttnamedef[m]->attribs.ax_align;
        if (a == 0) {
            serror("GETALIGN 0");
        }
        return a;
    }
    a = ttsize[m];
    if ((a==1) || (a==2) || (a==4) || (a==8)) {
        return a;
    }
    printf("%s\n",Strmode(m,1));
    serror("GETALIGN SIZE NOT 1248");
    return 0;
}


// From module: cc_parse
static void readmodule	(void) {
int32	linkage;
int32	m;
int32	mbase;
int32	commaseen;
int32	wasdef;
unitrec *	p;
strec *	d;
paramrec *	pm;
int32	t;
    while (lx.symbol != eofsym) {
        if (lx.symbol == kshowtypesym) {
            lex();
            t = readcasttype(&d,0,&pm);
            skipsymbol(semisym);
            printf("%s %s\n","Type is:",Strmode(t,1));
            goto L2;
        }
        mbase = readdeclspec(stmodule,&linkage);
        commaseen = 0;
L4:;
        if ((lx.symbol==namesym) || (lx.symbol==mulsym) || (lx.symbol==lbracksym)) {
            m = readtype(stmodule,&d,mbase,&pm);
            if (d == 0) {
                serror("Var name expected");
            }
            if (linkage == typedef_ss) {
                d = createtypedef(stmodule,d,m);
            }
            else if (pm) {
                if (lx.symbol == lcurlysym && commaseen) {
                    serror("fn def after comma");
                }
                d = readfunction(d,m,linkage,pm,&wasdef);
                if (wasdef) {
                    goto L5;
                }
            }
            else {
                d = readmodulevar(d,m,linkage);
            }
            if ((lx.symbol==commasym)) {
                commaseen = 1;
                lex();
            }
            else {
                skipsymbol(semisym);
                goto L5;
            }
        }
        else {
            if ((ttbasetype[mbase]==tenum) || (ttbasetype[mbase]==tstruct) || (ttbasetype[mbase]==tunion)) {
                skipsymbol(semisym);
                goto L5;
            } else if ((ttbasetype[mbase]==tsint)) {
                skipsymbol(semisym);
                goto L5;
            }
            else {
                serror_s("Decl error %s",typename(mbase));
            }
        }
        goto L4;
L5:;
L2:;
    }
}

int32 parsemodule	(int32 n) {
int32	size;
int32	t;
strec *	owner;
double	tsecs;
    startlex("PARSETEST",moduletable[n].fileno);
    owner = stmodule;
    currproc = 0;
    loopindex = 0;
    lex();
    readmodule();
    endlex();
    return 1;
}

static int32 readdeclspec	(strec * owner,int32 * linkage) {
declrec	d;
unitrec *	p;
int32	t;
int32	mod;
int32	m;
int32	fstruct;
paramrec *	pm;
strec *	e;
    memset((int32 *)&d,0,15);
    fstruct = mod = 0;
L15:;
    switch (lx.symbol) {
    case ktypespecsym:
        switch (lx.subcode) {
        case ts_int:
        case ts_char:
        case ts_float:
        case ts_double:
        case ts_bool:
        case ts_void:
            if (!!d.typeno) {
                if (fstruct) {
                    checksymbol(semisym);
                }
                else {
                    goto L17;
                }
            }
            d.typeno = typespectypes[lx.subcode-1];
            break;
        case ts_short:
            if (!!d.isshort || !!d.islong || !!d.isllong) {
                goto L17;
            }
            d.isshort = (mod = 1);
            break;
        case ts_long:
            if (!!d.isllong || !!d.isshort) {
                goto L17;
            }
            else if (!!d.islong) {
                d.islong = 0;
                d.isllong = 1;
            }
            else {
                d.islong = 1;
            }
            mod = 1;
            break;
        case ts_signed:
            if (!!d.issigned || !!d.isunsigned) {
                goto L17;
            }
            d.issigned = (mod = 1);
            break;
        case ts_unsigned:
            if (!!d.issigned || !!d.isunsigned) {
                goto L17;
            }
            d.isunsigned = (mod = 1);
            break;
        case ts_complex:
            if (!!d.typeno && d.typeno != tfloat && d.typeno != tdouble) {
                goto L17;
            }
            d.typeno = tcomplex;
            break;
        default:;
tserror:
L17:;
            serror_s("declspec/ts %s",typespecnames[lx.subcode-1]);
        }
        lex();
        break;
    case ktypequalsym:
        if ((lx.subcode==const_qual)) {
            d.isconst = 1;
        } else if ((lx.subcode==volatile_qual)) {
            d.isvolatile = 1;
        } else if ((lx.subcode==restrict_qual)) {
            d.isrestrict = 1;
        }
        lex();
        break;
    case klinkagesym:
        d.linkage = lx.subcode;
        lex();
        break;
    case kfnspecsym:
        if ((lx.subcode==inline_fnspec)) {
            d.isinline = 1;
        }
        lex();
        break;
    case kstructsym:
    case kunionsym:
        if (!!d.typeno) {
            serror("struct?");
        }
        d.typeno = readstructdecl(owner);
        d.isusertype = 1;
        fstruct = 1;
        break;
    case kenumsym:
        if (!!d.typeno) {
            serror("enum?");
        }
        readenumdecl(owner);
        d.typeno = tsint;
        d.isusertype = 1;
        break;
    case namesym:
        if (!d.typeno && !!(m = isusertype(owner))) {
            if (mod) {
                d.typeno = tsint;
                goto L16;
            }
            d.typeno = m;
            d.isusertype = 1;
            lex();
        }
        else {
            if (d.typeno == 0 && !mod) {
                serror_s("Implicit decls not allowed: %s",lx.symptr->name);
            }
            if (d.typeno == 0) {
                d.typeno = tsint;
            }
            goto L16;
        }
        break;
    case ktypeofsym:
        lex();
        skipsymbol(lbracksym);
        p = readexpression();
        skipsymbol(rbracksym);
        if (!!d.typeno || mod) {
            serror("typeof");
        }
        d.typeno = p->mode;
        break;
    case kmccassertsym:
        dostaticassert();
        break;
    default:;
        goto L16;
    }
    goto L15;
L16:;
    t = (!!d.typeno?(d).typeno:tsint);
    if (!d.isusertype) {
        if ((t==tsint)) {
            if (!!d.isshort) {
                t = (!!d.isunsigned?tushort:tsshort);
            }
            else if (!!d.islong) {
                if (wintarget) {
                    t = (!!d.isunsigned?tuint:tsint);
                }
                else {
                    t = (!!d.isunsigned?tullong:tsllong);
                }
            }
            else if (!!d.isllong) {
                t = (!!d.isunsigned?tullong:tsllong);
            }
            else if (!!d.isunsigned) {
                t = tuint;
            }
        } else if ((t==tuchar)) {
            if (!!d.isshort || !!d.islong || !!d.isllong) {
                serror("char decl?");
            }
            t = (!!d.issigned?tschar:tuchar);
        } else if ((t==tdouble)) {
            if (!!d.isshort || !!d.isllong || !!d.issigned || !!d.isunsigned) {
                serror("dbl decl?");
            }
        } else if ((t==tcomplex)) {
            if (!!d.isshort || !!d.isllong || !!d.issigned || !!d.isunsigned) {
                serror("Complex?");
            }
        }
        else {
            if (mod) {
                serror("declspec/float");
            }
        }
    }
    if (!!d.isconst) {
        t = createconstmode(t);
    }
    *linkage = d.linkage;
    return t;
}

static int32 istypestarter	(void) {
strec *	d;
    switch (lx.symbol) {
    case ktypespecsym:
        return 1;
        break;
    case ktypequalsym:
        return 1;
        break;
    case namesym:
        d = resolvename((currproc?currproc:stmodule),lx.symptr,ns_general,currblockno);
        if (d) {
            lx.symptr = d;
            return (int32)(d->nameid == typeid);
        }
        break;
    case kstructsym:
    case kunionsym:
        return 1;
        break;
    default:;
    }
    return 0;
}

static unitrec * readexpression	(void) {
unitrec *	p;
unitrec *	ulist;
unitrec *	ulistx;
int32	t;
    if ((nextlx.symbol==semisym) || (nextlx.symbol==rbracksym)) {
        return readterm();
    }
    p = readassignexpr();
    if (lx.symbol == commasym) {
        ulist = ulistx = 0;
        while (1) {
            addlistunit(&ulist,&ulistx,p);
            if (lx.symbol != commasym) {
                goto L37;
            }
            lex();
            p = readassignexpr();
        }
L37:;
        p = createunit1(j_exprlist,ulist);
        if (ulistx) {
            p->mode = ulistx->mode;
        }
        return p;
    }
    return p;
}

static unitrec * readassignexpr	(void) {
unitrec *	p;
unitrec *	q;
unitrec *	r;
int32	opc;
int32	oldpmode;
    if ((nextlx.symbol==commasym) || (nextlx.symbol==semisym) || (nextlx.symbol==rbracksym)) {
        return readterm();
    } else if ((nextlx.symbol==assignsym)) {
        p = readterm();
        opc = lx.symbol;
        goto L41;
    }
    p = readcondexpr();
    switch (opc = lx.symbol) {
    case assignsym:
    case multosym:
    case divtosym:
    case remtosym:
    case addtosym:
    case subtosym:
    case shltosym:
    case shrtosym:
    case iandtosym:
    case ixortosym:
    case iortosym:
gotp:
L41:;
        lex();
        oldpmode = p->mode;
        checklvalue(p);
        q = readassignexpr();
        if (!!ttisref[p->mode]) {
            return createassignopref(opc,p,q);
        }
        q = coercemode(q,oldpmode);
        if (q->tag == j_convert && opc == assignsym) {
            q->convtomem = 1;
        }
        if (p->tag == j_deref && p->a->tag == j_const) {
            terror("Modifying constant?");
        }
        r = createunit2(symboltojtag[opc-1],p,q);
        r->mode = oldpmode;
        return r;
        break;
    default:;
    }
    return p;
}

static unitrec * readcondexpr	(void) {
unitrec *	x;
unitrec *	y;
unitrec *	pcond;
int32	s;
int32	t;
int32	u;
    pcond = readorlexpr();
    if (lx.symbol == questionsym) {
        coercecond(pcond);
        lex();
        x = readexpression();
        skipsymbol(colonsym);
        y = readcondexpr();
        if (!!(u = dominantmode[s = ttbasetype[x->mode]][t = ttbasetype[y->mode]])) {
            x = coercemode(x,u);
            y = coercemode(y,u);
            if (pcond->tag == j_const && x->tag == j_const && y->tag == j_const) {
                return (!!pcond->value?x:y);
            }
        }
        else if (s == tref && t == tref) {
            u = x->mode;
        }
        else if (s == tref && t == tsint && y->tag == j_const && y->value == 0) {
            u = x->mode;
            coercemode(y,u);
        }
        else if (s == tsint && t == tref && x->tag == j_const && x->value == 0) {
            u = y->mode;
            coercemode(x,u);
        }
        else if (s == tstruct && t == tstruct) {
            u = x->mode;
        }
        else if (s == t && t == tvoid) {
            u = tvoid;
        }
        else {
            printf("%s %s\n",Strmode(x->mode,1),Strmode(y->mode,1));
            terror("?: incompatible types");
        }
        pcond = createunit3(j_ifx,pcond,x,y);
        pcond->mode = u;
    }
    return pcond;
}

static unitrec * readorlexpr	(void) {
unitrec *	x;
unitrec *	y;
    x = readandlexpr();
    while (lx.symbol == orlsym) {
        lex();
        y = readandlexpr();
        coercecond(x);
        coercecond(y);
        if (x->tag == j_const && y->tag == j_const) {
            x->value = ((!!x->value || !!y->value)?1:0);
            goto L50;
        }
        x = createunit2(j_orl,x,y);
        x->mode = tsint;
L50:;
    }
    return x;
}

static unitrec * readandlexpr	(void) {
unitrec *	x;
unitrec *	y;
    x = readiorexpr();
    while (lx.symbol == andlsym) {
        lex();
        y = readiorexpr();
        coercecond(x);
        coercecond(y);
        if (x->tag == j_const && y->tag == j_const) {
            x->value = ((!!x->value && !!y->value)?1:0);
            goto L53;
        }
        x = createunit2(j_andl,x,y);
        x->mode = tsint;
L53:;
    }
    return x;
}

static unitrec * readiorexpr	(void) {
unitrec *	x;
unitrec *	y;
int32	u;
    x = readixorexpr();
    while (lx.symbol == iorsym) {
        lex();
        y = readixorexpr();
        if (!!(u = dominantmode[ttbasetype[x->mode]][ttbasetype[y->mode]])) {
            if (u >= tfloat) {
                terror("float|float");
            }
            x = coercemode(x,u);
            y = coercemode(y,u);
        }
        else {
            terror("invalid | operands");
        }
        if (x->tag == j_const && y->tag == j_const) {
            if ((u==tsint) || (u==tsllong)) {
                x->value |= y->value;
                goto L56;
            }
        }
        x = createunit2(j_ior,x,y);
        x->mode = u;
L56:;
    }
    return x;
}

static unitrec * readixorexpr	(void) {
unitrec *	x;
unitrec *	y;
int32	u;
    x = readiandexpr();
    while (lx.symbol == ixorsym) {
        lex();
        y = readiandexpr();
        if (!!(u = dominantmode[ttbasetype[x->mode]][ttbasetype[y->mode]])) {
            if (u >= tfloat) {
                terror("float^float");
            }
            x = coercemode(x,u);
            y = coercemode(y,u);
        }
        else {
            terror("invalid ^ operands");
        }
        if (x->tag == j_const && y->tag == j_const) {
            if ((u==tsint) || (u==tsllong)) {
                x->value ^= y->value;
                goto L61;
            }
        }
        x = createunit2(j_ixor,x,y);
        x->mode = u;
L61:;
    }
    return x;
}

static unitrec * readiandexpr	(void) {
unitrec *	x;
unitrec *	y;
int32	u;
    x = readeqexpr();
    while (lx.symbol == iandsym) {
        lex();
        y = readeqexpr();
        if (!!(u = dominantmode[ttbasetype[x->mode]][ttbasetype[y->mode]])) {
            if (u >= tfloat) {
                terror("float&float");
            }
            x = coercemode(x,u);
            y = coercemode(y,u);
        }
        else {
            printf("%s\n",Strmode(x->mode,1));
            printf("%s\n",Strmode(y->mode,1));
            terror("invalid & operands");
        }
        if (x->tag == j_const && y->tag == j_const) {
            if ((u==tsint) || (u==tsllong)) {
                x->value &= y->value;
                goto L66;
            }
        }
        x = createunit2(j_iand,x,y);
        x->mode = u;
L66:;
    }
    return x;
}

static unitrec * readeqexpr	(void) {
unitrec *	x;
unitrec *	y;
int32	opc;
int32	s;
int32	t;
int32	u;
int32	ss;
int32	tt;
    x = readrelexpr();
    while ((opc = lx.symbol) == eqsym || opc == nesym) {
        lex();
        y = readrelexpr();
        if (!!(u = dominantmode[s = ttbasetype[x->mode]][t = ttbasetype[y->mode]])) {
            x = coercemode(x,u);
            y = coercemode(y,u);
        }
        else if (s == tref && t == tref) {
            if ((ss = tttarget[x->mode]) != (tt = tttarget[y->mode])) {
                if (ss != tvoid && tt != tvoid) {
                    if (!checkpointertypes(x->mode,y->mode,1)) {
                        terror("Comparing distinct pointers/eq");
                    }
                }
            }
        }
        else if (s == tref && t == tsint) {
            if (y->tag != j_const || y->value != 0) {
                terror("Can't compare pointer to int");
            }
        }
        else if (s == tsint && t == tref) {
            if (x->tag != j_const || x->value != 0) {
                terror("Can't compare pointer to int2");
            }
        }
        else {
            terror("invalid == operands");
        }
        if (x->tag == j_const && y->tag == j_const) {
            if ((u==tsint) || (u==tsllong) || (u==tuint) || (u==tullong) || (u==0)) {
                if (opc == eqsym) {
                    x->value = (int64)(x->value == y->value);
                }
                else {
                    x->value = (int64)(x->value != y->value);
                }
                goto L71;
            }
        }
        x = createunit2(symboltojtag[opc-1],x,y);
        x->mode = tsint;
L71:;
    }
    return x;
}

static unitrec * readrelexpr	(void) {
unitrec *	x;
unitrec *	y;
int32	opc;
int32	s;
int32	t;
int32	u;
int32	a;
int32	b;
int32	c;
    x = readshiftexpr();
    while ((opc = lx.symbol) == ltsym || opc == lesym || opc == gesym || opc == gtsym) {
        lex();
        y = readshiftexpr();
        if (!!(u = dominantmode[s = ttbasetype[x->mode]][t = ttbasetype[y->mode]])) {
            x = coercemode(x,u);
            y = coercemode(y,u);
        }
        else if (s == tref && t == tref) {
            if (!checkpointertypes(x->mode,y->mode,1)) {
                terror("Comparing distinct pointers/rel");
            }
        }
        else {
            terror("invalid rel operands");
        }
        if (x->tag == j_const && y->tag == j_const) {
            a = x->value;
            b = y->value;
            if ((u==tsint) || (u==tsllong)) {
                if ((opc==ltsym)) {
                    c = (int32)(a < b);
                } else if ((opc==lesym)) {
                    c = (int32)(a <= b);
                } else if ((opc==gesym)) {
                    c = (int32)(a >= b);
                }
                else {
                    c = (int32)(a > b);
                }
                x->value = c;
                goto L81;
            }
        }
        x = createunit2(symboltojtag[opc-1],x,y);
        x->mode = tsint;
L81:;
    }
    return x;
}

static unitrec * readshiftexpr	(void) {
unitrec *	x;
unitrec *	y;
int32	opc;
int32	u;
    x = readaddexpr();
    while ((opc = lx.symbol) == shlsym || opc == shrsym) {
        lex();
        y = readaddexpr();
        coercebasetype(x);
        if (!((u = ttbasetype[x->mode]) >= tfirstint && u <= tlastint)) {
            terror("shift:Not an int");
        }
        y = coercemode(y,tsint);
        if (x->tag == j_const && y->tag == j_const) {
            if ((u==tsint) || (u==tsllong)) {
                if (opc == shlsym) {
                    x->value = x->value<<y->value;
                }
                else {
                    x->value = x->value>>y->value;
                }
                goto L92;
            }
        }
        x = createunit2(((opc == shlsym)?j_shl:j_shr),x,y);
        x->mode = u;
L92:;
    }
    return x;
}

static unitrec * readaddexpr	(void) {
unitrec *	p;
unitrec *	q;
int32	opc;
    p = readmulexpr();
    while ((opc = lx.symbol) == addsym || opc == subsym) {
        lex();
        q = readmulexpr();
        if (opc == addsym) {
            p = createaddop(p,q);
        }
        else {
            p = createsubop(p,q);
        }
    }
    return p;
}

static unitrec * readmulexpr	(void) {
unitrec *	p;
unitrec *	q;
int32	opc;
    p = readterm();
    while ((opc = lx.symbol) == mulsym || opc == divsym || opc == remsym) {
        lex();
        q = readterm();
        if ((opc==mulsym)) {
            p = createmulop(p,q);
        } else if ((opc==divsym)) {
            p = createdivop(p,q);
        } else if ((opc==remsym)) {
            p = createremop(p,q);
        }
    }
    return p;
}

static unitrec * readterm	(void) {
unitrec *	p;
unitrec *	q;
int32	t;
int32	u;
int32	opc;
int32	shift;
int32	newlen;
int32	slength;
int32	tbase;
int32	fwide;
byte *	pbyte;
int64	a;
strec *	d;
char *	ss;
char *	s;
paramrec *	pm;
int32	av_1;
    switch (lx.symbol) {
    case intconstsym:
    case realconstsym:
        p = createconstunit(lx.value,lx.subcode);
        lex();
        break;
    case namesym:
        if (lx.symptr->nameid <= macroid) {
            d = resolvename((currproc?currproc:stmodule),lx.symptr,ns_general,currblockno);
            if (d == 0) {
                serror_s("Undefined name \"%s\"",getstname(lx.symptr));
            }
        }
        else {
            d = lx.symptr;
        }
        d->attribs.ax_used = 1;
        if ((d->nameid==enumid)) {
            p = createconstunit(d->index,tsint);
        } else if ((d->nameid==procid)) {
            if (nextlx.symbol != lbracksym) {
                p = createunit0(j_funcname);
                p->def = d;
                p->mode = createrefmode(createprocmode(d->mode,d->paramlist));
            }
            else {
                goto L107;
            }
        }
        else {
doname:
L107:;
            p = createname(d);
            p->mode = t = d->mode;
            if (ttbasetype[t] == tarray) {
                p->tag = j_nameaddr;
                p->mode = createrefmode(tttarget[t]);
                p->alength = ttlength[t];
            }
            else if (d->nameid != procid && ttsize[t] < 4) {
                fixmemopnd(p);
            }
        }
        p->lineno = lx.lineno;
        lex();
        break;
    case stringconstsym:
    case wstringconstsym:
        fwide = (int32)(lx.symbol == wstringconstsym);
        s = (char *)lx.svalue;
        slength = lx.length;
        while (nextlx.symbol == stringconstsym) {
            newlen = slength+nextlx.length;
            ss = (char *)pcm_alloc(newlen+1);
            memcpy((int32 *)ss,(int32 *)s,slength);
            memcpy((int32 *)(ss+slength),(int32 *)nextlx.svalue,nextlx.length);
            *(ss+newlen) = 0;
            s = ss;
            slength = newlen;
            lex();
        }
        p = createstringconstunit(s,slength);
        p->slength = slength;
        if (fwide) {
            p->mode = trefwchar;
        }
        lex();
        break;
    case charconstsym:
        a = 0;
        shift = 0;
        pbyte = lx.svalue;
        av_1 = lx.length;
        while (av_1--) {
            a = a|((uint64)*pbyte<<shift);
            shift += 8;
            ++pbyte;
        }
        p = createconstunit(a,tsint);
        lex();
        break;
    case addsym:
        lex();
        p = readterm();
        break;
    case subsym:
        lex();
        p = createnegop(readterm());
        break;
    case notlsym:
        lex();
        p = readterm();
        coercecond(p);
        p = createunit1(j_notl,p);
        p->mode = tsint;
        break;
    case inotsym:
        lex();
        p = createinotop(readterm());
        break;
    case iandsym:
        lex();
        if (lx.symbol == mulsym) {
            lex();
            p = readterm();
        }
        else {
            p = createaddrofop(readterm());
        }
        break;
    case andlsym:
        serror("rt/&&label");
        break;
    case mulsym:
        lex();
        p = createderefop(readterm());
        break;
    case incrsym:
    case decrsym:
        opc = symboltojtag[lx.symbol-1];
        lex();
        p = createincrop(opc,readterm());
        break;
    case abssym:
        lex();
        skipsymbol(lbracksym);
        p = createabsop(readexpression());
        skipsymbol(rbracksym);
        break;
    case lbracksym:
        lex();
        if (!!istypestarter()) {
            t = readcasttype(&d,0,&pm);
            skipsymbol(rbracksym);
            if (lx.symbol == lcurlysym) {
                serror("rt/compound lit");
            }
            else {
                p = docast(readterm(),t,1,0);
            }
        }
        else {
            p = readexpression();
            skipsymbol(rbracksym);
        }
        break;
    case ksizeofsym:
        lex();
        if (lx.symbol == lbracksym) {
            lex();
            if (!!istypestarter()) {
                t = readcasttype(&d,0,&pm);
                skipsymbol(rbracksym);
                p = createconstunit(ttsize[t],tsint);
            }
            else {
                p = readexpression();
                skipsymbol(rbracksym);
                p = createsizeofop(p);
            }
        }
        else {
            p = createsizeofop(readterm());
        }
        break;
    case kgenericsym:
        serror("rt/generic");
        break;
    case kalignofsym:
        serror("rt/alignof");
        break;
    case kstrtypesym:
        lex();
        skipsymbol(lbracksym);
        t = readcasttype(&d,0,&pm);
        skipsymbol(rbracksym);
        p = createstringconstunit(pcm_copyheapstring(Strmode(t,1)),-1);
        break;
    default:;
        serror("Readterm?");
    }
L117:;
    switch (lx.symbol) {
    case lsqsym:
        lex();
        q = readexpression();
        skipsymbol(rsqsym);
        p = createindexop(p,q);
        break;
    case dotsym:
    case idotsym:
        opc = symboltojtag[lx.symbol-1];
        lex();
        checksymbol(namesym);
        d = lx.symptr;
        lex();
        p = createdotop(opc,p,d);
        break;
    case lbracksym:
        lex();
        if (lx.symbol == rbracksym) {
            q = 0;
            lex();
        }
        else {
            q = readexprlist(0);
            skipsymbol(rbracksym);
        }
        p = createcall(p,q);
        break;
    case incrsym:
        lex();
        p = createincrop(j_postincr,p);
        break;
    case decrsym:
        lex();
        p = createincrop(j_postdecr,p);
        break;
    default:;
        goto L118;
    }
    goto L117;
L118:;
    return p;
}

static unitrec * readexprlist	(unitrec * p) {
unitrec *	ulist;
unitrec *	ulistx;
    ulist = ulistx = p;
    while (1) {
        p = readassignexpr();
        addlistunit(&ulist,&ulistx,p);
        if (lx.symbol != commasym) {
            goto L120;
        }
        lex();
    }
L120:;
    return ulist;
}

static strec * readmodulevar	(strec * d,int32 m,int32 linkage) {
strec *	e;
int32	scope;
int32	emode;
    e = checkdupl(stmodule,d,ns_general,0);
    if (e) {
        if (e->nameid != staticid) {
            serror_ss("var: name in use %s %s",e->name,namenames[e->nameid]);
        }
        emode = e->mode;
        if (emode != m) {
            if (!comparemode(emode,m)) {
redef:
L121:;
                serror_s("var: redefining %s",e->name);
            }
            if ((ttbasetype[emode]==tarray)) {
                if (ttlength[emode] == 0) {
                    e->mode = m;
                }
                else if (!!ttlength[m] && ttlength[emode] != ttlength[m]) {
                    goto L121;
                }
            }
        }
        d = e;
        scope = d->scope;
        if (scope == local_scope && linkage == none_ss || scope == exported_scope && linkage == static_ss || scope == imported_scope && linkage == static_ss) {
        }
        else if (scope == imported_scope && linkage == none_ss) {
            scope = exported_scope;
        }
    }
    else {
        d = createdupldef(stmodule,d,staticid);
        d->mode = m;
        if ((linkage==static_ss)) {
            scope = local_scope;
        } else if ((linkage==extern_ss)) {
            scope = imported_scope;
        }
        else {
            scope = exported_scope;
        }
    }
    if (lx.symbol == assignsym) {
        if (!!d->code) {
            serror_s("Can't init twice %s",d->name);
        }
        if (scope == imported_scope) {
            serror_s("Can't init extern %s",d->name);
        }
        lex();
        d->code = readinitexpr(stmodule,d->mode);
    }
    d->scope = scope;
    return d;
}

static strec * readframevar	(strec * d,int32 m,int32 linkage) {
paramrec *	pm;
strec *	e;
int32	scope;
int32	id;
    e = checkdupl_inproc(currproc,d,ns_general,currblockno);
    if (e) {
        serror_s("var: name in use %s",e->name);
        d = e;
        scope = d->scope;
        if (scope == local_scope && linkage == none_ss || scope == exported_scope && linkage == static_ss || scope == imported_scope && linkage == static_ss) {
        }
        else if (scope == imported_scope && linkage == none_ss) {
            scope = exported_scope;
        }
    }
    else {
        id = frameid;
        scope = function_scope;
        if ((linkage==static_ss)) {
            id = staticid;
        } else if ((linkage==extern_ss)) {
            scope = imported_scope;
            id = staticid;
        }
        d = createdupldef(currproc,d,id);
        d->mode = m;
        d->blockno = currblockno;
        blockcounts[currblockno] = 1;
    }
    if (lx.symbol == assignsym) {
        if (!!d->code) {
            serror_s("Can't init twice %s",d->name);
        }
        if (scope == imported_scope) {
            serror_s("Can't init extern %s",d->name);
        }
        lex();
        d->code = readinitexpr(currproc,d->mode);
    }
    d->scope = scope;
    return d;
}

static int32 readtype	(strec * owner,strec * * d,int32 m,paramrec * * pm) {
int32	modtype[20];
void *	modvalue[20];
paramrec *	pmx;
int32	nmodifiers;
int32	i;
    nmodifiers = 0;
    *pm = 0;
    readnamedtype(owner,d,(int32 (*)[])&modtype,(void * (*)[])&modvalue,&nmodifiers);
    for (i=nmodifiers; i>=1; --i) {
        if ((modtype[i-1]=='A')) {
            m = createarraymode(m,(int32)(int64)modvalue[i-1]);
        } else if ((modtype[i-1]=='R')) {
            m = createrefmode(m);
        } else if ((modtype[i-1]=='C')) {
            m = createconstmode(m);
        } else if ((modtype[i-1]=='F')) {
            if (i == 1) {
                *pm = (paramrec *)modvalue[1-1];
            }
            else {
                m = createprocmode(m,(paramrec *)modvalue[i-1]);
            }
        }
    }
    return m;
}

static void readnamedtype	(strec * owner,strec * * d,int32 (*modtype)[],void * (*modvalue)[],int32 * nmodifiers) {
int32	length;
int32	fconst[20];
int32	nrefs;
unitrec *	pdim;
    *d = 0;
    nrefs = 0;
    while (lx.symbol == mulsym) {
        ++nrefs;
        fconst[nrefs-1] = 0;
        lex();
        while (lx.symbol == ktypequalsym) {
            if ((lx.subcode==const_qual)) {
                fconst[nrefs-1] = 1;
            } else if ((lx.subcode==volatile_qual) || (lx.subcode==restrict_qual)) {
            }
            else {
                serror("rnt1");
            }
            lex();
        }
    }
    if ((lx.symbol==namesym)) {
        *d = lx.symptr;
        lex();
    } else if ((lx.symbol==lbracksym)) {
        lex();
        readnamedtype(owner,d,modtype,modvalue,nmodifiers);
        skipsymbol(rbracksym);
    }
L155:;
    if ((lx.symbol==lsqsym)) {
        lex();
        if (lx.symbol == rsqsym) {
            length = 0;
        }
        else {
            pdim = readassignexpr();
            if (pdim->tag == j_const) {
                length = pdim->value;
            }
            else {
                serror("Can't do VLAs");
            }
            checksymbol(rsqsym);
        }
        if (length < 0) {
            terror("Negative array dim");
        }
        lex();
        (*modtype)[++*nmodifiers-1] = 'A';
        (*modvalue)[*nmodifiers-1] = (void *)(int64)length;
    } else if ((lx.symbol==lbracksym)) {
        lex();
        (*modtype)[++*nmodifiers-1] = 'F';
        (*modvalue)[*nmodifiers-1] = readparams(owner);
    }
    else {
        goto L156;
    }
    goto L155;
L156:;
    while (nrefs) {
        if (!!fconst[nrefs-1]) {
            (*modtype)[++*nmodifiers-1] = 'C';
        }
        (*modtype)[++*nmodifiers-1] = 'R';
        --nrefs;
    }
}

static int32 readconstintexpr	(void) {
unitrec *	p;
    p = readassignexpr();
    if ((p->tag==j_const)) {
        return p->value;
    }
    else {
        serror_s("readconstint %s",jtagnames[p->tag]);
    }
    return 0;
}

static unitrec * readinitexpr	(strec * owner,int32 m) {
int32	count;
unitrec *	p;
    p = readinitexpr2(owner,m,1);
    return p;
}

static unitrec * readinitexpr2	(strec * owner,int32 m,int32 istop) {
unitrec *	ulist;
unitrec *	ulistx;
unitrec *	p;
int32	mbase;
int32	melem;
int32	mm;
int32	dim;
int32	count;
strec *	d;
strec *	e;
    mbase = ttbasetype[m];
    count = 0;
    if (lx.symbol == lcurlysym) {
        lex();
        count = 0;
        if ((mbase==tarray)) {
            dim = ttlength[m];
            if (!istop && dim == 0) {
                terror("init/0-size array");
            }
            melem = tttarget[m];
        } else if ((mbase==tstruct) || (mbase==tunion)) {
            d = ttnamedef[m];
            e = d->deflist;
            if (e == 0) {
                terror("init/Empty struct");
            }
            melem = e->mode;
        }
        else {
            p = readassignexpr();
            p = coercemode(p,m);
            skipsymbol(rcurlysym);
            return p;
        }
        ulist = ulistx = 0;
        while (1) {
            p = readinitexpr2(owner,melem,0);
            ++count;
            if ((mbase==tarray)) {
                if (dim && count > dim) {
                    terror("Too many array elems");
                }
                if (ttbasetype[melem] == tarray && ttbasetype[tttarget[melem]] == tuchar && p->mode == trefchar) {
                }
                else {
                    p = coercemode(p,melem);
                }
            } else if ((mbase==tstruct)) {
                mm = e->mode;
                if (ttbasetype[mm] == tarray && ttbasetype[tttarget[mm]] == tuchar && p->mode == trefchar) {
                }
                else {
                    p = coercemode(p,mm);
                }
                e = e->nextdef;
                if (e == 0) {
                    if (lx.symbol == commasym && nextlx.symbol != rcurlysym) {
                        terror("Too many struct elems");
                    }
                }
                else {
                    melem = e->mode;
                }
            } else if ((mbase==tunion)) {
                p = coercemode(p,melem);
                ulist = ulistx = p;
                goto L171;
            }
            addlistunit(&ulist,&ulistx,p);
            if (lx.symbol != commasym) {
                goto L167;
            }
            if (nextlx.symbol == rcurlysym) {
                lex();
                goto L167;
            }
            lex();
        }
L167:;
        if (mbase == tarray && dim == 0) {
            ttlength[m] = count;
            ttsize[m] = count*ttsize[melem];
        }
donestruct:
L171:;
        skipsymbol(rcurlysym);
        p = createunit1(j_makelist,ulist);
        p->count = count;
        p->mode = m;
    }
    else {
        if ((mbase==tarray)) {
            if (lx.symbol != stringconstsym && tttarget[m] != tuchar) {
                terror("{} initialiser expected");
            }
            p = readassignexpr();
            if (p->tag == j_const) {
                p->strarray = 1;
            }
            if (p->mode != trefchar) {
                terror("Array init");
            }
            if ((dim = ttlength[m]) == 0) {
                ttlength[m] = ttsize[m] = p->slength+1;
            }
            else {
                if (p->slength > dim) {
                    terror("Init str too long");
                }
            }
            return p;
        }
        p = readassignexpr();
        p = coercemode(p,m);
    }
    return p;
}

static void pushblock	(void) {
int32	n;
    if (blocklevel >= maxblockstack) {
        serror("Too many block levels");
    }
    if (nextblockno >= maxblock) {
        serror("Too many blocks");
    }
    ++blocklevel;
    ++nextblockno;
    n = currblockno;
    while (n && blockcounts[n] == 0) {
        --n;
    }
    blockowner[nextblockno] = n;
    currblockno = blockstack[blocklevel] = nextblockno;
    blockcounts[currblockno] = 0;
}

static void popblock	(void) {
    currblockno = blockstack[--blocklevel];
}

static unitrec * readcompoundstmt	(int32 params) {
unitrec *	ulist;
unitrec *	ulistx;
unitrec *	p;
unitrec *	q;
    ulist = ulistx = 0;
    lex();
    pushblock();
    if (params) {
        blockcounts[1] = 1;
    }
    while (lx.symbol != rcurlysym) {
        p = readstatement();
        if (p == 0) {
            goto L177;
        }
        if (p->tag == j_tempdecl) {
            do {
                q = p->nextunit;
                if (!!p->def->code && p->def->nameid != staticid) {
                    p->tag = j_decl;
                    p->nextunit = 0;
                    addlistunit(&ulist,&ulistx,p);
                }
                p = q;
            } while (!(p == 0));
        }
        else {
            addlistunit(&ulist,&ulistx,p);
        }
L177:;
    }
    lex();
    popblock();
    return createunit3(j_block,ulist,0,ulistx);
}

static unitrec * readstatement	(void) {
unitrec *	p;
unitrec *	q;
strbuffer *	ss;
strec *	d;
int32	index;
    switch (lx.symbol) {
    case kifsym:
        return readifstmt();
        break;
    case kforsym:
        return readforstmt();
        break;
    case kwhilesym:
        return readwhilestmt();
        break;
    case kdosym:
        return readdostmt();
        break;
    case kreturnsym:
        return readreturnstmt();
        break;
    case kswitchsym:
        return readswitchstmt();
        break;
    case lcurlysym:
        return readcompoundstmt(0);
        break;
    case kgotosym:
        return readgotostmt();
        break;
    case kbreaksym:
        if (loopindex) {
            p = createunit0(((looptypestack[loopindex-1] == 'L')?j_break:j_breaksw));
            lex();
        }
        else {
            serror("break outside loop/sw");
        }
        break;
    case kcontinuesym:
        index = loopindex;
        while (index && looptypestack[index-1] != 'L') {
            --index;
        }
        if (index == 0) {
            serror("continue outside loop");
        }
        p = createunit0(j_continue);
        lex();
        break;
    case kcasesym:
        return readcaselabel();
        break;
    case kdefaultsym:
        lex();
        skipsymbol(colonsym);
        return createunit1(j_defaultstmt,readstatement());
        break;
    case kshowmodesym:
        lex();
        p = readexpression();
        ss = strexpr(p);
        printf("%s %s %s %s %s %d %s %d","Mode is:",ss->strptr,":",Strmode(p->mode,1),"\ton line",lx.lineno,"Size is",ttsize[p->mode]);
        if (!!ttisref[p->mode]) {
            printf("%s %d"," target size",ttsize[tttarget[p->mode]]);
        }
        printf("\n");
        break;
    case kmccassertsym:
        dostaticassert();
        break;
    case semisym:
        lex();
        return 0;
        break;
    case namesym:
        if (nextlx.symbol == colonsym) {
            p = createunit1(j_labelstmt,0);
            d = resolvename(currproc,lx.symptr,ns_labels,0);
            if (d) {
                if (!!d->index) {
                    printf("%s\n",lx.symptr->name);
                    terror("Duplicate label");
                }
                else {
                    d->index = ++labelno;
                }
            }
            else {
                d = createdupldef(currproc,lx.symptr,labelid);
                d->mode = tvoid;
                d->index = ++labelno;
            }
            p->def = d;
            lex();
            lex();
            if (lx.symbol == rcurlysym) {
                serror("label before }");
            }
            p->a = readstatement();
            return p;
        }
        else {
            ist_symptr = 0;
            if (!!isusertype(currproc)) {
                goto L185;
            }
            if (ist_symptr) {
                lx.symptr = ist_symptr;
            }
            p = readexpression();
        }
        break;
    case ktypespecsym:
    case ktypequalsym:
    case klinkagesym:
    case kfnspecsym:
    case kstructsym:
    case kunionsym:
    case kenumsym:
    case ktypeofsym:
doreaddecl:
L185:;
        return readlocaldecl();
        break;
    default:;
        p = readexpression();
    }
    skipsymbol(semisym);
    return p;
}

static unitrec * readifstmt	(void) {
unitrec *	pcond;
unitrec *	pbody;
unitrec *	pelse;
    lex();
    pcond = readcond();
    coercecond(pcond);
    pbody = readstatement();
    pelse = 0;
    if (lx.symbol == kelsesym) {
        lex();
        pelse = readstatement();
    }
    return createunit3(j_if,pcond,pbody,pelse);
}

static unitrec * readforstmt	(void) {
unitrec *	pinit;
unitrec *	pcond;
unitrec *	pincr;
unitrec *	pbody;
unitrec *	ulist;
unitrec *	ulistx;
unitrec *	p;
int32	linkage;
int32	hasblock;
int32	m;
int32	mbase;
paramrec *	pm;
strec *	d;
    lex();
    skipsymbol(lbracksym);
    hasblock = 0;
    if (lx.symbol != semisym) {
        if (!!istypestarter()) {
            hasblock = 1;
            pushblock();
            mbase = readdeclspec(currproc,&linkage);
            ulist = ulistx = 0;
L186:;
            if ((lx.symbol==namesym) || (lx.symbol==mulsym) || (lx.symbol==lbracksym)) {
                m = readtype(currproc,&d,mbase,&pm);
                if (d == 0) {
                    serror("Var name expected");
                }
                if (linkage == typedef_ss || pm) {
                    serror("Not allowed in for stmt");
                }
                d = readframevar(d,m,linkage);
                if (!!d->code) {
                    p = createunit0(j_decl);
                    p->def = d;
                    addlistunit(&ulist,&ulistx,p);
                }
                if ((lx.symbol==commasym)) {
                    lex();
                }
                else {
                    goto L187;
                }
            }
            else {
                serror("For decl error");
            }
            goto L186;
L187:;
            pinit = createunit3(j_block,ulist,0,ulistx);
        }
        else {
            pinit = readexpression();
        }
    }
    else {
        pinit = createunit0(j_null);
    }
    skipsymbol(semisym);
    if (lx.symbol != semisym) {
        pcond = readexpression();
        coercecond(pcond);
    }
    else {
        pcond = createunit0(j_null);
    }
    skipsymbol(semisym);
    if (lx.symbol != rbracksym) {
        pincr = readexprstmt();
    }
    else {
        pincr = 0;
    }
    skipsymbol(rbracksym);
    pushloop('L');
    pbody = readstatement();
    poploop();
    if (hasblock) {
        popblock();
    }
    pinit->nextunit = pcond;
    pcond->nextunit = pincr;
    return createunit2(j_for,pinit,pbody);
}

static unitrec * readwhilestmt	(void) {
unitrec *	pcond;
unitrec *	pbody;
    lex();
    pcond = readcond();
    coercecond(pcond);
    pushloop('L');
    pbody = readstatement();
    poploop();
    return createunit2(j_while,pcond,pbody);
}

static unitrec * readdostmt	(void) {
unitrec *	pbody;
unitrec *	pcond;
    lex();
    pushloop('L');
    pbody = readstatement();
    poploop();
    skipsymbol(kwhilesym);
    pcond = readcond();
    coercecond(pcond);
    skipsymbol(semisym);
    return createunit2(j_dowhile,pbody,pcond);
}

static unitrec * readreturnstmt	(void) {
unitrec *	p;
    lex();
    p = 0;
    if (lx.symbol != semisym) {
        if (currproc->mode == tvoid) {
            terror("Can't return value in void function");
        }
        p = readexpression();
        p = coercemode(p,currproc->mode);
        checksymbol(semisym);
    }
    else if (currproc->mode != tvoid) {
        terror("Return value needed");
    }
    lex();
    return createunit1(j_return,p);
}

static unitrec * readgotostmt	(void) {
strec *	d;
unitrec *	p;
    lex();
    checksymbol(namesym);
    d = resolvename(currproc,lx.symptr,ns_labels,0);
    if (d == 0) {
        d = createdupldef(currproc,lx.symptr,labelid);
        d->mode = tvoid;
    }
    p = createunit1(j_goto,0);
    p->def = d;
    lex();
    skipsymbol(semisym);
    return p;
}

static unitrec * readswitchstmt	(void) {
unitrec *	pindex;
unitrec *	pstmt;
unitrec *	p;
    lex();
    pindex = readcond();
    pushloop('S');
    pstmt = readstatement();
    p = createunit2(j_switch,pindex,pstmt);
    p->nextcase = casevaluestack[loopindex-1];
    poploop();
    return p;
}

static unitrec * readcaselabel	(void) {
unitrec *	p;
unitrec *	q;
int32	value;
    lex();
    value = readconstintexpr();
    skipsymbol(colonsym);
    p = createunit1(j_casestmt,readstatement());
    p->index = value;
    addcasevalue(value);
    return p;
}

static unitrec * readexprstmt	(void) {
    return readexpression();
}

static unitrec * readcond	(void) {
unitrec *	pcond;
    skipsymbol(lbracksym);
    pcond = readexpression();
    skipsymbol(rbracksym);
    return pcond;
}

static int32 isusertype	(strec * owner) {
strec *	d;
    d = resolvename(owner,lx.symptr,ns_general,currblockno);
    if (d) {
        if (d->nameid == typeid) {
            return d->mode;
        }
        ist_symptr = d;
    }
    return 0;
}

static unitrec * readlocaldecl	(void) {
int32	m;
int32	mbase;
int32	linkage;
strec *	d;
unitrec *	ulist;
unitrec *	ulistx;
unitrec *	p;
paramrec *	pm;
    ulist = ulistx = 0;
    mbase = readdeclspec(currproc,&linkage);
L194:;
    if ((lx.symbol==namesym) || (lx.symbol==mulsym) || (lx.symbol==lbracksym)) {
        m = readtype(currproc,&d,mbase,&pm);
        if (d == 0) {
            serror("Var name expected");
        }
        if (linkage == typedef_ss) {
            d = createtypedef(currproc,d,m);
        }
        else if (pm) {
            serror("Nested function");
        }
        else {
            d = readframevar(d,m,linkage);
            p = createunit0(j_tempdecl);
            p->def = d;
            addlistunit(&ulist,&ulistx,p);
        }
        if ((lx.symbol==commasym)) {
            lex();
        }
        else {
            skipsymbol(semisym);
            goto L195;
        }
    }
    else {
        if ((ttbasetype[mbase]==tenum) || (ttbasetype[mbase]==tstruct) || (ttbasetype[mbase]==tunion)) {
            skipsymbol(semisym);
            goto L195;
        } else if ((ttbasetype[mbase]==tsint)) {
            skipsymbol(semisym);
            goto L195;
        }
        else {
            serror_s("Local decl error %s",typename(m));
        }
    }
    goto L194;
L195:;
    return ulist;
}

static strec * createtypedef	(strec * owner,strec * symptr,int32 mode) {
strec *	d;
    d = checkdupl(owner,symptr,ns_general,currblockno);
    if (d) {
        if (d->nameid != typeid) {
            serror_s("Typedef name in use %s",d->name);
        }
        if (d->mode != mode) {
            if (!comparemode(d->mode,mode)) {
                serror_s("Typedef redefined or can't match types %s",d->name);
            }
        }
        return d;
    }
    d = createdupldef(owner,symptr,typeid);
    d->mode = mode;
    d->blockno = currblockno;
    blockcounts[currblockno] = 1;
    return d;
}

static paramrec * readparams	(strec * owner) {
paramrec *	ulist;
paramrec *	ulistx;
paramrec *	pm;
paramrec *	q;
int32	m;
int32	nparams;
int32	variadic;
int32	flags;
int32	nnames;
strec *	d;
    ulist = ulistx = 0;
    variadic = nparams = nnames = 0;
    if (callbackflag) {
        iscallbackfn = 1;
        callbackflag = 0;
    }
    while (lx.symbol != rbracksym) {
        if (lx.symbol == ellipsissym) {
            variadic = 1;
            lex();
            goto L207;
        }
        m = readcasttype(&d,1,&pm);
        if (pm) {
            m = createrefmode(createprocmode(m,pm));
        }
        if (ttbasetype[m] == tarray) {
            m = createrefmode(tttarget[m]);
        }
        pm = (paramrec *)pcm_allocz(24);
        pm->def = d;
        pm->mode = m;
        ++nparams;
        if (d) {
            ++nnames;
            q = ulist;
            while (q) {
                if (q->def == d) {
                    serror_ss("Param name reused %s %s",d->name,namenames[d->nameid]);
                }
                q = q->nextparam;
            }
        }
        addlistparam(&ulist,&ulistx,pm);
        if ((lx.symbol==commasym)) {
            lex();
        } else if ((lx.symbol==ellipsissym) || (lx.symbol==rbracksym)) {
        }
        else {
            serror("bad symbol in paramlist");
        }
    }
L207:;
    flags = 0;
    skipsymbol(rbracksym);
    if (variadic) {
        flags = pm_variadic;
    }
    else if (nparams == 0) {
        flags = pm_notset;
    }
    else if (nparams == 1 && m == tvoid) {
        flags = pm_empty;
        nparams = 0;
        ulist->mode = tnone;
    }
    if (ulist == 0) {
        ulist = (paramrec *)pcm_allocz(24);
    }
    ulist->nparams = nparams;
    ulist->flags = flags;
    return ulist;
}

static int32 readcasttype	(strec * * d,int32 allowname,paramrec * * pm) {
strec *	owner;
int32	m;
int32	linkage;
    owner = (currproc?currproc:stmodule);
    linkage = 0;
    *d = 0;
    m = readdeclspec(owner,&linkage);
    *pm = 0;
    if ((lx.symbol==namesym) || (lx.symbol==mulsym) || (lx.symbol==lbracksym) || (lx.symbol==lsqsym)) {
        m = readtype(owner,d,m,pm);
        if (!!*d && !allowname) {
            serror_s("NAME not allowed in cast type %s",(*d)->name);
        }
    }
    return m;
}

static strec * readfunction	(strec * d,int32 m,int32 linkage,paramrec * pm,int32 * wasdef) {
strec *	f;
strec *	owner;
int32	scope;
    owner = stmodule;
    *wasdef = 0;
    f = checkdupl(owner,d,ns_general,0);
    if (f) {
        if (f->nameid != procid) {
            serror_s("fn: name in use %s",d->name);
        }
        d = f;
        scope = d->scope;
        if (scope == local_scope && linkage == none_ss || scope == exported_scope && linkage == static_ss || scope == imported_scope && linkage == static_ss) {
        }
        else if (scope == imported_scope && linkage == none_ss) {
            scope = exported_scope;
        }
    }
    else {
        d = createdupldef(owner,d,procid);
        d->mode = m;
        if ((linkage==static_ss)) {
            scope = local_scope;
        } else if ((linkage==extern_ss)) {
            scope = imported_scope;
        }
        else {
            scope = exported_scope;
        }
        if (!!iscallbackfn) {
            d->attribs.ax_callback = 1;
            iscallbackfn = 0;
        }
    }
    d->paramlist = pm;
    d->scope = scope;
    if (lx.symbol == lcurlysym) {
        *wasdef = 1;
        if (!!d->code) {
            serror_s("Can't define function twice %s",d->name);
        }
        if (scope == imported_scope) {
        }
        readfunctionbody(d);
    }
    return d;
}

static void readfunctionbody	(strec * f) {
strec *	e;
unitrec *	p;
paramrec *	pm;
int32	pmcount;
int32	av_2;
    currproc = f;
    nextblockno = currblockno = 0;
    pmcount = 0;
    pm = f->paramlist;
    if (!!pm->def) {
        av_2 = pm->nparams;
        while (av_2--) {
            e = createdupldef(f,pm->def,paramid);
            e->blockno = 1;
            e->mode = pm->mode;
            pm = pm->nextparam;
            pmcount = 1;
        }
    }
    else if (!!pm->nparams) {
        serror("Param names missing");
    }
    p = readcompoundstmt(pmcount);
    currproc->code = p;
    currproc = 0;
}

static unitrec * createnegop	(unitrec * p) {
unitrec *	q;
int32	t;
    t = p->mode;
    if (p->tag == j_const) {
        if ((t==tsint) || (t==tsllong) || (t==tullong)) {
            p->value = -p->value;
            return p;
        } else if ((t==tuint)) {
            p->value = -p->value&4294967295ll;
            return p;
        } else if ((t==tdouble)) {
            p->xvalue = -p->xvalue;
        }
    }
retry:
L235:;
    if (t >= tfirstnum && t <= tlastnum) {
        coercebasetype(p);
        q = createunit1(j_neg,p);
    }
    else if (!!ttconst[t]) {
        t = ttconsttype[t];
        goto L235;
    }
    else {
        printf("%s\n",Strmode(t,1));
        terror("neg bad type");
    }
    q->mode = p->mode;
    return q;
}

static unitrec * createabsop	(unitrec * p) {
unitrec *	q;
int32	t;
    t = p->mode;
    if (p->tag == j_const) {
        if ((t==tsint) || (t==tsllong)) {
            p->value = abs(p->value);
            return p;
        }
    }
    if (t >= tfirstint && t <= tlastint) {
        coercebasetype(p);
        q = createunit1(j_abs,p);
    }
    else {
        terror("abs bad type");
    }
    q->mode = p->mode;
    return q;
}

static unitrec * createinotop	(unitrec * p) {
unitrec *	q;
int32	t;
    t = ttbasetype[p->mode];
    if (p->tag == j_const) {
        if ((t==tsint) || (t==tsllong) || (t==tuint) || (t==tullong)) {
            p->value = ~p->value;
            return p;
        }
    }
    if (t > tfirstint && t <= tlastint) {
        coercebasetype(p);
        q = createunit1(j_inot,p);
    }
    else {
        printf("%s\n",Strmode(t,1));
        terror("! bad type");
    }
    q->mode = p->mode;
    return q;
}

static unitrec * createderefop	(unitrec * p) {
unitrec *	q;
int32	t;
int32	m;
    if (!ttisref[t = p->mode]) {
        terror("* not pointer");
    }
    m = tttarget[t];
    if (ttbasetype[m] == tproc) {
        return p;
    }
    if ((p->tag==j_nameaddr)) {
        p->tag = j_name;
        p->mode = tttarget[t];
        fixmemopnd(p);
        return p;
    } else if ((p->tag==j_addoffset)) {
        p->tag = j_derefoffset;
        p->mode = tttarget[t];
        fixmemopnd(p);
        return p;
    }
    q = createunit1(j_deref,p);
    q->mode = m;
    q = arraytopointer(q);
    fixmemopnd(q);
    return q;
}

static unitrec * createincrop	(int32 opc,unitrec * p) {
unitrec *	q;
int32	t;
    t = p->mode;
    checklvalue(p);
    if (!(t >= tfirstint && t <= tlastint && t != tbool || !!ttisref[t])) {
        terror("++ bad type");
    }
    q = createunit1(opc,p);
    q->mode = p->mode;
    return q;
}

static unitrec * createsizeofop	(unitrec * p) {
unitrec *	q;
int32	t;
int32	size;
    t = p->mode;
    switch (p->tag) {
    case j_name:
    case j_nameaddr:
        size = ttsize[p->def->mode];
        break;
    case j_const:
        if (t == trefchar) {
            size = p->slength+1;
        }
        else {
            size = ttsize[t];
        }
        break;
    case j_deref:
        if (!!ttisref[t] && !!p->alength) {
            size = ttsize[tttarget[t]]*p->alength;
        }
        else {
            size = ttsize[t];
        }
        break;
    default:;
        size = ttsize[t];
    }
    q = createconstunit(size,tsint);
    return q;
}

static unitrec * createaddrofop	(unitrec * p) {
strec *	d;
unitrec *	q;
int32	t;
int32	u;
restartx:
L245:;
    t = p->mode;
    switch (p->tag) {
    case j_name:
doname:
L246:;
        d = p->def;
        p->mode = createrefmode(d->mode);
        p->tag = j_nameaddr;
        return p;
        break;
    case j_nameaddr:
        d = p->def;
        u = d->mode;
        if (!!ttisref[t] && ttbasetype[u] == tarray) {
            p->mode = createrefmode(u);
            return p;
        }
        serror_s("& on nameaddr &%s",d->name);
        break;
    case j_funcname:
        t = createprocmode(p->def->mode,p->def->paramlist);
        break;
    case j_deref:
        return p->a;
        break;
    case j_derefoffset:
        p->tag = j_addoffset;
        p->mode = createrefmode(p->mode);
        break;
    case j_addoffset:
        if (!!p->alength) {
            p->mode = createrefmode(createarraymode(tttarget[t],p->alength));
            return p;
        }
        else {
            goto L247;
        }
        break;
    case j_convert:
        if (p->a->tag == j_name) {
            p = p->a;
            goto L246;
        }
        goto L247;
        break;
    case j_widenmem:
        p = p->a;
        goto L245;
        break;
    default:;
cad1:
L247:;
        checklvalue(p);
        t = p->mode;
    }
    p->mode = createrefmode(t);
    return p;
}

static unitrec * createaddop	(unitrec * x,unitrec * y) {
unitrec *	z;
int32	s;
int32	t;
int32	u;
int32	opc;
int32	elemsize;
    s = ttbasetype[x->mode];
    t = ttbasetype[y->mode];
    opc = j_add;
    if (!!(u = dominantmode[s][t])) {
        x = coercemode(x,u);
        y = coercemode(y,u);
    }
    else if (s == tref) {
doaddref:
L251:;
        u = x->mode;
        elemsize = ttsize[tttarget[u]];
        if (x->tag == j_const && y->tag == j_const) {
            x->value += y->value*elemsize;
            return x;
        }
        y = coercemode(y,tptroffset);
        z = createunit2(j_addoffset,x,y);
        z->mode = u;
        z->ptrscale = elemsize;
        return z;
    }
    else if (t == tref) {
        {unitrec *	temp;
            temp = x;
            x = y;
            y = temp;
        }
        goto L251;
    }
    else {
        terror("Sub bad types");
    }
    if (x->tag == j_const && y->tag == j_const) {
        return eval_add(opc,x,y,u);
    }
    z = createunit2(opc,x,y);
    z->mode = u;
    return z;
}

static unitrec * createsubop	(unitrec * x,unitrec * y) {
unitrec *	z;
int32	s;
int32	t;
int32	u;
int32	opc;
    s = ttbasetype[x->mode];
    t = ttbasetype[y->mode];
    opc = j_sub;
    if (!!(u = dominantmode[s][t])) {
        x = coercemode(x,u);
        y = coercemode(y,u);
    }
    else if (s == tref) {
        if (t != tref) {
            y = coercemode(y,tptroffset);
            u = x->mode;
        }
        else {
            z = createunit2(opc,x,y);
            z->mode = tptroffset;
            z = divunit(z,tttarget[x->mode]);
            z->mode = tptroffset;
            return z;
        }
        y = mulunit(y,tttarget[x->mode]);
    }
    else {
        terror("Sub bad types");
    }
    if (x->tag == j_const && y->tag == j_const) {
        return eval_sub(opc,x,y,u);
    }
    z = createunit2(opc,x,y);
    z->mode = u;
    return z;
}

static unitrec * createmulop	(unitrec * x,unitrec * y) {
unitrec *	z;
int32	s;
int32	t;
int32	u;
int32	opc;
    s = ttbasetype[x->mode];
    t = ttbasetype[y->mode];
    opc = j_mul;
    if (!!(u = dominantmode[s][t])) {
        x = coercemode(x,u);
        y = coercemode(y,u);
    }
    else {
        terror("Mul bad types");
    }
    if (x->tag == j_const && y->tag == j_const) {
        return eval_mul(opc,x,y,u);
    }
    z = createunit2(opc,x,y);
    z->mode = u;
    return z;
}

static unitrec * createdivop	(unitrec * x,unitrec * y) {
unitrec *	z;
int32	s;
int32	t;
int32	u;
int32	opc;
    s = ttbasetype[x->mode];
    t = ttbasetype[y->mode];
    opc = j_div;
    if (!!(u = dominantmode[s][t])) {
        x = coercemode(x,u);
        y = coercemode(y,u);
    }
    else {
        terror("Div bad types");
    }
    if (x->tag == j_const && y->tag == j_const) {
        return eval_div(opc,x,y,u);
    }
    z = createunit2(opc,x,y);
    z->mode = u;
    return z;
}

static unitrec * createremop	(unitrec * x,unitrec * y) {
unitrec *	z;
int32	s;
int32	t;
int32	u;
int32	opc;
    s = ttbasetype[x->mode];
    t = ttbasetype[y->mode];
    opc = j_rem;
    if (!!(u = dominantmode[s][t])) {
        if (u == tdouble || u == tfloat) {
            u = tsint;
        }
        x = coercemode(x,u);
        y = coercemode(y,u);
    }
    else {
        terror("Rem bad types");
    }
    if (x->tag == j_const && y->tag == j_const) {
        return eval_rem(opc,x,y,u);
    }
    z = createunit2(opc,x,y);
    z->mode = u;
    return z;
}

static void insertunit	(unitrec * p,int32 tag) {
unitrec *	q;
    q = createunit0(0);
    *q = *p;
    p->tag = tag;
    p->a = q;
    p->b = p->c = 0;
    p->lineno = q->lineno;
    p->simple = 0;
    p->nextunit = q->nextunit;
    q->nextunit = 0;
}

static unitrec * eval_add	(int32 opc,unitrec * x,unitrec * y,int32 t) {
unitrec *	z;
    if ((t==tsint) || (t==tsllong) || (t==tuint) || (t==tullong)) {
        x->value += y->value;
        return x;
    } else if ((t==tdouble)) {
        x->xvalue += y->xvalue;
        return x;
    }
    else {
        if (ttbasetype[t] == tref) {
            x->value += y->value*ttsize[tttarget[t]];
            return x;
        }
    }
    z = createunit2(opc,x,y);
    z->mode = t;
    return z;
}

static unitrec * eval_sub	(int32 opc,unitrec * x,unitrec * y,int32 t) {
unitrec *	z;
    if ((t==tsint) || (t==tsllong)) {
        x->value -= y->value;
        return x;
    } else if ((t==tdouble)) {
        x->xvalue -= y->xvalue;
        return x;
    }
    else {
        if (ttbasetype[t] == tref) {
            if (ttbasetype[y->mode] == tref) {
                terror("EVALSUB/REF");
            }
            return x;
        }
    }
    z = createunit2(opc,x,y);
    z->mode = t;
    return z;
}

static unitrec * eval_mul	(int32 opc,unitrec * x,unitrec * y,int32 t) {
unitrec *	z;
    if ((t==tsint) || (t==tsllong) || (t==tsshort) || (t==tschar)) {
        x->value *= y->value;
        return x;
    } else if ((t==tuint) || (t==tullong) || (t==tushort) || (t==tuchar)) {
        x->uvalue = x->uvalue*y->uvalue;
        return x;
    } else if ((t==tdouble)) {
        x->xvalue *= y->xvalue;
        return x;
    }
    z = createunit2(opc,x,y);
    z->mode = t;
    return z;
}

static unitrec * eval_div	(int32 opc,unitrec * x,unitrec * y,int32 t) {
unitrec *	z;
    if ((t==tsint) || (t==tsllong)) {
        if (y->value == 0) {
            serror("div 0");
        }
        x->value = x->value/ y->value;
        return x;
    } else if ((t==tdouble)) {
        x->xvalue /= y->xvalue;
        return x;
    }
    z = createunit2(opc,x,y);
    z->mode = t;
    return z;
}

static unitrec * eval_rem	(int32 opc,unitrec * x,unitrec * y,int32 t) {
unitrec *	z;
    if ((t==tsint) || (t==tsllong)) {
        if (y->value == 0) {
            serror("rem 0");
        }
        x->value = x->value% y->value;
        return x;
    }
    z = createunit2(opc,x,y);
    z->mode = t;
    return z;
}

static int32 eval_convert	(unitrec * p,int32 t,int32 opc) {
int32	s;
    if (opc == soft_c) {
dosoft:
L272:;
        p->mode = t;
        return 1;
    }
    s = p->mode;
    if (s == t) {
        return 1;
    }
    if ((s==tsint) || (s==tsshort) || (s==tschar) || (s==tsllong)) {
        if ((t==tdouble) || (t==tfloat)) {
            p->xvalue = p->value;
            p->mode = t;
            return 1;
        } else if ((t==tullong) || (t==tsllong) || (t==tuint) || (t==tsint) || (t==tsshort) || (t==tschar) || (t==tuchar) || (t==tushort)) {
dotrunc:
L279:;
            if ((ttsize[t]==1)) {
                p->value &= 255;
            } else if ((ttsize[t]==2)) {
                p->value &= 65535;
            } else if ((ttsize[t]==4)) {
                p->value &= 4294967295ll;
            }
            goto L272;
        }
        if (!!ttisref[t]) {
            p->mode = t;
            return 1;
        }
    } else if ((s==tuint) || (s==tuchar) || (s==tushort) || (s==tullong)) {
        if ((t==tdouble) || (t==tfloat)) {
            if (p->value >= 0) {
                p->xvalue = p->value;
            }
            else {
                p->xvalue = -p->value;
            }
            p->mode = t;
            return 1;
        } else if ((t==tullong) || (t==tsllong) || (t==tsint) || (t==tuint) || (t==tullong) || (t==tushort) || (t==tschar) || (t==tuchar) || (t==tsshort)) {
            goto L279;
        }
        if (!!ttisref[t]) {
            p->mode = t;
            return 1;
        }
    } else if ((s==tdouble)) {
        if ((t==tsint)) {
            p->value = p->xvalue;
            p->mode = tsint;
            return 1;
        } else if ((t==tfloat)) {
            p->mode = tfloat;
            return 1;
        }
    }
    else {
        if (!!ttisref[p->mode]) {
            if ((t==tsint) || (t==tsllong) || (t==tuint) || (t==tullong)) {
                p->mode = t;
                return 1;
            }
        }
    }
    return 0;
}

static void coercecond	(unitrec * p) {
int32	t;
    if ((t = p->mode) == tsint) {
        return;
    }
retry:
L294:;
    if ((ttbasetype[t]==tfloat) || (ttbasetype[t]==tdouble) || (ttbasetype[t]==tref)) {
        goto L297;
    }
    else {
        if (t >= tfirstint && t <= tlastint) {
doint:
L297:;
            if (p->tag == j_const && !!p->value) {
                p->value = 1;
            }
            else {
                insertunit(p,j_istruel);
            }
        }
        else if (!!ttconst[t]) {
            t = ttconsttype[t];
            goto L294;
        }
        else {
            serror_s("Invalid condition %s",Strmode(t,1));
        }
    }
    p->mode = tsint;
}

static void coercebasetype	(unitrec * p) {
int32	t;
    if ((t = p->mode) >= tschar && t <= tsshort) {
        p = coercemode(p,tsint);
    }
    else if (t >= tbool && t <= tushort) {
        p = coercemode(p,tuint);
    }
}

static void checklvalue	(unitrec * p) {
    if ((p->tag==j_name) || (p->tag==j_deref)) {
    } else if ((p->tag==j_widenmem)) {
        if ((p->a->tag==j_name) || (p->a->tag==j_deref) || (p->a->tag==j_derefoffset)) {
            *p = *p->a;
        }
        else {
            printf("%s\n","WM");
            printunit(0,p->a,0,"*");
            terror("CHECKLV/WIDEN");
        }
    } else if ((p->tag==j_derefoffset)) {
    } else if ((p->tag==j_const)) {
        if (!ttisref[p->mode]) {
            goto L311;
        }
    } else if ((p->tag==j_convert)) {
        if (p->a->tag == j_name) {
            *p = *p->a;
            return;
        }
    }
    else {
notlv:
L311:;
        printunit(0,p,0,"*");
        terror_s("Not lvalue: %s",jtagnames[p->tag]);
    }
}

static unitrec * createcall	(unitrec * p,unitrec * q) {
unitrec *	r;
unitrec *	s;
strec *	d;
paramrec *	pm;
int32	i;
int32	nparams;
int32	aparams;
int32	m;
int32	retmode;
int32	mproc;
    if (p->tag != j_name || p->def->nameid != procid) {
        m = p->mode;
        mproc = tttarget[m];
        if (!ttisref[m] || ttbasetype[mproc] != tproc) {
            serror_ss("Not function pointer %s %s",typename(m),typename(mproc));
        }
        pm = ttparams[mproc];
        retmode = tttarget[mproc];
    }
    else {
        d = p->def;
        p->tag = j_nameaddr;
        pm = d->paramlist;
        retmode = d->mode;
    }
    nparams = pm->nparams;
    aparams = 0;
    s = q;
    while (s) {
        ++aparams;
        s = s->nextunit;
    }
    if (aparams < nparams) {
        terror("Too few args");
    }
    else if (aparams > nparams && pm->flags != pm_variadic) {
        terror("Too many args");
    }
    s = q;
    for (i=1; i<=aparams; ++i) {
        if (i <= nparams) {
            coercemode_inplace(s,pm->mode);
            pm = pm->nextparam;
        }
        else {
            coercebasetype(s);
        }
        s = s->nextunit;
    }
    r = createunit2(j_callfn,p,q);
    r->mode = retmode;
    r->aparams = aparams;
    return r;
}

static unitrec * arraytopointer	(unitrec * p) {
int32	t=p->mode;
    if (ttbasetype[t] == tarray) {
        if ((p->tag==j_derefoffset)) {
            p->tag = j_addoffset;
        } else if ((p->tag==j_deref)) {
            p = p->a;
        }
        else {
            printf("%s\n","ATP:");
            printunit(0,p,0,"*");
            terror("ATP?");
        }
        p->mode = createrefmode(tttarget[t]);
        p->alength = ttlength[t];
    }
    return p;
}

static unitrec * createindexop	(unitrec * p,unitrec * q) {
unitrec *	r;
unitrec *	s;
int32	t;
int32	elemtype;
int32	elemsize;
int32	scale;
    t = p->mode;
    if (!ttisref[t]) {
        {unitrec *	temp;
            temp = p;
            p = q;
            q = temp;
        }
        t = p->mode;
    }
    if (!ttisref[t]) {
        terror_s("Can't index this type %s",Strmode(t,1));
    }
    q = coercemode(q,tptroffset);
    scale = ttsize[elemtype = tttarget[t]];
    if (q->tag == j_const) {
        q->value = q->value*scale;
        scale = 1;
    }
    s = 0;
    if ((p->tag==j_const) || (p->tag==j_nameaddr) || (p->tag==j_name)) {
        s = createunit2(j_derefoffset,p,q);
        s->ptrscale = scale;
    } else if ((p->tag==j_addoffset)) {
        if (p->b->tag == j_const && p->ptrscale > 1) {
            terror("CREATEINDEX/ADDOFFSET/CONST SCALE<>1?");
        }
        if (p->b->tag == j_const) {
            if (q->tag == j_const) {
                p->b->value += q->value;
            }
            else {
                p->c = p->b;
                p->b = q;
            }
            p->ptrscale = scale;
        }
        else if (q->tag == j_const) {
            if (!!p->c) {
                p->c->value += q->value;
            }
            else {
                p->c = q;
            }
        }
        else {
            s = createunit2(j_derefoffset,p,q);
            s->ptrscale = scale;
            goto L331;
        }
        p->tag = j_derefoffset;
        s = p;
    }
    else {
        s = createunit2(j_derefoffset,p,q);
        s->ptrscale = scale;
    }
done:
L331:;
    s->mode = elemtype;
    s = arraytopointer(s);
    fixmemopnd(s);
    return s;
}

static int32 readstructdecl	(strec * owner) {
strec *	d;
strec *	e;
strec *	currrecord;
strec *	ulist;
strec *	ulistx;
strec *	tagowner;
int32	funion;
int32	linkage;
int32	mbase;
int32	m;
int32	offset;
int32	recsize;
int32	maxsize;
int32	maxalignment;
int32	alignment;
int32	size;
paramrec *	pm;
fieldrec *	fieldlist;
fieldrec *	fl;
    funion = (int32)(lx.symbol == kunionsym);
    lex();
    tagowner = (currproc?currproc:stmodule);
    if (lx.symbol == lcurlysym) {
        d = addnamestr(nextautotype());
    }
    else {
        checksymbol(namesym);
        d = lx.symptr;
        lex();
        if (lx.symbol != lcurlysym) {
            e = resolvename(tagowner,d,ns_tags,currblockno);
            if (e) {
                if (e->nameid != structtagid) {
                    serror_s("Struct tag in use %s",e->name);
                }
                return e->mode;
            }
            e = createdupldef(tagowner,d,structtagid);
            e->mode = createstructmode(e,(funion?tunion:tstruct));
            e->blockno = currblockno;
            blockcounts[currblockno] = 1;
            return e->mode;
        }
    }
    e = checkdupl(tagowner,d,ns_tags,currblockno);
    if (e) {
        if (e->nameid != structtagid) {
            serror_s("Struct tag in use %s",e->name);
        }
        if (!!e->deflist) {
            printf("%s %d %s %s\n","Prev",e->lineno&1677215,sourcefilenames[e->lineno>>24],sourcefilepaths[e->lineno>>24]);
            serror_s("Redefining struct %s",e->name);
        }
    }
    else {
        e = createdupldef(tagowner,d,structtagid);
        e->mode = createstructmode(e,(funion?tunion:tstruct));
        e->blockno = currblockno;
        blockcounts[currblockno] = 1;
    }
    lex();
    currrecord = e;
    ulist = ulistx = 0;
    offset = maxsize = recsize = 0;
    maxalignment = 1;
    fieldlist = 0;
    while (lx.symbol != rcurlysym) {
        mbase = readdeclspec(currrecord,&linkage);
L335:;
        if ((lx.symbol==namesym) || (lx.symbol==mulsym) || (lx.symbol==lbracksym)) {
            m = readtype(currrecord,&d,mbase,&pm);
            if (d == 0) {
                serror("Field name expected");
            }
            if (linkage == typedef_ss || pm) {
                serror("typedef or function inside struct");
            }
            e = checkdupl(currrecord,d,ns_fields,0);
            if (e) {
                serror_s("member name in use %s",e->name);
            }
            if (linkage != none_ss) {
                serror("Can't use ss in struct");
            }
addanonfield:
L339:;
            d = createdupldef(0,d,fieldid);
            d->mode = m;
            addlistdef(&ulist,&ulistx,d);
            currrecord->deflist = ulist;
            currrecord->deflistx = ulistx;
            d->owner = currrecord;
            alignment = getalignment(m);
            if (alignment > maxalignment) {
                maxalignment = alignment;
            }
            d->offset = roundoffset(offset,alignment);
            size = ttsize[m];
            recsize += d->offset-offset;
            offset = d->offset;
            addnewfield(&fieldlist,d,offset);
            if (funion) {
                maxsize = (maxsize>size?maxsize:size);
            }
            else {
                offset += size;
                recsize += size;
            }
            if (lx.symbol == colonsym) {
                lex();
                readassignexpr();
            }
            if ((lx.symbol==commasym)) {
                lex();
            }
            else {
                skipsymbol(semisym);
                goto L336;
            }
        } else if ((lx.symbol==colonsym)) {
            lex();
            readassignexpr();
            skipsymbol(semisym);
            goto L336;
        }
        else {
            if ((ttbasetype[mbase]==tstruct) || (ttbasetype[mbase]==tunion)) {
                d = getautofieldname();
                m = mbase;
                goto L339;
            }
            else {
                serror_s("Struct decl error %s",typename(m));
            }
        }
        goto L335;
L336:;
    }
    skipsymbol(rcurlysym);
    currrecord->nextfield = fieldlist;
    ttsize[currrecord->mode] = roundoffset((funion?maxsize:recsize),maxalignment);
    currrecord->attribs.ax_align = maxalignment;
    return currrecord->mode;
}

static int32 checkpointertypes	(int32 s,int32 t,int32 hard) {
int32	starget=tttarget[s];
int32	ttarget=tttarget[t];
int32	sconst=0;
int32	tconst=0;
    if (!!ttconst[starget]) {
        starget = ttconsttype[starget];
        sconst = 1;
    }
    if (!!ttconst[ttarget]) {
        ttarget = ttconsttype[ttarget];
        tconst = 1;
    }
    if (!hard && sconst && !tconst) {
        printf("%s\n",Strmode(s,1));
        printf("%s\n",Strmode(t,1));
        terror("const to non-const pointer");
    }
    if (starget == ttarget) {
        return 1;
    }
    s = starget;
    t = ttarget;
    if (ttbasetype[s] == tvoid || ttbasetype[t] == tvoid) {
        return 1;
    }
    if (!!ttisref[s] && !!ttisref[t]) {
        return checkpointertypes(s,t,hard);
    }
    else if (ttbasetype[s] == tarray && ttbasetype[t] == tarray) {
        if (ttlength[s] != ttlength[t]) {
            return 0;
        }
        starget = tttarget[s];
        ttarget = tttarget[t];
        if (starget == ttarget) {
            return 1;
        }
        if (!!ttisref[starget] && !!ttisref[ttarget]) {
            return checkpointertypes(starget,ttarget,hard);
        }
    }
    else if (ttbasetype[s] == tproc && ttbasetype[t] == tproc) {
        return 1;
    }
    return 0;
}

static int32 comparemode	(int32 s,int32 t) {
    if (s == t) {
        return 1;
    }
    if (ttbasetype[s] == tarray && ttbasetype[s] == tarray) {
        if (comparemode(tttarget[s],tttarget[t]) == 0) {
            return 0;
        }
        if (ttlength[s] == 0 || ttlength[t] == 0 || ttlength[s] == ttlength[t]) {
            return 1;
        }
    }
    return 0;
}

static int32 readenumdecl	(strec * owner) {
strec *	d;
strec *	e;
    lex();
    if (lx.symbol == lcurlysym) {
        readenumnames(owner);
        return tenum;
    }
    checksymbol(namesym);
    d = lx.symptr;
    lex();
    if (lx.symbol != lcurlysym) {
        e = checkdupl(owner,d,ns_tags,currblockno);
        if (e) {
            if (e->nameid != enumtagid) {
                serror_s("Enum tag in use %s",e->name);
            }
        }
        e = createdupldef(owner,d,enumtagid);
        e->mode = createenummode(e);
        e->blockno = currblockno;
        blockcounts[currblockno] = 1;
        return e->mode;
    }
    e = checkdupl(owner,d,ns_tags,currblockno);
    if (e) {
        if (e->nameid != enumtagid) {
            serror_s("Enum tag in use %s",e->name);
        }
        if (!!e->deflist) {
            serror_s("Redefining enum %s",e->name);
        }
    }
    else {
        e = createdupldef(owner,d,enumtagid);
        e->mode = createenummode(e);
        e->blockno = currblockno;
        blockcounts[currblockno] = 1;
    }
    readenumnames(owner);
    ttnamedef[e->mode] = e;
    return e->mode;
}

static void readenumnames	(strec * owner) {
strec *	d;
strec *	e;
strec *	ulist;
strec *	ulistx;
int32	enumseq;
    ulist = ulistx = 0;
    enumseq = 0;
    lex();
    while (lx.symbol == namesym) {
        d = checkdupl(owner,lx.symptr,ns_general,currblockno);
        if (d) {
            serror_s("enum name reused %s",d->name);
        }
        d = createdupldef(owner,lx.symptr,enumid);
        lex();
        if (lx.symbol == assignsym) {
            lex();
            enumseq = readconstintexpr();
        }
        d->index = enumseq;
        d->blockno = currblockno;
        blockcounts[currblockno] = 1;
        ++enumseq;
        if (lx.symbol == commasym) {
            lex();
        }
    }
    skipsymbol(rcurlysym);
}

static unitrec * createdotop	(int32 opc,unitrec * p,strec * d) {
unitrec *	q;
unitrec *	r;
unitrec *	poffset;
unitrec *	pb;
unitrec *	pc;
strec *	e;
strec *	f;
strec *	prec;
strec *	panon;
strec *	pfield;
strec *	gend;
int32	m;
int32	offset;
fieldrec *	fl;
    m = p->mode;
    if (opc == j_idot) {
        if (!ttisref[m]) {
            serror("-> needs pointer");
        }
        m = tttarget[m];
    }
    if ((ttbasetype[m]==tstruct) || (ttbasetype[m]==tunion)) {
    }
    else {
        serror(". -> not a struct");
    }
    prec = ttnamedef[m];
    f = d;
    while (f = f->nextdupl) {
        if (f->owner == prec) {
            offset = f->offset;
            goto L355;
        }
    }
L355:;
    if (!f) {
        gend = d;
        while (gend->prevdupl) {
            gend = gend->prevdupl;
        }
        fl = prec->nextfield;
        while (fl) {
            if (fl->gendef == gend) {
                f = fl->def;
                offset = fl->offset;
                goto L361;
            }
            fl = fl->nextfield;
        }
L361:;
    }
    if (!f) {
        terror_ss("Not a field of struct %s %s",d->name,Strmode(m,1));
    }
    poffset = createconstunit(offset,tsint);
    if (opc == j_dot) {
        if ((p->tag==j_name)) {
            p->tag = j_nameaddr;
            p->mode = createrefmode(p->mode);
            q = createunit2(j_derefoffset,p,poffset);
        } else if ((p->tag==j_deref)) {
            p->tag = j_derefoffset;
            p->b = poffset;
            q = p;
        } else if ((p->tag==j_derefoffset)) {
            pb = p->b;
            pc = p->c;
            if (pc) {
                pc->value += offset;
            }
            else if (pb->tag == j_const) {
                pb->value += offset;
            }
            else {
                p->c = poffset;
            }
            q = p;
        }
        else {
            q = createunit2(j_derefoffset,p,poffset);
        }
    }
    else {
        if (p->tag == j_const) {
            p->value += offset;
            q = createunit1(j_deref,p);
        }
        else {
            q = createunit2(j_derefoffset,p,poffset);
        }
    }
    q->mode = f->mode;
    q = arraytopointer(q);
    fixmemopnd(q);
    return q;
}

static unitrec * mulunit	(unitrec * p,int32 elemtype) {
int32	elemsize;
    if ((elemsize = ttsize[elemtype]) != 1) {
        if (p->tag == j_const) {
            p->value = p->value*elemsize;
        }
        else {
            p = createunit1(j_scale,p);
            p->scale = elemsize;
            p->mode = tptroffset;
        }
    }
    return p;
}

static unitrec * divunit	(unitrec * p,int32 elemtype) {
int32	elemsize;
    if ((elemsize = ttsize[elemtype]) != 1) {
        if (p->tag == j_const) {
            p->value = p->value/ elemsize;
        }
        else {
            p = createunit1(j_scale,p);
            p->scale = -elemsize;
            p->mode = tptroffset;
        }
    }
    return p;
}

static unitrec * createassignopref	(int32 opc,unitrec * p,unitrec * q) {
int32	pmode;
int32	qmode;
int32	rmode;
int32	elemmode;
unitrec *	r;
    pmode = rmode = p->mode;
    elemmode = tttarget[pmode];
    qmode = q->mode;
    if ((opc==assignsym)) {
        q = coercemode(q,pmode);
        r = createunit2(j_assign,p,q);
    } else if ((opc==addtosym)) {
        if (!!ttisref[qmode]) {
            serror("ptr+=ptr");
        }
        q = coercemode(q,tptroffset);
        r = createunit2(j_addto,p,mulunit(q,elemmode));
    } else if ((opc==subtosym)) {
        if (!!ttisref[qmode]) {
            if (!comparemode(pmode,qmode)) {
                serror("-= refs don't match");
            }
            r = divunit(createunit2(j_sub,p,q),elemmode);
            rmode = tsint;
        }
        else {
            r = createunit2(j_subto,p,mulunit(q,elemmode));
        }
    }
    else {
        serror("Not allowed on ptrs");
    }
    r->mode = rmode;
    return r;
}

static void addnewfield	(fieldrec * * flist,strec * d,int32 offset) {
strec *	e;
fieldrec *	f;
    if ((uchar)*d->name != '$') {
        f = (fieldrec *)pcm_allocz(28);
        f->def = d;
        while (d->prevdupl) {
            d = d->prevdupl;
        }
        f->gendef = d;
        f->offset = offset;
        f->nextfield = *flist;
        *flist = f;
    }
    else {
        e = ttnamedef[d->mode]->deflist;
        while (e) {
            addnewfield(flist,e,offset+e->offset);
            e = e->nextdef;
        }
    }
}

static void pushloop	(int32 looptype) {
    if (loopindex >= maxnestedloops) {
        serror("Too many nested loop or switch");
    }
    ++loopindex;
    looptypestack[loopindex-1] = looptype;
    casevaluestack[loopindex-1] = 0;
}

static void poploop	(void) {
    if (loopindex) {
        --loopindex;
    }
    else {
        serror("poploop?");
    }
}

static void addcasevalue	(int32 value) {
caserec *	p;
int32	index=loopindex;
    while (index && looptypestack[index-1] != 'S') {
        --index;
    }
    if (index == 0) {
        serror("case not inside switch stmt");
    }
    p = (caserec *)pcm_alloc(12);
    p->value = value;
    p->nextcase = casevaluestack[index-1];
    casevaluestack[index-1] = p;
}

static int32 roundoffset	(int32 offset,int32 alignment) {
int32	mask;
    if (structpadding) {
        if (alignment == 1) {
            return offset;
        }
        mask = alignment-1;
        while (offset&mask) {
            ++offset;
        }
    }
    return offset;
}

static void fixmemopnd	(unitrec * p) {
int32	t;
    if ((t = ttbasetype[p->mode]==tschar) || (t = ttbasetype[p->mode]==tsshort) || (t = ttbasetype[p->mode]==tuchar) || (t = ttbasetype[p->mode]==tushort) || (t = ttbasetype[p->mode]==tbool)) {
        insertunit(p,j_widenmem);
        p->mode = tsint;
    }
}

static unitrec * docast	(unitrec * p,int32 t,int32 hard,int32 inplace) {
unitrec *	q;
int32	s;
int32	opc;
    s = p->mode;
retry:
L385:;
    if (s == t) {
        return p;
    }
    opc = 0;
    if (s < 16 && t < 16) {
        opc = conversionops[s][t];
    }
    else if (!!ttisref[s] && !!ttisref[t]) {
        if (!!checkpointertypes(s,t,hard)) {
            p->mode = t;
            return p;
        }
    }
    else if (!!ttconst[s]) {
        s = ttconsttype[s];
        goto L385;
    }
    else if (!!ttconst[t]) {
        t = ttconsttype[t];
        goto L385;
    }
    else if (!!ttisref[t] && s >= tfirstint && s <= tlastint && p->tag == j_const && p->value == 0) {
        opc = soft_c;
    }
    if (opc == 0) {
        if (!hard) {
            printf("%s\n",Strmode(s,1));
            printf("%s\n",Strmode(t,1));
            terror_ss("Can't do conversion %s => %s",typename(s),typename(t));
        }
        opc = hard_c;
    }
    if ((p->tag==j_const)) {
        if (!!eval_convert(p,t,opc)) {
            return p;
        }
    } else if ((p->tag==j_nameaddr) || (p->tag==j_funcname)) {
        p->mode = t;
        return p;
    } else if ((p->tag==j_add)) {
        if (p->a->tag == j_const && p->b->tag == j_const) {
            p->value = p->a->value+p->b->value;
            p->mode = t;
            p->tag = j_const;
            return p;
        }
    }
    if (inplace) {
        insertunit(p,j_convert);
        p->mode = t;
        p->opcode = opc;
        return 0;
    }
    else {
        q = createunit1(j_convert,p);
        q->opcode = opc;
        q->mode = t;
    }
    return q;
}

static unitrec * coercemode	(unitrec * p,int32 t) {
int32	s;
int32	opc;
unitrec *	q;
    if (p->mode == t) {
        return p;
    }
    docast(p,t,0,1);
    return p;
}

static void coercemode_inplace	(unitrec * p,int32 t) {
int32	s;
int32	opc;
unitrec *	q;
    if (p->mode == t) {
        return;
    }
    docast(p,t,0,1);
}

static void dostaticassert	(void) {
int32	x;
char	str[256];
    lex();
    skipsymbol(lbracksym);
    x = readconstintexpr();
    skipsymbol(commasym);
    checksymbol(stringconstsym);
    if (!x) {
        memcpy((int32 *)&str,(int32 *)lx.svalue,lx.length);
        str[lx.length+1-1] = 0;
        serror((char *)&str);
    }
    lex();
    skipsymbol(rbracksym);
}


// From module: cc_libtcl
static void printtcl	(tclrec * tc) {
    gs_init(tcl);
    writetclinstr(tc);
    gs_println(tcl,0);
}

void settcdest	(int32 dest) {
}

void inittc	(void) {
int32	i;
int32	j;
int32	k;
opndrec *	rx;
void *	f;
    f = fopen("kkk1","w");
    for (i=t_comment; i<=78; ++i) {
        fprintf(f,"!when %s then\n",tclnames[i-1]);
    }
    fclose(f);
    inittccode();
    memset((int32 *)&zerotcl,0,64);
    memset((int32 *)&zeroopnd,0,16);
    for (i=1; i<=maxopnd; ++i) {
        opndtable[i-1] = (opndrec *)pcm_allocz(16);
    }
}

void inittccode	(void) {
    tccode = tccodex = 0;
    tccode = tccodex = newtclrec(t_tempdata);
    topopnd = currtempno = 0;
}

void gentc	(int32 opcode) {
tclrec *	p;
    if (opcode == t_stmt) {
        if (tccodex->opcode == t_stmt) {
            return;
        }
    }
    p = newtclrec(opcode);
    tccodex->nexttcl = p;
    tccodex = p;
}

void gentc1	(int32 opcode,opndrec * a) {
tclrec *	p;
    p = newtclrec(opcode);
    p->a = *a;
    tccodex->nexttcl = p;
    tccodex = p;
}

void gentc2	(int32 opcode,opndrec * a,opndrec * b) {
tclrec *	p;
    p = newtclrec(opcode);
    p->a = *a;
    p->b = *b;
    tccodex->nexttcl = p;
    tccodex = p;
}

void gentc3	(int32 opcode,opndrec * a,opndrec * b,opndrec * c) {
tclrec *	p;
    p = newtclrec(opcode);
    p->a = *a;
    p->b = *b;
    p->c = *c;
    tccodex->nexttcl = p;
    tccodex = p;
}

void gentc_label	(int32 opcode,int32 labno) {
tclrec *	p;
    p = newtclrec(opcode);
    p->a.fmt = label_opnd;
    p->a.labelno = labno;
    addtclrec(p);
}

void gentc_int	(int32 opcode,int32 value) {
tclrec *	p;
    p = newtclrec(opcode);
    p->a.fmt = int_opnd;
    p->a.value = value;
    p->a.typecode = signed_type;
    p->a.size = 4;
    addtclrec(p);
}

static tclrec * newtclrec	(int32 opcode) {
tclrec *	p;
    p = (tclrec *)pcm_alloc(64);
    *p = zerotcl;
    p->opcode = opcode;
    p->lineno = clineno;
    ++ntclinstructions;
    return p;
}

static void addtclrec	(tclrec * p) {
    if (tccode == 0) {
        tccode = tccodex = p;
    }
    else {
        tccodex->nexttcl = p;
    }
    tccodex = p;
}

static opndrec * getnextopnd	(void) {
    if (topopnd < maxopnd) {
        return opndtable[++topopnd-1];
    }
    return (opndrec *)pcm_allocz(16);
}

opndrec * gen_int	(int64 a,int32 size) {
opndrec *	ax;
    ax = getnextopnd();
    ax->fmt = int_opnd;
    ax->typecode = signed_type;
    ax->value = a;
    ax->size = size;
    return ax;
}

opndrec * gen_real	(double x,int32 size) {
opndrec *	ax;
    ax = getnextopnd();
    ax->fmt = real_opnd;
    ax->typecode = float_type;
    ax->xvalue = x;
    ax->size = size;
    return ax;
}

opndrec * gen_label	(int32 lab) {
opndrec *	ax;
    ax = getnextopnd();
    ax->fmt = label_opnd;
    ax->labelno = lab;
    return ax;
}

opndrec * gen_string	(char * s,int32 length) {
opndrec *	ax;
    ax = getnextopnd();
    ax->fmt = string_opnd;
    ax->svalue = s;
    ax->size = ptrsize;
    ax->typecode = pointer_type;
    ax->slength = ((length < 255)?(length):255);
    return ax;
}

opndrec * gen_mem	(strec * d,int32 m) {
opndrec *	ax;
int32	t;
    ax = getnextopnd();
    if (m == 0) {
        m = d->mode;
    }
    ax->fmt = mem_opnd;
    ax->def = d;
    ax->size = ttsize[m];
    ax->typecode = gettypecode(m);
    return ax;
}

opndrec * gen_addr	(strec * d) {
opndrec *	ax;
    ax = getnextopnd();
    ax->fmt = memaddr_opnd;
    ax->def = d;
    ax->size = ptrsize;
    ax->typecode = pointer_type;
    return ax;
}

opndrec * gen_dest	(opndrec * dest,int32 m) {
    if (dest) {
        return dest;
    }
    return gen_temp(m);
}

opndrec * gen_destax	(opndrec * dest,opndrec * ax) {
    if (dest) {
        return dest;
    }
    return gen_tempax(ax);
}

opndrec * gen_temp	(int32 m) {
opndrec *	ax;
    ax = getnextopnd();
    if (currtempno >= maxtemp) {
        gerror("Too many temps",0);
    }
    ++currtempno;
    ax->fmt = temp_opnd;
    ax->tempno = currtempno;
    ax->size = ttsize[m];
    ax->typecode = gettypecode(m);
    opndsizes[currtempno-1] = ax->size;
    opndtypes[currtempno-1] = ax->typecode;
    return ax;
}

opndrec * gen_tempax	(opndrec * px) {
opndrec *	ax;
    ax = getnextopnd();
    if (currtempno >= maxtemp) {
        gerror("Too many temps",0);
    }
    ++currtempno;
    ax->fmt = temp_opnd;
    ax->tempno = currtempno;
    ax->size = px->size;
    ax->typecode = px->typecode;
    opndsizes[currtempno-1] = ax->size;
    opndtypes[currtempno-1] = ax->typecode;
    return ax;
}

opndrec * gen_imem	(strec * d,int32 m) {
opndrec *	ax;
    ax = gen_mem(d,m);
    ax->fmt = imem_opnd;
    return ax;
}

opndrec * gen_itemp	(int32 m) {
opndrec *	ax;
    ax = gen_temp(m);
    ax->fmt = itemp_opnd;
    return ax;
}

opndrec * makeindirect	(opndrec * ax,int32 m) {
opndrec *	bx;
    bx = getnextopnd();
    *bx = *ax;
    bx->size = ttsize[m];
    bx->typecode = gettypecode(m);
    if ((bx->fmt==mem_opnd)) {
        bx->fmt = imem_opnd;
    } else if ((bx->fmt==temp_opnd)) {
        bx->fmt = itemp_opnd;
    }
    return bx;
}

void gencomment	(char * s) {
    if (s == 0 || (uchar)*s == 0) {
        gentc(t_blank);
    }
    else {
        gentc(t_comment);
        tccodex->a.fmt = string_opnd;
        tccodex->a.svalue = s;
    }
}

void make_int_opnd	(opndrec * ax,int64 value,int32 size) {
    ax->fmt = int_opnd;
    ax->value = value;
    ax->size = size;
}

static void writetclproc	(strec * d) {
tclrec *	m;
int32	n;
char	str[100];
    gs_str(tcl,"PROC:");
    gs_strln(tcl,d->name);
    m = (tclrec *)d->tclcode;
    n = 0;
    while (m) {
        sprintf((char *)&str,"%4d %06d: ",++n,m->lineno&16777215);
        gs_str(tcl,(char *)&str);
        writetclinstr(m);
        m = m->nexttcl;
    }
    gs_line(tcl);
}

static void writetclinstr	(tclrec * m) {
char	str[4096];
char	str2[32];
char	str3[32];
int32	i;
int32	n;
enum {opwidth = 12};
    if ((m->opcode==t_stmt)) {
        gs_strln(tcl,">>");
        return;
    } else if ((m->opcode==t_label)) {
        gs_str(tcl," L");
        gs_strint(tcl,m->a.labelno);
        if (!!m->b.def) {
            gs_str(tcl,"/");
            gs_str(tcl,m->b.def->name);
        }
        gs_strln(tcl,": =========");
    } else if ((m->opcode==t_tempdata)) {
        n = m->ntemps;
        gs_str(tcl,"TEMPDATA:");
        gs_strint(tcl,n);
        gs_line(tcl);
        for (i=1; i<=n; ++i) {
            gs_str(tcl,"\t\t\t");
            gs_strint(tcl,i);
            gs_str(tcl,": ");
            gs_str(tcl,getshorttypecode((*m->a.temptypes)[i-1],(*m->b.tempsizes)[i-1]));
            gs_line(tcl);
        }
        return;
    }
    gs_str(tcl,"   ");
    if ((m->opcode==t_comment)) {
        gs_str(tcl,"; ");
        gs_strln(tcl,m->a.svalue);
    } else if ((m->opcode==t_label)) {
        gs_line(tcl);
    } else if ((m->opcode==t_labelname)) {
        gs_str(tcl,"   ");
        gs_str(tcl,m->a.def->name);
        gs_strln(tcl,":");
    } else if ((m->opcode==t_blank)) {
        gs_line(tcl);
    }
    else {
        gs_leftstr(tcl,getsizestr(m),14,'-');
        strcpy((char *)&str2,tclnames[m->opcode-1]+2);
        if ((m->opcode==t_jumpcc) || (m->opcode==t_setcc)) {
            strcat((char *)&str2,".");
            strcat((char *)&str2,jtagnames[m->cond]);
        }
        else {
            if (!!m->paramno) {
                sprintf((char *)&str3,".%d",m->paramno);
                strcat((char *)&str2,(char *)&str3);
            }
        }
        gs_leftstr(tcl,(char *)&str2,opwidth,32);
        if (!!m->a.fmt) {
            strcpy((char *)&str,strtclopnd(&(m)->a));
            if (!!m->b.fmt) {
                strcat((char *)&str,",  ");
                strcat((char *)&str,strtclopnd(&(m)->b));
                if (!!m->c.fmt) {
                    strcat((char *)&str,",  ");
                    strcat((char *)&str,strtclopnd(&(m)->c));
                }
            }
            gs_str(tcl,(char *)&str);
        }
        if ((m->opcode==t_index) || (m->opcode==t_indexref) || (m->opcode==t_indexlv)) {
            if (!!m->c.offset) {
                gs_str(tcl," Offset:");
                gs_strint(tcl,m->c.offset);
            }
        }
        gs_line(tcl);
    }
}

char * strtclopnd	(opndrec * p) {
static char	str[1024];
char	str2[320];
byte	doplus;
int32	length;
static int32	maxlen=0;
static int32	newmaxlen=0;
    if ((p->fmt==int_opnd)) {
        sprintf((char *)&str,"%lld",p->value);
    } else if ((p->fmt==real_opnd)) {
        sprintf((char *)&str,"%f",p->uvalue);
    } else if ((p->fmt==string_opnd)) {
        if (p->svalue == 0) {
            return "0";
        }
        if ((length = strlen(p->svalue)) > 256) {
            strcpy((char *)&str,"(LONGSTR)");
        }
        else {
            strcpy((char *)&str,"\"");
            convertstring(p->svalue,&str[2-1],-1);
            strcat((char *)&str,"\"");
        }
    } else if ((p->fmt==label_opnd)) {
        sprintf((char *)&str,"L%d",p->labelno);
    } else if ((p->fmt==mem_opnd)) {
        sprintf((char *)&str,"[%s]",p->def->name);
    } else if ((p->fmt==imem_opnd)) {
        sprintf((char *)&str,"@[%s]",p->def->name);
    } else if ((p->fmt==memaddr_opnd)) {
        sprintf((char *)&str,"&%s",p->def->name);
    } else if ((p->fmt==temp_opnd)) {
        sprintf((char *)&str,"T%d",p->tempno);
    } else if ((p->fmt==itemp_opnd)) {
        sprintf((char *)&str,"@T%d",p->tempno);
    }
    else {
        strcpy((char *)&str,"<amode>");
    }
    if (p->size > 8) {
        strcat((char *)&str," <BLOCK>");
    }
    return (char *)&str;
}

static char * getsizestr	(tclrec * tc) {
static char	str[32];
char	astr[16];
char	bstr[16];
char	cstr[16];
    astr[1-1] = (uchar)(bstr[1-1] = (uchar)(cstr[1-1] = 0));
    if (!!tc->a.size) {
        strcpy((char *)&astr,getshorttypecode(tc->a.typecode,tc->a.size));
    }
    if (!!tc->b.size) {
        strcpy((char *)&bstr,getshorttypecode(tc->b.typecode,tc->b.size));
    }
    if (!!tc->c.size) {
        strcpy((char *)&cstr,getshorttypecode(tc->c.typecode,tc->c.size));
    }
    sprintf((char *)&str,"%s/%s/%s",&astr,&bstr,&cstr);
    return (char *)&str;
}

strbuffer * writetccode	(char * caption,int32 n,int32 phase) {
int32	cmd;
int32	pc;
int32	i;
int32	lastline;
int32	line;
int32	lab;
strec *	stm;
strec *	d;
tclrec *	tccode;
    gs_init(tcl);
    gs_str(tcl,"PROC ");
    gs_str(tcl,caption);
    gs_str(tcl,"/MODULE:");
    gs_str(tcl,moduletable[n].name);
    gs_str(tcl,"/");
    gs_strint(tcl,n);
    gs_strln(tcl,":");
    gs_line(tcl);
    stm = moduletable[n].stmodule;
    d = stm->deflist;
    while (d) {
        if (d->nameid == procid && !!d->code) {
            writetclproc(d);
        }
        d = d->nextdef;
    }
    return tcl;
}

int32 checkblockreturn	(unitrec * p) {
unitrec *	q;
    if (p == 0) {
        return 0;
    }
    if ((p->tag==j_block)) {
        q = p->c;
        if (q == 0) {
            return 0;
        }
        if (q->tag == j_return) {
            return 1;
        }
        return checkblockreturn(q);
    } else if ((p->tag==j_return)) {
        return 1;
    } else if ((p->tag==j_if)) {
        return (int32)(!!checkblockreturn(p->b) && !!checkblockreturn(p->c));
    }
    return 0;
}

int32 gettypecode	(int32 m) {
    m = ttbasetype[m];
    if (m >= tfirstint && m <= tlastint) {
        return (!!stdtypesigned[m]?signed_type:unsigned_type);
    }
    else if (m >= tfirstreal && m <= tlastreal) {
        return float_type;
    }
    else if (m == tref) {
        return pointer_type;
    }
    else {
        return block_type;
    }
}

opndrec * fixopnd	(opndrec * ax) {
opndrec *	tx;
    if ((ax->fmt==imem_opnd) || (ax->fmt==itemp_opnd)) {
        gentc2(t_getptr,tx = gen_tempax(ax),ax);
        return tx;
    }
    return ax;
}

char * getshorttypecode	(int32 t,int32 size) {
static char	str[20];
    sprintf((char *)&str,"%s%d",shorttypenames[t],size);
    return (char *)&str;
}

int32 roundoffsetdown	(int32 a,int32 t) {
int32	mask;
    if ((ttbasetype[t]==tarray)) {
        return roundoffsetdown(a,tttarget[t]);
    } else if ((ttbasetype[t]==tschar) || (ttbasetype[t]==tuchar)) {
        return a;
    } else if ((ttbasetype[t]==tsshort) || (ttbasetype[t]==tushort)) {
        mask = 1;
    } else if ((ttbasetype[t]==tsint) || (ttbasetype[t]==tuint)) {
        mask = 3;
    }
    else {
        mask = 7;
    }
    while (a&mask) {
        --a;
    }
    return a;
}


// From module: cc_genasm
int32 codegen_asm	(int32 n,char * outfile) {
strec *	d;
int32	i;
    if (fverbose) {
        printf("%s\n","Generating ASM64:");
    }
    gen2start = os_clock();
    initasmdest();
    stmodule = moduletable[n].stmodule;
    asmstr(";\tModule:");
    asmstrln(stmodule->name);
    asmstrln("%include \"mccasm.inc\"");
    asmline();
    if (fshowline) {
        asmstrln("\textern $showline");
    }
    d = stmodule->deflist;
    while (d) {
        if ((d->nameid==procid)) {
            doprocdef(d);
        } else if ((d->nameid==staticid)) {
            dostaticvar(d);
        } else if ((d->nameid==typeid) || (d->nameid==structtagid) || (d->nameid==enumtagid)) {
        }
        d = d->nextdef;
    }
    writetables();
    gen2end = os_clock();
    *asmptr = 0;
    if (fverbose) {
        printf("%s %s%s\n","Writing",outfile,":");
    }
    asmwstart = os_clock();
    writefile(outfile,(byte *)asmstart,asmptr-asmstart);
    asmwend = os_clock();
    moduletable[n].asmstr = asmstart;
    return 1;
}

static void doprocdef	(strec * p) {
int32	i;
int32	nparams;
int32	nlowparams;
int32	t;
int32	frameoffset;
int32	paramoffset;
int32	framebytes;
int32	parambytes;
int32	offset;
int32	adjbytes;
int32	size;
strec *	d;
tclrec *	m;
static int32	fncount=0;
int32	paramtypes[4];
paramrec *	pm;
    asmbuffercheck(1024);
    if (!!p->code) {
        if ((p->scope==imported_scope) || (p->scope==exported_scope)) {
            asmstr("\tglobal ");
            asmstrln(p->name);
        }
    }
    else {
        if ((p->scope==imported_scope) || (p->scope==exported_scope)) {
            if (!!p->attribs.ax_used) {
                asmstr("\textern ");
                asmstrln(p->name);
            }
        }
        else {
            gerror("Static function not defined",0);
        }
        return;
    }
    currproc = p;
    txreturn = 0;
    asmstr(";\tProc:");
    asmstrln(p->name);
    paramoffset = 16;
    frameoffset = 0;
    parambytes = 0;
    adjbytes = 0;
    nparams = nlowparams = 0;
    d = p->deflist;
    while (d) {
        if ((d->nameid==staticid)) {
            dostaticvar_fn(d);
        } else if ((d->nameid==frameid)) {
            if ((size = ttsize[d->mode]) == 0) {
                printf("%s\n",d->name);
                gerror("Zero size local",0);
            }
            frameoffset -= size;
            frameoffset = roundoffsetdown(frameoffset,d->mode);
            d->offset = frameoffset;
            if (!!d->code) {
                if (d->code->tag == j_makelist || ttbasetype[d->mode] == tarray && d->code->tag == j_const) {
                    dostaticvar_fn(d);
                }
            }
        } else if ((d->nameid==paramid)) {
            d->offset += paramoffset;
            paramoffset += 8;
            ++nparams;
            if (nparams <= 4) {
                paramtypes[++nlowparams-1] = d->mode;
            }
        }
        d = d->nextdef;
    }
    m = (tclrec *)p->tclcode;
    if (m->opcode != t_tempdata) {
        gerror("tempdata op expected",0);
    }
    ntemps = m->ntemps;
    temptypes = m->a.temptypes;
    tempsizes = m->b.tempsizes;
    m = m->nexttcl;
    if (m->opcode == t_setret) {
        txreturn = &(m)->a;
        m = m->nexttcl;
    }
    frameoffset = roundoffsetdown(frameoffset,tullong);
    for (i=1; i<=ntemps; ++i) {
        frameoffset -= size = m_imax((*tempsizes)[i-1],8);
        frameoffset = roundoffsetdown_size(frameoffset,size);
        tempoffsets[i-1] = frameoffset;
    }
    framebytes = -frameoffset;
    if (!!(framebytes&8)) {
        framebytes += 8;
        frameoffset -= 8;
    }
    parambytes = paramoffset-16;
    setcodeseg();
    asmstr(p->name);
    asmchar(':');
    asmline();
    if (p->namelen == 4 && memcmp(p->name,"main",4) == 0 && parambytes) {
        genmainprelude();
    }
    if (!!(framebytes+parambytes)) {
        asmstrln("\tpush Dframe");
        asmstrln("\tmov Dframe, Dstack");
        if (framebytes) {
            asmstr("\tsub Dstack, ");
            asmint(framebytes);
            asmline();
        }
    }
    else {
        adjbytes = 8;
        asmstrln("\tsub Dstack, 8");
    }
    asmline();
    offset = 16;
    if (p->paramlist->flags == pm_variadic) {
        nlowparams = 4;
    }
    for (i=1; i<=nlowparams; ++i) {
        t = paramtypes[i-1];
        if (tfirstreal <= t && t <= tlastreal) {
            asmstr(((t == tfloat)?"\tmovd":"\tmovq"));
            asmstr(" [Dframe+");
            asmint(offset);
            asmstr("], XMM");
            asmint((xr0+i-2));
            asmline();
        }
        else {
            asmstr("\tmov [Dframe+");
            asmint(offset);
            asmstr("], D");
            asmint((r10+i-2));
            asmline();
        }
        offset += 8;
    }
    if (txreturn) {
        storeopnd(txreturn,r9);
    }
    while (m) {
        translate(m);
        m = m->nexttcl;
    }
    if (framebytes) {
        asmstr("\tadd Dstack, ");
        asmint(framebytes);
        asmline();
    }
    if (!!(framebytes+parambytes)) {
        asmstrln("\tpop Dframe");
    }
    if (adjbytes) {
        asmstrln("\tadd Dstack,8");
    }
    if (strcmp(currproc->name,"main") == 0) {
        asmstrln("\textern exit");
        asmstrln("\tsub Dstack,40");
        asmstrln("\tmov D10,D0");
        asmstrln("\tcall exit");
    }
    else {
        asmstrln("\tret");
    }
    asmstrln(";\tEnd\n");
}

static void writetables	(void) {
int32	i;
byte *	s;
    if (nstrings) {
        setidataseg(8);
        asmstrln("\n;string table:");
        for (i=1; i<=nstrings; ++i) {
            asmstr("KK");
            asmint(i);
            asmstr(":\t");
            genstrconst(stringtable[i-1],stringlentable[i-1]);
            asmline();
        }
    }
    if (nreals) {
        setidataseg(8);
        asmstrln("\n;real const table:");
        for (i=1; i<=nreals; ++i) {
            asmstr("RR");
            asmint(i);
            asmstr(":\t");
            genrealconst(realtable[i-1],realsizetable[i-1]);
            asmline();
        }
    }
}

static void translate	(tclrec * m) {
opndrec *	a;
opndrec *	b;
opndrec *	c;
char *	name;
static int32	lastcline=0;
    doopndsize = 0;
    clineno = m->lineno;
    opndcomment1[1-1] = (uchar)(opndcomment2[1-1] = 0);
    if (asmend-asmptr < 1024) {
        expandasmdest();
    }
    a = &(m)->a;
    b = &(m)->b;
    c = &(m)->c;
    asmstr("; ------------------------------ ");
    asmstrln(tclnames[m->opcode-1]+2);
    switch (m->opcode) {
    case t_comment:
        asmchar(';');
        asmstrln(a->svalue);
        break;
    case t_blank:
        asmln();
        break;
    case t_stmt:
        break;
    case t_param:
        ncallparams = m->paramno;
        paramlist[ncallparams-1] = a;
        return;
        break;
    case t_eval:
        break;
    case t_move:
        domove(a,b);
        break;
    case t_copylist:
        docopylist(a);
        break;
    case t_getptr:
        dogetptr(a,b);
        break;
    case t_index:
        doindex(a,b,c,m->scale,0);
        break;
    case t_indexlv:
        doindex(a,b,c,m->scale,1);
        break;
    case t_indexref:
        doindex(a,b,c,m->scale,1);
        break;
    case t_getaddr:
        dogetaddr(a,b);
        break;
    case t_label:
        asmchar('L');
        asmint(a->labelno);
        asmchar(':');
        if (!!b->def) {
            asmstr(" ;<");
            asmstr(b->def->name);
            asmstr(">");
        }
        asmline();
        break;
    case t_jumplabel:
        asmstr("\tdq ");
        asmchar('L');
        asmint(a->labelno);
        asmstr("\t; ");
        asmint(m->index);
        asmline();
        break;
    case t_switch:
        doswitchop(m,a,b,c);
        break;
    case t_jump:
        asmstr("\tjmp\t");
        asmopnd(a);
        asmln();
        break;
    case t_jumpcc:
        dojumpcc(m->cond,a,b,c);
        break;
    case t_jumptrue:
        dojumptrue(a,b,1);
        break;
    case t_jumpfalse:
        dojumptrue(a,b,0);
        break;
    case t_setcc:
        dosetcc(m->cond,a,b,c);
        break;
    case t_andl:
        break;
    case t_callfn:
    case t_callproc:
        docallproc(m,a,b);
        break;
    case t_return:
doret:
L37:;
        asmstr("\tjmp ");
        asmopnd(a);
        asmln();
        break;
    case t_returnx:
        if (txreturn) {
            saveretvalue(b);
        }
        else {
            gloadopnd(b,r0);
        }
        goto L37;
        break;
    case t_hardret:
        break;
    case t_add:
        doadd(a,b,c);
        break;
    case t_sub:
        dosub(a,b,c);
        break;
    case t_mul:
        domul(a,b,c);
        break;
    case t_div:
    case t_rem:
        dodiv(a,b,c,m->opcode);
        break;
    case t_iand:
    case t_ior:
    case t_ixor:
        doiand(a,b,c,m->opcode);
        break;
    case t_shl:
    case t_shr:
        doshl(a,b,c,m->opcode);
        break;
    case t_neg:
        doneg(a,b);
        break;
    case t_abs:
        doabs(a,b);
        break;
    case t_inot:
        doinot(a,b);
        break;
    case t_addto:
        doaddto(a,b);
        break;
    case t_subto:
        dosubto(a,b);
        break;
    case t_multo:
        domulto(a,b);
        break;
    case t_divto:
    case t_remto:
        dodivto(a,b,m->opcode);
        break;
    case t_iandto:
    case t_iorto:
    case t_ixorto:
        doiandto(a,b,m->opcode);
        break;
    case t_shlto:
    case t_shrto:
        doshlto(a,b,m->opcode);
        break;
    case t_incrto:
        doincr(a,1);
        break;
    case t_decrto:
        doincr(a,0);
        break;
    case t_preincrx:
        dopreincrx(a,b,1,m->scale);
        break;
    case t_predecrx:
        dopreincrx(a,b,0,m->scale);
        break;
    case t_postincrx:
        dopostincrx(a,b,1,m->scale);
        break;
    case t_postdecrx:
        dopostincrx(a,b,0,m->scale);
        break;
    case t_softconv:
        dosoftconv(a,b);
        break;
    case t_float:
        dofloat(a,b);
        break;
    case t_fix:
        dofix(a,b);
        break;
    case t_widen:
        dowiden(a,b);
        break;
    case t_fwiden:
        dofwiden(a,b);
        break;
    case t_fnarrow:
        dofnarrow(a,b);
        break;
    case t_narrow:
        donarrow(a,b);
        break;
    case t_truncate:
        dotruncate(a,b);
        break;
    default:;
        printf("%s %s %s %d\n","CAN'T DO",tclnames[m->opcode-1],"((M)^.LINENO IAND 16777215)=",m->lineno&16777215);
        asmstr("ASM: CAN'T DO:");
        asmstrln(tclnames[m->opcode-1]);
    }
}

static int32 nextstringindex	(char * s,int32 length) {
    if (nstrings > maxstringtable) {
        gerror("Too many string consts",0);
    }
    stringtable[++nstrings-1] = s;
    stringlentable[nstrings-1] = length;
    return nstrings;
}

static int32 nextrealindex	(double x,int32 size) {
float	sx;
    if (nreals > maxrealtable) {
        gerror("Too many real consts",0);
    }
    if (size == 8) {
        realtable[++nreals-1] = *(uint64*)&x;
    }
    else {
        sx = x;
        realtable[++nreals-1] = *(uint32*)&sx;
    }
    realsizetable[nreals-1] = size;
    return nreals;
}

static void genstrconst	(char * s,int32 length) {
int32	state;
char	c;
static int32	k=100;
int32	av_1;
    if ((uchar)*s == 0 || length == 0) {
        asmstrln("db 0");
        return;
    }
    asmstr("db ");
    state = 0;
    av_1 = length;
    while (av_1--) {
        c = (uchar)*s++;
        if (!--k) {
            k = 100;
            asmbuffercheck(1024);
        }
        switch ((uchar)c) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case '\'':
        case 127:
            if (state == 1) {
                asmstr("',");
                state = 0;
            }
            asmint((uchar)c);
            asmchar(',');
            break;
        default:;
            if (state == 0) {
                asmchar('\'');
                state = 1;
            }
            asmchar((uchar)c);
        }
    }
    if (state == 1) {
        asmstr("',0");
    }
    else {
        asmchar('0');
    }
}

static void genrealconst	(uint64 x,int32 size) {
int32	n;
    if (size == 8) {
        asmstr("dq ");
        n = sprintf(asmptr,"0x%llX",x);
    }
    else {
        asmstr("dd ");
        n = sprintf(asmptr,"0x%X, 0",x);
    }
    asmptr += n;
}

static void asmstr	(char * s) {
    while ((uchar)*s) {
        *asmptr++ = (uchar)*s++;
    }
}

static void asmstrln	(char * s) {
char	c;
    while (c = (uchar)*s) {
        *asmptr = (uchar)c;
        ++asmptr;
        ++s;
    }
    *asmptr = 10;
    ++asmptr;
}

static void asmline	(void) {
    *asmptr = 10;
    ++asmptr;
}

static void asmln	(void) {
    if (!!(uchar)opndcomment1[1-1]) {
        asmstr("\t; ");
        asmstr((char *)&opndcomment1);
        opndcomment1[1-1] = 0;
        if (!!(uchar)opndcomment2[1-1]) {
            asmchar(',');
            asmstr((char *)&opndcomment2);
            opndcomment2[1-1] = 0;
        }
    }
    asmline();
}

static void asmint	(int64 a) {
int32	n;
    n = sprintf(asmptr,"%lld",a);
    asmptr += n;
}

static void asmchar	(int32 c) {
    *asmptr = c;
    ++asmptr;
}

static void initasmdest	(void) {
    asmalloc = 4096;
    asmstart = asmptr = (char *)pcm_alloc(asmalloc);
    asmend = asmstart+asmalloc;
}

static void expandasmdest	(void) {
int32	newalloc;
int32	usedbytes;
byte *	p;
    newalloc = asmalloc*2;
    usedbytes = asmptr-asmstart;
    if (usedbytes > asmalloc) {
        gerror("ASMBUFFER ERROR",0);
    }
    p = (byte *)pcm_alloc(newalloc);
    memcpy((int32 *)p,(int32 *)asmstart,usedbytes);
    asmstart = (char *)p;
    asmptr = asmstart+usedbytes;
    asmalloc = newalloc;
    asmend = asmstart+asmalloc;
}

static void setcodeseg	(void) {
    if (currseg != 'C') {
        currseg = 'C';
        asmstrln("\tsegment .text");
    }
}

static void setzdataseg	(int32 align) {
    if (currseg != 'Z') {
        currseg = 'Z';
        asmstrln("\tsegment .bss");
    }
    if (align != 1) {
        asmstr("\talign ");
        asmint(align);
        asmstrln(",resb 1");
    }
}

static void setidataseg	(int32 align) {
    if (currseg != 'I') {
        currseg = 'I';
        asmstrln("\tsegment .data");
    }
    if (align != 1) {
        asmstr("\talign ");
        asmint(align);
        asmline();
    }
}

static void genidata	(unitrec * p) {
int32	t;
int32	length;
int32	n;
int32	i;
int32	j;
int32	nwords;
int32	offset1;
int32	offset2;
int32	size;
int32	padding;
int32	isunion;
unitrec *	q;
unitrec *	a;
unitrec *	b;
strec *	d;
float	sx;
int32	av_2;
int32	av_3;
    t = p->mode;
    asmbuffercheck(1024);
    if ((p->tag==j_makelist)) {
        n = p->count;
        if (ttbasetype[t] == tarray) {
            length = ttlength[t];
            q = p->a;
            for (i=1; i<=n; ++i) {
                genidata(q);
                q = q->nextunit;
            }
            if (n < length) {
                n = (length-n)*ttsize[tttarget[t]];
                while (n >= 8) {
                    asmbuffercheck(1024);
                    asmstrln("\tdq 0");
                    n -= 8;
                }
                av_2 = n;
                while (av_2--) {
                    asmstrln("\tdb 0");
                }
            }
        }
        else {
            isunion = (int32)(ttbasetype[t] == tunion);
            d = ttnamedef[t]->deflist;
            size = ttsize[t];
            offset1 = offset2 = 0;
            q = p->a;
            for (i=1; i<=n; ++i) {
                genidata(q);
                offset1 += ttsize[q->mode];
                d = d->nextdef;
                if (d && !isunion) {
                    offset2 = d->offset;
                }
                else {
                    offset2 = size;
                }
                if (offset1 != offset2) {
                    padding = offset2-offset1;
                    asmstr("\tdb ");
                    for (j=1; j<=padding; ++j) {
                        asmchar('0');
                        if (j < padding) {
                            asmchar(',');
                        }
                    }
                    asmline();
                    offset1 = offset2;
                }
                q = q->nextunit;
            }
            if (offset2 < size) {
                n = size-offset2;
                while (n >= 8) {
                    asmstrln("\tdq 0");
                    n -= 8;
                }
                av_3 = n;
                while (av_3--) {
                    asmstrln("\tdb 0");
                }
            }
        }
        return;
    } else if ((p->tag==j_const)) {
        if (t >= tfirstint && t <= tlastreal) {
            if ((ttsize[t]==1)) {
                asmstr("\tdb ");
            } else if ((ttsize[t]==2)) {
                asmstr("\tdw ");
            } else if ((ttsize[t]==4)) {
                asmstr("\tdd ");
            } else if ((ttsize[t]==8)) {
                asmstr("\tdq ");
            }
            if (t == tfloat) {
                sx = p->xvalue;
                asmint(*(int32*)&sx);
            }
            else {
                asmint(p->value);
            }
            asmline();
        }
        else if (ttbasetype[t] == tref) {
            if (p->slength > 100) {
                asmbuffercheck(p->slength+100);
            }
            if (p->value == 0) {
                asmstrln("\tdq 0");
            }
            else if (!!p->strarray) {
                asmchar('	');
                genstrconst(p->svalue,p->slength);
                asmline();
            }
            else {
                asmstr("\tdq KK");
                asmint(nextstringindex(p->svalue,p->slength));
                asmline();
            }
        }
        else {
            printf("%s\n",Strmode(t,1));
            gerror("IDATA/SCALAR",0);
        }
        return;
    } else if ((p->tag==j_nameaddr) || (p->tag==j_funcname)) {
        d = p->def;
        if ((d->nameid==staticid) || (d->nameid==procid)) {
            asmstr(((ttsize[p->mode] == 8)?"\tdq ":"\tdd "));
            if (d->scope == function_scope) {
                asmstr(currproc->name);
                asmchar('.');
            }
            asmstrln(d->name);
        }
        else {
            gerror("Idata &frame",0);
        }
        return;
    } else if ((p->tag==j_add)) {
        a = p->a;
        b = p->b;
        if (a->tag == j_nameaddr && b->tag == j_const) {
            d = a->def;
            if ((d->nameid==staticid)) {
                asmstr("\tdq ");
                if (d->scope == function_scope) {
                    asmstr(currproc->name);
                    asmchar('.');
                }
                asmstr(d->name);
                asmchar('+');
                asmint(b->value);
                asmline();
            }
            else {
                gerror("Add/Idata &frame",0);
            }
        }
        else if (a->tag == j_const && b->tag == j_const && ttbasetype[a->mode] == tref) {
            asmstr("\tdq ");
            asmint(a->value);
            asmchar('+');
            asmint(b->value);
            asmline();
        }
        else {
            printunit(0,p,0,"*");
            gerror("Runtime or unsupported expr in static data",0);
        }
        return;
    }
    printf("%s %d\n",jtagnames[p->tag],p->lineno);
    printunit(0,p,0,"*");
    gerror("IDATA? [Run-time expressions in {...} data not supported]",p);
}

static void dostaticvar	(strec * d) {
int32	align;
    asmbuffercheck(1024);
    if ((d->scope==imported_scope)) {
        if (!!d->attribs.ax_used) {
            asmstr("\textern ");
            asmstrln(d->name);
        }
        return;
    } else if ((d->scope==exported_scope)) {
        asmstr("\tglobal ");
        asmstrln(d->name);
    }
    align = getalignment(d->mode);
    if (!!d->code) {
        setidataseg(align);
        asmstr(d->name);
        asmchar(':');
        asmline();
        genidata(d->code);
    }
    else {
        setzdataseg(align);
        if (strcmp(d->name,"ch") == 0) {
            asmstr("$ch");
        }
        else {
            asmstr(d->name);
        }
        asmstr(":\tresb ");
        asmint(ttsize[d->mode]);
        asmline();
    }
}

static void dostaticvar_fn	(strec * d) {
int32	align;
    if ((d->scope==imported_scope)) {
        dostaticvar(d);
        return;
    }
    align = getalignment(d->mode);
    if (!!d->code) {
        setidataseg(align);
        if (d->nameid == frameid) {
            asmchar('$');
        }
        asmstr(d->owner->name);
        asmchar('.');
        asmstr(d->name);
        asmchar(':');
        asmline();
        genidata(d->code);
    }
    else {
        setzdataseg(align);
        asmstr(d->owner->name);
        asmchar('.');
        asmstr(d->name);
        asmstr(":\tresb ");
        asmint(ttsize[d->mode]);
        asmline();
    }
}

static void addvarcomment	(strec * d,int32 wasind) {
char *	s;
    if ((uchar)opndcomment1[1-1] == 0) {
        s = (char *)&opndcomment1;
        opndcomment2[1-1] = 0;
    }
    else {
        s = (char *)&opndcomment2;
    }
    sprintf(s,"%.*s %d %c",d->namelen,d->name,d->offset,(wasind?'*':' '));
}

static void addtempcomment	(int32 temp,int32 wasind) {
char *	s;
    if ((uchar)opndcomment1[1-1] == 0) {
        s = (char *)&opndcomment1;
        opndcomment2[1-1] = 0;
    }
    else {
        s = (char *)&opndcomment2;
    }
    sprintf(s,"T%d %c",temp,(wasind?'*':' '));
}

static void asmreg	(int32 reg,int32 size) {
    asmchar((uchar)regnameprefix[size-1]);
    if (reg < r10) {
        asmchar((uchar)regname1[reg-1]);
    }
    else if (reg != rstack) {
        asmchar('1');
        asmchar((uchar)regname1[(reg-r10)+1-1]);
    }
    else {
        asmstr("stack");
    }
}

static void asmxreg	(int32 reg) {
    asmstr("XMM");
    if (reg < xr10) {
        asmchar((uchar)regname1[reg-1]);
    }
    else {
        asmchar('1');
        asmchar((uchar)regname1[(reg-xr10)+1-1]);
    }
}

static void asmxmove	(opndrec * ax) {
    if (ax->size == 4) {
        asmstr("\tmovd\t");
    }
    else {
        asmstr("\tmovq\t");
    }
}

static void asmexch	(int32 reg1,int32 reg2,int32 size) {
    asmstr("\txchg\t");
    asmreg(reg1,size);
    asmchar(',');
    asmreg(reg2,size);
    asmline();
}

static void asmbuffercheck	(int32 n) {
    if (asmend-asmptr < n) {
        expandasmdest();
    }
}

static void genmainprelude	(void) {
    setcodeseg();
    asmstrln("\tsub\tDstack,152");
    asmstrln("\tsub\tDstack,8");
    asmstrln("\tlea\tD0,[Dstack+8]");
    asmstrln("\tpush\tD0");
    asmstrln("\tsub\tDstack,32");
    asmstrln("\tlea\tD0,[Dstack+196]");
    asmstrln("\tmov\t[Dstack],D0");
    asmstrln("\tlea\tD0,[Dstack+184]");
    asmstrln("\tmov\t[Dstack+8],D0");
    asmstrln("\tlea\tD0,[Dstack+176]");
    asmstrln("\tmov\t[Dstack+16],D0");
    asmstrln("\tmov\tA0,0");
    asmstrln("\tmov\t[Dstack+24],A0");
    asmstrln("\tmov\tD10,[Dstack]");
    asmstrln("\tmov\tD11,[Dstack+8]");
    asmstrln("\tmov\tD12,[Dstack+16]");
    asmstrln("\tmov\tD13,[Dstack+24]");
    asmstrln("\textern __getmainargs");
    asmstrln("\tcall\t__getmainargs");
    asmstrln("\tadd\tDstack,48");
    asmstrln("\tsub\tDstack,32");
    asmstrln("\tmov\tA0,[Dstack+180]");
    asmstrln("\tmov\t[Dstack],A0");
    asmstrln("\tmov\tD0,[Dstack+168]");
    asmstrln("\tmov\t[Dstack+8],D0");
    asmstrln("\tmov\tD10,[Dstack]");
    asmstrln("\tmov\tD11,[Dstack+8]");
    asmstrln("\tcall\t.main");
    asmline();
    asmstrln(".main:");
}

static int32 roundoffsetdown_size	(int32 a,int32 size) {
int32	mask;
    if ((size==1)) {
        return a;
    } else if ((size==2) || (size==4) || (size==8)) {
        mask = size-1;
    }
    else {
        mask = 7;
    }
    while (a&mask) {
        --a;
    }
    return a;
}

static void asmopnd	(opndrec * ax) {
byte	doplus;
int32	length;
static int32	maxlen=0;
static int32	newmaxlen=0;
strec *	d;
int32	reg;
int32	offset;
    switch (ax->fmt) {
    case mem_opnd:
    case imem_opnd:
        d = ax->def;
        if (!!doopndsize && ax->size <= 8) {
            asmstr(sizeprefixes[ax->size-1]);
        }
        asmchar('[');
        if ((d->nameid==frameid) || (d->nameid==paramid)) {
            asmstr("Dframe");
            offset = d->offset;
            if (offset >= 0) {
                asmchar('+');
            }
            asmint(offset);
            addvarcomment(d,(int32)(ax->fmt == imem_opnd));
        }
        else {
            if (d->scope == function_scope) {
                asmstr(currproc->name);
                asmchar('.');
            }
            else if (strcmp(d->name,"ch") == 0) {
                asmstr("$ch");
                goto L109;
            }
            asmstr(d->name);
skipname:
L109:;
        }
        asmchar(']');
        break;
    case temp_opnd:
    case itemp_opnd:
        if (!!doopndsize && ax->size <= 8) {
            asmstr(sizeprefixes[ax->size-1]);
        }
        asmstr("[Dframe");
        asmint(tempoffsets[ax->tempno-1]);
        asmchar(']');
        addtempcomment(ax->tempno,(int32)(ax->fmt == itemp_opnd));
        break;
    case int_opnd:
        if (!(ax->value >= -2000000000 && ax->value <= 2000000000)) {
            asmchar('[');
            asmstr("RR");
            asmint(nextrealindex(ax->xvalue,8));
            asmchar(']');
        }
        else {
            asmint(ax->value);
        }
        break;
    case real_opnd:
        asmchar('[');
        asmstr("RR");
        asmint(nextrealindex(ax->xvalue,ax->size));
        asmchar(']');
        break;
    case string_opnd:
        if (ax->svalue == 0) {
            asmchar('0');
            return;
        }
        asmstr("KK");
        asmint(nextstringindex(ax->svalue,ax->slength));
        break;
    case label_opnd:
        asmchar('L');
        asmint(ax->labelno);
        break;
    case memaddr_opnd:
        d = ax->def;
        if ((d->nameid==frameid) || (d->nameid==paramid)) {
            asmstr("Dframe");
            offset = d->offset;
            if (offset >= 0) {
                asmchar('+');
            }
            asmint(offset);
            addvarcomment(d,0);
        }
        else {
            if (d->scope == function_scope) {
                asmstr(currproc->name);
                asmchar('.');
            }
            else if (strcmp(d->name,"ch") == 0) {
                asmstr("$ch");
                goto L115;
            }
            asmstr(d->name);
skipname2:
L115:;
        }
        break;
    case ptr_opnd:
        if (!!doopndsize) {
            asmstr(sizeprefixes[ax->size-1]);
        }
        asmchar('[');
        asmreg(ax->regno,ptrsize);
        asmchar(']');
        break;
    case regvar_opnd:
        asmreg(ax->regno,ax->size);
        break;
    default:;
        printf("%s %s\n","OTHER OPND",opndnames[ax->fmt]);
        gerror("OTHER OPND",0);
        asmstr("<");
        asmstr(opndnames[ax->fmt]);
        asmstr(">");
    }
}

static void pushopnd	(opndrec * ax) {
    if ((ax->size==8)) {
        asmstr("\tpush qword ");
        asmopnd(ax);
        asmln();
    } else if ((ax->size==4)) {
        loadopnd(ax,r13);
        asmstrln("\tpush D13");
    }
    else {
        gerror("push odd size",0);
    }
}

static void loadopnd	(opndrec * ax,int32 reg) {
int32	oldfmt;
    oldfmt = ax->fmt;
    if (oldfmt == memaddr_opnd) {
        asmstr("\tlea ");
        ax->fmt = mem_opnd;
    }
    else if (oldfmt == tempaddr_opnd) {
        asmstr("\tlea ");
        ax->fmt = temp_opnd;
    }
    else {
        if ((ax->fmt==imem_opnd) || (ax->fmt==itemp_opnd)) {
            ax = getlvopnd(ax,r13);
        }
        asmstr("\tmov ");
    }
    asmreg(reg,ax->size);
    asmchar(',');
    asmopnd(ax);
    asmln();
    ax->fmt = oldfmt;
}

static void storeopnd	(opndrec * ax,int32 reg) {
    if ((ax->fmt==itemp_opnd) || (ax->fmt==imem_opnd)) {
        ax = getlvopnd(ax,r13);
    }
    asmstr("\tmov ");
    asmopnd(ax);
    asmchar(',');
    asmreg(reg,ax->size);
    asmln();
}

static void floadopnd	(opndrec * ax,int32 reg) {
    ax = getlvopnd(ax,r13);
    asmstr(((ax->size == 4)?"\tmovd ":"\tmovq "));
    asmxreg(reg);
    asmchar(',');
    asmopnd(ax);
    asmln();
}

static void fstoreopnd	(opndrec * ax,int32 reg) {
    ax = getlvopnd(ax,r13);
    asmstr(((ax->size == 4)?"\tmovd ":"\tmovq "));
    asmopnd(ax);
    asmchar(',');
    asmxreg(reg);
    asmln();
}

static void gloadopnd	(opndrec * ax,int32 reg) {
    if (ax->typecode == float_type) {
        floadopnd(ax,reg);
    }
    else {
        loadopnd(ax,reg);
    }
}

static void gstoreopnd	(opndrec * ax,int32 reg) {
    if ((ax->typecode==float_type)) {
        fstoreopnd(ax,reg);
    } else if ((ax->typecode==block_type)) {
        gerror("STORE BLOCK OPND",0);
    }
    else {
        storeopnd(ax,reg);
    }
}

static void loadaddr	(opndrec * ax,int32 reg) {
int32	oldfmt;
int32	oldsize;
    oldfmt = ax->fmt;
    oldsize = ax->size;
    if ((oldfmt==itemp_opnd)) {
        ax->fmt = temp_opnd;
    } else if ((oldfmt==imem_opnd)) {
        ax->fmt = mem_opnd;
    } else if ((oldfmt==mem_opnd)) {
        ax->fmt = memaddr_opnd;
    } else if ((oldfmt==temp_opnd)) {
        ax->fmt = tempaddr_opnd;
    }
    else {
        printf("%s %s\n","OPNDNAMES^[(AX)^.FMT]=",opndnames[ax->fmt]);
        printf("%s\n",strtclopnd(ax));
        gerror("loadaddr",0);
    }
    ax->size = ptrsize;
    loadopnd(ax,reg);
    ax->fmt = oldfmt;
    ax->size = oldsize;
}

static void domove	(opndrec * a,opndrec * b) {
    if (a->typecode == block_type) {
        doblockmove(a,b);
        return;
    }
    loadopnd(b,r0);
    storeopnd(a,r0);
}

static void doblockmove	(opndrec * a,opndrec * b) {
    docopyblock(a,b);
}

static void doincr	(opndrec * a,int32 isinc) {
    a = getlvopnd(a,r13);
    doopndsize = 1;
    asmstr((isinc?"\tinc ":"\tdec "));
    asmopnd(a);
    asmln();
}

static char * getasmcondcode	(int32 cond,int32 fsigned) {
    if ((cond==j_eq)) {
        return "z";
    } else if ((cond==j_ne)) {
        return "nz";
    }
    else {
        if (fsigned) {
            if ((cond==j_lt)) {
                return "l";
            } else if ((cond==j_le)) {
                return "le";
            } else if ((cond==j_ge)) {
                return "ge";
            } else if ((cond==j_gt)) {
                return "g";
            }
        }
        else {
            if ((cond==j_lt)) {
                return "b";
            } else if ((cond==j_le)) {
                return "be";
            } else if ((cond==j_ge)) {
                return "ae";
            } else if ((cond==j_gt)) {
                return "a";
            }
        }
    }
    return "";
}

static void dojumpcc	(int32 cond,opndrec * a,opndrec * b,opndrec * c) {
int32	t;
    t = b->typecode;
    if (t == float_type && cond != j_eq && cond != j_ne) {
        floadopnd(b,xr0);
        asmstr(((b->size == 4)?"\tcomiss XMM0, ":"\tcomisd XMM0, "));
        asmopnd(c);
        asmln();
    }
    else {
        loadopnd(b,r0);
        asmstr("\tcmp ");
        asmreg(r0,b->size);
        asmchar(',');
        asmopnd(c);
        asmln();
    }
    asmstr("\tj");
    asmstr(getasmcondcode(cond,(int32)(t == signed_type)));
    asmchar(' ');
    asmopnd(a);
    asmln();
}

static void docallproc	(tclrec * m,opndrec * a,opndrec * b) {
int32	i;
int32	argbytes;
    argbytes = 0;
    if (ncallparams > 4 && !!(ncallparams&1)) {
        asmstrln("\tsub Dstack,8");
        argbytes = 8;
    }
    for (i=ncallparams; i>=5; --i) {
        if (!!m->isvariadic && paramlist[i-1]->size == 4 && paramlist[i-1]->typecode == float_type) {
            pushfloatparam(paramlist[i-1]);
        }
        else {
            pushopnd(paramlist[i-1]);
        }
        argbytes += 8;
    }
    argbytes += 32;
    asmstrln("\tsub Dstack,32");
    for (i=1; i<=4; ++i) {
        if (i <= ncallparams) {
            if ((paramlist[i-1]->typecode==float_type)) {
                if (!!m->isvariadic) {
                    if (paramlist[i-1]->size == 4) {
                        loadfloatparam(paramlist[i-1],i-1);
                    }
                    else {
                        floadopnd(paramlist[i-1],xr0+(i-1));
                        loadopnd(paramlist[i-1],r10+(i-1));
                    }
                }
                else {
                    floadopnd(paramlist[i-1],xr0+(i-1));
                }
            } else if ((paramlist[i-1]->typecode==block_type)) {
                gerror("BLOCK PARAM 1..4",0);
            }
            else {
                loadopnd(paramlist[i-1],r10+(i-1));
            }
        }
    }
    if (m->opcode == t_callproc) {
        asmstr("\tcall ");
        asmopnd(a);
        asmln();
    }
    else if (a->typecode == block_type) {
        loadaddr(a,r9);
        asmstr("\tcall ");
        asmopnd(b);
        asmln();
    }
    else {
        asmstr("\tcall ");
        asmopnd(b);
        asmln();
        gstoreopnd(a,r0);
    }
    asmstr("\tadd Dstack, ");
    asmint(argbytes);
    asmline();
    ncallparams = 0;
}

static void doadd	(opndrec * a,opndrec * b,opndrec * c) {
int32	size;
    size = a->size;
    if (a->typecode != float_type) {
        loadopnd(b,r0);
        loadopnd(c,r1);
        asmstr("\tadd ");
        asmreg(r0,size);
        asmchar(',');
        asmreg(r1,size);
        asmln();
        storeopnd(a,r0);
    }
    else {
        dofadd(a,b,c,t_add);
    }
}

static void dosub	(opndrec * a,opndrec * b,opndrec * c) {
int32	size;
    size = a->size;
    if (a->typecode != float_type) {
        loadopnd(b,r0);
        loadopnd(c,r1);
        asmstr("\tsub ");
        asmreg(r0,size);
        asmchar(',');
        asmreg(r1,size);
        asmln();
        storeopnd(a,r0);
    }
    else {
        dofadd(a,b,c,t_sub);
    }
}

static void dofadd	(opndrec * a,opndrec * b,opndrec * c,int32 opcode) {
char *	opcstr;
    floadopnd(b,xr0);
    floadopnd(c,xr1);
    if ((opcode==t_add)) {
        opcstr = "\tadds";
    } else if ((opcode==t_sub)) {
        opcstr = "\tsubs";
    } else if ((opcode==t_mul)) {
        opcstr = "\tmuls";
    } else if ((opcode==t_div)) {
        opcstr = "\tdivs";
    }
    asmstr(opcstr);
    asmstr(((a->size == 4)?"s ":"d "));
    asmxreg(xr0);
    asmchar(',');
    asmxreg(xr1);
    asmln();
    fstoreopnd(a,xr0);
}

static void domul	(opndrec * a,opndrec * b,opndrec * c) {
int32	size;
    size = a->size;
    if (a->typecode != float_type) {
        loadopnd(b,r0);
        loadopnd(c,r1);
        asmstr("\tmul ");
        asmreg(r1,size);
        asmln();
        storeopnd(a,r0);
    }
    else {
        dofadd(a,b,c,t_mul);
    }
}

static void dodiv	(opndrec * a,opndrec * b,opndrec * c,int32 opcode) {
int32	size;
    size = a->size;
    if (a->typecode != float_type) {
        loadopnd(b,r0);
        loadopnd(c,r1);
        if (a->typecode == signed_type) {
            asmstrln(((size == 4)?"\tcdq ":"\tcqo"));
            asmstr("\tidiv ");
        }
        else {
            asmstrln("\txor D11,D11");
            asmstr("\tdiv ");
        }
        asmreg(r1,size);
        asmln();
        if (opcode == t_rem) {
            if (size == 4) {
                asmstrln("\txchg A0,A11");
            }
            else {
                asmstrln("\txchg D0,D11");
            }
        }
        storeopnd(a,r0);
    }
    else {
        dofadd(a,b,c,t_div);
    }
}

static void doiand	(opndrec * a,opndrec * b,opndrec * c,int32 opc) {
int32	size;
    size = a->size;
    loadopnd(b,r0);
    loadopnd(c,r1);
    if ((opc==t_iand)) {
        asmstr("\tand ");
    } else if ((opc==t_ior)) {
        asmstr("\tor ");
    } else if ((opc==t_ixor)) {
        asmstr("\txor ");
    }
    asmreg(r0,size);
    asmchar(',');
    asmreg(r1,size);
    asmln();
    storeopnd(a,r0);
}

static void doshl	(opndrec * a,opndrec * b,opndrec * c,int32 opc) {
int32	size;
    size = a->size;
    loadopnd(b,r0);
    c->size = 1;
    loadopnd(c,r10);
    if ((opc==t_shl)) {
        asmstr("\tshl ");
    } else if ((opc==t_shr)) {
        if (b->typecode == signed_type) {
            asmstr("\tsar ");
        }
        else {
            asmstr("\tshr ");
        }
    }
    asmreg(r0,size);
    asmstr(", cl");
    asmln();
    storeopnd(a,r0);
}

static void doshlto	(opndrec * a,opndrec * b,int32 opc) {
int32	size;
    size = a->size;
    loadopnd(a,r0);
    loadopnd(b,r10);
    if ((opc==t_shlto)) {
        asmstr("\tshl ");
    } else if ((opc==t_shrto)) {
        if (b->typecode == signed_type) {
            asmstr("\tsar ");
        }
        else {
            asmstr("\tshr ");
        }
    }
    asmreg(r0,size);
    asmstrln(", cl");
    storeopnd(a,r0);
}

static void dojumptrue	(opndrec * a,opndrec * b,int32 dojumptrue) {
    loadopnd(b,r0);
    asmstr("\tand ");
    asmreg(r0,b->size);
    asmchar(',');
    asmreg(r0,b->size);
    asmln();
    asmstr((dojumptrue?"\tjnz ":"\tjz "));
    asmopnd(a);
    asmln();
}

static void dogetptr	(opndrec * a,opndrec * b) {
    if (a->typecode == block_type) {
        doblockgetptr(a,b);
        return;
    }
    loadopnd(b,r0);
    asmstr("\tmov ");
    asmreg(r0,a->size);
    asmstr(", [");
    asmreg(r0,b->size);
    asmstrln("]");
    storeopnd(a,r0);
}

static void doblockgetptr	(opndrec * a,opndrec * b) {
    loadaddr(a,r10);
    loadopnd(b,r11);
    domemcpy(a->size);
}

static void dogetaddr	(opndrec * a,opndrec * b) {
    asmstr("\tlea ");
    asmreg(r0,a->size);
    asmchar(',');
    asmopnd(b);
    asmln();
    storeopnd(a,r0);
}

static opndrec * getlvopnd	(opndrec * ax,int32 reg) {
static opndrec	ptr;
int32	oldsize;
    if ((ax->fmt==imem_opnd) || (ax->fmt==itemp_opnd)) {
    }
    else {
        return ax;
    }
    asmstr("\tmov ");
    asmreg(reg,ptrsize);
    asmchar(8236);
    oldsize = ax->size;
    ax->size = ptrsize;
    asmopnd(ax);
    ax->size = oldsize;
    asmln();
    ptr.fmt = ptr_opnd;
    ptr.regno = reg;
    ptr.size = ax->size;
    ptr.typecode = ax->typecode;
    doopndsize = 1;
    return &ptr;
}

static void dowiden	(opndrec * a,opndrec * b) {
int32	asize=a->size;
    if (b->typecode == signed_type) {
        asmstr("\tmovsx ");
    }
    else {
        if (asize == 8) {
            asize = 4;
            if (b->size == 4) {
                asmstr("\tmov ");
            }
            else {
                asmstr("\tmovzx ");
            }
        }
        else {
            asmstr("\tmovzx ");
        }
    }
    asmreg(r0,asize);
    asmchar(',');
    doopndsize = 1;
    asmopnd(b);
    asmln();
    storeopnd(a,r0);
}

static void donarrow	(opndrec * a,opndrec * b) {
    loadopnd(b,r0);
    storeopnd(a,r0);
}

static void dotruncate	(opndrec * a,opndrec * b) {
    loadopnd(b,r0);
    if ((a->size==1)) {
        asmstrln("\tand D0,255");
    } else if ((a->size==2)) {
        asmstrln("\tand D0,65535");
    } else if ((a->size==4)) {
        asmstrln("\tmov A0,A0");
    }
    storeopnd(a,r0);
}

static void docopylist	(opndrec * a) {
strec *	d;
int32	nbytes;
    d = a->def;
    nbytes = a->size;
    asmstrln("\tsub Dstack,32");
    asmstr("\tlea D10,");
    asmopnd(a);
    asmln();
    asmstr("\tmov D11,$");
    asmstr(currproc->name);
    asmchar('.');
    asmstr(d->name);
    asmline();
    asmstr("\tmov D12,");
    asmint(nbytes);
    asmline();
    asmstrln("\textern memcpy");
    asmstrln("\tcall memcpy");
    asmstrln("\tadd Dstack,32");
}

static void doindex	(opndrec * a,opndrec * b,opndrec * c,int32 scale,int32 lv) {
    if (a->typecode == block_type) {
        doblockindex(a,b,c,scale,lv);
        return;
    }
    loadopnd(b,r0);
    loadopnd(c,r1);
    if ((scale==1) || (scale==2) || (scale==4) || (scale==8)) {
    }
    else {
        asmstr("\timul ");
        asmreg(r1,ptrsize);
        asmchar(',');
        asmint(scale);
        asmline();
        scale = 1;
    }
    asmstr((lv?"\tlea ":"\tmov "));
    asmreg(r0,a->size);
    asmstr(", [");
    asmreg(r0,ptrsize);
    asmchar('+');
    asmreg(r1,ptrsize);
    if (scale > 1) {
        asmchar('*');
        asmint(scale);
    }
    if (!!c->offset) {
        asmchar('+');
        asmint(c->offset);
    }
    asmchar(']');
    asmline();
    storeopnd(a,r0);
}

static void doblockindex	(opndrec * a,opndrec * b,opndrec * c,int32 scale,int32 lv) {
    loadopnd(b,r0);
    loadopnd(c,r1);
    if ((scale==1) || (scale==2) || (scale==4) || (scale==8)) {
    }
    else {
        asmstr("\timul ");
        asmreg(r1,ptrsize);
        asmchar(',');
        asmint(scale);
        asmline();
        scale = 1;
    }
    asmstr("\tlea ");
    asmreg(r11,ptrsize);
    asmstr(", [");
    asmreg(r0,ptrsize);
    asmchar('+');
    asmreg(r1,ptrsize);
    if (scale > 1) {
        asmchar('*');
        asmint(scale);
    }
    asmchar(']');
    asmline();
    loadaddr(a,r10);
    domemcpy(a->size);
}

static void dopreincrx	(opndrec * a,opndrec * b,int32 isinc,int32 scale) {
    b = getlvopnd(b,r13);
    doopndsize = 1;
    if (scale <= 1) {
        asmstr((isinc?"\tinc ":"\tdec "));
        asmopnd(b);
    }
    else {
        asmstr((isinc?"\tadd ":"\tsub "));
        asmopnd(b);
        asmchar(',');
        asmint(scale);
    }
    asmln();
    loadopnd(b,r0);
    storeopnd(a,r0);
}

static void dopostincrx	(opndrec * a,opndrec * b,int32 isinc,int32 scale) {
    b = getlvopnd(b,r13);
    loadopnd(b,r0);
    doopndsize = 1;
    if (scale <= 1) {
        asmstr((isinc?"\tinc ":"\tdec "));
        asmopnd(b);
    }
    else {
        asmstr((isinc?"\tadd ":"\tsub "));
        asmopnd(b);
        asmchar(',');
        asmint(scale);
    }
    asmln();
    storeopnd(a,r0);
}

static void dofloat	(opndrec * a,opndrec * b) {
    asmstr(((a->size == 4)?"\tcvtsi2ss XMM0,":"\tcvtsi2sd XMM0,"));
    doopndsize = 1;
    asmopnd(b);
    doopndsize = 0;
    asmln();
    fstoreopnd(a,xr0);
}

static void dofix	(opndrec * a,opndrec * b) {
    floadopnd(b,xr0);
    asmstr(((b->size == 4)?"\tcvtss2si ":"\tcvtsd2si "));
    asmreg(r0,a->size);
    asmstrln(", XMM0");
    storeopnd(a,r0);
}

static void dosoftconv	(opndrec * a,opndrec * b) {
    loadopnd(b,r0);
    storeopnd(a,r0);
}

static void doaddto	(opndrec * a,opndrec * b) {
int32	size;
    size = a->size;
    if (a->typecode != float_type) {
        loadopnd(a,r0);
        loadopnd(b,r1);
        asmstr("\tadd ");
        asmreg(r0,size);
        asmchar(',');
        asmreg(r1,size);
        asmln();
        storeopnd(a,r0);
    }
    else {
        dofaddto(a,b,t_addto);
    }
}

static void dofaddto	(opndrec * a,opndrec * b,int32 opcode) {
char *	opcstr;
    floadopnd(a,xr0);
    floadopnd(b,xr1);
    if ((opcode==t_addto)) {
        opcstr = "\tadds";
    } else if ((opcode==t_subto)) {
        opcstr = "\tsubs";
    } else if ((opcode==t_multo)) {
        opcstr = "\tmuls";
    } else if ((opcode==t_divto)) {
        opcstr = "\tdivs";
    }
    asmstr(opcstr);
    asmstr(((a->size == 4)?"s ":"d "));
    asmxreg(xr0);
    asmchar(',');
    asmxreg(xr1);
    asmln();
    fstoreopnd(a,xr0);
}

static void dosubto	(opndrec * a,opndrec * b) {
int32	size;
    size = a->size;
    if (a->typecode != float_type) {
        loadopnd(a,r0);
        loadopnd(b,r1);
        asmstr("\tsub ");
        asmreg(r0,size);
        asmchar(',');
        asmreg(r1,size);
        asmln();
        storeopnd(a,r0);
    }
    else {
        dofaddto(a,b,t_subto);
    }
}

static void domulto	(opndrec * a,opndrec * b) {
int32	size;
    size = a->size;
    if (a->typecode != float_type) {
        loadopnd(a,r0);
        loadopnd(b,r1);
        asmstr("\tmul ");
        asmreg(r1,size);
        asmln();
        storeopnd(a,r0);
    }
    else {
        dofaddto(a,b,t_multo);
    }
}

static void dodivto	(opndrec * a,opndrec * b,int32 opcode) {
int32	size;
    size = a->size;
    if (a->typecode != float_type) {
        loadopnd(a,r0);
        loadopnd(b,r1);
        if (a->typecode == signed_type) {
            asmstrln(((size == 4)?"\tcdq ":"\tcqo"));
            asmstr("\tidiv ");
        }
        else {
            asmstrln("\txor D11,D11");
            asmstr("\tdiv ");
        }
        asmreg(r1,size);
        asmln();
        if (opcode == t_remto) {
            if (size == 4) {
                asmstrln("\txchg A0,A11");
            }
            else {
                asmstrln("\txchg D0,D11");
            }
        }
        storeopnd(a,r0);
    }
    else {
        dofaddto(a,b,t_divto);
    }
}

static void doiandto	(opndrec * a,opndrec * b,int32 opcode) {
int32	size;
    size = a->size;
    loadopnd(a,r0);
    loadopnd(b,r1);
    if ((opcode==t_iandto)) {
        asmstr("\tand ");
    } else if ((opcode==t_iorto)) {
        asmstr("\tor ");
    } else if ((opcode==t_ixorto)) {
        asmstr("\txor ");
    }
    asmreg(r0,size);
    asmchar(',');
    asmreg(r1,size);
    asmln();
    storeopnd(a,r0);
}

static void doneg	(opndrec * a,opndrec * b) {
    if (a->typecode != float_type) {
        loadopnd(b,r0);
        asmstr("\tneg ");
        asmreg(r0,a->size);
        asmline();
        storeopnd(a,r0);
    }
    else {
        floadopnd(b,xr0);
        asmstrln("\txorpd XMM0,[fchsmask_pd]");
        fstoreopnd(a,xr0);
    }
}

static void doabs	(opndrec * a,opndrec * b) {
    loadopnd(b,r0);
    asmstr("\tcmp ");
    asmreg(r0,a->size);
    asmstrln(", 0");
    asmstr("\tjge L");
    asmint(++labelno);
    asmline();
    asmstr("\tneg ");
    asmreg(r0,a->size);
    asmline();
    asmchar('L');
    asmint(labelno);
    asmstrln(":");
    storeopnd(a,r0);
}

static void doinot	(opndrec * a,opndrec * b) {
    loadopnd(b,r0);
    asmstr("\tnot ");
    asmreg(r0,a->size);
    asmline();
    storeopnd(a,r0);
}

static void docopyblock	(opndrec * a,opndrec * b) {
    loadaddr(a,r10);
    loadaddr(b,r11);
    domemcpy(a->size);
}

static void domemcpy	(int32 size) {
    asmstr("\tmov D12,");
    asmint(size);
    asmline();
    asmstrln("\textern memcpy");
    asmstrln("\tsub Dstack,32");
    asmstrln("\tcall memcpy");
    asmstrln("\tadd Dstack,32");
}

static void doswitchop	(tclrec * m,opndrec * a,opndrec * b,opndrec * c) {
    loadopnd(a,r0);
    asmstr("\tsub A0, ");
    asmint(b->value);
    asmline();
    asmstr("\tcmp A0, ");
    asmint(m->nlabels);
    asmline();
    asmstr("\tjae L");
    asmint(c->labelno);
    asmline();
    asmstr("\tjmp [A0*8+L");
    asmint(m->nexttcl->a.labelno);
    asmstrln("]");
    asmstrln("\talign 8");
}

static void dosetcc	(int32 cond,opndrec * a,opndrec * b,opndrec * c) {
int32	t;
    t = b->typecode;
    if (t == float_type && cond != j_eq && cond != j_ne) {
        floadopnd(b,xr0);
        asmstr(((b->size == 4)?"\tcomiss XMM0, ":"\tcomisd XMM0, "));
        asmopnd(c);
        asmln();
    }
    else {
        loadopnd(b,r0);
        asmstr("\tcmp ");
        asmreg(r0,b->size);
        asmchar(',');
        asmopnd(c);
        asmln();
    }
    asmstr("\tset");
    asmstr(getasmcondcode(cond,(int32)(t == signed_type)));
    asmstrln(" B0");
    asmstrln("\tmovzx A0,B0");
    storeopnd(a,r0);
}

static void pushfloatparam	(opndrec * ax) {
    printf("%s\n","PUSHFLOATPARAM");
    asmstr("\tcvtss2sd XMM15, ");
    asmopnd(ax);
    asmline();
    asmstrln("\tsub Dstack, 8");
    asmstrln("\tmovq [Dstack], XMM15");
}

static void loadfloatparam	(opndrec * ax,int32 regoffset) {
int32	ireg=r10+regoffset;
int32	xreg=xr0+regoffset;
    printf("%s\n","LOADFLOATPARAM");
    asmstr("\tcvtss2sd ");
    asmxreg(xreg);
    asmchar(',');
    asmopnd(ax);
    asmline();
    asmstr("\tmovq ");
    asmreg(ireg,8);
    asmchar(',');
    asmxreg(xreg);
    asmline();
}

static void dofwiden	(opndrec * a,opndrec * b) {
    asmstr("\tcvtss2sd XMM0, ");
    asmopnd(b);
    asmline();
    fstoreopnd(a,xr0);
}

static void dofnarrow	(opndrec * a,opndrec * b) {
    asmstr("\tcvtsd2ss XMM0, ");
    asmopnd(b);
    asmline();
    fstoreopnd(a,xr0);
}

static void saveretvalue	(opndrec * b) {
    loadopnd(txreturn,r10);
    loadaddr(b,r11);
    domemcpy(b->size);
}


// From module: cc_gentcl
int32 codegen_tcl	(int32 n) {
strec *	d;
    if (fverbose) {
        printf("%s\n","Generating TCL code:");
    }
    inittc();
    stmodule = moduletable[n].stmodule;
    d = stmodule->deflist;
    while (d) {
        if (d->nameid == procid && !!d->code) {
            do_procdef(d);
        }
        d = d->nextdef;
    }
    return 1;
}

static void do_stmt	(unitrec * p) {
int32	oldclineno;
int32	value;
int32	i;
unitrec *	a;
unitrec *	b;
opndrec *	rx;
opndrec *	ax;
opndrec *	bx;
opndrec *	lhs;
opndrec *	rhs;
strec *	d;
char	str[256];
    if (p == 0) {
        return;
    }
    oldclineno = clineno;
    clineno = (p->fileno<<24)+p->lineno;
    a = p->a;
    b = p->b;
    gentc(t_stmt);
    switch (p->tag) {
    case j_block:
        while (a) {
            do_stmt(a);
            a = a->nextunit;
        }
        break;
    case j_decl:
        d = p->def;
        a = d->code;
        if (a->tag != j_makelist) {
            if (ttbasetype[d->mode] == tarray && a->tag == j_const) {
                goto L7;
            }
            gentc2(t_move,gen_mem(d,d->mode),do_expr(a,0));
        }
        else {
copyl:
L7:;
            gentc1(t_copylist,gen_mem(d,d->mode));
        }
        break;
    case j_callfn:
        dx_call(p,a,b,0);
        break;
    case j_return:
        do_return(a);
        break;
    case j_assign:
        do_assign(a,b);
        break;
    case j_if:
        do_if(a,b,p->c);
        break;
    case j_for:
        do_for(a,b);
        break;
    case j_while:
        do_while(a,b);
        break;
    case j_dowhile:
        do_dowhile(a,b);
        break;
    case j_goto:
        do_goto(p->def);
        break;
    case j_labelstmt:
        do_labeldef(p->def);
        do_stmt(a);
        break;
    case j_casestmt:
        sprintf((char *)&str,"case %d:",p->index);
        gencomment(pcm_copyheapstring((char *)&str));
        if (sw_ncases == 0) {
            gentc_label(t_label,(*sw_labeltable)[(p->index-sw_lower)+1-1]);
        }
        else {
            value = p->index;
            for (i=1; i<=sw_ncases; ++i) {
                if ((*sw_valuetable)[i-1] == value) {
                    gentc_label(t_label,(*sw_labeltable)[i-1]);
                    goto L11;
                }
            }
            gerror("case: serial switch not found",0);
L11:;
        }
        do_stmt(a);
        break;
    case j_defaultstmt:
        sw_defaultseen = 1;
        gencomment("default:");
        gentc_label(t_label,sw_defaultlabel);
        do_stmt(a);
        break;
    case j_breaksw:
        genjumpl(sw_breaklabel);
        break;
    case j_break:
        genjumpl(breakstack[loopindex-1]);
        break;
    case j_continue:
        genjumpl(continuestack[loopindex-1]);
        break;
    case j_switch:
        do_switch(p,a,b);
        break;
    case j_addto:
        dx_addto(a,b,t_addto,0);
        break;
    case j_subto:
        dx_addto(a,b,t_subto,0);
        break;
    case j_multo:
        dx_addto(a,b,t_multo,0);
        break;
    case j_divto:
        dx_addto(a,b,t_divto,0);
        break;
    case j_remto:
        dx_addto(a,b,t_remto,0);
        break;
    case j_iandto:
        dx_addto(a,b,t_iandto,0);
        break;
    case j_iorto:
        dx_addto(a,b,t_iorto,0);
        break;
    case j_ixorto:
        dx_addto(a,b,t_ixorto,0);
        break;
    case j_shlto:
        dx_addto(a,b,t_shlto,0);
        break;
    case j_shrto:
        dx_addto(a,b,t_shrto,0);
        break;
    case j_preincr:
    case j_postincr:
        do_incr(a,t_incrto,t_addto);
        break;
    case j_predecr:
    case j_postdecr:
        do_incr(a,t_decrto,t_subto);
        break;
    case j_null:
        gerror("stmt/null",0);
        break;
    case j_exprlist:
        while (a && !!(b = a->nextunit)) {
            do_stmt(a);
            a = b;
        }
        do_stmt(a);
        break;
    default:;
        loneexpr(p);
    }
    clineno = oldclineno;
}

static opndrec * do_expr	(unitrec * p,opndrec * dest) {
int32	oldclineno;
int32	value;
int32	i;
int32	m;
unitrec *	a;
unitrec *	b;
opndrec *	rx;
opndrec *	ax;
opndrec *	bx;
opndrec *	lhs;
opndrec *	rhs;
opndrec *	tx;
char	str[256];
strec *	d;
    if (p == 0) {
        return 0;
    }
    oldclineno = clineno;
    clineno = (p->fileno<<24)+p->lineno;
    a = p->a;
    b = p->b;
    m = p->mode;
    switch (p->tag) {
    case j_const:
        tx = dx_const(p);
        break;
    case j_name:
        d = p->def;
        if (d->nameid == paramid && !!isstructunion(m)) {
            tx = gen_temp(p->mode);
            gentc2(t_getptr,tx,gen_mem(d,tref));
        }
        else {
            tx = gen_mem(d,m);
        }
        break;
    case j_nameaddr:
        d = p->def;
        if (d->nameid == paramid && !!isstructunion(tttarget[m])) {
            tx = gen_mem(d,tref);
        }
        else {
            gentc2(t_getaddr,tx = gen_dest(dest,tintptr),gen_mem(d,0));
        }
        break;
    case j_widenmem:
        tx = dx_widen(a,m,dest);
        break;
    case j_funcname:
        tx = gen_addr(p->def);
        break;
    case j_assign:
        tx = dx_assign(a,b);
        break;
    case j_andl:
    case j_orl:
        tx = dx_andorl(p);
        break;
    case j_notl:
        tx = dx_andorl(p);
        break;
    case j_exprlist:
        while (a && !!(b = a->nextunit)) {
            ax = do_expr(a,0);
            a = b;
        }
        tx = do_expr(a,0);
        break;
    case j_callfn:
        tx = dx_call(p,a,b,1);
        break;
    case j_ifx:
        tx = dx_ifx(a,b,p->c);
        break;
    case j_eq:
    case j_ne:
    case j_lt:
    case j_le:
    case j_ge:
    case j_gt:
        tx = dx_eq(a,b,p->tag);
        break;
    case j_add:
        if (!!ttisref[a->mode] && ttsize[b->mode] <= 4) {
            b->mode = tintptr;
        }
        tx = dx_add(a,b,t_add,dest);
        break;
    case j_sub:
        tx = dx_add(a,b,t_sub,dest);
        tx->typecode = gettypecode(p->mode);
        break;
    case j_mul:
        tx = dx_add(a,b,t_mul,dest);
        break;
    case j_div:
        tx = dx_add(a,b,t_div,dest);
        break;
    case j_rem:
        tx = dx_add(a,b,t_rem,dest);
        break;
    case j_iand:
        tx = dx_add(a,b,t_iand,dest);
        break;
    case j_ior:
        tx = dx_add(a,b,t_ior,dest);
        break;
    case j_ixor:
        tx = dx_add(a,b,t_ixor,dest);
        break;
    case j_shl:
        tx = dx_add(a,b,t_shl,dest);
        break;
    case j_shr:
        tx = dx_add(a,b,t_shr,dest);
        break;
    case j_deref:
        tx = dx_deref(p,a);
        break;
    case j_derefoffset:
    case j_addoffset:
        tx = dx_derefoffset(p,a,b,p->c,0,dest);
        break;
    case j_convert:
        if (m == tvoid) {
            tx = do_expr(a,dest);
        }
        else {
            tx = dx_convert(a,m,p->opcode);
        }
        break;
    case j_scale:
        ax = do_expr(a,0);
        if (p->scale >= 0) {
            gentc3(t_mul,tx = gen_tempax(ax),ax,gen_int(p->scale,ptrsize));
        }
        else {
            gentc3(t_div,tx = gen_tempax(ax),ax,gen_int(-p->scale,ptrsize));
        }
        break;
    case j_neg:
        tx = dx_neg(a,t_neg);
        break;
    case j_abs:
        tx = dx_neg(a,t_abs);
        break;
    case j_inot:
        tx = dx_neg(a,t_inot);
        break;
    case j_preincr:
        tx = dx_preincr(a,t_preincrx);
        break;
    case j_predecr:
        tx = dx_preincr(a,t_predecrx);
        break;
    case j_postincr:
        tx = dx_preincr(a,t_postincrx);
        break;
    case j_postdecr:
        tx = dx_preincr(a,t_postdecrx);
        break;
    case j_addto:
        tx = dx_addto(a,b,t_addto,1);
        break;
    case j_subto:
        tx = dx_addto(a,b,t_subto,1);
        break;
    case j_multo:
        tx = dx_addto(a,b,t_multo,1);
        break;
    case j_divto:
        tx = dx_addto(a,b,t_divto,1);
        break;
    case j_remto:
        tx = dx_addto(a,b,t_remto,1);
        break;
    case j_iandto:
        tx = dx_addto(a,b,t_iandto,1);
        break;
    case j_iorto:
        tx = dx_addto(a,b,t_iorto,1);
        break;
    case j_ixorto:
        tx = dx_addto(a,b,t_ixorto,1);
        break;
    case j_shlto:
        tx = dx_addto(a,b,t_shlto,1);
        break;
    case j_shrto:
        tx = dx_addto(a,b,t_shrto,1);
        break;
    default:;
        gerror_s("DO-EXPR: can't do tag: %s",jtagnames[p->tag],0);
    }
    if (dest && tx != dest) {
        gentc2(t_move,dest,tx);
    }
    clineno = oldclineno;
    return tx;
}

static opndrec * do_exprlv	(unitrec * p,opndrec * dest) {
int32	oldclineno;
int32	value;
int32	i;
int32	m;
unitrec *	a;
unitrec *	b;
opndrec *	rx;
opndrec *	ax;
opndrec *	bx;
opndrec *	lhs;
opndrec *	rhs;
opndrec *	tx;
char	str[256];
strec *	d;
    if (p == 0) {
        return 0;
    }
    oldclineno = clineno;
    clineno = (p->fileno<<24)+p->lineno;
    a = p->a;
    b = p->b;
    m = p->mode;
    switch (p->tag) {
    case j_name:
        tx = gen_mem(p->def,m);
        break;
    case j_deref:
        tx = dx_dereflv(p,a);
        break;
    case j_derefoffset:
        tx = dx_derefoffset(p,a,b,p->c,1,0);
        break;
    default:;
        gerror_s("DO-EXPRLV: can't do tag: %s",jtagnames[p->tag],0);
    }
    if (dest && tx != dest) {
        gentc2(t_move,dest,tx);
    }
    clineno = oldclineno;
    return tx;
}

static void loneexpr	(unitrec * p) {
    if (p && p->tag != j_null) {
        gentc1(t_eval,do_expr(p,0));
    }
}

static opndrec * dx_const	(unitrec * p) {
opndrec *	ax;
int32	t;
    if ((t = ttbasetype[p->mode]) >= tfirstint && t <= tlastint) {
        return gen_int(p->value,ttsize[p->mode]);
    }
    else if (t >= tfirstreal && t <= tlastreal) {
        ax = gen_real(p->xvalue,ttsize[p->mode]);
        return ax;
    }
    else if (t == tref) {
        if (!!p->isstrconst) {
            return gen_string(p->svalue,p->slength);
        }
        return gen_int(p->value,8);
    }
    gerror_s("dxconst %s",Strmode(p->mode,1),0);
    return 0;
}

static void do_assign	(unitrec * a,unitrec * b) {
opndrec *	ax;
opndrec *	bx;
    ax = do_exprlv(a,0);
    if (b->tag == j_widenmem && ax->size < ttsize[b->mode]) {
        b = b->a;
    }
    if (ax->fmt == mem_opnd) {
        do_expr(b,ax);
    }
    else {
        bx = do_expr(b,0);
        gentc2(t_move,ax,bx);
    }
}

static opndrec * dx_assign	(unitrec * a,unitrec * b) {
opndrec *	lhs;
opndrec *	rhs;
    lhs = do_exprlv(a,0);
    do_expr(b,lhs);
    return lhs;
}

static void do_labeldef	(strec * d) {
    gentc_label(t_label,d->index);
    tccodex->b.def = d;
}

static void do_goto	(strec * d) {
    if (d->index == 0) {
        gerror_s("Label not defined: %s",d->name,0);
    }
    gentc_label(t_jump,d->index);
}

static void do_if	(unitrec * a,unitrec * b,unitrec * c) {
int32	lab1;
int32	lab2;
    lab1 = createfwdlabel();
    genjumpcond(kjumpf,a,lab1);
    do_stmt(b);
    if (c) {
        lab2 = createfwdlabel();
        genjumpl(lab2);
        definefwdlabel(lab1);
        do_stmt(c);
        definefwdlabel(lab2);
    }
    else {
        definefwdlabel(lab1);
    }
}

static int32 definelabel	(void) {
    gentc_label(t_label,++labelno);
    return labelno;
}

int32 createfwdlabel	(void) {
    return ++labelno;
}

void definefwdlabel	(int32 lab) {
    gentc_label(t_label,lab);
}

static void genjumpl	(int32 lab) {
    gentc_label(t_jump,lab);
}

static void genjumpcond	(int32 opc,unitrec * p,int32 lab) {
unitrec *	q;
unitrec *	r;
int32	lab2;
opndrec *	ax;
    q = p->a;
    r = p->b;
    switch (p->tag) {
    case j_andl:
        if ((opc==kjumpf)) {
            genjumpcond(kjumpf,q,lab);
            genjumpcond(kjumpf,r,lab);
        } else if ((opc==kjumpt)) {
            lab2 = createfwdlabel();
            genjumpcond(kjumpf,q,lab2);
            genjumpcond(kjumpt,r,lab);
            definefwdlabel(lab2);
        }
        break;
    case j_orl:
        if ((opc==kjumpf)) {
            lab2 = createfwdlabel();
            genjumpcond(kjumpt,q,lab2);
            genjumpcond(kjumpf,r,lab);
            definefwdlabel(lab2);
        } else if ((opc==kjumpt)) {
            genjumpcond(kjumpt,q,lab);
            genjumpcond(kjumpt,r,lab);
        }
        break;
    case j_notl:
        if ((opc==kjumpf)) {
            genjumpcond(kjumpt,q,lab);
        } else if ((opc==kjumpt)) {
            genjumpcond(kjumpf,q,lab);
        }
        break;
    case j_istruel:
        genjumpcond(opc,q,lab);
        break;
    case j_eq:
    case j_ne:
    case j_lt:
    case j_le:
    case j_ge:
    case j_gt:
        gcomparejump(opc,p,q,r,lab);
        break;
    case j_exprlist:
        while (q->nextunit) {
            do_stmt(q);
            q = q->nextunit;
        }
        genjumpcond(opc,q,lab);
        break;
    default:;
        ax = do_expr(p,0);
        gentc_label(((opc == kjumpt)?t_jumptrue:t_jumpfalse),lab);
        tccodex->b = *ax;
    }
}

static void gcomparejump	(int32 jumpopc,unitrec * p,unitrec * lhs,unitrec * rhs,int32 lab) {
int32	cond;
int32	mclcond;
opndrec *	ax;
opndrec *	bx;
    cond = p->tag;
    if (jumpopc == kjumpf) {
        cond = reversecond(cond);
    }
    ax = do_expr(lhs,0);
    bx = do_expr(rhs,0);
    gentc_label(t_jumpcc,lab);
    tccodex->cond = cond;
    tccodex->b = *ax;
    tccodex->c = *bx;
}

static int32 reversecond	(int32 op) {
    if ((op==j_eq)) {
        return j_ne;
    } else if ((op==j_ne)) {
        return j_eq;
    } else if ((op==j_lt)) {
        return j_ge;
    } else if ((op==j_le)) {
        return j_gt;
    } else if ((op==j_ge)) {
        return j_lt;
    } else if ((op==j_gt)) {
        return j_le;
    }
    return 0;
}

static void stacklooplabels	(int32 a,int32 b) {
    continuestack[++loopindex-1] = a;
    breakstack[loopindex-1] = b;
}

static void do_while	(unitrec * pcond,unitrec * pbody) {
int32	lab_b;
int32	lab_c;
int32	lab_d;
    lab_c = createfwdlabel();
    lab_d = createfwdlabel();
    stacklooplabels(lab_c,lab_d);
    genjumpl(lab_c);
    lab_b = definelabel();
    do_stmt(pbody);
    definefwdlabel(lab_c);
    genjumpcond(kjumpt,pcond,lab_b);
    definefwdlabel(lab_d);
    --loopindex;
}

static void do_dowhile	(unitrec * pbody,unitrec * pcond) {
int32	lab_b;
int32	lab_c;
int32	lab_d;
    lab_c = createfwdlabel();
    lab_d = createfwdlabel();
    stacklooplabels(lab_c,lab_d);
    lab_b = definelabel();
    do_stmt(pbody);
    definefwdlabel(lab_c);
    genjumpcond(kjumpt,pcond,lab_b);
    definefwdlabel(lab_d);
    --loopindex;
}

static void do_for	(unitrec * pinit,unitrec * pbody) {
unitrec *	pcond;
unitrec *	pincr;
int32	lab_b;
int32	lab_c;
int32	lab_d;
int32	lab_cond;
    pcond = pinit->nextunit;
    pincr = pcond->nextunit;
    lab_c = createfwdlabel();
    lab_d = createfwdlabel();
    lab_cond = createfwdlabel();
    if (pinit->tag != j_null) {
        do_stmt(pinit);
    }
    genjumpl(lab_cond);
    stacklooplabels(lab_c,lab_d);
    lab_b = definelabel();
    do_stmt(pbody);
    definefwdlabel(lab_c);
    do_stmt(pincr);
    definefwdlabel(lab_cond);
    if (pcond->tag != j_null) {
        genjumpcond(kjumpt,pcond,lab_b);
    }
    else {
        genjumpl(lab_b);
    }
    definefwdlabel(lab_d);
    --loopindex;
}

static void do_incr	(unitrec * p,int32 incropc,int32 addopc) {
opndrec *	ptropnd;
int32	m;
int32	size;
    ptropnd = do_exprlv(p,0);
    m = p->mode;
    if (!!ttisref[m] && (size = ttsize[tttarget[m]]) != 1) {
        gentc2(addopc,ptropnd,gen_int(size,4));
    }
    else {
        gentc1(incropc,ptropnd);
    }
}

static opndrec * dx_preincr	(unitrec * p,int32 incropc) {
opndrec *	ptropnd;
opndrec *	tx;
int32	m;
int32	size;
    ptropnd = do_exprlv(p,0);
    m = p->mode;
    tx = gen_temp(m);
    gentc2(incropc,tx,ptropnd);
    if (!!ttisref[m] && (size = ttsize[tttarget[m]]) != 1) {
        tccodex->scale = size;
    }
    return tx;
}

static void do_return	(unitrec * a) {
opndrec *	ax;
    if (a) {
        ax = do_expr(a,0);
        gentc_label(t_returnx,retindex);
        tccodex->b = *ax;
    }
    else {
        gentc_label(t_return,retindex);
    }
}

static opndrec * dx_neg	(unitrec * a,int32 opc) {
opndrec *	ax;
opndrec *	tx;
    ax = do_expr(a,0);
    gentc2(opc,tx = gen_tempax(ax),ax);
    return tx;
}

static opndrec * dx_add	(unitrec * a,unitrec * b,int32 opc,opndrec * dest) {
opndrec *	ax;
opndrec *	bx;
opndrec *	tx;
    ax = do_expr(a,0);
    bx = do_expr(b,0);
    gentc3(opc,tx = gen_destax(dest,ax),ax,bx);
    return tx;
}

static opndrec * dx_convert	(unitrec * a,int32 t,int32 opc) {
opndrec *	ax;
opndrec *	tx;
int32	ssize;
int32	tsize;
    ssize = ttsize[a->mode];
    tsize = ttsize[t];
    tx = gen_temp(t);
    ax = do_expr(a,0);
    if ((opc==soft_c)) {
dosoft:
L38:;
        gentc2(t_softconv,tx,ax);
        return tx;
    } else if ((opc==hard_c)) {
        if (tsize < ssize) {
            gentc2(t_narrow,tx,ax);
        }
        else if (tsize > ssize) {
            gentc2(t_widen,tx,ax);
        }
        else {
            return ax;
        }
    } else if ((opc==swiden_c) || (opc==uwiden_c)) {
        if (ssize == tsize) {
            goto L38;
        }
        if (ax->fmt == int_opnd) {
            ax->size = tx->size;
            tx = ax;
        }
        else {
            gentc2(t_widen,tx,ax);
        }
    } else if ((opc==sfloat_c) || (opc==ufloat_c)) {
        gentc2(t_float,tx,ax);
    } else if ((opc==sfix_c) || (opc==ufix_c)) {
        gentc2(t_fix,tx,ax);
    } else if ((opc==fnarrow_c) || (opc==fwiden_c)) {
        gentc2(((opc == fnarrow_c)?t_fnarrow:t_fwiden),tx,ax);
    } else if ((opc==narrow_c)) {
        gentc2(t_narrow,tx,ax);
    } else if ((opc==truncate_c)) {
        gentc2(t_truncate,tx,ax);
    }
    else {
        gerror_s("Convert op not implem: %s",convnames[opc],0);
    }
    return tx;
}

static opndrec * dx_andorl	(unitrec * p) {
int32	lab1;
int32	lab2;
opndrec *	tx;
    lab1 = createfwdlabel();
    genjumpcond(kjumpf,p,lab1);
    tx = gen_temp(tsint);
    lab2 = createfwdlabel();
    gentc2(t_move,tx,gen_int(1,4));
    genjumpl(lab2);
    definefwdlabel(lab1);
    gentc2(t_move,tx,gen_int(0,4));
    definefwdlabel(lab2);
    return tx;
}

static opndrec * getindex	(unitrec * a,int32 * scale) {
opndrec *	ax;
opndrec *	tx;
    if (a->tag != j_scale) {
        ax = do_expr(a,0);
        *scale = 1;
        return ax;
    }
    ax = do_expr(a->a,0);
    if ((a->scale==2) || (a->scale==4) || (a->scale==8)) {
        *scale = a->scale;
        return ax;
    }
    else {
        *scale = 1;
        gentc3(t_mul,tx = gen_tempax(ax),ax,gen_int(a->scale,4));
    }
    return tx;
}

static opndrec * dx_deref	(unitrec * p,unitrec * a) {
opndrec *	ax;
opndrec *	bx;
opndrec *	ix;
opndrec *	tx;
int32	elemsize;
int32	scale;
int32	m;
int32	memtype;
    tx = gen_temp(p->mode);
    gentc2(t_getptr,tx,do_expr(a,0));
    return tx;
}

static opndrec * dx_dereflv	(unitrec * p,unitrec * a) {
opndrec *	ax;
opndrec *	bx;
opndrec *	ix;
opndrec *	tx;
int32	elemsize;
int32	scale;
int32	m;
int32	memtype;
    if (a->tag == j_name) {
        return makeindirect(do_expr(a,0),p->mode);
    }
    tx = gen_temp(a->mode);
    gentc2(t_move,tx,do_expr(a,0));
    return makeindirect(tx,p->mode);
}

static void do_switch	(unitrec * p,unitrec * a,unitrec * b) {
int32	labeltable[500];
int32	valuetable[500];
byte	flags[500];
int32	defaultlabel;
int32	breakswlabel;
int32	switchlabel;
int32	lower;
int32	upper;
int32	length;
int32	value;
int32	ncases;
byte	serialsw;
int32	i;
int32	index;
caserec *	pcase;
opndrec *	ax;
opndrec *	bx;
int32 (*old_labeltable)[];
int32 (*old_valuetable)[];
int32	old_ncases;
int32	old_lower;
byte	old_defaultseen;
int32	old_defaultlabel;
int32	old_breaklabel;
    pcase = p->nextcase;
    ncases = length = 0;
    while (pcase) {
        ++ncases;
        if (ncases > maxcases) {
            gerror("Too many cases on one switch",0);
        }
        valuetable[ncases-1] = value = pcase->value;
        if (ncases == 1) {
            lower = upper = value;
        }
        else {
            lower = (lower<value?lower:value);
            upper = (upper>value?upper:value);
        }
        pcase = pcase->nextcase;
    }
    length = (upper-lower)+1;
    defaultlabel = createfwdlabel();
    breakswlabel = createfwdlabel();
    if (length > maxswitchrange) {
        serialsw = 1;
        ax = do_expr(a,0);
        for (i=1; i<=ncases; ++i) {
            labeltable[i-1] = createfwdlabel();
            gentc_label(t_jumpcc,labeltable[i-1]);
            tccodex->cond = j_eq;
            tccodex->b = *ax;
            tccodex->c = *gen_int(valuetable[i-1],4);
        }
        gentc_label(t_jump,defaultlabel);
    }
    else {
        serialsw = 0;
        memset((int32 *)&flags,0,length);
        for (i=1; i<=length; ++i) {
            labeltable[i-1] = defaultlabel;
        }
        for (i=1; i<=ncases; ++i) {
            value = valuetable[i-1];
            index = (value-lower)+1;
            labeltable[index-1] = createfwdlabel();
            if (!!flags[index-1]) {
                gerror_s("Dupl case value: %d",(char *)(void *)(int64)value,0);
            }
            flags[index-1] = 1;
        }
        switchlabel = createfwdlabel();
        ax = do_expr(a,0);
        gentc3(t_switch,ax,gen_int(lower,4),gen_label(defaultlabel));
        tccodex->nlabels = length;
        definefwdlabel(switchlabel);
        for (i=1; i<=length; ++i) {
            gentc_label(t_jumplabel,labeltable[i-1]);
            tccodex->index = i;
        }
    }
    old_labeltable = sw_labeltable;
    old_valuetable = sw_valuetable;
    old_lower = sw_lower;
    old_ncases = sw_ncases;
    old_defaultseen = sw_defaultseen;
    old_defaultlabel = sw_defaultlabel;
    old_breaklabel = sw_breaklabel;
    sw_labeltable = (int32 (*)[])&labeltable;
    sw_valuetable = (int32 (*)[])&valuetable;
    sw_lower = lower;
    sw_ncases = (!!serialsw?ncases:0);
    sw_defaultseen = 0;
    sw_defaultlabel = defaultlabel;
    sw_breaklabel = breakswlabel;
    do_stmt(b);
    if (!sw_defaultseen) {
        definefwdlabel(defaultlabel);
    }
    definefwdlabel(breakswlabel);
    sw_labeltable = old_labeltable;
    sw_valuetable = old_valuetable;
    sw_lower = old_lower;
    sw_ncases = old_ncases;
    sw_defaultseen = old_defaultseen;
    sw_defaultlabel = old_defaultlabel;
    sw_breaklabel = old_breaklabel;
}

static opndrec * dx_addto	(unitrec * a,unitrec * b,int32 opc,int32 isexpr) {
opndrec *	ax;
    gentc2(opc,ax = do_exprlv(a,0),do_expr(b,0));
    if (isexpr) {
        return fixopnd(ax);
    }
    return 0;
}

static opndrec * dx_call	(unitrec * p,unitrec * a,unitrec * b,int32 isfn) {
opndrec *	rx;
opndrec *	fx;
opndrec *	tx;
paramrec *	pm;
int32	i;
int32	n;
int32	retmode;
int32	oldslotno;
int32	offsetx;
byte	dummyparam;
byte	isfnptr;
byte	allsimple;
byte	variadic;
unitrec *	paramlist[100];
opndrec *	arglist[100];
unitrec *	q;
    retmode = p->mode;
    if (retmode == tvoid) {
        retmode = tsint;
    }
    if (a->tag == j_nameaddr) {
        pm = a->def->paramlist;
        isfnptr = 0;
    }
    else {
        pm = ttparams[tttarget[a->mode]];
        isfnptr = 1;
    }
    variadic = (uint32)(pm->flags == pm_variadic);
    q = b;
    n = 0;
    while (q) {
        paramlist[++n-1] = q;
        rx = arglist[n-1] = do_expr(q,0);
        if (rx->typecode == block_type) {
            tx = gen_temp(tref);
            if ((rx->fmt==mem_opnd) || (rx->fmt==temp_opnd)) {
                gentc2(t_getaddr,tx,rx);
            }
            else {
                gerror("call/block param?",0);
            }
            arglist[n-1] = tx;
        }
        q = q->nextunit;
    }
    if (a->tag == j_nameaddr) {
        fx = gen_addr(a->def);
    }
    else {
        fx = do_expr(a,0);
    }
    for (i=1; i<=n; ++i) {
        gentc1(t_param,arglist[i-1]);
        tccodex->paramno = i;
    }
    if (isfn) {
        rx = gen_temp(retmode);
        gentc2(t_callfn,rx,fx);
        tccodex->isvariadic = variadic;
        return rx;
    }
    else {
        gentc1(t_callproc,fx);
        tccodex->isvariadic = variadic;
        return 0;
    }
}

static opndrec * dx_ifx	(unitrec * a,unitrec * b,unitrec * c) {
opndrec *	ax;
opndrec *	bx;
opndrec *	cx;
opndrec *	tx;
int32	lab1;
int32	lab2;
    lab1 = createfwdlabel();
    lab2 = createfwdlabel();
    if (b->mode != tvoid) {
        tx = gen_temp(b->mode);
    }
    else {
        tx = gen_temp(tsint);
    }
    genjumpcond(kjumpf,a,lab1);
    bx = do_expr(b,tx);
    genjumpl(lab2);
    definefwdlabel(lab1);
    cx = do_expr(c,tx);
    definefwdlabel(lab2);
    return tx;
}

static opndrec * dx_eq	(unitrec * a,unitrec * b,int32 cond) {
opndrec *	ax;
opndrec *	bx;
opndrec *	cx;
    ax = do_expr(a,0);
    bx = do_expr(b,0);
    gentc3(t_setcc,cx = gen_temp(tsint),ax,bx);
    tccodex->cond = cond;
    return cx;
}

static void do_procdef	(strec * p) {
int32	i;
int32	nparams;
int32	nextframeoffset;
int32	nextparamoffset;
int32	framebytes;
strec *	d;
opndrec *	tx;
    currproc = p;
    settcdest(1);
    inittccode();
    loopindex = 0;
    nparams = 0;
    d = p->deflist;
    retindex = createfwdlabel();
    if ((ttbasetype[p->mode]==tstruct) || (ttbasetype[p->mode]==tunion)) {
        tx = gen_temp(tref);
        gentc1(t_setret,tx);
    }
    do_stmt(p->code);
    if (p->mode != tvoid) {
        if (!checkblockreturn(p->code)) {
            if (strcmp(p->name,"main") == 0) {
                gentc_label(t_returnx,retindex);
                tccodex->b = *gen_int(0,4);
            }
        }
    }
    definefwdlabel(retindex);
    gentc(t_hardret);
    tccode->ntemps = currtempno;
    tccode->a.tempsizes = (byte (*)[])pcm_alloc(currtempno);
    tccode->b.temptypes = (byte (*)[])pcm_alloc(currtempno);
    memcpy((int32 *)tccode->a.temptypes,(int32 *)&opndtypes,currtempno);
    memcpy((int32 *)tccode->b.tempsizes,(int32 *)&opndsizes,currtempno);
    p->tclcode = tccode;
}

static opndrec * dx_derefoffset	(unitrec * p,unitrec * a,unitrec * b,unitrec * c,int32 lv,opndrec * dest) {
opndrec *	ax;
opndrec *	bx;
opndrec *	ix;
opndrec *	tx;
opndrec *	tx2;
int32	elemsize;
int32	m;
int32	memtype;
int32	scale;
int32	offset;
int32	opcode;
int32	opc;
    opcode = p->tag;
    scale = p->ptrscale;
    if (scale == 0) {
        scale = 1;
    }
    offset = (c?(c->value):0);
    tx = gen_dest(dest,((opcode == j_addoffset || lv)?tintptr:(p)->mode));
    if (a->tag == j_nameaddr && !isstructunion(a->def->mode)) {
        ax = gen_addr(a->def);
    }
    else {
        ax = do_expr(a,0);
    }
    ix = do_expr(b,0);
    if (scale > 255 || offset < -32768 || offset > 32767) {
        if (scale > 1) {
            tx2 = gen_temp(tintptr);
            gentc3(t_mul,tx2,ix,gen_int(scale,ptrsize));
            ix = tx2;
            scale = 1;
        }
        if (offset) {
            tx2 = gen_temp(tintptr);
            gentc3(t_add,tx2,ix,gen_int(offset,ptrsize));
            ix = tx2;
            offset = 0;
        }
    }
    if (lv) {
        opc = t_indexlv;
    }
    else if (opcode == j_derefoffset) {
        opc = t_index;
    }
    else {
        opc = t_indexref;
    }
    gentc3(opc,tx,ax,ix);
    tccodex->scale = scale;
    tccodex->c.offset = offset;
    if (lv) {
        return makeindirect(tx,p->mode);
    }
    return tx;
}

static opndrec * dx_widen	(unitrec * a,int32 m,opndrec * dest) {
opndrec *	ax;
opndrec *	tx;
    dest = 0;
    ax = do_expr(a,0);
    if (ttsize[m] == ax->size) {
        return ax;
    }
    gentc2(t_widen,tx = gen_dest(dest,m),ax);
    return tx;
}

static int32 isstructunion	(int32 m) {
    if ((ttbasetype[m]==tstruct) || (ttbasetype[m]==tunion)) {
        return 1;
    }
    return 0;
}


// From module: cc_start
void start	(void) {
int32	s;
int32	t;
int32	stopcode;
char *	file;
void *	f;
    starttiming();
    initdata();
    getinputoptions();
    showcaption();
    if (!!fshowoptions) {
        showoptions();
    }
    if (!!fwriteheaders) {
        writeheaders();
        exit(0);
    }
    if (!fverbose && !fquiet) {
        printf("%s %s %s %s\n","Compiling",inputfiles[1],"to",outfile);
    }
    initsearchdirs();
    initlogfile();
    if (!!fshowpaths) {
        showsearchdirs();
    }
    if (!!(passes&mload)) {
        do_loadmodules();
    }
    if (!!(passes&mpreprocess)) {
        do_preprocess();
    }
    if (!!(passes&mparse)) {
        do_parsemodules();
    }
    if (!!(passes&mgen1)) {
        do_gen1();
    }
    if (!!(passes&mgen2)) {
        do_gen2();
    }
    if (!!(passes&mlink)) {
        do_linkmodules();
    }
    progend = os_clock();
    if (!!(passes&mrun)) {
        do_runprog();
    }
    showoutput();
    if (!!fshowlog) {
        closelogfile();
    }
    if (fverbose) {
        printf("%s\n","Finished.");
    }
    stopcode = 0;
    exit(stopcode);
}

static void showoutput	(void) {
    if (!!fshowmodules) {
        showmodules();
    }
    if (!!fshowfiles) {
        showfiles();
    }
    if (!!fshowast) {
        showast(1);
    }
    if (!!fshowst) {
        showsttree("ST",1);
    }
    if (!!fshowstflat) {
        showstflat("FST");
    }
    if (!!fshowtypes) {
        printmodelist(logdev);
    }
    if (!!fshowtcl) {
        showtcl("TCL",1);
    }
    if (!!fshowasm) {
        showasm(1);
    }
    if (!!fshowtiming) {
        showtiming();
    }
}

static void do_loadmodules	(void) {
    if ((ninputfiles==0)) {
        loaderror("No sourcefile specified","");
    } else if ((ninputfiles==1)) {
    }
    else {
        loaderror("Can only compile a file at a time for now","");
    }
    if (nlibfiles) {
        loaderror("Can't yet use lib files","");
    }
    if (fverbose) {
        printf("%s %s\n","Loading:",inputfiles[1]);
    }
    loadstart = os_clock();
    loadstatus = loadmainmodule(inputfiles[1]);
    loadend = os_clock();
}

static void do_preprocess	(void) {
    if (!loadstatus) {
        return;
    }
    lex_preprocess_only(inputfiles[1],fshowtokens);
}

static void do_parsemodules	(void) {
    if (!loadstatus) {
        return;
    }
    if (fverbose) {
        printf("%s\n","Parsing:");
    }
    parsestart = os_clock();
    parsestatus = parsemodule(1);
    parseend = os_clock();
}

static int32 do_linkmodules	(void) {
    return 0;
}

static void do_gen1	(void) {
    if (!parsestatus) {
        return;
    }
    gen1start = os_clock();
    if ((gen1target==4997972)) {
        gen1status = codegen_tcl(1);
    }
    else {
        loaderror("GEN1?","");
    }
    gen1end = os_clock();
}

static void do_gen2	(void) {
    if (!gen1status) {
        return;
    }
    if (!!fgenasm) {
        if ((gen2target==5067585)) {
            gen2status = codegen_asm(1,outfile);
        }
        else {
            loaderror("GEN2?","");
        }
    }
    else {
        loaderror("Can't do generate BIN code yet","");
    }
}

static void do_runprog	(void) {
    loaderror("Can't run any code yet","");
}

static int32 loadmainmodule	(char * filespec) {
char	modulename[100];
char	path[300];
int32	status;
modulerec	m;
int32	i;
int32	flag;
int32	fileno;
    pcm_clearmem(&moduletable[0],78);
    sourcefilenames[0] = "<dummy file>";
    sourcefilepaths[0] = "<dummy path>";
    sourcefiletext[0] = "<sourcefile0>";
    sourcefilesizes[0] = strlen(sourcefiletext[0]);
    moduletable[0].name = "PROGRAM";
    moduletable[0].fileno = 0;
    stprogram = createdupldef(0,addnamestr("$prog"),programid);
    moduletable[0].stmodule = stprogram;
    if (!checkfile(filespec)) {
        loaderror("Can't load main module: %s",filespec);
    }
    fileno = loadsourcefile(filespec,filespec);
    strcpy((char *)&modulename,extractbasefile(filespec));
    strcpy((char *)&path,extractpath(filespec));
    if (!!(uchar)path[1-1]) {
        ++nsearchdirs;
        for (i=nsearchdirs; i>=2; --i) {
            searchdirs[i-1] = searchdirs[i-1-1];
        }
        searchdirs[1-1] = pcm_copyheapstring((char *)&path);
    }
    addmodule((char *)&modulename,fileno,moduleid);
    return 1;
}

static int32 addmodule	(char * modulename,int32 fileno,int32 id) {
modulerec	m;
int32	i;
int32	status;
int32	k;
int32	flag;
int32	j;
modulerec *	pmodule;
    pcm_clearmem(&m,78);
    m.name = pcm_copyheapstring(modulename);
    m.fileno = fileno;
    stmodule = createnewmoduledef(stprogram,addnamestr(m.name));
    m.stmodule = stmodule;
    ++modulelevel;
    if (nmodules >= maxmodule) {
        loaderror("Too many modules %s",modulename);
    }
    pmodule = &moduletable[++nmodules];
    *pmodule = m;
    m.stmodule->attribs.ax_moduleno = nmodules;
    if (nmodules >= maxmodule) {
        loaderror("Too many modules %s",modulename);
    }
    return nmodules;
}

static void initlogfile	(void) {
    if (!fshowlog) {
        return;
    }
    if ((logdest==2)) {
        remove("mcc.log");
        logdev = fopen("mcc.log","w");
    } else if ((logdest==0) || (logdest==1)) {
        logdev = os_getstdout();
    }
}

static void closelogfile	(void) {
char	str[100];
int32	pos;
    if (logdest == 2) {
        fclose(logdev);
        sprintf((char *)&str,"\\m\\med.bat %s","mcc.log");
        if (!!checkfile("cc_start.m")) {
            os_execwait((char *)&str,1,0);
        }
        else {
            printf("%s %s\n","Diagnostic outputs written to","mcc.log");
        }
    }
    else if (dopause && logdest != 0) {
        printf("%s","CLF Press key...");
        os_getch();
        printf("\n");
    }
}

static void initdata	(void) {
    pcm_init();
    lexsetup();
    inittypetables();
    initcclib();
}

static void initsearchdirs	(void) {
char	str1[300];
char	str2[300];
int32	i;
    searchdirs[++nsearchdirs-1] = "";
    if (nincludepaths == 0) {
        includepaths[1-1] = "/cx/headers/";
        ++nincludepaths;
    }
    for (i=1; i<=nincludepaths; ++i) {
        if (!!(uchar)*includepaths[i-1]) {
            searchdirs[++nsearchdirs-1] = includepaths[i-1];
        }
    }
}

static void showsearchdirs	(void) {
int32	i;
    printf("%s\n","Include search paths:");
    if (dointheaders) {
        printf("%s\n","0: Internal standard headers (disable with -ext)");
    }
    for (i=1; i<=nsearchdirs; ++i) {
        if (!!(uchar)*searchdirs[i-1]) {
            printf("%d%s %s\n",i,":",searchdirs[i-1]);
        }
        else {
            printf("%d%s\n",i,": .");
        }
    }
    printf("\n");
}

static void showast	(int32 n) {
    if (logdest) {
        if (logdest == 2) {
            fprintf(logdev,"\n");
        }
        printcode(logdev,"PROC AST",n);
        fprintf(logdev,"\n");
    }
}

static void showstflat	(char * caption) {
    if (logdest) {
        if (logdest == 2) {
        }
        fprintf(logdev,"%s %s\n","PROC",caption);
        printstflat(logdev);
        fprintf(logdev,"\n");
    }
}

static void showsttree	(char * caption,int32 n) {
    if (logdest) {
        if (logdest == 2) {
        }
        fprintf(logdev,"%s %s\n","PROC",caption);
        printst(logdev,moduletable[n].stmodule,0);
        fprintf(logdev,"\n");
    }
}

static void showtcl	(char * caption,int32 n) {
strbuffer *	tclstr;
    if (logdest) {
        tclstr = writetccode(caption,n,1);
        gs_println(tclstr,logdev);
    }
}

static void showasm	(int32 n) {
char *	asmstr;
char *	caption;
    if ((gen2target==5067585)) {
        caption = "PROC ASSEMBLY LISTING";
    } else if ((gen2target=='C')) {
        caption = "PROC FLATC LISTING";
    }
    asmstr = moduletable[n].asmstr;
    if (asmstr == 0) {
        return;
    }
    if (logdest) {
        fprintf(logdev,"%s %d\n",caption,n);
        fprintf(logdev,"%s\n",asmstr);
    }
}

static void showmodules	(void) {
int32	i;
int32	j;
int32	k;
int32	fileno;
modulerec	m;
    printf("%s\n","Modules:");
    for (i=1; i<=nmodules; ++i) {
        m = moduletable[i];
        fileno = m.fileno;
        printf("%d%s",i,":");
        printf("%s %s %s %d %s %p\n",m.name,sourcefilepaths[fileno],"Size:",sourcefilesizes[fileno],"@",(void*)(m.stmodule));
    }
    printf("\n");
}

static void showfiles	(void) {
int32	i;
    printf("%s\n","Sourcefiles:");
    for (i=1; i<=nsourcefiles; ++i) {
        printf("%d %s %s %s %s %d\n",i,":",sourcefilepaths[i],sourcefilenames[i],"Size:",sourcefilesizes[i]);
    }
    printf("\n");
}

static void starttiming	(void) {
int32	t;
    t = os_clock();
    do {
    } while (!(os_clock() != t));
    progstart = os_clock();
}

static void showtiming	(void) {
int32	t;
int32	i;
int32	loadtime=loadend-loadstart;
int32	parsetime=parseend-parsestart;
int32	codegen1time=gen1end-gen1start;
int32	codegen2time=gen2end-gen2start;
int32	asmwtime=asmwend-asmwstart;
int32	progtime=progend-progstart;
    printf("%d %s\n",NALLLINES,"Lines");
    showlps("Load",loadtime,1);
    showlps("Parse",parsetime,1);
    showlps("Codegen1",codegen1time,0);
    showlps("(Load/Parse/Gen1)",loadtime+parsetime+codegen1time,1);
    showlps("Codegen2",codegen2time,0);
    showlps("Writeasm",asmwtime,0);
    showlps("Compile",parsetime+codegen1time+codegen2time+asmwtime,1);
    showlps("Load+Compile",loadtime+parsetime+codegen1time+codegen2time+asmwtime,1);
    showlps("Program",progtime,1);
}

void showlps	(char * caption,int32 t,int32 showlps) {
char	str[256];
int32	lps;
int32	txi;
double	tx;
double	lpsx;
    txi = t;
    if (t > 1) {
        lpsx = NALLLINES/ (double)t;
    }
    else {
        lps = (lpsx = 0.0);
    }
    if (showlps) {
        sprintf((char *)&str,"%18s: %4d ms  %8dK Lines per second\n",caption,txi,(int32)lpsx);
    }
    else {
        sprintf((char *)&str,"%18s: %4d ms\n",caption,txi);
    }
    printf("%s",(char*)(&str));
}

static void getinputoptions	(void) {
enum {slash = '-'};
int32	i;
int32	j;
int32	k;
int32	paramno;
int32	pmtype;
int32	sw;
char *	name;
char *	value;
char *	ext;
    paramno = 2;
    while (pmtype = nextparam(&paramno,&name,&value)) {
        if ((pmtype==pm_option)) {
            convlcstring(name);
            for (sw=1; sw<=34; ++sw) {
                if (strcmp(name,optionnames[sw-1]) == 0) {
                    do_option(sw,value);
                    goto L43;
                }
            }
            printf("%s %s\n","Unknown option:",name);
            exit(99);
L43:;
        } else if ((pmtype==pm_sourcefile)) {
            if (ninputfiles >= maxmodule) {
                loaderror("Too many input files","");
            }
            inputfiles[++ninputfiles] = pcm_copyheapstring(name);
        } else if ((pmtype==pm_libfile)) {
            if (nlibfiles >= maxlibfile) {
                loaderror("Too many lib files","");
            }
            libfiles[++nlibfiles] = pcm_copyheapstring(name);
        }
    }
    if (fgenasm == 0 && fgenbin == 0) {
        fgenasm = 1;
    }
    if (passes == 0) {
        passes = 29;
    }
    if (!!fshowlog && logdest == 0) {
        logdest = 2;
    }
    if (ninputfiles == 0 && !fwriteheaders) {
        showcaption();
        printf("%s\n","Usage:");
        printf("%s%s %s\n","\t",sysparams[1-1],"filename[.c]");
        printf("%s%s %s\n","\t",sysparams[1-1],"-help");
        exit(0);
    }
    else if (ninputfiles) {
        if ((gen2target==5067585)) {
            ext = "asm";
        } else if ((gen2target=='C')) {
            ext = "cx";
        }
        outfile = pcm_copyheapstring(changeext(inputfiles[1],ext));
    }
}

static void do_option	(int32 sw,char * value) {
int32	length;
    if ((sw==load_sw)) {
        passes = mload;
    } else if ((sw==preprocess_sw)) {
        passes = 3;
    } else if ((sw==parse_sw)) {
        passes = 5;
    } else if ((sw==gen1_sw)) {
        passes = 13;
    } else if ((sw==gen2_sw)) {
        passes = 29;
    } else if ((sw==link_sw)) {
        passes = 61;
    } else if ((sw==run_sw)) {
        passes = 125;
    } else if ((sw==asm_sw)) {
        fgenasm = 1;
        fgenbin = 0;
    } else if ((sw==bin_sw)) {
        fgenasm = 0;
        fgenbin = 1;
    } else if ((sw==options_sw)) {
        fshowoptions = 1;
    } else if ((sw==modules_sw)) {
        fshowmodules = 1;
    } else if ((sw==files_sw)) {
        fshowfiles = 1;
    } else if ((sw==e_sw)) {
        passes = 3;
        fshowtokens = 1;
    } else if ((sw==ast_sw)) {
        fshowast = 1;
        fshowlog = 1;
    } else if ((sw==st_sw)) {
        fshowst = 1;
        fshowlog = 1;
    } else if ((sw==stflat_sw)) {
        fshowstflat = 1;
        fshowlog = 1;
    } else if ((sw==tcl_sw)) {
        fshowtcl = 1;
        fshowlog = 1;
    } else if ((sw==showasm_sw)) {
        fshowasm = 1;
        fshowlog = 1;
    } else if ((sw==types_sw)) {
        fshowtypes = 1;
        fshowlog = 1;
    } else if ((sw==dis_sw)) {
        fshowdis = 1;
        fshowlog = 1;
    } else if ((sw==paths_sw)) {
        fshowpaths = 1;
    } else if ((sw==headers_sw)) {
        fshowheaders = 1;
    } else if ((sw==compile_sw)) {
        passes = 29;
    } else if ((sw==s_sw)) {
        logdest = 1;
    } else if ((sw==d_sw)) {
        logdest = 2;
        if (!fshowlog) {
            fshowast = 1;
            fshowst = 1;
            fshowtcl = 1;
        }
    } else if ((sw==inclpath_sw)) {
        if (nincludepaths > maxincludepaths) {
            loaderror("Too many include paths","");
        }
        length = strlen(value);
        if (((uchar)*(value+length-1)=='\\') || ((uchar)*(value+length-1)=='/')) {
        }
        else {
            loaderror("Path should end with / or \\: %s",value);
        }
        includepaths[++nincludepaths-1] = pcm_copyheapstring(value);
    } else if ((sw==time_sw)) {
        fshowtiming = 1;
    } else if ((sw==v_sw)) {
        fverbose = 1;
    } else if ((sw==v2_sw)) {
        fverbose = 1;
    } else if ((sw==quiet_sw)) {
        fquiet = 1;
    } else if ((sw==help_sw) || (sw==help2_sw)) {
        showhelp();
    } else if ((sw==ext_sw)) {
        dointheaders = 0;
    } else if ((sw==writeheaders_sw)) {
        fwriteheaders = 1;
    }
}

static int32 nextparam	(int32 * paramno,char * * name,char * * value) {
static int32	infile=0;
static char *	filestart=0;
static char *	fileptr=0;
static byte	colonnext=0;
byte *	q;
char *	item;
char *	fileext;
int32	length;
static char	str[300];
reenter:
L87:;
    if (infile) {
        if (readnextfileitem(&fileptr,&item) == 0) {
            free(filestart);
            infile = 0;
            goto L87;
        }
    }
    else {
        if (!!colonnext || *paramno > nsysparams) {
            return pm_end;
        }
        item = sysparams[*paramno-1];
        ++*paramno;
        length = strlen(item);
        if ((uchar)*item != '-' && (uchar)*(item+length-1) == ':') {
            printf("%s\n","//COLON SEEN");
            colonnext = 1;
            *(item+length-1) = 0;
        }
        if ((uchar)*item == '@') {
            filestart = fileptr = (char *)readfile(item+1);
            if (filestart == 0) {
                printf("%s %s\n","Can't open",item);
                exit(0);
            }
            infile = 1;
            goto L87;
        }
        if ((uchar)*item == ':') {
            return pm_end;
        }
    }
    *value = 0;
    if ((uchar)*item == '-') {
        *name = item+1;
        q = (byte *)strchr(item,':');
        if (!q) {
            q = (byte *)strchr(item,'=');
        }
        if (q) {
            *value = (char *)(q+1);
            *q = 0;
        }
        return pm_option;
    }
    fileext = extractext(item,0);
    *name = item;
    if ((uchar)*fileext == 0) {
        strcpy((char *)&str,*name);
        *name = addext((char *)&str,".c");
    }
    else if (strcmp(fileext,"dll") == 0) {
        return pm_libfile;
    }
    return pm_sourcefile;
}

static int32 readnextfileitem	(char * * fileptr,char * * item) {
char *	p;
char *	pstart;
char *	pend;
int32	i;
int32	n;
static char	str[256];
    p = *fileptr;
    while (1) {
        if (((uchar)*p==' ') || ((uchar)*p=='	') || ((uchar)*p==13) || ((uchar)*p==10)) {
            ++p;
        } else if (((uchar)*p==26) || ((uchar)*p==0)) {
            return 0;
        }
        else {
            goto L92;
        }
    }
L92:;
    if ((uchar)*p == '"') {
        pstart = ++p;
        while (1) {
            if (((uchar)*p==0) || ((uchar)*p==26)) {
                printf("%s\n","Unexpected EOF in @file");
                exit(0);
            } else if (((uchar)*p=='"')) {
                pend = p++;
                if ((uchar)*p == ',') {
                    ++p;
                }
                goto L98;
            }
            ++p;
        }
L98:;
    }
    else {
        pstart = p;
        while (1) {
            if (((uchar)*p==0) || ((uchar)*p==26)) {
                pend = p;
                goto L103;
            } else if (((uchar)*p==' ') || ((uchar)*p=='	') || ((uchar)*p==',') || ((uchar)*p==13) || ((uchar)*p==10)) {
                pend = p++;
                goto L103;
            }
            ++p;
        }
L103:;
    }
    n = pend-pstart;
    if (n >= 256) {
        printf("%s\n","@file item too long");
        exit(0);
    }
    memcpy((int32 *)&str,(int32 *)pstart,n);
    str[n+1-1] = 0;
    *item = (char *)&str;
    *fileptr = p;
    return 1;
}

static void showoptions	(void) {
int32	i;
    printf("\n");
    printf("%s\n","Options:");
    printf("%s\n","--------");
    if (!!(passes&mload)) {
        printf("%s\n","-load");
    }
    if (!!(passes&mpreprocess)) {
        printf("%s\n","-pp");
    }
    if (!!(passes&mparse)) {
        printf("%s\n","-parse");
    }
    if (!!(passes&mgen1)) {
        printf("%s\n","-gen1");
    }
    if (!!(passes&mgen2)) {
        printf("%s\n","-gen2");
    }
    if (!!(passes&mlink)) {
        printf("%s\n","-link");
    }
    if (!!(passes&mrun)) {
        printf("%s\n","-run");
    }
    if (!!fshowoptions) {
        printf("%s\n","-options");
    }
    if (!!fshowmodules) {
        printf("%s\n","-modules");
    }
    if (!!fshowtokens) {
        printf("%s\n","-e");
    }
    if (!!fshowast) {
        printf("%s\n","-ast");
    }
    if (!!fshowst) {
        printf("%s\n","-st");
    }
    if (!!fshowstflat) {
        printf("%s\n","-stflat");
    }
    if (!!fshowtypes) {
        printf("%s\n","-types");
    }
    if (!!fshowtcl) {
        printf("%s\n","-tcl");
    }
    if (!!fshowasm) {
        printf("%s\n","-showasm");
    }
    if (!!fshowdis) {
        printf("%s\n","-dis");
    }
    if (!!fshowtiming) {
        printf("%s\n","-time");
    }
    if (!!fshowlog) {
        printf("%s\n","-d");
    }
    if (!!fgenasm) {
        printf("%s\n","-asm");
    }
    if (!!fgenbin) {
        printf("%s\n","-bin");
    }
    if (!!fshowlog) {
        printf("%s\n","<showlog>");
    }
    printf("\n");
    printf("%s %s\n","Use internal headers:",(dointheaders?"Yes":"No"));
    showincludepaths();
    printf("%s %d\n","Input files",ninputfiles);
    for (i=1; i<=ninputfiles; ++i) {
        printf("%d %s\n",i,inputfiles[i]);
    }
    printf("\n");
    printf("%s %d\n","Library files",nlibfiles);
    for (i=1; i<=nlibfiles; ++i) {
        printf("%d %s\n",i,libfiles[i]);
    }
    printf("\n");
}

static void showincludepaths	(void) {
int32	i;
    printf("%s %d\n","Include paths",nincludepaths);
    for (i=1; i<=nincludepaths; ++i) {
        printf("%d %s\n",i,includepaths[i-1]);
    }
    printf("\n");
}

static void showhelp	(void) {
static char *	helptext="MCC-ASM version compiles one C file to .asm64\r\n\r\nNormal use (mcc is the compiler executable):\r\n\r\n\tmcc filename\r\n\tmcc filename.c\r\n\r\nTranslates filename.c to filename.asm64\r\n\r\nOptions for ASM version:\r\n\r\n\t-load\t\tLoad source only\r\n\t-pp\t\tPreprocess only\r\n\t-parse\t\tParse/type-check only\r\n\t-gen1\t\tGenerate intermediate code ('mcl')\r\n\t-gen2\t\tGenerate asm code\r\n\t-c\t\tSame as -gen2\r\n\r\n\t-i:path\t\tAdd include path (should end with \\ or /)\r\n\t-ext\t\tDon't use internal standard headers\r\n\r\n\t-e\t\tWrite preprocessed output to filename.i (also does -pp)\r\n\t-modules\tList modules\r\n\t-files\t\tShow all source files\r\n\t-st\t\tShow structured symbol table (to log file)\r\n\t-stflat\t\tShow main hash table (to log file)\r\n\t-ast\t\tShow abstract syntax tree per function (to log file)\r\n\t-mcl\t\tShow intermediate code (to log file)\r\n\t-showasm\tShow asm64 code (to log file as well as filename.asm64)\r\n\t-types\t\tShow type table\r\n\t-paths\t\tShow include/search paths\r\n\r\n\t-time\t\tShow compiler timing stats\r\n\t-options\tShow options chosen\r\n\t-v\t\tMore verbose\r\n\r\n\t-writeheaders\tWrite out internal headers as .hdr (not .h) files\r\n\r\nNotes:\r\n\r\n* Options can be placed, one per line, in an @ file, then just use\r\n  @filename in place of an option\r\n* Compiler is not finished\r\n* Standard header files are largely unpopulated (can use alternate\r\n  headers via -ext and -i, but there can be compatibility issues)\r\n* Only one source file is compiled\r\n* The only output is x64 ASM source code (requires additional resources and\r\n  info to assemble and link)\r\n";
    printf("%s\n",helptext);
    exit(0);
}

static void showcaption	(void) {
    printf("%s\n","MC [CY] Compiler 8.10");
}

/* Notes:

   The original modules are named:

        mm_clib
        mm_mainc
        mm_mlib
        mm_nos
        cc_tables
        cc_decls
        cc_support
        cc_headers
        cc_lex
        cc_lib
        cc_parse
        cc_libtcl
        cc_genasm
        cc_gentcl
        cc_start
*/
