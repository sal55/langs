// Generated C
#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"

extern double sqrt(double);
extern double sin(double);
extern double cos(double);
extern double tan(double);
extern double asin(double);
extern double acos(double);
extern double atan(double);
extern double log(double);
extern double log10(double);
extern double exp(double);
extern double floor(double);
extern double ceil(double);
extern double atan2(double, double);
extern double fmod(double, double);
extern double pow(double, double);

typedef signed char		i8;
typedef short			i16;
typedef int				i32;
typedef long long int	i64;
typedef unsigned char			u8;
typedef unsigned short			u16;
typedef unsigned int			u32;
typedef unsigned long long int	u64;

typedef unsigned char byte;

typedef float r32;
typedef double r64;

extern void exit(i32);
extern void memset(u64, i32, u64);

#define asi8(x)  *(i8*)&x
#define asi16(x) *(i16*)&x
#define asi32(x) *(i32*)&x
#define asi64(x) *(i64*)&x

#define asu8(x)  *(u8*)&x
#define asu16(x) *(u16*)&x
#define asu32(x) *(u32*)&x
#define asu64(x) *(u64*)&x

#define asr32(x) *(r32*)&x
#define asr64(x) *(r64*)&x


#define toi8(x)  (i8)x
#define toi16(x) (i16)x
#define toi32(x) (i32)x
#define toi64(x) (i64)x

#define tou8(x)  (u8)x
#define tou16(x) (u16)x
#define tou32(x) (u32)x
#define tou64(x) (u64)x

#define tor32(x) (r32)x
#define tor64(x) (r64)x


#define toi8p(x)  (i8*)x
#define toi16p(x) (i16*)x
#define toi32p(x) (i32*)x
#define toi64p(x) (i64*)x

#define tou8p(x)  (u8*)x
#define tou16p(x) (u16*)x
#define tou32p(x) (u32*)x
#define tou64p(x) (u64*)x

#define tor32p(x) (r32*)x
#define tor64p(x) (r64*)x


i64 Getdotindex(u64 a, int i);
u64 Setdotindex(u64 a, i64 i, i64 x);
i64 Getdotslice(u64 a, i64 i, i64 j);
u64 Setdotslice(u64 a, i64 i, i64 j, u64 x);
i64 Poweri64(i64 a, i64 n);

#define Min(x, y) (x<=y ? x : y)
#define Max(x, y) (x>=y ? x : y)

i64 ncmdparams;
i64 nenvstrings;
char* (*cmdparams)[];
i64 $cmdskip;

/*
PROC START
*/
void mmi_main();
void (*entrypoint)(void) = mmi_main;

// ***** Types *****
struct $B1 {u64 a[10];};   // mem:80;
struct $B2 {u16 a[5];};   // mem:10;
struct $B3 {u64 a[2];};   // mem:16;
struct $B4 {u64 a[512];};   // mem:4096;
struct $B5 {u32 a[25];};   // mem:100;
struct $B6 {u64 a[40];};   // mem:320;
struct $B7 {u64 a[301];};   // mem:2408;
struct $B8 {u64 a[3];};   // mem:24;
struct $B9 {u32 a[3];};   // mem:12;
struct $B10 {u8 a[2049];};   // mem:2049;
struct $B11 {u64 a[9];};   // mem:72;
struct $B12 {u64 a[6];};   // mem:48;
struct $B13 {u32 a[9];};   // mem:36;
struct $B14 {u32 a[65];};   // mem:260;
struct $B15 {u32 a[75];};   // mem:300;
struct $B16 {u64 a[32];};   // mem:256;
struct $B17 {u32 a[5];};   // mem:20;
struct $B18 {u64 a[4];};   // mem:32;
struct $B19 {u64 a[50];};   // mem:400;
struct $B20 {u64 a[143];};   // mem:1144;
struct $B21 {u64 a[16];};   // mem:128;
struct $B22 {u64 a[14];};   // mem:112;
struct $B23 {u16 a[7];};   // mem:14;
struct $B24 {u8 a[143];};   // mem:143;
struct $B25 {u64 a[7];};   // mem:56;
struct $B26 {u64 a[151];};   // mem:1208;
struct $B27 {u8 a[151];};   // mem:151;
struct $B28 {u64 a[21];};   // mem:168;
struct $B29 {u8 a[21];};   // mem:21;
struct $B30 {u64 a[20];};   // mem:160;
struct $B31 {u64 a[137];};   // mem:1096;
struct $B32 {u8 a[137];};   // mem:137;
struct $B33 {u64 a[8];};   // mem:64;
struct $B34 {u64 a[18];};   // mem:144;
struct $B35 {u16 a[9];};   // mem:18;
struct $B36 {u16 a[25];};   // mem:50;
struct $B37 {u64 a[17];};   // mem:136;
struct $B38 {u64 a[64];};   // mem:512;
struct $B39 {u64 a[128];};   // mem:1024;
struct $B40 {u64 a[193];};   // mem:1544;
struct $B41 {u64 a[1];};   // mem:8;
struct $B42 {u64 a[11];};   // mem:88;
struct $B43 {u64 a[55];};   // mem:440;
struct $B44 {u8 a[55];};   // mem:55;
struct $B45 {u8 a[301];};   // mem:301;
struct $B46 {u64 a[31];};   // mem:248;
struct $B47 {u8 a[31];};   // mem:31;
struct $B48 {u64 a[51];};   // mem:408;
struct $B49 {u64 a[16001];};   // mem:128008;
struct $B50 {u32 a[16001];};   // mem:64004;
struct $B51 {u8 a[16001];};   // mem:16001;
struct $B52 {u64 a[152004];};   // mem:1216032;
struct $B53 {u32 a[38001];};   // mem:152004;
struct $B54 {u64 a[1000];};   // mem:8000;
struct $B55 {u64 a[200];};   // mem:1600;
struct $B56 {u8 a[65];};   // mem:65;
struct $B57 {u64 a[65536];};   // mem:524288;
struct $B58 {u64 a[13];};   // mem:104;
struct $B59 {u64 a[12];};   // mem:96;
struct $B60 {u64 a[33];};   // mem:264;
struct $B61 {u8 a[33];};   // mem:33;
struct $B62 {u64 a[123];};   // mem:984;
struct $B63 {u8 a[123];};   // mem:123;
struct $B64 {u64 a[136];};   // mem:1088;
struct $B65 {u64 a[174];};   // mem:1392;
struct $B66 {u16 a[87];};   // mem:174;
struct $B67 {u32 a[87];};   // mem:348;
struct $B68 {u8 a[1];};   // mem:0;
struct $B69 {u64 a[208];};   // mem:1664;
struct $B70 {u64 a[5];};   // mem:40;
struct $B71 {u64 a[45];};   // mem:360;
struct $B72 {u64 a[320];};   // mem:2560;
struct $B73 {u64 a[41];};   // mem:328;
struct $B74 {u64 a[5000];};   // mem:40000;
struct $B75 {u64 a[10000];};   // mem:80000;
struct $B76 {u64 a[100];};   // mem:800;
struct $B77 {u64 a[300];};   // mem:2400;
struct $B78 {u64 a[500];};   // mem:4000;
struct $B79 {u64 a[1001];};   // mem:8008;
struct $B80 {u64 a[256];};   // mem:2048;
struct $B81 {u64 a[250];};   // mem:2000;
struct $B82 {u32 a[125];};   // mem:500;
struct $B83 {u64 a[30];};   // mem:240;

// Function Ptr Types:
typedef i64 (*F1)(u64);
typedef i64 (*F2)();
typedef i64 (*F3)(i64);
typedef i64 (*F4)(i64, i64);
typedef i64 (*F5)(i64, i64, i64);
typedef i64 (*F6)(i64, i64, i64, i64);
typedef i64 (*F7)(i64, i64, i64, i64, i64);
typedef i64 (*F8)(i64, i64, i64, i64, i64, i64);
typedef i64 (*F9)(i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F10)(i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F11)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F12)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef i64 (*F13)(i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64);
typedef r64 (*F14)();
typedef r64 (*F15)(i64);
typedef r64 (*F16)(i64, i64);
typedef i64 (*F17)(i64, u64, u64);

// ***** Variables *****
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap;
static i64 msysc_outdev;
static u64 msysc_outchan;
static u64 msysc_fmtstr;
static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack;
static struct $B3 msysc_digits;
static struct $B3 msysc_defaultfmt;
static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug;
static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup;
static i64 mlib_show;
static i64 mlib_memtotal;
static i64 mlib_smallmemtotal;
static i64 mlib_smallmemobjs;
static i64 mlib_maxmemtotal;
static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames;
static struct $B3 mlib_seed;
static i64 mlib_pcm_newblock_totalheapsize;
static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static u64 mwindows_hconsole;
static u64 mwindows_hconsolein;
static struct $B17 mwindows_lastkey;
static struct $B17 mwindows_pendkey;
static i64 mwindows_keypending;
static i64 mwindows_hpfreq;
static u64 mwindows_wndproc_callbackfn;
static i64 mwindows_init_flag;
static u8 mwindows_os_gxregisterclass_registered;
static struct $B15 mwindows_os_gethostname_name;
static i64 mwindows_os_gethostname_n;
static i64 mwindows_os_peek_lastticks;
static u8 pclint_pc_userunpcl;
static u8 pclint_ctarget;
static i64 pc_api_pclseqno;
static i64 pc_api_stseqno;
static u64 pc_api_pcstart;
static u64 pc_api_pccurr;
static u64 pc_api_pcend;
static i64 pc_api_pcalloc;
static u8 pc_api_pcfixed;
static i64 pc_api_pcseqno;
static i64 pc_api_pcneedfntable;
static i64 pc_api_initpcalloc;
static u64 pc_api_longstring;
static i64 pc_api_longstringlen;
static i64 pc_api_mlabelno;
static u8 pc_api_phighmem;
static u8 pc_api_pfullsys;
static u8 pc_api_fpshortnames;
static u64 pc_api_idomcl_assem;
static u64 pc_api_icheckasmlabel;
static u64 pc_api_igethostfn;
static struct $B18 pc_api_strpmode_str;
static struct $B16 pc_api_getfullname_str;
static struct $B16 pc_api_addstr_str;
static u64 pc_decls_pinfo;
static i64 pc_decls_bspill;
static i64 pc_decls_bxspill;
static u8 pc_decls_r10used;
static u8 pc_decls_r11used;
static u8 pc_decls_localshadow;
static i64 pc_decls_mmpos;
static u64 pc_decls_psymboltable;
static u64 pc_decls_psymboltablex;
static u64 pc_decls_currprog;
static u64 pc_decls_currfunc;
static u64 pc_decls_blockretname;
static u64 pc_decls_entryproc;
static struct $B3 pc_decls_sbuffer;
static u64 pc_decls_pdest;
static struct $B19 pc_decls_plibfiles;
static struct $B19 pc_decls_plibinst;
static i64 pc_decls_nplibfiles;
static u64 pc_decls_igetmsourceinfo;
static u8 pc_decls_pcldone;
static u8 pc_decls_mcldone;
static u8 pc_decls_ssdone;
static u8 pc_decls_objdone;
static u8 pc_decls_exedone;
static u8 pc_decls_pverbose;
static i64 pc_decls_pcmdskip;
static i64 pc_decls_assemtype;
static i64 pc_decls_ppseqno;
static u8 pc_decls_fpeephole;
static u8 pc_decls_fregoptim;
static i64 pc_decls_mcltime;
static i64 pc_decls_sstime;
static i64 pc_decls_objtime;
static i64 pc_decls_exetime;
static u64 pc_decls_$pmodulename;
static struct $B20 pc_decls_pclflags;
static i64 pc_decls_pstartclock;
static i64 pc_run_dotrace;
static i64 pc_run_dostep;
static i64 pc_run_go;
static i64 pc_run_seqno;
static struct $B21 pc_run_emptyst;
static u64 pc_run_labeltable;
static struct $B22 pc_tables_pstdnames;
static struct $B23 pc_tables_psize;
static struct $B23 pc_tables_psigned;
static struct $B23 pc_tables_pint;
static struct $B23 pc_tables_pfloat;
static struct $B23 pc_tables_pmin;
static struct $B23 pc_tables_xxpiwrb;
static struct $B22 pc_tables_opndnames;
static struct $B20 pc_tables_pclnames;
static struct $B24 pc_tables_pclhastype;
static struct $B24 pc_tables_pclextra;
static struct $B24 pc_tables_pclhasopnd;
static struct $B24 pc_tables_pclargs;
static struct $B25 pc_tables_ccnames;
static struct $B1 pc_tables_idnames;
static i64 mc_genss_dummy_psstime;
static struct $B11 mc_decls_valtypenames;
static struct $B26 mc_decls_mclnames;
static struct $B27 mc_decls_mclnopnds;
static struct $B27 mc_decls_mclcodes;
static struct $B28 mc_decls_regnames;
static struct $B29 mc_decls_regcodes;
static struct $B30 mc_decls_condnames;
static struct $B30 mc_decls_asmcondnames;
static struct $B30 mc_decls_asmrevcond;
static struct $B31 mc_decls_dregnames;
static struct $B32 mc_decls_regsizes;
static struct $B32 mc_decls_regindices;
static struct $B21 mc_decls_xmmregnames;
static struct $B33 mc_decls_fregnames;
static struct $B33 mc_decls_mregnames;
static struct $B34 mc_decls_jmpccnames;
static struct $B35 mc_decls_jmpcccodes;
static struct $B21 mc_decls_setccnames;
static struct $B3 mc_decls_setcccodes;
static struct $B21 mc_decls_cmovccnames;
static struct $B3 mc_decls_cmovcccodes;
static struct $B12 mc_decls_segmentnames;
static struct $B8 mc_decls_reftypenames;
static struct $B12 mc_decls_opndnames_ma;
static struct $B19 mc_decls_pclopnd;
static struct $B36 mc_decls_pclreg;
static struct $B36 mc_decls_pclmode;
static struct $B36 mc_decls_pclcount;
static struct $B36 mc_decls_pclloc;
static struct $B36 mc_decls_pcltempflags;
static struct $B19 mc_decls_pcltempopnds;
static i64 mc_decls_noperands;
static i64 mc_decls_mstackdepth;
static struct $B18 mc_decls_locnames;
static struct $B3 mc_decls_workregs;
static struct $B3 mc_decls_workxregs;
static i64 mc_decls_nworkregs;
static i64 mc_decls_nworkxregs;
static i64 mc_decls_nregvars;
static i64 mc_decls_nxregvars;
static i64 mc_decls_maxregvars;
static i64 mc_decls_maxxregvars;
static i64 mc_decls_xregmax;
static struct $B3 mc_decls_regset;
static struct $B3 mc_decls_xregset;
static struct $B3 mc_decls_isregvar;
static struct $B3 mc_decls_isxregvar;
static struct $B3 mc_decls_usedregs;
static struct $B3 mc_decls_usedxregs;
static u8 mc_decls_noxorclear;
static struct $B37 mc_decls_xregnames;
static struct $B18 mc_decls_callalign;
static struct $B18 mc_decls_callblockret;
static struct $B21 mc_decls_callblocksize;
static struct $B38 mc_decls_callargsize;
static i64 mc_decls_ncalldepth;
static i64 mc_decls_lababs32;
static i64 mc_decls_lababs64;
static i64 mc_decls_labneg32;
static i64 mc_decls_labneg64;
static i64 mc_decls_labmask63;
static i64 mc_decls_laboffset64;
static i64 mc_decls_labzero;
static i64 mc_decls_kk0used;
static u64 mc_decls_mccode;
static u64 mc_decls_mccodex;
static i64 mc_decls_currsegment;
static u64 mc_decls_dstackopnd;
static u64 mc_decls_dframeopnd;
static struct $B39 mc_decls_regtable;
static struct $B40 mc_decls_frameregtable;
static u64 mc_decls_cstringlist;
static u64 mc_decls_vstringlist;
static u64 mc_decls_creallist;
static u64 mc_decls_cr32list;
static u64 mc_decls_currasmproc;
static i64 mc_decls_lab_funcnametable;
static i64 mc_decls_lab_funcaddrtable;
static i64 mc_decls_lab_funcnprocs;
static i64 mc_decls_ss_zdatalen;
static u64 mc_decls_ss_zdata;
static u64 mc_decls_ss_idata;
static u64 mc_decls_ss_code;
static u64 mc_decls_ss_idatarelocs;
static u64 mc_decls_ss_coderelocs;
static i64 mc_decls_ss_nidatarelocs;
static i64 mc_decls_ss_ncoderelocs;
static u64 mc_decls_ss_symboltable;
static i64 mc_decls_ss_nsymbols;
static i64 mc_decls_ss_symboltablesize;
static u64 mc_decls_labeldeftable;
static i64 mc_decls_aaseqno;
static i64 mc_decls_aapos;
static u64 mc_decls_regmodes;
static u8 mc_decls_pmode;
static u64 mc_decls_currpcl;
static u64 mc_decls_mclprocentry;
static u64 mc_decls_mce_oldmccodex;
static u64 mc_decls_mce_lastmcl;
static u64 mc_decls_mce_nextmcl;
static u64 mc_decls_mcf_oldmccodex;
static u64 mc_decls_mcf_lastmcl;
static u64 mc_decls_mcf_nextmcl;
static u8 mc_decls_fpcheckunusedlocals;
static u64 mc_decls_riplist;
static struct $B19 mc_decls_blockdefs;
static i64 mc_decls_nblocktemps;
static struct $B12 mc_decls_multregs;
static struct $B12 mc_decls_multxregs;
static struct $B23 mc_decls_ploadopx;
static struct $B23 mc_decls_ploadop;
static struct $B25 mc_objdecls_relocnames;
static u64 mm_cli_syslibname;
static struct $B42 mm_cli_passnames;
static struct $B33 mm_cli_dpassnames;
static struct $B43 mm_cli_optionnames;
static struct $B44 mm_cli_optionvalues;
static u8 mm_cli_msfile;
static u64 mm_cli_outext;
static i64 mm_cli_startclock;
static i64 mm_cli_endclock;
static i64 mm_cli_cmdskip;
static u64 mm_cli_inputfile;
static i64 mm_cli_loadtime;
static i64 mm_cli_parsetime;
static i64 mm_cli_resolvetime;
static i64 mm_cli_typetime;
static i64 mm_cli_ctime;
static i64 mm_cli_pcltime;
static i64 mm_cli_compiletime;
static u8 mm_cli_do_option_outused;
static u8 mm_cli_do_option_outpathused;
static i64 mm_blockpcl_nnn;
static struct $B30 mm_blockpcl_casestmt;
static struct $B30 mm_blockpcl_caseelse;
static i64 mm_blockpcl_casedepth;
static u64 mm_blockpcl_sw_labeltable;
static u64 mm_blockpcl_sw_valuetable;
static i64 mm_blockpcl_sw_lower;
static i64 mm_blockpcl_sw_ncases;
static u8 mm_blockpcl_sw_defaultseen;
static i64 mm_blockpcl_sw_defaultlabel;
static i64 mm_blockpcl_sw_breaklabel;
static i64 mm_blockpcl_maxreg;
static u64 mm_blockpcl_pnprocs;
static u64 mm_blockpcl_pprocname;
static u64 mm_blockpcl_pprocaddr;
static struct $B7 mm_decls_modules;
static struct $B45 mm_decls_moduletosub;
static struct $B46 mm_decls_subprogs;
static struct $B7 mm_decls_sources;
static struct $B47 mm_decls_subproghasstart;
static i64 mm_decls_nmodules;
static i64 mm_decls_nsubprogs;
static i64 mm_decls_nsourcefiles;
static i64 mm_decls_nlibfiles;
static u64 mm_decls_stprogram;
static u64 mm_decls_stmodule;
static i64 mm_decls_currmoduleno;
static u8 mm_decls_loadedfromma;
static struct $B3 mm_decls_lx;
static struct $B3 mm_decls_nextlx;
static struct $B48 mm_decls_libfiles;
static i64 mm_decls_mainsubprogno;
static i64 mm_decls_ntypes;
static struct $B49 mm_decls_ttnamedef;
static struct $B49 mm_decls_ttowner;
static struct $B50 mm_decls_ttbasetype;
static struct $B49 mm_decls_ttname;
static struct $B50 mm_decls_ttsize;
static struct $B51 mm_decls_ttsizeset;
static struct $B50 mm_decls_ttlower;
static struct $B50 mm_decls_ttlength;
static struct $B49 mm_decls_ttmult;
static struct $B49 mm_decls_ttdimexpr;
static struct $B50 mm_decls_tttarget;
static struct $B51 mm_decls_ttusercat;
static struct $B50 mm_decls_ttlineno;
static struct $B51 mm_decls_ttsigned;
static struct $B51 mm_decls_ttisreal;
static struct $B51 mm_decls_ttisinteger;
static struct $B51 mm_decls_ttisshort;
static struct $B51 mm_decls_ttisref;
static struct $B51 mm_decls_ttisblock;
static struct $B52 mm_decls_typenames;
static struct $B53 mm_decls_typenamepos;
static i64 mm_decls_ntypenames;
static struct $B32 mm_decls_typestarterset;
static u64 mm_decls_currproc;
static i64 mm_decls_assemmode;
static i64 mm_decls_headermode;
static u64 mm_decls_proclist;
static u64 mm_decls_proclistx;
static u64 mm_decls_staticlist;
static u64 mm_decls_staticlistx;
static u64 mm_decls_constlist;
static u64 mm_decls_constlistx;
static u64 mm_decls_nullunit;
static i64 mm_decls_ndllproctable;
static struct $B54 mm_decls_dllproctable;
static i64 mm_decls_fverbose;
static u8 mm_decls_msyslevel;
static u8 mm_decls_mvarlib;
static u8 mm_decls_fvarnames;
static u8 mm_decls_fshowtiming;
static u8 mm_decls_fshowss;
static u8 mm_decls_fshowc;
static u8 mm_decls_fshowpcl;
static u8 mm_decls_fshowasm;
static u8 mm_decls_fshowast1;
static u8 mm_decls_fshowast2;
static u8 mm_decls_fshowast3;
static u8 mm_decls_fshowst;
static u8 mm_decls_fshowpst;
static u8 mm_decls_fshowstflat;
static u8 mm_decls_fshowtypes;
static u8 mm_decls_fshowmodules;
static u8 mm_decls_fcheckunusedlocals;
static u8 mm_decls_highmem;
static u8 mm_decls_clinux;
static u8 mm_decls_dointlibs;
static i64 mm_decls_passlevel;
static i64 mm_decls_dpasslevel;
static i64 mm_decls_prodmode;
static i64 mm_decls_debugmode;
static i64 mm_decls_libmode;
static i64 mm_decls_fshortnames;
static u64 mm_decls_outfile;
static u64 mm_decls_destfilename;
static u64 mm_decls_destfilepath;
static i64 mm_decls_nunits;
static i64 mm_decls_nunitsmem;
static struct $B3 mm_diags_dummy_sbuffer;
static u64 mm_diags_dummy_dest;
static i64 mm_diags_dummy_currlineno;
static struct $B3 mm_exportm_sbuffer;
static u64 mm_exportm_dest;
static i64 mm_genpcl_retindex;
static i64 mm_genpcl_initstaticsindex;
static u64 mm_genpcl_pcldoswx;
static struct $B55 mm_genpcl_loopstack;
static i64 mm_genpcl_loopindex;
static struct $B56 mm_genpcl_zero_unit;
static u64 mm_genpcl_pzero;
static i64 mm_genpcl_nvarlocals;
static i64 mm_genpcl_nvarparams;
static struct $B30 mm_lex_lxstart_stack;
static struct $B30 mm_lex_lxsource_stack;
static struct $B30 mm_lex_lxsptr_stack;
static struct $B30 mm_lex_lxfileno_stack;
static struct $B6 mm_lex_lxnextlx_stack;
static struct $B17 mm_lex_lximport_stack;
static i64 mm_lex_sourcelevel;
static i64 mm_lex_lximport;
static u64 mm_lex_lxsource;
static u64 mm_lex_lxstart;
static u64 mm_lex_lxsptr;
static i64 mm_lex_lxifcond;
static i64 mm_lex_lxfileno;
static struct $B57 mm_lex_hashtable;
static struct $B16 mm_lex_namemap;
static u64 mm_lex_u64maxstr;
static i64 mm_lib_autotypeno;
static i64 mm_lib_nextavindex;
static i64 mm_lib_nextsvindex;
static struct $B3 mm_lib_exprstrvar;
static u64 mm_lib_exprstr;
static u64 mm_lib_unitheapptr;
static i64 mm_lib_remainingunits;
static struct $B3 mm_lib_sbuffer;
static u64 mm_lib_dest;
static u64 mm_lib_jdest;
static u64 mm_lib_framevarname;
static struct $B18 mm_lib_nextautotype_str;
static struct $B16 mm_lib_getdottedname_str;
static struct $B4 mm_lib_strmode_str;
static struct $B4 mm_lib_strmode2_str;
static struct $B58 mm_libsources_syslibnames;
static struct $B58 mm_libsources_syslibtext;
static u64 mm_modules_fileext;
static struct $B15 mm_modules_getmodulefilename_str;
static u64 mm_name_currstproc;
static i64 mm_name_allowmodname;
static i64 mm_name_noexpand;
static i64 mm_name_noassem;
static i64 mm_name_macrolevels;
static struct $B19 mm_name_macroparams;
static struct $B19 mm_name_macroparamsgen;
static struct $B19 mm_name_macroargs;
static i64 mm_name_nmacroparams;
static i64 mm_name_nmacroargs;
static i64 mm_parse_intabledata;
static i64 mm_parse_inreadprint;
static i64 mm_parse_inparamlist;
static i64 mm_parse_inrecordbody;
static i64 mm_parse_inimportmodule;
static i64 mm_parse_labelseen;
static u64 mm_parse_tabledataname;
static struct $B1 mm_parse_procstack;
static i64 mm_parse_nprocstack;
static u64 mm_parse_unionstring;
static u64 mm_parse_unionpend;
static u64 mm_parse_unionlastvar;
static u64 mm_parse_dretvar;
static i64 mm_parse_varattribs;
static struct $B1 mm_parse_dollarstack;
static i64 mm_parse_ndollar;
static i64 mm_parse_insiderecord;
static i64 mm_parse_insidedllimport;
static struct $B1 mm_parse_forindexvars;
static i64 mm_parse_nforloops;
static u64 mm_support_bytemasks;
static struct $B16 mm_tables_stdnames;
static struct $B18 mm_tables_stdsize;
static struct $B18 mm_tables_stdpcl;
static i64 mm_tables_trefproc;
static i64 mm_tables_treflabel;
static struct $B60 mm_tables_sysfnnames;
static struct $B61 mm_tables_sysfnparams;
static struct $B61 mm_tables_sysfnres;
static struct $B60 mm_tables_sysfnhandlers;
static struct $B62 mm_tables_jtagnames;
static struct $B63 mm_tables_jsubs;
static struct $B63 mm_tables_jisexpr;
static struct $B63 mm_tables_jsolo;
static struct $B33 mm_tables_bitfieldnames;
static struct $B18 mm_tables_optypenames;
static struct $B64 mm_tables_symbolnames;
static struct $B37 mm_tables_symboloptypes;
static struct $B37 mm_tables_symbolgenops;
static struct $B37 mm_tables_symbolgentoops;
static struct $B37 mm_tables_symbolopprios;
static struct $B37 mm_tables_exprstarter;
static struct $B18 mm_tables_headerdirnames;
static struct $B18 mm_tables_scopenames;
static struct $B3 mm_tables_parammodenames;
static struct $B34 mm_tables_namenames;
static struct $B35 mm_tables_name2pid;
static struct $B1 mm_tables_propnames;
static struct $B65 mm_tables_stnames;
static struct $B66 mm_tables_stsymbols;
static struct $B67 mm_tables_stsubcodes;
static struct $B22 mm_tables_convnames;
static struct $B23 mm_tables_convtopcl;
static struct $B12 mm_tables_d_typestarterset;
static struct $B36 mm_tables_softconvtable;
static struct $B37 mm_tables_endsexpr;
static struct $B9 mm_tables_exprendsymbols;
static struct $B63 mm_tables_isbooltag;
static i64 mm_type_countedfields;
static i64 mm_type_inassem;
static i64 mm_type_inidata;
static i64 mm_type_tpass_depth;
static i64 mm_type_setrecordsize_depth;
static i64 mm_type_tx_assign_nn;
static i64 $nprocs;
static struct $B68 $procname;
static struct $B68 $procaddr;

// ***** Imported Functions *****
extern u64 malloc(u64 $1);
extern u64 realloc(u64 $1, u64 $2);
extern void free(u64 $1);
extern void memset(u64 $1, i32 $2, u64 $3);
extern void memcpy(u64 $1, u64 $2, u64 $3);
extern void memmove(u64 $1, u64 $2, u64 $3);
extern i32 clock();
extern i32 ftell(u64 $1);
extern i32 fseek(u64 $1, i32 $2, i32 $3);
extern u64 fread(u64 $1, u64 $2, u64 $3, u64 $4);
extern u64 fwrite(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 getc(u64 $1);
extern i32 ungetc(i32 $1, u64 $2);
extern u64 fopen(u64 a, u64 b);
extern i32 fclose(u64 $1);
extern u64 fgets(u64 $1, i64 $2, u64 $3);
extern i32 remove(u64 $1);
extern i32 rename(u64 $1, u64 $2);
extern i32 getchar();
extern void putchar(i32 $1);
extern void setbuf(u64 $1, u64 $2);
extern i64 strlen(u64 $1);
extern u64 strcpy(u64 $1, u64 $2);
extern i32 strcmp(u64 $1, u64 $2);
extern i32 strncmp(u64 $1, u64 $2, u64 $3);
extern u64 strncpy(u64 $1, u64 $2, u64 $3);
extern i32 memcmp(u64 $1, u64 $2, u64 $3);
extern u64 strcat(u64 $1, u64 $2);
extern i32 tolower(i32 $1);
extern i32 toupper(i32 $1);
extern i32 isalpha(i32 $1);
extern i32 isupper(i32 $1);
extern i32 islower(i32 $1);
extern i32 isalnum(i32 $1);
extern i32 isspace(i32 $1);
extern u64 strstr(u64 $1, u64 $2);
extern i64 atol(u64 $1);
extern i32 atoi(u64 $1);
extern r64 strtod(u64 $1, u64 $2);
extern u64 _strdup(u64 $1);
extern i32 puts(u64 $1);
extern i32 printf(u64 $1, ...);
extern i32 sprintf(u64 $1, u64 $2, ...);
extern i32 sscanf(u64 $1, u64 $2, ...);
extern i32 scanf(u64 $1, ...);
extern i32 rand();
extern void srand(u32 $1);
extern i32 system(u64 $1);
extern i32 fgetc(u64 $1);
extern i32 fputc(i32 $1, u64 $2);
extern i32 fprintf(u64 $1, u64 $2, ...);
extern i32 fputs(u64 $1, u64 $2);
extern i32 feof(u64 $1);
extern i32 getch();
extern i32 _getch();
extern i32 kbhit();
extern i32 _mkdir(u64 $1);
extern i32 mkdir(u64 $1);
extern u64 strchr(u64 $1, i32 $2);
extern i32 _setmode(i32 $1, i32 $2);
extern void _exit(i32 $1);
extern void exit(i32 $1);
extern r64 pow(r64 $1, r64 $2);
extern r64 sqrt(r64 $1);
extern r64 sin(r64 $1);
extern r64 cos(r64 $1);
extern r64 tan(r64 $1);
extern r64 asin(r64 $1);
extern r64 acos(r64 $1);
extern r64 atan(r64 $1);
extern r64 log(r64 $1);
extern r64 log10(r64 $1);
extern r64 exp(r64 $1);
extern r64 floor(r64 $1);
extern r64 ceil(r64 $1);
extern void qsort(u64 $1, u64 $2, u64 $3, u64 $4);
extern i32 __getmainargs(u64 $1, u64 $2, u64 $3, i64 $4, u64 $5);
extern u64 GetStdHandle(u32 $1);
extern i64 GetConsoleScreenBufferInfo(u64 $1, u64 $2);
extern i64 SetConsoleCtrlHandler(u64 $1, i64 $2);
extern i64 SetConsoleMode(u64 $1, u32 $2);
extern i64 CreateProcessA(u64 $1, u64 $2, u64 $3, u64 $4, i64 $5, u32 $6, u64 $7, u64 $8, u64 $9, u64 $10);
extern u32 GetLastError();
extern u32 WaitForSingleObject(u64 $1, u32 $2);
extern i64 GetExitCodeProcess(u64 $1, u64 $2);
extern i64 CloseHandle(u64 $1);
extern i64 GetNumberOfConsoleInputEvents(u64 $1, u64 $2);
extern i64 FlushConsoleInputBuffer(u64 $1);
extern u64 LoadLibraryA(u64 $1);
extern u64 GetProcAddress(u64 $1, u64 $2);
extern u64 LoadCursorA(u64 $1, u64 $2);
extern u32 RegisterClassExA(u64 $1);
extern i64 DefWindowProcA(u64 $1, u32 $2, u64 $3, u64 $4);
extern i64 ReadConsoleInputA(u64 $1, u64 $2, u32 $3, u64 $4);
extern void Sleep(u32 $1);
extern u32 GetModuleFileNameA(u64 $1, u64 $2, u32 $3);
extern void ExitProcess(u32 $1);
extern void PostQuitMessage(i32 $1);
extern void MessageBoxA(i32 x, u64 message, u64 caption, i32 y);
extern u32 QueryPerformanceCounter(u64 $1);
extern u32 QueryPerformanceFrequency(u64 $1);
extern u64 CreateFileA(u64 $1, u32 $2, u32 $3, u64 $4, u32 $5, u32 $6, u64 $7);
extern u32 GetFileTime(u64 $1, u64 $2, u64 $3, u64 $4);
extern void GetSystemTime(u64 $1);
extern void GetLocalTime(u64 $1);
extern u64 GetTickCount64();
extern u32 PeekMessageA(u64 $1, u64 $2, u32 $3, u32 $4, u32 $5);
extern u64 GetCommandLineA();
extern u64 VirtualAlloc(u64 $1, u32 $2, u32 $3, u32 $4);
extern u32 VirtualProtect(u64 $1, u32 $2, u32 $3, u64 $4);
extern u32 WriteConsoleA(u64 $1, u64 $2, i32 $3, u64 $4, u64 $5);
extern u64 FindFirstFileA(u64 $1, u64 $2);
extern u32 FindNextFileA(u64 $1, u64 $2);
extern u32 FindClose(u64 $1);
extern u32 MessageBeep(i32 $1);
extern u32 Beep(i32 freq, i32 dur);

// ***** Function Declarations *****
static u64 msysc_getfmt(u64 fmtstyle);
static u64 msysc_strint(i64 a, u64 fmtstyle);
static u64 msysc_strword(u64 a, u64 fmtstyle);
static u64 msysc_strreal(r64 a, u64 fmtstyle);
static u64 mlib_pcm_newblock(i64 itemsize);
static i64 mlib_pcm_round(i64 n);
static u64 mlib_changeext(u64 s, u64 newext);
static u64 mlib_extractpath(u64 s);
static u64 mlib_extractbasefile(u64 s);
static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext);
static i64 mlib_readnextfileitem(u64 fileptr, u64 item);
static u64 mlib_padstr(u64 s, i64 width, u64 padchar);
static u64 mlib_chr(i64 c);
static void mwindows_os_gxregisterclass(u64 classname);
static i64 mwindows_mainwndproc(u64 hwnd, u32 message, u64 wparam, u64 lparam);
static u64 mwindows_os_gethostname();
static void mwindows_os_peek();
static u64 pc_api_strpmode(i64 mode, i64 size);
static u64 pc_api_getfullname(u64 d, i64 backtick);
static u64 pc_api_addstr(u64 s, u64 t);
static void mm_cli_do_option(i64 sw, u64 value, i64 paramno);
static u64 mm_lib_nextautotype();
static u64 mm_lib_getdottedname(u64 p);
static u64 mm_lib_strmode(i64 m, i64 expand);
static u64 mm_lib_strmode2(i64 m, i64 expand);
static u64 mm_modules_getmodulefilename(u64 path, u64 name, i64 issyslib);
static u64 mm_parse_readcompilervar();
static void mm_type_tpass(u64 p, i64 t, i64 lv);
static void mm_type_setrecordsize(i64 m);
static void mm_type_tx_assign(u64 p, u64 a, u64 b, i64 t);
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl);
static void msysc_pushio();
static void msysc_m$print_startfile(u64 dev);
static void msysc_resetprintbuffer();
static void msysc_m$print_startstr(u64 s);
static void msysc_m$print_startptr(u64 p);
static void msysc_m$print_startcon();
static void msysc_m$print_setfmt(u64 format);
static void msysc_m$print_end();
static void msysc_nextfmtchars(i64 lastx);
static void msysc_dumpprintbuffer();
static void msysc_m$print_ptr(u64 a, u64 fmtstyle);
static void msysc_m$print_u64(u64 a, u64 fmtstyle);
static void msysc_m$print_ptr_nf(u64 a);
static void msysc_m$print_i64(i64 a, u64 fmtstyle);
static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep);
static void msysc_printstr_n(u64 s, i64 n);
static void msysc_strtofmt(u64 s, i64 slen, u64 fmt);
static void msysc_tostr_i64(i64 a, u64 fmt);
static void msysc_m$print_i64_nf(i64 a);
static void msysc_m$print_bool(i64 a, u64 fmtstyle);
static void msysc_m$print_str(u64 s, u64 fmtstyle);
static void msysc_printstr(u64 s);
static void msysc_tostr_u64(u64 a, u64 fmt);
static void msysc_m$print_r64(r64 x, u64 fmtstyle);
static void msysc_tostr_r64(r64 x, u64 fmt);
static void msysc_m$print_r32(r32 x, u64 fmtstyle);
static void msysc_m$print_c8(i64 a, u64 fmtstyle);
static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt);
static i64 msysc_getutfsize(u64 s);
static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt);
static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle);
static void msysc_m$print_str_nf(u64 s);
static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle);
static void mlib_abortprogram(u64 s);
static void msysc_m$print_newline();
static void msysc_m$print_nogap();
static void msysc_m$print_space();
static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer);
static void msysc_printstrn_app(u64 s, i64 length, u64 f);
static void msysc_printchar(i64 ch);
static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt);
static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep);
static u64 mlib_convlcstring(u64 s);
static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt);
static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt);
static u64 mlib_pcm_alloc(i64 n);
static u64 mlib_convucstring(u64 s);
static void mlib_pcm_free(u64 p, i64 n);
static u64 msysc_getstr(u64 s, u64 fmt);
static void msysc_getstrint(i64 a, u64 dest);
static u64 mlib_pcm_copyheapstring(u64 s);
static void msysc_initreadbuffer();
static void msysc_m$read_conline();
static void mlib_readlinen(u64 handlex, u64 buffer, i64 size);
static void msysc_m$read_fileline(u64 f);
static void msysc_m$read_strline(u64 s);
static u64 msysc_readitem(u64 itemlength);
static i64 msysc_strtoint(u64 s, i64 length, u64 base);
static i64 msysc_m$read_i64(i64 fmt);
static r64 msysc_m$read_r64(i64 fmt);
static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt);
static void mlib_iconvlcn(u64 s, i64 n);
static void msysc_readstr(u64 dest, i64 fmt, i64 destlen);
static void msysc_rereadln();
static void msysc_reread();
static i64 msysc_valint(u64 s, i64 fmt);
static r64 msysc_valreal(u64 s);
static void msysc_mclunimpl(u64 mess);
static void msysc_addtobuffer(u64 s, i64 n);
static i64 msysc_m$sign_i64(i64 a);
static r64 msysc_m$sign_r64(r64 x);
static void mlib_pcm_init();
static i64 mlib_pcm_getac(i64 size);
static u64 mlib_allocmem(i64 n);
static void mlib_pcm_freeac(u64 p, i64 alloc);
static void mlib_pcm_clearmem(u64 p, i64 n);
static u64 mlib_pcm_allocz(i64 n);
static u64 mlib_pcm_copyheapstringn(u64 s, i64 n);
static u64 mlib_pcm_copyheapblock(u64 s, i64 length);
static u64 mlib_reallocmem(u64 p, i64 n);
static i64 mlib_getfilesize(u64 handlex);
static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size);
static i64 mlib_setfilepos(u64 file, i64 offset);
static i64 mlib_getfilepos(u64 file);
static u64 mlib_readfile(u64 filename);
static i64 mlib_writefile(u64 filename, u64 data, i64 size);
static i64 mlib_checkfile(u64 file);
static u64 mwindows_os_getstdin();
static void mlib_iconvucn(u64 s, i64 n);
static u64 mlib_extractext(u64 s, i64 period);
static u64 mlib_extractfile(u64 s);
static u64 mlib_addext(u64 s, u64 newext);
static u64 mlib_pcm_alloc32();
static void mlib_pcm_free32(u64 p);
static void mlib_outbyte(u64 f, i64 x);
static void mlib_outu16(u64 f, u64 x);
static void mlib_outu32(u64 f, u64 x);
static void mlib_outu64(u64 f, u64 x);
static void mlib_outstring(u64 f, u64 s);
static void mlib_outblock(u64 f, u64 p, i64 n);
static i64 mlib_myeof(u64 f);
static void mlib_strbuffer_add(u64 dest, u64 s, i64 n);
static void mlib_gs_init(u64 dest);
static void mlib_gs_free(u64 dest);
static void mlib_gs_str(u64 dest, u64 s);
static void mlib_gs_char(u64 dest, i64 c);
static void mlib_gs_strn(u64 dest, u64 s, i64 length);
static void mlib_gs_strvar(u64 dest, u64 s);
static void mlib_gs_strint(u64 dest, i64 a);
static void mlib_gs_strln(u64 dest, u64 s);
static void mlib_gs_line(u64 dest);
static void mlib_gs_strsp(u64 dest, u64 s);
static i64 mlib_gs_getcol(u64 dest);
static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch);
static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch);
static void mlib_gs_padto(u64 dest, i64 col, i64 ch);
static void mlib_gs_println(u64 dest, u64 f);
static i64 mlib_eqstring(u64 s, u64 t);
static void mlib_ipadstr(u64 s, i64 width, u64 padchar);
static i64 mlib_cmpstring(u64 s, u64 t);
static i64 mlib_cmpstringn(u64 s, u64 t, i64 n);
static i64 mlib_cmpbytes(u64 p, u64 q, i64 n);
static i64 mlib_eqbytes(u64 p, u64 q, i64 n);
static void mlib_mseed(u64 a, u64 b);
static u64 mlib_mrandom();
static i64 mlib_mrandomp();
static i64 mlib_mrandomint(i64 n);
static i64 mlib_mrandomrange(i64 a, i64 b);
static r64 mlib_mrandomreal();
static r64 mlib_mrandomreal1();
static u64 mlib_readline();
static u64 mlib_findfunction(u64 name);
static i64 mlib_roundtoblock(i64 n, i64 align);
static u64 mlib_pcm_allocnfz(i64 n);
static void mwindows_os_init();
static i64 mwindows_os_execwait(u64 cmdline, i64 newconsole, u64 workdir);
static i64 mwindows_os_execcmd(u64 cmdline, i64 newconsole);
static i64 mwindows_os_getch();
static i64 mwindows_os_getchx();
static i64 mwindows_os_kbhit();
static u64 mwindows_os_getdllinst(u64 name);
static u64 mwindows_os_getdllprocaddr(i64 hinst, u64 name);
static void mwindows_os_initwindows();
static void mwindows_os_setmesshandler(u64 addr);
static u64 mwindows_os_getos();
static i64 mwindows_os_gethostsize();
static i64 mwindows_os_shellexec(u64 opc, u64 file);
static void mwindows_os_sleep(i64 a);
static u64 mwindows_os_getstdout();
static u64 mwindows_os_getmpath();
static i64 mwindows_os_clock();
static i64 mwindows_os_hpcounter();
static i64 mwindows_os_ticks();
static i64 mwindows_os_iswindows();
static void mwindows_os_getsystime(u64 tm);
static u64 mwindows_os_allocexecmem(i64 n);
static i64 mwindows_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t);
static i64 mwindows_os_hpfreq();
static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes);
static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams);
static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams);
static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat);
static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d);
static u64 pc_api_pcl_start(u64 name, i64 nunits);
static void pc_api_pclerror(u64 mess);
static u64 pc_api_pc_makesymbol(u64 s, i64 id);
static void pc_api_pcl_end();
static void pc_api_pc_gen(i64 opcode, u64 p);
static u64 pc_api_pcl_writepcl(u64 filename);
static u64 pc_diags_dummy_writeallpcl();
static u64 pc_api_pcl_writepst(u64 filename);
static u64 pc_diags_dummy_writepst();
static void pc_api_pcl_genmcl();
static void mc_genmcl_dummy_genmcl();
static void pc_api_pcl_genss(i64 obj);
static void mc_genss_dummy_genss(i64 obj);
static u64 pc_api_pcl_writess(u64 filename, i64 obj);
static u64 mc_writess_dummy_writessdata(i64 fexe);
static u64 pc_api_pcl_writeasm(u64 filename, i64 atype);
static u64 mc_writeasm_dummy_getassemstr();
static void pc_api_pcl_writeobj(u64 filename);
static void mc_writeobj_dummy_writecoff(u64 outfile);
static void pc_api_pcl_writedll(u64 filename);
static void mc_writeexe_dummy_writeexe(u64 outfile, i64 dodll);
static void pc_api_pcl_writeexe(u64 filename);
static void pc_api_pcl_writemx(u64 filename);
static void mx_run_dummy_writemcx(u64 filename);
static void pc_api_pcl_exec();
static void mx_run_dummy_runlibfile(u64 filename, i64 cmdskip);
static void pc_api_pcl_setflags(i64 highmem, i64 verbose, i64 shortnames);
static void pc_api_extendpclblock();
static u64 pc_api_newpcl();
static void pc_api_pc_genix(i64 opcode, i64 scale, i64 offset);
static void pc_api_pc_genx(i64 opcode, i64 x, u64 p);
static void pc_api_pc_genxy(i64 opcode, i64 x, i64 y, u64 p);
static void pc_api_pc_gencond(i64 opcode, i64 cond, u64 p);
static u64 pc_api_genint(i64 a);
static u64 pc_api_genreal(r64 x, i64 mode);
static u64 pc_api_genrealimm(r64 x, i64 mode);
static u64 pc_api_genstring(u64 s);
static u64 pc_api_genpcstrimm(u64 s);
static u64 pc_api_genlabel(i64 a);
static u64 pc_api_genmem(u64 d);
static u64 pc_api_genmemaddr(u64 d);
static u64 pc_api_gendata(u64 s, i64 length);
static void pc_api_gencomment(u64 s);
static u64 pc_api_genname(u64 s);
static u64 pc_api_gennameaddr(u64 s);
static u64 pc_api_genassem(u64 code);
static void pc_api_pc_setmode(i64 m, i64 size);
static void pc_api_pc_setmode2(i64 m);
static void pc_api_pc_setxy(i64 x, i64 y);
static void pc_api_pc_setscaleoff(i64 scale, i64 offset);
static void pc_api_pc_setoffset(i64 offset);
static void pc_api_pc_addoffset(i64 offset);
static void pc_api_pc_setincr(i64 n);
static void pc_api_pc_setnargs(i64 n);
static void pc_api_pc_setnvariadics(i64 n);
static void pc_api_pc_setalign(i64 n);
static void pc_api_perror(u64 mess);
static void pc_api_perror_s(u64 mess, u64 param);
static u64 pc_api_getbasename(u64 s);
static void pc_api_pc_addsymbol(u64 d);
static void pc_api_pcerrorstop(u64 filename, i64 lineno);
static void pc_api_pc_addplib(u64 name);
static void pc_api_pc_defproc(u64 d, i64 mode, i64 isentry, i64 threaded);
static void pc_api_pc_setimport(u64 d);
static void pc_api_pc_addparam(u64 d);
static void pc_api_pc_addlocal(u64 d);
static void pc_api_pc_endproc();
static void pc_api_merror(u64 mess, u64 param);
static u64 pc_api_pc_duplpst(u64 d);
static void pc_api_pcl_cmdskip(i64 cmdskip, u64 dcmdskip);
static i64 pc_api_convertstring(u64 s, u64 t);
static void pc_diags_dummy_pshowlogfile();
static void pc_diags_dummy_strpcl(u64 p);
static u64 pc_diags_dummy_stropnd(u64 p);
static u64 pc_diags_dummy_strpclstr(u64 p, i64 buffsize);
static void pc_diags_dummy_writepcl(u64 p);
static void pc_reduce_pcl_reducetest();
static i64 pc_run_dispatch_loop(u64 pcentry, i64 cmain);
static i64 pc_runaux_pci_getopnd(u64 p, u64 locals);
static i64 pc_runaux_pci_loadptr(u64 p, i64 mode);
static void pc_runaux_pci_storeptr(u64 p, i64 a, i64 mode, i64 size);
static void pc_runaux_pcusopnd(u64 p);
static u64 pc_runaux_pci_loadbf(u64 a, u64 i, u64 j);
static u64 pc_runaux_pci_storebf(u64 a, u64 i, u64 j, u64 x);
static i64 pc_run_getlineno(u64 pc);
static void pc_runaux_pcerrorx(u64 p, u64 mess, u64 param);
static i64 pc_runaux_docalldll(u64 d, u64 fnaddr, u64 revargs, i64 nargs, i64 nvars, i64 retmode);
static i64 pc_runaux_cmpreal(i64 cond, r64 x, r64 y);
static i64 pc_runaux_cmpint(i64 cond, i64 x, i64 y);
static i64 pc_runaux_cmpword(i64 cond, u64 x, u64 y);
static u64 pc_runaux_pci_getopndaddr(u64 p, u64 locals);
static void pc_runaux_doincr(u64 pu8, i64 incr, i64 mode);
static void pc_run_fixuppcl();
static u64 pc_runaux_getdllfnptr(u64 d);
static void pc_run_pcl_runpcl();
static void pc_runaux_loadlibs();
static void pc_runaux_docmdskip();
static void mc_decls_start();
static u64 mc_writeasm_dummy_getdispname(u64 d);
static u64 mc_writeasm_dummy_gettempname(u64 d, i64 n);
static u64 mc_writeasm_dummy_strmclstr(u64 m);
static void mc_writeexe_dummy_genexe(u64 entrypoint, u64 outfile, i64 dodll);
void mmi_main();
static void pclint_start();
static void mmi_start();
static void mm_cli_main2();
static void mm_cli_initdata();
static void mm_cli_getinputoptions();
static void mm_cli_production_compiler();
static void mm_cli_debug_compiler();
static void mm_modules_loadproject(u64 file);
static void mm_cli_do_parse(i64 flog);
static void mm_cli_do_name(i64 flog);
static void mm_cli_do_type(i64 flog);
static void mm_cli_do_genpcl(i64 flog);
static void mm_cli_do_genmcl(i64 flog);
static void mm_diags_dummy_showtimings();
static void mm_diags_dummy_showlogfile();
static void mm_cli_showcompilemess();
static void mm_support_do_writema(u64 inpfile);
static void mm_support_do_getinfo(u64 filename);
static void mm_cli_do_writeexports();
static i64 mm_parse_parsemodule(u64 pm);
static void mm_name_fixusertypes();
static void mm_cli_fixstartprocs();
static void mm_diags_dummy_showast(u64 filename);
static void mm_name_rx_typetable();
static i64 mm_name_rx_module(i64 n);
static void mm_type_tx_typetable();
static i64 mm_type_tx_module(i64 n);
static void mm_type_tx_allprocs();
static void mm_genpcl_codegen_il(u64 dummy);
static void mm_lex_lexsetup();
static void mm_assem_dummy_initassemsymbols();
static void mm_support_init_tt_tables();
static void mm_support_initbblib();
static u64 mm_lex_addnamestr(u64 name);
static u64 mm_lib_createdupldef(u64 owner, u64 symptr, i64 id);
static i64 mm_support_mgetsourceinfo(i64 pos, u64 filename, u64 sourceline);
static void mm_assemaux_dummy_domcl_assem(u64 pcode);
static u64 mm_genpcl_findhostfn(i64 opc);
static i64 mm_assemaux_dummy_checkasmlabel(u64 p);
static void mm_support_loaderror(u64 mess, u64 mess2, u64 mess3);
static void mm_cli_showcaption();
static void mm_cli_showhelp();
static void mm_exportm_writeexports(u64 basefile, u64 modulename);
static u64 mm_cli_getoutfilename(u64 file, u64 ext);
static u64 mm_cli_addstartproc(u64 owner, u64 name, i64 scope, i64 moduleno);
static u64 mm_lib_getduplnameptr(u64 owner, u64 symptr, i64 id);
static u64 mm_parse_makeblock(u64 p);
static void mm_lib_adddef(u64 owner, u64 p);
static void mm_lib_addtoproclist(u64 d);
static void mm_blockpcl_evalunit(u64 p);
static void mm_blockpcl_do_const(u64 p);
static void mm_blockpcl_do_name(u64 p);
static void mm_blockpcl_do_block(u64 p);
static void mm_blockpcl_do_callproc(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_return(u64 p, u64 a);
static void mm_blockpcl_do_returnmult(u64 p, u64 a);
static void mm_blockpcl_do_assign(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_assignms(u64 a, u64 b);
static void mm_blockpcl_do_assignmm(u64 a, u64 b);
static void mm_blockpcl_do_assignmdrem(u64 a, u64 b);
static void mm_blockpcl_do_to(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_if(u64 p, u64 pcond, u64 plist, u64 pelse, i64 isref);
static void mm_blockpcl_do_for(u64 p, u64 pindex, u64 pfrom, u64 pbody, i64 down);
static void mm_blockpcl_do_forall(u64 p, u64 pindex, u64 plist, u64 pbody, i64 down);
static void mm_blockpcl_do_while(u64 p, u64 pcond, u64 pbody, u64 pincr);
static void mm_blockpcl_do_repeat(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_goto(u64 a);
static void mm_blockpcl_do_labeldef(u64 p);
static void mm_blockpcl_do_exit(u64 p, i64 k);
static void mm_blockpcl_do_do(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_case(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 loopsw, i64 isref);
static void mm_blockpcl_do_switch(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 isref);
static void mm_blockpcl_do_recase(u64 p, u64 a);
static void mm_blockpcl_do_swap(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_select(u64 p, u64 a, u64 b, u64 c, i64 isref);
static void mm_blockpcl_do_print(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_read(u64 p, u64 a);
static void mm_blockpcl_do_readln(u64 a);
static void mm_blockpcl_do_stop(u64 p, u64 a);
static void mm_libpcl_setmode_u(u64 p);
static void mm_blockpcl_do_andl(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_orl(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_setcc(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_setccchain(u64 p, u64 q);
static void mm_blockpcl_do_bin(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_index(u64 p, u64 parray, u64 pindex);
static void mm_blockpcl_do_dotindex(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_dotslice(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_dot(u64 pdot);
static void mm_blockpcl_do_ptr(u64 p, u64 a);
static void mm_blockpcl_evalref(u64 p, u64 q);
static void mm_blockpcl_do_convert(u64 p, u64 a);
static void mm_blockpcl_do_typepun(u64 p, u64 a);
static void mm_blockpcl_do_shorten(u64 p, u64 a);
static void mm_blockpcl_do_typeconst(u64 p);
static void mm_blockpcl_do_unary(u64 p, u64 a);
static void mm_blockpcl_do_notl(u64 p, u64 a);
static void mm_blockpcl_do_istruel(u64 p, u64 a);
static void mm_blockpcl_do_isfalsel(u64 p, u64 a);
static void mm_blockpcl_do_incr(u64 p, u64 a);
static void mm_blockpcl_do_incrload(u64 p, u64 a);
static void mm_blockpcl_do_binto(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_unaryto(u64 p, u64 a);
static void mm_blockpcl_do_syscall(u64 p, u64 a);
static void mm_blockpcl_do_empty(u64 p, u64 a);
static void mm_blockpcl_do_slice(u64 p, u64 a, u64 b);
static void mm_support_gerror_s(u64 mess, u64 s, u64 p);
static void mm_diags_dummy_printunit(u64 p, i64 level, u64 prefix, u64 dev);
static void mm_support_gerror(u64 mess, u64 p);
static void mm_genpcl_genpushmemaddr_d(u64 d);
static void mm_libpcl_setmode(i64 mode);
static void mm_genpcl_genpushint(i64 a);
static void mm_blockpcl_do_indexref(u64 parray, u64 pindex);
static void mm_blockpcl_do_dotref(u64 pdot);
static void mm_blockpcl_evalarray(u64 p);
static void mm_blockpcl_genjumpcond(i64 opc, u64 p, i64 lab);
static i64 mm_genpcl_createfwdlabel();
static void mm_genpcl_definefwdlabel(i64 lab);
static void mm_blockpcl_gcomparejump(i64 jumpopc, i64 cond, u64 lhs, u64 rhs, i64 lab);
static i64 mm_genpcl_reversecond(i64 cc);
static i64 mm_genpcl_reversecond_order(i64 cc);
static void mm_blockpcl_genjumpl(i64 lab);
static void mm_blockpcl_unimpl(u64 mess);
static i64 mm_lib_getpclmode(i64 t);
static void mm_genpcl_genpushreal(r64 x, i64 mode);
static void mm_genpcl_genpushstring(u64 s);
static void mm_genpcl_genpushmem_d(u64 d);
static void mm_libpcl_setmode2(i64 mode);
static void mm_blockpcl_do_assignblock(u64 p, u64 a, u64 b);
static void mm_blockpcl_do_storeindex(u64 p, u64 parray, u64 pindex, u64 rhs);
static void mm_blockpcl_do_storedot(u64 pdot, u64 pfield, u64 rhs);
static u64 mm_genpcl_genmem_u(u64 p);
static void mm_blockpcl_do_setinplace();
static u64 mm_genpcl_genmemaddr_d(u64 d);
static i64 mm_genpcl_definelabel();
static void mm_genpcl_stacklooplabels(i64 a, i64 b, i64 c);
static void mm_blockpcl_docond(i64 opc, u64 p, i64 lab);
static i64 mm_genpcl_findlooplabel(i64 k, i64 n);
static void mm_genpcl_genpc_sysproc(i64 fnindex, u64 a, u64 b, u64 c, i64 asfunc);
static void mm_blockpcl_setincrstep(i64 m);
static u64 mm_lib_getavname(u64 owner, i64 id);
static u64 mm_genpcl_genmem_d(u64 d);
static u64 mm_lib_createname(u64 p);
static i64 mm_blockpcl_checkdotchain(u64 p, u64 pname);
static i64 mm_lib_createrefmode(u64 owner, i64 target, i64 typedefx);
static i64 mm_blockpcl_getindexoffset(u64 parray, u64 pindex);
static u64 mm_lib_strexpr(u64 p);
static void mm_genpcl_genpc_sysfn(i64 fnindex, u64 a, u64 b, u64 c);
static void mm_genpcl_setfunctab();
static void mm_blockpcl_do_assignarray(u64 a, u64 b);
static void mm_blockpcl_do_assignrecord(u64 a, u64 b);
static u64 mm_lib_createconstunit(u64 a, i64 t);
static u64 mm_lib_createunit2(i64 tag, u64 p, u64 q);
static u64 mm_lib_createunit0(i64 tag);
static void mm_blockpcl_pushrhs(u64 a);
static void mm_blockpcl_poptomult(u64 a);
static u64 mm_lib_getprocretmodes(u64 p);
static u64 mm_assem_dummy_readassemline();
static void mm_lex_lex();
static u64 mm_assem_dummy_readassemblock();
static void mm_diags_dummy_printmodelist(u64 f);
static void mm_diags_dummy_printst(u64 f, u64 p, i64 level);
static void mm_diags_dummy_printstrec(u64 f, u64 p, i64 level);
static void mm_diags_dummy_printstflat(u64 f);
static void mm_diags_dummy_printcode(u64 f, u64 caption);
static void mm_diags_dummy_printunitlist(u64 dev, u64 p, i64 level, u64 prefix);
static void mm_diags_dummy_showprojectinfo(u64 dev);
static void mm_diags_dummy_printsymbol(u64 lp);
static void mm_exportm_wxstr(u64 s);
static void mm_exportm_wxstrln(u64 s);
static void mm_exportm_exportrecord(u64 d);
static void mm_exportm_wxline();
static void mm_exportm_exportstatic(u64 d);
static void mm_exportm_exportconst(u64 d);
static void mm_exportm_exportproc(u64 d);
static void mm_exportm_wxmode(i64 mode);
static void mm_lib_jevalx2(u64 dest, u64 p);
static void mm_genpcl_dolibs();
static void mm_genpcl_dostaticvar(u64 d);
static void mm_genpcl_gendllproc(u64 p);
static void mm_genpcl_genprocdef(u64 p);
static void mm_genpcl_scanprocs();
static void mm_genpcl_genmaindef(u64 p);
static void mm_genpcl_genstartdef(u64 p);
static void mm_genpcl_doprocdef(u64 d, i64 ismain);
static void mm_genpcl_genreturn();
static u64 mm_libpcl_getpsymbol(u64 d);
static i64 mm_lib_getalignment(i64 m);
static void mm_genpcl_genidata(u64 p, i64 doterm, i64 am, i64 offset);
static void mm_genpcl_pushsysarg(u64 p, i64 n, u64 nargs);
static u64 mm_genpcl_getsysfnhandler(i64 fn);
static void mm_genpcl_start();
static void mm_genpcl_docallproc(u64 d);
static void mm_genpcl_initstaticvar(u64 d);
static void mm_lex_lexreadtoken();
static void mm_lex_doinclude();
static void mm_support_lxerror(u64 mess);
static i64 mm_lex_setinttype(u64 a);
static void mm_lex_readrawstring();
static void mm_lex_readarraystring(i64 prefix);
static void mm_lex_lookup(u64 name, i64 length, i64 hashindex);
static void mm_lex_readhex();
static void mm_lex_readbin();
static void mm_lex_readdec();
static void mm_lex_lxreadstring(i64 termchar);
static void mm_lex_readrawxname();
static void mm_lex_unstacksource();
static void mm_lex_inithashtable();
static void mm_lex_printstrn(u64 s, i64 length);
static i64 mm_lex_lookupsys(u64 name);
static i64 mm_lex_gethashvaluez(u64 s);
static void mm_lex_printhashtable();
static void mm_lex_addreservedword(u64 name, i64 symbol, i64 subcode, i64 regsize);
static u64 mm_support_getsupportfile(u64 filename, u64 ext, u64 path);
static void mm_lex_stacksource(i64 fileno, i64 isimport);
static void mm_lex_startlex(u64 file);
static void mm_lex_ps(u64 caption);
static void mm_lex_psnext(u64 caption);
static void mm_lex_psx(u64 caption);
static void mm_lex_lxerror_s(u64 mess, u64 s);
static i64 mm_lex_readhexcode(u64 s, i64 n, i64 sp);
static i64 mm_lex_getutf8(i64 c, u64 s);
static void mm_lex_readreal();
static void mm_lex_nodecimal();
static void mm_lex_start();
static u64 mm_lib_newstrec();
static void mm_support_serror(u64 mess);
static u64 mm_lib_allocunitrec();
static u64 mm_lib_createunit1(i64 tag, u64 p);
static u64 mm_lib_createunit3(i64 tag, u64 p, u64 q, u64 r);
static void mm_lib_insertunit(u64 p, i64 tag);
static void mm_lib_deleteunit(u64 p, u64 q);
static u64 mm_lib_createstringconstunit(u64 s, i64 length);
static i64 mm_lib_newtypename(u64 a, u64 b);
static i64 mm_lib_createusertype(u64 stname);
static i64 mm_lib_createusertypefromstr(u64 name);
static u64 mm_lib_getrangelwbunit(u64 p);
static u64 mm_lib_getrangeupbunit(u64 p);
static i64 mm_lib_createarraymode(u64 owner, i64 target, u64 dimexpr, i64 typedefx);
static i64 mm_lib_storemode(u64 owner, i64 m, u64 pmode);
static i64 mm_lib_sameunit(u64 p, u64 q, u64 powner, u64 qowner);
static i64 mm_lib_createarraymodek(u64 owner, i64 target, i64 lower, i64 length, i64 typedefx);
static i64 mm_lib_createslicemode(u64 owner, i64 slicetype, i64 target, u64 dimexpr, i64 typedefx);
static i64 mm_lib_createslicemodek(u64 owner, i64 target, i64 lower, i64 typedefx);
static i64 mm_lib_createrefprocmode(u64 owner, u64 stproc, u64 paramlist, i64 kwd, i64 prettype, i64 typedefx);
static void mm_lib_copyttvalues(i64 dest, i64 source);
static void mm_lib_unionstr_clear(u64 u);
static void mm_lib_unionstr_append(u64 u, i64 c);
static void mm_lib_unionstr_concat(u64 u, u64 v);
static i64 mm_lib_unionstr_last(u64 u);
static void mm_lib_unionstr_copy(u64 u, u64 v);
static i64 mm_lib_createrecordmode(u64 owner, i64 typedefx);
static i64 mm_lib_createtuplemode(u64 owner, u64 elements, i64 elementslen, i64 typedefx);
static void mm_lib_jevalx(u64 p);
static void mm_lib_jadditem(u64 s);
static void mm_lib_jaddstr(u64 s);
static void mm_support_gs_additem(u64 dest, u64 s);
static void mm_lib_istrmode(i64 m, i64 expand, u64 dest);
static u64 mm_lib_typename(i64 m);
static void mm_support_gs_copytostr(u64 source, u64 s);
static void mm_support_mcerror(u64 mess);
static void mm_lib_addstatic(u64 d);
static void mm_lib_addexpconst(u64 d);
static u64 mm_lib_createnewmoduledef(u64 owner, u64 symptr, i64 id);
static u64 mm_lib_duplunit(u64 p, i64 lineno);
static i64 mm_lib_isconstunit(u64 a);
static void mm_lib_getownername(u64 d, u64 dest);
static void mm_lib_addlistunit(u64 ulist, u64 ulistx, u64 p);
static i64 mm_lib_gettypebase(i64 m);
static void mm_lib_writegsfile(u64 filename, u64 d);
static void mm_lib_addtolog(u64 filename, u64 logdest);
static void mm_support_txerror(u64 mess, u64 p);
static u64 mm_libpcl_getequivdef(u64 d);
static void mm_libsources_loadbuiltins();
static u64 mm_support_newsourcefile();
static u64 mm_modules_loadsp(u64 filename, i64 mainsub);
static u64 mm_modules_loadmodule(u64 filespec, i64 issyslib);
static void mm_parse_skipsemi();
static void mm_parse_lexchecksymbol(i64 symbol);
static void mm_parse_checksymbol(i64 symbol);
static void mm_modules_addlib(u64 libname);
static void mm_parse_checkend(i64 endsym, i64 endkwd1, i64 endkwd2, i64 startline);
static void mm_support_serror_s(u64 mess, u64 a);
static u64 mm_modules_loadsourcefile(u64 filespec, i64 issyslib);
static void mm_modules_loadsyslib();
static void mm_modules_loadmafile(u64 filespec, u64 builtinstr);
static u64 mm_modules_readfileline(u64 s);
static u64 mm_modules_findnextlineheader(u64 s);
static void mm_name_do_baseclass(u64 p);
static void mm_name_rx_unit(u64 owner, u64 p);
static void mm_name_resolvename(u64 owner, u64 p);
static void mm_name_expandmacro(u64 p, u64 a, u64 b);
static void mm_name_resolvedot(u64 owner, u64 p);
static void mm_name_rx_unitlist(u64 owner, u64 p);
static void mm_name_rx_passdef(u64 owner, u64 p);
static void mm_name_rx_deflist(u64 owner, u64 p);
static u64 mm_name_resolvetopname(u64 owner, u64 stnewname, i64 moduleno, i64 allowmod);
static void mm_support_rxerror_s(u64 mess, u64 a, u64 p);
static u64 mm_name_addframevar(u64 owner, u64 d, i64 moduleno, i64 mode);
static u64 mm_name_finddupl(u64 d, u64 pdupl);
static u64 mm_name_finddupl_sub(u64 d, u64 pdupl);
static void mm_support_rxerror(u64 mess, u64 p);
static void mm_name_fixmode(u64 p);
static u64 mm_name_copylistunit(u64 p);
static u64 mm_name_copyunit(u64 p);
static void mm_name_replaceunit(u64 p, u64 q);
static void mm_name_duplfield(u64 owner, u64 p, u64 q);
static void mm_parse_initparser();
static void mm_parse_readmoduledefs(u64 owner);
static void mm_parse_readprocdef(u64 procowner, i64 scope);
static u64 mm_parse_readvardef(u64 owner, i64 scope, i64 isstatic, i64 varid, i64 k);
static void mm_parse_readimportmodule(u64 owner);
static void mm_parse_readtypedef(u64 owner, i64 scope);
static void mm_parse_readconstdef(u64 owner, i64 scope);
static void mm_parse_readclassdef(u64 owner, i64 scope);
static void mm_parse_readtabledef(u64 owner, i64 scope);
static void mm_parse_readmacrodef(u64 owner, i64 scope);
static i64 mm_parse_istypestarter();
static void mm_parse_checkequals();
static i64 mm_parse_getcurrline();
static i64 mm_parse_checkbegin(i64 fbrack);
static void mm_parse_checkbeginend(i64 closesym, i64 kwd, i64 startline);
static void mm_parse_checksymbollex(i64 symbol);
static i64 mm_parse_readtypespec(u64 owner, i64 typedefx);
static u64 mm_parse_readunit();
static u64 mm_parse_readconstexpr(i64 needconst);
static u64 mm_parse_readlbrack();
static u64 mm_parse_readsunit(i64 inwhile);
static u64 mm_parse_fixcond(u64 p);
static void mm_parse_addlistparam(u64 ulist, u64 ulistx, u64 p);
static u64 mm_parse_readcast();
static u64 mm_parse_readopc();
static u64 mm_parse_readterm2();
static i64 mm_support_getlineno(u64 pos);
static u64 mm_parse_readcastx();
static i64 mm_parse_readrefproc(u64 owner, i64 typedefx);
static i64 mm_parse_readslicetype(u64 owner, i64 slicetype, i64 typedefx);
static u64 mm_parse_readslist(i64 iscall, i64 donulls);
static u64 mm_parse_readindex(u64 p, i64 dot);
static u64 mm_parse_readdotsuffix(u64 p);
static i64 mm_parse_readconstint();
static u64 mm_parse_readprocdecl(u64 procowner, i64 scope);
static void mm_parse_pushproc(u64 p);
static void mm_parse_popproc();
static u64 mm_parse_readparams(u64 procowner, u64 owner, u64 varparams, u64 nparams);
static i64 mm_parse_readreturntype(u64 owner, u64 retmodes);
static u64 mm_parse_readcondsuffix(u64 p);
static u64 mm_parse_readif();
static u64 mm_parse_readswitchcase();
static u64 mm_parse_readgoto(i64 gototag);
static u64 mm_parse_readunless();
static u64 mm_parse_readstop();
static u64 mm_parse_readreturn();
static u64 mm_parse_readdo();
static u64 mm_parse_readto();
static u64 mm_parse_readwhile();
static u64 mm_parse_readrepeat();
static u64 mm_parse_readloopcontrol();
static u64 mm_parse_readprint();
static u64 mm_parse_readread();
static u64 mm_parse_readfor();
static u64 mm_parse_readname();
static void mm_parse_readrecordfields(u64 owner, i64 m);
static u64 mm_parse_readequivfield(u64 owner);
static void mm_parse_readclassbody(u64 owner, i64 classkwd);
static void mm_parse_readimportbody(u64 owner);
static u64 mm_parse_readset();
static u64 mm_parse_readassignment(u64 pt);
static u64 mm_parse_readorterms(u64 pt);
static u64 mm_parse_readandterms(u64 pt);
static u64 mm_parse_readcmpterms(u64 pt);
static u64 mm_parse_readinterms(u64 pt);
static u64 mm_parse_readrangeterm(u64 pt);
static u64 mm_parse_readaddterms(u64 pt);
static u64 mm_parse_readmulterms(u64 pt);
static u64 mm_parse_readpowerterms(u64 p);
static u64 mm_parse_readterm();
static u64 mm_parse_readrecase();
static void mm_parse_checknotempty(u64 p);
static u64 mm_parse_readbxdata();
static void mm_support_serror_gen(u64 mess);
static void mm_support_showdivider(u64 ch);
static void mm_support_showerrorsource(i64 pos, u64 stproc);
static void mm_support_stopcompiler(u64 filename, i64 lineno);
static i64 mm_support_getfileno(u64 pos);
static u64 mm_support_getsourceline(u64 pos);
static u64 mm_support_getsourcepos(u64 pos);
static void mm_support_error_gen(i64 pass, u64 mess, u64 p);
static void mm_support_txerror_s(u64 mess, u64 a, u64 p);
static void mm_support_txerror_ss(u64 mess, u64 a, u64 b);
static void mm_support_lxerror_gen(u64 mess);
static i64 mm_support_isalphanum(i64 c);
static i64 mm_support_isabspath(u64 filespec);
static u64 mm_support_getsourcestart(u64 pos);
static void mm_support_getst(u64 f, u64 d);
static void mm_support_getstrec(u64 f, u64 d);
static void mm_tables_start();
static void mm_type_tx_name(u64 p, i64 t, i64 lv);
static void mm_type_tx_bin(u64 p, u64 a, u64 b);
static i64 mm_type_tx_in(u64 p, u64 a, u64 b);
static void mm_type_tx_unary(u64 p, u64 a);
static void mm_type_tx_prop(u64 p, u64 a);
static void mm_type_tx_binto(u64 p, u64 a, u64 b);
static void mm_type_tx_unaryto(u64 p, u64 a);
static void mm_type_tpasslv(u64 p, i64 t);
static void mm_type_tx_addroffirst(u64 p, u64 a, i64 t);
static void mm_type_tx_if(u64 p, u64 pcond, u64 plist, u64 pelse, i64 t, i64 lv);
static void mm_type_tx_index(u64 p, u64 a, u64 b, i64 t, i64 lv);
static void mm_type_tx_ptr(u64 p, u64 a, i64 t, i64 lv);
static void mm_type_tx_callproc(u64 p, u64 a, u64 pargs, i64 t);
static void mm_type_tx_dot(u64 p, u64 a, u64 b, i64 lv);
static void mm_type_tx_andl(u64 p, u64 a, u64 b);
static void mm_type_tx_notl(u64 p, u64 a);
static void mm_type_tx_convert(u64 p, u64 a, i64 hard);
static void mm_type_tx_typepun(u64 p, u64 a);
static void mm_type_tx_incrto(u64 p, u64 a, i64 t);
static void mm_type_tx_makerange(u64 p, u64 a, u64 b);
static void mm_type_tx_swap(u64 p, u64 a, u64 b);
static void mm_type_tx_select(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv);
static void mm_type_tx_switch(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv);
static void mm_type_tx_case(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv);
static void mm_type_tx_dotindex(u64 p, u64 a, u64 b, i64 lv);
static void mm_type_tx_slice(u64 p, u64 a, u64 b);
static void mm_type_tx_block(u64 p, u64 a, i64 t, i64 lv);
static void mm_type_tx_return(u64 p, u64 a, i64 t);
static void mm_type_tx_unitlist(u64 p, i64 t, i64 lv);
static void mm_type_fixchararray(u64 a);
static void mm_type_tx_for(u64 pindex, u64 pfrom, u64 pbody);
static void mm_type_tx_forall(u64 pindex, u64 plist, u64 pbody);
static void mm_type_coerceunit(u64 p, i64 t, i64 hard);
static void mm_type_tx_makelist(u64 p, u64 a, i64 t, i64 lv);
static void mm_type_tx_exit(u64 p, u64 a);
static void mm_type_tx_goto(u64 p, u64 a);
static i64 mm_type_iscondtrue(u64 p);
static i64 mm_type_iscondfalse(u64 p);
static void mm_type_tx_bitfield(u64 p, u64 a, i64 lv);
static void mm_type_tx_cmpchain(u64 p, u64 a);
static void mm_type_tx_strinclude(u64 p, u64 a);
static void mm_type_tx_makeslice(u64 p, u64 a, u64 b, i64 t);
static void mm_type_tx_makeset(u64 p, u64 a, i64 t);
static void mm_type_tevaluate(u64 p);
static void mm_type_tx_passdef(u64 p);
static void mm_type_setmodesize(i64 m);
static void mm_type_setarraysize(i64 m);
static void mm_type_setslicesize(i64 m);
static i64 mm_type_getconstint(u64 q);
static void mm_type_checkblocktype(i64 m);
static void mm_type_tx_namedconst(u64 d);
static void mm_type_tx_namedef(u64 d);
static void mm_type_checkconstexpr(u64 p);
static void mm_type_makenewconst(u64 p, i64 x, i64 t);
static void mm_type_twiden(u64 p, i64 lv);
static i64 mm_type_dobinnumx(u64 p, u64 a, u64 b);
static void mm_type_combinestrings(u64 p);
static i64 mm_type_comparemodes(i64 s, i64 t);
static void mm_type_mulstrings(u64 p);
static i64 mm_type_dobinnumf(u64 p, u64 a, u64 b);
static i64 mm_type_dobinnumi(u64 p, u64 a, u64 b);
static i64 mm_type_getdominantmode(i64 amode, i64 bmode);
static void mm_type_tmethodcall(u64 p, u64 pdot, u64 pargs);
static void mm_type_do_bounds(u64 p, u64 a);
static void mm_type_deref(u64 a, i64 needres);
static void mm_type_scanrecord(i64 state, u64 fields, u64 index, u64 isize, i64 offset, i64 calign, u64 maxalign);
static i64 mm_type_roundoffset(i64 offset, i64 alignment);
static void mm_type_tx_makeslicefromlist(u64 p, u64 a, i64 t);
static u64 mm_type_resolvefield(u64 d, i64 m);
static void mm_type_convintconst(u64 p, i64 x);
static void mm_type_tx_sliceptr(u64 p, u64 a);
static void mm_type_tstringslice(u64 p, i64 slicemode);
static void mm_type_addnotl(u64 p);
static void mm_type_tevalbinop(u64 p);
static void mm_type_tevalmonop(u64 p);
static u64 mm_type_addrdotindex(u64 p, u64 offset);
static void mm_type_applyconversion(u64 p, i64 s, i64 t, i64 opc);
static i64 mm_type_tevalconvert(u64 p, i64 s, i64 t, i64 opc);
static void mm_type_checkmodes(i64 s, i64 t);
static void mm_type_tx_assignmultmult(u64 pp, u64 a, u64 b);
static void mm_type_tx_assignmultscalar(u64 pp, u64 a, u64 b, i64 t);


int main(int nargs, char** args) {
    msysc_$getcommands(nargs, (u64)args, 0);
    mmi_main();
}

// **************************************************
static i64 msysc_fmtparam;
i64 msysc_$cmdskip;
static i64 msysc_needgap = 0;

static i64 msysc_outdev = 1;

static u64 msysc_outchan = 0;

static u64 msysc_fmtstr = 0;

static struct $B1 msysc_outchan_stack;
static struct $B1 msysc_outdev_stack;
static struct $B1 msysc_fmtstr_stack;
static struct $B2 msysc_needgap_stack;
static struct $B1 msysc_ptr_stack;
static i64 msysc_niostack = 0;

static struct $B3 msysc_digits = {{
3978425819141910832,
5063528411713059128}};

static struct $B3 msysc_defaultfmt = {{
112287625641984,
20992}};

static u64 msysc_rd_buffer;
static i64 msysc_rd_length;
static u64 msysc_rd_pos;
static u64 msysc_rd_lastpos;
static i64 msysc_termchar;
static i64 msysc_itemerror;
static struct $B4 msysc_printbuffer;
static u64 msysc_printptr;
static i64 msysc_printlen;
static i64 msysc_ncmdparams;
static u64 msysc_cmdparams;
static struct $B3 msysc_getfmt_fmt;
static struct $B5 msysc_strint_str;
static struct $B5 msysc_strword_str;
static struct $B6 msysc_strreal_str;
static struct $B7 mlib_allocupper;
static i64 mlib_alloccode;
static i64 mlib_allocbytes;
static i64 mlib_fdebug = 0;

static i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static u8 mlib_pcm_setup = 0;

static i64 mlib_show = 0;

static i64 mlib_memtotal = 0;

static i64 mlib_smallmemtotal = 0;

static i64 mlib_smallmemobjs = 0;

static i64 mlib_maxmemtotal = 0;

static struct $B8 mlib_memalloctable;
static struct $B9 mlib_memallocsize;
static u64 mlib_pcheapstart;
static u64 mlib_pcheapend;
static u64 mlib_pcheapptr;
static struct $B10 mlib_sizeindextable;
static struct $B11 mlib_freelist;
static struct $B12 mlib_pmnames = {{
(u64)"pm_end",
(u64)"pm_option",
(u64)"pm_sourcefile",
(u64)"pm_libfile",
(u64)"pm_colon",
(u64)"pm_extra"}};

static struct $B3 mlib_seed = {{
2993073034246558322,
1617678968452121188}};

static i64 mlib_pcm_newblock_totalheapsize;
// Istatic skipped:mlib.pcm_round.allocbytes

static struct $B14 mlib_changeext_newfile;
static struct $B14 mlib_extractpath_str;
static struct $B5 mlib_extractbasefile_str;
// Istatic skipped:mlib.nextcmdparamnew.infile

// Istatic skipped:mlib.nextcmdparamnew.filestart

// Istatic skipped:mlib.nextcmdparamnew.fileptr

// Istatic skipped:mlib.nextcmdparamnew.colonseen

static struct $B15 mlib_nextcmdparamnew_str;
static struct $B16 mlib_readnextfileitem_str;
static struct $B16 mlib_padstr_str;
static u64 mlib_chr_str;
static u64 mwindows_hconsole;
static u64 mwindows_hconsolein;
static struct $B17 mwindows_lastkey;
static struct $B17 mwindows_pendkey;
static i64 mwindows_keypending;
static i64 mwindows_hpfreq;
static u64 mwindows_wndproc_callbackfn = 0;

static i64 mwindows_init_flag = 0;

static u8 mwindows_os_gxregisterclass_registered;
// Istatic skipped:mwindows.mainwndproc.count

static struct $B15 mwindows_os_gethostname_name;
static i64 mwindows_os_gethostname_n;
static i64 mwindows_os_peek_lastticks;
static u8 pclint_pc_userunpcl = 1;

static u8 pclint_ctarget = 0;

static i64 pc_api_pclseqno;
static i64 pc_api_stseqno;
static u64 pc_api_pcstart;
static u64 pc_api_pccurr;
static u64 pc_api_pcend;
static i64 pc_api_pcalloc;
static u8 pc_api_pcfixed;
static i64 pc_api_pcseqno;
static i64 pc_api_pcneedfntable;
static i64 pc_api_initpcalloc = 65536;

static u64 pc_api_longstring;
static i64 pc_api_longstringlen;
static i64 pc_api_mlabelno;
static u8 pc_api_phighmem;
static u8 pc_api_pfullsys;
static u8 pc_api_fpshortnames;
static u64 pc_api_idomcl_assem;
static u64 pc_api_icheckasmlabel;
static u64 pc_api_igethostfn;
static struct $B18 pc_api_strpmode_str;
static struct $B16 pc_api_getfullname_str;
static struct $B16 pc_api_addstr_str;
static u64 pc_decls_pinfo;
static i64 pc_decls_bspill;
static i64 pc_decls_bxspill;
static u8 pc_decls_r10used;
static u8 pc_decls_r11used;
static u8 pc_decls_localshadow;
static i64 pc_decls_mmpos;
static u64 pc_decls_psymboltable;
static u64 pc_decls_psymboltablex;
static u64 pc_decls_currprog;
static u64 pc_decls_currfunc;
static u64 pc_decls_blockretname;
static u64 pc_decls_entryproc;
static struct $B3 pc_decls_sbuffer;
static u64 pc_decls_pdest = (u64)&pc_decls_sbuffer;

static struct $B19 pc_decls_plibfiles;
static struct $B19 pc_decls_plibinst;
static i64 pc_decls_nplibfiles;
static u64 pc_decls_igetmsourceinfo;
static u8 pc_decls_pcldone;
static u8 pc_decls_mcldone;
static u8 pc_decls_ssdone;
static u8 pc_decls_objdone;
static u8 pc_decls_exedone;
static u8 pc_decls_pverbose;
static i64 pc_decls_pcmdskip;
static i64 pc_decls_assemtype = 16705;

static i64 pc_decls_ppseqno;
static u8 pc_decls_fpeephole = 1;

static u8 pc_decls_fregoptim = 1;

static i64 pc_decls_mcltime;
static i64 pc_decls_sstime;
static i64 pc_decls_objtime;
static i64 pc_decls_exetime;
static u64 pc_decls_$pmodulename;
static struct $B20 pc_decls_pclflags;
static i64 pc_decls_pstartclock;
static i64 pc_run_dotrace = 0;

static i64 pc_run_dostep = 1;

static i64 pc_run_go;
static i64 pc_run_seqno;
static struct $B21 pc_run_emptyst;
static u64 pc_run_labeltable;
static struct $B22 pc_tables_pstdnames = {{
(u64)"void",
(u64)"r32",
(u64)"r64",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"mem",
(u64)"vec",
(u64)"$last"}};

static struct $B23 pc_tables_psize = {{
1024,
264,
1026,
264,
1026,
8,
0}};

static struct $B23 pc_tables_psigned = {{
0,
0,
0,
256,
257,
1,
0}};

static struct $B23 pc_tables_pint = {{
0,
256,
257,
257,
257,
1,
0}};

static struct $B23 pc_tables_pfloat = {{
256,
1,
0,
0,
0,
0,
0}};

static struct $B23 pc_tables_pmin = {{
256,
1282,
1285,
2310,
2313,
2826,
12}};

static struct $B23 pc_tables_xxpiwrb = {{
256,
1538,
1542,
2566,
2570,
10,
0}};

static struct $B22 pc_tables_opndnames = {{
(u64)"no_opnd",
(u64)"mem_opnd",
(u64)"memaddr_opnd",
(u64)"label_opnd",
(u64)"int_opnd",
(u64)"real_opnd",
(u64)"r32_opnd",
(u64)"string_opnd",
(u64)"strimm_opnd",
(u64)"assem_opnd",
(u64)"realimm_opnd",
(u64)"realimm32_opnd",
(u64)"data_opnd",
(u64)"any_opnd"}};

static struct $B20 pc_tables_pclnames = {{
(u64)"nop",
(u64)"load",
(u64)"iload",
(u64)"iloadx",
(u64)"store",
(u64)"istore",
(u64)"istorex",
(u64)"storem",
(u64)"dupl",
(u64)"double",
(u64)"swapstk",
(u64)"unload",
(u64)"opnd",
(u64)"type",
(u64)"loadbit",
(u64)"loadbf",
(u64)"storebit",
(u64)"storebf",
(u64)"callp",
(u64)"icallp",
(u64)"retproc",
(u64)"callf",
(u64)"icallf",
(u64)"retfn",
(u64)"jump",
(u64)"ijump",
(u64)"jumpcc",
(u64)"jumpt",
(u64)"jumpf",
(u64)"jumpret",
(u64)"jumpretm",
(u64)"setcc",
(u64)"stop",
(u64)"to",
(u64)"forup",
(u64)"fordown",
(u64)"iswap",
(u64)"switch",
(u64)"switchu",
(u64)"swlabel",
(u64)"endsw",
(u64)"clear",
(u64)"assem",
(u64)"add",
(u64)"sub",
(u64)"mul",
(u64)"div",
(u64)"idiv",
(u64)"irem",
(u64)"idivrem",
(u64)"bitand",
(u64)"bitor",
(u64)"bitxor",
(u64)"shl",
(u64)"shr",
(u64)"min",
(u64)"max",
(u64)"addpx",
(u64)"subpx",
(u64)"subp",
(u64)"neg",
(u64)"abs",
(u64)"bitnot",
(u64)"not",
(u64)"toboolt",
(u64)"toboolf",
(u64)"sqr",
(u64)"sqrt",
(u64)"sin",
(u64)"cos",
(u64)"tan",
(u64)"asin",
(u64)"acos",
(u64)"atan",
(u64)"log",
(u64)"log10",
(u64)"exp",
(u64)"round",
(u64)"floor",
(u64)"ceil",
(u64)"sign",
(u64)"atan2",
(u64)"power",
(u64)"fmod",
(u64)"incrto",
(u64)"decrto",
(u64)"incrload",
(u64)"decrload",
(u64)"loadincr",
(u64)"loaddecr",
(u64)"addto",
(u64)"subto",
(u64)"multo",
(u64)"divto",
(u64)"idivto",
(u64)"iremto",
(u64)"bitandto",
(u64)"bitorto",
(u64)"bitxorto",
(u64)"shlto",
(u64)"shrto",
(u64)"minto",
(u64)"maxto",
(u64)"addpxto",
(u64)"subpxto",
(u64)"negto",
(u64)"absto",
(u64)"bitnotto",
(u64)"notto",
(u64)"toboolto",
(u64)"typepun",
(u64)"float",
(u64)"fix",
(u64)"truncate",
(u64)"widen",
(u64)"fwiden",
(u64)"fnarrow",
(u64)"startmx",
(u64)"resetmx",
(u64)"endmx",
(u64)"proc",
(u64)"tcproc",
(u64)"endproc",
(u64)"istatic",
(u64)"zstatic",
(u64)"data",
(u64)"initdswx",
(u64)"label",
(u64)"labeldef",
(u64)"setjmp",
(u64)"longjmp",
(u64)"setcall",
(u64)"setarg",
(u64)"loadall",
(u64)"eval",
(u64)"comment",
(u64)"endprog",
(u64)"param",
(u64)"local",
(u64)"rettype",
(u64)"variadic",
(u64)"addlib",
(u64)"extproc"}};

static struct $B24 pc_tables_pclhastype = {{
0,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
0,
0,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
2,
2,
2,
2,
2,
0,
1,
1,
0,
0,
0,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
0,
0,
0}};

static struct $B24 pc_tables_pclextra = {{
0,
1,
0,
2,
0,
0,
2,
0,
0,
0,
2,
0,
0,
0,
0,
0,
0,
0,
2,
2,
0,
2,
2,
0,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
2,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B24 pc_tables_pclhasopnd = {{
0,
13,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
13,
0,
0,
0,
0,
0,
2,
0,
0,
2,
0,
0,
3,
0,
3,
3,
3,
3,
3,
0,
0,
3,
3,
3,
0,
3,
3,
3,
0,
0,
13,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
1,
1,
13,
0,
3,
2,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
0,
0,
7,
1}};

static struct $B24 pc_tables_pclargs = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
2,
2,
9,
9,
0,
9,
9,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
2,
2,
2,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B25 pc_tables_ccnames = {{
(u64)"xx",
(u64)"eq",
(u64)"ne",
(u64)"lt",
(u64)"le",
(u64)"ge",
(u64)"gt"}};

static struct $B1 pc_tables_idnames = {{
(u64)"--",
(u64)"Import",
(u64)"Proc",
(u64)"Static",
(u64)"Local",
(u64)"Param",
(u64)"Label",
(u64)"Export",
(u64)"Misc",
(u64)"Program"}};

static i64 mc_genss_dummy_psstime;
static struct $B11 mc_decls_valtypenames = {{
(u64)"no_val",
(u64)"intimm_val",
(u64)"realimm_val",
(u64)"realmem_val",
(u64)"stringimm_val",
(u64)"def_val",
(u64)"label_val",
(u64)"name_val",
(u64)"temp_val"}};

static struct $B26 mc_decls_mclnames = {{
(u64)"m_procstart",
(u64)"m_procend",
(u64)"m_comment",
(u64)"m_labelname",
(u64)"m_define",
(u64)"m_definereg",
(u64)"m_trace",
(u64)"m_endx",
(u64)"m_labelx",
(u64)"m_nop",
(u64)"m_mov",
(u64)"m_push",
(u64)"m_pop",
(u64)"m_lea",
(u64)"m_cmovcc",
(u64)"m_movd",
(u64)"m_movq",
(u64)"m_movsx",
(u64)"m_movzx",
(u64)"m_movsxd",
(u64)"m_call",
(u64)"m_ret",
(u64)"m_leave",
(u64)"m_retn",
(u64)"m_jmp",
(u64)"m_jmpcc",
(u64)"m_xchg",
(u64)"m_add",
(u64)"m_sub",
(u64)"m_adc",
(u64)"m_sbb",
(u64)"m_imul",
(u64)"m_mul",
(u64)"m_imul2",
(u64)"m_imul3",
(u64)"m_idiv",
(u64)"m_div",
(u64)"m_andx",
(u64)"m_orx",
(u64)"m_xorx",
(u64)"m_test",
(u64)"m_cmp",
(u64)"m_shl",
(u64)"m_sar",
(u64)"m_shr",
(u64)"m_rol",
(u64)"m_ror",
(u64)"m_rcl",
(u64)"m_rcr",
(u64)"m_neg",
(u64)"m_notx",
(u64)"m_inc",
(u64)"m_dec",
(u64)"m_cbw",
(u64)"m_cwd",
(u64)"m_cdq",
(u64)"m_cqo",
(u64)"m_setcc",
(u64)"m_bsf",
(u64)"m_bsr",
(u64)"m_shld",
(u64)"m_shrd",
(u64)"m_sqrtss",
(u64)"m_sqrtsd",
(u64)"m_addss",
(u64)"m_addsd",
(u64)"m_subss",
(u64)"m_subsd",
(u64)"m_mulss",
(u64)"m_mulsd",
(u64)"m_divss",
(u64)"m_divsd",
(u64)"m_comiss",
(u64)"m_comisd",
(u64)"m_ucomisd",
(u64)"m_xorps",
(u64)"m_xorpd",
(u64)"m_andps",
(u64)"m_andpd",
(u64)"m_pxor",
(u64)"m_pand",
(u64)"m_cvtss2si",
(u64)"m_cvtsd2si",
(u64)"m_cvttss2si",
(u64)"m_cvttsd2si",
(u64)"m_cvtsi2ss",
(u64)"m_cvtsi2sd",
(u64)"m_cvtsd2ss",
(u64)"m_cvtss2sd",
(u64)"m_movdqa",
(u64)"m_movdqu",
(u64)"m_pcmpistri",
(u64)"m_pcmpistrm",
(u64)"m_fld",
(u64)"m_fst",
(u64)"m_fstp",
(u64)"m_fild",
(u64)"m_fist",
(u64)"m_fistp",
(u64)"m_fadd",
(u64)"m_fsub",
(u64)"m_fmul",
(u64)"m_fdiv",
(u64)"m_fsqrt",
(u64)"m_fsin",
(u64)"m_fcos",
(u64)"m_fsincos",
(u64)"m_fptan",
(u64)"m_fpatan",
(u64)"m_fabs",
(u64)"m_fchs",
(u64)"m_minss",
(u64)"m_maxss",
(u64)"m_minsd",
(u64)"m_maxsd",
(u64)"m_db",
(u64)"m_dw",
(u64)"m_dd",
(u64)"m_dq",
(u64)"m_isegment",
(u64)"m_zsegment",
(u64)"m_csegment",
(u64)"m_align",
(u64)"m_resb",
(u64)"m_resw",
(u64)"m_resd",
(u64)"m_resq",
(u64)"m_xlat",
(u64)"m_loopnz",
(u64)"m_loopz",
(u64)"m_loopcx",
(u64)"m_jecxz",
(u64)"m_jrcxz",
(u64)"m_cmpsb",
(u64)"m_cmpsw",
(u64)"m_cmpsd",
(u64)"m_cmpsq",
(u64)"m_rdtsc",
(u64)"m_popcnt",
(u64)"m_bswap",
(u64)"m_finit",
(u64)"m_fldz",
(u64)"m_fld1",
(u64)"m_fldpi",
(u64)"m_fld2t",
(u64)"m_fld2e",
(u64)"m_fldlg2",
(u64)"m_fldln2",
(u64)"m_cpuid",
(u64)"m_xxxx",
(u64)"m_halt"}};

static struct $B27 mc_decls_mclnopnds = {{
0,
0,
0,
0,
0,
0,
0,
0,
1,
0,
2,
1,
1,
2,
2,
2,
2,
2,
2,
2,
1,
0,
0,
1,
1,
1,
2,
2,
2,
2,
2,
1,
1,
2,
3,
1,
1,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
0,
0,
0,
0,
1,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
3,
3,
1,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
2,
2,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
2,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B27 mc_decls_mclcodes = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
144,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
232,
195,
201,
0,
233,
0,
0,
0,
5,
2,
3,
5,
4,
0,
0,
7,
6,
4,
1,
6,
0,
7,
4,
7,
5,
0,
1,
2,
3,
3,
2,
0,
1,
0,
0,
0,
0,
0,
188,
189,
164,
172,
81,
81,
88,
88,
92,
92,
89,
89,
94,
94,
0,
47,
46,
87,
87,
84,
84,
239,
219,
0,
0,
0,
0,
0,
0,
0,
0,
102,
243,
99,
98,
0,
2,
3,
0,
2,
3,
193,
233,
201,
249,
250,
254,
255,
251,
242,
243,
225,
224,
93,
95,
93,
95,
0,
0,
0,
0,
0,
0,
0,
0,
1,
2,
4,
8,
215,
224,
225,
226,
227,
227,
0,
0,
0,
0,
49,
0,
0,
0,
238,
232,
235,
233,
234,
236,
237,
0,
244,
244}};

static struct $B28 mc_decls_regnames = {{
(u64)"rnone",
(u64)"r0",
(u64)"r1",
(u64)"r2",
(u64)"r3",
(u64)"r4",
(u64)"r5",
(u64)"r6",
(u64)"r7",
(u64)"r8",
(u64)"r9",
(u64)"r10",
(u64)"r11",
(u64)"r12",
(u64)"r13",
(u64)"r14",
(u64)"r15",
(u64)"r16",
(u64)"r17",
(u64)"r18",
(u64)"r19"}};

static struct $B29 mc_decls_regcodes = {{
0,
0,
10,
11,
7,
3,
6,
12,
13,
14,
15,
1,
2,
8,
9,
5,
4,
4,
7,
5,
6}};

static struct $B30 mc_decls_condnames = {{
(u64)"ov",
(u64)"nov",
(u64)"ltu",
(u64)"geu",
(u64)"eq",
(u64)"ne",
(u64)"leu",
(u64)"gtu",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"lt",
(u64)"ge",
(u64)"le",
(u64)"gt",
(u64)"flt",
(u64)"fge",
(u64)"fle",
(u64)"fgt"}};

static struct $B30 mc_decls_asmcondnames = {{
(u64)"o",
(u64)"no",
(u64)"b",
(u64)"ae",
(u64)"z",
(u64)"nz",
(u64)"be",
(u64)"a",
(u64)"s",
(u64)"ns",
(u64)"p",
(u64)"np",
(u64)"l",
(u64)"ge",
(u64)"le",
(u64)"g",
(u64)"b",
(u64)"ae",
(u64)"be",
(u64)"a"}};

static struct $B30 mc_decls_asmrevcond = {{
1,
0,
3,
2,
5,
4,
7,
6,
9,
8,
11,
10,
13,
12,
15,
14,
17,
16,
19,
18}};

static struct $B31 mc_decls_dregnames = {{
(u64)"d0",
(u64)"d1",
(u64)"d2",
(u64)"d3",
(u64)"d4",
(u64)"d5",
(u64)"d6",
(u64)"d7",
(u64)"d8",
(u64)"d9",
(u64)"d10",
(u64)"d11",
(u64)"d12",
(u64)"d13",
(u64)"d14",
(u64)"d15",
(u64)"a0",
(u64)"a1",
(u64)"a2",
(u64)"a3",
(u64)"a4",
(u64)"a5",
(u64)"a6",
(u64)"a7",
(u64)"a8",
(u64)"a9",
(u64)"a10",
(u64)"a11",
(u64)"a12",
(u64)"a13",
(u64)"a14",
(u64)"a15",
(u64)"w0",
(u64)"w1",
(u64)"w2",
(u64)"w3",
(u64)"w4",
(u64)"w5",
(u64)"w6",
(u64)"w7",
(u64)"w8",
(u64)"w9",
(u64)"w10",
(u64)"w11",
(u64)"w12",
(u64)"w13",
(u64)"w14",
(u64)"w15",
(u64)"b0",
(u64)"b1",
(u64)"b2",
(u64)"b3",
(u64)"b4",
(u64)"b5",
(u64)"b6",
(u64)"b7",
(u64)"b8",
(u64)"b9",
(u64)"b10",
(u64)"b11",
(u64)"b12",
(u64)"b13",
(u64)"b14",
(u64)"b15",
(u64)"b16",
(u64)"b17",
(u64)"b18",
(u64)"b19",
(u64)"_b20",
(u64)"rax",
(u64)"rbx",
(u64)"rcx",
(u64)"rdx",
(u64)"rsi",
(u64)"rdi",
(u64)"rbp",
(u64)"rsp",
(u64)"r8",
(u64)"r9",
(u64)"r10",
(u64)"r11",
(u64)"r12",
(u64)"r13",
(u64)"r14",
(u64)"r15",
(u64)"eax",
(u64)"ebx",
(u64)"ecx",
(u64)"edx",
(u64)"esi",
(u64)"edi",
(u64)"ebp",
(u64)"esp",
(u64)"r8d",
(u64)"r9d",
(u64)"r10d",
(u64)"r11d",
(u64)"r12d",
(u64)"r13d",
(u64)"r14d",
(u64)"r15d",
(u64)"ax",
(u64)"bx",
(u64)"cx",
(u64)"dx",
(u64)"si",
(u64)"di",
(u64)"bp",
(u64)"sp",
(u64)"r8w",
(u64)"r9w",
(u64)"r10w",
(u64)"r11w",
(u64)"r12w",
(u64)"r13w",
(u64)"r14w",
(u64)"r15w",
(u64)"al",
(u64)"bl",
(u64)"cl",
(u64)"dl",
(u64)"ah",
(u64)"bh",
(u64)"ch",
(u64)"dh",
(u64)"sil",
(u64)"dil",
(u64)"bpl",
(u64)"spl",
(u64)"r8b",
(u64)"r9b",
(u64)"r10b",
(u64)"r11b",
(u64)"r12b",
(u64)"r13b",
(u64)"r14b",
(u64)"r15b"}};

static struct $B32 mc_decls_regsizes = {{
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
8,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1}};

static struct $B32 mc_decls_regindices = {{
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
12,
13,
14,
15,
16,
17,
18,
19,
20,
0,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10,
1,
5,
11,
12,
17,
18,
19,
20,
6,
4,
15,
16,
13,
14,
2,
3,
7,
8,
9,
10}};

static struct $B21 mc_decls_xmmregnames = {{
(u64)"xmm0",
(u64)"xmm1",
(u64)"xmm2",
(u64)"xmm3",
(u64)"xmm4",
(u64)"xmm5",
(u64)"xmm6",
(u64)"xmm7",
(u64)"xmm8",
(u64)"xmm9",
(u64)"xmm10",
(u64)"xmm11",
(u64)"xmm12",
(u64)"xmm13",
(u64)"xmm14",
(u64)"xmm15"}};

static struct $B33 mc_decls_fregnames = {{
(u64)"st0",
(u64)"st1",
(u64)"st2",
(u64)"st3",
(u64)"st4",
(u64)"st5",
(u64)"st6",
(u64)"st7"}};

static struct $B33 mc_decls_mregnames = {{
(u64)"mmx0",
(u64)"mmx1",
(u64)"mmx2",
(u64)"mmx3",
(u64)"mmx4",
(u64)"mmx5",
(u64)"mmx6",
(u64)"mmx7"}};

static struct $B34 mc_decls_jmpccnames = {{
(u64)"jo",
(u64)"jno",
(u64)"jb",
(u64)"jae",
(u64)"jz",
(u64)"jnz",
(u64)"jbe",
(u64)"ja",
(u64)"js",
(u64)"jns",
(u64)"jp",
(u64)"jnp",
(u64)"jl",
(u64)"jge",
(u64)"jle",
(u64)"jg",
(u64)"jc",
(u64)"jnc"}};

static struct $B35 mc_decls_jmpcccodes = {{
256,
770,
1284,
1798,
2312,
2826,
3340,
3854,
770}};

static struct $B21 mc_decls_setccnames = {{
(u64)"seto",
(u64)"setno",
(u64)"setb",
(u64)"setae",
(u64)"setz",
(u64)"setnz",
(u64)"setbe",
(u64)"seta",
(u64)"sets",
(u64)"setns",
(u64)"setp",
(u64)"setnp",
(u64)"setl",
(u64)"setge",
(u64)"setle",
(u64)"setg"}};

static struct $B3 mc_decls_setcccodes = {{
506097522914230528,
1084818905618843912}};

static struct $B21 mc_decls_cmovccnames = {{
(u64)"cmovo",
(u64)"cmovno",
(u64)"cmovb",
(u64)"cmovae",
(u64)"cmovz",
(u64)"cmovnz",
(u64)"cmovbe",
(u64)"cmova",
(u64)"cmovs",
(u64)"cmovns",
(u64)"cmovp",
(u64)"cmovnp",
(u64)"cmovl",
(u64)"cmovge",
(u64)"cmovle",
(u64)"cmovg"}};

static struct $B3 mc_decls_cmovcccodes = {{
506097522914230528,
1084818905618843912}};

static struct $B12 mc_decls_segmentnames = {{
(u64)"no_seg",
(u64)"code_seg",
(u64)"idata_seg",
(u64)"zdata_seg",
(u64)"rodata_seg",
(u64)"impdata_seg"}};

static struct $B8 mc_decls_reftypenames = {{
(u64)"extern_ref",
(u64)"fwd_ref",
(u64)"back_ref"}};

static struct $B12 mc_decls_opndnames_ma = {{
(u64)"a_none",
(u64)"a_reg",
(u64)"a_imm",
(u64)"a_mem",
(u64)"a_cond",
(u64)"a_xreg"}};

static struct $B19 mc_decls_pclopnd;
static struct $B36 mc_decls_pclreg;
static struct $B36 mc_decls_pclmode;
static struct $B36 mc_decls_pclcount;
static struct $B36 mc_decls_pclloc;
static struct $B36 mc_decls_pcltempflags;
static struct $B19 mc_decls_pcltempopnds;
static i64 mc_decls_noperands;
static i64 mc_decls_mstackdepth;
static struct $B18 mc_decls_locnames = {{
(u64)"pend",
(u64)"reg",
(u64)"regvar",
(u64)"temp"}};

static struct $B3 mc_decls_workregs;
static struct $B3 mc_decls_workxregs;
static i64 mc_decls_nworkregs;
static i64 mc_decls_nworkxregs;
static i64 mc_decls_nregvars;
static i64 mc_decls_nxregvars;
static i64 mc_decls_maxregvars;
static i64 mc_decls_maxxregvars;
static i64 mc_decls_xregmax;
static struct $B3 mc_decls_regset;
static struct $B3 mc_decls_xregset;
static struct $B3 mc_decls_isregvar;
static struct $B3 mc_decls_isxregvar;
static struct $B3 mc_decls_usedregs;
static struct $B3 mc_decls_usedxregs;
static u8 mc_decls_noxorclear;
static struct $B37 mc_decls_xregnames = {{
(u64)"-",
(u64)"xmm0",
(u64)"xmm1",
(u64)"xmm2",
(u64)"xmm3",
(u64)"xmm4",
(u64)"xmm5",
(u64)"xmm6",
(u64)"xmm7",
(u64)"xmm8",
(u64)"xmm9",
(u64)"xmm10",
(u64)"xmm11",
(u64)"xmm12",
(u64)"xmm13",
(u64)"xmm15",
(u64)"xmm15"}};

static struct $B18 mc_decls_callalign;
static struct $B18 mc_decls_callblockret;
static struct $B21 mc_decls_callblocksize;
static struct $B38 mc_decls_callargsize;
static i64 mc_decls_ncalldepth;
static i64 mc_decls_lababs32;
static i64 mc_decls_lababs64;
static i64 mc_decls_labneg32;
static i64 mc_decls_labneg64;
static i64 mc_decls_labmask63;
static i64 mc_decls_laboffset64;
static i64 mc_decls_labzero;
static i64 mc_decls_kk0used = 0;

static u64 mc_decls_mccode;
static u64 mc_decls_mccodex;
static i64 mc_decls_currsegment = 0;

static u64 mc_decls_dstackopnd;
static u64 mc_decls_dframeopnd;
static struct $B39 mc_decls_regtable;
static struct $B40 mc_decls_frameregtable;
static u64 mc_decls_cstringlist;
static u64 mc_decls_vstringlist;
static u64 mc_decls_creallist;
static u64 mc_decls_cr32list;
static u64 mc_decls_currasmproc;
static i64 mc_decls_lab_funcnametable;
static i64 mc_decls_lab_funcaddrtable;
static i64 mc_decls_lab_funcnprocs;
static i64 mc_decls_ss_zdatalen;
static u64 mc_decls_ss_zdata;
static u64 mc_decls_ss_idata;
static u64 mc_decls_ss_code;
static u64 mc_decls_ss_idatarelocs;
static u64 mc_decls_ss_coderelocs;
static i64 mc_decls_ss_nidatarelocs;
static i64 mc_decls_ss_ncoderelocs;
static u64 mc_decls_ss_symboltable;
static i64 mc_decls_ss_nsymbols;
static i64 mc_decls_ss_symboltablesize;
static u64 mc_decls_labeldeftable;
static i64 mc_decls_aaseqno;
static i64 mc_decls_aapos;
static u64 mc_decls_regmodes = 432345564311454723;

static u8 mc_decls_pmode;
static u64 mc_decls_currpcl;
static u64 mc_decls_mclprocentry;
static u64 mc_decls_mce_oldmccodex;
static u64 mc_decls_mce_lastmcl;
static u64 mc_decls_mce_nextmcl;
static u64 mc_decls_mcf_oldmccodex;
static u64 mc_decls_mcf_lastmcl;
static u64 mc_decls_mcf_nextmcl;
static u8 mc_decls_fpcheckunusedlocals;
static u64 mc_decls_riplist;
static struct $B19 mc_decls_blockdefs;
static i64 mc_decls_nblocktemps;
static struct $B12 mc_decls_multregs = {{
1,
2,
3,
11,
12,
13}};

static struct $B12 mc_decls_multxregs = {{
1,
2,
3,
4,
5,
6}};

static struct $B23 mc_decls_ploadopx;
static struct $B23 mc_decls_ploadop;
static struct $B25 mc_objdecls_relocnames = {{
(u64)"abs_rel",
(u64)"addr64_rel",
(u64)"addr32_rel",
(u64)"addr32nb_rel",
(u64)"rel32_rel",
(u64)"rel321_rel",
(u64)"rel8_rel"}};

static u64 mm_cli_syslibname = (u64)"";

static struct $B42 mm_cli_passnames = {{
(u64)"ma",
(u64)"list",
(u64)"proj",
(u64)"pcl",
(u64)"(int)",
(u64)"asm",
(u64)"obj",
(u64)"dll",
(u64)"exe",
(u64)"mx",
(u64)"(run)"}};

static struct $B33 mm_cli_dpassnames = {{
(u64)"dload_pass",
(u64)"dparse_pass",
(u64)"dfixup_pass",
(u64)"dname_pass",
(u64)"dtype_pass",
(u64)"dpcl_pass",
(u64)"dmcl_pass",
(u64)"dss_pass"}};

static struct $B43 mm_cli_optionnames = {{
(u64)"ma",
(u64)"getst",
(u64)"getproj",
(u64)"p",
(u64)"i",
(u64)"a",
(u64)"nasm",
(u64)"obj",
(u64)"dll",
(u64)"d",
(u64)"exe",
(u64)"mx",
(u64)"r",
(u64)"dload",
(u64)"dparse",
(u64)"dfixup",
(u64)"dname",
(u64)"dtype",
(u64)"dpcl",
(u64)"dmcl",
(u64)"dss",
(u64)"sys",
(u64)"min",
(u64)"nosys",
(u64)"linux",
(u64)"no",
(u64)"nopeep",
(u64)"noregs",
(u64)"ast1",
(u64)"ast2",
(u64)"ast3",
(u64)"showc",
(u64)"showpcl",
(u64)"showasm",
(u64)"st",
(u64)"stflat",
(u64)"types",
(u64)"showss",
(u64)"modules",
(u64)"shortnames",
(u64)"pst",
(u64)"time",
(u64)"v",
(u64)"vv",
(u64)"q",
(u64)"cs",
(u64)"ss",
(u64)"h",
(u64)"help",
(u64)"ext",
(u64)"o",
(u64)"outpath",
(u64)"unused",
(u64)"norip",
(u64)"himem"}};

static struct $B44 mm_cli_optionvalues = {{
1,
2,
3,
4,
5,
6,
6,
7,
8,
8,
9,
10,
11,
1,
2,
3,
4,
5,
6,
7,
8,
2,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
3,
0,
1,
2,
0,
0,
0,
0,
0,
0,
0,
2}};

static u8 mm_cli_msfile;
static u64 mm_cli_outext = (u64)"";

static i64 mm_cli_startclock;
static i64 mm_cli_endclock;
static i64 mm_cli_cmdskip;
static u64 mm_cli_inputfile;
static i64 mm_cli_loadtime;
static i64 mm_cli_parsetime;
static i64 mm_cli_resolvetime;
static i64 mm_cli_typetime;
static i64 mm_cli_ctime;
static i64 mm_cli_pcltime;
static i64 mm_cli_compiletime;
static u8 mm_cli_do_option_outused;
static u8 mm_cli_do_option_outpathused;
static i64 mm_blockpcl_nnn;
static struct $B30 mm_blockpcl_casestmt;
static struct $B30 mm_blockpcl_caseelse;
static i64 mm_blockpcl_casedepth;
static u64 mm_blockpcl_sw_labeltable;
static u64 mm_blockpcl_sw_valuetable;
static i64 mm_blockpcl_sw_lower;
static i64 mm_blockpcl_sw_ncases;
static u8 mm_blockpcl_sw_defaultseen;
static i64 mm_blockpcl_sw_defaultlabel;
static i64 mm_blockpcl_sw_breaklabel;
static i64 mm_blockpcl_maxreg = 0;

static u64 mm_blockpcl_pnprocs;
static u64 mm_blockpcl_pprocname;
static u64 mm_blockpcl_pprocaddr;
static struct $B7 mm_decls_modules;
static struct $B45 mm_decls_moduletosub;
static struct $B46 mm_decls_subprogs;
static struct $B7 mm_decls_sources;
static struct $B47 mm_decls_subproghasstart;
static i64 mm_decls_nmodules;
static i64 mm_decls_nsubprogs;
static i64 mm_decls_nsourcefiles;
static i64 mm_decls_nlibfiles;
static u64 mm_decls_stprogram;
static u64 mm_decls_stmodule;
static i64 mm_decls_currmoduleno;
static u8 mm_decls_loadedfromma;
static struct $B3 mm_decls_lx;
static struct $B3 mm_decls_nextlx;
static struct $B48 mm_decls_libfiles;
static i64 mm_decls_mainsubprogno;
static i64 mm_decls_ntypes;
static struct $B49 mm_decls_ttnamedef;
static struct $B49 mm_decls_ttowner;
static struct $B50 mm_decls_ttbasetype;
static struct $B49 mm_decls_ttname;
static struct $B50 mm_decls_ttsize;
static struct $B51 mm_decls_ttsizeset;
static struct $B50 mm_decls_ttlower;
static struct $B50 mm_decls_ttlength;
static struct $B49 mm_decls_ttmult;
static struct $B49 mm_decls_ttdimexpr;
static struct $B50 mm_decls_tttarget;
static struct $B51 mm_decls_ttusercat;
static struct $B50 mm_decls_ttlineno;
static struct $B51 mm_decls_ttsigned;
static struct $B51 mm_decls_ttisreal;
static struct $B51 mm_decls_ttisinteger;
static struct $B51 mm_decls_ttisshort;
static struct $B51 mm_decls_ttisref;
static struct $B51 mm_decls_ttisblock;
static struct $B52 mm_decls_typenames;
static struct $B53 mm_decls_typenamepos;
static i64 mm_decls_ntypenames;
static struct $B32 mm_decls_typestarterset;
static u64 mm_decls_currproc;
static i64 mm_decls_assemmode = 0;

static i64 mm_decls_headermode = 0;

static u64 mm_decls_proclist;
static u64 mm_decls_proclistx;
static u64 mm_decls_staticlist;
static u64 mm_decls_staticlistx;
static u64 mm_decls_constlist;
static u64 mm_decls_constlistx;
static u64 mm_decls_nullunit;
static i64 mm_decls_ndllproctable;
static struct $B54 mm_decls_dllproctable;
static i64 mm_decls_fverbose = 1;

static u8 mm_decls_msyslevel = 2;

static u8 mm_decls_mvarlib = 0;

static u8 mm_decls_fvarnames = 0;

static u8 mm_decls_fshowtiming;
static u8 mm_decls_fshowss;
static u8 mm_decls_fshowc;
static u8 mm_decls_fshowpcl;
static u8 mm_decls_fshowasm;
static u8 mm_decls_fshowast1;
static u8 mm_decls_fshowast2;
static u8 mm_decls_fshowast3;
static u8 mm_decls_fshowst;
static u8 mm_decls_fshowpst;
static u8 mm_decls_fshowstflat;
static u8 mm_decls_fshowtypes;
static u8 mm_decls_fshowmodules;
static u8 mm_decls_fcheckunusedlocals = 0;

static u8 mm_decls_highmem = 1;

static u8 mm_decls_clinux;
static u8 mm_decls_dointlibs = 1;

static i64 mm_decls_passlevel = 0;

static i64 mm_decls_dpasslevel = 0;

static i64 mm_decls_prodmode = 0;

static i64 mm_decls_debugmode = 0;

static i64 mm_decls_libmode = 0;

static i64 mm_decls_fshortnames;
static u64 mm_decls_outfile;
static u64 mm_decls_destfilename;
static u64 mm_decls_destfilepath;
static i64 mm_decls_nunits;
static i64 mm_decls_nunitsmem;
static struct $B3 mm_diags_dummy_sbuffer;
static u64 mm_diags_dummy_dest = (u64)&mm_diags_dummy_sbuffer;

static i64 mm_diags_dummy_currlineno;
static struct $B3 mm_exportm_sbuffer;
static u64 mm_exportm_dest = (u64)&mm_exportm_sbuffer;

static i64 mm_genpcl_retindex;
static i64 mm_genpcl_initstaticsindex;
static u64 mm_genpcl_pcldoswx;
static struct $B55 mm_genpcl_loopstack;
static i64 mm_genpcl_loopindex;
static struct $B56 mm_genpcl_zero_unit;
static u64 mm_genpcl_pzero = (u64)&mm_genpcl_zero_unit;

static i64 mm_genpcl_nvarlocals;
static i64 mm_genpcl_nvarparams;
static struct $B30 mm_lex_lxstart_stack;
static struct $B30 mm_lex_lxsource_stack;
static struct $B30 mm_lex_lxsptr_stack;
static struct $B30 mm_lex_lxfileno_stack;
static struct $B6 mm_lex_lxnextlx_stack;
static struct $B17 mm_lex_lximport_stack;
static i64 mm_lex_sourcelevel = 0;

static i64 mm_lex_lximport;
static u64 mm_lex_lxsource;
static u64 mm_lex_lxstart;
static u64 mm_lex_lxsptr;
static i64 mm_lex_lxifcond;
static i64 mm_lex_lxfileno;
static struct $B57 mm_lex_hashtable;
static struct $B16 mm_lex_namemap;
static u64 mm_lex_u64maxstr = (u64)"18446744073709551615";

static i64 mm_lib_autotypeno = 0;

static i64 mm_lib_nextavindex = 0;

static i64 mm_lib_nextsvindex = 0;

static struct $B3 mm_lib_exprstrvar;
static u64 mm_lib_exprstr = (u64)&mm_lib_exprstrvar;

static u64 mm_lib_unitheapptr = 0;

static i64 mm_lib_remainingunits = 0;

static struct $B3 mm_lib_sbuffer;
static u64 mm_lib_dest = (u64)&mm_lib_sbuffer;

static u64 mm_lib_jdest;
static u64 mm_lib_framevarname;
static struct $B18 mm_lib_nextautotype_str;
static struct $B16 mm_lib_getdottedname_str;
static struct $B4 mm_lib_strmode_str;
static struct $B4 mm_lib_strmode2_str;
static struct $B58 mm_libsources_syslibnames = {{
(u64)"msyswin.m",
(u64)"msyswinc.m",
(u64)"msyswini.m",
(u64)"msyslinc.m",
(u64)"msys.m",
(u64)"msysc.m",
(u64)"msysmin.m",
(u64)"mlib.m",
(u64)"mclib.m",
(u64)"mwindows.m",
(u64)"mlinux.m",
(u64)"mwindll.m",
(u64)"mwindllc.m"}};

static struct $B58 mm_libsources_syslibtext = {{
(u64)"module msys\nmodule mlib\nmodule mclib\nmodule mwindows\nmodule mwindll\n\n!proc start=\n!\tCPL \"MSYSWIN/START\"\n!END\n",
(u64)"module msysc\nmodule mlib\nmodule mclib\nmodule mwindows\nmodule mwindllc\n",
(u64)"module msys\nmodule mlib\nmodule mclib\nmodule mwindows\nmodule mwindllc\n",
(u64)"module msysc\nmodule mlib\nmodule mclib\nmodule mlinux\nmodule mwindllc\n",
(u64)"global record procinforec=\n\tu16\t\t\tfnindex\n\tbyte\t\trettype\n\tbyte\t\tnparams\n\t[12]byte\tparamlist\nend\n\n!for print/read routines\n!------------------------------------------\nexport record fmtrec=\t! (default)\n\tbyte\tminwidth\t! n (0)   min field width (0 if not used or don't care)\n\ti8\t\tprecision\t! .n (0)   number of decimals/significant figures/max width\n\tbyte\tbase\t\t! B,H or Xn (10)  2 to 16\n\n\tchar\tquotechar\t! Qc (0)   0 or '\"' or c\n\tchar\tpadchar\t\t! Pc, Z (' ')\n\tchar\trealfmt\t\t! E,F,G ('f') 'e' or 'f' or 'g'\n\n\tchar\tplus\t\t! (0)   0 or '+'\n\tchar\tsepchar\t\t! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits\n\tchar\tlettercase\t! A,a ('A') 'A' or 'a'\n\tchar\tjustify\t\t! JL, JR, JC ('R') 'L' or 'R' or 'C'?\n\tchar\tsuffix\t\t! Tc (0)   0 or 'B' or 'H' or c\n\tchar\tusigned\t\t! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)\n\tchar\tcharmode\t! C,M (0)  0 or 'C' or 'M'\to/p int as int or single char or multi-char\n\tchar\theapmode\t! D (0)  'D' for str-functions, return ptr to heap string\n\tchar\tparam\t\t! Use int value for <fmtparam>\n\tbyte\tspare : (showtype:1, newline:1)\nend\n\nint fmtparam\t\t\t!as set with :'V'\n\nenumdata =\n\tstd_io,file_io,str_io\nend\n\nconst comma = ','\n\nexport int $cmdskip\t\t\t!0 unless set by READMCX/etc\n\nexport int needgap\t\t\t= 0\nint outdev\t\t\t= std_io\nfilehandle outchan\t= nil\nref char fmtstr \t= nil\n\nconst maxiostack=10\n[maxiostack]filehandle\toutchan_stack\n[maxiostack]int\t\t\toutdev_stack\n[maxiostack]ref char\tfmtstr_stack\n[maxiostack]byte\t\tneedgap_stack\n\n[maxiostack]ref char\tptr_stack\t\t!this one doesn't need pushing, as each is pointed to from outchan\nint niostack=0\n\n[0:]char digits=s\"0123456789ABCDEF\"\nconst onesixty=360\nfmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)\n\n!Read buffer vars\nexport const rd_buffersize = 16384\t!total capacity of line buffer\n\nexport ref char rd_buffer\t\t! point to start of read buffer\nexport int rd_length\t\t\t! length of this line (as read by readln)\nexport ref char rd_pos\t\t\t! current position it's up to (next read starts here)\nexport ref char rd_lastpos\t\t! set by sread() just before reading used for reread()\n\nint termchar\t\t\t! terminator char set by readxxx()\nint itemerror\t\t\t!\tset by some read functions, eg for reals\n\n[4096]char printbuffer\nichar printptr\nint printlen\n\n!------------------------------------------\n\nconst maxparam=128\nexport int nsysparams\nexport int ncmdparams\nexport int nenvstrings\nexport [maxparam]ichar sysparams\n!export ref[]ichar cmdparams\nexport ref[0:]ichar cmdparams\nexport ref[]ichar envstrings\n!export [maxparam]ichar envstrings\n\nproc start=\n\ti32 nargs\n\tint nargs64\n\tref[]ichar args\n\tstatic [128]byte startupinfo\t\t\t! 68 or 104 bytes\n\tint res\n\n!res:=1234567\n!res:=0x1234567\n!\n!CPL \"MSYS/START\"\n\n\tres:=__getmainargs(&nargs,cast(&args),cast(&envstrings),0,cast(&startupinfo))\n!\tres:=__getmainargs(&nargs,cast(&args),nil,0,cast(&startupinfo))\n\t\n\tnsysparams:=nargs\n\n\tif nsysparams>maxparam then\n\t\tprintf(\"Too many params\\n\")\n\t\tstop 50\n\tfi\n\n\tnargs64:=nargs\t\t\t!bug when using 32-bit limit when compiled with mm\n\tfor i:=1 to nargs64 do\n\t\tsysparams[i]:=args[i]\n\tod\n\t\n!assume nsysparams is >=1, since first is always the program name\n\tncmdparams:=nsysparams-($cmdskip+1)\n\tcmdparams:=cast(&sysparams[$cmdskip+1])\n\n\tint j:=1\n\tnenvstrings:=0\n\twhile envstrings[j] do\n\t\t++nenvstrings\n\t\t++j\n\tod\nend\n\nproc pushio=\n\tif niostack>=maxiostack then\n\t\tprintf(\"Too many io levels\\n\")\n\t\tstop 53\n\tfi\n\t++niostack\n\toutchan_stack[niostack]\t:= outchan\n\toutdev_stack[niostack]\t:= outdev\n\tfmtstr_stack[niostack]\t:= fmtstr\n\tneedgap_stack[niostack]\t:= needgap\n\tneedgap:=0\n\tfmtstr:=nil\n\toutchan:=nil\nend\n\nexport proc m$print_startfile(ref void dev)=\n\tpushio()\n\toutchan:=cast(dev)\n\tif dev then\n\t\toutdev:=file_io\n\telse\n\t\toutdev:=std_io\n\tfi\n\tresetprintbuffer()\nend\n\nexport proc m$print_startstr(ref char s)=\n\tref ref char p\n\tpushio()\n\n\tptr_stack[niostack]:=s\n\tp:=&ptr_stack[niostack]\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startptr(ref ref char p)=\n\tpushio()\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startcon=\n\tpushio()\n\toutdev:=std_io\n\tresetprintbuffer()\nend\n\nexport proc m$print_setfmt(ref char format)=\n\tfmtstr:=format\nend\n\nexport proc m$print_end=\n\tneedgap:=0\n\tnextfmtchars(1)\n\tif niostack=1 and outdev in [std_io,file_io] then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif niostack=0 then return fi\n\toutchan\t:= outchan_stack[niostack]\n\toutdev\t:= outdev_stack[niostack]\n\tfmtstr\t:= fmtstr_stack[niostack]\n\tneedgap\t:= needgap_stack[niostack]\n\n\t--niostack\nend\n\nexport proc m$print_ptr(u64 a,ichar fmtstyle=nil)=\n\tif fmtstyle=nil then\n\t\tfmtstyle:=\"z8H\"\n\tfi\n\tm$print_u64(a,fmtstyle)\nend\n\nexport proc m$print_ptr_nf(u64 a)=\n\tm$print_ptr(a)\nend\n\nexport proc m$print_i64(i64 a,ichar fmtstyle=nil)=\n\t[40]char s\n\tfmtrec fmt\n\tint n\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tif a>=0 then\n\t\t\tn:=u64tostr(a,&.s,10,0)\n\t\telsif a=i64.min then\n\t\t\tfmt:=defaultfmt\n\t\t\tdofmt\n\n\t\telse\n\t\t\ts[1]:='-'\n\t\t\tn:=u64tostr(-a,&s[2],10,0)+1\n\t\tfi\n\n\t\tprintstr_n(&.s,n)\n\n\telse\n\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\tif fmt.param='V' then\n\t\t\tfmtparam:=a\n\t\t\tneedgap:=0\n\t\telse\ndofmt:\n\t\t\ttostr_i64(a,&fmt)\n\t\tfi\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_i64_nf(i64 a)=\n\tm$print_i64(a)\nend\n\nexport proc m$print_bool(i64 a, ichar fmtstyle=nil)=\n\tif a then\n\t\tm$print_str(\"True\",fmtstyle)\n\telse\n\t\tm$print_str(\"False\",fmtstyle)\n\tfi\nend\n\nexport proc m$print_u64(u64 a,ichar fmtstyle=nil)=\n\t[40]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%llu\",a)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_u64(a,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_r64(real x,ichar fmtstyle=nil)=\n\t[360]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%f\",x)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_r64(x,&fmt)\n\tfi\n\n\tneedgap:=1\nend\n\nexport proc m$print_r32(r32 x,ichar fmtstyle=nil)=\n!\tm$print_r64(x,fmtstyle)\n\tnextfmtchars()\n\tprintf(\"%f\",x)\n\tneedgap:=1\nend\n\nglobal proc m$print_c8(i64 a,ichar fmtstyle=nil)=\n\t[32]char s\n!\tint cc@s\n\tfmtrec fmt\n\tint n\n\tbyte charmode:=0\n\n\tnextfmtchars()\n\n\tif fmtstyle then\n\t\tstrtofmt(fmtstyle,-1, &fmt)\n\t\tcharmode:=fmt.charmode\n\tfi\n\n\tif charmode='M' then\n\t\tn:=domultichar(ref char(&a), 8, &.s, &fmt)\n!\t\tn:=domultichar(ref char(&a), 8, &.str, fmt)\n\telse\t\t\t\t\t\t!assume 'C'\n\t\t(ref int(&s)^):=a\t\n\t\ts[9]:=0\n\n\t\tn:=getutfsize(s)\t\t\t!isolate size of next char\n\tfi\n\n\tprintstr_n(s,n)\n\n\tneedgap:=1\nend\n\nexport proc m$print_str(ichar s, fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr(s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,-1,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_strn(ichar s, int length, ichar fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr_n(s,length)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,length,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_str_nf(ichar s)=\n\tm$print_str(s)\nend\n\nexport proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)=\nABORTPROGRAM(\"PRTSL\")\n!\tnextfmtchars()\n!\n!!\tfmtrec fmt\n!\n!\tif fmtstyle=nil then\n!\t\tprintstr_n(cast(s.sliceptr),s.len)\n!!\t\tprintstr_n(cast(ss.str),ss.length)\n!\telse\n!\t\tabortprogram(\"FORMATED PRINT SLICE NOT READY\")\n!!\t\tstrtofmt(fmtstyle,-1,&fmt)\n!!\t\ttostr_str(s,s.len,&fmt)\n!\tfi\n!\tneedgap:=1\nend\n\nexport proc m$print_newline=\n!PUTS(\"<NEWLINE>\")\n\tneedgap:=0\n\tnextfmtchars(1)\n\tprintstr(\"\\w\")\nend\n\nexport proc m$print_nogap=\n\tneedgap:=0\nend\n\nexport proc m$print_space=\n\tneedgap:=0\n\tprintstr(\" \")\nend\n\nexport proc printstr(ichar s)=\n\tprintstr_n(s,strlen(s))\nend\n\nexport proc printstr_n(ichar s,int n)=\n\n!\treturn when n=0\n\n!\tif niostack=1 and outdev in [std_io,file_io] then\n!!puts(\"ADDTO BUFF\")\n!\t\taddtobuffer(s,n)\n!\telse\n!printf(\"DUMPSTR %lld\\n\", n)\n\t\tdumpstr(s,n)\n!\tfi\nend\n\nexport proc printstrn_app(ichar s, int length, filehandle f=nil)=\nif length then\n\tif f=nil then\n\t\tprintf(\"%.*s\",length,s)\n\telse\n\t\tfprintf(f,\"%.*s\",length,s)\n\tfi\nfi\nend\n\nproc printchar(int ch)=\n\t[4]char str\n\n\tstr[1]:=ch\n\tstr[2]:=0\n\tprintstr_n(str,1)\nend\n\nglobal proc nextfmtchars(int lastx=0)=\n\tchar c\n\tref char pstart\n\tint n\n\tif not fmtstr then\t\t\t!format not in use\n\t\tif needgap then\n\t\t\tprintchar(' ')\n\t\tfi\n\t\tneedgap:=0\n\t\treturn\n\tfi\n\n\tpstart:=fmtstr\n\tn:=0\n\n\tdo\n\t\tc:=fmtstr^\n\t\tcase c\n\t\twhen '#' then\n\t\t\tif lastx then\n\t\t\t\tgoto skip\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\tfi\n\t\t\treturn\n\t\twhen 0 then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\telsif not lastx then\n\t\t\t\tprintstr_n(\"|\",1)\n\t\t\tfi\n\t\t\treturn\n\t\twhen '~' then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\t\tn:=0\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tc:=fmtstr^\n\t\t\tif c then\n\t\t\t\t++fmtstr\n\t\t\t\tprintchar(c)\n\t\t\tfi\n\t\t\tpstart:=fmtstr\n\t\telse\n\tskip:\n\t\t\t++n\n\t\t\t++fmtstr\n\t\tesac\n\tod\nend\n\nexport proc strtofmt(ref char s,int slen,ref fmtrec fmt) =\t\t!PC_STRTOFMT\n!convert format code string in s, to fmtrec at fmt^\n!Format code is a string containing the following char codes (upper or lower when mostly)\n!n\tWidth\n!.n\tMax width/precision\n!A\tConvert to upper case\n!a\tConvert to lower case\n!B\tBinary\n!C\tShow int as single n-bit (unicode) character\n!D\tDuplicate string returned via STRINT etc on heap\n!E,F,G\tSpecify format for double (corresponds to C format codes)\n!F\n!G\n!H\tHex\n!JC\tJustify centre\n!JL\tJustify left\n!JR\tJustify right\n!M\tShow int as multi-bit (unicode) character\n!M\tHEAPMODE???\n!O\tOctal\n!Pc\tUse padding char c\n!Q\tAdd double quotes around string (and deal with embedded quotes)\n!'\tAdd single quotes around string (and deal with embedded quotes)\n!Sc\tUse separator char c between every 3 or 4 digits\n!Tc\tUse terminator char c (typically B or H)\n!U\tShow ints as unsigned\n!V\tFor ints, don't display: store value as parameter for subsequent '*'\n!W\tUnsigned\n!Xn\tUse base n (n is hex 0 to F)\n!Z\tUse \"0\" padding\n!+\tAlways have + or - in front of integers\n!~\tQuote char is ~\n!*\tSame as n but uses parameter set with :'V' on previous int\n\n\tint c, base\n\tbyte wset\n\tint n\n\t[0:100]char str\n\n\tfmt^:=defaultfmt\n\n\tif s=nil then return fi\n\n\tif slen=-1 then slen:=strlen(s) fi\n\n\tmemcpy(&.str,s,slen)\t\t!convert s/slen to zero-terminated string\n\tstr[slen]:=0\n\ts:=&.str\n\n\twset:=0\n\twhile s^ do\n\t\tc:=s^\n\t\t++s\n\t\tif c='A' then fmt.lettercase:='A'\n\t\telsif c='a' then fmt.lettercase:='a'\n\t\telseswitch toupper(c)\n\t\twhen 'B' then fmt.base:=2\n\t\twhen 'H' then fmt.base:=16\n\t\twhen 'O' then fmt.base:=8\n\t\twhen 'X' then\n\t\t\tbase:=0\n\t\t\tdo\n\t\t\t\tc:=s^\n\t\t\t\tif c in '0'..'9' then\n\t\t\t\t\tbase:=base*10+c-'0'\n\t\t\t\t\t++s\n\t\t\t\telse\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\tod\n\t\t\tif base in 2..16 then\n\t\t\t\tfmt.base:=base\n\t\t\tfi\n\n\t\twhen 'Q' then fmt.quotechar:='\"'\n\t\twhen 'J' then\n\t\t\tfmt.justify:=toupper(s^)\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'Z' then fmt.padchar:='0'\n\t\twhen 'S' then\n\t\t\tfmt.sepchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'P' then\n\t\t\tfmt.padchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'T' then\n\t\t\tfmt.suffix:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'U' then fmt.usigned:='W'\n\t\twhen 'E' then fmt.realfmt:='e'\n\t\twhen 'F' then fmt.realfmt:='f'\n\t\twhen 'G' then fmt.realfmt:='g'\n\t\twhen 'D' then fmt.heapmode:='D'\n\t\twhen 'C' then fmt.charmode:='C'\n\t\twhen 'M' then fmt.charmode:='M'\n\t\twhen 'V' then fmt.param:='V'\n\t\twhen 'Y' then fmt.showtype:=1\n\t\twhen 'N' then fmt.newline:=1\n\t\telsecase c\n\t\twhen '.' then\n\t\t\twset:=1\n\t\twhen comma,'_' then fmt.sepchar:=c\n\t\twhen '+' then fmt.plus:='+'\n\t\twhen '~' then fmt.quotechar:='~'\n\t\twhen '*' then\n\t\t\tn:=fmtparam\n\t\t\tgoto gotwidth\n\t\telse\n\t\t\tif c>='0' and c<='9' then\n\t\t\t\tn:=c-'0'\n\t\t\t\tdo\n\t\t\t\t\tc:=s^\n\t\t\t\t\tif s^=0 then\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\t\tif c>='0' and c<='9' then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\tn:=n*10+c-'0'\n\t\t\t\t\telse\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\tod\ngotwidth:\n\t\t\t\tif not wset then\n\t\t\t\t\tfmt.minwidth:=n\n\t\t\t\t\twset:=1\n\t\t\t\telse\n\t\t\t\t\tfmt.precision:=n\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\tod\nend\n\nfunction domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int =\n!there are n (4 or 8) chars at p.!\n!There could be 0 to 4 or 8 printable chars converted to string at dest\n\t[0:20]char str\n\tref char q\n\tint nchars\n\n\tq:=&.str\n\n\tnchars:=n\n\n\tto n do\n\t\tif p^=0 then exit fi\n\t\tq^:=p^\n\t\t++q\n\t\t++p\n\tod\n\tq^:=0\n\n\treturn expandstr(&.str,dest,strlen(&.str),fmt)\nend\n\nexport function expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int =\t\t!EXPANDSTR\n!s contains a partly stringified value.\n!widen s if necessary, according to fmt, and copy result to t\n!n is current length of s\n!note) = for non-numeric strings, fmt.base should be set to 0, to avoid moving\n!a leading +/- when right-justifying with '0' padding.\n!t MUST be big enough for the expanded string; caller must take care of this\n!result will be zero-terminated, for use in this module\n\n\tint i,w,m\n\n!check to see if result is acceptable as it is\n\tw:=fmt.minwidth\n\tif w=0 or w<=n then\t\t! allow str to be longer than minwidth\n\t\tstrncpy(t,s,n)\n\t\t(t+n)^:=0\n\t\treturn n\n\tfi\n\n\tif fmt.justify='L' then\t! left-justify\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tfor i:=1 to w-n do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\telsif fmt.justify='R' then\n\t\tif fmt.padchar='0' and fmt.base and (s^='-' or s^='+') then ! need to move sign outside \n\t\t\tt^:=s^\n\t\t\t++t\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s+1,n-1)\n\t\t\t(t+n-1)^:=0\n\t\telse\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s,n)\n\t\t\t(t+n)^:=0\n\t\tfi\n\n\telse\t\t\t\t! centre-justify?\n\n\t\tm:=(w-n+1)/2\n\t\tto m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tto w-n-m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\n\tfi\n\treturn w\nend\n\nexport function u64tostr(u64 aa,ref char s,word base,int sep)int =\t\t!U64TOSTR\n!convert 64-bit int a to string in s^\n!base is number base, usually 10 but can be 2 or 16. Other bases allowed\n!result when a=minint (will give \"<minint>\")\n\t[0:onesixty]char t\n\tu64 dd\n\tint i,j,k,g\n\tref char s0\n\n\ti:=0\n\tk:=0\n\tg:=(base=10|3|4)\n\n\trepeat\n!\t\tif base=10 then\t\t\t!BUGGY FOR AA OVER I64.MAX\n!\t\t\tassem\n!\t\t\t\tmov\t\trcx, [aa]\n!\t\t\t\tmov\t\trax, rcx\n!\t\t\t\tmov\t\trdx, 7378697629483820647\n!\t\t\t\timul\trdx\n!\t\t\t\tmov\t\trax, rdx\n!\t\t\t\tmov\t\trdx, rcx\n!\t\t\t\tsar\t\trdx, 63\n!\t\t\t\tsar\t\trax, 2\n!\t\t\t\tsub\t\trax, rdx\n!\t\t\t\tlea\t\trdx, [rax+rax*4]\n!\t\t\t\tadd\t\trdx, rdx\n!\t\t\t\tsub\t\trcx, rdx\n!\t\t\t\tmov\t\t[dd], rcx\n!\t\t\t\tmov\t\t[aa], rax\n!\t\t\tend\n!\t\telse\n\t\t\tdd:=aa rem base\n\t\t\taa:=aa/base\n!\t\tfi\n\n\t\tt[++i]:=digits[dd]\n\n!BUG in separator logic, doesn't work when leading zeros used, eg. printing\n!out a full length binary\n!so perhaps move this out to expandstr\n\t\t++k\n\t\tif sep and aa<>0 and k=g then\n\t\t\tt[++i]:=sep\n\t\t\tk:=0\n\t\tfi\n\tuntil aa=0\n\n\tj:=i\n\ts0:=s\n\twhile i do\n\t\ts^:=t[i--]\n\t\t++s\n\tod\n\ts^:=0\n\n\treturn j\nend\n\nexport function i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\n!a is signed 64-bit int/long, fmt is a ref to a filled-in fmtrec\n!convert a to a string in s, according to fmt\n!a basic conversion is done first,: the field manipulation is done\n!signed=1 for int, 0 for u32 (fmt.unsigned forces ints to be treated as longs)\n!returns length of s\n\t[0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint n, usigned\n\tconst i64 mindint=0x8000'0000'0000'0000\n\n\tusigned:=0\n\tif fmt.usigned then\n\t\tusigned:=1\n\tfi\n\tif aa=mindint and not usigned then\t\t! minint\n\n\t\tstr[0]:='-'\n\t\tn:=i64mintostr(&str[1],fmt.base,fmt.sepchar)+1\n\n\telse\n\t\tif (not usigned and aa<0) or fmt.plus then\n\t\t\tif aa<0 then\n\t\t\t\taa:=-aa\n\t\t\t\tstr[0]:='-'\n\t\t\telse\n\t\t\t\tstr[0]:='+'\n\t\t\tfi\n\t\t\tn:=u64tostr(aa,&str[1],fmt.base,fmt.sepchar)+1\n\t\telse\n\t\t\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\t\tfi\n\tfi\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif (fmt.base>10 or fmt.suffix) and fmt.lettercase='a'\tthen\t! need lower when\n\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nexport function u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\t\t!U64TOSTRFMT\n!see i64tostrfmt\n\t[0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint n\n\n\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif fmt.base>10 or fmt.suffix and fmt.lettercase='a'\tthen\t! need lower when\n!\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nexport function i64mintostr(ref char s,int base,int sep)int =\t\t!I64MINTOSTR\n!convert minint to string in s do not include minus sign\n!return number of chars in string\n\t[0:onesixty]char t\n\tint i,j,k,g\n\n\tcase base\n\twhen 10 then\n\t\tstrcpy(&t[0],\"9223372036854775808\")\n\t\tj:=3\n\twhen 16 then\n\t\tstrcpy(&t[0],\"8000000000000000\")\n\t\tj:=1\n\twhen 2 then\n\t\tstrcpy(&t[0],\"1000000000000000000000000000000000000000000000000000000000000000\")\n\t\tj:=7\n\telse\n\t\tstrcpy(&t[0],\"<mindint>\")\n\tesac\n\n\ti:=strlen(&t[0])\n\ts+:=i\n\tif sep then\n\t\ts+:=j\n\tfi\n\ts^:=0\n\n\tk:=0\n\tg:=(base=10|3|4)\n\n\twhile i do\n\t\t--s\n\t\ts^:=t[i-- -1]\n\t\tif sep and i and ++k=g then\n\t\t\t--s\n\t\t\ts^:=sep\n\t\t\tk:=0\n\t\tfi\n\tod\n\treturn strlen(s)\nend\n\nexport function strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int =\n!s is a string process according to fmtrec fmt^, and return result in t\n!caller should check whether any changes are required to s (now it can just use s), but this\n!check is done here anyway (with a simple copy to t)\n!n is current length of s\n!return length of t\n!Three processing stages:\n!1 Basic input string s\n!2 Additions or mods: quotes, suffix, when conversion\n!3 Width adjustment\n!1 is detected here, 2 is done here, 3 is done by expandstr\n\tref char u,v\n\t[256]char str\n\tint w,nheap\t\t! whether any heap storage is used  bytes allocated\n\n\tnheap:=0\n\n\tif fmt.quotechar or fmt.lettercase then\t\t! need local copy\n\t\tif n<256 then\n\t\t\tu:=&.str\n\t\telse\n\t\t\tnheap:=n+3\t\t\t\t\t! allow for quotes+terminator\n\t\t\tu:=pcm_alloc(nheap)\n\t\tfi\n\t\tif fmt.quotechar then\n\t\t\tv:=u\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tif n then\n\t\t\t\tstrcpy(v,s)\n\t\t\t\tv+:=n\n\t\t\tfi\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tv^:=0\n\t\t\tn+:=2\n\t\telse\n\t\t\tmemcpy(u,s,n)\n\t\tfi\n\t\tcase fmt.lettercase\n\t\twhen 'a' then\t! need lower when\n\t\t\tconvlcstring(u)\n\t\twhen 'A' then\n\t\t\tconvucstring(u)\n\t\tesac\n\t\ts:=u\n\tfi\n\n\tw:=fmt.minwidth\n\tif w>n then\n\t\tn:=expandstr(s,t,n,fmt)\n\telse\n\t\tmemcpy(t,s,n)\n\tfi\n\tif nheap then\n\t\tpcm_free(u,nheap)\n\tfi\n\treturn n\nend\n\nproc tostr_i64(i64 a, ref fmtrec fmt)=\n\t[360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 0 then\n\t\tn:=i64tostrfmt(a,&.str,fmt)\n\twhen 'M' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\telse\t\t\t\t\t\t!assume 'C'\n\t\tm$print_c8(a, nil)\n!\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_u64(u64 a, ref fmtrec fmt)=\n\t[360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 'M' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\twhen 'C' then\n\t\tm$print_c8(a, nil)\n!\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\n\telse\n\t\tn:=u64tostrfmt(a,&.str,fmt)\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_r64(real x,ref fmtrec fmt) =\n\t[360]char str,str2\n\t[0:10]char cfmt\n\tint n\n\n\tcfmt[0]:='%'\n\n\tif fmt.precision then\n\t\tcfmt[1]:='.'\n\t\tcfmt[2]:='*'\n\t\tcfmt[3]:=fmt.realfmt\n\t\tcfmt[4]:=0\n\t\tsprintf(&.str,&.cfmt,fmt.precision,x)\n\telse\n\t\tcfmt[1]:=fmt.realfmt\n\t\tcfmt[2]:=0\n\t\tsprintf(&.str,&.cfmt,x)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\n\tn:=strlen(&.str)\t\t! current length\n\n\tif n<fmt.minwidth then\n\t\tn:=expandstr(&.str,&.str2,n,fmt)\n\t\tstrcpy(&.str,&.str2)\n\tfi\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_str(ref char s, int oldlen, ref fmtrec fmt) =\n\tint newlen,n\n\tref char t\n\n!try and work out size of formatted string\n\tif oldlen=-1 then\n\t\toldlen:=strlen(s)\n\tfi\n\tnewlen:=oldlen\n\n\tif fmt.quotechar or fmt.minwidth>newlen or fmt.lettercase or fmt.precision then\n\t\tif fmt.quotechar then\n\t\t\tnewlen+:=2\n\t\tfi\n\t\tif fmt.minwidth>newlen then\n\t\t\tnewlen:=fmt.minwidth\n\t\tfi\n\t\tt:=pcm_alloc(newlen+1)\n\t\tn:=strtostrfmt(s,t,oldlen,fmt)\n\t\tif fmt.precision then\n\t\t\tn min:=fmt.precision\n\t\tfi\n\n\t\tprintstr_n(t,n)\n\t\tpcm_free(t,newlen+1)\n\telse\n\t\tprintstr_n(s,oldlen)\n\tfi\nend\n\nfunction getfmt(ichar fmtstyle)ref fmtrec=\n\tstatic fmtrec fmt\n\tif fmtstyle then\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\treturn &fmt\n\telse\n\t\treturn &defaultfmt\n\tfi\nend\n\nexport function strint(i64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_i64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport proc getstrint(i64 a, ichar dest)=\n\tm$print_startstr(dest)\n\ttostr_i64(a,getfmt(nil))\n\tm$print_end()\nend\n\nexport function strword(u64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_u64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function strreal(real a, ichar fmtstyle=nil)ichar=\n\tstatic [320]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_r64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function getstr(ichar s, ref fmtrec fmt)ichar=\n\tif fmt.heapmode then\n\t\treturn pcm_copyheapstring(s)\n\telse\n\t\treturn s\n\tfi\nend\n\nproc initreadbuffer=\n\tif rd_buffer then return fi\n\trd_buffer:=pcm_alloc(rd_buffersize)\n\trd_buffer^:=0\n\trd_pos:=rd_lastpos:=rd_buffer\nend\n\nglobal proc m$read_conline=\n\tinitreadbuffer()\n\n\treadlinen(nil,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_fileline(filehandle f)=\n\tinitreadbuffer()\n\n\tif f=filehandle(1) then\nABORTPROGRAM(\"READ CMDLINE\")\n!\t\trd_buffer^:=0\n!\t\tp:=getcommandlinea()\n!\t\trepeat\n!\t\t\t++p\n!\t\tuntil p^ in [' ','\\t',0]\n!\t\tstrcpy(rd_buffer, p)\n!\t\trd_length:=strlen(rd_buffer)\n!\t\trd_pos:=rd_buffer\n!\t\trd_lastpos:=nil\n\t\treturn\n\tfi\n\n\treadlinen(f,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_strline(ichar s)=\n\tint n\n\n\tinitreadbuffer()\n\tn:=strlen(s)\n\n\tif n<rd_buffersize then\n\t\tstrcpy(rd_buffer,s)\n\telse\n\t\tmemcpy(rd_buffer,s,rd_buffersize-1)\n\t\t(rd_buffer+rd_buffersize-1)^:=0\n\tfi\n\trd_length:=n\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nfunction readitem(int &itemlength)ref char =\n!read next item from rd_buffer\n!identify a substring that can contain a name, int, real, string or filename\n!return updated position of s that points past the item and past the immediate\n!terminator \n!information about the read item is returned in itemstr, which points to\n!the start of the item, and in itemlength. Item excludes any surrounding whitespace\n!Item can be quoted, then the item points inside the quotes\n!Any embedded quotes are removed, and the characters moved up. The item will\n!be that reduced subsequence\n!NOTE THAT THIS IS DESTRUCTIVE. On reread, the input will be different.\n!I can mitigate this by adding spaces between the end of the item, and the next item,\n!overwriting also the terminator. But this won't restore the line if one of the next\n!reads is literal, using 'L' or 'C' codes.\n\tref char p,s,itemstr\n\tchar quotechar, c\n\n\tunless rd_buffer then \n\t\tinitreadbuffer()\n\tend unless\n\n\ts:=rd_pos\n\n!scan string, eliminating leading white space\n\twhile s^=' ' or s^=9 do\n\t\t++s\n\tod\n\n\titemstr:=s\n\trd_lastpos:=rd_pos:=s\n\n\tif s^=0 then\n\t\ttermchar:=0\n\t\titemlength:=0\n\t\treturn s\n\tfi\n\n\tquotechar:=0\n\tif s^='\"' then\n\t\tquotechar:='\"'\n\t\t++s\n\telsif s^='\\'' then\n\t\tquotechar:='\\''\n\t\t++s\n\tfi\n\n!loop reading characters until separator or end reached\n\tp:=itemstr:=s\n\n\twhile s^ do\n\t\tc:=s++^\n\t\tcase c\n\t\twhen ' ', 9, comma, '=' then\t\t! separator\n\t\t\tif quotechar or p=s then\t\t\t!can be considered part of name if inside quotes, or is only char\n\t\t\t\tgoto normalchar\n\t\t\tfi\n\t\t\ttermchar:=c\n\t\t\texit\n\t\telse\n\tnormalchar:\n\t\t\tif c=quotechar then\n\t\t\t\tif s^=quotechar then\t! embedded quote\n\t\t\t\t\tp^:=c\n\t\t\t\t\t++s\n\t\t\t\t\t++p\n\t\t\t\telse\t\t\t\t\t! end of name\n\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tif termchar in [',', '='] then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tfi\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tp^:=c\n\t\t\t\t++p\n\t\t\tfi\n\t\tesac\n\tod\n\n\tif s^=0 then\n\t\ttermchar:=0\n\tfi\n\titemlength:=p-itemstr\t\t\t\t! actual length of token\n\trd_pos:=s\n\n\treturn itemstr\nend\n\nexport function strtoint(ichar s,int length=-1, word base=10)i64=\n!return point to next char after terminator (which can be just off length of string)\n\tbyte signd\n\tu64 aa\n\tword c,d\n\n\titemerror:=0\n\n\tif length=-1 then\n\t\tlength:=strlen(s)\n\tfi\n!check for sign\n\tsignd:=0\n\tif length and s^='-' then\n\t\tsignd:=1; ++s; --length\n\telsif length and s^='+' then\n\t\t++s; --length\n\tfi\n\n\taa:=0\n\twhile length do\n\t\tc:=s++^\n\t\t--length\n\t\tif c in 'A'..'F' then d:=c-'A'+10\n\t\telsif c in 'a'..'f' then d:=c-'a'+10\n\t\telsif c in '0'..'9' then d:=c-'0'\n\t\telsif c in ['_', '\\''] then\n\t\t\tnextloop\n\t\telse\n\t\t\titemerror:=1\n\t\t\texit\n\t\tfi\n\n\t\tif d>=base then\n\t\t\titemerror:=1\n\t\t\texit\n\t\tfi\n\t\taa:=aa*base+d\n\tod\n\n\tif signd then\n\t\treturn -aa\n\telse\n\t\treturn aa\n\tfi\nend\n\nglobal function m$read_i64(int fmt=0)i64=\n\tref char s\n\tint length\n\n\tfmt:=toupper(fmt)\n\n\tcase fmt\n\twhen 'C' then\n\t\trd_lastpos:=rd_pos\n\t\tif rd_pos^ then\n\t\t\treturn rd_pos++^\n\t\telse\n\t\t\treturn 0\n\t\tfi\n\twhen 'T' then\n\t\treturn termchar\n\twhen 'E' then\n\t\treturn itemerror\n\tesac\n\n\ts:=readitem(length)\n\n\tcase fmt\n\twhen 0,'I' then\n\t\treturn strtoint(s,length)\n\twhen 'B' then\n\t\treturn strtoint(s,length,2)\n\twhen 'H' then\n\t\treturn strtoint(s,length,16)\n\tesac\n\treturn 0\nend\n\nglobal function m$read_r64(int fmt=0)real=\n\t[512]char str\n\tref char s\n\tint length\n\ti32 numlength\n\treal x\n\n\ts:=readitem(length)\n\n\tif length=0 or length>=str.len then\t\t!assume not a real\n\t\treturn 0.0\n\tfi\n\tmemcpy(&.str,s,length)\n\tstr[length+1]:=0\n\n\titemerror:=0\n\n\tif sscanf(&.str,\"%lf%n\", &x, &numlength)=0 or numlength<>length then\n\t\tx:=0.0\n\t\titemerror:=1\n\tfi\n\n\treturn x\nend\n\nglobal proc m$read_str(ref char dest, int destlen=0,fmt=0)=\n\tref char s\n\tint length\n\n\titemerror:=0\n\tif fmt in ['L','l'] then\n\t\ts:=rd_pos\n\t\tlength:=rd_buffer+rd_length-rd_pos\n\n\telse\n\t\ts:=readitem(length)\n\n\t\tif fmt in ['N','n'] then\n\t\t\ticonvlcn(s,length)\n\t\tfi\n\tfi\n\n\tif destlen>0 then\n\t\tif length>=destlen then\n\t\t\tlength:=destlen-1\n\t\t\titemerror:=1\n\t\tfi\n\tfi\n\tmemcpy(dest,s,length)\n\t(dest+length)^:=0\nend\n\nexport proc readstr(ref char dest, int fmt=0,destlen=0)=\n\tm$read_str(dest,destlen,fmt)\nend\n\nexport proc rereadln=\n\trd_pos:=rd_buffer\n\trd_lastpos:=rd_pos\nend\n\nexport proc reread=\n\trd_pos:=rd_lastpos\nend\n\nexport function valint(ichar s, int fmt=0)i64=\n\tref char old_pos, old_lastpos\n\ti64 aa\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\taa:=m$read_i64(fmt)\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn aa\nend\n\nexport function valreal(ichar s)real=\n\tref char old_pos, old_lastpos\n\treal x\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\tx:=m$read_r64()\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn x\nend\n\nproc mclunimpl(ichar mess)=\n\tprintf(\"MCL-UNIMPL: %s\\n\",mess)\n\tstop 1\nend\n\nproc dumpstr(ichar s, int n, fbuffer=0)=\n!fbuffer=1 when outputting contents of buffer\n\n\tref ref char p\n\n\tif outdev=str_io then\n\t\tp:=cast(outchan)\n\t\tif n then\n\t\t\tmemcpy(p^,s,n)\n\t\t\tp^+:=n\n\t\tfi\n\t\tp^^:=0\n\t\treturn\n\tfi\n\n\treturn when n=0\n\tif fbuffer and n>=2 and outdev=std_io then\n\t\t--printptr\t\t\t\t!point to last char\n\t\tif printptr^=10 then\n\t\t\tif (printptr-1)^=13 then\t\t!crlf\n\t\t\t\t(printptr-1)^:=0\n\t\t\telse\t\t\t\t\t\t\t!lf only\n\t\t\t\tprintptr^:=0\n\t\t\tfi\n\t\t\tputs(printbuffer)\n\t\t\treturn\n\t\tfi\n\tfi\n\n\tcase outdev\n\twhen std_io then\n\t\tprintf(\"%.*s\",n,s)\n\twhen file_io then\n\t\tfprintf(outchan,\"%.*s\",n,s)\n\tesac\nend\n\nproc dumpprintbuffer=\n\tif printlen then\n\t\tdumpstr(&.printbuffer,printlen,1)\n\tfi\n\n\tresetprintbuffer()\nend\n\nproc resetprintbuffer=\n\tprintptr:=&.printbuffer\n\tprintlen:=0\nend\n\nproc addtobuffer(ichar s, int n)=\n\tif printlen+n>=(printbuffer.len-8) then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif n<printbuffer.len then\n\t\tmemcpy(printptr,s,n)\n\t\tprintptr+:=n\n\t\tprintlen+:=n\n\t\treturn\n\tfi\n\n\tdumpstr(s, n)\t\t\t!don't bother with buffer\nend\n\nglobal function m$power_i64(i64 a,n)i64=\n\tif n<0 then\n\t\treturn 0\n\telsif n=0 then\n\t\treturn 1\n\telsif n=1 then\n\t\treturn a\n\telsif (n iand 1)=0 then\n\t\treturn m$power_i64(sqr a,n/2)\n\telse\t\t\t!assume odd\n\t\treturn m$power_i64(sqr a,(n-1)/2)*a\n\tfi\nend\n\nfunc getutfsize(ref char s)int =\n!work out the size in bytes of the ascii or utf8 character that s points to\n\tint a\n\n\ta:=s++^\n\n\tif a=0 then\t\t\t\t\t\t!end of string\n\t\t0\n\telsif a.[7]=0 then\t\t\t\t!ascii\n\t\t1\n\telsif a.[7..5]=2x110 then\n\t\t2\n\telsif a.[7..4]=2x1110 then\n\t\t3\n\telsif a.[7..3]=2x11110 then\n\t\t4\n\telse\t\t\t\t\t\t\t!error: just assume a byte of random binary\n\t\t1\n\tfi\nend\n\n!export fun `fract(real x)real = fmod(x,1.0)\n!export fun fraction(real x)real = fmod(x,1.0)\n\n!export fun m$sign_i64(int a)int = (a<0|-1| (a>0|1|0))\n!\n!export func m$sign_r64(real x)real =\n!\tif x<0 then return -1 fi\n!\tif x>0 then return 1 fi\n!\t0\n!end\n",
(u64)"global record procinforec=\n\tu16\t\tfnindex\n\tbyte\t\trettype\n\tbyte\t\tnparams\n\t[12]byte\tparamlist\nend\n\n!for print/read routines\n!------------------------------------------\nexport record fmtrec=\t! (default)\n\tbyte\tminwidth\t! n (0)   min field width (0 if not used or don't care)\n\ti8\t\tprecision\t! .n (0)   number of decimals/significant figures/max width\n\tbyte\tbase\t\t! B,H or Xn (10)  2 to 16\n\n\tchar\tquotechar\t! Qc (0)   0 or '\"' or c\n\tchar\tpadchar\t\t! Pc, Z (' ')\n\tchar\trealfmt\t\t! E,F,G ('f') 'e' or 'f' or 'g'\n\n\tchar\tplus\t\t! (0)   0 or '+'\n\tchar\tsepchar\t\t! Sc (0)   0 or ',' or c placed every 3 (base=10) or 4 digits\n\tchar\tlettercase\t! A,a ('A') 'A' or 'a'\n\tchar\tjustify\t\t! JL, JR, JC ('R') 'L' or 'R' or 'C'?\n\tchar\tsuffix\t\t! Tc (0)   0 or 'B' or 'H' or c\n\tchar\tusigned\t\t! W (0)   0 or 'W' force unsigned o/p for ints (eg. for hex display)\n\tchar\tcharmode\t! C,M (0)  0 or 'C' or 'M'\to/p int as int or single char or multi-char\n\tchar\theapmode\t! D (0)  'D' for str-functions, return ptr to heap string\n\tchar\tparam\t\t! Use int value for <fmtparam>\n\tbyte\tspare : (showtype:1, newline:1)\nend\n\nint fmtparam\t\t\t!as set with :'V'\n\nenumdata =\n\tstd_io,file_io,str_io\nend\n\nconst comma = ','\n\nexport int $cmdskip\t\t\t!0 unless set by READMCX/etc\n\nexport int needgap\t\t\t= 0\nint outdev\t\t\t= std_io\nfilehandle outchan\t= nil\nref char fmtstr \t= nil\n\nconst maxiostack=10\n[maxiostack]filehandle\toutchan_stack\n[maxiostack]int\t\t\toutdev_stack\n[maxiostack]ref char\tfmtstr_stack\n[maxiostack]byte\t\tneedgap_stack\n\n[maxiostack]ref char\tptr_stack\t\t!this one doesn't need pushing, as each is pointed to from outchan\nint niostack=0\n\n[0:]char digits=A\"0123456789ABCDEF\"\nconst onesixty=360\nfmtrec defaultfmt = (0,0, 10, 0,' ','f', 0,0,0,'R',0,0, 0,0,0,0)\n\n!Read buffer vars\nexport const rd_buffersize = 16384\t!total capacity of line buffer\n\nexport ref char rd_buffer\t\t! point to start of read buffer\nexport int rd_length\t\t\t! length of this line (as read by readln)\nexport ref char rd_pos\t\t\t! current position it's up to (next read starts here)\nexport ref char rd_lastpos\t\t! set by sread() just before reading used for reread()\n\nint termchar\t\t\t! terminator char set by readxxx()\nint itemerror\t\t\t!\tset by some read functions, eg for reals\n\n[4096]char printbuffer\nichar printptr\nint printlen\n\n!------------------------------------------\n\nexport int ncmdparams\n!export ref[]ichar cmdparams\nexport ref[0:]ichar cmdparams\n\nproc $getcommands(int ncmd, ref[0:]ichar cmds, int cmdskipL)=\n!CPL =$CMDSKIP\n!CPL =CMDSKIPL\n\tncmdparams:=ncmd-1\n\tcmdparams:=cmds\nend\n\n!export proc m$init(int nargs, ref[]ichar args)=\n!\tnsysparams:=nargs\n!\n!\tif nsysparams>maxparam then\n!\t\tprintf(\"Too many params\\n\")\n!\t\tstop 1\n!\tfi\n!\n!\tfor i:=1 to nargs do\n!\t\tsysparams[i]:=args[i]\n!\tod\n!\n!!assume nsysparams is >=1, since first is always the program name\n!\tncmdparams:=nsysparams-($cmdskip+1)\n!\tcmdparams:=cast(&sysparams[$cmdskip+1])\n!\n!\tint j:=1\n!\tnenvstrings:=0\n!!\twhile envstrings[j] do\n!!\t\t++nenvstrings\n!!\t\t++j\n!!\tod\n!\n!end\n\nproc pushio=\n\tif niostack>=maxiostack then\n\t\tprintf(\"Too many io levels\\n\")\n\t\tstop 53\n\tfi\n\t++niostack\n\toutchan_stack[niostack]\t:= outchan\n\toutdev_stack[niostack]\t:= outdev\n\tfmtstr_stack[niostack]\t:= fmtstr\n\tneedgap_stack[niostack]\t:= needgap\n\tneedgap:=0\n\tfmtstr:=nil\n\toutchan:=nil\nend\n\nexport proc m$print_startfile(ref void dev)=\n\tpushio()\n\toutchan:=cast(dev)\n\tif dev then\n\t\toutdev:=file_io\n\telse\n\t\toutdev:=std_io\n\tfi\n\tresetprintbuffer()\nend\n\nexport proc m$print_startstr(ref char s)=\n\tref ref char p\n\tpushio()\n\n\tptr_stack[niostack]:=s\n\tp:=&ptr_stack[niostack]\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startptr(ref ref char p)=\n\tpushio()\n\n\toutchan:=cast(p)\n\toutdev:=str_io\nend\n\nexport proc m$print_startcon=\n\tpushio()\n\toutdev:=std_io\n\tresetprintbuffer()\nend\n\nexport proc m$print_setfmt(ref char format)=\n\tfmtstr:=format\nend\n\nexport proc m$print_end=\n\tneedgap:=0\n\tnextfmtchars(1)\n\tif niostack=1 and outdev in [std_io,file_io] then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif niostack=0 then return fi\n\toutchan\t:= outchan_stack[niostack]\n\toutdev\t:= outdev_stack[niostack]\n\tfmtstr\t:= fmtstr_stack[niostack]\n\tneedgap\t:= needgap_stack[niostack]\n\n\t--niostack\nend\n\nexport proc m$print_ptr(u64 a,ichar fmtstyle=nil)=\n\tif fmtstyle=nil then\n\t\tfmtstyle:=\"z8H\"\n\tfi\n\tm$print_u64(a,fmtstyle)\nend\n\nexport proc m$print_ptr_nf(u64 a)=\n\tm$print_ptr(a)\nend\n\nexport proc m$print_i64(i64 a,ichar fmtstyle=nil)=\n\t[40]char s\n\tfmtrec fmt\n\tint n\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tif a>=0 then\n\t\t\tn:=u64tostr(a,&.s,10,0)\n\t\telsif a=i64.min then\n\t\t\tfmt:=defaultfmt\n\t\t\tdofmt\n\n\t\telse\n\t\t\ts[1]:='-'\n\t\t\tn:=u64tostr(-a,&s[2],10,0)+1\n\t\tfi\n\n\t\tprintstr_n(&.s,n)\n\n\telse\n\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\tif fmt.param='V' then\n\t\t\tfmtparam:=a\n\t\t\tneedgap:=0\n\t\telse\ndofmt:\n\t\t\ttostr_i64(a,&fmt)\n\t\tfi\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_i64_nf(i64 a)=\n\tm$print_i64(a)\nend\n\nexport proc m$print_bool(i64 a, ichar fmtstyle=nil)=\n\tif a then\n\t\tm$print_str(\"True\",fmtstyle)\n\telse\n\t\tm$print_str(\"False\",fmtstyle)\n\tfi\nend\n\nexport proc m$print_u64(u64 a,ichar fmtstyle=nil)=\n\t[40]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%llu\",a)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_u64(a,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_r64(real x,ichar fmtstyle=nil)=\n\t[360]char s\n\tfmtrec fmt\n\n\tnextfmtchars()\n\tif fmtstyle=nil then\n\t\tsprintf(&.s,\"%f\",x)\n\t\tprintstr(&.s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_r64(x,&fmt)\n\tfi\n\n\tneedgap:=1\nend\n\nexport proc m$print_r32(r32 x,ichar fmtstyle=nil)=\n\tm$print_r64(x,fmtstyle)\nend\n\nglobal proc m$print_c8(i64 a,ichar fmtstyle=nil)=\n\t[32]char s\n!\tint cc@s\n\tfmtrec fmt\n\tint n\n\tbyte charmode:=0\n\n\tnextfmtchars()\n\n\tif fmtstyle then\n\t\tstrtofmt(fmtstyle,-1, &fmt)\n\t\tcharmode:=fmt.charmode\n\tfi\n\n\tif charmode='M' then\n\t\tn:=domultichar(ref char(&a), 8, &.s, &fmt)\n!\t\tn:=domultichar(ref char(&a), 8, &.str, fmt)\n\telse\t\t\t\t\t\t!assume 'C'\n\t\t(ref int(&s)^):=a\t\n!\t\tcc:=a\t\n\t\ts[9]:=0\n\n\t\tn:=getutfsize(s)\t\t\t!isolate size of next char\n\tfi\n\n\tprintstr_n(s,n)\n\n\tneedgap:=1\nend\n\nexport proc m$print_str(ichar s, fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr(s)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,-1,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_strn(ichar s, int length, ichar fmtstyle=nil)=\n\tnextfmtchars()\n\n\tif s=nil then\n\t\tprintstr(\"<null>\")\n\t\treturn\n\tfi\n\n\tfmtrec fmt\n\tif fmtstyle=nil then\n\t\tprintstr_n(s,length)\n\telse\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\ttostr_str(s,length,&fmt)\n\tfi\n\tneedgap:=1\nend\n\nexport proc m$print_str_nf(ichar s)=\n\tm$print_str(s)\nend\n\nexport proc m$print_strsl(slice[]char s, ichar fmtstyle=nil)=\nABORTPROGRAM(\"PRTSL\")\n!\tnextfmtchars()\n!\n!!\tfmtrec fmt\n!\n!\tif fmtstyle=nil then\n!\t\tprintstr_n(cast(s.sliceptr),s.len)\n!!\t\tprintstr_n(cast(ss.str),ss.length)\n!\telse\n!\t\tabortprogram(\"FORMATED PRINT SLICE NOT READY\")\n!!\t\tstrtofmt(fmtstyle,-1,&fmt)\n!!\t\ttostr_str(s,s.len,&fmt)\n!\tfi\n!\tneedgap:=1\nend\n\nexport proc m$print_newline=\n!PUTS(\"<NEWLINE>\")\n\tneedgap:=0\n\tnextfmtchars(1)\n\tprintstr(\"\\w\")\nend\n\nexport proc m$print_nogap=\n\tneedgap:=0\nend\n\nexport proc m$print_space=\n\tneedgap:=0\n\tprintstr(\" \")\nend\n\nexport proc printstr(ichar s)=\n\tprintstr_n(s,strlen(s))\nend\n\nexport proc printstr_n(ichar s,int n)=\n\n!\treturn when n=0\n\n!\tif niostack=1 and outdev in [std_io,file_io] then\n!!puts(\"ADDTO BUFF\")\n!\t\taddtobuffer(s,n)\n!\telse\n!printf(\"DUMPSTR %lld\\n\", n)\n\t\tdumpstr(s,n)\n!\tfi\nend\n\nexport proc printstrn_app(ichar s, int length, filehandle f=nil)=\nif length then\n\tif f=nil then\n\t\tprintf(\"%.*s\",length,s)\n\telse\n\t\tfprintf(f,\"%.*s\",length,s)\n\tfi\nfi\nend\n\nproc printchar(int ch)=\n\t[4]char str\n\n\tstr[1]:=ch\n\tstr[2]:=0\n\tprintstr_n(str,1)\nend\n\nglobal proc nextfmtchars(int lastx=0)=\n\tchar c\n\tref char pstart\n\tint n\n\tif not fmtstr then\t\t\t!format not in use\n\t\tif needgap then\n\t\t\tprintchar(' ')\n\t\tfi\n\t\tneedgap:=0\n\t\treturn\n\tfi\n\n\tpstart:=fmtstr\n\tn:=0\n\n\tdo\n\t\tc:=fmtstr^\n\t\tcase c\n\t\twhen '#' then\n\t\t\tif lastx then\n\t\t\t\tgoto skip\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\tfi\n\t\t\treturn\n\t\twhen 0 then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\telsif not lastx then\n\t\t\t\tprintstr_n(\"|\",1)\n\t\t\tfi\n\t\t\treturn\n\t\twhen '~' then\n\t\t\tif n then\n\t\t\t\tprintstr_n(pstart,n)\n\t\t\t\tn:=0\n\t\t\tfi\n\t\t\t++fmtstr\n\t\t\tc:=fmtstr^\n\t\t\tif c then\n\t\t\t\t++fmtstr\n\t\t\t\tprintchar(c)\n\t\t\tfi\n\t\t\tpstart:=fmtstr\n\t\telse\n\tskip:\n\t\t\t++n\n\t\t\t++fmtstr\n\t\tesac\n\tod\nend\n\nexport proc strtofmt(ref char s,int slen,ref fmtrec fmt) =\t\t!PC_STRTOFMT\n!convert format code string in s, to fmtrec at fmt^\n!Format code is a string containing the following char codes (upper or lower when mostly)\n!n\tWidth\n!.n\tMax width/precision\n!A\tConvert to upper case\n!a\tConvert to lower case\n!B\tBinary\n!C\tShow int as single n-bit (unicode) character\n!D\tDuplicate string returned via STRINT etc on heap\n!E,F,G\tSpecify format for double (corresponds to C format codes)\n!F\n!G\n!H\tHex\n!JC\tJustify centre\n!JL\tJustify left\n!JR\tJustify right\n!M\tShow int as multi-bit (unicode) character\n!M\tHEAPMODE???\n!O\tOctal\n!Pc\tUse padding char c\n!Q\tAdd double quotes around string (and deal with embedded quotes)\n!'\tAdd single quotes around string (and deal with embedded quotes)\n!Sc\tUse separator char c between every 3 or 4 digits\n!Tc\tUse terminator char c (typically B or H)\n!U\tShow ints as unsigned\n!V\tFor ints, don't display: store value as parameter for subsequent '*'\n!W\tUnsigned\n!Xn\tUse base n (n is hex 0 to F)\n!Z\tUse \"0\" padding\n!+\tAlways have + or - in front of integers\n!~\tQuote char is ~\n!*\tSame as n but uses parameter set with :'V' on previous int\n\n\tint c, base\n\tbyte wset\n\tint n\n\t[0:100]char str\n\n\tfmt^:=defaultfmt\n\n\tif s=nil then return fi\n\n\tif slen=-1 then slen:=strlen(s) fi\n\n\tmemcpy(&.str,s,slen)\t\t!convert s/slen to zero-terminated string\n\tstr[slen]:=0\n\ts:=&.str\n\n\twset:=0\n\twhile s^ do\n\t\tc:=s^\n\t\t++s\n\t\tif c='A' then fmt.lettercase:='A'\n\t\telsif c='a' then fmt.lettercase:='a'\n\t\telseswitch toupper(c)\n\t\twhen 'B' then fmt.base:=2\n\t\twhen 'H' then fmt.base:=16\n\t\twhen 'O' then fmt.base:=8\n\t\twhen 'X' then\n\t\t\tbase:=0\n\t\t\tdo\n\t\t\t\tc:=s^\n\t\t\t\tif c in '0'..'9' then\n\t\t\t\t\tbase:=base*10+c-'0'\n\t\t\t\t\t++s\n\t\t\t\telse\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\tod\n\t\t\tif base in 2..16 then\n\t\t\t\tfmt.base:=base\n\t\t\tfi\n\n\t\twhen 'Q' then fmt.quotechar:='\"'\n\t\twhen 'J' then\n\t\t\tfmt.justify:=toupper(s^)\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'Z' then fmt.padchar:='0'\n\t\twhen 'S' then\n\t\t\tfmt.sepchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'P' then\n\t\t\tfmt.padchar:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'T' then\n\t\t\tfmt.suffix:=s^\n\t\t\tif s^ then\n\t\t\t\t++s\n\t\t\tfi\n\t\twhen 'U' then fmt.usigned:='W'\n\t\twhen 'E' then fmt.realfmt:='e'\n\t\twhen 'F' then fmt.realfmt:='f'\n\t\twhen 'G' then fmt.realfmt:='g'\n\t\twhen 'D' then fmt.heapmode:='D'\n\t\twhen 'C' then fmt.charmode:='C'\n\t\twhen 'M' then fmt.charmode:='M'\n\t\twhen 'V' then fmt.param:='V'\n\t\twhen 'Y' then fmt.showtype:=1\n\t\twhen 'N' then fmt.newline:=1\n\t\telsecase c\n\t\twhen '.' then\n\t\t\twset:=1\n\t\twhen comma,'_' then fmt.sepchar:=c\n\t\twhen '+' then fmt.plus:='+'\n\t\twhen '~' then fmt.quotechar:='~'\n\t\twhen '*' then\n\t\t\tn:=fmtparam\n\t\t\tgoto gotwidth\n\t\telse\n\t\t\tif c>='0' and c<='9' then\n\t\t\t\tn:=c-'0'\n\t\t\t\tdo\n\t\t\t\t\tc:=s^\n\t\t\t\t\tif s^=0 then\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\t\tif c>='0' and c<='9' then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\tn:=n*10+c-'0'\n\t\t\t\t\telse\n\t\t\t\t\t\texit\n\t\t\t\t\tfi\n\t\t\t\tod\ngotwidth:\n\t\t\t\tif not wset then\n\t\t\t\t\tfmt.minwidth:=n\n\t\t\t\t\twset:=1\n\t\t\t\telse\n\t\t\t\t\tfmt.precision:=n\n\t\t\t\tfi\n\t\t\tfi\n\t\tfi\n\tod\nend\n\nfunction domultichar (ref char p,int n,ref char dest,ref fmtrec fmt)int =\n!there are n (4 or 8) chars at p.!\n!There could be 0 to 4 or 8 printable chars converted to string at dest\n\t[0:20]char str\n\tref char q\n\tint nchars\n\n\tq:=&.str\n\n\tnchars:=n\n\n\tto n do\n\t\tif p^=0 then exit fi\n\t\tq^:=p^\n\t\t++q\n\t\t++p\n\tod\n\tq^:=0\n\n\treturn expandstr(&.str,dest,strlen(&.str),fmt)\nend\n\nexport function expandstr(ref char s,ref char t,int n,ref fmtrec fmt)int =\t\t!EXPANDSTR\n!s contains a partly stringified value.\n!widen s if necessary, according to fmt, and copy result to t\n!n is current length of s\n!note) = for non-numeric strings, fmt.base should be set to 0, to avoid moving\n!a leading +/- when right-justifying with '0' padding.\n!t MUST be big enough for the expanded string; caller must take care of this\n!result will be zero-terminated, for use in this module\n\n\tint i,w,m\n\n!check to see if result is acceptable as it is\n\tw:=fmt.minwidth\n\tif w=0 or w<=n then\t\t! allow str to be longer than minwidth\n\t\tstrncpy(t,s,n)\n\t\t(t+n)^:=0\n\t\treturn n\n\tfi\n\n\tif fmt.justify='L' then\t! left-justify\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tfor i:=1 to w-n do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\telsif fmt.justify='R' then\n\t\tif fmt.padchar='0' and fmt.base and (s^='-' or s^='+') then ! need to move sign outside \n\t\t\tt^:=s^\n\t\t\t++t\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s+1,n-1)\n\t\t\t(t+n-1)^:=0\n\t\telse\n\t\t\tto w-n do\n\t\t\t\tt^:=fmt.padchar\n\t\t\t\t++t\n\t\t\tod\n\t\t\tstrncpy(t,s,n)\n\t\t\t(t+n)^:=0\n\t\tfi\n\n\telse\t\t\t\t! centre-justify?\n\n\t\tm:=(w-n+1)/2\n\t\tto m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tstrncpy(t,s,n)\n\t\tt+:=n\n\t\tto w-n-m do\n\t\t\tt^:=fmt.padchar\n\t\t\t++t\n\t\tod\n\t\tt^:=0\n\n\tfi\n\treturn w\nend\n\nexport function u64tostr(u64 aa,ref char s,word base,int sep)int =\t\t!U64TOSTR\n!convert 64-bit int a to string in s^\n!base is number base, usually 10 but can be 2 or 16. Other bases allowed\n!result when a=minint (will give \"<minint>\")\n\t[0:onesixty]char t\n\tu64 dd\n\tint i,j,k,g\n\tref char s0\n\n\ti:=0\n\tk:=0\n\tg:=(base=10|3|4)\n\n\trepeat\n!\t\tif base=10 then\t\t\t!BUGGY FOR AA OVER I64.MAX\n!\t\t\tassem\n!\t\t\t\tmov\t\trcx, [aa]\n!\t\t\t\tmov\t\trax, rcx\n!\t\t\t\tmov\t\trdx, 7378697629483820647\n!\t\t\t\timul\trdx\n!\t\t\t\tmov\t\trax, rdx\n!\t\t\t\tmov\t\trdx, rcx\n!\t\t\t\tsar\t\trdx, 63\n!\t\t\t\tsar\t\trax, 2\n!\t\t\t\tsub\t\trax, rdx\n!\t\t\t\tlea\t\trdx, [rax+rax*4]\n!\t\t\t\tadd\t\trdx, rdx\n!\t\t\t\tsub\t\trcx, rdx\n!\t\t\t\tmov\t\t[dd], rcx\n!\t\t\t\tmov\t\t[aa], rax\n!\t\t\tend\n!\t\telse\n\t\t\tdd:=aa rem base\n\t\t\taa:=aa/base\n!\t\tfi\n\n\t\tt[++i]:=digits[dd]\n\n!BUG in separator logic, doesn't work when leading zeros used, eg. printing\n!out a full length binary\n!so perhaps move this out to expandstr\n\t\t++k\n\t\tif sep and aa<>0 and k=g then\n\t\t\tt[++i]:=sep\n\t\t\tk:=0\n\t\tfi\n\tuntil aa=0\n\n\tj:=i\n\ts0:=s\n\twhile i do\n\t\ts^:=t[i--]\n\t\t++s\n\tod\n\ts^:=0\n\n\treturn j\nend\n\nexport function i64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\n!a is signed 64-bit int/long, fmt is a ref to a filled-in fmtrec\n!convert a to a string in s, according to fmt\n!a basic conversion is done first,: the field manipulation is done\n!signed=1 for int, 0 for u32 (fmt.unsigned forces ints to be treated as longs)\n!returns length of s\n\t[0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint n, usigned\n\tconst i64 mindint=0x8000'0000'0000'0000\n\n\tusigned:=0\n\tif fmt.usigned then\n\t\tusigned:=1\n\tfi\n\tif aa=mindint and not usigned then\t\t! minint\n\n\t\tstr[0]:='-'\n\t\tn:=i64mintostr(&str[1],fmt.base,fmt.sepchar)+1\n\n\telse\n\t\tif (not usigned and aa<0) or fmt.plus then\n\t\t\tif aa<0 then\n\t\t\t\taa:=-aa\n\t\t\t\tstr[0]:='-'\n\t\t\telse\n\t\t\t\tstr[0]:='+'\n\t\t\tfi\n\t\t\tn:=u64tostr(aa,&str[1],fmt.base,fmt.sepchar)+1\n\t\telse\n\t\t\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\t\tfi\n\tfi\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif (fmt.base>10 or fmt.suffix) and fmt.lettercase='a'\tthen\t! need lower when\n\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nexport function u64tostrfmt(i64 aa,ref char s,ref fmtrec fmt)int =\t\t!U64TOSTRFMT\n!see i64tostrfmt\n\t[0:onesixty]char str\t\t\t\t! allow for binary with separators!\n\tint n\n\n\tn:=u64tostr(aa,&.str,fmt.base,fmt.sepchar)\n\n\tif fmt.suffix then\n\t\tstr[n]:=fmt.suffix\n\t\tstr[++n]:=0\n\tfi\n\n!str uses upper cases for hex/etc see if lc needed\n\tif fmt.base>10 or fmt.suffix and fmt.lettercase='a'\tthen\t! need lower when\n!\t\tconvlcstring(&.str)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\treturn expandstr(&.str,s,n,fmt)\nend\n\nexport function i64mintostr(ref char s,int base,int sep)int =\t\t!I64MINTOSTR\n!convert minint to string in s do not include minus sign\n!return number of chars in string\n\t[0:onesixty]char t\n\tint i,j,k,g\n\n\tcase base\n\twhen 10 then\n\t\tstrcpy(&t[0],\"9223372036854775808\")\n\t\tj:=3\n\twhen 16 then\n\t\tstrcpy(&t[0],\"8000000000000000\")\n\t\tj:=1\n\twhen 2 then\n\t\tstrcpy(&t[0],\"1000000000000000000000000000000000000000000000000000000000000000\")\n\t\tj:=7\n\telse\n\t\tstrcpy(&t[0],\"<mindint>\")\n\tesac\n\n\ti:=strlen(&t[0])\n\ts+:=i\n\tif sep then\n\t\ts+:=j\n\tfi\n\ts^:=0\n\n\tk:=0\n\tg:=(base=10|3|4)\n\n\twhile i do\n\t\t--s\n\t\ts^:=t[i-- -1]\n\t\tif sep and i and ++k=g then\n\t\t\t--s\n\t\t\ts^:=sep\n\t\t\tk:=0\n\t\tfi\n\tod\n\treturn strlen(s)\nend\n\nexport function strtostrfmt(ref char s,ref char t,int n,ref fmtrec fmt)int =\n!s is a string process according to fmtrec fmt^, and return result in t\n!caller should check whether any changes are required to s (now it can just use s), but this\n!check is done here anyway (with a simple copy to t)\n!n is current length of s\n!return length of t\n!Three processing stages:\n!1 Basic input string s\n!2 Additions or mods: quotes, suffix, when conversion\n!3 Width adjustment\n!1 is detected here, 2 is done here, 3 is done by expandstr\n\tref char u,v\n\t[256]char str\n\tint w,nheap\t\t! whether any heap storage is used  bytes allocated\n\n\tnheap:=0\n\n\tif fmt.quotechar or fmt.lettercase then\t\t! need local copy\n\t\tif n<256 then\n\t\t\tu:=&.str\n\t\telse\n\t\t\tnheap:=n+3\t\t\t\t\t! allow for quotes+terminator\n\t\t\tu:=pcm_alloc(nheap)\n\t\tfi\n\t\tif fmt.quotechar then\n\t\t\tv:=u\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tif n then\n\t\t\t\tstrcpy(v,s)\n\t\t\t\tv+:=n\n\t\t\tfi\n\t\t\tv^:=fmt.quotechar\n\t\t\t++v\n\t\t\tv^:=0\n\t\t\tn+:=2\n\t\telse\n\t\t\tmemcpy(u,s,n)\n\t\tfi\n\t\tcase fmt.lettercase\n\t\twhen 'a' then\t! need lower when\n\t\t\tconvlcstring(u)\n\t\twhen 'A' then\n\t\t\tconvucstring(u)\n\t\tesac\n\t\ts:=u\n\tfi\n\n\tw:=fmt.minwidth\n\tif w>n then\n\t\tn:=expandstr(s,t,n,fmt)\n\telse\n\t\tmemcpy(t,s,n)\n\tfi\n\tif nheap then\n\t\tpcm_free(u,nheap)\n\tfi\n\treturn n\nend\n\nproc tostr_i64(i64 a, ref fmtrec fmt)=\n\t[360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 0 then\n\t\tn:=i64tostrfmt(a,&.str,fmt)\n\twhen 'M' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\telse\t\t\t\t\t\t!assume 'C'\n\t\tm$print_c8(a, nil)\n!\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_u64(u64 a, ref fmtrec fmt)=\n\t[360]char str\n\tint n\n\n\tcase fmt.charmode\n\twhen 'M' then\n\t\tn:=domultichar(ref char(&a),8,&.str,fmt)\n\n\twhen 'C' then\n\t\tm$print_c8(a, nil)\n!\t\tprintchar(a)\t\t\t!no other formatting allowed\n\t\treturn\n\n\telse\n\t\tn:=u64tostrfmt(a,&.str,fmt)\n\tesac\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_r64(real x,ref fmtrec fmt) =\n\t[360]char str,str2\n\t[0:10]char cfmt\n\tint n\n\n\tcfmt[0]:='%'\n\n\tif fmt.precision then\n\t\tcfmt[1]:='.'\n\t\tcfmt[2]:='*'\n\t\tcfmt[3]:=fmt.realfmt\n\t\tcfmt[4]:=0\n\t\tsprintf(&.str,&.cfmt,fmt.precision,x)\n\telse\n\t\tcfmt[1]:=fmt.realfmt\n\t\tcfmt[2]:=0\n\t\tsprintf(&.str,&.cfmt,x)\n\tfi\n\n!at this point, n is the str length including signs and suffix\n\n\tn:=strlen(&.str)\t\t! current length\n\n\tif n<fmt.minwidth then\n\t\tn:=expandstr(&.str,&.str2,n,fmt)\n\t\tstrcpy(&.str,&.str2)\n\tfi\n\n\tprintstr_n(&.str,n)\nend\n\nproc tostr_str(ref char s, int oldlen, ref fmtrec fmt) =\n\tint newlen,n\n\tref char t\n\n!try and work out size of formatted string\n\tif oldlen=-1 then\n\t\toldlen:=strlen(s)\n\tfi\n\tnewlen:=oldlen\n\n\tif fmt.quotechar or fmt.minwidth>newlen or fmt.lettercase or fmt.precision then\n\t\tif fmt.quotechar then\n\t\t\tnewlen+:=2\n\t\tfi\n\t\tif fmt.minwidth>newlen then\n\t\t\tnewlen:=fmt.minwidth\n\t\tfi\n\t\tt:=pcm_alloc(newlen+1)\n\t\tn:=strtostrfmt(s,t,oldlen,fmt)\n\t\tif fmt.precision then\n\t\t\tn min:=fmt.precision\n\t\tfi\n\n\t\tprintstr_n(t,n)\n\t\tpcm_free(t,newlen+1)\n\telse\n\t\tprintstr_n(s,oldlen)\n\tfi\nend\n\nfunction getfmt(ichar fmtstyle)ref fmtrec=\n\tstatic fmtrec fmt\n\tif fmtstyle then\n\t\tstrtofmt(fmtstyle,-1,&fmt)\n\t\treturn &fmt\n\telse\n\t\treturn &defaultfmt\n\tfi\nend\n\nexport function strint(i64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_i64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport proc getstrint(i64 a, ichar dest)=\n\tm$print_startstr(dest)\n\ttostr_i64(a,getfmt(nil))\n\tm$print_end()\nend\n\nexport function strword(u64 a, ichar fmtstyle=nil)ichar=\n\tstatic [100]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_u64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function strreal(real a, ichar fmtstyle=nil)ichar=\n\tstatic [320]char str\n\tref fmtrec fmt\n\n\tm$print_startstr(&.str)\n\ttostr_r64(a,fmt:=getfmt(fmtstyle))\n\tm$print_end()\n\treturn getstr(&.str,fmt)\nend\n\nexport function getstr(ichar s, ref fmtrec fmt)ichar=\n\tif fmt.heapmode then\n\t\treturn pcm_copyheapstring(s)\n\telse\n\t\treturn s\n\tfi\nend\n\nproc initreadbuffer=\n\tif rd_buffer then return fi\n\trd_buffer:=pcm_alloc(rd_buffersize)\n\trd_buffer^:=0\n\trd_pos:=rd_lastpos:=rd_buffer\nend\n\nglobal proc m$read_conline=\n\tinitreadbuffer()\n\n\treadlinen(nil,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_fileline(filehandle f)=\n\tinitreadbuffer()\n\n\tif f=filehandle(1) then\nABORTPROGRAM(\"READ CMDLINE\")\n!\t\trd_buffer^:=0\n!\t\tp:=getcommandlinea()\n!\t\trepeat\n!\t\t\t++p\n!\t\tuntil p^ in [' ','\\t',0]\n!\t\tstrcpy(rd_buffer, p)\n!\t\trd_length:=strlen(rd_buffer)\n!\t\trd_pos:=rd_buffer\n!\t\trd_lastpos:=nil\n\t\treturn\n\tfi\n\n\treadlinen(f,rd_buffer,rd_buffersize)\n\n\trd_length:=strlen(rd_buffer)\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nglobal proc m$read_strline(ichar s)=\n\tint n\n\n\tinitreadbuffer()\n\tn:=strlen(s)\n\n\tif n<rd_buffersize then\n\t\tstrcpy(rd_buffer,s)\n\telse\n\t\tmemcpy(rd_buffer,s,rd_buffersize-1)\n\t\t(rd_buffer+rd_buffersize-1)^:=0\n\tfi\n\trd_length:=n\n\trd_pos:=rd_buffer\n\trd_lastpos:=nil\nend\n\nfunction readitem(int &itemlength)ref char =\n!read next item from rd_buffer\n!identify a substring that can contain a name, int, real, string or filename\n!return updated position of s that points past the item and past the immediate\n!terminator \n!information about the read item is returned in itemstr, which points to\n!the start of the item, and in itemlength. Item excludes any surrounding whitespace\n!Item can be quoted, then the item points inside the quotes\n!Any embedded quotes are removed, and the characters moved up. The item will\n!be that reduced subsequence\n!NOTE THAT THIS IS DESTRUCTIVE. On reread, the input will be different.\n!I can mitigate this by adding spaces between the end of the item, and the next item,\n!overwriting also the terminator. But this won't restore the line if one of the next\n!reads is literal, using 'L' or 'C' codes.\n\tref char p,s,itemstr\n\tchar quotechar, c\n\n\tunless rd_buffer then \n\t\tinitreadbuffer()\n\tend unless\n\n\ts:=rd_pos\n\n!scan string, eliminating leading white space\n\twhile s^=' ' or s^=9 do\n\t\t++s\n\tod\n\n\titemstr:=s\n\trd_lastpos:=rd_pos:=s\n\n\tif s^=0 then\n\t\ttermchar:=0\n\t\titemlength:=0\n\t\treturn s\n\tfi\n\n\tquotechar:=0\n\tif s^='\"' then\n\t\tquotechar:='\"'\n\t\t++s\n\telsif s^='\\'' then\n\t\tquotechar:='\\''\n\t\t++s\n\tfi\n\n!loop reading characters until separator or end reached\n\tp:=itemstr:=s\n\n\twhile s^ do\n\t\tc:=s++^\n\t\tcase c\n\t\twhen ' ', 9, comma, '=' then\t\t! separator\n\t\t\tif quotechar or p=s then\t\t\t!can be considered part of name if inside quotes, or is only char\n\t\t\t\tgoto normalchar\n\t\t\tfi\n\t\t\ttermchar:=c\n\t\t\texit\n\t\telse\n\tnormalchar:\n\t\t\tif c=quotechar then\n\t\t\t\tif s^=quotechar then\t! embedded quote\n\t\t\t\t\tp^:=c\n\t\t\t\t\t++s\n\t\t\t\t\t++p\n\t\t\t\telse\t\t\t\t\t! end of name\n\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tif termchar in [',', '='] then\n\t\t\t\t\t\t++s\n\t\t\t\t\t\ttermchar:=s^\n\t\t\t\t\tfi\n\t\t\t\t\texit\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tp^:=c\n\t\t\t\t++p\n\t\t\tfi\n\t\tesac\n\tod\n\n\tif s^=0 then\n\t\ttermchar:=0\n\tfi\n\titemlength:=p-itemstr\t\t\t\t! actual length of token\n\trd_pos:=s\n\n\treturn itemstr\nend\n\nexport function strtoint(ichar s,int length=-1, word base=10)i64=\n!return point to next char after terminator (which can be just off length of string)\n\tbyte signd\n\tu64 aa\n\tword c,d\n\n\titemerror:=0\n\n\tif length=-1 then\n\t\tlength:=strlen(s)\n\tfi\n!check for sign\n\tsignd:=0\n\tif length and s^='-' then\n\t\tsignd:=1; ++s; --length\n\telsif length and s^='+' then\n\t\t++s; --length\n\tfi\n\n\taa:=0\n\twhile length do\n\t\tc:=s++^\n\t\t--length\n\t\tif c in 'A'..'F' then d:=c-'A'+10\n\t\telsif c in 'a'..'f' then d:=c-'a'+10\n\t\telsif c in '0'..'9' then d:=c-'0'\n\t\telsif c in ['_', '\\''] then\n\t\t\tnextloop\n\t\telse\n\t\t\titemerror:=1\n\t\t\texit\n\t\tfi\n\n\t\tif d>=base then\n\t\t\titemerror:=1\n\t\t\texit\n\t\tfi\n\t\taa:=aa*base+d\n\tod\n\n\tif signd then\n\t\treturn -aa\n\telse\n\t\treturn aa\n\tfi\nend\n\nglobal function m$read_i64(int fmt=0)i64=\n\tref char s\n\tint length\n\n\tfmt:=toupper(fmt)\n\n\tcase fmt\n\twhen 'C' then\n\t\trd_lastpos:=rd_pos\n\t\tif rd_pos^ then\n\t\t\treturn rd_pos++^\n\t\telse\n\t\t\treturn 0\n\t\tfi\n\twhen 'T' then\n\t\treturn termchar\n\twhen 'E' then\n\t\treturn itemerror\n\tesac\n\n\ts:=readitem(length)\n\n\tcase fmt\n\twhen 0,'I' then\n\t\treturn strtoint(s,length)\n\twhen 'B' then\n\t\treturn strtoint(s,length,2)\n\twhen 'H' then\n\t\treturn strtoint(s,length,16)\n\tesac\n\treturn 0\nend\n\nglobal function m$read_r64(int fmt=0)real=\n\t[512]char str\n\tref char s\n\tint length\n\ti32 numlength\n\treal x\n\n\ts:=readitem(length)\n\n\tif length=0 or length>=str.len then\t\t!assume not a real\n\t\treturn 0.0\n\tfi\n\tmemcpy(&.str,s,length)\n\tstr[length+1]:=0\n\n\titemerror:=0\n\n\tif sscanf(&.str,\"%lf%n\", &x, &numlength)=0 or numlength<>length then\n\t\tx:=0.0\n\t\titemerror:=1\n\tfi\n\n\treturn x\nend\n\nglobal proc m$read_str(ref char dest, int destlen=0,fmt=0)=\n\tref char s\n\tint length\n\n\titemerror:=0\n\tif fmt in ['L','l'] then\n\t\ts:=rd_pos\n\t\tlength:=rd_buffer+rd_length-rd_pos\n\n\telse\n\t\ts:=readitem(length)\n\n\t\tif fmt in ['N','n'] then\n\t\t\ticonvlcn(s,length)\n\t\tfi\n\tfi\n\n\tif destlen>0 then\n\t\tif length>=destlen then\n\t\t\tlength:=destlen-1\n\t\t\titemerror:=1\n\t\tfi\n\tfi\n\tmemcpy(dest,s,length)\n\t(dest+length)^:=0\nend\n\nexport proc readstr(ref char dest, int fmt=0,destlen=0)=\n\tm$read_str(dest,destlen,fmt)\nend\n\nexport proc rereadln=\n\trd_pos:=rd_buffer\n\trd_lastpos:=rd_pos\nend\n\nexport proc reread=\n\trd_pos:=rd_lastpos\nend\n\nexport function valint(ichar s, int fmt=0)i64=\n\tref char old_pos, old_lastpos\n\ti64 aa\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\taa:=m$read_i64(fmt)\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn aa\nend\n\nexport function valreal(ichar s)real=\n\tref char old_pos, old_lastpos\n\treal x\n\n\tinitreadbuffer()\n\told_pos:=rd_pos\n\told_lastpos:=rd_lastpos\n\n\trd_pos:=s\n\tx:=m$read_r64()\n\trd_pos:=old_pos\n\trd_lastpos:=old_lastpos\n\treturn x\nend\n\nproc mclunimpl(ichar mess)=\n\tprintf(\"MCL-UNIMPL: %s\\n\",mess)\n\tstop 1\nend\n\nproc dumpstr(ichar s, int n, fbuffer=0)=\n!fbuffer=1 when outputting contents of buffer\n\n\tref ref char p\n\n\tif outdev=str_io then\n\t\tp:=cast(outchan)\n\t\tif n then\n\t\t\tmemcpy(p^,s,n)\n\t\t\tp^+:=n\n\t\tfi\n\t\tp^^:=0\n\t\treturn\n\tfi\n\n\treturn when n=0\n\tif fbuffer and n>=2 and outdev=std_io then\n\t\t--printptr\t\t\t\t!point to last char\n\t\tif printptr^=10 then\n\t\t\tif (printptr-1)^=13 then\t\t!crlf\n\t\t\t\t(printptr-1)^:=0\n\t\t\telse\t\t\t\t\t\t\t!lf only\n\t\t\t\tprintptr^:=0\n\t\t\tfi\n\t\t\tputs(printbuffer)\n\t\t\treturn\n\t\tfi\n\tfi\n\n\tcase outdev\n\twhen std_io then\n\t\tprintf(\"%.*s\",n,s)\n\twhen file_io then\n\t\tfprintf(outchan,\"%.*s\",n,s)\n\tesac\nend\n\nproc dumpprintbuffer=\n\tif printlen then\n\t\tdumpstr(&.printbuffer,printlen,1)\n\tfi\n\n\tresetprintbuffer()\nend\n\nproc resetprintbuffer=\n\tprintptr:=&.printbuffer\n\tprintlen:=0\nend\n\nproc addtobuffer(ichar s, int n)=\n\tif printlen+n>=(printbuffer.len-8) then\n\t\tdumpprintbuffer()\n\tfi\n\n\tif n<printbuffer.len then\n\t\tmemcpy(printptr,s,n)\n\t\tprintptr+:=n\n\t\tprintlen+:=n\n\t\treturn\n\tfi\n\n\tdumpstr(s, n)\t\t\t!don't bother with buffer\nend\n\nfunc getutfsize(ref char s)int =\n!work out the size in bytes of the ascii or utf8 character that s points to\n\tint a\n\n\ta:=s++^\n\n\tif a=0 then\t\t\t\t\t\t!end of string\n\t\t0\n\telsif a.[7]=0 then\t\t\t\t!ascii\n\t\t1\n\telsif a.[7..5]=2x110 then\n\t\t2\n\telsif a.[7..4]=2x1110 then\n\t\t3\n\telsif a.[7..3]=2x11110 then\n\t\t4\n\telse\t\t\t\t\t\t\t!error: just assume a byte of random binary\n\t\t1\n\tfi\nend\n\n!export fun fraction(real x)real = fmod(x,1.0)\n\nexport fun m$sign_i64(int a)int = (a<0|-1| (a>0|1|0))\n\nexport func m$sign_r64(real x)real =\n\tif x<0 then return -1 fi\n\tif x>0 then return 1 fi\n\t0\nend\n",
(u64)"!import clib\n!export type filehandle=ref void\n\n!importdll $cstd=\nimportdll msvcrt=\n\tfunc malloc\t(u64)ref void\n\tproc free\t\t(ref void)\n!\tfunc pow\t\t(real,real)real\n!\n\tfunc printf (ref char,...)i32\n!\tfunc fprintf (ref void,ref char,...)i32\n\tfunc puts (ref char)i32\n\tproc `exit(i32)\n\tfunc getchar\t:i32\n\tproc memcpy\t\t(ref void, ref void, word)\n\tproc memset\t\t(ref void, i32, u64)\n\tfunc strlen\t\t(ichar)u64\n\tfunc strcpy\t\t(ichar,ichar)ichar\n\tfunc strcat\t\t(ichar,ichar)ichar\n\tfunc strcmp\t\t(ichar,ichar)i32\n\tfunc `sqrt\t\t(real)real\n\n\tfunc _strdup\t(ichar)ichar\nend\n\nexport macro strdup=_strdup\n\n!export proc free(ref void) = end\n\n\nint needgap\n\n!proc start=\n!\tCPL \"MIN/START\"\n!end\n\n\nglobal proc m$print_startcon=\nend\n\nglobal proc m$print_end=\n\tneedgap:=0\nend\n\n!global proc m$print_ptr(u64 a,ichar fmtstyle=nil)=\n!!\tnextfmtchars()\n!\tprintf(\"%p\",a)\n!\tneedgap:=1\n!end\n\nglobal proc m$print_ptr_nf(u64 a)=\n\tnextfmtchars()\n\tprintf(\"%p\",a)\n\tneedgap:=1\nend\n!\n!global proc m$print_i64(i64 a,ichar fmtstyle=nil)=\n!\tnextfmtchars()\n!\tprintf(\"%lld\",a)\n!\tneedgap:=1\n!end\n\n!global proc m$print_i128(i64 a,ichar fmtstyle=nil)=\n!\tputs(\"<128>\")\n!!\tnextfmtchars()\n!!\tprintf(\"%lld\",a)\n!!\tneedgap:=1\n!end\n\nglobal proc m$print_i64_nf(i64 a)=\n!puts(\"PRINTI64_nf\")\n\tnextfmtchars()\n\tprintf(\"%lld\",a)\n\tneedgap:=1\nend\n\nglobal proc m$print_u64(u64 a,ichar fmtstyle=nil)=\n\tnextfmtchars()\n\tprintf(\"%llu\",a)\n\tneedgap:=1\nend\n\nglobal proc m$print_r64(real x,ichar fmtstyle=nil)=\n\tnextfmtchars()\n\tprintf(\"%f\",x)\n\tneedgap:=1\nend\n\nglobal proc m$print_r32(real x,ichar fmtstyle=nil)=\n\tnextfmtchars()\n\tprintf(\"%f\",x)\n\tneedgap:=1\nend\n\n!global proc m$print_c8(i64 a,ichar fmtstyle=nil)=\n!\tnextfmtchars()\n!\tprintf(\"%c\",a)\n!\tneedgap:=1\n!end\n!\n!global proc m$print_str(ichar s, fmtstyle=nil)=\n!\tnextfmtchars()\n!\tprintf(\"%s\",s)\n!\tneedgap:=1\n!end\n\nglobal proc m$print_str_nf(ichar s)=\n\tnextfmtchars()\n\tprintf(\"%s\",s)\n\tneedgap:=1\nend\n\nglobal proc m$print_space=\n\tneedgap:=0\n\tprintf(\" \")\nend\n\nglobal proc m$print_newline=\n\tneedgap:=0\n\tprintf(\"\\n\")\nend\n\nglobal proc m$unimpl=\n\tputs(\"Sysfn unimpl\")\n\tstop 1\nend\n\nglobal proc m$print_nogap=\n\tneedgap:=0\nend\n\n!global proc nextfmtchars(int lastx=0)=\nglobal proc nextfmtchars=\n\tif needgap then\n\t\tprintf(\" \")\n\t\tneedgap:=0\n\tfi\nend\n\n!global proc m$stop(int stopcode)=\n!\t`exit(stopcode)\n!end\n!\n!global func strint(i64 a, ichar fmtstyle=nil)ichar=\n!\treturn \"?\"\n!end\n!\n\n!global function m$power_i64(i64 a,n)i64=\n!\tif n<0 then\n!\t\treturn 0\n!\telsif n=0 then\n!\t\treturn 1\n!\telsif n=1 then\n!\t\treturn a\n!\telsif (n iand 1)=0 then\n!\t\treturn m$power_i64(sqr a,n/2)\n!\telse\t\t\t!assume odd\n!\t\treturn m$power_i64(sqr a,(n-1)/2)*a\n!\tfi\n!end\n!\n!\n",
(u64)"!const mem_check=1\nconst mem_check=0\n\nglobal [0..300]u64 allocupper\nglobal int alloccode\t\t\t\t!set by heapalloc\nexport int allocbytes\t\t\t\t!set by heapalloc\nexport int fdebug=0\nexport int rfsize\n\nconst threshold=1<<25\nconst alloc_step=1<<25\nword maxmemory\nint  maxalloccode\n\n!GLOBAL REF VOID ALLOCBASE\n\nbyte pcm_setup=0\n\nint show=0\n\nglobal int memtotal=0\nexport i64 smallmemtotal=0\nglobal int smallmemobjs=0\nglobal int maxmemtotal=0\n\n!store all allocated pointers\nconst int maxmemalloc=(mem_check|500000|2)\n[maxmemalloc+1]ref i32 memalloctable\n[maxmemalloc+1]i32 memallocsize\n\nconst pcheapsize=1048576*2\nref byte pcheapstart\nref byte pcheapend\t\t\t!points to first address past heap\nref byte pcheapptr\n\nconst int maxblockindex = 8 \t\t!2048\nexport const int maxblocksize = 2048\nexport const int $maxblocksizexx = 2048\n\n[0:maxblocksize+1]byte sizeindextable\t!convert byte size to block index 1..maxblockindex\n\nconst int size16   = 1\t\t\t!the various index codes\nconst int size32   = 2\nconst int size64   = 3\nconst int size128  = 4\nconst int size256  = 5\nconst int size512  = 6\nconst int size1024 = 7\nconst int size2048 = 8\n\nexport [0:9]ref word freelist\n\nexport record strbuffer =\n\tichar strptr\n\ti32 length\n\ti32 allocated\nend\n\nexport enumdata [0:]ichar pmnames=\n\t(pm_end=0,\t\t$),\n\t(pm_option,\t\t$),\n\t(pm_sourcefile,\t$),\n\t(pm_libfile,\t$),\n\t(pm_colon,\t\t$),\n\t(pm_extra,\t\t$),\nend\n\n[2]int seed = (0x2989'8811'1111'1272',0x1673'2673'7335'8264)\n\n!PROC START=\n!CPL \"MLIB START\"\n!END\n\n\nexport function pcm_alloc(int n)ref void =\n\tref byte p\n\n\n\tif not pcm_setup then\n\t\tpcm_init()\n\tfi\n\n!GOTO DOLARGE\n\n\tif n>maxblocksize then\t\t\t!large block allocation\n!DOLARGE:\n\t\talloccode:=pcm_getac(n)\n\t\tallocbytes:=allocupper[alloccode]\n\n\t\tp:=allocmem(allocbytes)\n\t\tif not p then\n\t\t\tabortprogram(\"pcm_alloc failure\")\n\t\tfi\n\n\t\treturn p\n\tfi\n\n!CPL \"DOSMALL\"\n\n\talloccode:=sizeindextable[n]\t\t!Size code := 0,1,2 etc for 0, 16, 32 etc\n\tallocbytes:=allocupper[alloccode]\n!\tsmallmemtotal+:=allocbytes\n\n\tif p:=ref byte(freelist[alloccode]) then\t\t!Items of this block size available\n\t\tfreelist[alloccode]:=ref word(int((freelist[alloccode])^))\n\n\t\treturn p\n\tfi\n\n!No items in freelists: allocate new space in this heap block\n\tp:=pcheapptr\t\t\t\t!Create item at start of remaining pool in heap block\n\tpcheapptr+:=allocbytes\t\t\t!Shrink remaining pool\n\n\tif pcheapptr>=pcheapend then\t\t!Overflows?\n\t\tp:=pcm_newblock(allocbytes)\t\t!Create new heap block, and allocate from start of that\n\t\treturn p\n\tfi\n\n\treturn p\nend\n\nexport proc pcm_free(ref void p,int n) =\n!n can be the actual size requested it does not need to be the allocated size\n\tint acode\n\n\treturn when n=0 or p=nil\n\n\tif n>maxblocksize then\t\t!large block\n\t\tfree(p)\n\telse\n\t\tacode:=sizeindextable[n]\t\t!Size code := 0,1,2 etc for 0, 16, 32 etc\n\t\tcast(p,ref word)^:=word(int(freelist[acode]))\n\t\tfreelist[acode]:=p\n\tfi\nend\n\nexport proc pcm_freeac(ref void p,int alloc) =\n\tpcm_free(p,allocupper[alloc])\nend\n\nexport proc pcm_clearmem(ref void p,int n) =\n\tmemset(p,0,n)\nend\n\nexport proc pcm_init =\n!set up sizeindextable too\n\tint j, k\n\ti64 size\n\tconst limit=1<<33\n\n\talloccode:=0\n\tif pcm_setup then\n\t\treturn\n\tfi\n\n\tpcm_newblock(0)\n\n\tfor i to maxblocksize do\t!table converts eg. 78 to 4 (4th of 16,32,64,128)\n\t\tj:=1\n\t\tk:=16\n\t\twhile i>k do\n\t\t\tk:=k<<1\n\t\t\t++j\n\t\tod\n\t\tsizeindextable[i]:=j\n\tod\n\n\tallocupper[1]:=16\n\tsize:=16\n\n\tfor i:=2 to 27 do\n\t\tsize*:=2\n\t\tallocupper[i]:=size\n\t\tif size>=threshold then\n\t\t\t\tk:=i\n\t\t\texit\n\t\tfi\n\tod\n\n\tfor i:=k+1 to allocupper.upb do\n\t\tsize+:=alloc_step\n\t\tif size<limit then\n\t\t\tallocupper[i]:=size\n\t\t\tmaxmemory:=size\n\t\telse\n\t\t\tmaxalloccode:=i-1\n\t\t\texit\n\t\tfi\n\t\t\n\tod\n\tpcm_setup:=1\nend\n\nexport function pcm_getac(int size)int =\n! convert linear blocksize from 0..approx 2GB to 8-bit allocation code\n\n!sizeindextable scales values from 0 to 2048 to allocation code 0 to 9\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]\t\t!size 0 to 2KB\n\tfi\n\n\tsize:=(size+255)>>8\t\t\t\t\t!scale by 256\n\n!now same sizetable can be used for 2KB to 512KB (288 to 2KB)\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]+8\n\tfi\n\n!sizetable now used for 512KB to 128MB (to 2KB)\n\tsize:=(size+63)>>6\t\t\t\t\t!scale by 256\n\n\tif size<=maxblocksize then\n\t\treturn sizeindextable[size]+14\n\tfi\n\n!size>2048, which means it had been over 128MB.\n\tsize:=(size-2048+2047)/2048+22\n\treturn size\nend\n\nexport function pcm_newblock(int itemsize)ref void=\n!create new heap block (can be first)\n!also optionally allocate small item at start\n!return pointer to this item (and to the heap block)\n\tstatic int totalheapsize\n\tref byte p\n\n\ttotalheapsize+:=pcheapsize\n\talloccode:=0\n\tp:=allocmem(pcheapsize)\t!can't free this block until appl terminates\n\tif p=nil then\n\t\tabortprogram(\"Can't alloc pc heap\")\n\tfi\n\tmemset(p,0,pcheapsize)\n\n\tpcheapptr:=p\n\tpcheapend:=p+pcheapsize\n\n\tif pcheapstart=nil then\t\t!this is first block\n\t\tpcheapstart:=p\n\tfi\n\tpcheapptr+:=itemsize\n\treturn ref u32(p)\nend\n\nexport function pcm_round(int n)int =\n!for any size n, return actual number of bytes that would be allocated\n\tstatic [0:maxblockindex+1]i32 allocbytes=(0,16,32,64,128,256,512,1024,2048)\n\n\tif n>maxblocksize then\n\t\treturn n\n\telse\n\t\treturn allocbytes[sizeindextable[n]]\n\tfi\nend\n\nexport function pcm_allocz(int n)ref void =\n\tref void p\n\tp:=pcm_alloc(n)\n\n\tmemset(p,0,n)\n\treturn p\nend\n\nexport function pcm_copyheapstring(ref char s)ref char =\n!allocate enough bytes for string s: copy s to the heap\n!return pointer to new string\n\tref char q\n\tint n\n\tif s=nil then return nil fi\n\n\tn:=strlen(s)+1\n\tq:=pcm_alloc(n)\n\tmemcpy(q,s,n)\n\treturn q\nend\n\nexport function pcm_copyheapstringn(ref char s,int n)ref char =\n\tref char q\n\tif s=nil then return nil fi\n\n\tq:=pcm_alloc(n+1)\n\tmemcpy(q,s,n)\n\t(q+n)^:=0\n\treturn q\nend\n\nexport function pcm_copyheapblock(ref char s, int length)ref char =\n!allocate enough bytes for string s: copy s to the heap\n!return pointer to new string\n\tref char q\n\tif length=0 then return nil fi\n\n\tq:=pcm_alloc(length)\n\tmemcpy(q,s,length)\n\treturn q\nend\n\nexport function allocmem(int n)ref void =\n\tref void p\n\n\tp:=malloc(n)\n\tif p then\n\t\treturn p\n\tfi\n\tprintln n,memtotal\n\tabortprogram(\"Alloc mem failure\")\n\treturn nil\nend\n\nglobal function reallocmem(ref void p,int n)ref void =\n\tp:=realloc(p,n)\n\treturn p when p\n\tprintln n\n\tabortprogram(\"Realloc mem failure\")\n\treturn nil\nend\n\nexport proc abortprogram(ref char s) =\n\tprintln s\n\tprint   \"ABORTING: Press key...\"\n!os_getch()\n\tstop 5\nend\n\nexport function getfilesize(filehandle handlex)int=\n\tu32 p,size\n\n\tp:=ftell(handlex)\t\t!current position\n\tfseek(handlex,0,2)\t\t!get to eof\n\tsize:=ftell(handlex)\t\t!size in bytes\n\tfseek(handlex,p,seek_set)\t!restore position\n\treturn size\nend\n\nexport proc readrandom(filehandle handlex, ref byte memx, int offset, size) =\n\tint a\n\tfseek(handlex,offset,seek_set)\n\ta:=fread(memx,1,size,handlex)\t\t\t!assign so as to remove gcc warning\nend\n\nexport function writerandom(filehandle handlex, ref byte memx, int offset,size)int =\n\tfseek(handlex,offset,seek_set)\n\treturn fwrite(memx,1,size,handlex)\nend\n\nexport function setfilepos(filehandle file,int offset)int=\n\treturn fseek(file,offset,0)\nend\n\nexport function getfilepos(filehandle file)int=\n\treturn ftell(file)\nend\n\nexport function readfile(ref char filename)ref byte =\n\tfilehandle f\n\tint size\n\tref byte m,p\n\n\tf:=fopen(filename,\"rb\")\n\tif f=nil then\n\t\treturn nil\n\tfi\n\trfsize:=size:=getfilesize(f)\n\n\tm:=malloc(size+2)\t\t!allow space for etx/zeof etc\n\n\tif m=nil then\n\t\treturn nil\n\tfi\n\n\treadrandom(f,m,0,size)\n\tp:=m+size\t\t\t!point to following byte\n\t(ref u16(p)^:=0)\t!add two zero bytes\n\n\tfclose(f)\n\treturn m\nend\n\nexport function writefile(ref char filename,ref byte data,int size)int =\n\tfilehandle f\n\tint n\n\n\tf:=fopen(filename,\"wb\")\n\tif f=nil then\n\t\treturn 0\n\tfi\n\n\tn:=writerandom(f,data,0,size)\n\tfclose(f)\n\treturn n\nend\n\nexport function checkfile(ref char file)int=\n\tfilehandle f\n\tif f:=fopen(file,\"rb\") then\n\t\tfclose(f)\n\t\treturn 1\n\tfi\n\treturn 0\nend\n\nexport proc readlinen(filehandle handlex,ref char buffer,int size) =\n!size>2\n\tint ch\n\tref char p\n\tint n\n\tbyte crseen\n\n\tif handlex=nil then\n\t\thandlex:=filehandle(os_getstdin())\n\tfi\n\tif handlex=nil then\n\t\tn:=0\n\t\tp:=buffer\n\t\tdo\n\t\t\tch:=getchar()\n\t\t\tif ch=13 or ch=10 or ch=-1 then\n\t\t\t\tp^:=0\n\t\t\t\treturn\n\t\t\tfi\n\t\t\tp++^:=ch\n\t\t\t++n\n\t\t\tif n>=(size-2) then\n\t\t\t\tp^:=0\n\t\t\t\treturn\n\t\t\tfi\n\t\tod\n\tfi\n\n\tbuffer^:=0\n\tif fgets(buffer,size-2,handlex)=nil then\n\t\treturn\n\tfi\n\n\tn:=strlen(buffer)\n\tif n=0 then\n\t\treturn\n\tfi\n\n\tp:=buffer+n-1\t\t!point to last char\n\tcrseen:=0\n\twhile (p>=buffer and (p^=13 or p^=10)) do\n\t\tif p^=13 or p^=10 then crseen:=1 fi\n\t\tp--^ :=0\n\tod\n\n!NOTE: this check doesn't work when a line simply doesn't end with cr-lf\n\n\tif not crseen and (n+4>size) then\n\t\tcpl size,n\n\t\tabortprogram(\"line too long\")\n\tfi\nend\n\nexport proc iconvlcn(ref char s,int n) =\n\tto n do\n\t\ts^:=tolower(s^)\n\t\t++s\n\tod\nend\n\nexport proc iconvucn(ref char s,int n) =\n\tto n do\n\t\ts^:=toupper(s^)\n\t\t++s\n\tod\nend\n\nexport function convlcstring(ref char s)ichar s0=\n\ts0:=s\n\twhile (s^) do\n\t\ts^:=tolower(s^)\n\t\t++s\n\tod\n\ts0\nend\n\nexport function convucstring(ref char s)ichar s0=\n\ts0:=s\n\twhile (s^) do\n\t\ts^:=toupper(s^)\n\t\t++s\n\tod\n\ts0\nend\n\nexport function changeext(ref char s,newext)ichar=\n!whether filespec has an extension or not, change it to newext\n!newext should start with \".\"\n!return new string (locally stored static string, so must be used before calling again)\n\tstatic [260]char newfile\n\t[32]char newext2\n\tref char sext\n\tint n\n\n\tstrcpy(&newfile[1],s)\n\n\tcase newext^\n\twhen 0 then\n\t\tnewext2[1]:=0\n\t\tnewext2[2]:=0\n\twhen '.' then\n\t\tstrcpy(&newext2[1],newext)\n\telse\n\t\tstrcpy(&newext2[1],\".\")\n\t\tstrcat(&newext2[1],newext)\n\tesac\n\n\n\tsext:=extractext(s,1)\t\t\t!include \".\" when it is only extension\n\n\tcase sext^\n\twhen 0 then\t\t\t\t\t\t!no extension not even \".\"\n\t\tstrcat(&newfile[1],&newext2[1])\n\twhen '.' then\t\t\t\t\t\t!no extension not even \".\"\n\t\tstrcat(&newfile[1],&newext2[2])\n\telse\t\t\t\t\t\t\t!has extension\n\t\tn:=sext-s-2\t\t\t!n is number of chars before the \".\"\n\t\tstrcpy(&newfile[1]+n+1,&newext2[1])\n\tesac\n\n\treturn &newfile[1]\nend\n\nexport function extractext(ref char s,int period=0)ichar=\n!if filespec s has an extension, then return pointer to it otherwise return \"\"\n!if s ends with \".\", then returns \".\"\n\tref char t,u\n\n\tt:=extractfile(s)\n\n\tif t^=0 then\t\t\t!s contains no filename\n\t\treturn \"\"\n\tfi\n\n!t contains filename+ext\n\tu:=t+strlen(t)-1\t\t!u points to last char of t\n\n\twhile u>=t do\n\t\tif u^='.' then\t\t!start extension found\n\t\t\tif (u+1)^=0 then\t\t!null extension\n\t\t\t\treturn (period|\".\"|\"\")\n\t\t\tfi\n\t\t\treturn u+1\t\t\t!return last part of filename as extension exclude the dot\n\t\tfi\n\t\t--u\n\tod\n\treturn \"\"\t\t\t!no extension seen\nend\n\nexport function extractpath(ref char s)ichar=\n\tstatic [0:260]char str\n\tref char t\n\tint n\n\n\tt:=s+strlen(s)-1\t\t!t points to last char\n\n\twhile (t>=s) do\n\t\tcase t^\n\t\twhen '\\\\','/',':' then\t\t!path separator or drive letter terminator assume no extension\n\t\t\tn:=t-s+1\t\t\t!n is number of chars in path, which includes rightmost / or \\ or :\n\t\t\tmemcpy(&.str,s,n)\n\t\t\tstr[n]:=0\n\t\t\treturn &.str\n\t\tesac\n\t\t--t\n\tod\n\treturn \"\"\t\t\t!no path found\nend\n\nexport function extractfile(ref char s)ichar=\n\tref char t\n\n\tt:=extractpath(s)\n\n\tif t^=0 then\t\t\t!s contains no path\n\t\treturn s\n\tfi\n\n\treturn s+strlen(t)\t\t!point to last part of s that contains the file\n\tend\n\nexport function extractbasefile(ref char s)ichar=\n\tstatic [0:100]char str\n\tref char f,e\n\tint n,flen\n\n\tf:=extractfile(s)\n\tflen:=strlen(f)\n\tif flen=0 then\t\t!s contains no path\n\t\treturn \"\"\n\tfi\n\te:=extractext(f,0)\n\n\tif e^ then\t\t\t!not null extension\n\t\tn:=flen-strlen(e)-1\n\t\tmemcpy(&str,f,n)\n\t\tstr[n]:=0\n\t\treturn &.str\n\tfi\n\tif (f+flen-1)^='.' then\n\t\tmemcpy(&str,f,flen-1)\n\t\tstr[flen-1]:=0\n\t\treturn &.str\n\tfi\n\treturn f\nend\n\nexport function addext(ref char s,ref char newext)ichar=\n!when filespec has no extension of its own, add newext\n\tref char sext\n\n\tsext:=extractext(s,1)\n\n\tif sext^=0 then\t\t\t\t\t\t!no extension not even \".\"\n\t\treturn changeext(s,newext)\n\tfi\n\n\treturn s\t\t\t\t\t\t\t!has own extension; use that\nend\n\nexport function pcm_alloc32:ref void =\n\tref byte p\n\n\tallocbytes:=32\n!\tsmallmemtotal+:=32\n\n\tif p:=ref byte(freelist[2]) then\t\t!Items of this block size available\n\t\tfreelist[2]:=ref word(int((freelist[2])^))\n\t\treturn p\n\tfi\n\n!No items in freelists: allocate new space in this heap block\n\treturn pcm_alloc(32)\nend\n\nexport proc pcm_free32(ref void p) =\n!n can be the actual size requested it does not need to be the allocated size\n\n!\tsmallmemtotal-:=32\n\n\tcast(p,ref word)^:=word(int(freelist[2]))\n\tfreelist[2]:=p\nend\n\nexport proc outbyte(filehandle f,int x)=\n\tfwrite(&x,1,1,f)\nend\n\nexport proc outu16(filehandle f,word x)=\n\tfwrite(&x,2,1,f)\nend\n\nexport proc outu32(filehandle f,word x)=\n\tfwrite(&x,4,1,f)\nend\n\nexport proc outu64(filehandle f,u64 x)=\n\tfwrite(&x,8,1,f)\nend\n\nexport proc outstring(filehandle f, ichar s)=\n\tfwrite(s,strlen(s)+1,1,f)\nend\n\nexport proc outblock(filehandle f, ref void p, int n)=\n\tfwrite(p,n,1,f)\nend\n\nexport function myeof(filehandle f)int=\n\tint c\n\n\tc:=fgetc(f)\n\tif c=c_eof then return 1 fi\n\tungetc(c,f)\n\treturn 0\nend\n\nexport proc strbuffer_add(ref strbuffer dest, ichar s, int n=-1)=\n\tint newlen,oldlen\n\tichar newptr\n\n!\tIF N=0 THEN CPL \"N=0\" FI\n\n\tif n=-1 then\n\t\tn:=strlen(s)\n\tfi\n\n\toldlen:=dest.length\n\n\tif oldlen=0 then\t\t\t\t!first string\n\t\tdest.strptr:=pcm_alloc(n+1)\n\t\tdest.allocated:=allocbytes\n\t\tdest.length:=n\t\t\t\t!length always excludes terminator\n\t\tmemcpy(dest.strptr,s,n)\n\t\t(dest.strptr+n)^:=0\n\t\treturn\n\tfi\n\n\tnewlen:=oldlen+n\n\tif newlen+1>dest.allocated then\n\t\tnewptr:=pcm_alloc(newlen+1)\n\t\tmemcpy(newptr,dest.strptr,oldlen)\n\t\tdest.strptr:=newptr\n\t\tdest.allocated:=allocbytes\n\tfi\n\n\tmemcpy(dest.strptr+oldlen,s,n)\n\t(dest.strptr+newlen)^:=0\n\n\tdest.length:=newlen\nend\n\nexport proc gs_init(ref strbuffer dest)=\n\tpcm_clearmem(dest,strbuffer.bytes)\nend\n\nexport proc gs_free(ref strbuffer dest)=\n\tif dest.allocated then\n\t\tpcm_free(dest.strptr,dest.allocated)\n\tfi\nend\n\nexport proc gs_str(ref strbuffer dest,ichar s)=\n\tstrbuffer_add(dest,s)\nend\n\nexport proc gs_char(ref strbuffer dest,int c)=\n\t[16]char s\n\n\ts[1]:=c\n\ts[2]:=0\n\n\tstrbuffer_add(dest,&.s,1)\nend\n\nexport proc gs_strn(ref strbuffer dest,ichar s,int length)=\n\tstrbuffer_add(dest,s,length)\nend\n\nexport proc gs_strvar(ref strbuffer dest,s)=\n\tstrbuffer_add(dest,s.strptr)\nend\n\nexport proc gs_strint(ref strbuffer dest,i64 a)=\n\tstrbuffer_add(dest,strint(a))\nend\n\nexport proc gs_strln(ref strbuffer dest,ichar s)=\n\tgs_str(dest,s)\n\tgs_line(dest)\nend\n\nexport proc gs_strsp(ref strbuffer dest,ichar s)=\n\tgs_str(dest,s)\n\tgs_str(dest,\" \")\nend\n\nexport proc gs_line(ref strbuffer dest)=\n!\tstrbuffer_add(dest,\"\\w\")\n\tstrbuffer_add(dest,\"\\n\")\nend\n\nexport function gs_getcol(ref strbuffer dest)int=\n\treturn dest.length\nend\n\nexport proc gs_leftstr(ref strbuffer dest, ichar s, int w, padch=' ')=\n\tint col,i,n,slen\n\t[2560]char str\n\tcol:=dest.length\n\tstrcpy(&.str,s)\n\tslen:=strlen(s)\n\tn:=w-slen\n\tif n>0 then\n\t\tfor i:=1 to n do\n\t\t\tstr[slen+i]:=padch\n\t\tod\n\t\tstr[slen+n+1]:=0\n\tfi\n\tgs_str(dest,&.str)\nend\n\nexport proc gs_leftint(ref strbuffer dest, int a, int w, padch=' ')=\n\tgs_leftstr(dest,strint(a),w,padch)\nend\n\nexport proc gs_padto(ref strbuffer dest,int col, ch=' ')=\n\tint n\n\t[2560]char str\n\n\tn:=col-dest.length\n\tif n<=0 then return fi\n\tfor i:=1 to n do\n\t\tstr[i]:=ch\n\tod\n\tstr[n+1]:=0\n\tgs_str(dest,&.str)\nend\n\nexport proc gs_println(ref strbuffer dest,filehandle f=nil)=\n\tif dest.length=0 then return fi\n\t(dest.strptr+dest.length)^:=0\n\n\tif f=nil then\n\t\tprintln dest.strptr,,\"\\c\"\n\telse\n\t\tprintln @f,dest.strptr,,\"\\c\"\n\tfi\nend\n\nexport function nextcmdparamnew(int &paramno, ichar &name, &value, ichar defext=nil)int=\n\tstatic int infile=0\n\tstatic ichar filestart=nil\n\tstatic ichar fileptr=nil\n\tstatic byte colonseen=0\n\tref char q\n\tichar item,fileext\n\tint length\n\tstatic [300]char str\n\n\treenter:\n\tvalue:=nil\n\tname:=nil\n\n\tif infile then\n\t\tif readnextfileitem(fileptr,item)=0 then\t\t!eof\n\t\t\tfree(filestart)\t\t\t\t\t\t\t\t!file allocated via malloc\n\t\t\tinfile:=0\n\t\t\tgoto reenter\n\t\tfi\n\telse\n\t\tif paramno>ncmdparams then\n\t\t\treturn pm_end\n\t\tfi\n\t\titem:=cmdparams[paramno]\n\t\t++paramno\n\n\t\tlength:=strlen(item)\n\n\t\tif item^='@' then\t\t!@ file\n\t\t\tfilestart:=fileptr:=readfile(item+1)\n\t\t\tif filestart=nil then\n\t\t\t\tprintln \"Can't open\",item\n\t\t\t\tstop 7\n\t\t\tfi\n\t\t\tinfile:=1\n\t\t\tgoto reenter\n\t\tfi\n\n\t\tif item^=':' then\n\t\t\tcolonseen:=1\n\t\t\treturn pm_colon\n\t\tfi\n\tfi\n\n\tvalue:=nil\n\tif item^='-' then\n\t\tname:=item+(colonseen|0|1)\n\t\tq:=strchr(item,':')\n\t\tif not q then\n\t\t\tq:=strchr(item,'=')\n\t\tfi\n\t\tif q then\n\t\t\tvalue:=q+1\n\t\t\tq^:=0\n\t\tfi\n\t\treturn (colonseen|pm_extra|pm_option)\n\tfi\n\n\tfileext:=extractext(item,0)\n\tname:=item\n\n\tif fileext^=0 then\t\t\t\t\t\t\t!no extension\n\t\tstrcpy(&.str,name)\n\t\tif defext and not colonseen then\n\t\t\tname:=addext(&.str,defext)\t\t\t\t!try .c\n\t\tfi\n!\telsif eqstring(fileext,\"dll\") then\n\telsif eqstring(fileext,\"dll\") or eqstring(fileext,\"mcx\") then\n\t\treturn (colonseen|pm_extra|pm_libfile)\n\tfi\n\treturn (colonseen|pm_extra|pm_sourcefile)\nend\n\nfunction readnextfileitem(ichar &fileptr,&item)int=\n\tref char p,pstart,pend\n\tint n\n\tstatic [256]char str\n\n\tp:=fileptr\n\n\treenter:\n\tdo\n\t\tcase p^\n\t\twhen ' ','\\t',13,10 then\t!skip white space\n\t\t\t++p\n\t\twhen 26,0 then\t\t\t\t!eof\n\t\t\treturn 0\n\t\telse\n\t\t\texit\n\t\tesac\n\tod\n\n\tcase p^\n\twhen '!', '#' then\t\t\t!comment\n\t\t++p\n\t\tdocase p++^\n\t\twhen 10 then\n\t\t\tgoto reenter\n\t\twhen 26,0 then\n\t\t\tfileptr:=p-1\n\t\t\treturn 0\n\t\telse\n\n\t\tend docase\n\tesac\n\n\n\tcase p^\n\twhen '\"' then\t\t\t\t!read until closing \"\n\t\tpstart:=++p\n\t\tdo\n\t\t\tcase p^\n\t\t\twhen 0,26 then\n\t\t\t\tprintln \"Unexpected EOF in @file\"\n\t\t\t\tstop 8\n\t\t\twhen '\"' then\n\t\t\t\tpend:=p++\n\t\t\t\tif p^=',' then ++p fi\n\t\t\t\texit\n\t\t\tesac\n\t\t\t++p\n\t\tod\n\telse\n\t\tpstart:=p\n\t\tdo\n\t\t\tcase p^\n\t\t\twhen 0,26 then\n\t\t\t\tpend:=p\n\t\t\t\texit\n\t\t\twhen ' ','\\t',',',13,10 then\n\t\t\t\tpend:=p++\n\t\t\t\texit\n\t\t\tesac\n\t\t\t++p\n\t\tod\n\tesac\n\n\tn:=pend-pstart\n\tif n>=str.len then\n\t\tprintln \"@file item too long\"\n\t\tstop 9\n\tfi\n\tmemcpy(&.str,pstart,n)\n\tstr[n+1]:=0\n\titem:=&.str\n\tfileptr:=p\n\n\treturn 1\nend\n\nexport proc ipadstr(ref char s,int width,ref char padchar=\" \")=\n\tint n\n\n\tn:=strlen(s)\n\tto width-n do\n\t\tstrcat(s,padchar)\n\tod\nend\n\nexport function padstr(ref char s,int width,ref char padchar=\" \")ichar=\n\tstatic [256]char str\n\n\tstrcpy(&.str,s)\n\tipadstr(&.str,width,padchar)\n\treturn &.str\nend\n\nexport function chr(int c)ichar=\n\tstatic [8]char str\n\n\tstr[1]:=c\n\tstr[2]:=0\n\treturn &.str\nend\n\nexport function cmpstring(ichar s,t)int=\n\tint res\n\tif (res:=strcmp(s,t))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function cmpstringn(ichar s,t,int n)int=\n\tint res\n\tif (res:=strncmp(s,t,n))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function eqstring(ichar s,t)int=\n\treturn strcmp(s,t)=0\nend\n\nexport function cmpbytes(ref void p,q,int n)int=\n\tint res\n\tif (res:=memcmp(p,q,n))<0 then\n\t\treturn -1\n\telsif res>0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport function eqbytes(ref void p,q,int n)int=\n\treturn memcmp(p,q,n)=0\nend\n\nexport proc mseed(u64 a,b=0)=\n\tseed[1]:=a\n\tif b then\n\t\tseed[2]:=b\n\telse\n\t\tseed[2] ixor:=a\n\tfi\nend\n\nexport function mrandom:word =\n!return pure 64-bit word value, 0 to 2**64-1\n!(cast result for signed value)\n!\tu64 x,y\n\tint x,y\n\tx:=seed[1]\n\ty:=seed[2]\n\tseed[1]:=y\n\tx ixor:=(x<<23)\n\tseed[2]:= x ixor y ixor (x>>17) ixor (y>>26)\n\treturn seed[2]+y\nend\n\nexport function mrandomp:int =\n!pure 64-bit int value, positive only, 0 to 2**63-1\n\treturn mrandom() iand 0x7FFF'FFFF'FFFF'FFFF\nend\n\nexport function mrandomint(int n)int=\n!positive random int value from 0 to n-1\n\treturn mrandomp() rem n\nend\n\nexport function mrandomrange(int a,b)int=\n!random int value from a to b inclusive\n!span extent must be 1 to 2**63-1\n\tint span\n\tspan:=b-a+1\n\tif span<=0 then\n\t\treturn 0\n\tfi\n\treturn (mrandomp() rem span)+a\nend\n\nexport function mrandomreal:real x=\n!positive random real value from 0 to just under (but not including) 1.0\n\trepeat x:=mrandomp()/9223372036854775808.0 until x<>1.0\n\treturn x\nend\n\nexport function mrandomreal1:real=\n!positive random real value from 0 to 1.0 inclusive\n\treturn mrandomp()/9223372036854775807.0\nend\n\nexport function readline:ichar=\n\treadln\n\treturn rd_buffer\nend\n\nexport function findfunction(ichar name)ref void=\n\tfor i to $getnprocs() do\n\t\tif eqstring($getprocname(i),name) then\n\t\t\treturn $getprocaddr(i)\n\t\tfi\n\tod\n\treturn nil\nend\n\nexport function roundtoblock(int n,align)int=\n!round up n until it is a multiple of filealign (which is a power of two)\n!return aligned value. Returns original if already aligned\n\tif n iand (align-1)=0 then return n fi\n\treturn n+(align-(n iand (align-1)))\nend\n\nexport function pcm_allocnfz(int n)ref void =\n!non-freeing allocator for small objects\n!n should be a multiple of 8 bytes, but is rounded up here if needed\n\tref byte p\n\n!make n a multiple of 8\n\tif n iand 7 then\n\t\tn:=n+(8-(n iand 7))\n\tfi\n\n\tp:=pcheapptr\t\t\t\t\t!Create item at start of remaining pool in heap block\n\tpcheapptr+:=n\t\t\t\t\t!Shrink remaining pool\n\n\tif pcheapptr>=pcheapend then\t!Overflows?\n\t\tp:=pcm_newblock(n)\t\t\t!Create new heap block, and allocate from start of that\n\tfi\n\n\treturn p\nend\n\n!export proc freddy=\n!\tPRINTLN \"FREDDY\"\n!end\n",
(u64)"export type filehandle=ref void\n\nimportdll $cstd=\n\tfunc malloc\t\t(u64)ref void\n\tfunc realloc\t(ref void, word)ref void\n\tproc free\t\t(ref void)\n\tproc memset\t\t(ref void, i32, word)\n\tproc memcpy\t\t(ref void, ref void, word)\n\tproc memmove\t\t(ref void, ref void, word)\n\tfunc clock\t\t:i32\n\tfunc ftell\t\t(filehandle)i32\n\tfunc fseek\t\t(filehandle, i32, i32)i32\n\tfunc fread\t\t(ref void, word, word, filehandle)word\n\tfunc fwrite\t\t(ref void, word, word, filehandle)word\n\tfunc getc\t\t(filehandle)i32\n\tfunc ungetc\t\t(i32, filehandle)i32\n\tfunc fopen\t\t(ichar a, b=\"rb\")filehandle\n\tfunc fclose\t\t(filehandle)i32\n\tfunc fgets\t\t(ichar, int, filehandle)ichar\n\tfunc remove\t\t(ichar)i32\n\tfunc rename\t\t(ichar, ichar)i32\n\tfunc getchar\t:i32\n\tproc putchar\t(i32)\n\tproc setbuf\t\t(filehandle, ref byte)\n\n\tfunc strlen\t\t(ichar)int\n\tfunc strcpy\t\t(ichar, ichar)ichar\n\tfunc strcmp\t\t(ichar, ichar)i32\n\tfunc strncmp\t(ichar, ichar, word)i32\n\tfunc strncpy\t(ichar, ichar, word)word\n\tfunc memcmp\t\t(ref void, ref void, word)i32\n\tfunc strcat\t\t(ichar, ichar)ichar\n\tfunc tolower\t(i32)i32\n\tfunc toupper\t(i32)i32\n\tfunc isalpha\t(i32)i32\n\tfunc isupper\t(i32)i32\n\tfunc islower\t(i32)i32\n\tfunc isalnum\t(i32)i32\n\tfunc isspace\t(i32)i32\n\tfunc strstr\t\t(ichar, ichar)ichar\n\tfunc atol\t\t(ichar)int\n\tfunc atoi\t\t(ichar)i32\n\tfunc strtod\t\t(ichar,ref ref char)r64\n\tfunc _strdup\t(ichar)ichar\n\n\tfunc puts\t\t(ichar)i32\n\tfunc printf\t\t(ichar, ...)i32\n\n\tfunc sprintf\t(ichar, ichar, ...)i32\n\n\tfunc sscanf\t\t(ichar, ichar, ...)i32\n\tfunc scanf\t\t(ichar, ...)i32\n\n\tfunc rand\t\t:i32\n\tproc srand\t\t(u32)\n\tfunc system\t\t(ichar)i32\n\n\tfunc fgetc\t\t(filehandle)i32\n\tfunc fputc\t\t(i32,  filehandle)i32\n\tfunc fprintf\t(filehandle, ichar, ...)i32\n\tfunc fputs\t\t(ichar,  filehandle)i32\n\tfunc feof\t\t(filehandle)i32\n\tfunc getch\t\t:i32\n\tfunc _getch\t\t:i32\n\tfunc kbhit\t\t:i32\n\tfunc _mkdir\t\t(ichar)i32\n\tfunc mkdir\t\t(ichar)i32\n\tfunc strchr\t\t(ichar,i32)ichar\n\n\tfunc _setmode\t(i32,i32)i32\n\n\tproc _exit\t\t(i32)\n\tproc \"exit\"\t\t(i32)\n!\tproc `exit\t\t(i32)\n\tfunc pow\t\t(real,real)real\n\n\tfunc `sqrt \t\t(real)real\n\tfunc `sin \t\t(real)real\n\tfunc `cos\t\t(real)real\n\tfunc `tan\t\t(real)real\n\tfunc `asin\t\t(real)real\n\tfunc `acos\t\t(real)real\n\tfunc `atan \t\t(real)real\n\tfunc `log\t\t(real)real\n\tfunc `log10\t\t(real)real\n\tfunc `exp\t\t(real)real\n\tfunc `floor\t\t(real)real\n\tfunc `ceil\t\t(real)real\n\n\tproc  qsort   \t(ref void, u64, u64, ref proc)\n\nend\n\nexport macro strdup=_strdup\n\nimportdll $cstdextra=\n\tfunc __getmainargs\t(ref i32, ref void, ref void, int, ref void)i32\nend\n\nexport const c_eof\t\t=-1\nexport const seek_set\t= 0\nexport const seek_curr\t= 1\nexport const seek_end\t= 2\n",
(u64)"const wm_destroy=2\n\nexport type wt_word\t= u16\nexport type wt_wordpm\t= u32\nexport type wt_bool\t= u32\nexport type wt_dword\t= u32\nexport type wt_wchar\t= u16\nexport type wt_wcharpm\t= u32\nexport type wt_char\t= byte\nexport type wt_ichar\t= ref char\nexport type wt_ptr\t\t= ref void\nexport type wt_wndproc\t= ref proc\nexport type wt_handle\t= ref void\nexport type wt_int\t\t= i32\nexport type wt_uint\t= u32\nexport type wt_long\t= i32\nexport type wt_wparam\t= word\nexport type wt_lparam\t= word\nexport type wt_point\t= rpoint\n\nexport record rsystemtime =\n\twt_word year\n\twt_word month\n\twt_word dayofweek\n\twt_word day\n\twt_word hour\n\twt_word minute\n\twt_word second\n\twt_word milliseconds\nend\n\nimportdll $windowsdlls=\n!\tfunc \"VirtualAlloc\"(wt_ptr, dint,wt_dword,wt_dword)wt_ptr\n\tfunc \"GetStdHandle\"(wt_dword)wt_handle\n\tfunc \"GetConsoleScreenBufferInfo\"(wt_handle,wt_ptr)int\n\tfunc \"SetConsoleCtrlHandler\"(wt_wndproc,int)int\n\tfunc \"SetConsoleMode\"(wt_handle,wt_dword)int\n\tfunc \"CreateProcessA\"(wt_ichar,wt_ichar,wt_ptr,wt_ptr, int,\n\t\t\t\t\t\twt_dword, wt_ptr,wt_ichar,wt_ptr,wt_ptr)int\n\tfunc \"GetLastError\":wt_dword\n\tfunc \"WaitForSingleObject\"(wt_handle,wt_dword)wt_dword\n\tfunc \"GetExitCodeProcess\"(wt_handle,wt_ptr)int\n\tfunc \"CloseHandle\"(wt_handle)int\n\tfunc \"GetNumberOfConsoleInputEvents\"(wt_handle,wt_ptr)int\n\tfunc \"FlushConsoleInputBuffer\"(wt_handle)int\n\tfunc \"LoadLibraryA\"(wt_ichar)wt_handle\n!\tfunc \"GetProcAddress\"(wt_handle,wt_ichar)wt_wndproc\n\tfunc \"GetProcAddress\"(wt_handle,wt_ichar)ref void\n\tfunc \"LoadCursorA\"(wt_handle,wt_ichar)wt_handle\n\tfunc \"RegisterClassExA\"(wt_ptr)wt_wordpm\n\tfunc \"DefWindowProcA\"(wt_handle,wt_uint,wt_wparam,wt_lparam)int\n\tfunc \"ReadConsoleInputA\"(wt_handle,wt_ptr,wt_dword,wt_ptr)int\n\tproc \"Sleep\"(wt_dword)\n\tfunc \"GetModuleFileNameA\"(wt_handle,wt_ichar,wt_dword)wt_dword\n\n\tproc \"ExitProcess\"(wt_uint)\n\tproc \"PostQuitMessage\"(wt_int)\n\n\tproc \"MessageBoxA\"(wt_int x=0,wt_ichar message, caption=\"Caption\",wt_int y=0)\n\n\tfunc \"QueryPerformanceCounter\"(ref i64)wt_bool\n\tfunc \"QueryPerformanceFrequency\"(ref i64)wt_bool\n\n\tfunc \"CreateFileA\"(wt_ichar,wt_dword,wt_dword,wt_ptr,wt_dword,wt_dword,wt_handle)wt_handle\n\tfunc \"GetFileTime\"(wt_handle,wt_ptr,wt_ptr,wt_ptr)wt_bool\n\n\tproc \"GetSystemTime\"(ref rsystemtime)\n\tproc \"GetLocalTime\"(ref rsystemtime)\n\n\tfunc \"GetTickCount64\":u64\n\tfunc \"PeekMessageA\"\t\t(ref void, ref wt_handle, wt_uint,wt_uint,wt_uint)wt_bool\n\n\tfunc \"GetCommandLineA\":ichar\n\n\tfunc \"VirtualAlloc\" (ref void, wt_dword, wt_dword, wt_dword)ref void\n\tfunc \"VirtualProtect\" (ref void, wt_dword, wt_dword, ref wt_dword)wt_bool\n\n\tfunc \"WriteConsoleA\" (ref void, ref void, i32, ref i32, ref void)wt_bool\n\n\tfunc \"FindFirstFileA\" (wt_ichar,ref rfinddata)wt_handle\n\tfunc \"FindNextFileA\"  (wt_handle, ref rfinddata)wt_bool\n\tfunc \"FindClose\"      (wt_handle)wt_bool\n\n\tfunc \"MessageBeep\"    (i32)wt_bool\n\tfunc \"Beep\"    (i32 freq, dur)wt_bool\nend\n\nrecord input_record = $caligned\n\twt_word\teventtype\n!\tu16\tpadding\n\t\twt_bool\tkeydown\t\t\t!key event record (was inside 'Event' union in win32)\n\t\twt_word\trepeatcount\n\t\twt_word\tvirtualkeycode\n\t\twt_word\tvirtualscancode\n\t\tunion\n\t\t\twt_word unicodechar\n\t\t\twt_char asciichar\n\t\tend\n\t\twt_dword controlkeystate\nend\n\nrecord rspoint=(i16 x,y)\n\nrecord rsrect=\n\ti16 leftx,top,rightx,bottom\nend\n\nglobal record rpoint =\n\twt_long x,y\nend\n\nrecord rconsole=\n\trspoint size,pos\n\tu16 attributes\n\trsrect window\n\trspoint maxwindowsize\nend\n\nrecord rstartupinfo =\n\twt_dword\tsize\n\tu32 dummy1\n\twt_ichar\treserved\n\twt_ichar\tdesktop\n\twt_ichar\ttitle\n\twt_dword\tx\n\twt_dword\ty\n\twt_dword\txsize\n\twt_dword\tysize\n\twt_dword\txcountchars\n\twt_dword\tycountchars\n\twt_dword\tfillattribute\n\twt_dword\tflags\n\twt_word\t\tshowwindow\n\twt_word\t\treserved2\n\tu32 dummy2\n\twt_ptr\t\treserved4\n\twt_handle\tstdinput\n\twt_handle\tstdoutput\n\twt_handle\tstderror\nend\n\nrecord rprocess_information =\n\twt_handle process\n\twt_handle thread\n\twt_dword processid\n\twt_dword threadid\nend\n\nrecord rwndclassex =\n\twt_uint\t\tsize\n\twt_uint\t\tstyle\n\twt_wndproc\twndproc\n\twt_int\t\tclsextra\n\twt_int\t\twndextra\n\twt_handle\tinstance\n\twt_handle\ticon\n\twt_handle\tcursor\n\twt_handle\tbackground\n\twt_ichar\tmenuname\n\twt_ichar\tclassname\n\twt_handle\ticonsm\nend\n\nglobal record rmsg =\n\twt_handle\thwnd\n\twt_uint\t\tmessage\n\tu32\t\tdummy1\n\twt_wparam\twParam\n\twt_lparam\tlParam\n\twt_dword\ttime\n\tu32\t\tdummy2\n\twt_point\tpt\nend\n\nrecord rfiletime =\n\twt_dword lowdatetime\n\twt_dword highdatetime\nend\n\nrecord rfinddata =\n\twt_dword\tfileattributes\n\trfiletime\tcreationtime\n\trfiletime\tlastaccesstime\n\trfiletime\tlastwritetime\n\twt_dword\tfilesizehigh\n\twt_dword\tfilesizelow\n\twt_dword\treserved0\n\twt_dword\treserved1\n\t[260]char\tfilename\n\t[14]char\t\taltfilename\n\twt_dword\tobs1, obs2\n\twt_word\t\tobs3\nend\n\nconst NORMAL_PRIORITY_CLASS=32\nconst CREATE_NEW_CONSOLE=16\nconst DETACHED_PROCESS=16\n\nconst MEM_COMMIT\t\t\t\t= 4096\nconst MEM_RESERVE\t\t\t\t= 8192\nconst PAGE_EXECUTE\t\t\t\t= 16\nconst PAGE_EXECUTE_READ\t\t\t= 32\nconst PAGE_EXECUTE_READWRITE\t= 64\nconst PAGE_NOACCESS\t\t\t\t= 1\n\n\nexport wt_handle hconsole, hconsolein\n\ninput_record lastkey, pendkey\nint keypending\t\t\t!whether pendkey contains a new key event detected by flushkbd\n\nint hpfreq\t\t\t\t!counts per msec\n\n\nref func (ref void)int wndproc_callbackfn=nil\t!windows call-back: address of handler\n\nint init_flag=0\n\nexport proc os_init=\n!general initialisation\n\thconsole:=GetStdHandle(u32(-11))\n\thconsolein:=GetStdHandle(u32(-10))\n\n\tlastkey.repeatcount:=0\n\tkeypending:=0\n\n\tSetConsoleCtrlHandler(nil,1)\n\n\tSetConsoleMode(hconsole,1 ior 2)\n\n\tinit_flag:=1\n\nend\n\nexport func os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int =\n\twt_dword exitcode\n\tint status\n\tint cflags:=0\n\n\trstartupinfo si\n\trprocess_information xpi\n\n\tclear si\n\tclear xpi\n\n\tcase newconsole\n\twhen 0 then cflags := NORMAL_PRIORITY_CLASS\n\twhen 1 then cflags := NORMAL_PRIORITY_CLASS ior CREATE_NEW_CONSOLE\n\twhen 2 then cflags := NORMAL_PRIORITY_CLASS ior DETACHED_PROCESS\n\tesac\n\n\tsi.size := rstartupinfo.bytes\n\n\tstatus:=CreateProcessA(\n\t\tnil,\n\t\tcmdline,\n\t\tnil,\n\n\t\tnil,\n\t\t1,\n\t\tcflags,\n\n\t\tnil,\n\t\tnil,\n\t\t&si,\n\t\t&xpi )\n\n\tif status=0 then\t\t!fails\n\t\tstatus:=GetLastError()\n\t\tprintf(\"Winexec error: %lld\\n\",status)\n\t\treturn -1\n\tfi\n\n\tWaitForSingleObject(xpi.process, 0xFFFF'FFFF)\n\tGetExitCodeProcess(xpi.process,&exitcode)\n\n\tCloseHandle(xpi.process)\n\tCloseHandle(xpi.thread)\n\n\treturn exitcode\nend\n\nexport func os_execcmd(ichar cmdline, int newconsole=0)int =\n\trstartupinfo si\n\trprocess_information xpi\n\n\tclear si\n\tclear xpi\n\n\tsi.size := rstartupinfo.bytes\n\n\tCreateProcessA( nil,\n\t\tcmdline,\n\t\tnil,\n\t\tnil,\n\t\t1,\n\t\tNORMAL_PRIORITY_CLASS ior (newconsole|CREATE_NEW_CONSOLE|0),\n\t\tnil,\n\t\tnil,\n\t\t&si,\n\t\t&xpi )\n\n\tCloseHandle(xpi.process)\n\tCloseHandle(xpi.thread)\n\n\treturn 1\nend\n\nexport func os_getch:int=\n\tint k\n\n\tk:=os_getchx() iand 255\n\n\treturn k\nend\n\nexport func os_kbhit:int=\n\twt_dword count\n\n\tunless init_flag then os_init() end\n\n\tGetNumberOfConsoleInputEvents(hconsolein,&count)\n\treturn count>1\nend\n\nexport func os_getdllinst(ichar name)u64=\n\twt_handle hinst\n\n\thinst:=LoadLibraryA(name)\n\treturn cast(hinst)\nend\n\nexport func os_getdllprocaddr(int hinst,ichar name)ref void=\n\treturn GetProcAddress(cast(hinst),name)\nend\n\nexport proc os_initwindows=\n\tos_init()\n\tos_gxregisterclass(\"pcc001\")\nend\n\nexport proc os_gxregisterclass(ichar classname)=\n\tconst idcarrow=32512\n\trwndclassex r\n\tstatic byte registered\n\n\tif registered then\n\t\treturn\n\tfi\n\n\tclear r\n\n\tr.size:=r.bytes\n\tr.style:=8 ior 32\n\tr.wndproc:=cast(&mainwndproc)\n\tr.instance:=nil\n\n\tr.icon:=nil\n\tr.cursor:=LoadCursorA(nil,ref void(idcarrow))\n\tr.background:=cast(15+1)\n\tr.menuname:=nil\n\tr.classname:=classname\n\tr.iconsm:=nil\n\n\tif RegisterClassExA(&r)=0 then\n\t\tprintf(\"Regclass error: %lld %lld\\n\",classname,GetLastError())\n\t\tstop 1\n\tend\n\tregistered:=1\nend\n\nglobal function mainwndproc (\n\t\twt_handle hwnd, wt_uint message, wt_wparam wParam, wt_lparam lParam)int=\n\trmsg m\n\tint result\n\tstatic int count=0\n\n!CPL \"MAINWNDPROC\",HWND\n\n\tm.hwnd:=hwnd\n\tm.message:=message\n\tm.wParam:=wParam\n\tm.lParam:=lParam\n\tm.pt.x:=0\n\tm.pt.y:=0\n\t\n\tif (wndproc_callbackfn) then\n\t\tresult:=(wndproc_callbackfn^)(&m)\n\telse\n\t\tresult:=0\n\tfi\n\n\tif m.message=wm_destroy then\n\t\treturn 0\n\tfi\n\n\tif not result then\n\t\treturn DefWindowProcA(hwnd,message,wParam,lParam)\n\telse\n\t\treturn 0\n\tfi\nend\n\nexport proc os_setmesshandler(ref void addr)=\n\twndproc_callbackfn:=addr\nend\n\nexport func os_getchx:int=\n!Q! function  os_getchx_c:int\n!return a 32-bit value containing:\n! 15..B0:\tchar code\n! 23..16\tvirtual keycode\n! 31..24\tshift flags (.[24]=shift, .[25]=ctrl, .[26]=alt, .[27]=capslock)\n\tconst rightaltmask\t= 1\n\tconst leftaltmask\t= 2\n\tconst leftctrlmask\t= 8\n\tconst rightctrlmask\t= 4\n\tconst shiftmask\t\t= 16\n\tconst capsmask\t\t= 128\n\tconst scrollmask\t= 64\n\tint count\n\tint charcode,keyshift,keycode\n\tint altdown,ctrldown,shiftdown,capslock\n\n!os_init() unless init_flag\n\tunless init_flag then os_init() end\n\n\tif keypending then\n\t\tlastkey:=pendkey\n\t\tkeypending:=0\n\telse\n\t\tif lastkey.repeatcount=0 then\n\t\t\trepeat\n\t\t\t\tcount:=0\n\t\t\t\tReadConsoleInputA(hconsolein,&lastkey,1,&count)\n\t\t\tuntil (lastkey.eventtype=1 and lastkey.keydown=1)\n\t\tfi\n\tfi\n\n!set shift flags\n\n\taltdown\t\t:= ((lastkey.controlkeystate iand (leftaltmask ior rightaltmask))|1|0)\n\tctrldown\t:= ((lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask))|1|0)\n\tshiftdown\t:= ((lastkey.controlkeystate iand shiftmask)|1|0)\n\tcapslock\t:= ((lastkey.controlkeystate iand capsmask)|1|0)\n\n\t--lastkey.repeatcount\t\t!count this key out\n\n\tcharcode:=lastkey.asciichar\n\tkeycode:=lastkey.virtualkeycode iand 255\n\n\tif charcode<0 then\n\t\tif charcode<-128 then\n\t\t\tcharcode:=0\n\t\telse\n\t\t\tcharcode+:=256\n\t\tfi\n\tfi\n\n!for keycodes in range 186 to 223, which are all stand-alone punctuation keys, I might\n!wish to set charcode to the appropriate printed char code (currently charcode will be\n!zero, and keyboard handlers need to detect keycodes such as vkequals)\n!....\n\n\tif altdown and ctrldown and charcode=166 then\n\t\taltdown:=ctrldown:=0\n\telse\n\t\tif altdown or ctrldown then\n\t\t\tcharcode:=0\n\t\t\tif keycode>='A' and keycode<= 'Z' then\n\t\t\t\tcharcode:=keycode-'@'\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tkeyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown\n\n\treturn keyshift<<24 ior keycode<<16 ior charcode\nend\n\nexport func os_getos=>ichar=\n\treturn \"W64\"\nend\n\nexport func os_gethostsize=>int=\n\treturn 64\nend\n\nexport func os_shellexec(ichar opc, file)int=\n\treturn system(file)\nend\n\nexport proc os_sleep(int a)=\n\tSleep(a)\nend\n\nexport func os_getstdin:filehandle =\n\treturn fopen(\"con\",\"rb\")\nend\n\nexport func os_getstdout:filehandle =\n\treturn fopen(\"con\",\"wb\")\nend\n\nexport func os_gethostname:ichar=\n\tstatic [300]char name\n\tstatic int n\n\n\tGetModuleFileNameA(nil,&.name,name.bytes)\n\treturn &.name\nend\n\nexport func os_getmpath:ichar=\n!BART\n!\treturn \"C:\\\\m\\\\\"\n\treturn F\"C:@@@@\\m\\\" !ABC\n!\treturn \"C:@@@@\\\\m\\\\\" !ABC\nend\n\nexport func os_clock:i64=\n!\treturn clock()\n\treturn os_hpcounter()\nend\n\nexport func os_ticks:i64=\n\treturn GetTickCount64()\nend\n\nexport func os_iswindows:int=\n\treturn 1\nend\n\nexport proc os_getsystime(ref rsystemtime tm)=\n\tGetLocalTime(tm)\nend\n\nexport proc os_peek=\n\tint ticks\n\tstatic int lastticks\n\t[100]byte m\n\tticks:=GetTickCount64()\n\tif ticks-lastticks>=1000 then\n\t\tlastticks:=ticks\n\t\tPeekMessageA(&m,nil,0,0,0)\n\tfi\nend\n\nexport func os_allocexecmem(int n)ref byte=\n\tref byte p\n\tu32 oldprot\n\tint status\n\n\tp := VirtualAlloc(nil, n, MEM_RESERVE ior MEM_COMMIT, PAGE_NOACCESS)\n\tif p = nil then return nil fi\n\n\tstatus := VirtualProtect(p, n, PAGE_EXECUTE_READWRITE, &oldprot)\n\tif status = 0 then return nil fi\n\n\treturn p\nend\n\nexport func dirlist(ichar filespec, ref[]ichar dest, int capacity, t=1)int=\n!filespec is a filename (eg. \"*.dwg\") with possible drive/path; scan\n!directory for all matching files:\n! Store each file in dest array up to capacity\n! Return:\n!  -1:\tcapacity exceeded\n!   N:  number of files found including 0 for no matching files\n\n!t has this value\n! +1  Include normal files only, no sub-directory names\n! +2  Include directories\n! +3  (+1 +2) Include all files including directories\n! +4  Convert to lower case\n\tref void hfind\n\trfinddata file\n\tint nfiles:=0\n\t[300]char path\n\t[300]char fullfilename\n\n\tstrcpy(path, extractpath(filespec))\n\n\n\tif (hfind:=findfirstfilea(filespec,&file))<>ref void(-1) then\t!at least one file\n\t\trepeat\n\t\t\tif (file.fileattributes iand 16) then\t\t!this is a directory\n\t\t\t\tif (t iand 2)=0 then nextloop fi\t\t!no directories\n\t\t\telse\t\t\t\t\t\t!this is a file\n\t\t\t\tif (t iand 1)=0 then nextloop fi\n\t\t\tfi\n\t\t\tif nfiles>=capacity then\n\t\t\t\tnfiles:=-1\n\t\t\t\texit\n\t\t\tfi\n\n\t\t\tif (t iand 4) then\t\t\t\t!to lower case\n\t\t\t\tconvlcstring(file.filename)\n!\t\t\t\tconvlcstring(&.file.filename)\n\t\t\tfi\n\t\t\tstrcpy(fullfilename, path)\n\t\t\tstrcat(fullfilename, file.filename)\n\n\t\t\tdest[++nfiles]:=pcm_copyheapstring(fullfilename)\n\n\t\tuntil not findnextfilea(hfind,&file)\n\t\tfindclose(hfind)\n\tfi\n\treturn nfiles\nend\n\nexport func os_hpcounter:int a =\n!return counter such that successive calls indicate duration in msec\n\n\tif hpfreq=0 then\n\t\thpfreq:=os_hpfreq()/1000\t\t!counts per msec\n\tfi\n\n\tQueryPerformanceCounter(&a)\n\ta/hpfreq\nend\n\nexport func os_hpfreq:int a =\n\tQueryPerformanceFrequency(&a)\n\ta\nend\n\n",
(u64)"!import clib\n!import mlib\n!\n!importlib cstd=\n!\tclang proc     sleep\t(word32)\n!end\n\nrecord termios =\n\ti32 c_iflag\n\ti32 c_oflag\n\ti32 c_cflag\n\ti32 c_lflag\n\tchar c_line\n\t[32]char c_cc\t\t\t\t!at offset 17\n\t[3]byte filler\n\ti32 c_ispeed\t\t\t\t!at offset 52\n\ti32 c_ospeed\nend\n\n!importdll dlstuff=\nimportdll msvcrt=\n\tfunc dlopen\t\t\t(ichar, i32)ref void\n\tfunc dlsym\t\t\t(ref void, ichar)ref void\n\tfunc tcgetattr\t\t(i32, ref termios) i32\n\tfunc tcsetattr\t\t(i32, i32, ref termios) i32\n\tfunc gettimeofday\t(ref timeval, ref void) i32\n\tfunc gmtime_r  \t   (ref i64, ref tm_rec) ref void\n\tproc stdin\n\tproc stdout\nend\n \nrecord timeval =\n\ti64 tv_sec\n\ti64 tv_usec\nend\n\nrecord tm_rec =\n\ti32 tm_sec\n\ti32 tm_min\n\ti32 tm_hour\n\ti32 tm_mday\n\n\ti32 tm_mon\n\ti32 tm_year\n\ti32 tm_wday\n\ti32 tm_yday\n\ti32 tm_isdst\n\t[20]byte padding\nend\n\n!this record is used by some apps, so these fields must be present\nexport record rsystemtime =\n\ti32 year\n\ti32 month\n\ti32 dayofweek\n\ti32 day\n\ti32 hour\n\ti32 minute\n\ti32 second\n\tint milliseconds\nend\n\nint init_flag=0\n\n\nexport proc os_init=\n\tinit_flag:=1\nend\n\nexport func os_execwait(ichar cmdline,int newconsole=0,ichar workdir=nil)int =\n\treturn system(cmdline)\nend\n\nexport func os_execcmd(ichar cmdline, int newconsole)int =\n\treturn system(cmdline)\nend\n\nexport func os_getch:int=\n\tconst ICANON  = 2\n\tconst ECHO    = 8\n\tconst TCSANOW = 0\n\tconst ISIG    = 1\n\n\ttermios old,new\n\tchar ch\n\n\ttcgetattr(0,&old)\n\tnew:=old\n\tnew.c_lflag iand:=inot ICANON\n\tnew.c_lflag iand:=inot ECHO\n\tnew.c_lflag iand:=inot ISIG\n\n\ttcsetattr(0,TCSANOW,&new)\n\n\tch:=getchar()\n\n\ttcsetattr(0,TCSANOW,&old)\n\n\treturn ch\nend\n\nexport func os_kbhit:int=\n\tabortprogram(\"kbhit\")\n\treturn 0\nend\n\nexport proc os_flushkeys=\n\tabortprogram(\"flushkeys\")\nend\n\nexport func os_getconsolein:ref void=\n\treturn nil\nend\n\nexport func os_getconsoleout:ref void=\n\treturn nil\nend\n\nexport func os_proginstance:ref void=\n\tabortprogram(\"PROGINST\")\n\treturn nil\nend\n\nexport func os_getdllinst(ichar name)u64=\n\tconst RTLD_LAZY=1\n\tref void h\n\n\th:=dlopen(name,RTLD_LAZY)\n\n\tif h=nil then\n\t\tif strcmp(name,\"msvcrt\")=0 then\t\t\t!might be linux\n\t\t\th:=dlopen(\"libc.so.6\",RTLD_LAZY);\n\t\tfi\n\tfi\n\n\treturn cast(h)\nend\n\nexport func os_getdllprocaddr(int hlib,ichar name)ref void=\n\tref void fnaddr\n\n\tif hlib=0 then\n\t\treturn nil\n\tfi\n\n\tfnaddr:=dlsym(cast(int(hlib)), name)\n\treturn fnaddr\nend\n\nexport proc os_initwindows=\nend\n\nexport func os_getchx:int=\n\tabortprogram(\"getchx\")\n\treturn 0\nend\n\nexport func os_getos=>ichar=\n!\tif $targetbits=32 then\n!\t\treturn \"L32\"\n!\telse\n\t\treturn \"L64\"\n!\tfi\nend\n\nexport func os_gethostsize=>int=\n\treturn 64\nend\n\nexport func os_iswindows:int=\n\treturn 0\nend\n\nexport func os_shellexec(ichar opc, file)int=\n\tabortprogram(\"SHELL EXEC\")\n\treturn 0\nend\n\nexport proc  os_sleep(int a)=\n!*!\tsleep(a)\nend\n\nexport func os_getstdin:filehandle =\n\tref filehandle pf:=cast(stdin)\n\treturn pf^\nend\n\nexport func os_getstdout:filehandle =\n\tref filehandle pf:=cast(stdout)\n\treturn pf^\nend\n\nexport func os_gethostname:ichar=\n!\tabortprogram(\"gethostname\")\n\treturn \"\"\nend\n\nexport func os_getmpath:ichar=\n!\tabortprogram(\"getmpath\")\n\treturn \"\"\nend\n\nexport proc os_exitprocess(int x)=\n\tstop\n!\t_exit(0)\n!\tExitProcess(x)\nend\n\nexport func os_clock:i64=\n\tif os_iswindows() then\n\t\treturn clock()\n\telse\n\t\treturn clock()/1000\n\tfi\nend\n\nexport func os_ticks:i64=\n\treturn clock()\nend\n\nexport func os_getclockspersec:i64=\n\treturn (os_iswindows()|1000|1000'000)\nend\n\nexport proc os_setmesshandler(ref void addr)=\n\tabortprogram(\"SETMESSHANDLER\")\n!\twndproc_callbackfn:=addr\nend\n\nexport func os_hpcounter:i64=\n\treturn 1\nend\n\nexport func os_hpfrequency:i64=\n\treturn 1\nend\n\nexport func os_filelastwritetime(ichar filename)i64=\n\treturn 0\nend\n\nexport proc os_getsystime(ref rsystemtime tm)=\n\ttimeval tv\n\ttm_rec tmr\n\n\n\tgettimeofday(&tv, nil)\n\tgmtime_r(&tv.tv_sec, &tmr)\n\n\ttm.year := tmr.tm_year + 1900\n\ttm.month := tmr.tm_mon + 1\n\ttm.dayofweek := tmr.tm_wday + 1\n\ttm.day := tmr.tm_mday\n\ttm.hour := tmr.tm_hour\n\ttm.minute := tmr.tm_min\n\ttm.second := tmr.tm_sec\n\ttm.milliseconds := tv.tv_usec/1000\ntm.month:=1\t\t\t!avoid crashing the M compiler\nend\n\nexport proc os_peek=\nend\n\nexport func  os_allocexecmem(int n)ref byte=\n\tabortprogram(\"No allocexec\")\n\tnil\nend\n\nexport func dirlist(ichar filespec, ref[]ichar dest, int capacity, t=1)int=\n\t0\nend\n",
(u64)"export function os_calldllfunction(\n\tref proc fnaddr,\n\tint retcode, nargs,\n\tref[]i64 args,\n\tref[]byte argcodes)u64 =\n\n\tu64 a\n\tr64 x\n\tint nextra := 0, pushedbytes\n\n!Stack is 16-byte aligned at this point\n\n\tif nargs<4 then\n\t\tnextra:=4-nargs\t\t\t!need at least 4 slots for shadow space\n\telsif nargs.odd then\t\t!need one more for a 16-byte-aligned stack\n\t\tnextra:=1\n\tfi\n\n\tpushedbytes:=(nextra+nargs)*8\n\n\tto nextra do\n\t\tasm push 0\n\tod\n\n\tfor i:=nargs downto 1 do\n\t\ta:=args[i]\t\t\t\t!get generic 64-bit value to push\n\t\tasm push u64 [a]\n\tod\n\n! blindly load first 4 args to both int/float regs, whether used or not,\n! and assuming calling a variadic function whether it is or not\n\n\tassem\n\t\tmov D10,   [Dstack]\n\t\tmovq XMM0, [Dstack]\n\t\tmov D11,   [Dstack+8]\n\t\tmovq XMM1, [Dstack+8]\n\t\tmov D12,   [Dstack+16]\n\t\tmovq XMM2, [Dstack+16]\n\t\tmov D13,   [Dstack+24]\n\t\tmovq XMM3, [Dstack+24]\n\tend\n\n\tif retcode='I' then\n\t\ta:=(ref func:i64(fnaddr))^()\n\t\tasm add Dstack,[pushedbytes]\n\t\treturn a\n\n\telse\n\t\tx:=(ref func:r64(fnaddr))^()\n\t\tasm add Dstack,[pushedbytes]\n\t\treturn u64@(x)\t\t\t!(type-punning cast)\n\n\tfi\nend\t\n",
(u64)"type dll0_int=ref function:int\ntype dll1_int=ref function(int)int\ntype dll2_int=ref function(int,int)int\ntype dll3_int=ref function(int,int,int)int\ntype dll4_int=ref function(int,int,int,int)int\ntype dll5_int=ref function(int,int,int,int,int)int\ntype dll6_int=ref function(int,int,int,int,int,int)int\ntype dll8_int=ref function(int,int,int,int, int,int,int,int)int\ntype dll9_int=ref function(int,int,int,int, int,int,int,int, int)int\ntype dll10_int=ref function(int,int,int,int, int,int,int,int, int,int)int\ntype dll11_int=ref function(int,int,int,int, int,int,int,int, int,int,int)int\ntype dll12_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int)int\ntype dll14_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int, int,int)int\n\ntype dll0_r64=ref function:r64\ntype dll1_r64=ref function(int)r64\ntype dll2_r64=ref function(int,int)r64\n\ntype dll0_r64x=ref function:r64\ntype dll1_r64x=ref function(real)r64\ntype dll2_r64x=ref function(real,real)r64\n\ntype m_dll0_int=ref function:int\ntype m_dll1_int=ref function(int)int\ntype m_dll2_int=ref function(int,int)int\ntype m_dll3_int=ref function(int,int,int)int\ntype m_dll4_int=ref function(int,int,int,int)int\ntype m_dll5_int=ref function(int,int,int,int,int)int\ntype m_dll12_int=ref function(int,int,int,int, int,int,int,int, int,int,int,int)int\n\ntype m_dll0_r64=ref function:r64\ntype m_dll1_r64=ref function(int)r64\ntype m_dll2_r64=ref function(int,int)r64\n\n\nexport function os_calldllfunction(ref proc fnaddr,\n\t\tint retcode, nargs, ref[]i64 args, ref[]byte argcodes)u64 =\n!retcode is 'R' or 'I'\n!each argcodes element is 'R' or 'I' too\n!The x64 version can work with any combination.\n!Here, for C, only some combinations are dealt with:\n! I result, params all I (not all param counts)\n! R result, params all I (not all param counts)\n!Mixed params, for arbitrary return type, not handled (not really detected either)\n\n\tu64 a\n\tr64 x\n\tint oddstack, nextra, pushedbytes\n\n!CPL \"/////CCCCCCCCCCCCCCCCCC\"\n\n\tif retcode='I' then\n\t\treturn calldll_cint(fnaddr,args,nargs)\n\telse\n\t\treturn calldll_creal(fnaddr,args,nargs)\n\tfi\nend\t\n\nglobal function os_pushargs(ref[]u64 args, int nargs, nextra,\n\t\t\t\t\tref proc fnaddr, int isfloat)u64=\n\tu64 a\n\tr64 x\n!ABORTPROGRAM(\"PUSHARGS/C NOT READY\")\n\n\treturn os_calldllfunction(fnaddr, (isfloat|0|'I'), nargs, cast(args), nil)\n\n\n!\treturn a\nend\n\nfunction calldll_cint (ref proc fnaddr,ref[]i64 params,int nparams)i64=\nswitch nparams\nwhen 0 then\n\treturn dll0_int(fnaddr)^()\nwhen 1 then\n\treturn dll1_int(fnaddr)^(params^[1])\nwhen 2 then\n\treturn dll2_int(fnaddr)^(params^[1],params^[2])\nwhen 3 then\n\treturn dll3_int(fnaddr)^(params^[1],params^[2],params^[3])\nwhen 4 then\n\treturn dll4_int(fnaddr)^(params^[1],params^[2],params^[3],\n\t\t\tparams^[4])\nwhen 5 then\n\treturn dll5_int(fnaddr)^(params^[1],params^[2],params^[3],\n\t\t\tparams^[4], params^[5])\nwhen 6 then\n\treturn dll6_int(fnaddr)^(params^[1],params^[2],params^[3],\n\t\t\tparams^[4], params^[5],params^[6])\nwhen 8 then \n\treturn (dll8_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8])\nwhen 9 then \n\treturn (dll9_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8],params^[9])\nwhen 10 then \n\treturn (dll10_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8],params^[9],params^[10])\nwhen 11 then \n\treturn (dll11_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8],params^[9],params^[10],\tparams^[11])\n\nwhen 12 then \n\treturn (dll12_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n\t\t\t\tparams^[7],params^[8],params^[9],params^[10],\tparams^[11],params^[12])\n\n!when 14 then \n!\treturn (dll14_int(fnaddr))^(params^[1],params^[2],params^[3],params^[4],\tparams^[5],params^[6],\n!\t\t\t\tparams^[7],params^[8],params^[9],params^[10],\tparams^[11],params^[12],\n!\t\t\t\tparams^[13],params^[14])\n!\nelse\n\tcpl nparams\n\tprintln \"calldll/c/int unsupported # of params\", nparams\n\tstop 1\nend switch\nreturn 0\nend\n\nfunction calldll_creal (ref proc fnaddr,ref[]i64 params,int nparams)i64=\nr64 x\n\nswitch nparams\nwhen 0 then\n\treturn dll0_r64(fnaddr)^()\nwhen 1 then\n\tos_dummycall(params^[1],params^[2],params^[3],params^[4])\n\tx:=dll1_r64(fnaddr)^(params^[1])\nwhen 2 then\n\tx:=dll2_r64(fnaddr)^(params^[1],params^[2])\nelse\n\tprintln \"calldll/c/real too many params\"\n\tstop 1\nend switch\nreturn i64@(x)\nend\n\n\nglobal proc os_dummycall(r64 a,b,c,d)=\nend\n"}};

static u64 mm_modules_fileext = (u64)"m";

static struct $B15 mm_modules_getmodulefilename_str;
static u64 mm_name_currstproc;
static i64 mm_name_allowmodname = 0;

static i64 mm_name_noexpand;
static i64 mm_name_noassem;
static i64 mm_name_macrolevels;
static struct $B19 mm_name_macroparams;
static struct $B19 mm_name_macroparamsgen;
static struct $B19 mm_name_macroargs;
static i64 mm_name_nmacroparams;
static i64 mm_name_nmacroargs;
static i64 mm_parse_intabledata = 0;

static i64 mm_parse_inreadprint = 0;

static i64 mm_parse_inparamlist = 0;

static i64 mm_parse_inrecordbody = 0;

static i64 mm_parse_inimportmodule = 0;

static i64 mm_parse_labelseen = 0;

static u64 mm_parse_tabledataname = 0;

static struct $B1 mm_parse_procstack;
static i64 mm_parse_nprocstack = 0;

static u64 mm_parse_unionstring;
static u64 mm_parse_unionpend;
static u64 mm_parse_unionlastvar = 0;

static u64 mm_parse_dretvar;
static i64 mm_parse_varattribs = 0;

static struct $B1 mm_parse_dollarstack;
static i64 mm_parse_ndollar = 0;

static i64 mm_parse_insiderecord = 0;

static i64 mm_parse_insidedllimport = 0;

static struct $B1 mm_parse_forindexvars;
static i64 mm_parse_nforloops;
// Istatic skipped:mm_parse.readcompilervar.monthnames

static u64 mm_support_bytemasks = -9205322385119247871;

static struct $B16 mm_tables_stdnames = {{
(u64)"void",
(u64)"r64",
(u64)"r32",
(u64)"i64",
(u64)"u64",
(u64)"c64",
(u64)"bool64",
(u64)"ref",
(u64)"rec",
(u64)"range",
(u64)"array",
(u64)"slice",
(u64)"c8",
(u64)"b8",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"ichar",
(u64)"refbit",
(u64)"auto",
(u64)"any",
(u64)"proc",
(u64)"label",
(u64)"type",
(u64)"bitfl",
(u64)"tuple",
(u64)"pend",
(u64)"block",
(u64)"last "}};

static struct $B18 mm_tables_stdsize = {{
578721382704351232,
144397767127601152,
17626613022980,
2251799948427264}};

static struct $B18 mm_tables_stdpcl = {{
433478087141818880,
578434388745456395,
434041037011550985,
3102847684445702}};

static i64 mm_tables_trefproc;
static i64 mm_tables_treflabel;
static struct $B60 mm_tables_sysfnnames = {{
(u64)"sf_init",
(u64)"sf_print_startfile",
(u64)"sf_print_startstr",
(u64)"sf_print_startptr",
(u64)"sf_print_startcon",
(u64)"sf_print_setfmt",
(u64)"sf_print_nogap",
(u64)"sf_print_space",
(u64)"sf_print_i64",
(u64)"sf_print_i64_nf",
(u64)"sf_print_u64",
(u64)"sf_print_r64",
(u64)"sf_print_r32",
(u64)"sf_print_str",
(u64)"sf_print_str_nf",
(u64)"sf_print_strsl",
(u64)"sf_print_ptr",
(u64)"sf_print_ptr_nf",
(u64)"sf_print_c8",
(u64)"sf_print_bool",
(u64)"sf_print_newline",
(u64)"sf_print_end",
(u64)"sf_read_i64",
(u64)"sf_read_r64",
(u64)"sf_read_str",
(u64)"sf_read_fileline",
(u64)"sf_read_strline",
(u64)"sf_read_conline",
(u64)"sf_getnprocs",
(u64)"sf_getprocname",
(u64)"sf_getprocaddr",
(u64)"sf_power_i64",
(u64)"sf_unimpl"}};

static struct $B61 mm_tables_sysfnparams = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B61 mm_tables_sysfnres = {{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1}};

static struct $B60 mm_tables_sysfnhandlers;
static struct $B62 mm_tables_jtagnames = {{
(u64)"jnone",
(u64)"jconst",
(u64)"jnull",
(u64)"jvoidvar",
(u64)"jname",
(u64)"jnamelv",
(u64)"jblock",
(u64)"jdecimal",
(u64)"jassem",
(u64)"jassemmacro",
(u64)"jassemreg",
(u64)"jassemxreg",
(u64)"jassemmem",
(u64)"jstrinclude",
(u64)"jsourceline",
(u64)"jandl",
(u64)"jorl",
(u64)"jnotl",
(u64)"jistruel",
(u64)"jisfalsel",
(u64)"jmakelist",
(u64)"jmakerange",
(u64)"jmakeset",
(u64)"jmakedict",
(u64)"jmakeslice",
(u64)"jreturnmult",
(u64)"jkeyword",
(u64)"jkeyvalue",
(u64)"jassign",
(u64)"jassignmm",
(u64)"jassignms",
(u64)"jassignmdrem",
(u64)"jcall",
(u64)"jcmp",
(u64)"jcmpchain",
(u64)"jbin",
(u64)"junary",
(u64)"jprop",
(u64)"jbinto",
(u64)"junaryto",
(u64)"jincr",
(u64)"jin",
(u64)"jinrev",
(u64)"jinrange",
(u64)"jinset",
(u64)"jstringz",
(u64)"jindex",
(u64)"jindexlv",
(u64)"jslice",
(u64)"jdot",
(u64)"jdotlv",
(u64)"jdotindex",
(u64)"jdotslice",
(u64)"jptr",
(u64)"jptrlv",
(u64)"jaddrof",
(u64)"jaddroffirst",
(u64)"jdaddrvv",
(u64)"jconvert",
(u64)"jshorten",
(u64)"jautocast",
(u64)"jtypepun",
(u64)"jtypeconst",
(u64)"joperator",
(u64)"jupper",
(u64)"jbitwidth",
(u64)"jbytesize",
(u64)"jtypestr",
(u64)"jbitfield",
(u64)"jminvalue",
(u64)"jmaxvalue",
(u64)"jcvlineno",
(u64)"jcvstrlineno",
(u64)"jcvmodulename",
(u64)"jcvfilename",
(u64)"jcvfunction",
(u64)"jcvdate",
(u64)"jcvtime",
(u64)"jcvversion",
(u64)"jcvtypename",
(u64)"jcvnil",
(u64)"jcvpi",
(u64)"jcvinfinity",
(u64)"jcvtrue",
(u64)"jcvfalse",
(u64)"jwhenthen",
(u64)"jfmtitem",
(u64)"jnogap",
(u64)"jspace",
(u64)"jreturn",
(u64)"jsyscall",
(u64)"jto",
(u64)"jif",
(u64)"jforup",
(u64)"jfordown",
(u64)"jforall",
(u64)"jforallrev",
(u64)"jwhile",
(u64)"jrepeat",
(u64)"jgoto",
(u64)"jlabeldef",
(u64)"jredo",
(u64)"jnext",
(u64)"jexit",
(u64)"jdo",
(u64)"jcase",
(u64)"jdocase",
(u64)"jswitch",
(u64)"jdoswitch",
(u64)"jdoswitchu",
(u64)"jdoswitchx",
(u64)"jswap",
(u64)"jselect",
(u64)"jrecase",
(u64)"jprint",
(u64)"jprintln",
(u64)"jfprint",
(u64)"jfprintln",
(u64)"jread",
(u64)"jreadln",
(u64)"jstop",
(u64)"jeval",
(u64)"jclear"}};

static struct $B63 mm_tables_jsubs = {{
0,
0,
0,
0,
0,
0,
1,
0,
3,
0,
0,
0,
1,
1,
1,
2,
2,
1,
1,
1,
2,
2,
1,
1,
2,
0,
1,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
2,
2,
2,
2,
0,
2,
2,
2,
2,
2,
2,
2,
1,
1,
2,
1,
1,
1,
1,
1,
1,
0,
0,
1,
1,
1,
0,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
2,
2,
0,
0,
1,
1,
3,
3,
3,
3,
3,
3,
3,
2,
1,
0,
0,
0,
0,
1,
3,
3,
3,
3,
3,
3,
2,
3,
1,
2,
2,
3,
3,
2,
2,
1,
1,
1}};

static struct $B63 mm_tables_jisexpr = {{
0,
3,
3,
3,
3,
3,
0,
3,
0,
0,
0,
0,
0,
3,
3,
2,
2,
1,
1,
1,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
2,
1,
2,
1,
1,
2,
1,
3,
2,
2,
2,
2,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
1,
1,
1,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
3,
0,
3,
3,
3,
0,
3,
0,
3,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
3,
0,
3,
0,
0,
0,
0,
3,
0,
0,
0,
0,
0,
0,
0,
0,
3,
1}};

static struct $B63 mm_tables_jsolo = {{
0,
0,
0,
0,
0,
0,
1,
0,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
1,
1,
1,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
0,
1,
0,
0,
0,
0,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
0,
1,
1}};

static struct $B33 mm_tables_bitfieldnames = {{
(u64)"bf_msb",
(u64)"bf_lsb",
(u64)"bf_msbit",
(u64)"bf_lsbit",
(u64)"bf_msw",
(u64)"bf_lsw",
(u64)"bf_odd",
(u64)"bf_even"}};

static struct $B18 mm_tables_optypenames = {{
(u64)"no_op",
(u64)"bin_op",
(u64)"mon_op",
(u64)"prop_op"}};

static struct $B64 mm_tables_symbolnames = {{
(u64)".",
(u64)"&.",
(u64)",",
(u64)";",
(u64)":",
(u64)":=",
(u64)"=>",
(u64)"->",
(u64)"(",
(u64)")",
(u64)"[",
(u64)"]",
(u64)"{",
(u64)"}",
(u64)"^",
(u64)"|",
(u64)"@",
(u64)"?",
(u64)"&",
(u64)"&&",
(u64)"..",
(u64)"...",
(u64)"#",
(u64)"+",
(u64)"-",
(u64)"*",
(u64)"/",
(u64)"%",
(u64)"rem",
(u64)"divrem",
(u64)"iand",
(u64)"ior",
(u64)"ixor",
(u64)"<<",
(u64)">>",
(u64)"min",
(u64)"max",
(u64)"and",
(u64)"or",
(u64)"xor",
(u64)"=",
(u64)"cmp",
(u64)"**",
(u64)"in",
(u64)"notin",
(u64)"inrev",
(u64)"not",
(u64)"istrue",
(u64)"inot",
(u64)"abs",
(u64)"sign",
(u64)"sqrt",
(u64)"sqr",
(u64)"propsym",
(u64)"mathsopsym",
(u64)"maths2opsym",
(u64)"bitfieldsym",
(u64)"eolsym",
(u64)"eofsym",
(u64)"rawxnamesym",
(u64)"incrsym",
(u64)"intconstsym",
(u64)"realconstsym",
(u64)"charconstsym",
(u64)"stringconstsym",
(u64)"unitnamesym",
(u64)"namesym",
(u64)"kincludesym",
(u64)"kstrincludesym",
(u64)"regsym",
(u64)"xregsym",
(u64)"fregsym",
(u64)"mregsym",
(u64)"jmpccsym",
(u64)"setccsym",
(u64)"movccsym",
(u64)"segnamesym",
(u64)"asmopcodesym",
(u64)"stdtypesym",
(u64)"kicharsym",
(u64)"kifsym",
(u64)"kthensym",
(u64)"kelsifsym",
(u64)"kelsesym",
(u64)"kelsecasesym",
(u64)"kelseswitchsym",
(u64)"kendsym",
(u64)"kunlesssym",
(u64)"kcasesym",
(u64)"kdocasesym",
(u64)"krecasesym",
(u64)"kwhensym",
(u64)"kforsym",
(u64)"ktosym",
(u64)"kbysym",
(u64)"kdosym",
(u64)"kwhilesym",
(u64)"krepeatsym",
(u64)"kuntilsym",
(u64)"kreturnsym",
(u64)"kstopsym",
(u64)"kloopsym",
(u64)"kgotosym",
(u64)"kswitchsym",
(u64)"kdoswitchsym",
(u64)"kprintsym",
(u64)"kreadsym",
(u64)"kprocsym",
(u64)"kfunctionsym",
(u64)"klabelsym",
(u64)"krecordsym",
(u64)"kstructsym",
(u64)"kunionsym",
(u64)"kimportmodulesym",
(u64)"kprojectsym",
(u64)"ktypesym",
(u64)"krefsym",
(u64)"kvoidsym",
(u64)"kvarsym",
(u64)"kletsym",
(u64)"kslicesym",
(u64)"kmacrosym",
(u64)"kconstsym",
(u64)"kclearsym",
(u64)"kheadersym",
(u64)"kglobalsym",
(u64)"kstaticsym",
(u64)"kcastsym",
(u64)"compilervarsym",
(u64)"dollarsym",
(u64)"kevalsym",
(u64)"ktabledatasym",
(u64)"kclampsym",
(u64)"kswapsym",
(u64)"kassemsym",
(u64)"ksyscallsym"}};

static struct $B37 mm_tables_symboloptypes = {{
1099511627776,
0,
72057598332895232,
72340172838076673,
72340172838076673,
144678142341087489,
3307158503938,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B37 mm_tables_symbolgenops = {{
0,
0,
3098476543630901248,
3689065127789604140,
241444468020,
17732923538145280,
284597173566,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B37 mm_tables_symbolgentoops = {{
0,
0,
6485183463413514240,
7016608629048302683,
439787742050,
30399297484750848,
27243,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B37 mm_tables_symbolopprios = {{
1099511627776,
0,
288230397626548224,
289359587528868612,
578720265945678596,
25870599686,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0}};

static struct $B37 mm_tables_exprstarter = {{
256,
281474976776193,
72057594037993472,
1,
4311744512,
72339069014638849,
72339073326448897,
72340172821233664,
4295032833,
72339069014638592,
1,
1,
0,
0,
1103806595072,
72057594037927936,
72057598332895489}};

static struct $B18 mm_tables_headerdirnames = {{
(u64)"hdr_module",
(u64)"hdr_import",
(u64)"hdr_sourcepath",
(u64)"hdr_linkdll"}};

static struct $B18 mm_tables_scopenames = {{
(u64)"Local",
(u64)"Global",
(u64)"Program",
(u64)"Export"}};

static struct $B3 mm_tables_parammodenames = {{
(u64)"Byval ",
(u64)"Byref "}};

static struct $B34 mm_tables_namenames = {{
(u64)"nullid",
(u64)"programid",
(u64)"subprogid",
(u64)"moduleid",
(u64)"dllmoduleid",
(u64)"typeid",
(u64)"procid",
(u64)"dllprocid",
(u64)"dllvarid",
(u64)"constid",
(u64)"staticid",
(u64)"frameid",
(u64)"paramid",
(u64)"fieldid",
(u64)"labelid",
(u64)"macroid",
(u64)"macroparamid",
(u64)"linkid"}};

static struct $B35 mm_tables_name2pid = {{
0,
2304,
0,
258,
0,
1027,
5,
6,
0}};

static struct $B1 mm_tables_propnames = {{
(u64)"kksliceptr",
(u64)"kklen",
(u64)"kklwb",
(u64)"kkupb",
(u64)"kkbounds",
(u64)"kkbitwidth",
(u64)"kkbytesize",
(u64)"kktypestr",
(u64)"kkminval",
(u64)"kkmaxval"}};

static struct $B65 mm_tables_stnames = {{
(u64)"if",
(u64)"then",
(u64)"elsif",
(u64)"else",
(u64)"dummyelse",
(u64)"elsecase",
(u64)"elseswitch",
(u64)"case",
(u64)"docase",
(u64)"recase",
(u64)"when",
(u64)"for",
(u64)"to",
(u64)"downto",
(u64)"by",
(u64)"do",
(u64)"end",
(u64)"while",
(u64)"repeat",
(u64)"until",
(u64)"return",
(u64)"stop",
(u64)"redoloop",
(u64)"nextloop",
(u64)"exit",
(u64)"goto",
(u64)"switch",
(u64)"doswitch",
(u64)"doswitchu",
(u64)"doswitchx",
(u64)"tabledata",
(u64)"enumdata",
(u64)"clamp",
(u64)"eval",
(u64)"print",
(u64)"println",
(u64)"fprint",
(u64)"fprintln",
(u64)"cp",
(u64)"cpl",
(u64)"read",
(u64)"readln",
(u64)"cast",
(u64)"function",
(u64)"func",
(u64)"proc",
(u64)"fun",
(u64)"threadedproc",
(u64)"type",
(u64)"record",
(u64)"struct",
(u64)"union",
(u64)"ref",
(u64)"var",
(u64)"let",
(u64)"include",
(u64)"binclude",
(u64)"sinclude",
(u64)"strinclude",
(u64)"macro",
(u64)"assem",
(u64)"asm",
(u64)"static",
(u64)"const",
(u64)"$getnprocs",
(u64)"$getprocname",
(u64)"$getprocaddr",
(u64)"importdll",
(u64)"project",
(u64)"unless",
(u64)"global",
(u64)"export",
(u64)"swap",
(u64)"void",
(u64)"int",
(u64)"word",
(u64)"real",
(u64)"ichar",
(u64)"ivoid",
(u64)"i8",
(u64)"i16",
(u64)"i32",
(u64)"i64",
(u64)"r32",
(u64)"r64",
(u64)"byte",
(u64)"u8",
(u64)"u16",
(u64)"u32",
(u64)"u64",
(u64)"char",
(u64)"c8",
(u64)"c64",
(u64)"bool64",
(u64)"bool",
(u64)"bool8",
(u64)"label",
(u64)"slice",
(u64)"million",
(u64)"billion",
(u64)"$lineno",
(u64)"$strlineno",
(u64)"$filename",
(u64)"$modulename",
(u64)"$function",
(u64)"$date",
(u64)"$time",
(u64)"$version",
(u64)"$typename",
(u64)"nil",
(u64)"pi",
(u64)"true",
(u64)"false",
(u64)"infinity",
(u64)"$",
(u64)"and",
(u64)"or",
(u64)"xor",
(u64)"iand",
(u64)"ior",
(u64)"ixor",
(u64)"in",
(u64)"notin",
(u64)"inrev",
(u64)"rem",
(u64)"divrem",
(u64)"min",
(u64)"max",
(u64)"not",
(u64)"inot",
(u64)"istrue",
(u64)"abs",
(u64)"sqr",
(u64)"sqrt",
(u64)"sign",
(u64)"sin",
(u64)"cos",
(u64)"tan",
(u64)"asin",
(u64)"acos",
(u64)"atan",
(u64)"log",
(u64)"log10",
(u64)"exp",
(u64)"round",
(u64)"floor",
(u64)"ceil",
(u64)"atan2",
(u64)"fmod",
(u64)"sliceptr",
(u64)"len",
(u64)"lwb",
(u64)"upb",
(u64)"bounds",
(u64)"bitwidth",
(u64)"bytes",
(u64)"typestr",
(u64)"msb",
(u64)"lsb",
(u64)"msbit",
(u64)"lsbit",
(u64)"msw",
(u64)"lsw",
(u64)"odd",
(u64)"even",
(u64)"fi",
(u64)"esac",
(u64)"od",
(u64)"$caligned",
(u64)"clear",
(u64)"module",
(u64)"import",
(u64)"$sourcepath",
(u64)"linkdll"}};

static struct $B66 mm_tables_stsymbols = {{
21073,
21587,
21844,
22870,
23386,
23900,
24158,
24671,
24919,
25442,
25956,
26214,
26470,
26984,
26985,
33924,
33669,
27242,
27242,
27242,
27499,
28032,
27757,
27757,
28532,
29040,
30581,
17528,
17733,
31301,
34695,
31615,
34952,
29320,
22643,
32382,
30342,
20303,
20559,
20304,
20303,
20303,
20303,
20303,
20303,
20303,
20303,
20303,
31055,
16962,
33153,
33153,
33153,
33153,
33153,
33153,
33153,
9858,
10279,
8223,
11297,
11821,
7709,
9508,
12591,
12848,
13365,
14131,
14135,
14135,
14135,
14135,
14135,
14391,
13880,
13878,
13878,
13878,
14646,
14649,
14649,
14649,
22329,
22359,
31761,
32125,
32125}};

static struct $B67 mm_tables_stsubcodes = {{
92,
92,
6881281,
6881387,
7405674,
0,
65536,
0,
0,
0,
0,
6684773,
103,
7077995,
7209069,
65536,
0,
7536754,
7667828,
7536754,
7798902,
58,
0,
131073,
0,
0,
0,
0,
5439554,
83,
1,
0,
1966109,
31,
0,
196609,
0,
262147,
786433,
917504,
1048591,
131075,
1114113,
1179665,
262163,
786444,
393221,
851974,
720921,
131073,
4718663,
4784202,
4980811,
5111885,
5242959,
5439569,
5374036,
0,
0,
0,
0,
1,
0,
0,
0,
3997696,
0,
4456448,
4587589,
4718663,
4849737,
4980811,
5111885,
5308495,
65619,
196610,
327684,
458758,
65544,
196610,
327684,
458758,
5308424,
6291545,
1,
131073,
262147}};

static struct $B22 mm_tables_convnames = {{
(u64)"kkerror",
(u64)"kkfloat",
(u64)"kkfix",
(u64)"kktruncate",
(u64)"kkwiden",
(u64)"kkfwiden",
(u64)"kkfnarrow",
(u64)"kksoftconv",
(u64)"kktoboolt",
(u64)"kkharderr",
(u64)"kksofttrun",
(u64)"kkichar2sl",
(u64)"kkax2slice",
(u64)"kkcx2ichar"}};

static struct $B23 mm_tables_convtopcl = {{
28416,
29040,
29554,
116,
64,
0,
0}};

static struct $B12 mm_tables_d_typestarterset = {{
79,
11,
117,
111,
80,
121}};

static struct $B36 mm_tables_softconvtable = {{
7,
6,
2,
2,
2,
5,
7,
2,
2,
2,
1,
1,
7,
7,
7,
1,
1,
7,
7,
7,
1,
1,
7,
7,
7}};

static struct $B37 mm_tables_endsexpr;
static struct $B9 mm_tables_exprendsymbols = {{
1397885962,
1465934676,
1577324547}};

static struct $B63 mm_tables_isbooltag;
static i64 mm_type_countedfields;
static i64 mm_type_inassem;
static i64 mm_type_inidata;
static i64 mm_type_tpass_depth;
static i64 mm_type_setrecordsize_depth;
static i64 mm_type_tx_assign_nn;
static void msysc_$getcommands(i64 ncmd, u64 cmds, i64 cmdskipl) {
    u64 R1, R2; 
	asi64(R1) = ncmd;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_ncmdparams = asi64(R1);
	asu64(R1) = cmds;
	msysc_cmdparams = asu64(R1);
	return;
}

static void msysc_pushio() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_niostack;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4;
	R1 = tou64("Too many io levels\n");
	asi32(R1) = printf(asu64(R1));
	R1 = 53;
	exit(R1);
L4:
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) += 1;
	asu64(R1) = msysc_outchan;
	R2 = (u64)&msysc_outchan_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_outdev;
	R2 = (u64)&msysc_outdev_stack;
	asi64(R3) = msysc_niostack;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = msysc_fmtstr;
	R2 = (u64)&msysc_fmtstr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = msysc_needgap;
	R2 = (u64)&msysc_needgap_stack;
	asi64(R3) = msysc_niostack;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 0;
	msysc_fmtstr = asu64(R1);
	R1 = 0;
	msysc_outchan = asu64(R1);
	return;
}

static void msysc_m$print_startfile(u64 dev) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = dev;
	msysc_outchan = asu64(R1);
	asu64(R1) = dev;
	if (!asu64(R1)) goto L7;
	R1 = 2;
	msysc_outdev = asi64(R1);
	goto L6;
L7:
	R1 = 1;
	msysc_outdev = asi64(R1);
L6:
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_startstr(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	msysc_pushio();
	asu64(R1) = s;
	R2 = (u64)&msysc_ptr_stack;
	asi64(R3) = msysc_niostack;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&msysc_ptr_stack;
	asi64(R2) = msysc_niostack;
	R1 += (i64)R2*8-8;
	p = asu64(R1);
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startptr(u64 p) {
    u64 R1; 
	msysc_pushio();
	asu64(R1) = p;
	msysc_outchan = asu64(R1);
	R1 = 3;
	msysc_outdev = asi64(R1);
	return;
}

static void msysc_m$print_startcon() {
    u64 R1; 
	msysc_pushio();
	R1 = 1;
	msysc_outdev = asi64(R1);
	msysc_resetprintbuffer();
	return;
}

static void msysc_m$print_setfmt(u64 format) {
    u64 R1; 
	asu64(R1) = format;
	msysc_fmtstr = asu64(R1);
	return;
}

static void msysc_m$print_end() {
    u64 R1, R2; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	asi64(R1) = msysc_niostack;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L14;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L15;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L14;
L15:
	msysc_dumpprintbuffer();
L14:
	asi64(R1) = msysc_niostack;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L17;
	goto L12;
L17:
	R1 = (u64)&msysc_outchan_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_outchan = asu64(R1);
	R1 = (u64)&msysc_outdev_stack;
	asi64(R2) = msysc_niostack;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	msysc_outdev = asi64(R1);
	R1 = (u64)&msysc_fmtstr_stack;
	asi64(R2) = msysc_niostack;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_fmtstr = asu64(R1);
	R1 = (u64)&msysc_needgap_stack;
	asi64(R2) = msysc_niostack;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	msysc_needgap = asi64(R1);
	R1 = (u64)&msysc_niostack;
	(*toi64p(R1)) -=1;
L12:
	return;
}

static void msysc_m$print_ptr(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L20;
	R1 = tou64("z8H");
	fmtstyle = asu64(R1);
L20:
	asu64(R1) = fmtstyle;
	asu64(R2) = a;
	msysc_m$print_u64(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_ptr_nf(u64 a) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_ptr(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_i64(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	struct $B70 s;
	struct $B3 fmt;
	i64 n;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L24;
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L26;
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	asi64(R4) = a;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	goto L25;
L26:
	asi64(R1) = a;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L27;
	(R1_B3) = msysc_defaultfmt;
	fmt = (R1_B3);
	goto L28;
	goto L25;
L27:
	R1 = 45;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = 10;
	R3 = (u64)&s;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = a;
	asi64(R4) = -asi64(R4);
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L25:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L23;
L24:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 86;
	if (asu64(R1) != asu64(R2)) goto L30;
	asi64(R1) = a;
	msysc_fmtparam = asi64(R1);
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L29;
L30:
// msysc.m$print_i64.dofmt:
L28:
	R1 = (u64)&fmt;
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
L29:
L23:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_i64_nf(i64 a) {
    u64 R1, R2; 
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	return;
}

static void msysc_m$print_bool(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	asi64(R1) = a;
	if (!asi64(R1)) goto L34;
	asu64(R1) = fmtstyle;
	R2 = tou64("True");
	msysc_m$print_str(asu64(R2), asu64(R1));
	goto L33;
L34:
	asu64(R1) = fmtstyle;
	R2 = tou64("False");
	msysc_m$print_str(asu64(R2), asu64(R1));
L33:
	return;
}

static void msysc_m$print_u64(u64 a, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B70 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L37;
	asu64(R1) = a;
	R2 = tou64("%llu");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L36;
L37:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
L36:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r64(r64 x, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B71 s;
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L40;
	asr64(R1) = x;
	R2 = tou64("%f");
	R3 = (u64)&s;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
	R1 = (u64)&s;
	msysc_printstr(asu64(R1));
	goto L39;
L40:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asr64(R2) = x;
	msysc_tostr_r64(asr64(R2), asu64(R1));
L39:
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_r32(r32 x, u64 fmtstyle) {
    u64 R1, R2; 
	asu64(R1) = fmtstyle;
	asr32(R2) = x;
    asr64(R2) = tor64(asr32(R2));
	msysc_m$print_r64(asr64(R2), asu64(R1));
	return;
}

static void msysc_m$print_c8(i64 a, u64 fmtstyle) {
    u64 R1, R2, R3, R4; 
	struct $B18 s;
	struct $B3 fmt;
	i64 n;
	u8 charmode;
	R1 = 0;
	charmode = asu8(R1);
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L44;
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	charmode = asu8(R1);
L44:
	asu8(R1) = charmode;
	R1 = toi64(tou8(R1));
	R2 = 77;
	if (asi64(R1) != asi64(R2)) goto L46;
	R1 = (u64)&fmt;
	R2 = (u64)&s;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L45;
L46:
	asi64(R1) = a;
	R2 = (u64)&s;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&s;
	asi64(R1) = msysc_getutfsize(asu64(R1));
	n = asi64(R1);
L45:
	asi64(R1) = n;
	R2 = (u64)&s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 1;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_str(u64 s, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L49;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L47;
L49:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L51;
	asu64(R1) = s;
	msysc_printstr(asu64(R1));
	goto L50;
L51:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L50:
	R1 = 1;
	msysc_needgap = asi64(R1);
L47:
	return;
}

static void msysc_m$print_strn(u64 s, i64 length, u64 fmtstyle) {
    u64 R1, R2, R3; 
	struct $B3 fmt;
	R1 = 0;
	msysc_nextfmtchars(asi64(R1));
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L54;
	R1 = tou64("<null>");
	msysc_printstr(asu64(R1));
	goto L52;
L54:
	asu64(R1) = fmtstyle;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L56;
	asi64(R1) = length;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L55;
L56:
	R1 = (u64)&fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&fmt;
	asi64(R2) = length;
	asu64(R3) = s;
	msysc_tostr_str(asu64(R3), asi64(R2), asu64(R1));
L55:
	R1 = 1;
	msysc_needgap = asi64(R1);
L52:
	return;
}

static void msysc_m$print_str_nf(u64 s) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	return;
}

static void msysc_m$print_strsl(struct $B3 s, u64 fmtstyle) {
    u64 R1; 
	R1 = tou64("PRTSL");
	mlib_abortprogram(asu64(R1));
	return;
}

static void msysc_m$print_newline() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = 1;
	msysc_nextfmtchars(asi64(R1));
	R1 = tou64("\r\n");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_m$print_nogap() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	return;
}

static void msysc_m$print_space() {
    u64 R1; 
	R1 = 0;
	msysc_needgap = asi64(R1);
	R1 = tou64(" ");
	msysc_printstr(asu64(R1));
	return;
}

static void msysc_printstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_printstr_n(u64 s, i64 n) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_printstrn_app(u64 s, i64 length, u64 f) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L66;
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L68;
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L67;
L68:
	asu64(R1) = s;
	asi64(R2) = length;
	R3 = tou64("%.*s");
	asu64(R4) = f;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
L67:
L66:
	return;
}

static void msysc_printchar(i64 ch) {
    u64 R1, R2, R3; 
	u32 str;
	asi64(R1) = ch;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_nextfmtchars(i64 lastx) {
    u64 R1, R2; 
	u8 c;
	u64 pstart;
	i64 n;
	asu64(R1) = msysc_fmtstr;
	if (asu64(R1)) goto L72;
	asi64(R1) = msysc_needgap;
	if (!asi64(R1)) goto L74;
	R1 = 32;
	msysc_printchar(asi64(R1));
L74:
	R1 = 0;
	msysc_needgap = asi64(R1);
	goto L70;
L72:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L75:
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L78;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L79;
	R2 = 126;
	if (asu64(R1) == asu64(R2)) goto L80;
	goto L81;
L78:
	asi64(R1) = lastx;
	if (!asi64(R1)) goto L83;
	goto L84;
L83:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L86;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
L86:
	goto L70;
	goto L77;
L79:
	asi64(R1) = n;
	if (!asi64(R1)) goto L88;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	goto L87;
L88:
	asi64(R1) = lastx;
	if (asi64(R1)) goto L89;
	R1 = 1;
	R2 = tou64("|");
	msysc_printstr_n(asu64(R2), asi64(R1));
L89:
L87:
	goto L70;
	goto L77;
L80:
	asi64(R1) = n;
	if (!asi64(R1)) goto L91;
	asi64(R1) = n;
	asu64(R2) = pstart;
	msysc_printstr_n(asu64(R2), asi64(R1));
	R1 = 0;
	n = asi64(R1);
L91:
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu64(R1) = msysc_fmtstr;
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	if (!asu8(R1)) goto L93;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_printchar(asi64(R1));
L93:
	asu64(R1) = msysc_fmtstr;
	pstart = asu64(R1);
	goto L77;
L81:
// msysc.nextfmtchars.skip:
L84:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	R1 = (u64)&msysc_fmtstr;
	(*tou64p(R1)) += 1;
L77:
	goto L75;
L70:
	return;
}

static void msysc_strtofmt(u64 s, i64 slen, u64 fmt) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	i64 c;
	i64 base;
	u8 wset;
	i64 n;
	struct $B5 str;
	(R1_B3) = msysc_defaultfmt;
	asu64(R2) = fmt;
	*(struct $B3*)(R2) = (R1_B3);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L96;
	goto L94;
L96:
	asi64(R1) = slen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L98;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
L98:
	asi64(R1) = slen;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	s = asu64(R1);
	R1 = 0;
	wset = asu8(R1);
	goto L100;
L99:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L103;
	R1 = 65;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L103:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) != asi64(R2)) goto L104;
	R1 = 97;
	asu64(R2) = fmt;
	R3 = 8;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L102;
L104:
	asi64(R1) = c;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	switch (asi64(R1)) {
	case 66: goto L108;
	case 67: goto L137;
	case 68: goto L136;
	case 69: goto L133;
	case 70: goto L134;
	case 71: goto L135;
	case 72: goto L109;
	case 73: case 75: case 76: case 82: case 87: goto L107;
	case 74: goto L119;
	case 77: goto L138;
	case 78: goto L141;
	case 79: goto L110;
	case 80: goto L126;
	case 81: goto L118;
	case 83: goto L123;
	case 84: goto L129;
	case 85: goto L132;
	case 86: goto L139;
	case 88: goto L111;
	case 89: goto L140;
	case 90: goto L122;
	default: goto L107;
    };
// SWITCH
L108:
	R1 = 2;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L109:
	R1 = 16;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L110:
	R1 = 8;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L111:
	R1 = 0;
	base = asi64(R1);
L112:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L115;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L115;
	asi64(R1) = base;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	base = asi64(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L114;
L115:
	goto L113;
L114:
	goto L112;
L113:
	asi64(R1) = base;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L117;
	R2 = 16;
	if (asi64(R1) > asi64(R2)) goto L117;
	asi64(R1) = base;
	asu64(R2) = fmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L117:
	goto L105;
L118:
	R1 = 34;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L119:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = fmt;
	R3 = 9;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L121;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L121:
	goto L105;
L122:
	R1 = 48;
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L123:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L125;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L125:
	goto L105;
L126:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L128;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L128:
	goto L105;
L129:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = fmt;
	R3 = 10;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L131;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L131:
	goto L105;
L132:
	R1 = 87;
	asu64(R2) = fmt;
	R3 = 11;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L133:
	R1 = 101;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L134:
	R1 = 102;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L135:
	R1 = 103;
	asu64(R2) = fmt;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L136:
	R1 = 68;
	asu64(R2) = fmt;
	R3 = 13;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L137:
	R1 = 67;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L138:
	R1 = 77;
	asu64(R2) = fmt;
	R3 = 12;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L139:
	R1 = 86;
	asu64(R2) = fmt;
	R3 = 14;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L105;
L140:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L141:
	R1 = 1;
	asu64(R2) = fmt;
	R3 = 15;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L105;
L107:
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L143;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L144;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L145;
	R2 = 126;
	if (asi64(R1) == asi64(R2)) goto L146;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L147;
	goto L148;
L143:
	R1 = 1;
	wset = asu8(R1);
	goto L142;
L144:
	asi64(R1) = c;
	asu64(R2) = fmt;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L145:
	R1 = 43;
	asu64(R2) = fmt;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L146:
	R1 = 126;
	asu64(R2) = fmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L142;
L147:
	asi64(R1) = msysc_fmtparam;
	n = asi64(R1);
	goto L149;
	goto L142;
L148:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L151;
	asi64(R1) = c;
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
L152:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L155;
	goto L153;
L155:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L157;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L157;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	goto L156;
L157:
	goto L153;
L156:
	goto L152;
L153:
// msysc.strtofmt.gotwidth:
L149:
	asu8(R1) = wset;
	if (asu8(R1)) goto L159;
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	wset = asu8(R1);
	goto L158;
L159:
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 1;
	*toi8p(((i64)R2+(i64)R3)) = asi8(R1);
L158:
L151:
L142:
L105:
L102:
L100:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L99;
L94:
	return;
}

static i64 msysc_domultichar(u64 p, i64 n, u64 dest, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B17 str;
	u64 q;
	i64 nchars;
	i64 av_1;
	R1 = (u64)&str;
	q = asu64(R1);
	asi64(R1) = n;
	nchars = asi64(R1);
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L163;
L161:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L165;
	goto L163;
L165:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&q;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L161;
L163:
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = dest;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L160;
L160:
	return asi64(R1);
}

static i64 msysc_expandstr(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3; 
	i64 i;
	i64 w;
	i64 m;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 av_5;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L169;
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) > asi64(R2)) goto L168;
L169:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = n;
	goto L166;
L168:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 76;
	if (asu64(R1) != asu64(R2)) goto L171;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L174;
L172:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	i += 1; if (i <= av_1) goto L172;
L174:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	goto L170;
L171:
	asu64(R1) = fmt;
	R2 = 9;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 82;
	if (asu64(R1) != asu64(R2)) goto L175;
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) != asu64(R2)) goto L177;
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L177;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L178;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L177;
L178:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L181;
L179:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_2)) goto L179;
L181:
	asi64(R1) = n;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = s;
	R3 = 1;
	R2 += (i64)R3;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L176;
L177:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L184;
L182:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_3)) goto L182;
L184:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = t;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L176:
	goto L170;
L175:
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	m = asi64(R1);
	asi64(R1) = m;
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L187;
L185:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_4)) goto L185;
L187:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	asu64(R1) = strncpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	asi64(R2) = m;
	asi64(R1) -= asi64(R2);
	av_5 = asi64(R1);
	asi64(R1) = av_5;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L190;
L188:
	asu64(R1) = fmt;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	if (--asi64(av_5)) goto L188;
L190:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L170:
	asi64(R1) = w;
	goto L166;
L166:
	return asi64(R1);
}

static i64 msysc_u64tostr(u64 aa, u64 s, u64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B71 t;
	u64 dd;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	u64 s0;
	R1 = 0;
	i = asi64(R1);
	R1 = 0;
	k = asi64(R1);
	asu64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L193;
	R1 = 3;
	goto L192;
L193:
	R1 = 4;
L192:
	g = asi64(R1);
L194:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) %= asu64(R2);
	dd = asu64(R1);
	asu64(R1) = aa;
	asu64(R2) = base;
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	aa = asu64(R1);
	R1 = (u64)&msysc_digits;
	asu64(R2) = dd;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&k;
	(*toi64p(R1)) += 1;
	asi64(R1) = sep;
	if (!asi64(R1)) goto L198;
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L198;
	asi64(R1) = k;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L198;
	asi64(R1) = sep;
	R2 = (u64)&t;
	R3 = (u64)&i;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L198:
	asu64(R1) = aa;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L194;
	asi64(R1) = i;
	j = asi64(R1);
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L200;
L199:
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L200:
	asi64(R1) = i;
	if (asi64(R1)) goto L199;
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = j;
	goto L191;
L191:
	return asi64(R1);
}

static i64 msysc_i64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B71 str;
	i64 n;
	i64 usigned;
	R1 = 0;
	usigned = asi64(R1);
	asu64(R1) = fmt;
	R2 = 11;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L204;
	R1 = 1;
	usigned = asi64(R1);
L204:
	asi64(R1) = aa;
	R2 = 0x8000000000000000;
	if (asi64(R1) != asi64(R2)) goto L206;
	asi64(R1) = usigned;
	if (asi64(R1)) goto L206;
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R1) = msysc_i64mintostr(asu64(R3), asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L205;
L206:
	asi64(R1) = usigned;
	if (asi64(R1)) goto L210;
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L209;
L210:
	asu64(R1) = fmt;
	R2 = 6;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L208;
L209:
	asi64(R1) = aa;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L212;
	asi64(R1) = aa;
	asi64(R1) = -asi64(R1);
	aa = asi64(R1);
	R1 = 45;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L211;
L212:
	R1 = 43;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L211:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	R4 = 1;
	R3 += (i64)R4;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	goto L207;
L208:
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
L207:
L205:
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L214;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L214:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L217;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L216;
L217:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L216;
	R1 = (u64)&str;
	asu64(R1) = mlib_convlcstring(asu64(R1));
L216:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L202;
L202:
	return asi64(R1);
}

static i64 msysc_u64tostrfmt(i64 aa, u64 s, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B71 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = fmt;
	R3 = 2;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = tou64(tou8(R2));
	R3 = (u64)&str;
	asi64(R4) = aa;
	asi64(R1) = msysc_u64tostr(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L220;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L220:
	asu64(R1) = fmt;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) > asi64(R2)) goto L223;
	asu64(R1) = fmt;
	R2 = 10;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L222;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) != asu64(R2)) goto L222;
L223:
L222:
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = s;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L218;
L218:
	return asi64(R1);
}

static i64 msysc_i64mintostr(u64 s, i64 base, i64 sep) {
    u64 R1, R2, R3; 
	struct $B71 t;
	i64 i;
	i64 j;
	i64 k;
	i64 g;
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L226;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L227;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L228;
	goto L229;
L226:
	R1 = tou64("9223372036854775808");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 3;
	j = asi64(R1);
	goto L225;
L227:
	R1 = tou64("8000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 1;
	j = asi64(R1);
	goto L225;
L228:
	R1 = tou64("1000000000000000000000000000000000000000000000000000000000000000");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 7;
	j = asi64(R1);
	goto L225;
L229:
	R1 = tou64("<mindint>");
	R2 = (u64)&t;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L225:
	R1 = (u64)&t;
	R2 = 0;
	R1 += (i64)R2;
	asi64(R1) = strlen(asu64(R1));
	i = asi64(R1);
	asi64(R1) = i;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L231;
	asi64(R1) = j;
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L231:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
	asi64(R1) = base;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L233;
	R1 = 3;
	goto L232;
L233:
	R1 = 4;
L232:
	g = asi64(R1);
	goto L235;
L234:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	R1 = (u64)&t;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = sep;
	if (!asi64(R1)) goto L238;
	asi64(R1) = i;
	if (!asi64(R1)) goto L238;
	R1 = (u64)&k;
	asi64(R1) = *(toi64p(R1)) += 1;
	asi64(R2) = g;
	if (asi64(R1) != asi64(R2)) goto L238;
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asi64(R1) = sep;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = 0;
	k = asi64(R1);
L238:
L235:
	asi64(R1) = i;
	if (asi64(R1)) goto L234;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	goto L224;
L224:
	return asi64(R1);
}

static i64 msysc_strtostrfmt(u64 s, u64 t, i64 n, u64 fmt) {
    u64 R1, R2, R3, R4; 
	u64 u;
	u64 v;
	struct $B16 str;
	i64 w;
	i64 nheap;
	R1 = 0;
	nheap = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L242;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L241;
L242:
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) >= asi64(R2)) goto L244;
	R1 = (u64)&str;
	u = asu64(R1);
	goto L243;
L244:
	asi64(R1) = n;
	R2 = 3;
	asi64(R1) += asi64(R2);
	nheap = asi64(R1);
	asi64(R1) = nheap;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	u = asu64(R1);
L243:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L246;
	asu64(R1) = u;
	v = asu64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	asi64(R1) = n;
	if (!asi64(R1)) goto L248;
	asu64(R1) = s;
	asu64(R2) = v;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&v;
	*tou64p(R2) += asu64(R1);
L248:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&v;
	(*tou64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = v;
	*tou8p(R2) = asu8(R1);
	R1 = 2;
	R2 = (u64)&n;
	*toi64p(R2) += asi64(R1);
	goto L245;
L246:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L245:
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 97;
	if (asu64(R1) == asu64(R2)) goto L250;
	R2 = 65;
	if (asu64(R1) == asu64(R2)) goto L251;
	goto L252;
L250:
	asu64(R1) = u;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	goto L249;
L251:
	asu64(R1) = u;
	asu64(R1) = mlib_convucstring(asu64(R1));
	goto L249;
L252:
L249:
	asu64(R1) = u;
	s = asu64(R1);
L241:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	w = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = n;
	if (asi64(R1) <= asi64(R2)) goto L254;
	asu64(R1) = fmt;
	asi64(R2) = n;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	goto L253;
L254:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = t;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L253:
	asi64(R1) = nheap;
	if (!asi64(R1)) goto L256;
	asi64(R1) = nheap;
	asu64(R2) = u;
	mlib_pcm_free(asu64(R2), asi64(R1));
L256:
	asi64(R1) = n;
	goto L239;
L239:
	return asi64(R1);
}

static void msysc_tostr_i64(i64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B71 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L259;
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L260;
	goto L261;
L259:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asi64(R3) = a;
	asi64(R1) = msysc_i64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L260:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L258;
L261:
	R1 = 0;
	asi64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L257;
L258:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L257:
	return;
}

static void msysc_tostr_u64(u64 a, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B71 str;
	i64 n;
	asu64(R1) = fmt;
	R2 = 12;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 77;
	if (asu64(R1) == asu64(R2)) goto L264;
	R2 = 67;
	if (asu64(R1) == asu64(R2)) goto L265;
	goto L266;
L264:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	R3 = 8;
	R4 = (u64)&a;
	asi64(R1) = msysc_domultichar(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
	goto L263;
L265:
	R1 = 0;
	asu64(R2) = a;
	msysc_m$print_c8(asi64(R2), asu64(R1));
	goto L262;
	goto L263;
L266:
	asu64(R1) = fmt;
	R2 = (u64)&str;
	asu64(R3) = a;
	asi64(R1) = msysc_u64tostrfmt(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L263:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
L262:
	return;
}

static void msysc_tostr_r64(r64 x, u64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B71 str;
	struct $B71 str2;
	struct $B2 cfmt;
	i64 n;
	R1 = 37;
	R2 = (u64)&cfmt;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L269;
	R1 = 46;
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 42;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	asu64(R2) = fmt;
	R3 = 1;
	asi8(R2) = *toi8p(((i64)R2+(i64)R3));
	R2 = toi64(toi8(R2));
	R3 = (u64)&cfmt;
	R4 = (u64)&str;
	asi32(R1) = sprintf(asu64(R4), asu64(R3), asi64(R2), asr64(R1));
	goto L268;
L269:
	asu64(R1) = fmt;
	R2 = 5;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&cfmt;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&cfmt;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asr64(R1) = x;
	R2 = (u64)&cfmt;
	R3 = (u64)&str;
	asi32(R1) = sprintf(asu64(R3), asu64(R2), asr64(R1));
L268:
	R1 = (u64)&str;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = fmt;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) >= asi64(R2)) goto L271;
	asu64(R1) = fmt;
	asi64(R2) = n;
	R3 = (u64)&str2;
	R4 = (u64)&str;
	asi64(R1) = msysc_expandstr(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	R1 = (u64)&str2;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L271:
	asi64(R1) = n;
	R2 = (u64)&str;
	msysc_printstr_n(asu64(R2), asi64(R1));
	return;
}

static void msysc_tostr_str(u64 s, i64 oldlen, u64 fmt) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 n;
	u64 t;
	asi64(R1) = oldlen;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L274;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	oldlen = asi64(R1);
L274:
	asi64(R1) = oldlen;
	newlen = asi64(R1);
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) > asi64(R2)) goto L277;
	asu64(R1) = fmt;
	R2 = 8;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L277;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L276;
L277:
	asu64(R1) = fmt;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L279;
	R1 = 2;
	R2 = (u64)&newlen;
	*toi64p(R2) += asi64(R1);
L279:
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = newlen;
	if (asi64(R1) <= asi64(R2)) goto L281;
	asu64(R1) = fmt;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	newlen = asi64(R1);
L281:
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	t = asu64(R1);
	asu64(R1) = fmt;
	asi64(R2) = oldlen;
	asu64(R3) = t;
	asu64(R4) = s;
	asi64(R1) = msysc_strtostrfmt(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	if (!asi8(R1)) goto L283;
	asu64(R1) = fmt;
	R2 = 1;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2));
	R1 = toi64(toi8(R1));
	R2 = (u64)&n;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
L283:
	asi64(R1) = n;
	asu64(R2) = t;
	msysc_printstr_n(asu64(R2), asi64(R1));
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = t;
	mlib_pcm_free(asu64(R2), asi64(R1));
	goto L275;
L276:
	asi64(R1) = oldlen;
	asu64(R2) = s;
	msysc_printstr_n(asu64(R2), asi64(R1));
L275:
	return;
}

static u64 msysc_getfmt(u64 fmtstyle) {
    u64 R1, R2, R3; 
	asu64(R1) = fmtstyle;
	if (!asu64(R1)) goto L286;
	R1 = (u64)&msysc_getfmt_fmt;
	R2 = -1;
	asu64(R3) = fmtstyle;
	msysc_strtofmt(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&msysc_getfmt_fmt;
	goto L285;
L286:
	R1 = (u64)&msysc_defaultfmt;
L285:
	goto L284;
L284:
	return asu64(R1);
}

static u64 msysc_strint(i64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strint_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strint_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L287;
L287:
	return asu64(R1);
}

static void msysc_getstrint(i64 a, u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = 0;
	asu64(R1) = msysc_getfmt(asu64(R1));
	asi64(R2) = a;
	msysc_tostr_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	return;
}

static u64 msysc_strword(u64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strword_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asu64(R2) = a;
	msysc_tostr_u64(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strword_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L289;
L289:
	return asu64(R1);
}

static u64 msysc_strreal(r64 a, u64 fmtstyle) {
    u64 R1, R2; 
	u64 fmt;
	R1 = (u64)&msysc_strreal_str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = fmtstyle;
	asu64(R1) = msysc_getfmt(asu64(R1));
	R2 = R1;
	fmt = asu64(R2);
	asr64(R2) = a;
	msysc_tostr_r64(asr64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = fmt;
	R2 = (u64)&msysc_strreal_str;
	asu64(R1) = msysc_getstr(asu64(R2), asu64(R1));
	goto L290;
L290:
	return asu64(R1);
}

static u64 msysc_getstr(u64 s, u64 fmt) {
    u64 R1, R2; 
	asu64(R1) = fmt;
	R2 = 13;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L293;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	goto L292;
L293:
	asu64(R1) = s;
L292:
	goto L291;
L291:
	return asu64(R1);
}

static void msysc_initreadbuffer() {
    u64 R1, R2; 
	asu64(R1) = msysc_rd_buffer;
	if (!asu64(R1)) goto L296;
	goto L294;
L296:
	R1 = 16384;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	msysc_rd_buffer = asu64(R1);
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = msysc_rd_buffer;
	R2 = R1;
	msysc_rd_lastpos = asu64(R2);
	msysc_rd_pos = asu64(R1);
L294:
	return;
}

static void msysc_m$read_conline() {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	R3 = 0;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_m$read_fileline(u64 f) {
    u64 R1, R2, R3; 
	msysc_initreadbuffer();
	asu64(R1) = f;
	R2 = 1;
	if (asu64(R1) != asu64(R2)) goto L300;
	R1 = tou64("READ CMDLINE");
	mlib_abortprogram(asu64(R1));
	goto L298;
L300:
	R1 = 16384;
	asu64(R2) = msysc_rd_buffer;
	asu64(R3) = f;
	mlib_readlinen(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = msysc_rd_buffer;
	asi64(R1) = strlen(asu64(R1));
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
L298:
	return;
}

static void msysc_m$read_strline(u64 s) {
    u64 R1, R2, R3; 
	i64 n;
	msysc_initreadbuffer();
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 16384;
	if (asi64(R1) >= asi64(R2)) goto L303;
	asu64(R1) = s;
	asu64(R2) = msysc_rd_buffer;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L302;
L303:
	R1 = 16383;
	asu64(R2) = s;
	asu64(R3) = msysc_rd_buffer;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = msysc_rd_buffer;
	R3 = 16384;
	R2 += (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
L302:
	asi64(R1) = n;
	msysc_rd_length = asi64(R1);
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static u64 msysc_readitem(u64 itemlength) {
    u64 R1, R2; 
	u64 p;
	u64 s;
	u64 itemstr;
	u8 quotechar;
	u8 c;
	asu64(R1) = msysc_rd_buffer;
	if (asu64(R1)) goto L306;
	msysc_initreadbuffer();
L306:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	goto L308;
L307:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L308:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L307;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L307;
	asu64(R1) = s;
	itemstr = asu64(R1);
	asu64(R1) = s;
	R2 = R1;
	msysc_rd_pos = asu64(R2);
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L311;
	R1 = 0;
	msysc_termchar = asi64(R1);
	R1 = 0;
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	goto L304;
L311:
	R1 = 0;
	quotechar = asu8(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) != asu64(R2)) goto L313;
	R1 = 34;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L312;
L313:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 39;
	if (asu64(R1) != asu64(R2)) goto L314;
	R1 = 39;
	quotechar = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L314:
L312:
	asu64(R1) = s;
	R2 = R1;
	itemstr = asu64(R2);
	p = asu64(R1);
	goto L316;
L315:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	c = asu8(R1);
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L319;
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L319;
	goto L320;
L319:
	asu8(R1) = quotechar;
	if (asu8(R1)) goto L323;
	asu64(R1) = p;
	asu64(R2) = s;
	if (asu64(R1) != asu64(R2)) goto L322;
L323:
	goto L324;
L322:
	asu8(R1) = c;
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	goto L317;
	goto L318;
L320:
// msysc.readitem.normalchar:
L324:
	asu8(R1) = c;
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L326;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asu8(R2) = quotechar;
	R2 = tou64(tou8(R2));
	if (asu64(R1) != asu64(R2)) goto L328;
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L327;
L328:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
	asi64(R1) = msysc_termchar;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L331;
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L330;
L331:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	msysc_termchar = asi64(R1);
L330:
	goto L317;
L327:
	goto L325;
L326:
	asu8(R1) = c;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L325:
L318:
L316:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L315;
L317:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L333;
	R1 = 0;
	msysc_termchar = asi64(R1);
L333:
	asu64(R1) = p;
	asu64(R2) = itemstr;
	asi64(R1) -= asi64(R2);
	asu64(R2) = itemlength;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = itemstr;
	goto L304;
L304:
	return asu64(R1);
}

static i64 msysc_strtoint(u64 s, i64 length, u64 base) {
    u64 R1, R2; 
	u8 signd;
	u64 aa;
	u64 c;
	u64 d;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L336;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
L336:
	R1 = 0;
	signd = asu8(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L338;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L338;
	R1 = 1;
	signd = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	goto L337;
L338:
	asi64(R1) = length;
	if (!asi64(R1)) goto L339;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L339;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
L339:
L337:
	R1 = 0;
	aa = asu64(R1);
	goto L341;
L340:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	c = asu64(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) -=1;
	asu64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L344;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L344;
	asu64(R1) = c;
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L344:
	asu64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L345;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L345;
	asu64(R1) = c;
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	d = asu64(R1);
	goto L343;
L345:
	asu64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L346;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L346;
	asu64(R1) = c;
	R2 = 48;
	asu64(R1) -= asu64(R2);
	d = asu64(R1);
	goto L343;
L346:
	asu64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L348;
	R2 = 39;
	if (asi64(R1) != asi64(R2)) goto L347;
L348:
	goto L341;
	goto L343;
L347:
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L343:
	asu64(R1) = d;
	asu64(R2) = base;
	if (asu64(R1) < asu64(R2)) goto L350;
	R1 = 1;
	msysc_itemerror = asi64(R1);
	goto L342;
L350:
	asu64(R1) = aa;
	asu64(R2) = base;
	asu64(R1) *= asu64(R2);
	asu64(R2) = d;
	asu64(R1) += asu64(R2);
	aa = asu64(R1);
L341:
	asi64(R1) = length;
	if (asi64(R1)) goto L340;
L342:
	asu8(R1) = signd;
	if (!asu8(R1)) goto L352;
	asu64(R1) = aa;
	asu64(R1) = -asu64(R1);
	goto L351;
L352:
	asu64(R1) = aa;
L351:
	goto L334;
L334:
	return asi64(R1);
}

static i64 msysc_m$read_i64(i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	asi64(R1) = fmt;
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	fmt = asi64(R1);
	asi64(R1) = fmt;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L355;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L356;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L357;
	goto L358;
L355:
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L360;
	R1 = (u64)&msysc_rd_pos;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L353;
	goto L359;
L360:
	R1 = 0;
	goto L353;
L359:
	goto L354;
L356:
	asi64(R1) = msysc_termchar;
	goto L353;
	goto L354;
L357:
	asi64(R1) = msysc_itemerror;
	goto L353;
	goto L354;
L358:
L354:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L362;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L363;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L364;
	goto L365;
L362:
	R1 = 10;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L363:
	R1 = 2;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L364:
	R1 = 16;
	asi64(R2) = length;
	asu64(R3) = s;
	asi64(R1) = msysc_strtoint(asu64(R3), asi64(R2), asu64(R1));
	goto L353;
	goto L361;
L365:
L361:
	R1 = 0;
	goto L353;
L353:
	return asi64(R1);
}

static r64 msysc_m$read_r64(i64 fmt) {
    u64 R1, R2, R3, R4; 
	struct $B38 str;
	u64 s;
	i64 length;
	i32 numlength;
	r64 x;
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L369;
	asi64(R1) = length;
	R2 = 512;
	if (asi64(R1) < asi64(R2)) goto L368;
L369:
	asr64(R1) = 0.000000000000000000e+000;
	goto L366;
L368:
	asi64(R1) = length;
	asu64(R2) = s;
	R3 = (u64)&str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	msysc_itemerror = asi64(R1);
	R1 = (u64)&numlength;
	R2 = (u64)&x;
	R3 = tou64("%lf%n");
	R4 = (u64)&str;
	asi32(R1) = sscanf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L372;
	asi32(R1) = numlength;
	R1 = toi64(toi32(R1));
	asi64(R2) = length;
	if (asi64(R1) == asi64(R2)) goto L371;
L372:
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L371:
	asr64(R1) = x;
	goto L366;
L366:
	return asr64(R1);
}

static void msysc_m$read_str(u64 dest, i64 destlen, i64 fmt) {
    u64 R1, R2, R3; 
	u64 s;
	i64 length;
	R1 = 0;
	msysc_itemerror = asi64(R1);
	asi64(R1) = fmt;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L376;
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L375;
L376:
	asu64(R1) = msysc_rd_pos;
	s = asu64(R1);
	asu64(R1) = msysc_rd_buffer;
	asi64(R2) = msysc_rd_length;
	R1 += (i64)R2;
	asu64(R2) = msysc_rd_pos;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	goto L374;
L375:
	R1 = (u64)&length;
	asu64(R1) = msysc_readitem(asu64(R1));
	s = asu64(R1);
	asi64(R1) = fmt;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L379;
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L378;
L379:
	asi64(R1) = length;
	asu64(R2) = s;
	mlib_iconvlcn(asu64(R2), asi64(R1));
L378:
L374:
	asi64(R1) = destlen;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L381;
	asi64(R1) = length;
	asi64(R2) = destlen;
	if (asi64(R1) < asi64(R2)) goto L383;
	asi64(R1) = destlen;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	R1 = 1;
	msysc_itemerror = asi64(R1);
L383:
L381:
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	asi64(R3) = length;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void msysc_readstr(u64 dest, i64 fmt, i64 destlen) {
    u64 R1, R2, R3; 
	asi64(R1) = fmt;
	asi64(R2) = destlen;
	asu64(R3) = dest;
	msysc_m$read_str(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void msysc_rereadln() {
    u64 R1; 
	asu64(R1) = msysc_rd_buffer;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = msysc_rd_pos;
	msysc_rd_lastpos = asu64(R1);
	return;
}

static void msysc_reread() {
    u64 R1; 
	asu64(R1) = msysc_rd_lastpos;
	msysc_rd_pos = asu64(R1);
	return;
}

static i64 msysc_valint(u64 s, i64 fmt) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	i64 aa;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	asi64(R1) = fmt;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	aa = asi64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asi64(R1) = aa;
	goto L387;
L387:
	return asi64(R1);
}

static r64 msysc_valreal(u64 s) {
    u64 R1; 
	u64 old_pos;
	u64 old_lastpos;
	r64 x;
	msysc_initreadbuffer();
	asu64(R1) = msysc_rd_pos;
	old_pos = asu64(R1);
	asu64(R1) = msysc_rd_lastpos;
	old_lastpos = asu64(R1);
	asu64(R1) = s;
	msysc_rd_pos = asu64(R1);
	R1 = 0;
	asr64(R1) = msysc_m$read_r64(asi64(R1));
	x = asr64(R1);
	asu64(R1) = old_pos;
	msysc_rd_pos = asu64(R1);
	asu64(R1) = old_lastpos;
	msysc_rd_lastpos = asu64(R1);
	asr64(R1) = x;
	goto L388;
L388:
	return asr64(R1);
}

static void msysc_mclunimpl(u64 mess) {
    u64 R1, R2; 
	asu64(R1) = mess;
	R2 = tou64("MCL-UNIMPL: %s\n");
	asi32(R1) = printf(asu64(R2), asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void msysc_dumpstr(u64 s, i64 n, i64 fbuffer) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = msysc_outdev;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L392;
	asu64(R1) = msysc_outchan;
	p = asu64(R1);
	asi64(R1) = n;
	if (!asi64(R1)) goto L394;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = p;
	asu64(R3) = *tou64p(R3);
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	asu64(R2) = p;
	*tou64p(R2) += asu64(R1);
L394:
	R1 = 0;
	asu64(R2) = p;
	asu64(R2) = *tou64p(R2);
	*tou8p(R2) = asu8(R1);
	goto L390;
L392:
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L396;
	goto L390;
L396:
	asi64(R1) = fbuffer;
	if (!asi64(R1)) goto L398;
	asi64(R1) = n;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L398;
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L398;
	R1 = (u64)&msysc_printptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = msysc_printptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L400;
	asu64(R1) = msysc_printptr;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L402;
	R1 = 0;
	asu64(R2) = msysc_printptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	goto L401;
L402:
	R1 = 0;
	asu64(R2) = msysc_printptr;
	*tou8p(R2) = asu8(R1);
L401:
	R1 = (u64)&msysc_printbuffer;
	asi32(R1) = puts(asu64(R1));
	goto L390;
L400:
L398:
	asi64(R1) = msysc_outdev;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L404;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L405;
	goto L406;
L404:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asi32(R1) = printf(asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L405:
	asu64(R1) = s;
	asi64(R2) = n;
	R3 = tou64("%.*s");
	asu64(R4) = msysc_outchan;
	asi32(R1) = fprintf(asu64(R4), asu64(R3), asi64(R2), asu64(R1));
	goto L403;
L406:
L403:
L390:
	return;
}

static void msysc_dumpprintbuffer() {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	if (!asi64(R1)) goto L409;
	R1 = 1;
	asi64(R2) = msysc_printlen;
	R3 = (u64)&msysc_printbuffer;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L409:
	msysc_resetprintbuffer();
	return;
}

static void msysc_resetprintbuffer() {
    u64 R1; 
	R1 = (u64)&msysc_printbuffer;
	msysc_printptr = asu64(R1);
	R1 = 0;
	msysc_printlen = asi64(R1);
	return;
}

static void msysc_addtobuffer(u64 s, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = msysc_printlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	R2 = 4088;
	if (asi64(R1) < asi64(R2)) goto L413;
	msysc_dumpprintbuffer();
L413:
	asi64(R1) = n;
	R2 = 4096;
	if (asi64(R1) >= asi64(R2)) goto L415;
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = msysc_printptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = (u64)&msysc_printptr;
	*tou64p(R2) += asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&msysc_printlen;
	*toi64p(R2) += asi64(R1);
	goto L411;
L415:
	R1 = 0;
	asi64(R2) = n;
	asu64(R3) = s;
	msysc_dumpstr(asu64(R3), asi64(R2), asi64(R1));
L411:
	return;
}

static i64 msysc_getutfsize(u64 s) {
    u64 R1, R2, R3; 
	i64 a;
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L418;
	R1 = 0;
	goto L417;
L418:
	asi64(R1) = a;
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L419;
	R1 = 1;
	goto L417;
L419:
	asi64(R1) = a;
	R2 = 5;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L420;
	R1 = 2;
	goto L417;
L420:
	asi64(R1) = a;
	R2 = 4;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L421;
	R1 = 3;
	goto L417;
L421:
	asi64(R1) = a;
	R2 = 3;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	R2 = 30;
	if (asi64(R1) != asi64(R2)) goto L422;
	R1 = 4;
	goto L417;
L422:
	R1 = 1;
L417:
	goto L416;
L416:
	return asi64(R1);
}

static i64 msysc_m$sign_i64(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L425;
	R1 = -1;
	goto L424;
L425:
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L427;
	R1 = 1;
	goto L426;
L427:
	R1 = 0;
L426:
L424:
	goto L423;
L423:
	return asi64(R1);
}

static r64 msysc_m$sign_r64(r64 x) {
    u64 R1, R2; 
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) >= asr64(R2)) goto L430;
	asr64(R1) = -1.000000000000000000e+000;
	goto L428;
L430:
	asr64(R1) = x;
	asr64(R2) = 0.000000000000000000e+000;
	if (asr64(R1) <= asr64(R2)) goto L432;
	asr64(R1) = 1.000000000000000000e+000;
	goto L428;
L432:
	asr64(R1) = 0.000000000000000000e+000;
	goto L428;
L428:
	return asr64(R1);
}

static u64 mlib_pcm_alloc(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asu8(R1) = mlib_pcm_setup;
	if (asu8(R1)) goto L435;
	mlib_pcm_init();
L435:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L437;
	asi64(R1) = n;
	asi64(R1) = mlib_pcm_getac(asi64(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L439;
	R1 = tou64("pcm_alloc failure");
	mlib_abortprogram(asu64(R1));
L439:
	asu64(R1) = p;
	goto L433;
L437:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mlib_alloccode = asi64(R1);
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = mlib_alloccode;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L441;
	R1 = (u64)&mlib_freelist;
	asi64(R2) = mlib_alloccode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	asi64(R3) = mlib_alloccode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L433;
L441:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L443;
	asi64(R1) = mlib_allocbytes;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L433;
L443:
	asu64(R1) = p;
	goto L433;
L433:
	return asu64(R1);
}

static void mlib_pcm_free(u64 p, i64 n) {
    u64 R1, R2, R3; 
	i64 acode;
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L447;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L446;
L447:
	goto L444;
L446:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L449;
	asu64(R1) = p;
	free(asu64(R1));
	goto L448;
L449:
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = n;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	acode = asi64(R1);
	R1 = (u64)&mlib_freelist;
	asi64(R2) = acode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	asi64(R3) = acode;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L448:
L444:
	return;
}

static void mlib_pcm_freeac(u64 p, i64 alloc) {
    u64 R1, R2; 
	R1 = (u64)&mlib_allocupper;
	asi64(R2) = alloc;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static void mlib_pcm_clearmem(u64 p, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	return;
}

static void mlib_pcm_init() {
    u64 R1, R2, R3; 
	i64 j;
	i64 k;
	i64 size;
	i64 av_1;
	i64 i;
	R1 = 0;
	mlib_alloccode = asi64(R1);
	asu8(R1) = mlib_pcm_setup;
	if (!asu8(R1)) goto L454;
	goto L452;
L454:
	R1 = 0;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	R1 = 1;
	i = asi64(R1);
L455:
	R1 = 1;
	j = asi64(R1);
	R1 = 16;
	k = asi64(R1);
	goto L459;
L458:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) <<= asi64(R2);
	k = asi64(R1);
	R1 = (u64)&j;
	(*toi64p(R1)) += 1;
L459:
	asi64(R1) = i;
	asi64(R2) = k;
	if (asi64(R1) > asi64(R2)) goto L458;
	asi64(R1) = j;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= 2048) goto L455;
	R1 = 16;
	R2 = (u64)&mlib_allocupper;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 16;
	size = asi64(R1);
	R1 = 2;
	i = asi64(R1);
L461:
	R1 = 2;
	R2 = (u64)&size;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	R2 = 33554432;
	if (asi64(R1) < asi64(R2)) goto L465;
	asi64(R1) = i;
	k = asi64(R1);
	goto L463;
L465:
	i += 1; if (i <= 27) goto L461;
L463:
	asi64(R1) = k;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	R1 = 300;
	av_1 = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = av_1;
	if (asi64(R1) > asi64(R2)) goto L468;
L466:
	R1 = 33554432;
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = size;
	R2 = 8589934592;
	if (asi64(R1) >= asi64(R2)) goto L470;
	asi64(R1) = size;
	R2 = (u64)&mlib_allocupper;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = size;
	mlib_maxmemory = asu64(R1);
	goto L469;
L470:
	asi64(R1) = i;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mlib_maxalloccode = asi64(R1);
	goto L468;
L469:
	i += 1; if (i <= av_1) goto L466;
L468:
	R1 = 1;
	mlib_pcm_setup = asu8(R1);
L452:
	return;
}

static i64 mlib_pcm_getac(i64 size) {
    u64 R1, R2; 
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L473;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L471;
L473:
	asi64(R1) = size;
	R2 = 255;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L475;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	asi64(R1) += asi64(R2);
	goto L471;
L475:
	asi64(R1) = size;
	R2 = 63;
	asi64(R1) += asi64(R2);
	R2 = 6;
	asi64(R1) >>= asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	R2 = 2048;
	if (asi64(R1) > asi64(R2)) goto L477;
	R1 = (u64)&mlib_sizeindextable;
	asi64(R2) = size;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	asi64(R1) += asi64(R2);
	goto L471;
L477:
	asi64(R1) = size;
	R2 = 2048;
	asi64(R1) -= asi64(R2);
	R2 = 2047;
	asi64(R1) += asi64(R2);
	R2 = 2048;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 22;
	asi64(R1) += asi64(R2);
	size = asi64(R1);
	asi64(R1) = size;
	goto L471;
L471:
	return asi64(R1);
}

static u64 mlib_pcm_newblock(i64 itemsize) {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 2097152;
	R2 = (u64)&mlib_pcm_newblock_totalheapsize;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	mlib_alloccode = asi64(R1);
	R1 = 2097152;
	asu64(R1) = mlib_allocmem(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L480;
	R1 = tou64("Can't alloc pc heap");
	mlib_abortprogram(asu64(R1));
L480:
	R1 = 2097152;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	mlib_pcheapptr = asu64(R1);
	asu64(R1) = p;
	R2 = 2097152;
	R1 += (i64)R2;
	mlib_pcheapend = asu64(R1);
	asu64(R1) = mlib_pcheapstart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L482;
	asu64(R1) = p;
	mlib_pcheapstart = asu64(R1);
L482:
	asi64(R1) = itemsize;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = p;
	goto L478;
L478:
	return asu64(R1);
}

static i64 mlib_pcm_round(i64 n) {
    u64 R1, R2, R3; 
// PROC LOCAL STATICS GO HERE
	static struct $B13 mlib_pcm_round_allocbytes = {{
0,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048    }};
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) <= asi64(R2)) goto L485;
	asi64(R1) = n;
	goto L484;
L485:
	R1 = (u64)&mlib_pcm_round_allocbytes;
	R2 = (u64)&mlib_sizeindextable;
	asi64(R3) = n;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
L484:
	goto L483;
L483:
	return asi64(R1);
}

static u64 mlib_pcm_allocz(i64 n) {
    u64 R1, R2, R3; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	p = asu64(R1);
	asi64(R1) = n;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	asu64(R1) = p;
	goto L486;
L486:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstring(u64 s) {
    u64 R1, R2, R3; 
	u64 q;
	i64 n;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L489;
	R1 = 0;
	goto L487;
L489:
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L487;
L487:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapstringn(u64 s, i64 n) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L492;
	R1 = 0;
	goto L490;
L492:
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = q;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	goto L490;
L490:
	return asu64(R1);
}

static u64 mlib_pcm_copyheapblock(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 q;
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L495;
	R1 = 0;
	goto L493;
L495:
	asi64(R1) = length;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	q = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = q;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = q;
	goto L493;
L493:
	return asu64(R1);
}

static u64 mlib_allocmem(i64 n) {
    u64 R1; 
	u64 p;
	asi64(R1) = n;
	asu64(R1) = malloc(asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L498;
	asu64(R1) = p;
	goto L496;
L498:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mlib_memtotal;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Alloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L496;
L496:
	return asu64(R1);
}

static u64 mlib_reallocmem(u64 p, i64 n) {
    u64 R1, R2; 
	asi64(R1) = n;
	asu64(R2) = p;
	asu64(R1) = realloc(asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	if (!asu64(R1)) goto L501;
	asu64(R1) = p;
	goto L499;
L501:
	msysc_m$print_startcon();
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Realloc mem failure");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L499;
L499:
	return asu64(R1);
}

static void mlib_abortprogram(u64 s) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("ABORTING: Press key...");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 5;
	exit(R1);
	return;
}

static i64 mlib_getfilesize(u64 handlex) {
    u64 R1, R2, R3; 
	u32 p;
	u32 size;
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	p = asu32(R1);
	R1 = 2;
	R2 = 0;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi32(R1) = ftell(asu64(R1));
	size = asu32(R1);
	R1 = 0;
	asu32(R2) = p;
	R2 = toi64(tou32(R2));
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu32(R1) = size;
	R1 = toi64(tou32(R1));
	goto L503;
L503:
	return asi64(R1);
}

static void mlib_readrandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	i64 a;
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fread(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	return;
}

static i64 mlib_writerandom(u64 handlex, u64 memx, i64 offset, i64 size) {
    u64 R1, R2, R3, R4; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = handlex;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 1;
	asu64(R4) = memx;
	asi64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L505;
L505:
	return asi64(R1);
}

static i64 mlib_setfilepos(u64 file, i64 offset) {
    u64 R1, R2, R3; 
	R1 = 0;
	asi64(R2) = offset;
	asu64(R3) = file;
	asi32(R1) = fseek(asu64(R3), asi32(R2), asi32(R1));
	R1 = toi64(toi32(R1));
	goto L506;
L506:
	return asi64(R1);
}

static i64 mlib_getfilepos(u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = ftell(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L507;
L507:
	return asi64(R1);
}

static u64 mlib_readfile(u64 filename) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 size;
	u64 m;
	u64 p;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L510;
	R1 = 0;
	goto L508;
L510:
	asu64(R1) = f;
	asi64(R1) = mlib_getfilesize(asu64(R1));
	R2 = R1;
	size = asi64(R2);
	mlib_rfsize = asi64(R1);
	asi64(R1) = size;
	R2 = 2;
	asu64(R1) += asu64(R2);
	asu64(R1) = malloc(asu64(R1));
	m = asu64(R1);
	asu64(R1) = m;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L512;
	R1 = 0;
	goto L508;
L512:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = m;
	asu64(R4) = f;
	mlib_readrandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = m;
	asi64(R2) = size;
	R1 += (i64)R2;
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	*tou16p(R2) = asu16(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = m;
	goto L508;
L508:
	return asu64(R1);
}

static i64 mlib_writefile(u64 filename, u64 data, i64 size) {
    u64 R1, R2, R3, R4; 
	u64 f;
	i64 n;
	R1 = tou64("wb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L515;
	R1 = 0;
	goto L513;
L515:
	asi64(R1) = size;
	R2 = 0;
	asu64(R3) = data;
	asu64(R4) = f;
	asi64(R1) = mlib_writerandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asi64(R1) = n;
	goto L513;
L513:
	return asi64(R1);
}

static i64 mlib_checkfile(u64 file) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("rb");
	asu64(R2) = file;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	R2 = R1;
	f = asu64(R2);
	if (!asu64(R1)) goto L518;
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	goto L516;
L518:
	R1 = 0;
	goto L516;
L516:
	return asi64(R1);
}

static void mlib_readlinen(u64 handlex, u64 buffer, i64 size) {
    u64 R1, R2, R3; 
	i64 ch;
	u64 p;
	i64 n;
	u8 crseen;
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L521;
	asu64(R1) = mwindows_os_getstdin();
	handlex = asu64(R1);
L521:
	asu64(R1) = handlex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L523;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = buffer;
	p = asu64(R1);
L524:
	asi32(R1) = getchar();
	R1 = toi64(toi32(R1));
	ch = asi64(R1);
	asi64(R1) = ch;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L528;
	asi64(R1) = ch;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L527;
L528:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L527:
	asi64(R1) = ch;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = n;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	if (asi64(R1) < asi64(R2)) goto L530;
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	goto L519;
L530:
	goto L524;
L523:
	R1 = 0;
	asu64(R2) = buffer;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = handlex;
	asi64(R2) = size;
	R3 = 2;
	asi64(R2) -= asi64(R3);
	asu64(R3) = buffer;
	asu64(R1) = fgets(asu64(R3), asi64(R2), asu64(R1));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L532;
	goto L519;
L532:
	asu64(R1) = buffer;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L534;
	goto L519;
L534:
	asu64(R1) = buffer;
	asi64(R2) = n;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	p = asu64(R1);
	R1 = 0;
	crseen = asu8(R1);
	goto L536;
L535:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L540;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L539;
L540:
	R1 = 1;
	crseen = asu8(R1);
L539:
	R1 = 0;
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) -= 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L536:
	asu64(R1) = p;
	asu64(R2) = buffer;
	if (asu64(R1) < asu64(R2)) goto L541;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L535;
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L535;
L541:
	asu8(R1) = crseen;
	if (asu8(R1)) goto L543;
	asi64(R1) = n;
	R2 = 4;
	asi64(R1) += asi64(R2);
	asi64(R2) = size;
	if (asi64(R1) <= asi64(R2)) goto L543;
	msysc_m$print_startcon();
	asi64(R1) = size;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = n;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("line too long");
	mlib_abortprogram(asu64(R1));
L543:
L519:
	return;
}

static void mlib_iconvlcn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L547;
L545:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L545;
L547:
	return;
}

static void mlib_iconvucn(u64 s, i64 n) {
    u64 R1, R2; 
	i64 av_1;
	asi64(R1) = n;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L551;
L549:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_1)) goto L549;
L551:
	return;
}

static u64 mlib_convlcstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L554;
L553:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = tolower(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L554:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L553;
	asu64(R1) = s0;
	goto L552;
L552:
	return asu64(R1);
}

static u64 mlib_convucstring(u64 s) {
    u64 R1, R2; 
	u64 s0;
	asu64(R1) = s;
	s0 = asu64(R1);
	goto L558;
L557:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L558:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	if (asu8(R1)) goto L557;
	asu64(R1) = s0;
	goto L556;
L556:
	return asu64(R1);
}

static u64 mlib_changeext(u64 s, u64 newext) {
    u64 R1, R2, R3; 
	struct $B18 newext2;
	u64 sext;
	i64 n;
	asu64(R1) = s;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L562;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L563;
	goto L564;
L562:
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&newext2;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L561;
L563:
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L561;
L564:
	R1 = tou64(".");
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = newext;
	R2 = (u64)&newext2;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L561:
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L566;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L567;
	goto L568;
L566:
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L567:
	R1 = (u64)&newext2;
	R2 = 1;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L565;
L568:
	asu64(R1) = sext;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 2;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	R1 = (u64)&newext2;
	R2 = 0;
	R1 += (i64)R2;
	R2 = (u64)&mlib_changeext_newfile;
	R3 = 0;
	R2 += (i64)R3;
	asi64(R3) = n;
	R2 += (i64)R3+1;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L565:
	R1 = (u64)&mlib_changeext_newfile;
	R2 = 0;
	R1 += (i64)R2;
	goto L560;
L560:
	return asu64(R1);
}

static u64 mlib_extractext(u64 s, i64 period) {
    u64 R1, R2; 
	u64 t;
	u64 u;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L571;
	R1 = tou64("");
	goto L569;
L571:
	asu64(R1) = t;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	u = asu64(R1);
	goto L573;
L572:
	asu64(R1) = u;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L576;
	asu64(R1) = u;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L578;
	asi64(R1) = period;
	if (!asi64(R1)) goto L580;
	R1 = tou64(".");
	goto L579;
L580:
	R1 = tou64("");
L579:
	goto L569;
L578:
	asu64(R1) = u;
	R2 = 1;
	R1 += (i64)R2;
	goto L569;
L576:
	R1 = (u64)&u;
	(*tou64p(R1)) -=1;
L573:
	asu64(R1) = u;
	asu64(R2) = t;
	if (asu64(R1) >= asu64(R2)) goto L572;
	R1 = tou64("");
	goto L569;
L569:
	return asu64(R1);
}

static u64 mlib_extractpath(u64 s) {
    u64 R1, R2, R3; 
	u64 t;
	i64 n;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L583;
L582:
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 47;
	if (asu64(R1) == asu64(R2)) goto L586;
	R2 = 58;
	if (asu64(R1) == asu64(R2)) goto L586;
	goto L587;
L586:
	asu64(R1) = t;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	R3 = (u64)&mlib_extractpath_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractpath_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractpath_str;
	goto L581;
	goto L585;
L587:
L585:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L583:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) >= asu64(R2)) goto L582;
	R1 = tou64("");
	goto L581;
L581:
	return asu64(R1);
}

static u64 mlib_extractfile(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R1) = mlib_extractpath(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L590;
	asu64(R1) = s;
	goto L588;
L590:
	asu64(R1) = s;
	asu64(R2) = t;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	goto L588;
L588:
	return asu64(R1);
}

static u64 mlib_extractbasefile(u64 s) {
    u64 R1, R2, R3; 
	u64 f;
	u64 e;
	i64 n;
	i64 flen;
	asu64(R1) = s;
	asu64(R1) = mlib_extractfile(asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asi64(R1) = strlen(asu64(R1));
	flen = asi64(R1);
	asi64(R1) = flen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L593;
	R1 = tou64("");
	goto L591;
L593:
	R1 = 0;
	asu64(R2) = f;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L595;
	asi64(R1) = flen;
	asu64(R2) = e;
	asi64(R2) = strlen(asu64(R2));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L595:
	asu64(R1) = f;
	asi64(R2) = flen;
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L597;
	asi64(R1) = flen;
	R2 = 1;
	asu64(R1) -= asu64(R2);
	asu64(R2) = f;
	R3 = (u64)&mlib_extractbasefile_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_extractbasefile_str;
	asi64(R3) = flen;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_extractbasefile_str;
	goto L591;
L597:
	asu64(R1) = f;
	goto L591;
L591:
	return asu64(R1);
}

static u64 mlib_addext(u64 s, u64 newext) {
    u64 R1, R2; 
	u64 sext;
	R1 = 1;
	asu64(R2) = s;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	sext = asu64(R1);
	asu64(R1) = sext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L600;
	asu64(R1) = newext;
	asu64(R2) = s;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	goto L598;
L600:
	asu64(R1) = s;
	goto L598;
L598:
	return asu64(R1);
}

static u64 mlib_pcm_alloc32() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 32;
	mlib_allocbytes = asi64(R1);
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	p = asu64(R2);
	if (!asu64(R1)) goto L603;
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = p;
	goto L601;
L603:
	R1 = 32;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	goto L601;
L601:
	return asu64(R1);
}

static void mlib_pcm_free32(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&mlib_freelist;
	R2 = 2;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu64(R2) = p;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&mlib_freelist;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	return;
}

static void mlib_outbyte(u64 f, i64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 1;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu16(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 2;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu32(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 4;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outu64(u64 f, u64 x) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	R3 = 8;
	R4 = (u64)&x;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outstring(u64 f, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asu64(R3) = s;
	asi64(R3) = strlen(asu64(R3));
	R4 = 1;
	asu64(R3) += asu64(R4);
	asu64(R4) = s;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mlib_outblock(u64 f, u64 p, i64 n) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = f;
	R2 = 1;
	asi64(R3) = n;
	asu64(R4) = p;
	asu64(R1) = fwrite(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mlib_myeof(u64 f) {
    u64 R1, R2; 
	i64 c;
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L613;
	R1 = 1;
	goto L611;
L613:
	asu64(R1) = f;
	asi64(R2) = c;
	asi32(R1) = ungetc(asi32(R2), asu64(R1));
	R1 = 0;
	goto L611;
L611:
	return asi64(R1);
}

static void mlib_strbuffer_add(u64 dest, u64 s, i64 n) {
    u64 R1, R2, R3, R4; 
	i64 newlen;
	i64 oldlen;
	u64 newptr;
	asi64(R1) = n;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L616;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
L616:
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	oldlen = asi64(R1);
	asi64(R1) = oldlen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L618;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L614;
L618:
	asi64(R1) = oldlen;
	asi64(R2) = n;
	asi64(R1) += asi64(R2);
	newlen = asi64(R1);
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = dest;
	R3 = 12;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) <= asi64(R2)) goto L620;
	asi64(R1) = newlen;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newptr = asu64(R1);
	asi64(R1) = oldlen;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = newptr;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = newptr;
	asu64(R2) = dest;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_allocbytes;
	asu64(R2) = dest;
	R3 = 12;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L620:
	asi64(R1) = n;
	asu64(R2) = s;
	asu64(R3) = dest;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi64(R4) = oldlen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R3) = newlen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = newlen;
	asu64(R2) = dest;
	R3 = 8;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L614:
	return;
}

static void mlib_gs_init(u64 dest) {
    u64 R1, R2; 
	R1 = 16;
	asu64(R2) = dest;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_free(u64 dest) {
    u64 R1, R2, R3; 
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L624;
	asu64(R1) = dest;
	R2 = 12;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_pcm_free(asu64(R2), asi64(R1));
L624:
	return;
}

static void mlib_gs_str(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_char(u64 dest, i64 c) {
    u64 R1, R2, R3; 
	struct $B3 s;
	asi64(R1) = c;
	R2 = (u64)&s;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&s;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strn(u64 dest, u64 s, i64 length) {
    u64 R1, R2, R3; 
	asi64(R1) = length;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strvar(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	R1 = -1;
	asu64(R2) = s;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strint(u64 dest, i64 a) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = 0;
	asi64(R3) = a;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mlib_gs_strln(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mlib_gs_strsp(u64 dest, u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_line(u64 dest) {
    u64 R1, R2, R3; 
	R1 = -1;
	R2 = tou64("\n");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static i64 mlib_gs_getcol(u64 dest) {
    u64 R1, R2; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L633;
L633:
	return asi64(R1);
}

static void mlib_gs_leftstr(u64 dest, u64 s, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	i64 col;
	i64 i;
	i64 n;
	i64 slen;
	struct $B72 str;
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	col = asi64(R1);
	asu64(R1) = s;
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	slen = asi64(R1);
	asi64(R1) = w;
	asi64(R2) = slen;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L636;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L639;
L637:
	asi64(R1) = padch;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = i;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L637;
L639:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = slen;
	asi64(R4) = n;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L636:
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mlib_gs_leftint(u64 dest, i64 a, i64 w, i64 padch) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = padch;
	asi64(R2) = w;
	R3 = 0;
	asi64(R4) = a;
	asu64(R3) = msysc_strint(asi64(R4), asu64(R3));
	asu64(R4) = dest;
	mlib_gs_leftstr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mlib_gs_padto(u64 dest, i64 col, i64 ch) {
    u64 R1, R2, R3; 
	i64 n;
	struct $B72 str;
	i64 i;
	asi64(R1) = col;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L643;
	goto L641;
L643:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L646;
L644:
	asi64(R1) = ch;
	R2 = (u64)&str;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= n) goto L644;
L646:
	R1 = 0;
	R2 = (u64)&str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&str;
	asu64(R2) = dest;
	mlib_gs_str(asu64(R2), asu64(R1));
L641:
	return;
}

static void mlib_gs_println(u64 dest, u64 f) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L649;
	goto L647;
L649:
	R1 = 0;
	asu64(R2) = dest;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = dest;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L651;
	msysc_m$print_startcon();
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\r");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L650;
L651:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64("\r");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L650:
L647:
	return;
}

static i64 mlib_nextcmdparamnew(u64 paramno, u64 name, u64 value, u64 defext) {
    u64 R1, R2; 
	u64 q;
	u64 item;
	u64 fileext;
	i64 length;
// PROC LOCAL STATICS GO HERE
	static i64 mlib_nextcmdparamnew_infile = 0;
	static u64 mlib_nextcmdparamnew_filestart = 0;
	static u64 mlib_nextcmdparamnew_fileptr = 0;
	static u8 mlib_nextcmdparamnew_colonseen = 0;
// mlib.nextcmdparamnew.reenter:
L653:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = mlib_nextcmdparamnew_infile;
	if (!asi64(R1)) goto L655;
	R1 = (u64)&item;
	R2 = (u64)&mlib_nextcmdparamnew_fileptr;
	asi64(R1) = mlib_readnextfileitem(asu64(R2), asu64(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L657;
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	free(asu64(R1));
	R1 = 0;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L657:
	goto L654;
L655:
	asu64(R1) = paramno;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = msysc_ncmdparams;
	if (asi64(R1) <= asi64(R2)) goto L659;
	R1 = 0;
	goto L652;
L659:
	asu64(R1) = msysc_cmdparams;
	asu64(R2) = paramno;
	asi64(R2) = *toi64p(R2);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	item = asu64(R1);
	asu64(R1) = paramno;
	(*toi64p(R1)) += 1;
	asu64(R1) = item;
	asi64(R1) = strlen(asu64(R1));
	length = asi64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 64;
	if (asu64(R1) != asu64(R2)) goto L661;
	asu64(R1) = item;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R1) = mlib_readfile(asu64(R1));
	R2 = R1;
	mlib_nextcmdparamnew_fileptr = asu64(R2);
	mlib_nextcmdparamnew_filestart = asu64(R1);
	asu64(R1) = mlib_nextcmdparamnew_filestart;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L663;
	msysc_m$print_startcon();
	R1 = tou64("Can't open");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = item;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 7;
	exit(R1);
L663:
	R1 = 1;
	mlib_nextcmdparamnew_infile = asi64(R1);
	goto L653;
L661:
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L665;
	R1 = 1;
	mlib_nextcmdparamnew_colonseen = asu8(R1);
	R1 = 4;
	goto L652;
L665:
L654:
	R1 = 0;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = item;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L667;
	asu64(R1) = item;
	asu8(R2) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R2)) goto L669;
	R2 = 0;
	goto L668;
L669:
	R2 = 1;
L668:
	R1 += (i64)R2;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	R1 = 58;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (asu64(R1)) goto L671;
	R1 = 61;
	asu64(R2) = item;
	asu64(R1) = strchr(asu64(R2), asi32(R1));
	q = asu64(R1);
L671:
	asu64(R1) = q;
	if (!asu64(R1)) goto L673;
	asu64(R1) = q;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = value;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	*tou8p(R2) = asu8(R1);
L673:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L675;
	R1 = 5;
	goto L674;
L675:
	R1 = 1;
L674:
	goto L652;
L667:
	R1 = 0;
	asu64(R2) = item;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	fileext = asu64(R1);
	asu64(R1) = item;
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = fileext;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L677;
	asu64(R1) = name;
	asu64(R1) = *tou64p(R1);
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = defext;
	if (!asu64(R1)) goto L679;
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (asu8(R1)) goto L679;
	asu64(R1) = defext;
	R2 = (u64)&mlib_nextcmdparamnew_str;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	asu64(R2) = name;
	*tou64p(R2) = asu64(R1);
L679:
	goto L676;
L677:
	R1 = tou64("dll");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L681;
	R1 = tou64("mcx");
	asu64(R2) = fileext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L680;
L681:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L683;
	R1 = 5;
	goto L682;
L683:
	R1 = 3;
L682:
	goto L652;
L680:
L676:
	asu8(R1) = mlib_nextcmdparamnew_colonseen;
	if (!asu8(R1)) goto L685;
	R1 = 5;
	goto L684;
L685:
	R1 = 2;
L684:
	goto L652;
L652:
	return asi64(R1);
}

static i64 mlib_readnextfileitem(u64 fileptr, u64 item) {
    u64 R1, R2, R3; 
	u64 p;
	u64 pstart;
	u64 pend;
	i64 n;
	asu64(R1) = fileptr;
	asu64(R1) = *tou64p(R1);
	p = asu64(R1);
// mlib.readnextfileitem.reenter:
L687:
L688:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L691;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L692;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L692;
	goto L693;
L691:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L690;
L692:
	R1 = 0;
	goto L686;
	goto L690;
L693:
	goto L689;
L690:
	goto L688;
L689:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 33;
	if (asu64(R1) == asu64(R2)) goto L695;
	R2 = 35;
	if (asu64(R1) == asu64(R2)) goto L695;
	goto L696;
L695:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L697:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L699;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L700;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L700;
	goto L701;
L699:
	goto L687;
	goto L697;
L700:
	asu64(R1) = p;
	R2 = 1;
	R1 -= (i64)R2;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	goto L686;
	goto L697;
L701:
	goto L697;
	goto L694;
L696:
L694:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L703;
	goto L704;
L703:
	R1 = (u64)&p;
	asu64(R1) = *(tou64p(R1)) += 1;
	pstart = asu64(R1);
L705:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L708;
	R2 = 34;
	if (asu64(R1) == asu64(R2)) goto L709;
	goto L710;
L708:
	msysc_m$print_startcon();
	R1 = tou64("Unexpected EOF in @file");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 8;
	exit(R1);
	goto L707;
L709:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 44;
	if (asu64(R1) != asu64(R2)) goto L712;
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
L712:
	goto L706;
	goto L707;
L710:
L707:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L705;
L706:
	goto L702;
L704:
	asu64(R1) = p;
	pstart = asu64(R1);
L713:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 26;
	if (asu64(R1) == asu64(R2)) goto L716;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L717;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L717;
	goto L718;
L716:
	asu64(R1) = p;
	pend = asu64(R1);
	goto L714;
	goto L715;
L717:
	R1 = (u64)&p;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	pend = asu64(R1);
	goto L714;
	goto L715;
L718:
L715:
	R1 = (u64)&p;
	(*tou64p(R1)) += 1;
	goto L713;
L714:
L702:
	asu64(R1) = pend;
	asu64(R2) = pstart;
	asi64(R1) -= asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) < asi64(R2)) goto L720;
	msysc_m$print_startcon();
	R1 = tou64("@file item too long");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 9;
	exit(R1);
L720:
	asi64(R1) = n;
	asu64(R2) = pstart;
	R3 = (u64)&mlib_readnextfileitem_str;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mlib_readnextfileitem_str;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mlib_readnextfileitem_str;
	asu64(R2) = item;
	*tou64p(R2) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = fileptr;
	*tou64p(R2) = asu64(R1);
	R1 = 1;
	goto L686;
L686:
	return asi64(R1);
}

static void mlib_ipadstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2; 
	i64 n;
	i64 av_1;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	n = asi64(R1);
	asi64(R1) = width;
	asi64(R2) = n;
	asi64(R1) -= asi64(R2);
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L724;
L722:
	asu64(R1) = padchar;
	asu64(R2) = s;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	if (--asi64(av_1)) goto L722;
L724:
	return;
}

static u64 mlib_padstr(u64 s, i64 width, u64 padchar) {
    u64 R1, R2, R3; 
	asu64(R1) = s;
	R2 = (u64)&mlib_padstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = padchar;
	asi64(R2) = width;
	R3 = (u64)&mlib_padstr_str;
	mlib_ipadstr(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mlib_padstr_str;
	goto L725;
L725:
	return asu64(R1);
}

static u64 mlib_chr(i64 c) {
    u64 R1, R2, R3; 
	asi64(R1) = c;
	R2 = (u64)&mlib_chr_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mlib_chr_str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mlib_chr_str;
	goto L726;
L726:
	return asu64(R1);
}

static i64 mlib_cmpstring(u64 s, u64 t) {
    u64 R1, R2; 
	i64 res;
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L729;
	R1 = -1;
	goto L728;
L729:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L730;
	R1 = 1;
	goto L728;
L730:
	R1 = 0;
L728:
	goto L727;
L727:
	return asi64(R1);
}

static i64 mlib_cmpstringn(u64 s, u64 t, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = t;
	asu64(R3) = s;
	asi32(R1) = strncmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L733;
	R1 = -1;
	goto L732;
L733:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L734;
	R1 = 1;
	goto L732;
L734:
	R1 = 0;
L732:
	goto L731;
L731:
	return asi64(R1);
}

static i64 mlib_eqstring(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = t;
	asu64(R2) = s;
	asi32(R1) = strcmp(asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L735;
L735:
	return asi64(R1);
}

static i64 mlib_cmpbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	i64 res;
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	res = asi64(R2);
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L738;
	R1 = -1;
	goto L737;
L738:
	asi64(R1) = res;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L739;
	R1 = 1;
	goto L737;
L739:
	R1 = 0;
L737:
	goto L736;
L736:
	return asi64(R1);
}

static i64 mlib_eqbytes(u64 p, u64 q, i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = p;
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L740;
L740:
	return asi64(R1);
}

static void mlib_mseed(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L743;
	asu64(R1) = b;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L742;
L743:
	asu64(R1) = a;
	R2 = (u64)&mlib_seed;
	R3 = 2;
	R2 += (i64)R3*8-8;
	*toi64p(R2) ^= asi64(R1);
L742:
	return;
}

static u64 mlib_mrandom() {
    u64 R1, R2, R3; 
	i64 x;
	i64 y;
	R1 = (u64)&mlib_seed;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	x = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	y = asi64(R1);
	asi64(R1) = y;
	R2 = (u64)&mlib_seed;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = x;
	R2 = 23;
	asi64(R1) <<= asi64(R2);
	R2 = (u64)&x;
	*toi64p(R2) ^= asi64(R1);
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) ^= asi64(R2);
	asi64(R2) = x;
	R3 = 17;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	asi64(R2) = y;
	R3 = 26;
	asi64(R2) >>= asi64(R3);
	asi64(R1) ^= asi64(R2);
	R2 = (u64)&mlib_seed;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&mlib_seed;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = y;
	asu64(R1) += asu64(R2);
	goto L744;
L744:
	return asu64(R1);
}

static i64 mlib_mrandomp() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandom();
	R2 = 9223372036854775807;
	asi64(R1) &= asi64(R2);
	goto L745;
L745:
	return asi64(R1);
}

static i64 mlib_mrandomint(i64 n) {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = n;
	asi64(R1) %= asi64(R2);
	goto L746;
L746:
	return asi64(R1);
}

static i64 mlib_mrandomrange(i64 a, i64 b) {
    u64 R1, R2; 
	i64 span;
	asi64(R1) = b;
	asi64(R2) = a;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	span = asi64(R1);
	asi64(R1) = span;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L749;
	R1 = 0;
	goto L747;
L749:
	asi64(R1) = mlib_mrandomp();
	asi64(R2) = span;
	asi64(R1) %= asi64(R2);
	asi64(R2) = a;
	asi64(R1) += asi64(R2);
	goto L747;
L747:
	return asi64(R1);
}

static r64 mlib_mrandomreal() {
    u64 R1, R2; 
	r64 x;
L751:
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	x = asr64(R1);
	asr64(R1) = x;
	asr64(R2) = 1.000000000000000000e+000;
	if (asr64(R1) == asr64(R2)) goto L751;
	asr64(R1) = x;
	goto L750;
L750:
	return asr64(R1);
}

static r64 mlib_mrandomreal1() {
    u64 R1, R2; 
	asi64(R1) = mlib_mrandomp();
	asr64(R1) = tor64(asi64(R1));
	asr64(R2) = 9.223372036854775800e+018;
	asr64(R1) /= asr64(R2);
	goto L754;
L754:
	return asr64(R1);
}

static u64 mlib_readline() {
    u64 R1; 
	msysc_m$read_conline();
	asu64(R1) = msysc_rd_buffer;
	goto L755;
L755:
	return asu64(R1);
}

static u64 mlib_findfunction(u64 name) {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = $nprocs;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L759;
L757:
	asu64(R1) = name;
	R2 = (u64)&$procname;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L761;
	R1 = (u64)&$procaddr;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L756;
L761:
	i += 1; if (i <= av_1) goto L757;
L759:
	R1 = 0;
	goto L756;
L756:
	return asu64(R1);
}

static i64 mlib_roundtoblock(i64 n, i64 align) {
    u64 R1, R2, R3, R4, R5; 
	asi64(R1) = n;
	asi64(R2) = align;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L764;
	asi64(R1) = n;
	goto L762;
L764:
	asi64(R1) = n;
	asi64(R2) = align;
	asi64(R3) = n;
	asi64(R4) = align;
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	goto L762;
L762:
	return asi64(R1);
}

static u64 mlib_pcm_allocnfz(i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asi64(R1) = n;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L767;
	asi64(R1) = n;
	R2 = 8;
	asi64(R3) = n;
	R4 = 7;
	asi64(R3) &= asi64(R4);
	asi64(R2) -= asi64(R3);
	asi64(R1) += asi64(R2);
	n = asi64(R1);
L767:
	asu64(R1) = mlib_pcheapptr;
	p = asu64(R1);
	asi64(R1) = n;
	R2 = (u64)&mlib_pcheapptr;
	*tou64p(R2) += asu64(R1);
	asu64(R1) = mlib_pcheapptr;
	asu64(R2) = mlib_pcheapend;
	if (asu64(R1) < asu64(R2)) goto L769;
	asi64(R1) = n;
	asu64(R1) = mlib_pcm_newblock(asi64(R1));
	p = asu64(R1);
L769:
	asu64(R1) = p;
	goto L765;
L765:
	return asu64(R1);
}

static void mwindows_os_init() {
    u64 R1, R2, R3; 
	R1 = -11;
	asi64(R1) = toi64(tou32(R1));
	asu64(R1) = GetStdHandle(asu32(R1));
	mwindows_hconsole = asu64(R1);
	R1 = -10;
	asi64(R1) = toi64(tou32(R1));
	asu64(R1) = GetStdHandle(asu32(R1));
	mwindows_hconsolein = asu64(R1);
	R1 = 0;
	R2 = (u64)&mwindows_lastkey;
	R3 = 8;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 0;
	mwindows_keypending = asi64(R1);
	R1 = 1;
	R2 = 0;
	asi64(R1) = SetConsoleCtrlHandler(asu64(R2), asi64(R1));
	R1 = 3;
	asu64(R2) = mwindows_hconsole;
	asi64(R1) = SetConsoleMode(asu64(R2), asu32(R1));
	R1 = 1;
	mwindows_init_flag = asi64(R1);
	return;
}

static i64 mwindows_os_execwait(u64 cmdline, i64 newconsole, u64 workdir) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10; 
	u32 exitcode;
	i64 status;
	i64 cflags;
	struct $B58 si;
	struct $B8 xpi;
	R1 = 0;
	cflags = asi64(R1);
	R1 = (u64)&si;
	memset(R1, 0, 104);
	R1 = (u64)&xpi;
	memset(R1, 0, 24);
	asi64(R1) = newconsole;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L773;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L774;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L775;
	goto L776;
L773:
	R1 = 32;
	cflags = asi64(R1);
	goto L772;
L774:
	R1 = 48;
	cflags = asi64(R1);
	goto L772;
L775:
	R1 = 48;
	cflags = asi64(R1);
	goto L772;
L776:
L772:
	R1 = 104;
	R2 = (u64)&si;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&xpi;
	R2 = (u64)&si;
	R3 = 0;
	R4 = 0;
	asi64(R5) = cflags;
	R6 = 1;
	R7 = 0;
	R8 = 0;
	asu64(R9) = cmdline;
	R10 = 0;
	asi64(R1) = CreateProcessA(asu64(R10), asu64(R9), asu64(R8), asu64(R7), asi64(R6), asu32(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	status = asi64(R1);
	asi64(R1) = status;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L778;
	asu32(R1) = GetLastError();
	R1 = toi64(tou32(R1));
	status = asi64(R1);
	asi64(R1) = status;
	R2 = tou64("Winexec error: %lld\n");
	asi32(R1) = printf(asu64(R2), asi64(R1));
	R1 = -1;
	goto L771;
L778:
	R1 = 4294967295;
	R2 = (u64)&xpi;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu32(R1) = WaitForSingleObject(asu64(R2), asu32(R1));
	R1 = (u64)&exitcode;
	R2 = (u64)&xpi;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = GetExitCodeProcess(asu64(R2), asu64(R1));
	R1 = (u64)&xpi;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	R1 = (u64)&xpi;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	asu32(R1) = exitcode;
	R1 = toi64(tou32(R1));
	goto L771;
L771:
	return asi64(R1);
}

static i64 mwindows_os_execcmd(u64 cmdline, i64 newconsole) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10; 
	struct $B58 si;
	struct $B8 xpi;
	R1 = (u64)&si;
	memset(R1, 0, 104);
	R1 = (u64)&xpi;
	memset(R1, 0, 24);
	R1 = 104;
	R2 = (u64)&si;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&xpi;
	R2 = (u64)&si;
	R3 = 0;
	R4 = 0;
	R5 = 32;
	asi64(R6) = newconsole;
	if (!asi64(R6)) goto L781;
	R6 = 16;
	goto L780;
L781:
	R6 = 0;
L780:
	asi64(R5) |= asi64(R6);
	R6 = 1;
	R7 = 0;
	R8 = 0;
	asu64(R9) = cmdline;
	R10 = 0;
	asi64(R1) = CreateProcessA(asu64(R10), asu64(R9), asu64(R8), asu64(R7), asi64(R6), asu32(R5), asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&xpi;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	R1 = (u64)&xpi;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = CloseHandle(asu64(R1));
	R1 = 1;
	goto L779;
L779:
	return asi64(R1);
}

static i64 mwindows_os_getch() {
    u64 R1, R2; 
	i64 k;
	asi64(R1) = mwindows_os_getchx();
	R2 = 255;
	asi64(R1) &= asi64(R2);
	k = asi64(R1);
	asi64(R1) = k;
	goto L782;
L782:
	return asi64(R1);
}

static i64 mwindows_os_kbhit() {
    u64 R1, R2; 
	u32 count;
	asi64(R1) = mwindows_init_flag;
	if (asi64(R1)) goto L785;
	mwindows_os_init();
L785:
	R1 = (u64)&count;
	asu64(R2) = mwindows_hconsolein;
	asi64(R1) = GetNumberOfConsoleInputEvents(asu64(R2), asu64(R1));
	asu32(R1) = count;
	R1 = toi64(tou32(R1));
	R2 = 1;
	asi64(R1) = asi64(R1)  >  asi64(R2);
	goto L783;
L783:
	return asi64(R1);
}

static u64 mwindows_os_getdllinst(u64 name) {
    u64 R1; 
	u64 hinst;
	asu64(R1) = name;
	asu64(R1) = LoadLibraryA(asu64(R1));
	hinst = asu64(R1);
	asu64(R1) = hinst;
	goto L786;
L786:
	return asu64(R1);
}

static u64 mwindows_os_getdllprocaddr(i64 hinst, u64 name) {
    u64 R1, R2; 
	asu64(R1) = name;
	asi64(R2) = hinst;
	asu64(R1) = GetProcAddress(asu64(R2), asu64(R1));
	goto L787;
L787:
	return asu64(R1);
}

static void mwindows_os_initwindows() {
    u64 R1; 
	mwindows_os_init();
	R1 = tou64("pcc001");
	mwindows_os_gxregisterclass(asu64(R1));
	return;
}

static void mwindows_os_gxregisterclass(u64 classname) {
    u64 R1, R2, R3; 
	struct $B1 r;
	asu8(R1) = mwindows_os_gxregisterclass_registered;
	if (!asu8(R1)) goto L791;
	goto L789;
L791:
	R1 = (u64)&r;
	memset(R1, 0, 80);
	R1 = 80;
	R2 = (u64)&r;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 40;
	R2 = (u64)&r;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mwindows_mainwndproc;
	R2 = (u64)&r;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 32512;
	R2 = 0;
	asu64(R1) = LoadCursorA(asu64(R2), asu64(R1));
	R2 = (u64)&r;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 16;
	R2 = (u64)&r;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = classname;
	R2 = (u64)&r;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&r;
	R3 = 72;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&r;
	asu32(R1) = RegisterClassExA(asu64(R1));
	R1 = toi64(tou32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L793;
	asu32(R1) = GetLastError();
	R1 = toi64(tou32(R1));
	asu64(R2) = classname;
	R3 = tou64("Regclass error: %lld %lld\n");
	asi32(R1) = printf(asu64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	exit(R1);
L793:
	R1 = 1;
	mwindows_os_gxregisterclass_registered = asu8(R1);
L789:
	return;
}

static i64 mwindows_mainwndproc(u64 hwnd, u32 message, u64 wparam, u64 lparam) {
    u64 R1, R2, R3, R4; 
	struct $B12 m;
	i64 result;
// PROC LOCAL STATICS GO HERE
	static i64 mwindows_mainwndproc_count = 0;
	asu64(R1) = hwnd;
	R2 = (u64)&m;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu32(R1) = message;
	R2 = (u64)&m;
	R3 = 8;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = wparam;
	R2 = (u64)&m;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = lparam;
	R2 = (u64)&m;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&m;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = (u64)&m;
	R3 = 44;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = mwindows_wndproc_callbackfn;
	if (!asu64(R1)) goto L796;
	R1 = (u64)&m;
	asu64(R2) = mwindows_wndproc_callbackfn;
	asi64(R1) = ((F1)R2)(asu64(R1));
	result = asi64(R1);
	goto L795;
L796:
	R1 = 0;
	result = asi64(R1);
L795:
	R1 = (u64)&m;
	R2 = 8;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L798;
	R1 = 0;
	goto L794;
L798:
	asi64(R1) = result;
	if (asi64(R1)) goto L800;
	asu64(R1) = lparam;
	asu64(R2) = wparam;
	asu32(R3) = message;
	R3 = toi64(tou32(R3));
	asu64(R4) = hwnd;
	asi64(R1) = DefWindowProcA(asu64(R4), asu32(R3), asu64(R2), asu64(R1));
	goto L799;
L800:
	R1 = 0;
L799:
	goto L794;
L794:
	return asi64(R1);
}

static void mwindows_os_setmesshandler(u64 addr) {
    u64 R1; 
	asu64(R1) = addr;
	mwindows_wndproc_callbackfn = asu64(R1);
	return;
}

static i64 mwindows_os_getchx() {
    u64 R1, R2, R3, R4; struct $B17 R1_B17; 
	i64 count;
	i64 charcode;
	i64 keyshift;
	i64 keycode;
	i64 altdown;
	i64 ctrldown;
	i64 shiftdown;
	i64 capslock;
	asi64(R1) = mwindows_init_flag;
	if (asi64(R1)) goto L804;
	mwindows_os_init();
L804:
	asi64(R1) = mwindows_keypending;
	if (!asi64(R1)) goto L806;
	(R1_B17) = mwindows_pendkey;
	mwindows_lastkey = (R1_B17);
	R1 = 0;
	mwindows_keypending = asi64(R1);
	goto L805;
L806:
	R1 = (u64)&mwindows_lastkey;
	R2 = 8;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L808;
L809:
	R1 = 0;
	count = asi64(R1);
	R1 = (u64)&count;
	R2 = 1;
	R3 = (u64)&mwindows_lastkey;
	asu64(R4) = mwindows_hconsolein;
	asi64(R1) = ReadConsoleInputA(asu64(R4), asu64(R3), asu32(R2), asu64(R1));
	R1 = (u64)&mwindows_lastkey;
	R2 = 0;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L809;
	R1 = (u64)&mwindows_lastkey;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L809;
L808:
L805:
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 3;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L813;
	R1 = 1;
	goto L812;
L813:
	R1 = 0;
L812:
	altdown = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 12;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L815;
	R1 = 1;
	goto L814;
L815:
	R1 = 0;
L814:
	ctrldown = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L817;
	R1 = 1;
	goto L816;
L817:
	R1 = 0;
L816:
	shiftdown = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 16;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 128;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L819;
	R1 = 1;
	goto L818;
L819:
	R1 = 0;
L818:
	capslock = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 8;
	R1 += (i64)R2;
	(*tou16p(R1)) -=1;
	R1 = (u64)&mwindows_lastkey;
	R2 = 14;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	charcode = asi64(R1);
	R1 = (u64)&mwindows_lastkey;
	R2 = 10;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 255;
	asi64(R1) &= asi64(R2);
	keycode = asi64(R1);
	asi64(R1) = charcode;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L821;
	asi64(R1) = charcode;
	R2 = -128;
	if (asi64(R1) >= asi64(R2)) goto L823;
	R1 = 0;
	charcode = asi64(R1);
	goto L822;
L823:
	R1 = 256;
	R2 = (u64)&charcode;
	*toi64p(R2) += asi64(R1);
L822:
L821:
	asi64(R1) = altdown;
	if (!asi64(R1)) goto L825;
	asi64(R1) = ctrldown;
	if (!asi64(R1)) goto L825;
	asi64(R1) = charcode;
	R2 = 166;
	if (asi64(R1) != asi64(R2)) goto L825;
	R1 = 0;
	R2 = R1;
	ctrldown = asi64(R2);
	altdown = asi64(R1);
	goto L824;
L825:
	asi64(R1) = altdown;
	if (asi64(R1)) goto L828;
	asi64(R1) = ctrldown;
	if (!asi64(R1)) goto L827;
L828:
	R1 = 0;
	charcode = asi64(R1);
	asi64(R1) = keycode;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L830;
	asi64(R1) = keycode;
	R2 = 90;
	if (asi64(R1) > asi64(R2)) goto L830;
	asi64(R1) = keycode;
	R2 = 64;
	asi64(R1) -= asi64(R2);
	charcode = asi64(R1);
L830:
L827:
L824:
	asi64(R1) = capslock;
	R2 = 3;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = altdown;
	R3 = 2;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asi64(R2) = ctrldown;
	R3 = 1;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asi64(R2) = shiftdown;
	asi64(R1) |= asi64(R2);
	keyshift = asi64(R1);
	asi64(R1) = keyshift;
	R2 = 24;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = keycode;
	R3 = 16;
	asi64(R2) <<= asi64(R3);
	asi64(R1) |= asi64(R2);
	asi64(R2) = charcode;
	asi64(R1) |= asi64(R2);
	goto L802;
L802:
	return asi64(R1);
}

static u64 mwindows_os_getos() {
    u64 R1; 
	R1 = tou64("W64");
	goto L831;
L831:
	return asu64(R1);
}

static i64 mwindows_os_gethostsize() {
    u64 R1; 
	R1 = 64;
	goto L832;
L832:
	return asi64(R1);
}

static i64 mwindows_os_shellexec(u64 opc, u64 file) {
    u64 R1; 
	asu64(R1) = file;
	asi32(R1) = system(asu64(R1));
	R1 = toi64(toi32(R1));
	goto L833;
L833:
	return asi64(R1);
}

static void mwindows_os_sleep(i64 a) {
    u64 R1; 
	asi64(R1) = a;
	Sleep(asu32(R1));
	return;
}

static u64 mwindows_os_getstdin() {
    u64 R1, R2; 
	R1 = tou64("rb");
	R2 = tou64("con");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	goto L835;
L835:
	return asu64(R1);
}

static u64 mwindows_os_getstdout() {
    u64 R1, R2; 
	R1 = tou64("wb");
	R2 = tou64("con");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	goto L836;
L836:
	return asu64(R1);
}

static u64 mwindows_os_gethostname() {
    u64 R1, R2, R3; 
	R1 = 300;
	R2 = (u64)&mwindows_os_gethostname_name;
	R3 = 0;
	asu32(R1) = GetModuleFileNameA(asu64(R3), asu64(R2), asu32(R1));
	R1 = (u64)&mwindows_os_gethostname_name;
	goto L837;
L837:
	return asu64(R1);
}

static u64 mwindows_os_getmpath() {
    u64 R1; 
	R1 = tou64("C:@@@@\\m\\\"");
	goto L838;
L838:
	return asu64(R1);
}

static i64 mwindows_os_clock() {
    u64 R1; 
	asi64(R1) = mwindows_os_hpcounter();
	goto L839;
L839:
	return asi64(R1);
}

static i64 mwindows_os_ticks() {
    u64 R1; 
	asi64(R1) = GetTickCount64();
	goto L840;
L840:
	return asi64(R1);
}

static i64 mwindows_os_iswindows() {
    u64 R1; 
	R1 = 1;
	goto L841;
L841:
	return asi64(R1);
}

static void mwindows_os_getsystime(u64 tm) {
    u64 R1; 
	asu64(R1) = tm;
	GetLocalTime(asu64(R1));
	return;
}

static void mwindows_os_peek() {
    u64 R1, R2, R3, R4, R5; 
	i64 ticks;
	struct $B5 m;
	asi64(R1) = GetTickCount64();
	ticks = asi64(R1);
	asi64(R1) = ticks;
	asi64(R2) = mwindows_os_peek_lastticks;
	asi64(R1) -= asi64(R2);
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L845;
	asi64(R1) = ticks;
	mwindows_os_peek_lastticks = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = (u64)&m;
	asu32(R1) = PeekMessageA(asu64(R5), asu64(R4), asu32(R3), asu32(R2), asu32(R1));
L845:
	return;
}

static u64 mwindows_os_allocexecmem(i64 n) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u32 oldprot;
	i64 status;
	R1 = 1;
	R2 = 12288;
	asi64(R3) = n;
	R4 = 0;
	asu64(R1) = VirtualAlloc(asu64(R4), asu32(R3), asu32(R2), asu32(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L848;
	R1 = 0;
	goto L846;
L848:
	R1 = (u64)&oldprot;
	R2 = 64;
	asi64(R3) = n;
	asu64(R4) = p;
	asu32(R1) = VirtualProtect(asu64(R4), asu32(R3), asu32(R2), asu64(R1));
	R1 = toi64(tou32(R1));
	status = asi64(R1);
	asi64(R1) = status;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L850;
	R1 = 0;
	goto L846;
L850:
	asu64(R1) = p;
	goto L846;
L846:
	return asu64(R1);
}

static i64 mwindows_dirlist(u64 filespec, u64 dest, i64 capacity, i64 t) {
    u64 R1, R2, R3; 
	u64 hfind;
	struct $B73 file;
	i64 nfiles;
	struct $B15 path;
	struct $B15 fullfilename;
	R1 = 0;
	nfiles = asi64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	R2 = (u64)&path;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&file;
	asu64(R2) = filespec;
	asu64(R1) = FindFirstFileA(asu64(R2), asu64(R1));
	R2 = R1;
	hfind = asu64(R2);
	R2 = -1;
	if (asu64(R1) == asu64(R2)) goto L853;
L854:
	R1 = (u64)&file;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L858;
	asi64(R1) = t;
	R2 = 2;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L860;
	goto L855;
L860:
	goto L857;
L858:
	asi64(R1) = t;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L862;
	goto L855;
L862:
L857:
	asi64(R1) = nfiles;
	asi64(R2) = capacity;
	if (asi64(R1) < asi64(R2)) goto L864;
	R1 = -1;
	nfiles = asi64(R1);
	goto L856;
L864:
	asi64(R1) = t;
	R2 = 4;
	asi64(R1) &= asi64(R2);
	if (!asi64(R1)) goto L866;
	R1 = (u64)&file;
	R2 = 44;
	R1 += (i64)R2;
	asu64(R1) = mlib_convlcstring(asu64(R1));
L866:
	R1 = (u64)&path;
	R2 = (u64)&fullfilename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&file;
	R2 = 44;
	R1 += (i64)R2;
	R2 = (u64)&fullfilename;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&fullfilename;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = dest;
	R3 = (u64)&nfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L855:
	R1 = (u64)&file;
	asu64(R2) = hfind;
	asu32(R1) = FindNextFileA(asu64(R2), asu64(R1));
	if (asu32(R1)) goto L854;
L856:
	asu64(R1) = hfind;
	asu32(R1) = FindClose(asu64(R1));
L853:
	asi64(R1) = nfiles;
	goto L851;
L851:
	return asi64(R1);
}

static i64 mwindows_os_hpcounter() {
    u64 R1, R2; 
	i64 a;
	asi64(R1) = mwindows_hpfreq;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L869;
	asi64(R1) = mwindows_os_hpfreq();
	R2 = 1000;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	mwindows_hpfreq = asi64(R1);
L869:
	R1 = (u64)&a;
	asu32(R1) = QueryPerformanceCounter(asu64(R1));
	asi64(R1) = a;
	asi64(R2) = mwindows_hpfreq;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	goto L867;
L867:
	return asi64(R1);
}

static i64 mwindows_os_hpfreq() {
    u64 R1; 
	i64 a;
	R1 = (u64)&a;
	asu32(R1) = QueryPerformanceFrequency(asu64(R1));
	asi64(R1) = a;
	goto L870;
L870:
	return asi64(R1);
}

static u64 mwindllc_os_calldllfunction(u64 fnaddr, i64 retcode, i64 nargs, u64 args, u64 argcodes) {
    u64 R1, R2, R3; 
	u64 a;
	r64 x;
	i64 oddstack;
	i64 nextra;
	i64 pushedbytes;
	asi64(R1) = retcode;
	R2 = 73;
	if (asi64(R1) != asi64(R2)) goto L873;
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_cint(asu64(R3), asu64(R2), asi64(R1));
	goto L872;
L873:
	asi64(R1) = nargs;
	asu64(R2) = args;
	asu64(R3) = fnaddr;
	asu64(R1) = mwindllc_calldll_creal(asu64(R3), asu64(R2), asi64(R1));
L872:
	goto L871;
L871:
	return asu64(R1);
}

static u64 mwindllc_os_pushargs(u64 args, i64 nargs, i64 nextra, u64 fnaddr, i64 isfloat) {
    u64 R1, R2, R3, R4, R5; 
	u64 a;
	r64 x;
	R1 = 0;
	asu64(R2) = args;
	asi64(R3) = nargs;
	asi64(R4) = isfloat;
	if (!asi64(R4)) goto L876;
	R4 = 0;
	goto L875;
L876:
	R4 = 73;
L875:
	asu64(R5) = fnaddr;
	asu64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	goto L874;
L874:
	return asu64(R1);
}

static i64 mwindllc_calldll_cint(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13; 
	asi64(R1) = nparams;
	switch (asi64(R1)) {
	case 0: goto L881;
	case 1: goto L882;
	case 2: goto L883;
	case 3: goto L884;
	case 4: goto L885;
	case 5: goto L886;
	case 6: goto L887;
	case 7: goto L880;
	case 8: goto L888;
	case 9: goto L889;
	case 10: goto L890;
	case 11: goto L891;
	case 12: goto L892;
	default: goto L880;
    };
// SWITCH
L881:
	asu64(R1) = fnaddr;
	asi64(R1) = ((F2)R1)();
	goto L877;
	goto L878;
L882:
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asi64(R1) = ((F3)R2)(asi64(R1));
	goto L877;
	goto L878;
L883:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asi64(R1) = ((F4)R3)(asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L884:
	asu64(R1) = params;
	R2 = 3;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 2;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 1;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = fnaddr;
	asi64(R1) = ((F5)R4)(asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L885:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = fnaddr;
	asi64(R1) = ((F6)R5)(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L886:
	asu64(R1) = params;
	R2 = 5;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 4;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 3;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 2;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 1;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = fnaddr;
	asi64(R1) = ((F7)R6)(asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L887:
	asu64(R1) = params;
	R2 = 6;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 5;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 4;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 3;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 2;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 1;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = fnaddr;
	asi64(R1) = ((F8)R7)(asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L888:
	asu64(R1) = params;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 7;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 6;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 5;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 4;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 3;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 2;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 1;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = fnaddr;
	asi64(R1) = ((F9)R9)(asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L889:
	asu64(R1) = params;
	R2 = 9;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 7;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 6;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 5;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 4;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 3;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 2;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 1;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = fnaddr;
	asi64(R1) = ((F10)R10)(asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L890:
	asu64(R1) = params;
	R2 = 10;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 9;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 7;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 6;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 5;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 4;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 3;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 2;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 1;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = fnaddr;
	asi64(R1) = ((F11)R11)(asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L891:
	asu64(R1) = params;
	R2 = 11;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 10;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 9;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 8;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 7;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 6;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 5;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 4;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 3;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 2;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 1;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = fnaddr;
	asi64(R1) = ((F12)R12)(asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L892:
	asu64(R1) = params;
	R2 = 12;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 11;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = params;
	R4 = 10;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = params;
	R5 = 9;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asu64(R5) = params;
	R6 = 8;
	asi64(R5) = *toi64p(((i64)R5+(i64)R6*8-8));
	asu64(R6) = params;
	R7 = 7;
	asi64(R6) = *toi64p(((i64)R6+(i64)R7*8-8));
	asu64(R7) = params;
	R8 = 6;
	asi64(R7) = *toi64p(((i64)R7+(i64)R8*8-8));
	asu64(R8) = params;
	R9 = 5;
	asi64(R8) = *toi64p(((i64)R8+(i64)R9*8-8));
	asu64(R9) = params;
	R10 = 4;
	asi64(R9) = *toi64p(((i64)R9+(i64)R10*8-8));
	asu64(R10) = params;
	R11 = 3;
	asi64(R10) = *toi64p(((i64)R10+(i64)R11*8-8));
	asu64(R11) = params;
	R12 = 2;
	asi64(R11) = *toi64p(((i64)R11+(i64)R12*8-8));
	asu64(R12) = params;
	R13 = 1;
	asi64(R12) = *toi64p(((i64)R12+(i64)R13*8-8));
	asu64(R13) = fnaddr;
	asi64(R1) = ((F13)R13)(asi64(R12), asi64(R11), asi64(R10), asi64(R9), asi64(R8), asi64(R7), asi64(R6), asi64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L877;
	goto L878;
L880:
	msysc_m$print_startcon();
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/int unsupported # of params");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L878:
	R1 = 0;
	goto L877;
L877:
	return asi64(R1);
}

static i64 mwindllc_calldll_creal(u64 fnaddr, u64 params, i64 nparams) {
    u64 R1, R2, R3, R4, R5; 
	r64 x;
	asi64(R1) = nparams;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L895;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L896;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L897;
	goto L898;
L895:
	asu64(R1) = fnaddr;
	asr64(R1) = ((F14)R1)();
	R1 = toi64(asr64(R1));
	goto L893;
	goto L894;
L896:
	asu64(R1) = params;
	R2 = 4;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = params;
	R3 = 3;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asr64(R2) = tor64(asi64(R2));
	asu64(R3) = params;
	R4 = 2;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asr64(R3) = tor64(asi64(R3));
	asu64(R4) = params;
	R5 = 1;
	asi64(R4) = *toi64p(((i64)R4+(i64)R5*8-8));
	asr64(R4) = tor64(asi64(R4));
	mwindllc_os_dummycall(asr64(R4), asr64(R3), asr64(R2), asr64(R1));
	asu64(R1) = params;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = fnaddr;
	asr64(R1) = ((F15)R2)(asi64(R1));
	x = asr64(R1);
	goto L894;
L897:
	asu64(R1) = params;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = params;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = fnaddr;
	asr64(R1) = ((F16)R3)(asi64(R2), asi64(R1));
	x = asr64(R1);
	goto L894;
L898:
	msysc_m$print_startcon();
	R1 = tou64("calldll/c/real too many params");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L894:
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	goto L893;
L893:
	return asi64(R1);
}

static void mwindllc_os_dummycall(r64 a, r64 b, r64 c, r64 d) {
	return;
}

static u64 pc_api_pcl_start(u64 name, i64 nunits) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_pcldone;
	if (!asu8(R1)) goto L902;
	R1 = tou64("PCL start?");
	pc_api_pclerror(asu64(R1));
L902:
	asu64(R1) = name;
	if (!asu64(R1)) goto L904;
	R1 = 9;
	asu64(R2) = name;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	pc_decls_currprog = asu64(R1);
L904:
	asi64(R1) = pc_api_initpcalloc;
	pc_api_pcalloc = asi64(R1);
	asi64(R1) = nunits;
	if (!asi64(R1)) goto L906;
	asi64(R1) = nunits;
	R2 = 9;
	asi64(R1) *= asi64(R2);
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	nunits = asi64(R1);
	goto L908;
L907:
	R1 = 2;
	R2 = (u64)&pc_api_pcalloc;
	*toi64p(R2) *= asi64(R1);
L908:
	asi64(R1) = pc_api_pcalloc;
	asi64(R2) = nunits;
	if (asi64(R1) < asi64(R2)) goto L907;
L906:
	asi64(R1) = pc_api_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pc_api_pcstart = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	asi64(R2) = pc_api_pcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	pc_api_pcend = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	pc_api_pccurr = asu64(R1);
	R1 = 0;
	pc_api_pcfixed = asu8(R1);
	R1 = 0;
	pc_api_pcseqno = asi64(R1);
	R1 = 0;
	pc_api_pcneedfntable = asi64(R1);
	R1 = 0;
	pc_api_mlabelno = asi64(R1);
	asu64(R1) = pc_decls_currprog;
	goto L900;
L900:
	return asu64(R1);
}

static void pc_api_pcl_end() {
    u64 R1, R2; 
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) < asu64(R2)) goto L912;
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 136;
	if (asi64(R1) == asi64(R2)) goto L912;
	R1 = 0;
	R2 = 136;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L912:
	R1 = 1;
	pc_decls_pcldone = asu8(R1);
	return;
}

static u64 pc_api_pcl_writepcl(u64 filename) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_diags_dummy_writeallpcl();
	d = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L915;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L917;
	msysc_m$print_startcon();
	R1 = tou64("Writing PCL");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L917:
	asu64(R1) = d;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = tou64("");
	goto L914;
L915:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L914:
	goto L913;
L913:
	return asu64(R1);
}

static u64 pc_api_pcl_writepst(u64 filename) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_diags_dummy_writepst();
	d = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L920;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L922;
	msysc_m$print_startcon();
	R1 = tou64("Writing PST");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L922:
	asu64(R1) = d;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = filename;
	asi64(R1) = mlib_writefile(asu64(R3), asu64(R2), asi64(R1));
	R1 = tou64("");
	goto L919;
L920:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L919:
	goto L918;
L918:
	return asu64(R1);
}

static void pc_api_pcl_genmcl() {
	mc_genmcl_dummy_genmcl();
	return;
}

static void pc_api_pcl_genss(i64 obj) {
    u64 R1; 
	mc_genmcl_dummy_genmcl();
	asi64(R1) = obj;
	mc_genss_dummy_genss(asi64(R1));
	return;
}

static u64 pc_api_pcl_writess(u64 filename, i64 obj) {
    u64 R1, R2; 
	u64 ssstr;
	u64 f;
	mc_genmcl_dummy_genmcl();
	asi64(R1) = obj;
	mc_genss_dummy_genss(asi64(R1));
	asi64(R1) = obj;
	asi64(R1) = !asi64(R1);
	asu64(R1) = mc_writess_dummy_writessdata(asi64(R1));
	ssstr = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L927;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = ssstr;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = ssstr;
	mlib_gs_free(asu64(R1));
	R1 = 0;
	goto L926;
L927:
	asu64(R1) = ssstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L926:
	goto L925;
L925:
	return asu64(R1);
}

static u64 pc_api_pcl_writeasm(u64 filename, i64 atype) {
    u64 R1, R2; 
	u64 asmstr;
	u64 f;
	asi64(R1) = pc_decls_assemtype;
	R2 = 1297301838;
	if (asi64(R1) != asi64(R2)) goto L930;
	R1 = 2;
	pc_api_phighmem = asu8(R1);
L930:
	mc_genmcl_dummy_genmcl();
	asu64(R1) = mc_writeasm_dummy_getassemstr();
	asmstr = asu64(R1);
	asu64(R1) = filename;
	if (!asu64(R1)) goto L932;
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L934;
	msysc_m$print_startcon();
	R1 = tou64("Writing");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L934:
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = asmstr;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	asu64(R1) = asmstr;
	mlib_gs_free(asu64(R1));
	R1 = 0;
	goto L931;
L932:
	asu64(R1) = asmstr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L931:
	goto L928;
L928:
	return asu64(R1);
}

static void pc_api_pcl_writeobj(u64 filename) {
    u64 R1, R2; 
	i64 tt;
	mc_genmcl_dummy_genmcl();
	R1 = 1;
	mc_genss_dummy_genss(asi64(R1));
	R1 = 0;
	pc_api_phighmem = asu8(R1);
	msysc_m$print_startcon();
	R1 = tou64("PHIGHMEM=");
	msysc_m$print_str_nf(asu64(R1));
	asu8(R1) = pc_api_phighmem;
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mwindows_os_clock();
	tt = asi64(R1);
	asu64(R1) = filename;
	mc_writeobj_dummy_writecoff(asu64(R1));
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_objtime = asi64(R1);
	return;
}

static void pc_api_pcl_writedll(u64 filename) {
    u64 R1, R2; 
	i64 tt;
	R1 = 2;
	pc_api_phighmem = asu8(R1);
	mc_genmcl_dummy_genmcl();
	R1 = 0;
	mc_genss_dummy_genss(asi64(R1));
	asi64(R1) = mwindows_os_clock();
	tt = asi64(R1);
	R1 = 1;
	asu64(R2) = filename;
	mc_writeexe_dummy_writeexe(asu64(R2), asi64(R1));
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_exetime = asi64(R1);
	return;
}

static void pc_api_pcl_writeexe(u64 filename) {
    u64 R1, R2; 
	i64 tt;
	mc_genmcl_dummy_genmcl();
	R1 = 0;
	mc_genss_dummy_genss(asi64(R1));
	asi64(R1) = mwindows_os_clock();
	tt = asi64(R1);
	R1 = 0;
	asu64(R2) = filename;
	mc_writeexe_dummy_writeexe(asu64(R2), asi64(R1));
	asi64(R1) = mwindows_os_clock();
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_exetime = asi64(R1);
	return;
}

static void pc_api_pcl_writemx(u64 filename) {
    u64 R1; 
	mc_genmcl_dummy_genmcl();
	R1 = 0;
	mc_genss_dummy_genss(asi64(R1));
	asu64(R1) = filename;
	mx_run_dummy_writemcx(asu64(R1));
	return;
}

static void pc_api_pcl_exec() {
    u64 R1, R2; 
	mc_genmcl_dummy_genmcl();
	R1 = 0;
	mc_genss_dummy_genss(asi64(R1));
	asi64(R1) = pc_decls_pcmdskip;
	R2 = tou64("dummy");
	mx_run_dummy_runlibfile(asu64(R2), asi64(R1));
	return;
}

static void pc_api_pcl_setflags(i64 highmem, i64 verbose, i64 shortnames) {
    u64 R1, R2; 
	asi64(R1) = highmem;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L942;
	asi64(R1) = highmem;
	pc_api_phighmem = asu8(R1);
L942:
	asi64(R1) = verbose;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L944;
	asi64(R1) = verbose;
	pc_decls_pverbose = asu8(R1);
L944:
	asi64(R1) = shortnames;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L946;
	asi64(R1) = shortnames;
	pc_api_fpshortnames = asu8(R1);
L946:
	return;
}

static void pc_api_extendpclblock() {
    u64 R1, R2, R3; 
	i64 newpcalloc;
	i64 lengthused;
	u64 newpcstart;
	asi64(R1) = pc_api_pcalloc;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	newpcalloc = asi64(R1);
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcstart;
	asi64(R1) -= asi64(R2);
    asi64(R1) /= 32;
	R2 = 1;
	asi64(R1) += asi64(R2);
	lengthused = asi64(R1);
	R1 = 32;
	asi64(R2) = newpcalloc;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	newpcstart = asu64(R1);
	asi64(R1) = lengthused;
	R2 = 32;
	asu64(R1) *= asu64(R2);
	asu64(R2) = pc_api_pcstart;
	asu64(R3) = newpcstart;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = newpcalloc;
	asi64(R2) = lengthused;
	asi64(R1) -= asi64(R2);
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = newpcstart;
	asi64(R3) = lengthused;
	R2 += (i64)R3*32;
	mlib_pcm_clearmem(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	asu64(R2) = pc_api_pccurr;
	asu64(R3) = pc_api_pcstart;
	asi64(R2) -= asi64(R3);
    asi64(R2) /= 32;
	R1 += (i64)R2*32;
	pc_api_pccurr = asu64(R1);
	asu64(R1) = newpcstart;
	asi64(R2) = newpcalloc;
	R1 += (i64)R2*32;
	R2 = 8;
	R1 -= (i64)R2*32;
	pc_api_pcend = asu64(R1);
	asi64(R1) = pc_api_pcalloc;
	R2 = 32;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc_api_pcstart;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = newpcstart;
	pc_api_pcstart = asu64(R1);
	asi64(R1) = newpcalloc;
	pc_api_pcalloc = asi64(R1);
	return;
}

static u64 pc_api_newpcl() {
    u64 R1, R2, R3, R4; 
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcend;
	if (asu64(R1) < asu64(R2)) goto L950;
	pc_api_extendpclblock();
L950:
	R1 = (u64)&pc_api_pccurr;
	(*tou64p(R1)) += 32;
	asi64(R1) = pc_decls_mmpos;
	asu64(R2) = pc_api_pccurr;
	R3 = 24;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&pc_api_pclseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = pc_api_pccurr;
	goto L948;
L948:
	return asu64(R1);
}

static void pc_api_pc_gen(i64 opcode, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L953;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L953:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void pc_api_pc_genix(i64 opcode, i64 scale, i64 offset) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = scale;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_genx(i64 opcode, i64 x, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L957;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L957:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_genxy(i64 opcode, i64 x, i64 y, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L960;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L960:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = y;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_gencond(i64 opcode, i64 cond, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L963;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
L963:
	asi64(R1) = opcode;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = cond;
	asu64(R2) = p;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 pc_api_genint(i64 a) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = a;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L964;
L964:
	return asu64(R1);
}

static u64 pc_api_genreal(r64 x, i64 mode) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asr64(R1) = x;
	asu64(R2) = p;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L967;
	R1 = 5;
	goto L966;
L967:
	R1 = 6;
L966:
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L965;
L965:
	return asu64(R1);
}

static u64 pc_api_genrealimm(r64 x, i64 mode) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asr64(R1) = x;
	asu64(R2) = p;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	asi64(R1) = mode;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L970;
	R1 = 10;
	goto L969;
L970:
	R1 = 11;
L969:
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L968;
L968:
	return asu64(R1);
}

static u64 pc_api_genstring(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 7;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L971;
L971:
	return asu64(R1);
}

static u64 pc_api_genpcstrimm(u64 s) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L972;
L972:
	return asu64(R1);
}

static u64 pc_api_genlabel(i64 a) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asi64(R1) = a;
	asu64(R2) = p;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L973;
L973:
	return asu64(R1);
}

static u64 pc_api_genmem(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L974;
L974:
	return asu64(R1);
}

static u64 pc_api_genmemaddr(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 2;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L975;
L975:
	return asu64(R1);
}

static u64 pc_api_gendata(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 12;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	asu64(R2) = p;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L976;
L976:
	return asu64(R1);
}

static void pc_api_gencomment(u64 s) {
    u64 R1, R2; 
	asu8(R1) = pc_decls_fregoptim;
	if (asu8(R1)) goto L980;
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L979;
L980:
	goto L977;
L979:
	asu64(R1) = s;
	asu64(R1) = pc_api_genpcstrimm(asu64(R1));
	R2 = 135;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L977:
	return;
}

static u64 pc_api_genname(u64 s) {
    u64 R1, R2; 
	R1 = 8;
	asu64(R2) = s;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L981;
L981:
	return asu64(R1);
}

static u64 pc_api_gennameaddr(u64 s) {
    u64 R1, R2; 
	R1 = 8;
	asu64(R2) = s;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	goto L982;
L982:
	return asu64(R1);
}

static u64 pc_api_genassem(u64 code) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = pc_api_newpcl();
	p = asu64(R1);
	asu64(R1) = code;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 9;
	asu64(R2) = p;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L983;
L983:
	return asu64(R1);
}

static u64 pc_api_strpmode(i64 mode, i64 size) {
    u64 R1, R2; 
	R1 = tou64("");
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L986;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L987;
	goto L988;
L986:
	R1 = tou64("mem:");
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	asi64(R2) = size;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&pc_api_strpmode_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_strpmode_str;
	goto L985;
L987:
	R1 = tou64("---");
	goto L985;
L988:
	R1 = (u64)&pc_tables_pstdnames;
	asi64(R2) = mode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
L985:
	goto L984;
L984:
	return asu64(R1);
}

static void pc_api_pc_setmode(i64 m, i64 size) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = m;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = size;
	if (!asi64(R1)) goto L991;
	asi64(R1) = size;
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L990;
L991:
	R1 = (u64)&pc_tables_psize;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L990:
	R1 = (u64)&pc_tables_pclhastype;
	asu64(R2) = pc_api_pccurr;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L993;
	asu64(R1) = pc_api_pccurr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L993:
	return;
}

static void pc_api_pc_setmode2(i64 m) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = m;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	return;
}

static void pc_api_pc_setxy(i64 x, i64 y) {
    u64 R1, R2, R3; 
	asi64(R1) = x;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = y;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setscaleoff(i64 scale, i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = scale;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setoffset(i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_addoffset(i64 offset) {
    u64 R1, R2, R3; 
	asi64(R1) = offset;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	return;
}

static void pc_api_pc_setincr(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setnargs(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setnvariadics(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_pc_setalign(i64 n) {
    u64 R1, R2, R3; 
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void pc_api_perror(u64 mess) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = mess;
	pc_api_perror_s(asu64(R2), asu64(R1));
	return;
}

static void pc_api_perror_s(u64 mess, u64 param) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PCL error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = param;
	if (!asu64(R1)) goto L1006;
	msysc_m$print_startcon();
	R1 = tou64(":");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L1006:
	R1 = 1;
	exit(R1);
	return;
}

static u64 pc_api_getbasename(u64 s) {
    u64 R1, R2; 
	u64 t;
	asu64(R1) = s;
	asu64(R2) = s;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	t = asu64(R1);
	goto L1009;
L1008:
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
L1009:
	asu64(R1) = t;
	asu64(R2) = s;
	if (asu64(R1) <= asu64(R2)) goto L1011;
	asu64(R1) = t;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L1008;
L1011:
	asu64(R1) = t;
	goto L1007;
L1007:
	return asu64(R1);
}

static void pc_api_pclerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PCL Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void pc_api_pc_addsymbol(u64 d) {
    u64 R1, R2, R3; 
	asu64(R1) = pc_decls_psymboltable;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1015;
	asu64(R1) = d;
	R2 = R1;
	pc_decls_psymboltablex = asu64(R2);
	pc_decls_psymboltable = asu64(R1);
	goto L1014;
L1015:
	asu64(R1) = d;
	asu64(R2) = pc_decls_psymboltablex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	pc_decls_psymboltablex = asu64(R1);
L1014:
	return;
}

static u64 pc_api_pc_makesymbol(u64 s, i64 id) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&pc_api_stseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = id;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1018;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1019;
	goto L1020;
L1018:
	R1 = 1;
	asu64(R2) = d;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1017;
L1019:
	R1 = 1;
	asu64(R2) = d;
	R3 = 81;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 2;
	id = asi64(R1);
	goto L1017;
L1020:
L1017:
	asi64(R1) = id;
	asu64(R2) = d;
	R3 = 72;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = id;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1023;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1022;
L1023:
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1021;
L1022:
	asi64(R1) = id;
	if (!asi64(R1)) goto L1024;
	asu64(R1) = d;
	pc_api_pc_addsymbol(asu64(R1));
L1024:
L1021:
	asu64(R1) = d;
	goto L1016;
L1016:
	return asu64(R1);
}

static u64 pc_api_getfullname(u64 d, i64 backtick) {
    u64 R1, R2, R3; 
	i64 n;
	u64 e;
	R1 = 0;
	n = asi64(R1);
	asu64(R1) = d;
	e = asu64(R1);
	R1 = 0;
	R2 = (u64)&pc_api_getfullname_str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L1027;
	R1 = tou64("`");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L1027:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1029;
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L1031;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64("*");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1030;
L1031:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L1030:
	R1 = (u64)&pc_api_getfullname_str;
	goto L1025;
L1029:
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1034;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1033;
L1034:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_getfullname_str;
	goto L1025;
L1033:
	asi64(R1) = backtick;
	if (!asi64(R1)) goto L1036;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&pc_api_getfullname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L1035;
L1036:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L1035:
	goto L1025;
L1025:
	return asu64(R1);
}

static void pc_api_pcerrorstop(u64 filename, i64 lineno) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 1;
	exit(R1);
	return;
}

static void pc_api_pc_addplib(u64 name) {
    u64 R1, R2, R3; 
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L1040;
	R1 = tou64("Too many libs");
	pc_api_perror(asu64(R1));
L1040:
	R1 = tou64("");
	asu64(R2) = name;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&pc_decls_plibfiles;
	R3 = (u64)&pc_decls_nplibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	return;
}

static void pc_api_pc_defproc(u64 d, i64 mode, i64 isentry, i64 threaded) {
    u64 R1, R2, R3; 
	asu64(R1) = pc_decls_currfunc;
	if (!asu64(R1)) goto L1043;
	R1 = tou64("Nested proc");
	pc_api_pclerror(asu64(R1));
L1043:
	asu64(R1) = d;
	asu64(R1) = pc_api_genmem(asu64(R1));
	asi64(R2) = threaded;
	if (!asi64(R2)) goto L1045;
	R2 = 121;
	goto L1044;
L1045:
	R2 = 120;
L1044:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1047;
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	mode = asi64(R1);
L1047:
	R1 = 0;
	asi64(R2) = mode;
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1049;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Dupl proc:");
	asu64(R1) = pc_api_addstr(asu64(R2), asu64(R1));
	pc_api_pclerror(asu64(R1));
L1049:
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pc_decls_entryproc;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1051;
	asi64(R1) = isentry;
	if (!asi64(R1)) goto L1051;
	asu64(R1) = d;
	pc_decls_entryproc = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 83;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1051:
	asu64(R1) = d;
	pc_decls_currfunc = asu64(R1);
	return;
}

static void pc_api_pc_setimport(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	pc_decls_currfunc = asu64(R1);
	return;
}

static void pc_api_pc_addparam(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = pc_decls_currfunc;
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L1055;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1055:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1057;
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1056;
L1057:
	goto L1059;
L1058:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L1059:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1058;
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1056:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1062;
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1062:
	asu64(R1) = pc_decls_currfunc;
	R2 = 112;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	return;
}

static void pc_api_pc_addlocal(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	asu64(R1) = pc_decls_currfunc;
	p = asu64(R1);
	asu64(R1) = p;
	if (asu64(R1)) goto L1065;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1065:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1067;
	asu64(R1) = d;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1066;
L1067:
	goto L1069;
L1068:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L1069:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1068;
	asu64(R1) = d;
	asu64(R2) = q;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1066:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1072;
	asu64(R1) = pc_decls_currfunc;
	asu64(R2) = d;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1072:
	asu64(R1) = pc_decls_currfunc;
	R2 = 114;
	R1 += (i64)R2;
	(*toi16p(R1)) += 1;
	return;
}

static void pc_api_pc_endproc() {
    u64 R1, R2; 
	asu64(R1) = pc_decls_currfunc;
	if (asu64(R1)) goto L1075;
	R1 = tou64("No proc");
	pc_api_pclerror(asu64(R1));
L1075:
	R1 = 0;
	R2 = 122;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	pc_decls_currfunc = asu64(R1);
	return;
}

static u64 pc_api_addstr(u64 s, u64 t) {
    u64 R1, R2; 
	asu64(R1) = s;
	R2 = (u64)&pc_api_addstr_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = t;
	R2 = (u64)&pc_api_addstr_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&pc_api_addstr_str;
	goto L1076;
L1076:
	return asu64(R1);
}

static void pc_api_merror(u64 mess, u64 param) {
    u64 R1, R2, R3, R4; 
	i64 lineno;
	u64 filename;
	u64 sourceline;
	asu64(R1) = pc_decls_igetmsourceinfo;
	if (!asu64(R1)) goto L1079;
	R1 = (u64)&sourceline;
	R2 = (u64)&filename;
	asi64(R3) = pc_decls_mmpos;
	asu64(R4) = pc_decls_igetmsourceinfo;
	asi64(R1) = ((F17)R4)(asi64(R3), asu64(R2), asu64(R1));
	lineno = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("LINENO=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("FILENAME=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L1078;
L1079:
	R1 = 0;
	lineno = asi64(R1);
	R1 = tou64("?");
	filename = asu64(R1);
L1078:
	asu64(R1) = pc_decls_currfunc;
	if (!asu64(R1)) goto L1081;
	msysc_m$print_startcon();
	R1 = tou64("Proc:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc_decls_currfunc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1081:
	msysc_m$print_startcon();
	R1 = tou64("MCL Error: # (#) on Line: # in #, PCL:#");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = pc_decls_ppseqno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = lineno;
	asu64(R2) = filename;
	pc_api_pcerrorstop(asu64(R2), asi64(R1));
	return;
}

static u64 pc_api_pc_duplpst(u64 d) {
    u64 R1, R2, R3; struct $B21 R1_B21; 
	u64 e;
	R1 = 128;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	e = asu64(R1);
	asu64(R1) = d;
	(R1_B21) = *(struct $B21*)(R1);
	asu64(R2) = e;
	*(struct $B21*)(R2) = (R1_B21);
	R1 = (u64)&pc_api_stseqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = e;
	R3 = 120;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 0;
	asu64(R2) = e;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	goto L1082;
L1082:
	return asu64(R1);
}

static void pc_api_pcl_cmdskip(i64 cmdskip, u64 dcmdskip) {
    u64 R1; 
	asi64(R1) = cmdskip;
	pc_decls_pcmdskip = asi64(R1);
	return;
}

static i64 pc_api_convertstring(u64 s, u64 t) {
    u64 R1, R2, R3; 
	i64 c;
	u64 t0;
	struct $B3 str;
	asu64(R1) = t;
	t0 = asu64(R1);
	goto L1086;
L1085:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1089;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1090;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L1091;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1092;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L1093;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1094;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1094;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1094;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L1094;
	goto L1095;
L1089:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 34;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1090:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 110;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1091:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 114;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1092:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 116;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1093:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1094:
	R1 = 60;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asi64(R1) = c;
	R2 = 10;
	asi64(R1) %= asi64(R2);
	R2 = 48;
	asu64(R1) += asu64(R2);
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 62;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1088;
L1095:
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) < asi64(R2)) goto L1097;
	R2 = 126;
	if (asi64(R1) > asi64(R2)) goto L1097;
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L1096;
L1097:
	R1 = 92;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 120;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("z2h");
	asi64(R2) = c;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L1096:
L1088:
L1086:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	if (asi64(R1)) goto L1085;
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = t;
	asu64(R2) = t0;
	asi64(R1) -= asi64(R2);
	goto L1084;
L1084:
	return asi64(R1);
}

static void pc_diags_dummy_pshowlogfile() {
	return;
}

static void pc_diags_dummy_strpcl(u64 p) {
	return;
}

static u64 pc_diags_dummy_stropnd(u64 p) {
    u64 R1; 
	R1 = 0;
	goto L1100;
L1100:
	return asu64(R1);
}

static u64 pc_diags_dummy_strpclstr(u64 p, i64 buffsize) {
    u64 R1; 
	R1 = 0;
	goto L1101;
L1101:
	return asu64(R1);
}

static void pc_diags_dummy_writepcl(u64 p) {
	return;
}

static u64 pc_diags_dummy_writeallpcl() {
    u64 R1; 
	R1 = tou64("dummy diags");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L1103;
L1103:
	return asu64(R1);
}

static u64 pc_diags_dummy_writepst() {
    u64 R1; 
	asu64(R1) = pc_diags_dummy_writeallpcl();
	goto L1104;
L1104:
	return asu64(R1);
}

static void pc_reduce_pcl_reducetest() {
    u64 R1, R2, R3, R4; struct $B18 R1_B18; 
	i64 nn;
	i64 seqno;
	i64 lab;
	i64 lab2;
	i64 nargs;
	u64 pc;
	u64 newpc;
	u64 pcnext;
	u64 pcnext2;
	u64 pcproc;
	u64 labelmap;
	u64 pdef;
	struct $B16 callstack;
	i64 ncall;
	i64 nprocs;
	i64 nleaf;
	i64 nallparams;
	i64 nalllocals;
	i64 offset;
	i64 av_1;
	R1 = 0;
	nprocs = asi64(R1);
	R1 = 0;
	nleaf = asi64(R1);
	R1 = 0;
	nallparams = asi64(R1);
	R1 = 0;
	nalllocals = asi64(R1);
	asu64(R1) = pc_api_pccurr;
	asu64(R2) = pc_api_pcstart;
	asi64(R1) -= asi64(R2);
    asi64(R1) /= 32;
	R2 = 1;
	asi64(R1) += asi64(R2);
	nn = asi64(R1);
	asu64(R1) = pc_api_pcstart;
	pc = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	labelmap = asu64(R1);
	goto L1109;
L1106:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1111;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1112;
	goto L1113;
L1111:
	goto L1110;
L1112:
	asu64(R1) = pc_api_icheckasmlabel;
	if (!asu64(R1)) goto L1115;
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pc_api_icheckasmlabel;
	asi64(R1) = ((F1)R2)(asu64(R1));
	lab = asi64(R1);
	asi64(R1) = lab;
	if (!asi64(R1)) goto L1117;
	asu64(R1) = labelmap;
	asi64(R2) = lab;
	R1 += (i64)R2*2-2;
	(*tou16p(R1)) += 1;
L1117:
L1115:
	goto L1110;
L1113:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1119;
	asu64(R1) = labelmap;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	R1 += (i64)R2*2-2;
	(*tou16p(R1)) += 1;
L1119:
L1110:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1109:
	asu64(R1) = pc;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1106;
// pc_reduce.pcl_reducetest.skip:
	asu64(R1) = pc_api_pcstart;
	pc = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	R2 = 1;
	R1 -= (i64)R2*32;
	newpc = asu64(R1);
	R1 = 0;
	seqno = asi64(R1);
	asi64(R1) = nn;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1123;
L1121:
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	pcnext = asu64(R1);
	R1 = (u64)&pc_tables_pclargs;
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	nargs = asi64(R2);
	if (!asi64(R1)) goto L1125;
	asi64(R1) = nargs;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L1127;
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	nargs = asi64(R1);
L1127:
	asu64(R1) = pc_decls_pinfo;
	R2 = 4;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = nargs;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 4;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1125:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1129;
	asu64(R1) = pc_decls_pinfo;
	if (!asu64(R1)) goto L1129;
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1129;
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1129:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 135;
	if (asi64(R1) == asi64(R2)) goto L1131;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1132;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1133;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1133;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L1134;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L1134;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L1134;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L1134;
	R2 = 131;
	if (asi64(R1) == asi64(R2)) goto L1135;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L1136;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1137;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1138;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1138;
	R2 = 114;
	if (asi64(R1) == asi64(R2)) goto L1139;
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L1140;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1141;
	goto L1142;
L1131:
	goto L1130;
L1132:
	asu64(R1) = labelmap;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu16(R1) = *tou16p(((i64)R1+(i64)R2*2-2));
	if (!asu16(R1)) goto L1144;
	goto L1142;
	goto L1142;
L1144:
	goto L1130;
L1133:
	R1 = (u64)&nprocs;
	(*toi64p(R1)) += 1;
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdef = asu64(R1);
	asu64(R1) = newpc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pdef;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 8;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_decls_pinfo = asu64(R1);
	asu64(R1) = pc_decls_pinfo;
	asu64(R2) = pdef;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = pc_decls_pinfo;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pdef;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&nallparams;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pdef;
	R2 = 114;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&nalllocals;
	*toi64p(R2) += asi64(R1);
	R1 = 0;
	ncall = asi64(R1);
	asu64(R1) = newpc;
	R2 = 1;
	R1 += (i64)R2*32;
	pcproc = asu64(R1);
	goto L1142;
	goto L1142;
	goto L1130;
L1134:
	R1 = 0;
	asu64(R2) = pc_decls_pinfo;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&ncall;
	(*toi64p(R1)) -=1;
	goto L1142;
	goto L1142;
	goto L1130;
L1135:
	R1 = (u64)&newpc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	(R1_B18) = *(struct $B18*)(R1);
	asu64(R2) = newpc;
	*(struct $B18*)(R2) = (R1_B18);
	R1 = (u64)&seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = newpc;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = newpc;
	R2 = (u64)&callstack;
	R3 = (u64)&ncall;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L1130;
L1136:
	asu64(R1) = pc_decls_pinfo;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1146;
	R1 = (u64)&nleaf;
	(*toi64p(R1)) += 1;
L1146:
	R1 = 0;
	pc_decls_pinfo = asu64(R1);
	goto L1142;
	goto L1142;
	goto L1130;
L1137:
	R1 = 1;
	asu64(R2) = pc_decls_pinfo;
	R3 = 5;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1142;
	goto L1142;
	goto L1130;
L1138:
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L1148;
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1148;
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = newpc;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1150;
	R1 = 3;
	goto L1149;
L1150:
	R1 = 6;
L1149:
	asu64(R2) = newpc;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1147;
L1148:
	goto L1142;
	goto L1142;
L1147:
	goto L1130;
L1139:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 113;
	if (asi64(R1) != asi64(R2)) goto L1152;
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = pcnext;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asu64(R1) != asu64(R2)) goto L1152;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1151;
L1152:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1154;
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L1153;
L1154:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = pcnext;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L1151;
L1153:
	goto L1142;
	goto L1142;
L1151:
	goto L1130;
L1140:
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1157;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1157;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1156;
L1157:
	asu64(R1) = newpc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	if (asi64(R1) != asi64(R2)) goto L1156;
	goto L1155;
L1156:
	goto L1142;
	goto L1142;
L1155:
	goto L1130;
L1141:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1159;
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = newpc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L1160;
	R2 = 57;
	if (asi64(R1) != asi64(R2)) goto L1160;
	R1 = 1;
	goto L1161;
L1160:
	R1 = 0;
L1161:
	asu16(R1) = !!asi64(R1);
	if (!asu16(R1)) goto L1159;
	asu64(R1) = pc;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = pcnext;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = pcnext;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = newpc;
	R3 = 20;
	R2 += (i64)R3;
	*toi32p(R2) += asi32(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1158;
L1159:
	asu64(R1) = pcnext;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1162;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1158;
L1162:
	goto L1142;
	goto L1142;
L1158:
	goto L1130;
L1142:
	R1 = (u64)&newpc;
	(*tou64p(R1)) += 32;
	asu64(R1) = pc;
	(R1_B18) = *(struct $B18*)(R1);
	asu64(R2) = newpc;
	*(struct $B18*)(R2) = (R1_B18);
	R1 = (u64)&seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = newpc;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 8;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	asu64(R1) = newpc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1164;
	asu64(R1) = newpc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1167;
	asu64(R1) = newpc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (asi32(R1)) goto L1166;
L1167:
	R1 = 1;
	asu64(R2) = newpc;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 88;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1166:
L1164:
L1130:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	if (--asi64(av_1)) goto L1121;
L1123:
	asu64(R1) = newpc;
	pc_api_pccurr = asu64(R1);
	asi64(R1) = pc_api_mlabelno;
	asu64(R2) = labelmap;
	mlib_pcm_free(asu64(R2), asi64(R1));
	return;
}

static i64 pc_run_dispatch_loop(u64 pcentry, i64 cmain) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 stack;
	u64 pc;
	i64 sp;
	i64 fp;
	i64 a;
	u64 ptr;
	i64 b;
	u64 ptrb;
	i64 n;
	u64 d;
	struct $B74 callstack;
	struct $B75 callstackst;
	i64 callsp;
	struct $B16 str;
	i64 mag;
	i64 oldsp;
	i64 ncmd;
	u64 cmd;
	i64 lastpos;
	i64 count;
	i64 av_1;
	i64 av_2;
	asu64(R1) = pcentry;
	pc = asu64(R1);
	R1 = 0;
	sp = asi64(R1);
	R1 = 0;
	fp = asi64(R1);
	R1 = 0;
	callsp = asi64(R1);
	R1 = 560000;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	stack = asu64(R1);
	asi64(R1) = cmain;
	if (!asi64(R1)) goto L1170;
	asi64(R1) = msysc_ncmdparams;
	ncmd = asi64(R1);
	asu64(R1) = msysc_cmdparams;
	cmd = asu64(R1);
	asi64(R1) = ncmd;
	asi64(R2) = pc_decls_pcmdskip;
	asi64(R1) -= asi64(R2);
	ncmd = asi64(R1);
	asu64(R1) = cmd;
	asi64(R2) = pc_decls_pcmdskip;
	R3 = 8;
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	cmd = asu64(R1);
	asu64(R1) = cmd;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = ncmd;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 0;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1170:
	R1 = 0;
	lastpos = asi64(R1);
	R1 = 0;
	count = asi64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1172;
	R1 = tou64("<Fn ptr>");
	R2 = (u64)&pc_run_emptyst;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1172:
L1173:
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L1177;
	case 1: goto L1178;
	case 2: goto L1181;
	case 3: goto L1182;
	case 4: goto L1183;
	case 5: goto L1190;
	case 6: goto L1191;
	case 7: goto L1176;
	case 8: case 9: goto L1192;
	case 10: goto L1193;
	case 11: goto L1194;
	case 12: goto L1195;
	case 13: goto L1197;
	case 14: goto L1198;
	case 15: goto L1199;
	case 16: goto L1200;
	case 17: goto L1203;
	case 18: case 21: goto L1204;
	case 19: goto L1229;
	case 20: goto L1219;
	case 22: goto L1237;
	case 23: goto L1224;
	case 24: goto L1242;
	case 25: goto L1243;
	case 26: goto L1244;
	case 27: goto L1252;
	case 28: goto L1255;
	case 29: goto L1258;
	case 30: goto L1259;
	case 31: goto L1260;
	case 32: goto L1267;
	case 33: goto L1268;
	case 34: goto L1271;
	case 35: goto L1274;
	case 36: goto L1277;
	case 37: case 38: goto L1280;
	case 39: goto L1283;
	case 40: goto L1284;
	case 41: goto L1285;
	case 42: goto L1286;
	case 43: goto L1287;
	case 44: goto L1290;
	case 45: goto L1293;
	case 46: goto L1296;
	case 47: goto L1297;
	case 48: goto L1300;
	case 49: goto L1303;
	case 50: goto L1304;
	case 51: goto L1305;
	case 52: goto L1306;
	case 53: goto L1307;
	case 54: goto L1308;
	case 55: goto L1311;
	case 56: goto L1315;
	case 57: goto L1319;
	case 58: goto L1320;
	case 59: goto L1321;
	case 60: goto L1322;
	case 61: goto L1325;
	case 62: goto L1328;
	case 63: goto L1329;
	case 64: goto L1330;
	case 65: goto L1331;
	case 66: goto L1332;
	case 67: goto L1335;
	case 68: goto L1336;
	case 69: goto L1337;
	case 70: goto L1338;
	case 71: goto L1339;
	case 72: goto L1340;
	case 73: goto L1341;
	case 74: goto L1342;
	case 75: goto L1343;
	case 76: goto L1344;
	case 77: goto L1345;
	case 78: goto L1346;
	case 79: goto L1347;
	case 80: goto L1348;
	case 81: goto L1349;
	case 82: goto L1350;
	case 83: goto L1353;
	case 84: goto L1354;
	case 85: goto L1355;
	case 86: goto L1356;
	case 87: goto L1357;
	case 88: goto L1358;
	case 89: goto L1359;
	case 90: goto L1360;
	case 91: goto L1363;
	case 92: goto L1366;
	case 93: case 94: goto L1369;
	case 95: goto L1372;
	case 96: goto L1373;
	case 97: goto L1374;
	case 98: goto L1375;
	case 99: goto L1376;
	case 100: goto L1377;
	case 101: goto L1380;
	case 102: goto L1384;
	case 103: goto L1388;
	case 104: goto L1389;
	case 105: goto L1390;
	case 106: goto L1391;
	case 107: goto L1392;
	case 108: goto L1393;
	case 109: goto L1394;
	case 110: goto L1395;
	case 111: goto L1396;
	case 112: goto L1399;
	case 113: goto L1400;
	case 114: goto L1401;
	case 115: goto L1402;
	case 116: goto L1403;
	case 117: goto L1404;
	case 118: goto L1405;
	case 119: goto L1406;
	case 120: goto L1407;
	case 121: goto L1413;
	case 122: goto L1414;
	case 123: goto L1415;
	case 124: goto L1416;
	case 125: goto L1417;
	case 126: goto L1428;
	case 127: goto L1418;
	case 128: goto L1419;
	case 129: goto L1420;
	case 130: goto L1421;
	case 131: goto L1422;
	case 132: goto L1423;
	case 133: goto L1424;
	case 134: goto L1425;
	case 135: goto L1426;
	case 136: goto L1427;
	default: goto L1176;
    };
// SWITCH
L1177:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1178:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1180;
	asu64(R1) = pc;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L1179;
L1180:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1179:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1181:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1182:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1183:
	asu64(R1) = pc;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1185;
	goto L1186;
L1185:
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1188;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptr = asu64(R1);
	goto L1187;
L1188:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1189;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1189;
	asu64(R1) = stack;
	asi64(R2) = fp;
	asu64(R3) = d;
	R4 = 76;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) += asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	goto L1187;
L1189:
	asu64(R1) = stack;
	asi64(R2) = fp;
	asu64(R3) = d;
	R4 = 76;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) += asi64(R3);
	R1 += (i64)R2*8-8;
	ptr = asu64(R1);
L1187:
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L1184;
L1186:
	asu64(R1) = pc;
	pc_runaux_pcusopnd(asu64(R1));
L1184:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1190:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1191:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1192:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1193:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	R4 = 1;
	asi64(R3) -= asi64(R4);
	asi64(R2) -= asi64(R3);
	R1 += (i64)R2*8-8;
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R4) = pc;
	R5 = 20;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	R5 = 1;
	asi64(R4) -= asi64(R5);
	asi64(R3) -= asi64(R4);
	R2 += (i64)R3*8-8;
	{i64 temp; temp = *toi64p(R1); *toi64p(R1) = *toi64p(R2); *toi64p(R2) = temp; }
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1194:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1195:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1197:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1198:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1199:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = stack;
	asi64(R4) = sp;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-24));
	asi64(R1) = pc_runaux_pci_loadbf(asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	R1 = 2;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1200:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-24));
	if (!asi64(R1)) goto L1202;
	R1 = 1;
	R2 = (u64)&a;
	asu64(R3) = stack;
	asi64(R4) = sp;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L1201;
L1202:
	R1 = 0;
	R2 = (u64)&a;
	asu64(R3) = stack;
	asi64(R4) = sp;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L1201:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1203:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-24));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-32));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = stack;
	asi64(R4) = sp;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-16));
	asi64(R4) = a;
	asi64(R1) = pc_runaux_pci_storebf(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	a = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 4;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1204:
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1206;
	asi64(R1) = callsp;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1209;
L1207:
	msysc_m$print_startcon();
	R1 = tou64("  ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_1)) goto L1207;
L1209:
	msysc_m$print_startcon();
	R1 = tou64("# Call:   # # SP=# FP=#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_run_seqno;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	asi64(R1) = pc_run_getlineno(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1206:
	asi64(R1) = sp;
	R2 = 69900;
	if (asi64(R1) <= asi64(R2)) goto L1211;
	R1 = tou64("");
	R2 = tou64("Stack overflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1211:
	asu64(R1) = d;
	R2 = 80;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1213;
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	R5 = 0;
	asu64(R6) = d;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) != asi64(R2)) goto L1215;
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	goto L1214;
L1215:
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1214:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1212;
L1213:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1216;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Proc not defined:");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1212;
L1216:
	asi64(R1) = sp;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 21;
	if (asi64(R2) != asi64(R3)) goto L1218;
	R2 = 1;
	goto L1217;
L1218:
	R2 = 0;
L1217:
	asi64(R1) += asi64(R2);
	R2 = (u64)&callstack;
	R3 = (u64)&callsp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	asu64(R1) = d;
	R2 = (u64)&callstackst;
	asi64(R3) = callsp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) |= asi64(R2);
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
L1212:
	goto L1173;
L1219:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	fp = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = callsp;
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L1221;
	R1 = tou64("");
	R2 = tou64("retp/call underflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1221:
	R1 = (u64)&callstack;
	R2 = (u64)&callsp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	oldsp = asi64(R1);
	asi64(R1) = sp;
	asi64(R2) = oldsp;
	if (asi64(R1) == asi64(R2)) goto L1223;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("RETP/SP mismatch: old=# curr=# ");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = oldsp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = tou64("");
	R2 = (u64)&str;
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1223:
	asu64(R1) = ptr;
	R2 = -16;
	asu64(R1) &= asu64(R2);
	pc = asu64(R1);
	goto L1173;
L1224:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R2) = *(toi64p(R2)) -= 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	fp = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R2) = *(toi64p(R2)) -= 1;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 15;
	asi64(R1) &= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = callsp;
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L1226;
	R1 = tou64("");
	R2 = tou64("ref/call underflow");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1226:
	R1 = (u64)&callstack;
	R2 = (u64)&callsp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(tou32(R1));
	oldsp = asi64(R1);
	asi64(R1) = sp;
	asi64(R2) = oldsp;
	if (asi64(R1) == asi64(R2)) goto L1228;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("RETF/SP mismatch: old=# curr=# ");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = oldsp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = tou64("");
	R2 = (u64)&str;
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1228:
	asu64(R1) = ptr;
	R2 = -16;
	asu64(R1) &= asu64(R2);
	pc = asu64(R1);
	goto L1173;
L1229:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1231;
	R1 = tou64("");
	R2 = tou64("ICALLP NIL PTR");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1231:
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pcstart;
	if (asu64(R1) < asu64(R2)) goto L1233;
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1233;
// pc_run.dispatch_loop.icallp:
L1234:
	asi64(R1) = sp;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 22;
	if (asi64(R2) != asi64(R3)) goto L1236;
	R2 = 1;
	goto L1235;
L1236:
	R2 = 0;
L1235:
	asi64(R1) += asi64(R2);
	R2 = (u64)&callstack;
	R3 = (u64)&callsp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou32p(((i64)R2+(i64)R3*4-4)) = asu32(R1);
	R1 = (u64)&pc_run_emptyst;
	R2 = (u64)&callstackst;
	asi64(R3) = callsp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) |= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = ptr;
	pc = asu64(R1);
	goto L1232;
L1233:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	asu64(R5) = ptr;
	R6 = 0;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1232:
	goto L1173;
L1237:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1239;
	R1 = tou64("");
	R2 = tou64("ICALLF NIL PTR");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1239:
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pcstart;
	if (asu64(R1) < asu64(R2)) goto L1241;
	asu64(R1) = ptr;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) > asu64(R2)) goto L1241;
	goto L1234;
	goto L1240;
L1241:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R3) = n;
	asu64(R4) = stack;
	asi64(R5) = sp;
	R4 += (i64)R5*8-8;
	asu64(R5) = ptr;
	R6 = 0;
	asi64(R1) = pc_runaux_docalldll(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1240:
	goto L1173;
L1242:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1173;
L1243:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1173;
L1244:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1246;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpreal(asi64(R3), asr64(R2), asr64(R1));
	n = asi64(R1);
	goto L1245;
L1246:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1247;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpint(asi64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	goto L1245;
L1247:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpword(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L1245:
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L1249;
	asi64(R1) = n;
	if (asi64(R1)) goto L1249;
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	goto L1248;
L1249:
	R1 = 2;
	R2 = (u64)&sp;
	*toi64p(R2) -= asi64(R1);
L1248:
	asi64(R1) = n;
	if (!asi64(R1)) goto L1251;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1250;
L1251:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1250:
	goto L1173;
L1252:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (!asi64(R1)) goto L1254;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1253;
L1254:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1253:
	goto L1173;
L1255:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1257;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1256;
L1257:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
L1256:
	goto L1173;
L1258:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1173;
L1259:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1260:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1262;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1263;
	goto L1264;
L1262:
	R1 = tou64("");
	R2 = tou64("setcc/r64");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1261;
L1263:
	R1 = tou64("");
	R2 = tou64("setcc/r32");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1261;
L1264:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1266;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpint(asi64(R3), asi64(R2), asi64(R1));
	n = asi64(R1);
	goto L1265;
L1266:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-16));
	asu64(R3) = pc;
	R4 = 2;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asi64(R1) = pc_runaux_cmpword(asi64(R3), asu64(R2), asu64(R1));
	n = asi64(R1);
L1265:
L1261:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	asi64(R1) = n;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1267:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L1168;
	goto L1173;
L1268:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	(*toi64p(R1)) -=1;
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	if (!asi64(R1)) goto L1270;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1269;
L1270:
	R1 = 2;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1269:
	goto L1173;
L1271:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = ptr;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = n;
	if (asi64(R1) > asi64(R2)) goto L1273;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1272;
L1273:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1272:
	goto L1173;
L1274:
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	asu64(R1) = pc_runaux_pci_getopndaddr(asu64(R2), asu64(R1));
	ptr = asu64(R1);
	asu64(R1) = stack;
	asi64(R2) = fp;
	R1 += (i64)R2*8-8;
	asu64(R2) = pc;
	R3 = 2;
	R2 += (i64)R3*32;
	asi64(R1) = pc_runaux_pci_getopnd(asu64(R2), asu64(R1));
	n = asi64(R1);
	asu64(R1) = pc;
	R2 = 16;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = ptr;
	*toi64p(R2) -= asi64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	asi64(R2) = n;
	if (asi64(R1) < asi64(R2)) goto L1276;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1275;
L1276:
	R1 = 3;
	R2 = (u64)&pc;
	*tou64p(R2) += asu64(R1)*32;
L1275:
	goto L1173;
L1277:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1279;
	R1 = tou64("");
	R2 = tou64("swap/block");
	asu64(R3) = pc;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1279:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptrb = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptrb;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	b = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = b;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptrb;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1280:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) < asi64(R2)) goto L1282;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) > asi64(R2)) goto L1282;
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	R1 += (i64)R2*32;
	asi64(R2) = a;
	R1 += (i64)R2*32;
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 -= (i64)R2*32;
	pc = asu64(R1);
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
	goto L1281;
L1282:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = pc;
	R3 = 1;
	R2 += (i64)R3*32;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pc = asu64(R1);
L1281:
	goto L1173;
L1283:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1284:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1285:
	asu64(R1) = pc;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	R2 = 0;
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1286:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1287:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1289;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) += asr64(R1);
	goto L1288;
L1289:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) += asi64(R1);
L1288:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1290:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1292;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) -= asr64(R1);
	goto L1291;
L1292:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) -= asi64(R1);
L1291:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1293:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1295;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tor64p(R2) *= asr64(R1);
	goto L1294;
L1295:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) *= asi64(R1);
L1294:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1296:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-8));
	asr64(R1) /= asr64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-16)) = asr64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1297:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1299;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	goto L1298;
L1299:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
   if (asu64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asu64(R1) /= asu64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-16)) = asu64(R1);
L1298:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1300:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1302;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) %= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	goto L1301;
L1302:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) %= asu64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-16)) = asu64(R1);
L1301:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1303:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1304:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) &= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1305:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) |= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1306:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) ^= asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1307:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tou64p(R2) <<= asu64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1308:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1310;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*toi64p(R2) >>= asi64(R1);
	goto L1309;
L1310:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
	*tou64p(R2) >>= asu64(R1);
L1309:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1311:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1313;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tor64p(R2) = Min(*tor64p(R2), asr64(R1));
	goto L1312;
L1313:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1314;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
	goto L1312;
L1314:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tou64p(R2) = Min(*tou64p(R2), asu64(R1));
L1312:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1315:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1317;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tor64p(R2) = Max(*tor64p(R2), asr64(R1));
	goto L1316;
L1317:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1318;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	goto L1316;
L1318:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-16;
    *tou64p(R2) = Max(*tou64p(R2), asu64(R1));
L1316:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1319:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 += (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1320:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R2) = a;
	asu64(R3) = pc;
	R4 = 16;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi64(R2) *= asi64(R3);
	R1 -= (i64)R2;
	asu64(R2) = pc;
	R3 = 20;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1321:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) -= asi64(R2);
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1322:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1324;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = -asr64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1323;
L1324:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = -asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1323:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1325:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1327;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	if (asr64(R1) < 0) asr64(R1) = -asr64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1326;
L1327:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1326:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1328:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = ~asu64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1329:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = 1;
	asi64(R1) ^= asi64(R2);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1330:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = !!asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1331:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = !asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1332:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1334;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	*tor64p(R2) *= asr64(R1);
	goto L1333;
L1334:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) *= asi64(R1);
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L1333:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1335:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = sqrt(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1336:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1337:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1338:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1339:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1340:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1341:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1342:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1343:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1344:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1345:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1346:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1347:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1348:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1349:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1350:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1352;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3*8-8));
	asr64(R1) = pow(asr64(R1), asr64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-16)) = asr64(R1);
	goto L1351;
L1352:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-16));
	asu64(R2) = stack;
	asi64(R3) = sp;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = Poweri64(asi64(R1), asi64(R2));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-16)) = asi64(R1);
L1351:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1353:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1354:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1355:
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = stack;
	R4 = (u64)&sp;
	asi64(R5) = *toi64p(R4); *(toi64p(R4)) -= 1; asi64(R4) = asi64(R5);
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1356:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1357:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1358:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1359:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R2) = -asi64(R2);
	asu64(R3) = ptr;
	pc_runaux_doincr(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1360:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1362;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) += asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1361;
L1362:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) += asi64(R1);
L1361:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1363:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1365;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) -= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1364;
L1365:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) -= asi64(R1);
L1364:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1366:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1368;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) *= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1367;
L1368:
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) *= asi64(R1);
L1367:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1369:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1371;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) /= asr64(R2);
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1370;
L1371:
	asi64(R1) = a;
	asi64(R2) = b;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	a = asi64(R1);
L1370:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1372:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) %= asi64(R2);
	a = asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1373:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) &= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1374:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) |= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1375:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) ^= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1376:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) <<= asi64(R1);
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1377:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1379;
	asi64(R1) = b;
	R2 = (u64)&a;
	*toi64p(R2) >>= asi64(R1);
	goto L1378;
L1379:
	asu64(R1) = b;
	R2 = (u64)&a;
	*tou64p(R2) >>= asu64(R1);
L1378:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1380:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1382;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) = Min(asr64(R1), asr64(R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1381;
L1382:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1383;
	asi64(R1) = b;
	R2 = (u64)&a;
    *toi64p(R2) = Min(*toi64p(R2), asi64(R1));
	goto L1381;
L1383:
	asu64(R1) = b;
	R2 = (u64)&a;
    *tou64p(R2) = Min(*tou64p(R2), asu64(R1));
L1381:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1384:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	b = asi64(R1);
	asu64(R1) = pc;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L1386;
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	asi64(R2) = b;
	asr64(R2) = asr64(R2);
	asr64(R1) = Max(asr64(R1), asr64(R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1385;
L1386:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1387;
	asi64(R1) = b;
	R2 = (u64)&a;
    *toi64p(R2) = Max(*toi64p(R2), asi64(R1));
	goto L1385;
L1387:
	asu64(R1) = b;
	R2 = (u64)&a;
    *tou64p(R2) = Max(*tou64p(R2), asu64(R1));
L1385:
	R1 = 0;
	asu64(R2) = pc;
	R3 = 3;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R3) = a;
	asu64(R4) = ptr;
	pc_runaux_pci_storeptr(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1388:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) *= asu64(R2);
	asu64(R2) = ptr;
	*tou64p(R2) += asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1389:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pc;
	R3 = 16;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) *= asu64(R2);
	asu64(R2) = ptr;
	*tou64p(R2) -= asu64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1390:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1391:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1392:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1393:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1394:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1395:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1396:
	R1 = (u64)&pc_tables_psigned;
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	R4 = 7;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1398;
	asu64(R1) = stack;
	asi64(R2) = sp;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
	goto L1397;
L1398:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asr64(R1) = tor64(asu64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*tor64p(((i64)R2+(i64)R3*8-8)) = asr64(R1);
L1397:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1399:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2*8-8));
	R1 = toi64(asr64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1400:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1401:
	asu64(R1) = pc;
	R2 = 28;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	R3 = 7;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	asu64(R2) = stack;
	asi64(R3) = sp;
	R2 += (i64)R3*8-8;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1402:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1403:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1404:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1405:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1406:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1407:
	asi64(R1) = fp;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = sp;
	fp = asi64(R1);
	asu64(R1) = pc;
	R2 = 20;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = (u64)&sp;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = pc_run_dotrace;
	if (!asi64(R1)) goto L1409;
	asi64(R1) = callsp;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L1412;
L1410:
	msysc_m$print_startcon();
	R1 = tou64("  ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_2)) goto L1410;
L1412:
	msysc_m$print_startcon();
	R1 = tou64("# Enter:  # SP=# FP=#");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = pc_run_seqno;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = sp;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = fp;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1409:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1413:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1414:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1415:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1416:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1417:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1418:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1419:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1420:
	asu64(R1) = stack;
	asi64(R2) = sp;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = pc;
	R2 = 1;
	R1 += (i64)R2*32;
	asu64(R2) = ptr;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = sp;
	asu64(R2) = ptr;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = fp;
	asu64(R2) = ptr;
	R3 = 2;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 0;
	asu64(R2) = stack;
	asi64(R3) = sp;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1421:
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	asu64(R1) = stack;
	R2 = (u64)&sp;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	ptr = asu64(R1);
	asu64(R1) = ptr;
	asu64(R1) = *tou64p(R1);
	pc = asu64(R1);
	asu64(R1) = ptr;
	R2 = 1;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	sp = asi64(R1);
	asu64(R1) = ptr;
	R2 = 2;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8));
	fp = asi64(R1);
	asi64(R1) = a;
	asu64(R2) = stack;
	R3 = (u64)&sp;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	goto L1173;
L1422:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1423:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1424:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1425:
	R1 = (u64)&sp;
	(*toi64p(R1)) -=1;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1426:
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1427:
	goto L1196;
	R1 = (u64)&pc;
	(*tou64p(R1)) += 32;
	goto L1173;
L1428:
	goto L1173;
L1176:
// pc_run.dispatch_loop.unimpl:
L1196:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("GETOPCODE=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pc;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Unimpl: # at seq: #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = pc;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = pc;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	goto L1173;
	R1 = 0;
	goto L1168;
L1168:
	return asi64(R1);
}

static void pc_run_fixuppcl() {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 d;
	u64 e;
	u64 dproc;
	u64 pdata;
	i64 parambytes;
	i64 framebytes;
	i64 paramslots;
	i64 localslots;
	u64 a;
	asi64(R1) = pc_api_mlabelno;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	pc_run_labeltable = asu64(R1);
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1433;
L1430:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1435;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L1435;
	goto L1436;
L1435:
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1434;
L1436:
L1434:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1433:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1430;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1440;
L1437:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1442;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1442;
	goto L1443;
L1442:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L1441;
L1443:
L1441:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1440:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1437;
	asu64(R1) = pc_api_pcstart;
	p = asu64(R1);
	goto L1447;
L1444:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L1449;
	R2 = 124;
	if (asi64(R1) == asi64(R2)) goto L1449;
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L1450;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L1451;
	R2 = 127;
	if (asi64(R1) == asi64(R2)) goto L1452;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L1453;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L1453;
	goto L1454;
L1449:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdata = asu64(R1);
	goto L1448;
L1450:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1456;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1458;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1459;
	goto L1460;
L1458:
	R1 = tou64("");
	R2 = tou64("FIX/DATA/MEM");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
	goto L1457;
L1459:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1462;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1463;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1464;
	goto L1465;
L1462:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L1461;
L1463:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L1461;
L1464:
	asu64(R1) = d;
	asu64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	a = asu64(R1);
	goto L1461;
L1465:
	R1 = tou64("");
	R2 = tou64("data &mem");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1461:
	asu64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1467;
	R1 = tou64("");
	R2 = tou64("data &mem = nil");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1467:
	goto L1457;
L1460:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L1457:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	R2 = (u64)&a;
	asu64(R3) = pdata;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L1455;
L1456:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asu64(R2) = p;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = pdata;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L1455:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&pdata;
	*tou64p(R2) += asu64(R1);
	goto L1448;
L1451:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	dproc = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	parambytes = asi64(R1);
	goto L1471;
L1468:
	R1 = 8;
	R2 = (u64)&parambytes;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = parambytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asi64(R1) = -asi64(R1);
	asu64(R2) = e;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = e;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1471:
	asu64(R1) = e;
	if (asu64(R1)) goto L1468;
	asu64(R1) = d;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	framebytes = asi64(R1);
	goto L1475;
L1472:
	asi64(R1) = framebytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = e;
	R3 = 76;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 8;
	asu64(R2) = e;
	R3 = 84;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	asi64(R1) = mlib_roundtoblock(asi64(R2), asi64(R1));
	R2 = (u64)&framebytes;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = e;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L1475:
	asu64(R1) = e;
	if (asu64(R1)) goto L1472;
	asi64(R1) = parambytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = R1;
	paramslots = asi64(R2);
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = framebytes;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = R1;
	localslots = asi64(R2);
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1448;
L1452:
	asu64(R1) = p;
	asu64(R2) = pc_run_labeltable;
	asu64(R3) = p;
	R4 = 8;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L1448;
L1453:
	asi64(R1) = paramslots;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = localslots;
	asu64(R2) = p;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1448;
L1454:
L1448:
	R1 = (u64)&p;
	(*tou64p(R1)) += 32;
L1447:
	asu64(R1) = p;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L1444;
	return;
}

static void pc_run_pcl_runpcl() {
    u64 R1, R2, R3; 
	i64 stopcode;
	pc_runaux_loadlibs();
	pc_run_fixuppcl();
	asu64(R1) = pc_decls_entryproc;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1478;
	R1 = tou64("");
	R2 = tou64("No 'main' entry point");
	asu64(R3) = pc_api_pcstart;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1478:
	pc_runaux_docmdskip();
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L1480;
	msysc_m$print_startcon();
	R1 = tou64("Run PCL:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1480:
	asu64(R1) = pc_decls_entryproc;
	R2 = 112;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = pc_decls_entryproc;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_run_dispatch_loop(asu64(R2), asi64(R1));
	stopcode = asi64(R1);
	asu8(R1) = pc_decls_pverbose;
	if (!asu8(R1)) goto L1482;
	msysc_m$print_startcon();
	R1 = tou64("Stopped");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = stopcode;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
L1482:
	asi64(R1) = stopcode;
	exit(R1);
	return;
}

static i64 pc_run_getlineno(u64 pc) {
    u64 R1, R2, R3, R4; 
	u64 filename;
	u64 sourceline;
	asu64(R1) = pc_decls_igetmsourceinfo;
	if (!asu64(R1)) goto L1485;
	R1 = (u64)&sourceline;
	R2 = (u64)&filename;
	asu64(R3) = pc;
	R4 = 24;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	asu64(R4) = pc_decls_igetmsourceinfo;
	asi64(R1) = ((F17)R4)(asi64(R3), asu64(R2), asu64(R1));
	goto L1484;
L1485:
	R1 = 0;
L1484:
	goto L1483;
L1483:
	return asi64(R1);
}

static i64 pc_runaux_pci_getopnd(u64 p, u64 locals) {
    u64 R1, R2, R3; 
	i64 a;
	u64 d;
	u64 ptr;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1488;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1489;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1490;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1491;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1492;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1492;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1493;
	goto L1494;
L1488:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	goto L1487;
L1489:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1496;
	goto L1497;
L1496:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptr = asu64(R1);
	goto L1495;
L1497:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	ptr = asu64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1499;
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1499;
	asu64(R1) = ptr;
	asu64(R1) = *tou64p(R1);
	ptr = asu64(R1);
L1499:
L1495:
	asu64(R1) = p;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ptr;
	asi64(R1) = pc_runaux_pci_loadptr(asu64(R2), asi64(R1));
	a = asi64(R1);
	goto L1487;
L1490:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1501;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1502;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1503;
	goto L1504;
L1501:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	a = asi64(R1);
	goto L1500;
L1502:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
	a = asi64(R1);
	asu64(R1) = d;
	R2 = 82;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L1506;
	asi64(R1) = a;
	ptr = asu64(R1);
	asu64(R1) = ptr;
	asi64(R1) = *toi64p(R1);
	a = asi64(R1);
L1506:
	goto L1500;
L1503:
	asu64(R1) = d;
	asi64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	a = asi64(R1);
	goto L1500;
L1504:
	asu64(R1) = d;
	R2 = 56;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
L1500:
	goto L1487;
L1491:
	asu64(R1) = p;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	goto L1487;
L1492:
	asu64(R1) = p;
	R2 = 8;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	asi64(R1) = asi64(R1);
	a = asi64(R1);
	goto L1487;
L1493:
	asu64(R1) = pc_run_labeltable;
	asu64(R2) = p;
	R3 = 8;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	a = asi64(R1);
	goto L1487;
L1494:
	asu64(R1) = p;
	pc_runaux_pcusopnd(asu64(R1));
L1487:
	asi64(R1) = a;
	goto L1486;
L1486:
	return asi64(R1);
}

static i64 pc_runaux_pci_loadptr(u64 p, i64 mode) {
    u64 R1, R2; 
	r64 x;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1509;
	R1 = tou64("Null ptr access");
	pc_api_pclerror(asu64(R1));
L1509:
	asi64(R1) = mode;
	switch (asi64(R1)) {
	case 1: goto L1515;
	case 2: goto L1514;
	case 3: goto L1523;
	case 4: goto L1522;
	case 5: goto L1521;
	case 6: goto L1520;
	case 7: goto L1519;
	case 8: goto L1518;
	case 9: goto L1517;
	case 10: goto L1516;
	case 11: goto L1513;
	default: goto L1512;
    };
// SWITCH
L1513:
	asu64(R1) = p;
	goto L1510;
L1514:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1510;
L1515:
	asu64(R1) = p;
	asr32(R1) = *tor32p(R1);
    asr64(R1) = tor64(asr32(R1));
	x = asr64(R1);
	asr64(R1) = x;
	asi64(R1) = asi64(R1);
	goto L1510;
L1516:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1510;
L1517:
	asu64(R1) = p;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	goto L1510;
L1518:
	asu64(R1) = p;
	asi16(R1) = *toi16p(R1);
	R1 = toi64(toi16(R1));
	goto L1510;
L1519:
	asu64(R1) = p;
	asi8(R1) = *toi8p(R1);
	R1 = toi64(toi8(R1));
	goto L1510;
L1520:
	asu64(R1) = p;
	asi64(R1) = *toi64p(R1);
	goto L1510;
L1521:
	asu64(R1) = p;
	asu32(R1) = *tou32p(R1);
	R1 = toi64(tou32(R1));
	goto L1510;
L1522:
	asu64(R1) = p;
	asu16(R1) = *tou16p(R1);
	R1 = toi64(tou16(R1));
	goto L1510;
L1523:
	asu64(R1) = p;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	goto L1510;
L1512:
	R1 = 0;
L1510:
	goto L1507;
L1507:
	return asi64(R1);
}

static void pc_runaux_pci_storeptr(u64 p, i64 a, i64 mode, i64 size) {
    u64 R1, R2, R3; 
	r64 x;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1526;
	R1 = tou64("Null ptr access");
	pc_api_pclerror(asu64(R1));
L1526:
	asi64(R1) = mode;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1528;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1529;
	goto L1530;
L1528:
	asi64(R1) = size;
	asi64(R2) = a;
	asu64(R3) = p;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	goto L1527;
L1529:
	asi64(R1) = a;
	asr64(R1) = asr64(R1);
	x = asr64(R1);
	asr64(R1) = x;
    asr32(R1) = tor32(asr64(R1));
	asu64(R2) = p;
	*tor32p(R2) = asr32(R1);
	goto L1527;
L1530:
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1532;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1533;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1534;
	goto L1535;
L1532:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi64p(R2) = asi64(R1);
	goto L1531;
L1533:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi32p(R2) = asi32(R1);
	goto L1531;
L1534:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi16p(R2) = asi16(R1);
	goto L1531;
L1535:
	asi64(R1) = a;
	asu64(R2) = p;
	*toi8p(R2) = asi8(R1);
L1531:
L1527:
	return;
}

static u64 pc_runaux_pci_getopndaddr(u64 p, u64 locals) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1538;
	R1 = tou64("");
	R2 = tou64("Not mem");
	asu64(R3) = p;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1538:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1540;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L1539;
L1540:
	asu64(R1) = locals;
	asu64(R2) = d;
	R3 = 76;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2*8;
L1539:
	goto L1536;
L1536:
	return asu64(R1);
}

static void pc_runaux_pcerrorx(u64 p, u64 mess, u64 param) {
    u64 R1, R2, R3, R4; 
	msysc_m$print_startcon();
	R1 = tou64("PC Exec error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = param;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("seq:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	if (!asu64(R2)) goto L1543;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	goto L1542;
L1543:
	R2 = 0;
L1542:
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void pc_runaux_pcusopnd(u64 p) {
    u64 R1, R2, R3, R4; 
	msysc_m$print_startcon();
	R1 = tou64("Unsupported operand:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_opndnames;
	asu64(R2) = p;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 28;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 8;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	msysc_m$print_u64(asu64(R2), asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static i64 pc_runaux_docalldll(u64 d, u64 fnaddr, u64 revargs, i64 nargs, i64 nvars, i64 retmode) {
    u64 R1, R2, R3, R4, R5; 
	struct $B76 args;
	i64 retval;
	i64 i;
	asu64(R1) = fnaddr;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1547;
	asu64(R1) = d;
	asu64(R1) = pc_runaux_getdllfnptr(asu64(R1));
	fnaddr = asu64(R1);
L1547:
	asi64(R1) = nargs;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1550;
L1548:
	asu64(R1) = revargs;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&args;
	asi64(R3) = nargs;
	asi64(R4) = i;
	asi64(R3) -= asi64(R4);
	*toi64p(((i64)R2+(i64)R3*8)) = asi64(R1);
	i += -1; if (i >= 1) goto L1548;
L1550:
	R1 = 0;
	R2 = (u64)&args;
	asi64(R3) = nargs;
	asi64(R4) = retmode;
	R5 = 1;
	if (asi64(R4) == asi64(R5)) goto L1553;
	R5 = 2;
	if (asi64(R4) != asi64(R5)) goto L1552;
L1553:
	R4 = 82;
	goto L1551;
L1552:
	R4 = 73;
L1551:
	asu64(R5) = fnaddr;
	asi64(R1) = mwindllc_os_calldllfunction(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asu64(R1));
	retval = asi64(R1);
	asi64(R1) = retval;
	goto L1545;
L1545:
	return asi64(R1);
}

static u64 pc_runaux_getdllfnptr(u64 d) {
    u64 R1, R2, R3; 
	u64 fnaddr;
	i64 libindex;
	u64 dllinst;
	u64 procname;
	u64 libname;
	i64 i;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L1556;
	asu64(R1) = fnaddr;
	goto L1554;
L1556:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	procname = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1560;
L1557:
	asu64(R1) = procname;
	R2 = (u64)&pc_decls_plibinst;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mwindows_os_getdllprocaddr(asi64(R2), asu64(R1));
	fnaddr = asu64(R1);
	asu64(R1) = fnaddr;
	if (!asu64(R1)) goto L1562;
	goto L1559;
L1562:
	i += 1; if (i <= pc_decls_nplibfiles) goto L1557;
L1560:
	asu64(R1) = procname;
	R2 = tou64("Can't find DLL func:");
	R3 = 0;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1559:
	asu64(R1) = fnaddr;
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = fnaddr;
	goto L1554;
L1554:
	return asu64(R1);
}

static void pc_runaux_loadlibs() {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = pc_decls_nplibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1566;
L1564:
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mwindows_os_getdllinst(asu64(R1));
	R2 = (u64)&pc_decls_plibinst;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&pc_decls_plibinst;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (asu64(R1)) goto L1568;
	R1 = (u64)&pc_decls_plibfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = tou64("Can't load lib:");
	R3 = 0;
	pc_runaux_pcerrorx(asu64(R3), asu64(R2), asu64(R1));
L1568:
	i += 1; if (i <= pc_decls_nplibfiles) goto L1564;
L1566:
	return;
}

static i64 pc_runaux_cmpreal(i64 cond, r64 x, r64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1571;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1572;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1573;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1574;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1575;
	goto L1576;
L1571:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  ==  asr64(R2);
	goto L1570;
L1572:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  !=  asr64(R2);
	goto L1570;
L1573:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  <  asr64(R2);
	goto L1570;
L1574:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  <=  asr64(R2);
	goto L1570;
L1575:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  >=  asr64(R2);
	goto L1570;
L1576:
	asr64(R1) = x;
	asr64(R2) = y;
	asi64(R1) = asr64(R1)  >  asr64(R2);
L1570:
	goto L1569;
L1569:
	return asi64(R1);
}

static i64 pc_runaux_cmpint(i64 cond, i64 x, i64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1579;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1580;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1581;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1582;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1583;
	goto L1584;
L1579:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L1578;
L1580:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	goto L1578;
L1581:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <  asi64(R2);
	goto L1578;
L1582:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  <=  asi64(R2);
	goto L1578;
L1583:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >=  asi64(R2);
	goto L1578;
L1584:
	asi64(R1) = x;
	asi64(R2) = y;
	asi64(R1) = asi64(R1)  >  asi64(R2);
L1578:
	goto L1577;
L1577:
	return asi64(R1);
}

static i64 pc_runaux_cmpword(i64 cond, u64 x, u64 y) {
    u64 R1, R2; 
	asi64(R1) = cond;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1587;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1588;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1589;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1590;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1591;
	goto L1592;
L1587:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  ==  asu64(R2);
	goto L1586;
L1588:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  !=  asu64(R2);
	goto L1586;
L1589:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  <  asu64(R2);
	goto L1586;
L1590:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  <=  asu64(R2);
	goto L1586;
L1591:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  >=  asu64(R2);
	goto L1586;
L1592:
	asu64(R1) = x;
	asu64(R2) = y;
	asi64(R1) = asu64(R1)  >  asu64(R2);
L1586:
	goto L1585;
L1585:
	return asi64(R1);
}

static void pc_runaux_doincr(u64 pu8, i64 incr, i64 mode) {
    u64 R1, R2; 
	R1 = (u64)&pc_tables_psize;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1595;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1596;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1597;
	goto L1598;
L1595:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou64p(R2) += asu64(R1);
	goto L1594;
L1596:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou32p(R2) += asu32(R1);
	goto L1594;
L1597:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou16p(R2) += asu16(R1);
	goto L1594;
L1598:
	asi64(R1) = incr;
	asu64(R2) = pu8;
	*tou8p(R2) += asu8(R1);
L1594:
	return;
}

static void pc_runaux_docmdskip() {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = pc_decls_psymboltable;
	d = asu64(R1);
	goto L1603;
L1600:
	R1 = tou64("$cmdskip");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = pc_api_getbasename(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1605;
	asi64(R1) = pc_decls_pcmdskip;
	asu64(R2) = d;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	*tou8p(R2) = asu8(R1);
	goto L1602;
L1605:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L1603:
	asu64(R1) = d;
	if (asu64(R1)) goto L1600;
L1602:
	return;
}

static u64 pc_runaux_pci_loadbf(u64 a, u64 i, u64 j) {
    u64 R1, R2; 
	u64 mask;
	i64 n;
	asu64(R1) = j;
	asu64(R2) = i;
	if (asu64(R1) >= asu64(R2)) goto L1608;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L1608:
	asu64(R1) = j;
	asu64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	R1 = -1;
	asi64(R2) = n;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	mask = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = mask;
	asu64(R1) &= asu64(R2);
	asu64(R2) = i;
	asu64(R1) >>= asu64(R2);
	goto L1606;
L1606:
	return asu64(R1);
}

static u64 pc_runaux_pci_storebf(u64 a, u64 i, u64 j, u64 x) {
    u64 R1, R2; 
	u64 mask;
	u64 n;
	asu64(R1) = j;
	asu64(R2) = i;
	if (asu64(R1) >= asu64(R2)) goto L1611;
	R1 = (u64)&i;
	R2 = (u64)&j;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L1611:
	asu64(R1) = j;
	asu64(R2) = i;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asu64(R1) += asu64(R2);
	n = asu64(R1);
	R1 = -1;
	asu64(R2) = n;
	asi64(R1) <<= asi64(R2);
	asi64(R1) = ~asi64(R1);
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	mask = asu64(R1);
	asu64(R1) = x;
	asu64(R2) = i;
	asu64(R1) <<= asu64(R2);
	asu64(R2) = mask;
	asu64(R1) &= asu64(R2);
	x = asu64(R1);
	asu64(R1) = a;
	asu64(R2) = mask;
	asu64(R2) = ~asu64(R2);
	asu64(R1) &= asu64(R2);
	asu64(R2) = x;
	asu64(R1) |= asu64(R2);
	goto L1609;
L1609:
	return asu64(R1);
}

static void mc_genmcl_dummy_genmcl() {
	return;
}

static void mc_genss_dummy_genss(i64 obj) {
	return;
}

static void mc_decls_start() {
    u64 R1, R2, R3, R4; 
	i64 av_1;
	i64 i;
	R1 = 0;
	i = asi64(R1);
	R1 = 13;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L1617;
L1615:
	R1 = 10;
	R2 = (u64)&mc_decls_ploadop;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L1615;
L1617:
	R1 = 19;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 5;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 4;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 18;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 9;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 8;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 16;
	R2 = (u64)&mc_decls_ploadop;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 17;
	R2 = (u64)&mc_decls_ploadop;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 11;
	R2 = R1;
	R3 = (u64)&mc_decls_ploadop;
	R4 = 10;
	*tou8p(((i64)R3+(i64)R4)) = asu8(R2);
	R2 = (u64)&mc_decls_ploadop;
	R3 = 6;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 mc_writeasm_dummy_getassemstr() {
    u64 R1; 
	R1 = tou64("no writeasm");
	mlib_abortprogram(asu64(R1));
	R1 = 0;
	goto L1618;
L1618:
	return asu64(R1);
}

static u64 mc_writeasm_dummy_getdispname(u64 d) {
    u64 R1; 
	R1 = tou64("");
	goto L1619;
L1619:
	return asu64(R1);
}

static u64 mc_writeasm_dummy_gettempname(u64 d, i64 n) {
    u64 R1; 
	R1 = tou64("");
	goto L1620;
L1620:
	return asu64(R1);
}

static u64 mc_writeasm_dummy_strmclstr(u64 m) {
    u64 R1; 
	R1 = tou64("?");
	goto L1621;
L1621:
	return asu64(R1);
}

static void mc_writeexe_dummy_genexe(u64 entrypoint, u64 outfile, i64 dodll) {
	return;
}

static void mc_writeexe_dummy_writeexe(u64 outfile, i64 dodll) {
	return;
}

static void mc_writeobj_dummy_writecoff(u64 outfile) {
	return;
}

static u64 mc_writess_dummy_writessdata(i64 fexe) {
    u64 R1; 
	R1 = 0;
	goto L1625;
L1625:
	return asu64(R1);
}

static void mx_run_dummy_runlibfile(u64 filename, i64 cmdskip) {
    u64 R1; 
	R1 = tou64("No Run");
	mlib_abortprogram(asu64(R1));
	return;
}

static void mx_run_dummy_writemcx(u64 filename) {
	return;
}

void mmi_main() {
    u64 R1; 
	pclint_start();
	mmi_start();
	mm_cli_main2();
	R1 = 0;
	exit(R1);
	return;
}

static void mm_cli_main2() {
    u64 R1, R2; 
	u64 p;
	u64 q;
	u64 r;
	i64 m;
	i64 fileno;
	i64 ntokens;
	i64 t;
	i64 tt;
	asi64(R1) = mwindows_os_clock();
	mm_cli_startclock = asi64(R1);
	asi64(R1) = mm_cli_startclock;
	pc_decls_pstartclock = asi64(R1);
	mm_cli_initdata();
	mm_cli_getinputoptions();
	asi64(R1) = mm_decls_prodmode;
	if (!asi64(R1)) goto L1631;
	mm_cli_production_compiler();
	goto L1630;
L1631:
	mm_cli_debug_compiler();
L1630:
	asi64(R1) = mm_decls_fverbose;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1633;
	msysc_m$print_startcon();
	R1 = tou64("Finished.");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1633:
	return;
}

static void mm_cli_debug_compiler() {
    u64 R1, R2; 
	asu64(R1) = mm_cli_inputfile;
	mm_modules_loadproject(asu64(R1));
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L1636;
	R1 = 4;
	mm_decls_passlevel = asi64(R1);
	goto L1635;
L1636:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L1637;
	R1 = 6;
	mm_decls_passlevel = asi64(R1);
L1637:
L1635:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L1639;
	asu8(R1) = mm_decls_fshowast1;
	R1 = toi64(tou8(R1));
	mm_cli_do_parse(asi64(R1));
L1639:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L1641;
	asu8(R1) = mm_decls_fshowast2;
	R1 = toi64(tou8(R1));
	mm_cli_do_name(asi64(R1));
L1641:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 5;
	if (asi64(R1) < asi64(R2)) goto L1643;
	asu8(R1) = mm_decls_fshowast3;
	R1 = toi64(tou8(R1));
	mm_cli_do_type(asi64(R1));
L1643:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L1645;
	asu8(R1) = mm_decls_fshowpcl;
	if (asu8(R1)) goto L1646;
	asu8(R1) = mm_decls_fshowpst;
	if (!asu8(R1)) goto L1647;
L1646:
	R1 = 1;
	goto L1648;
L1647:
	R1 = 0;
L1648:
	mm_cli_do_genpcl(asi64(R1));
L1645:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 7;
	if (asi64(R1) < asi64(R2)) goto L1650;
	asu8(R1) = mm_decls_fshowasm;
	if (asu8(R1)) goto L1651;
	asu8(R1) = pclint_ctarget;
	if (!asu8(R1)) goto L1652;
L1651:
	R1 = 1;
	goto L1653;
L1652:
	R1 = 0;
L1653:
	mm_cli_do_genmcl(asi64(R1));
L1650:
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 8;
	if (asi64(R1) < asi64(R2)) goto L1655;
	R1 = 0;
	pc_api_pcl_genss(asi64(R1));
L1655:
	asu8(R1) = mm_decls_fshowtiming;
	if (!asu8(R1)) goto L1657;
	mm_diags_dummy_showtimings();
L1657:
	mm_diags_dummy_showlogfile();
	return;
}

static void mm_cli_production_compiler() {
    u64 R1, R2; 
	mm_cli_showcompilemess();
	asu64(R1) = mm_cli_inputfile;
	mm_modules_loadproject(asu64(R1));
	R1 = 0;
	mm_cli_do_parse(asi64(R1));
	R1 = 0;
	mm_cli_do_name(asi64(R1));
	R1 = 0;
	mm_cli_do_type(asi64(R1));
	asi64(R1) = mm_decls_passlevel;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L1660;
	asu64(R1) = mm_cli_inputfile;
	mm_support_do_writema(asu64(R1));
L1660:
	asi64(R1) = mm_decls_passlevel;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1663;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L1662;
L1663:
	asu64(R1) = mm_cli_inputfile;
	mm_support_do_getinfo(asu64(R1));
L1662:
	asi64(R1) = mm_decls_passlevel;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L1665;
	mm_cli_do_writeexports();
L1665:
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	mm_cli_do_genpcl(asi64(R1));
	asi64(R1) = mm_decls_passlevel;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1667;
	pc_run_pcl_runpcl();
L1667:
	asi64(R1) = mm_decls_passlevel;
	R2 = 6;
	if (asi64(R1) < asi64(R2)) goto L1669;
	asi64(R1) = mm_decls_passlevel;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1670;
	asu8(R1) = pclint_ctarget;
	if (!asu8(R1)) goto L1671;
L1670:
	R1 = 1;
	goto L1672;
L1671:
	R1 = 0;
L1672:
	mm_cli_do_genmcl(asi64(R1));
	asi64(R1) = mm_decls_passlevel;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1674;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L1675;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1676;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1677;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1678;
	goto L1679;
L1674:
	R1 = tou64("obj");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	pc_api_pcl_writeobj(asu64(R1));
	goto L1673;
L1675:
	R1 = tou64("exe");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	pc_api_pcl_writeexe(asu64(R1));
	goto L1673;
L1676:
	R1 = tou64("dll");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	pc_api_pcl_writedll(asu64(R1));
	goto L1673;
L1677:
	R1 = tou64("mx");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	pc_api_pcl_writemx(asu64(R1));
	goto L1673;
L1678:
	pc_api_pcl_exec();
	goto L1673;
L1679:
L1673:
L1669:
	asu8(R1) = mm_decls_fshowtiming;
	if (!asu8(R1)) goto L1681;
	mm_diags_dummy_showtimings();
L1681:
	return;
}

static void mm_cli_showcompilemess() {
    u64 R1, R2; 
	asi64(R1) = mm_decls_fverbose;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1684;
	asu8(R1) = mm_cli_msfile;
	if (asu8(R1)) goto L1684;
	msysc_m$print_startcon();
	R1 = tou64("Compiling # to #");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = mm_cli_inputfile;
	msysc_m$print_str_nf(asu64(R1));
	asu8(R1) = pclint_ctarget;
	if (!asu8(R1)) goto L1686;
	R1 = tou64("c");
	goto L1685;
L1686:
	R1 = (u64)&mm_cli_passnames;
	asi64(R2) = mm_decls_passlevel;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
L1685:
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1684:
	return;
}

static void mm_cli_do_parse(i64 flog) {
    u64 R1, R2; 
	i64 tt;
	i64 i;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1690;
L1688:
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R1) = mm_parse_parsemodule(asu64(R1));
	i += 1; if (i <= mm_decls_nmodules) goto L1688;
L1690:
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_parsetime = asi64(R1);
	asi64(R1) = mm_decls_prodmode;
	if (asi64(R1)) goto L1693;
	asi64(R1) = mm_decls_dpasslevel;
	R2 = 3;
	if (asi64(R1) < asi64(R2)) goto L1692;
L1693:
	mm_name_fixusertypes();
L1692:
	mm_cli_fixstartprocs();
	asi64(R1) = flog;
	if (!asi64(R1)) goto L1695;
	R1 = tou64("AST1");
	mm_diags_dummy_showast(asu64(R1));
L1695:
	return;
}

static void mm_cli_do_name(i64 flog) {
    u64 R1, R2; 
	i64 tt;
	i64 i;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	mm_name_rx_typetable();
	R1 = 2;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L1699;
L1697:
	asi64(R1) = i;
	asi64(R1) = mm_name_rx_module(asi64(R1));
	i += 1; if (i <= mm_decls_nmodules) goto L1697;
L1699:
	R1 = 1;
	asi64(R1) = mm_name_rx_module(asi64(R1));
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_resolvetime = asi64(R1);
	asi64(R1) = flog;
	if (!asi64(R1)) goto L1701;
	R1 = tou64("AST2");
	mm_diags_dummy_showast(asu64(R1));
L1701:
	return;
}

static void mm_cli_do_type(i64 flog) {
    u64 R1, R2; 
	i64 tt;
	i64 i;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	mm_type_tx_typetable();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1705;
L1703:
	asi64(R1) = i;
	asi64(R1) = mm_type_tx_module(asi64(R1));
	i += 1; if (i <= mm_decls_nmodules) goto L1703;
L1705:
	mm_type_tx_allprocs();
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_typetime = asi64(R1);
	asi64(R1) = flog;
	if (!asi64(R1)) goto L1707;
	R1 = tou64("AST3");
	mm_diags_dummy_showast(asu64(R1));
L1707:
	return;
}

static void mm_cli_do_genpcl(i64 flog) {
    u64 R1, R2; 
	i64 tt;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	R1 = 0;
	mm_genpcl_codegen_il(asu64(R1));
	asu8(R1) = pc_decls_fregoptim;
	if (asu8(R1)) goto L1711;
	asu8(R1) = pc_decls_fpeephole;
	if (!asu8(R1)) goto L1710;
L1711:
	pc_reduce_pcl_reducetest();
L1710:
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_pcltime = asi64(R1);
	asi64(R1) = flog;
	if (!asi64(R1)) goto L1713;
	asu8(R1) = mm_decls_fshowpcl;
	if (asu8(R1)) goto L1716;
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1715;
L1716:
	R1 = tou64("pcl");
	asu64(R2) = mm_decls_outfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = pc_api_pcl_writepcl(asu64(R1));
L1715:
	asu8(R1) = mm_decls_fshowpst;
	if (!asu8(R1)) goto L1718;
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L1718;
	R1 = tou64("PSYMTAB");
	asu64(R1) = pc_api_pcl_writepst(asu64(R1));
L1718:
L1713:
	return;
}

static void mm_cli_do_genmcl(i64 flog) {
    u64 R1, R2, R3; 
	i64 tt;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	pc_api_pcl_genmcl();
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	pc_decls_mcltime = asi64(R1);
	asi64(R1) = flog;
	if (!asi64(R1)) goto L1721;
	R1 = 16705;
	asu8(R2) = pclint_ctarget;
	if (!asu8(R2)) goto L1723;
	R2 = tou64("c");
	goto L1722;
L1723:
	R2 = tou64("asm");
L1722:
	asu64(R3) = mm_decls_outfile;
	asu64(R2) = mlib_changeext(asu64(R3), asu64(R2));
	asu64(R1) = pc_api_pcl_writeasm(asu64(R2), asi64(R1));
L1721:
	asu8(R1) = mm_decls_fshowpst;
	if (!asu8(R1)) goto L1725;
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L1725;
	R1 = tou64("PSYMTAB");
	asu64(R1) = pc_api_pcl_writepst(asu64(R1));
L1725:
	return;
}

static void mm_cli_initdata() {
    u64 R1, R2, R3; 
	u64 pm;
	u64 pf;
	mlib_pcm_init();
	mm_lex_lexsetup();
	mm_assem_dummy_initassemsymbols();
	mm_support_init_tt_tables();
	mm_support_initbblib();
	R1 = 64;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pm = asu64(R1);
	R1 = tou64("PROGRAM");
	asu64(R2) = pm;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = tou64("$prog");
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	R3 = 0;
	asu64(R1) = mm_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	mm_decls_stprogram = asu64(R1);
	asu64(R1) = mm_decls_stprogram;
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pm;
	R2 = (u64)&mm_decls_modules;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&mm_support_mgetsourceinfo;
	pc_decls_igetmsourceinfo = asu64(R1);
	R1 = (u64)&mm_assemaux_dummy_domcl_assem;
	pc_api_idomcl_assem = asu64(R1);
	R1 = (u64)&mm_genpcl_findhostfn;
	pc_api_igethostfn = asu64(R1);
	R1 = (u64)&mm_assemaux_dummy_checkasmlabel;
	pc_api_icheckasmlabel = asu64(R1);
	R1 = tou64("PSYMTAB");
	asi32(R1) = remove(asu64(R1));
	return;
}

static void mm_cli_getinputoptions() {
    u64 R1, R2, R3, R4; 
	i64 paramno;
	i64 pmtype;
	i64 sw;
	i64 extlen;
	u64 name;
	u64 value;
	u64 ext;
	struct $B15 filespec;
	i64 av_1;
	asu8(R1) = pclint_pc_userunpcl;
	if (!asu8(R1)) goto L1729;
	R1 = 5;
	mm_decls_passlevel = asi64(R1);
	R1 = 1;
	mm_decls_prodmode = asi64(R1);
	R1 = 0;
	mm_decls_fverbose = asi64(R1);
L1729:
	R1 = 1;
	paramno = asi64(R1);
	R1 = tou64("ms.exe");
	asu64(R2) = mwindows_os_gethostname();
	asu64(R2) = mlib_extractfile(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1731;
	R1 = 1;
	mm_cli_msfile = asu8(R1);
	R1 = 0;
	mm_decls_fverbose = asi64(R1);
	R1 = 0;
	R2 = tou64("");
	R3 = 13;
	mm_cli_do_option(asi64(R3), asu64(R2), asi64(R1));
L1731:
	goto L1733;
L1732:
	asi64(R1) = pmtype;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L1736;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L1737;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L1738;
	goto L1739;
L1736:
	asu64(R1) = name;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = 1;
	sw = asi64(R1);
	R1 = 55;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1743;
L1740:
	R1 = (u64)&mm_cli_optionnames;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1745;
	asi64(R1) = paramno;
	asu64(R2) = value;
	asi64(R3) = sw;
	mm_cli_do_option(asi64(R3), asu64(R2), asi64(R1));
	goto L1742;
L1745:
	sw += 1; if (sw <= av_1) goto L1740;
L1743:
	msysc_m$print_startcon();
	R1 = tou64("Unknown option:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 99;
	exit(R1);
L1742:
	goto L1735;
L1737:
	asu64(R1) = mm_cli_inputfile;
	if (!asu64(R1)) goto L1747;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Specify one lead module only");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L1747:
	asu64(R1) = name;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	asu64(R1) = name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_cli_inputfile = asu64(R1);
	asi64(R1) = mm_decls_passlevel;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1750;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L1749;
L1750:
	asi64(R1) = paramno;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = msysc_$cmdskip;
	asi64(R1) += asi64(R2);
	mm_cli_cmdskip = asi64(R1);
	goto L1734;
L1749:
	goto L1735;
L1738:
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Lib files go in module headers");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
	goto L1735;
L1739:
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Invalid params");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L1735:
L1733:
	R1 = tou64("m");
	R2 = (u64)&value;
	R3 = (u64)&name;
	R4 = (u64)&paramno;
	asi64(R1) = mlib_nextcmdparamnew(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	R2 = R1;
	pmtype = asi64(R2);
	if (asi64(R1)) goto L1732;
L1734:
	asi64(R1) = mm_decls_prodmode;
	asi64(R2) = mm_decls_debugmode;
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L1752;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1752;
	asu8(R1) = pclint_ctarget;
	if (asu8(R1)) goto L1754;
	R1 = 9;
	mm_decls_passlevel = asi64(R1);
	R1 = tou64("exe");
	mm_cli_outext = asu64(R1);
	goto L1753;
L1754:
	R1 = 6;
	mm_decls_passlevel = asi64(R1);
	R1 = tou64("c");
	mm_cli_outext = asu64(R1);
L1753:
	R1 = 1;
	mm_decls_prodmode = asi64(R1);
L1752:
	asi64(R1) = mm_decls_passlevel;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L1756;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L1756;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1757;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L1758;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1758;
	goto L1759;
L1756:
	R1 = 2;
	mm_decls_highmem = asu8(R1);
	goto L1755;
L1757:
	asi64(R1) = pc_decls_assemtype;
	R2 = 1297301838;
	if (asi64(R1) != asi64(R2)) goto L1761;
	R1 = 2;
	mm_decls_highmem = asu8(R1);
L1761:
	goto L1755;
L1758:
	R1 = 0;
	mm_decls_highmem = asu8(R1);
	goto L1755;
L1759:
L1755:
	asu64(R1) = mm_cli_inputfile;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1763;
	mm_cli_showcaption();
	msysc_m$print_startcon();
	R1 = tou64("Usage:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("   ");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64(" prog[.m]  Compile prog.m to prog.exe");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("   ");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = msysc_cmdparams;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64(" -h           Show all options");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	exit(R1);
	goto L1762;
L1763:
	asu64(R1) = mm_cli_inputfile;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_outfile = asu64(R1);
	asu64(R1) = mm_decls_destfilename;
	if (!asu64(R1)) goto L1765;
	asu64(R1) = mm_decls_destfilename;
	mm_decls_outfile = asu64(R1);
L1765:
	asu64(R1) = mm_decls_destfilepath;
	if (!asu64(R1)) goto L1767;
	asu64(R1) = mm_decls_destfilepath;
	R2 = (u64)&filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = mm_decls_outfile;
	R2 = (u64)&filespec;
	asu64(R2) = mlib_extractfile(asu64(R2));
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_outfile = asu64(R1);
L1767:
L1762:
	R1 = 0;
	asu64(R2) = mm_cli_inputfile;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	ext = asu64(R1);
	asu64(R1) = ext;
	asi64(R1) = strlen(asu64(R1));
	extlen = asi64(R1);
	asu64(R1) = ext;
	asu64(R2) = msysc_cmdparams;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	R2 = (u64)&filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&filespec;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	asu64(R1) = mm_cli_inputfile;
	R2 = (u64)&filespec;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L1769;
	asi64(R1) = mm_decls_passlevel;
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L1769;
	R1 = tou64("2.m");
	R2 = (u64)&filespec;
	R3 = (u64)&filespec;
	asi64(R3) = strlen(asu64(R3));
	R2 += (i64)R3;
	asi64(R3) = extlen;
	R2 -= (i64)R3;
	R3 = 1;
	R2 -= (i64)R3;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_outfile = asu64(R1);
	msysc_m$print_startcon();
	R1 = tou64("New dest=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mm_decls_outfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L1769:
	asi64(R1) = mm_decls_fshortnames;
	R2 = -1;
	asu8(R3) = mm_decls_highmem;
	R3 = toi64(tou8(R3));
	pc_api_pcl_setflags(asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = mm_cli_cmdskip;
	pc_api_pcl_cmdskip(asi64(R2), asu64(R1));
	asu8(R1) = mm_decls_msyslevel;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L1771;
	R1 = 1;
	pc_api_pfullsys = asu8(R1);
L1771:
	return;
}

static void mm_cli_do_option(i64 sw, u64 value, i64 paramno) {
    u64 R1, R2, R3; 
	asi64(R1) = sw;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1774;
	R2 = 13;
	if (asi64(R1) > asi64(R2)) goto L1774;
	asi64(R1) = mm_decls_prodmode;
	if (!asi64(R1)) goto L1776;
	R1 = tou64("");
	R2 = (u64)&mm_cli_optionnames;
	asi64(R3) = sw;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = tou64("dupl prod option:");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L1776:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mm_decls_passlevel = asi64(R1);
	R1 = 1;
	mm_decls_prodmode = asi64(R1);
	R1 = (u64)&mm_cli_passnames;
	asi64(R2) = sw;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_cli_outext = asu64(R1);
	asi64(R1) = sw;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L1778;
	goto L1779;
L1778:
	asi64(R1) = paramno;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asi64(R2) = msysc_$cmdskip;
	asi64(R1) += asi64(R2);
	mm_cli_cmdskip = asi64(R1);
	goto L1777;
L1779:
L1777:
	goto L1772;
	goto L1773;
L1774:
	asi64(R1) = sw;
	R2 = 14;
	if (asi64(R1) < asi64(R2)) goto L1780;
	R2 = 21;
	if (asi64(R1) > asi64(R2)) goto L1780;
	asi64(R1) = mm_decls_debugmode;
	if (!asi64(R1)) goto L1782;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("dupl debug option");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L1782:
	asi64(R1) = sw;
	R2 = 14;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	mm_decls_dpasslevel = asi64(R1);
	R1 = 1;
	mm_decls_debugmode = asi64(R1);
	goto L1772;
L1780:
L1773:
	asi64(R1) = sw;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L1784;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L1785;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L1786;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L1787;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L1788;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1789;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L1790;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L1791;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L1792;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L1793;
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L1794;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L1795;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L1796;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L1797;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L1797;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L1797;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L1798;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L1799;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1800;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L1801;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L1802;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L1802;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L1802;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L1803;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L1803;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L1804;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L1804;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L1805;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L1806;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L1807;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L1808;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L1809;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L1810;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L1810;
	goto L1811;
L1784:
	R1 = 1;
	mm_decls_fshowast1 = asu8(R1);
	goto L1783;
L1785:
	R1 = 1;
	mm_decls_fshowast2 = asu8(R1);
	goto L1783;
L1786:
	R1 = 1;
	mm_decls_fshowast3 = asu8(R1);
	goto L1783;
L1787:
	R1 = 1;
	mm_decls_fshowpcl = asu8(R1);
	goto L1783;
L1788:
	R1 = 1;
	mm_decls_fshowc = asu8(R1);
	goto L1783;
L1789:
	R1 = 1;
	mm_decls_fshowasm = asu8(R1);
	goto L1783;
L1790:
	R1 = 1;
	mm_decls_fshowst = asu8(R1);
	goto L1783;
L1791:
	R1 = 1;
	mm_decls_fshowstflat = asu8(R1);
	goto L1783;
L1792:
	R1 = 1;
	mm_decls_fshowpst = asu8(R1);
	goto L1783;
L1793:
	R1 = 1;
	mm_decls_fshowtypes = asu8(R1);
	goto L1783;
L1794:
	R1 = 1;
	mm_decls_fshowss = asu8(R1);
	goto L1783;
L1795:
	R1 = 1;
	mm_decls_fshowmodules = asu8(R1);
	goto L1783;
L1796:
	R1 = 1;
	mm_decls_clinux = asu8(R1);
	goto L1783;
L1797:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	mm_decls_msyslevel = asu8(R1);
	goto L1783;
L1798:
	R1 = 0;
	R2 = R1;
	pc_decls_fregoptim = asu8(R2);
	pc_decls_fpeephole = asu8(R1);
	goto L1783;
L1799:
	R1 = 0;
	pc_decls_fpeephole = asu8(R1);
	goto L1783;
L1800:
	R1 = 0;
	pc_decls_fregoptim = asu8(R1);
	goto L1783;
L1801:
	R1 = 1;
	mm_decls_fshowtiming = asu8(R1);
	goto L1783;
L1802:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mm_decls_fverbose = asi64(R1);
	goto L1783;
L1803:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	pc_decls_pverbose = asu8(R1);
	goto L1783;
L1804:
	mm_cli_showhelp();
	R1 = 0;
	exit(R1);
	goto L1783;
L1805:
	R1 = 0;
	mm_decls_dointlibs = asu8(R1);
	goto L1783;
L1806:
	asu8(R1) = mm_cli_do_option_outpathused;
	if (!asu8(R1)) goto L1813;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("mixed out/path");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L1813:
	asu64(R1) = value;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_destfilename = asu64(R1);
	R1 = 1;
	mm_cli_do_option_outused = asu8(R1);
	goto L1783;
L1807:
	asu8(R1) = mm_cli_do_option_outused;
	if (!asu8(R1)) goto L1815;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("mixed out/path");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L1815:
	asu64(R1) = value;
	asu64(R2) = value;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L1817;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L1817;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Path needs to end with \\ or /");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L1817:
	asu64(R1) = value;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_decls_destfilepath = asu64(R1);
	R1 = 1;
	mm_cli_do_option_outpathused = asu8(R1);
	goto L1783;
L1808:
	R1 = 1;
	mm_decls_fcheckunusedlocals = asu8(R1);
	goto L1783;
L1809:
	R1 = 1;
	mm_decls_fshortnames = asi64(R1);
	goto L1783;
L1810:
	R1 = (u64)&mm_cli_optionvalues;
	asi64(R2) = sw;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	mm_decls_highmem = asu8(R1);
	goto L1783;
L1811:
L1783:
L1772:
	return;
}

static void mm_cli_showcaption() {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("M Compiler [M7.1]");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("19-Aug-2025");
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("19:15:16");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_cli_showhelp() {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("M Compiler for 64-bit Windows\n\nNormal use:           Compiles lead module prog.m to:\n\n    mm      prog      prog.exe (default)\n    mm -r   prog      in-memory native code then execute\n    mm -i   prog      in-memory IL then interpret\n\n    mm -exe prog      prog.exe\n    mm -dll prog      prog.dll\n    mm -obj prog      prog.obj\n    mm -a   prog      prog.asm\n    mm -n   prog      prog.nasm\n    mm -mx  prog      prog.mx\n    mm -p   prog      prog.pcl (textual IL)\n    mm -ma   prog     prog.ma (single amalgamated source file)\n\nOther options:\n\n    -ext              Used std headers external to compiler\n    -opt              Optimise native code\n    -out:file         Name output file (extension can be added)\n    -rip              Use RIP address modes\n    -himem            Generate PIC code (automatic with -obj/-dll)\n    @file             Read files and options from a file\n");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_cli_do_writeexports() {
    u64 R1, R2; 
	struct $B15 str;
	asu64(R1) = mm_decls_outfile;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("dll");
	R2 = (u64)&str;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R2) = mm_decls_outfile;
	mm_exportm_writeexports(asu64(R2), asu64(R1));
	return;
}

static u64 mm_cli_getoutfilename(u64 file, u64 ext) {
    u64 R1, R2; 
	asu64(R1) = ext;
	asu64(R2) = file;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	goto L1821;
L1821:
	return asu64(R1);
}

static void mm_cli_fixstartprocs() {
    u64 R1, R2, R3, R4, R5; 
	u64 ms;
	u64 ps;
	u64 d;
	u64 p;
	u64 q;
	i64 s;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1825;
L1823:
	R1 = (u64)&mm_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ps = asu64(R1);
	asu64(R1) = ps;
	R2 = 10;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L1827;
	asu64(R1) = ps;
	R2 = 8;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = ps;
	R3 = 10;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L1827:
	i += 1; if (i <= mm_decls_nsubprogs) goto L1823;
L1825:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1830;
L1828:
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ms = asu64(R1);
	asu64(R1) = ms;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1832;
	R1 = 1;
	R2 = (u64)&mm_decls_subproghasstart;
	asu64(R3) = ms;
	R4 = 18;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L1832:
	i += 1; if (i <= mm_decls_nmodules) goto L1828;
L1830:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L1835;
L1833:
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ms = asu64(R1);
	asu64(R1) = ms;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1837;
	asu64(R1) = ms;
	R2 = 18;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	s = asi64(R1);
	R1 = (u64)&mm_decls_subproghasstart;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L1839;
	R1 = (u64)&mm_decls_subprogs;
	asi64(R2) = s;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 10;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	asi64(R2) = i;
	if (asi64(R1) != asi64(R2)) goto L1839;
	asi64(R1) = i;
	R2 = 2;
	R3 = tou64("start");
	asu64(R4) = ms;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R1) = mm_cli_addstartproc(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = ms;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L1839:
L1837:
	i += 1; if (i <= mm_decls_nmodules) goto L1833;
L1835:
	return;
}

static u64 mm_cli_addstartproc(u64 owner, u64 name, i64 scope, i64 moduleno) {
    u64 R1, R2, R3; 
	u64 stproc;
	R1 = 6;
	asu64(R2) = name;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stproc = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stproc;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = moduleno;
	asu64(R2) = stproc;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = moduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = stproc;
	R3 = 95;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = stproc;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stproc;
	mm_lib_addtoproclist(asu64(R1));
	asu64(R1) = stproc;
	goto L1840;
L1840:
	return asu64(R1);
}

static void mm_blockpcl_evalunit(u64 p) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 a;
	u64 b;
	u64 c;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1843;
	goto L1841;
L1843:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	c = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: goto L1847;
	case 2: goto L1848;
	case 3: case 5: case 7: case 9: case 10: case 11: case 12: case 13: case 20: case 21: case 22: case 23: case 24: case 26: case 27: case 37: case 41: case 42: case 43: case 44: case 45: case 47: case 50: case 54: case 57: case 60: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: goto L1846;
	case 4: goto L1849;
	case 6: goto L1850;
	case 8: goto L1911;
	case 14: goto L1913;
	case 15: goto L1884;
	case 16: goto L1885;
	case 17: goto L1901;
	case 18: goto L1902;
	case 19: goto L1903;
	case 25: goto L1853;
	case 28: goto L1854;
	case 29: goto L1856;
	case 30: goto L1855;
	case 31: goto L1857;
	case 32: goto L1851;
	case 33: goto L1886;
	case 34: goto L1887;
	case 35: goto L1888;
	case 36: goto L1900;
	case 38: goto L1908;
	case 39: goto L1909;
	case 40: goto L1904;
	case 46: goto L1889;
	case 48: goto L1914;
	case 49: goto L1892;
	case 51: goto L1890;
	case 52: goto L1891;
	case 53: goto L1893;
	case 55: goto L1894;
	case 56: goto L1895;
	case 58: goto L1896;
	case 59: goto L1898;
	case 61: goto L1897;
	case 62: goto L1899;
	case 89: goto L1852;
	case 90: goto L1910;
	case 91: goto L1858;
	case 92: goto L1859;
	case 93: goto L1860;
	case 94: goto L1861;
	case 95: goto L1862;
	case 96: goto L1863;
	case 97: goto L1864;
	case 98: goto L1865;
	case 99: goto L1866;
	case 100: goto L1867;
	case 101: goto L1868;
	case 102: goto L1869;
	case 103: goto L1870;
	case 104: goto L1871;
	case 105: goto L1872;
	case 106: goto L1873;
	case 107: case 108: case 109: case 110: goto L1874;
	case 111: goto L1876;
	case 112: goto L1877;
	case 113: goto L1875;
	case 114: case 115: goto L1878;
	case 116: case 117: goto L1879;
	case 118: goto L1880;
	case 119: goto L1881;
	case 120: goto L1882;
	case 121: goto L1883;
	case 122: goto L1912;
	default: goto L1846;
    };
// SWITCH
L1847:
	asu64(R1) = p;
	mm_blockpcl_do_const(asu64(R1));
	goto L1844;
L1848:
	goto L1844;
L1849:
	asu64(R1) = p;
	mm_blockpcl_do_name(asu64(R1));
	goto L1844;
L1850:
	asu64(R1) = p;
	mm_blockpcl_do_block(asu64(R1));
	goto L1844;
L1851:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_callproc(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1852:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_return(asu64(R2), asu64(R1));
	goto L1844;
L1853:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_returnmult(asu64(R2), asu64(R1));
	goto L1844;
L1854:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_assign(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1855:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignms(asu64(R2), asu64(R1));
	goto L1844;
L1856:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignmm(asu64(R2), asu64(R1));
	goto L1844;
L1857:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignmdrem(asu64(R2), asu64(R1));
	goto L1844;
L1858:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_to(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1859:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_if(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L1844;
L1860:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_for(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L1844;
L1861:
	R1 = 1;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_for(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L1844;
L1862:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_forall(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L1844;
L1863:
	R1 = 1;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_forall(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L1844;
L1864:
	asu64(R1) = c;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_blockpcl_do_while(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1865:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_repeat(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1866:
	asu64(R1) = a;
	mm_blockpcl_do_goto(asu64(R1));
	goto L1844;
L1867:
	asu64(R1) = p;
	mm_blockpcl_do_labeldef(asu64(R1));
	goto L1844;
L1868:
	R1 = 1;
	asu64(R2) = p;
	mm_blockpcl_do_exit(asu64(R2), asi64(R1));
	goto L1844;
L1869:
	R1 = 2;
	asu64(R2) = p;
	mm_blockpcl_do_exit(asu64(R2), asi64(R1));
	goto L1844;
L1870:
	R1 = 3;
	asu64(R2) = p;
	mm_blockpcl_do_exit(asu64(R2), asi64(R1));
	goto L1844;
L1871:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_do(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1872:
	R1 = 0;
	R2 = 0;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_blockpcl_do_case(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L1844;
L1873:
	R1 = 0;
	R2 = 1;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_blockpcl_do_case(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L1844;
L1874:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_switch(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L1844;
L1875:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_recase(asu64(R2), asu64(R1));
	goto L1844;
L1876:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_swap(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1877:
	R1 = 0;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_select(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L1844;
L1878:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_print(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1879:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_print(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1880:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_read(asu64(R2), asu64(R1));
	goto L1844;
L1881:
	asu64(R1) = a;
	mm_blockpcl_do_readln(asu64(R1));
	goto L1844;
L1882:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_stop(asu64(R2), asu64(R1));
	goto L1844;
L1883:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 134;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	goto L1844;
L1884:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_andl(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1885:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_orl(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1886:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_setcc(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1887:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_setccchain(asu64(R2), asu64(R1));
	goto L1844;
L1888:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_bin(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1889:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_index(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1890:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_dotindex(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1891:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_dotslice(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1892:
	asu64(R1) = p;
	mm_blockpcl_do_dot(asu64(R1));
	goto L1844;
L1893:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_ptr(asu64(R2), asu64(R1));
	goto L1844;
L1894:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L1844;
L1895:
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L1844;
L1896:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_convert(asu64(R2), asu64(R1));
	goto L1844;
L1897:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_typepun(asu64(R2), asu64(R1));
	goto L1844;
L1898:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_shorten(asu64(R2), asu64(R1));
	goto L1844;
L1899:
	asu64(R1) = p;
	mm_blockpcl_do_typeconst(asu64(R1));
	goto L1844;
L1900:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_unary(asu64(R2), asu64(R1));
	goto L1844;
L1901:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_notl(asu64(R2), asu64(R1));
	goto L1844;
L1902:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_istruel(asu64(R2), asu64(R1));
	goto L1844;
L1903:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_isfalsel(asu64(R2), asu64(R1));
	goto L1844;
L1904:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L1907;
	R2 = 85;
	if (asi64(R1) != asi64(R2)) goto L1906;
L1907:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_incr(asu64(R2), asu64(R1));
	goto L1905;
L1906:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_incrload(asu64(R2), asu64(R1));
L1905:
	goto L1844;
L1908:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_binto(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1909:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_unaryto(asu64(R2), asu64(R1));
	goto L1844;
L1910:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_syscall(asu64(R2), asu64(R1));
	goto L1844;
L1911:
	asu64(R1) = p;
	asu64(R1) = pc_api_genassem(asu64(R1));
	R2 = 42;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	goto L1844;
L1912:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_blockpcl_do_empty(asu64(R2), asu64(R1));
	goto L1844;
L1913:
	R1 = tou64(" ");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc_api_gencomment(asu64(R1));
	goto L1844;
L1914:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_slice(asu64(R3), asu64(R2), asu64(R1));
	goto L1844;
L1846:
	R1 = 0;
	R2 = (u64)&mm_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("UNSUPPORTED TAG ");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L1841;
L1844:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L1916;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1916;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1918;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L1918;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L1918;
	goto L1919;
L1918:
	goto L1917;
L1919:
	R1 = (u64)&mm_tables_jsolo;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L1921;
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	mm_diags_dummy_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mm_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("NOT ALLOWED BY ITSELF:");
	asu64(R2) = pc_api_addstr(asu64(R3), asu64(R2));
	mm_support_gerror(asu64(R2), asu64(R1));
L1921:
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L1917:
L1916:
L1841:
	return;
}

static void mm_blockpcl_evalref(u64 p, u64 q) {
    u64 R1, R2, R3, R4, R5; 
	u64 a;
	u64 b;
	u64 c;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	c = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L1924;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L1925;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L1926;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L1927;
	goto L1928;
L1924:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushmemaddr_d(asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = q;
	if (!asu64(R1)) goto L1930;
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 17;
	mm_libpcl_setmode(asi64(R1));
L1930:
	goto L1923;
L1925:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_indexref(asu64(R2), asu64(R1));
	goto L1923;
L1926:
	asu64(R1) = p;
	mm_blockpcl_do_dotref(asu64(R1));
	goto L1923;
L1927:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	goto L1923;
L1928:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L1932;
	goto L1933;
L1932:
	R1 = 1;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_blockpcl_do_if(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L1931;
L1933:
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	mm_diags_dummy_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = tou64("evalref");
	mm_support_gerror(asu64(R2), asu64(R1));
L1931:
L1923:
	return;
}

static void mm_blockpcl_evalarray(u64 p) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L1936;
	goto L1937;
L1936:
	R1 = 0;
	asu64(R2) = p;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 2;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L1935;
L1937:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L1939;
	asu64(R1) = p;
	mm_blockpcl_evalunit(asu64(R1));
	goto L1938;
L1939:
	R1 = 0;
	asu64(R2) = p;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
L1938:
L1935:
	return;
}

static void mm_blockpcl_do_block(u64 p) {
    u64 R1, R2; 
	u64 a;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L1942;
L1941:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L1942:
	asu64(R1) = a;
	if (asu64(R1)) goto L1941;
	return;
}

static void mm_blockpcl_genjumpcond(i64 opc, u64 p, i64 lab) {
    u64 R1, R2, R3, R4, R5; 
	u64 q;
	u64 r;
	u64 s;
	i64 lab2;
	i64 i;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L1946;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L1947;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L1948;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L1948;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L1949;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L1950;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L1951;
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L1952;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L1953;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L1954;
	goto L1955;
L1946:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1957;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L1958;
	goto L1959;
L1957:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L1956;
L1958:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	goto L1956;
L1959:
L1956:
	goto L1945;
L1947:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1961;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L1962;
	goto L1963;
L1961:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = q;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	goto L1960;
L1962:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab;
	asu64(R2) = r;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L1960;
L1963:
L1960:
	goto L1945;
L1948:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L1965;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L1966;
	goto L1967;
L1965:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L1964;
L1966:
	asi64(R1) = lab;
	asu64(R2) = q;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L1964;
L1967:
L1964:
	goto L1945;
L1949:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L1945;
L1950:
	goto L1969;
L1968:
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L1969:
	asu64(R1) = q;
	if (!asu64(R1)) goto L1971;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L1968;
L1971:
	asi64(R1) = lab;
	asu64(R2) = q;
	asi64(R3) = opc;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	goto L1945;
L1951:
	asi64(R1) = lab;
	asu64(R2) = r;
	asu64(R3) = q;
	asu64(R4) = p;
	R5 = 64;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asi64(R5) = opc;
	mm_blockpcl_gcomparejump(asi64(R5), asi64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L1945;
L1952:
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = opc;
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L1973;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab2;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 3;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 4;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	goto L1972;
L1973:
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 3;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = r;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 6;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
L1972:
	goto L1945;
L1953:
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L1975;
	R1 = 0;
	R2 = tou64("empty set");
	mm_support_gerror(asu64(R2), asu64(R1));
L1975:
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L1977;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	goto L1979;
L1978:
	asu64(R1) = s;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = s;
	if (!asu64(R1)) goto L1982;
	asi64(R1) = lab2;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1981;
L1982:
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 2;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L1981:
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
L1979:
	asu64(R1) = s;
	if (asu64(R1)) goto L1978;
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	goto L1976;
L1977:
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	goto L1986;
L1983:
	asu64(R1) = s;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1988;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L1988:
	asu64(R1) = s;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
L1986:
	asu64(R1) = s;
	if (asu64(R1)) goto L1983;
L1976:
	goto L1945;
L1954:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = opc;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L1990;
	goto L1992;
L1991:
	asu64(R1) = r;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L1995;
	R1 = 0;
	R2 = 2;
	R3 = 1;
	R4 = 10;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asu64(R2) = p;
	R3 = 40;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R2) = mm_genpcl_reversecond(asi64(R2));
	asi64(R2) = mm_genpcl_reversecond_order(asi64(R2));
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1994;
L1995:
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asu64(R2) = p;
	R3 = 40;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R2) = mm_genpcl_reversecond(asi64(R2));
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L1994:
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	q = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L1992:
	asu64(R1) = r;
	if (asu64(R1)) goto L1991;
	goto L1989;
L1990:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	goto L1997;
L1996:
	asu64(R1) = r;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2000;
	R1 = 0;
	R2 = 2;
	R3 = 1;
	R4 = 10;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = lab2;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asu64(R2) = p;
	R3 = 40;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R2) = mm_genpcl_reversecond(asi64(R2));
	asi64(R2) = mm_genpcl_reversecond_order(asi64(R2));
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L1999;
L2000:
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asu64(R2) = p;
	R3 = 40;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L1999:
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	q = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L1997:
	asu64(R1) = r;
	if (asu64(R1)) goto L1996;
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
L1989:
	goto L1945;
L1955:
	asu64(R1) = p;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = opc;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = (u64)&mm_decls_ttisblock;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2002;
	R1 = 0;
	R2 = tou64("jumpt/f");
	mm_support_gerror(asu64(R2), asu64(R1));
L2002:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
L1945:
	return;
}

static void mm_blockpcl_gcomparejump(i64 jumpopc, i64 cond, u64 lhs, u64 rhs, i64 lab) {
    u64 R1, R2, R3; 
	asi64(R1) = jumpopc;
	R2 = 28;
	if (asi64(R1) != asi64(R2)) goto L2005;
	asi64(R1) = cond;
	asi64(R1) = mm_genpcl_reversecond(asi64(R1));
	cond = asi64(R1);
L2005:
	asu64(R1) = lhs;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = rhs;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = cond;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = lhs;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_genjumpl(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_blockpcl_unimpl(u64 mess) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = mess;
	R3 = tou64("Unimplemented: #");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_blockpcl_do_const(u64 p) {
    u64 R1, R2, R3; 
	i64 mode;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mode = asi64(R1);
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2011;
	asi64(R1) = mode;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L2010;
L2011:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushint(asi64(R1));
	goto L2009;
L2010:
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2012;
	asi64(R1) = mode;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	mm_genpcl_genpushreal(asr64(R2), asi64(R1));
	goto L2009;
L2012:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = mode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2013;
	asu64(R1) = p;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2015;
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 66;
	if (asu64(R1) != asu64(R2)) goto L2017;
	R1 = 0;
	R2 = tou64("1:B-str?");
	mm_support_gerror(asu64(R2), asu64(R1));
L2017:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushstring(asu64(R1));
	goto L2014;
L2015:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushint(asi64(R1));
L2014:
	goto L2009;
L2013:
	R1 = 0;
	R2 = tou64("do_const");
	mm_support_gerror(asu64(R2), asu64(R1));
L2009:
	asi64(R1) = mode;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_name(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2020;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L2020;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L2021;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L2022;
	goto L2023;
L2020:
	asu64(R1) = d;
	mm_genpcl_genpushmemaddr_d(asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L2019;
L2021:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2025;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L2025:
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2027;
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L2026;
L2027:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2026:
	goto L2019;
L2022:
	asu64(R1) = d;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_genpcl_genpushint(asi64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L2019;
L2023:
	asu64(R1) = d;
	mm_genpcl_genpushmem_d(asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
L2019:
	return;
}

static void mm_blockpcl_do_stop(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L2030;
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	goto L2029;
L2030:
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
L2029:
	R1 = 0;
	R2 = 32;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_blockpcl_do_andl(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 labfalse;
	i64 labend;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	labfalse = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	labend = asi64(R1);
	asi64(R1) = labfalse;
	asu64(R2) = a;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = labfalse;
	asu64(R2) = b;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	R1 = 1;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labend;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = labfalse;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labend;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_orl(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 labtrue;
	i64 labfalse;
	i64 labend;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	labtrue = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	labfalse = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	labend = asi64(R1);
	asi64(R1) = labtrue;
	asu64(R2) = a;
	R3 = 27;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = labfalse;
	asu64(R2) = b;
	R3 = 28;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = labtrue;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 1;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labend;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = labfalse;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labend;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_notl(u64 p, u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_istruel(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 64;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode2(asi64(R1));
	return;
}

static void mm_blockpcl_do_isfalsel(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 65;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode2(asi64(R1));
	return;
}

static void mm_blockpcl_do_typepun(u64 p, u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2038;
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 92;
	R2 += (i64)R3;
	R3 = 5;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L2038:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	if (asi64(R1) != asi64(R2)) goto L2040;
	goto L2036;
L2040:
	R1 = 0;
	R2 = 110;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 53;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode2(asi64(R1));
L2036:
	return;
}

static void mm_blockpcl_do_shorten(u64 p, u64 a) {
    u64 R1; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	return;
}

static void mm_blockpcl_do_assign(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2044;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 168;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	if (asu16(R1)) goto L2044;
	goto L2042;
L2044:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L2046;
	goto L2047;
L2046:
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2049;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_blockpcl_do_assignblock(asu64(R3), asu64(R2), asu64(R1));
	goto L2042;
L2049:
	goto L2045;
L2047:
L2045:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L2051;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L2052;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L2053;
	goto L2054;
L2051:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = p;
	mm_blockpcl_do_storeindex(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L2042;
	goto L2050;
L2052:
	R1 = 0;
	R2 = tou64("ASS/SLICE");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L2050;
L2053:
	asu64(R1) = b;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	mm_blockpcl_do_storedot(asu64(R3), asu64(R2), asu64(R1));
	goto L2042;
	goto L2050;
L2054:
L2050:
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2056;
	R1 = 0;
	R2 = 9;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2056:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2058;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L2059;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L2060;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L2061;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L2062;
	goto L2063;
L2058:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2066;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L2066;
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L2065;
L2066:
	R1 = 0;
	R2 = tou64("Assign to proc?");
	mm_support_gerror(asu64(R2), asu64(R1));
L2065:
	asu64(R1) = a;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2057;
L2059:
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	goto L2057;
L2060:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 16;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_libpcl_setmode_u(asu64(R1));
	goto L2042;
	goto L2057;
L2061:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 17;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_libpcl_setmode_u(asu64(R1));
	goto L2042;
	goto L2057;
L2062:
	R1 = 1;
	asu64(R2) = a;
	R3 = 32;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = a;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asu64(R5) = a;
	mm_blockpcl_do_if(asu64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	goto L2057;
L2063:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Can't assign");
	mm_support_gerror(asu64(R2), asu64(R1));
L2057:
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
L2042:
	return;
}

static void mm_blockpcl_do_bin(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L2070;
	R2 = 58;
	if (asi64(R1) != asi64(R2)) goto L2069;
L2070:
	R1 = 0;
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = a;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asu64(R3) = p;
	R4 = 62;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	goto L2068;
L2069:
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L2072;
	R1 = 0;
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = a;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
L2072:
L2068:
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_setcc(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 64;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 31;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_setccchain(u64 p, u64 q) {
    u64 R1, R2, R3, R4; 
	i64 lab1;
	i64 lab2;
	i64 i;
	i64 cond;
	u64 r;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab1 = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	goto L2076;
L2075:
	asu64(R1) = r;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = p;
	R2 = 40;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	asi64(R1) = mm_genpcl_reversecond(asi64(R1));
	cond = asi64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2079;
	R1 = 0;
	R2 = 2;
	R3 = 1;
	R4 = 10;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = cond;
	asi64(R1) = mm_genpcl_reversecond_order(asi64(R1));
	cond = asi64(R1);
L2079:
	asi64(R1) = lab1;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = cond;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2081;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L2081:
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asu64(R1) = r;
	q = asu64(R1);
	asu64(R1) = r;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
L2076:
	asu64(R1) = r;
	if (asu64(R1)) goto L2075;
	R1 = 1;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = lab2;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = lab1;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_binto(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	R1 = (u64)&mm_decls_ttisref;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2084;
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2084;
	R1 = 0;
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = a;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
L2084:
	return;
}

static void mm_blockpcl_do_unary(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 adj;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2087;
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2089;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2089;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2090;
	goto L2091;
L2089:
	R1 = 8;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2093;
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	adj = asi64(R1);
	asi64(R1) = adj;
	if (!asi64(R1)) goto L2095;
	asi64(R1) = adj;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 43;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
L2095:
L2093:
	goto L2088;
L2090:
	R1 = 0;
	R2 = 2;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L2088;
L2091:
L2088:
	goto L2085;
L2087:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
L2085:
	return;
}

static void mm_blockpcl_do_unaryto(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_ptr(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 2;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_labeldef(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	struct $B16 str;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2100;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L2100:
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmemaddr_d(asu64(R1));
	R2 = 128;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_blockpcl_do_goto(u64 a) {
    u64 R1, R2, R3; 
	u64 d;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2103;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L2103;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2105;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L2105:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2102;
L2103:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 25;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2102:
	return;
}

static void mm_blockpcl_do_do(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 lab_abc;
	i64 lab_d;
	asi64(R1) = mm_genpcl_definelabel();
	lab_abc = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_abc;
	asi64(R3) = lab_abc;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_abc;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_to(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 cvar;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 count;
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	cvar = asu64(R1);
	R1 = 3;
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = cvar;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2109;
	asu64(R1) = cvar;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = mm_genpcl_pzero;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_d;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 4;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L2108;
L2109:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	count = asi64(R1);
	asi64(R1) = count;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L2111;
	asi64(R1) = lab_d;
	mm_blockpcl_genjumpl(asi64(R1));
L2111:
L2108:
	asi64(R1) = lab_b;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 33;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = cvar;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_while(u64 p, u64 pcond, u64 pbody, u64 pincr) {
    u64 R1, R2, R3; 
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_incr;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pincr;
	if (!asu64(R1)) goto L2114;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_incr = asi64(R1);
	goto L2113;
L2114:
	asi64(R1) = lab_c;
	lab_incr = asi64(R1);
L2113:
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = lab_incr;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_b;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pbody;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pincr;
	if (!asu64(R1)) goto L2116;
	asu64(R1) = pincr;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_incr;
	mm_genpcl_definefwdlabel(asi64(R1));
L2116:
	asi64(R1) = lab_b;
	asu64(R2) = pcond;
	R3 = 27;
	mm_blockpcl_docond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_repeat(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 lab_ab;
	i64 lab_c;
	i64 lab_d;
	asi64(R1) = mm_genpcl_definelabel();
	lab_ab = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_ab;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2120;
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2119;
L2120:
	asi64(R1) = lab_ab;
	asu64(R2) = b;
	R3 = 28;
	mm_blockpcl_docond(asi64(R3), asu64(R2), asi64(R1));
L2119:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_exit(u64 p, i64 k) {
    u64 R1, R2; 
	i64 n;
	i64 index;
	asu64(R1) = p;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	index = asi64(R1);
	asi64(R1) = index;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2123;
	asi64(R1) = mm_genpcl_loopindex;
	index = asi64(R1);
L2123:
	asi64(R1) = index;
	asi64(R2) = k;
	asi64(R1) = mm_genpcl_findlooplabel(asi64(R2), asi64(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2125;
	asu64(R1) = p;
	R2 = tou64("Bad exit/loop index");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L2124;
L2125:
	asi64(R1) = n;
	mm_blockpcl_genjumpl(asi64(R1));
L2124:
	return;
}

static void mm_blockpcl_do_if(u64 p, u64 pcond, u64 plist, u64 pelse, i64 isref) {
    u64 R1, R2, R3; 
	i64 labend;
	i64 i;
	i64 lab2;
	i64 ismult;
	asi64(R1) = mm_genpcl_createfwdlabel();
	labend = asi64(R1);
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	ismult = asi64(R1);
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L2128;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2128:
	goto L2132;
L2129:
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab2 = asi64(R1);
	asi64(R1) = lab2;
	asu64(R2) = pcond;
	R3 = 28;
	mm_blockpcl_docond(asi64(R3), asu64(R2), asi64(R1));
	asi64(R1) = isref;
	if (!asi64(R1)) goto L2134;
	R1 = 0;
	asu64(R2) = plist;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L2133;
L2134:
	asu64(R1) = plist;
	mm_blockpcl_evalunit(asu64(R1));
L2133:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L2136;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L2136:
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L2139;
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L2138;
L2139:
	asi64(R1) = labend;
	mm_blockpcl_genjumpl(asi64(R1));
L2138:
	asi64(R1) = lab2;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcond = asu64(R1);
	asu64(R1) = plist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plist = asu64(R1);
L2132:
	asu64(R1) = pcond;
	if (asu64(R1)) goto L2129;
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L2141;
	asi64(R1) = isref;
	if (!asi64(R1)) goto L2143;
	R1 = 0;
	asu64(R2) = pelse;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L2142;
L2143:
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L2142:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L2145;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L2145:
L2141:
	asi64(R1) = labend;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_return(u64 p, u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L2148;
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = mm_genpcl_retindex;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 29;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	goto L2147;
L2148:
	asi64(R1) = mm_genpcl_retindex;
	mm_blockpcl_genjumpl(asi64(R1));
L2147:
	return;
}

static void mm_blockpcl_do_returnmult(u64 p, u64 a) {
    u64 R1, R2, R3; 
	struct $B76 params;
	u64 q;
	i64 nparams;
	i64 i;
	asu64(R1) = a;
	q = asu64(R1);
	R1 = 0;
	nparams = asi64(R1);
	goto L2151;
L2150:
	asi64(R1) = nparams;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L2154;
	R1 = 0;
	R2 = tou64("Mult?");
	mm_support_gerror(asu64(R2), asu64(R1));
L2154:
	asu64(R1) = q;
	R2 = (u64)&params;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L2151:
	asu64(R1) = q;
	if (asu64(R1)) goto L2150;
	asi64(R1) = nparams;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2157;
L2155:
	R1 = (u64)&params;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_blockpcl_evalunit(asu64(R1));
	i += -1; if (i >= 1) goto L2155;
L2157:
	asi64(R1) = mm_genpcl_retindex;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 30;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = nparams;
	pc_api_pc_setnargs(asi64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_blockpcl_do_callproc(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	struct $B76 paramlist;
	struct $B5 argattr;
	i64 nparams;
	i64 isptr;
	i64 nvariadics;
	i64 nret;
	i64 isfn;
	i64 iparams;
	i64 fparams;
	i64 nfixedparams;
	u64 d;
	u64 e;
	u64 pmult;
	u64 q;
	i64 i;
	R1 = 0;
	isptr = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2160;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L2161;
	goto L2162;
L2160:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L2159;
L2161:
	R1 = (u64)&mm_decls_ttnamedef;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 1;
	isptr = asi64(R1);
	goto L2159;
L2162:
	R1 = 0;
	R2 = tou64("call/not ptr");
	mm_support_gerror(asu64(R2), asu64(R1));
L2159:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	isfn = asi64(R1);
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	nvariadics = asi64(R1);
	asu64(R1) = b;
	q = asu64(R1);
	R1 = 0;
	nfixedparams = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L2166;
L2163:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L2168;
	R1 = (u64)&nfixedparams;
	(*toi64p(R1)) += 1;
L2168:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L2166:
	asu64(R1) = e;
	if (asu64(R1)) goto L2163;
	asu64(R1) = b;
	q = asu64(R1);
	goto L2172;
L2169:
	asi64(R1) = nparams;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L2174;
	R1 = 0;
	R2 = tou64("maxparams");
	mm_support_gerror(asu64(R2), asu64(R1));
L2174:
	asu64(R1) = q;
	R2 = (u64)&paramlist;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = d;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2176;
	asi64(R1) = nparams;
	asi64(R2) = nfixedparams;
	if (asi64(R1) < asi64(R2)) goto L2176;
	asi64(R1) = nparams;
	R2 = 4;
	if (asi64(R1) > asi64(R2)) goto L2176;
	asi64(R1) = nvariadics;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2176;
	asi64(R1) = nparams;
	nvariadics = asi64(R1);
L2176:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L2172:
	asu64(R1) = q;
	if (asu64(R1)) goto L2169;
	R1 = 0;
	R2 = 131;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asi64(R1) = nparams;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = R1;
	fparams = asi64(R2);
	iparams = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2179;
L2177:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	R1 = 0;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2182;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2181;
L2182:
	R1 = (u64)&fparams;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L2184;
	R1 = 2;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
L2184:
	goto L2180;
L2181:
	R1 = (u64)&iparams;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L2186;
	R1 = 2;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
L2186:
L2180:
	i += 1; if (i <= nparams) goto L2177;
L2179:
	asi64(R1) = fparams;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L2188;
	asi64(R1) = iparams;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L2188;
	R1 = 0;
	R2 = tou64("Mixed stack args");
	mm_support_gerror(asu64(R2), asu64(R1));
L2188:
	asi64(R1) = fparams;
	asi64(R2) = iparams;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	R2 = 8;
	asi64(R1) -= asi64(R2);
	iparams = asi64(R1);
	asi64(R1) = nparams;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2191;
L2189:
	asi64(R1) = iparams;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2193;
	R1 = (u64)&argattr;
	asi64(R2) = i;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2-1));
	if (!asi8(R1)) goto L2193;
	R1 = 1;
	R2 = (u64)&argattr;
	asi64(R3) = i;
	*toi8p(((i64)R2+(i64)R3-1)) = asi8(R1);
	R1 = 0;
	iparams = asi64(R1);
L2193:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = nvariadics;
	if (!asi64(R1)) goto L2195;
	asi64(R1) = i;
	asi64(R2) = nvariadics;
	if (asi64(R1) < asi64(R2)) goto L2195;
	asu64(R1) = pc_api_pccurr;
	R2 = 3;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2195;
	R1 = 0;
	R2 = 115;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 8;
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 2;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 28;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 7;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	R1 = 0;
	R2 = 132;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 1;
	mm_libpcl_setmode(asi64(R1));
	goto L2194;
L2195:
	R1 = 0;
	R2 = 132;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = q;
	mm_libpcl_setmode_u(asu64(R1));
L2194:
	asi64(R1) = i;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&argattr;
	asi64(R2) = i;
	asi8(R1) = *toi8p(((i64)R1+(i64)R2-1));
	R1 = toi64(toi8(R1));
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	i += -1; if (i >= 1) goto L2189;
L2191:
	asi64(R1) = isptr;
	if (asi64(R1)) goto L2197;
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmemaddr_d(asu64(R1));
	asi64(R2) = isfn;
	if (!asi64(R2)) goto L2199;
	R2 = 21;
	goto L2198;
L2199:
	R2 = 18;
L2198:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2196;
L2197:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	asi64(R2) = isfn;
	if (!asi64(R2)) goto L2201;
	R2 = 22;
	goto L2200;
L2201:
	R2 = 19;
L2200:
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2196:
	asi64(R1) = nparams;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = nvariadics;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = isfn;
	if (!asi64(R1)) goto L2203;
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L2203:
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L2205;
	asi64(R1) = isfn;
	if (!asi64(R1)) goto L2205;
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nret = asi64(R1);
	R1 = (u64)&mm_decls_ttmult;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pmult = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nret;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2208;
L2206:
	R1 = 0;
	R2 = 13;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pmult;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	i += 1; if (i <= nret) goto L2206;
L2208:
L2205:
	asi64(R1) = isfn;
	if (!asi64(R1)) goto L2210;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L2210;
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L2210:
	return;
}

static void mm_blockpcl_do_print(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	u64 q;
	u64 r;
	u64 fmt;
	i64 m;
	i64 fn;
	i64 needprintend;
	asu64(R1) = a;
	if (!asu64(R1)) goto L2213;
	R1 = 1;
	needprintend = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L2215;
	R1 = 0;
	R2 = tou64("@dev no ref");
	mm_support_gerror(asu64(R2), asu64(R1));
L2215:
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2217;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L2218;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L2219;
	goto L2220;
L2217:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 2;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L2216;
L2218:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 3;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L2216;
L2219:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 4;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L2216;
L2220:
	R1 = 0;
	R2 = tou64("@dev?");
	mm_support_gerror(asu64(R2), asu64(R1));
L2216:
	goto L2212;
L2213:
	R1 = 1;
	needprintend = asi64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 5;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L2212:
	asu64(R1) = b;
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L2222;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L2222;
	goto L2223;
L2222:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L2226;
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = q;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L2225;
L2226:
	R1 = 0;
	R2 = tou64("string expected");
	mm_support_gerror(asu64(R2), asu64(R1));
L2225:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = q;
	R5 = 6;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L2221;
L2223:
L2221:
	goto L2228;
L2227:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L2231;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L2232;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L2233;
	goto L2234;
L2231:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	fmt = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = r;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	goto L2230;
L2232:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 7;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L2228;
	goto L2230;
L2233:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 8;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L2228;
	goto L2230;
L2234:
	R1 = 0;
	fmt = asu64(R1);
	asu64(R1) = q;
	r = asu64(R1);
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
L2230:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2236;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2237;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2238;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2239;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L2240;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2241;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2242;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2243;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2244;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2245;
	goto L2246;
L2236:
	R1 = 9;
	fn = asi64(R1);
	asu64(R1) = fmt;
	if (asu64(R1)) goto L2248;
	R1 = 10;
	fn = asi64(R1);
L2248:
	goto L2235;
L2237:
	R1 = 11;
	fn = asi64(R1);
	goto L2235;
L2238:
	R1 = 13;
	fn = asi64(R1);
	goto L2235;
L2239:
	R1 = 12;
	fn = asi64(R1);
	goto L2235;
L2240:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L2251;
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L2250;
	R1 = (u64)&mm_decls_tttarget;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L2250;
L2251:
	R1 = 14;
	fn = asi64(R1);
	asu64(R1) = fmt;
	if (asu64(R1)) goto L2253;
	R1 = 15;
	fn = asi64(R1);
L2253:
	goto L2249;
L2250:
	R1 = 17;
	fn = asi64(R1);
	asu64(R1) = fmt;
	if (asu64(R1)) goto L2255;
	R1 = 18;
	fn = asi64(R1);
L2255:
L2249:
	goto L2235;
L2241:
	R1 = 20;
	fn = asi64(R1);
	goto L2235;
L2242:
	R1 = 0;
	R2 = tou64("PRINTARRAY");
	mm_support_gerror(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L2235;
L2243:
	R1 = 0;
	R2 = tou64("PRINTRECORD");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L2235;
L2244:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L2257;
	R1 = 16;
	fn = asi64(R1);
	goto L2256;
L2257:
	R1 = 0;
	R2 = tou64("PRINTSLICE");
	mm_support_gerror(asu64(R2), asu64(R1));
L2256:
	goto L2235;
L2245:
	R1 = 19;
	fn = asi64(R1);
	goto L2235;
L2246:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = 1;
	asi64(R3) = m;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("PRINT/T=#");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L2235:
	asi64(R1) = fn;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2259;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L2259;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L2259;
	goto L2260;
L2259:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = r;
	asi64(R5) = fn;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L2258;
L2260:
	R1 = 0;
	R2 = 0;
	asu64(R3) = fmt;
	if (!asu64(R3)) goto L2262;
	asu64(R3) = fmt;
	goto L2261;
L2262:
	asu64(R3) = mm_genpcl_pzero;
L2261:
	asu64(R4) = r;
	asi64(R5) = fn;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L2258:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L2228:
	asu64(R1) = q;
	if (asu64(R1)) goto L2227;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 115;
	if (asi64(R1) == asi64(R2)) goto L2264;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L2264;
	goto L2265;
L2264:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 21;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L2263;
L2265:
L2263:
	asi64(R1) = needprintend;
	if (!asi64(R1)) goto L2267;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 22;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L2267:
	return;
}

static void mm_blockpcl_do_incr(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_blockpcl_setincrstep(asi64(R1));
	return;
}

static void mm_blockpcl_setincrstep(i64 m) {
    u64 R1, R2, R3; 
	R1 = 1;
	pc_api_pc_setincr(asi64(R1));
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2271;
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	pc_api_pc_setincr(asi64(R1));
L2271:
	return;
}

static void mm_blockpcl_do_incrload(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_blockpcl_setincrstep(asi64(R1));
	return;
}

static void mm_blockpcl_do_for(u64 p, u64 pindex, u64 pfrom, u64 pbody, i64 down) {
    u64 R1, R2, R3; 
	u64 pto;
	u64 pstep;
	u64 pelse;
	u64 px;
	u64 ptoinit;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_e;
	i64 a;
	i64 b;
	i64 stepx;
	u64 d;
	asu64(R1) = pfrom;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	asu64(R1) = pto;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pstep = asu64(R1);
	asu64(R1) = pbody;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ptoinit = asu64(R1);
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 53;
	if (asi64(R1) != asi64(R2)) goto L2275;
	asu64(R1) = pto;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	px = asu64(R1);
	asu64(R1) = px;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L2277;
	asu64(R1) = px;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	d = asu64(R2);
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L2277;
	asu64(R1) = d;
	R2 = 160;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2277;
	R1 = 0;
	R2 = tou64("Possibly using &param as for-loop limit");
	mm_support_gerror(asu64(R2), asu64(R1));
L2277:
L2275:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L2279;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_e = asi64(R1);
	goto L2278;
L2279:
	asi64(R1) = lab_d;
	lab_e = asi64(R1);
L2278:
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pindex;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = ptoinit;
	if (!asu64(R1)) goto L2281;
	R1 = 0;
	asu64(R2) = ptoinit;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = ptoinit;
	mm_blockpcl_evalunit(asu64(R1));
L2281:
	asu64(R1) = pfrom;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2283;
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2283;
	asu64(R1) = pfrom;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	asi64(R1) = down;
	if (!asi64(R1)) goto L2287;
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) >= asi64(R2)) goto L2286;
L2287:
	asi64(R1) = down;
	if (asi64(R1)) goto L2285;
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L2285;
L2286:
	goto L2284;
L2285:
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2284:
	goto L2282;
L2283:
	asu64(R1) = pfrom;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2289;
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = down;
	if (!asi64(R2)) goto L2291;
	R2 = 6;
	goto L2290;
L2291:
	R2 = 3;
L2290:
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	goto L2288;
L2289:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = down;
	if (!asi64(R2)) goto L2293;
	R2 = 3;
	goto L2292;
L2293:
	R2 = 6;
L2292:
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L2288:
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
L2282:
	asi64(R1) = lab_b;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pbody;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pstep;
	if (!asu64(R1)) goto L2295;
	asu64(R1) = pstep;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2297;
	R1 = 0;
	R2 = tou64("for/step non-const not ready");
	mm_support_gerror(asu64(R2), asu64(R1));
L2297:
	asu64(R1) = pstep;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	stepx = asi64(R1);
	asi64(R1) = stepx;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L2299;
	R1 = 0;
	R2 = tou64("Bad for-step");
	mm_support_gerror(asu64(R2), asu64(R1));
L2299:
	asi64(R1) = lab_b;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = stepx;
	asi64(R3) = down;
	if (!asi64(R3)) goto L2301;
	R3 = 35;
	goto L2300;
L2301:
	R3 = 34;
L2300:
	pc_api_pc_genx(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
	goto L2294;
L2295:
	asi64(R1) = lab_b;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	asi64(R3) = down;
	if (!asi64(R3)) goto L2303;
	R3 = 35;
	goto L2302;
L2303:
	R3 = 34;
L2302:
	pc_api_pc_genx(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
L2294:
	asu64(R1) = pindex;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2305;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2306;
	goto L2307;
L2305:
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L2304;
L2306:
	asu64(R1) = pto;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L2304;
L2307:
L2304:
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L2309;
	asi64(R1) = lab_e;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L2309:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_forall(u64 p, u64 pindex, u64 plist, u64 pbody, i64 down) {
    u64 R1, R2, R3; 
	u64 plocal;
	u64 pfrom;
	u64 pto;
	u64 pelse;
	u64 passign;
	i64 lab_b;
	i64 lab_c;
	i64 lab_d;
	i64 lab_e;
	i64 a;
	i64 b;
	u64 dto;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plocal = asu64(R1);
	asu64(R1) = plocal;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfrom = asu64(R1);
	asu64(R1) = pfrom;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	asu64(R1) = plist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	passign = asu64(R1);
	asu64(R1) = pbody;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pelse = asu64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_b = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_c = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L2312;
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_e = asi64(R1);
	goto L2311;
L2312:
	asi64(R1) = lab_d;
	lab_e = asi64(R1);
L2311:
	asi64(R1) = lab_d;
	asi64(R2) = lab_c;
	asi64(R3) = lab_b;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pindex;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2314;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2314;
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 11;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	dto = asu64(R1);
	asu64(R1) = dto;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = dto;
	asu64(R1) = mm_lib_createname(asu64(R1));
	pto = asu64(R1);
	asu64(R1) = dto;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pto;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = pto;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2314:
	asu64(R1) = pfrom;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2316;
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2316;
	asu64(R1) = pfrom;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
	asi64(R1) = down;
	if (!asi64(R1)) goto L2320;
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) >= asi64(R2)) goto L2319;
L2320:
	asi64(R1) = down;
	if (asi64(R1)) goto L2318;
	asi64(R1) = a;
	asi64(R2) = b;
	if (asi64(R1) > asi64(R2)) goto L2318;
L2319:
	goto L2317;
L2318:
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 24;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2317:
	goto L2315;
L2316:
	asu64(R1) = pfrom;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2322;
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = down;
	if (!asi64(R2)) goto L2324;
	R2 = 6;
	goto L2323;
L2324:
	R2 = 3;
L2323:
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	goto L2321;
L2322:
	asu64(R1) = pfrom;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pto;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_e;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = down;
	if (!asi64(R2)) goto L2326;
	R2 = 3;
	goto L2325;
L2326:
	R2 = 6;
L2325:
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
L2321:
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
L2315:
	asi64(R1) = lab_b;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R2) = passign;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = passign;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pbody;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = lab_c;
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = lab_b;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	asi64(R3) = down;
	if (!asi64(R3)) goto L2328;
	R3 = 35;
	goto L2327;
L2328:
	R3 = 34;
L2327:
	pc_api_pc_genx(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = pindex;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = pindex;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2330;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2331;
	goto L2332;
L2330:
	asu64(R1) = pto;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2329;
L2331:
	asu64(R1) = pto;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2329;
L2332:
	asu64(R1) = dto;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2329:
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L2334;
	asi64(R1) = lab_e;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L2334:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_convert(u64 p, u64 a) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L2337;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2338;
	goto L2339;
L2337:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	goto L2335;
	goto L2336;
L2338:
	R1 = 0;
	R2 = tou64("CONV/ERROR");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L2336;
L2339:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = (u64)&mm_tables_convtopcl;
	asu64(R3) = p;
	R4 = 62;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2336:
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = p;
	R2 = 53;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode2(asi64(R1));
L2335:
	return;
}

static void mm_blockpcl_do_swap(u64 p, u64 a, u64 b) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	asu64(R2) = b;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	mm_blockpcl_do_setinplace();
	R1 = 0;
	R2 = 36;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static i64 mm_blockpcl_checkdotchain(u64 p, u64 pname) {
    u64 R1, R2, R3; 
	i64 offset;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L2343;
	goto L2344;
L2343:
	asu64(R1) = pname;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mm_blockpcl_checkdotchain(asu64(R2), asu64(R1));
	offset = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = offset;
	asi64(R1) += asi64(R2);
	goto L2341;
	goto L2342;
L2344:
	asu64(R1) = p;
	asu64(R2) = pname;
	*tou64p(R2) = asu64(R1);
	R1 = 0;
	goto L2341;
L2342:
	R1 = 0;
	goto L2341;
L2341:
	return asi64(R1);
}

static void mm_blockpcl_do_dotref(u64 pdot) {
    u64 R1, R2, R3; 
	i64 imode;
	i64 offset;
	u64 a;
	u64 pname;
	R1 = 0;
	asu64(R2) = pdot;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	imode = asi64(R1);
	asu64(R1) = pdot;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 0;
	pname = asu64(R1);
	R1 = (u64)&pname;
	asu64(R2) = a;
	asi64(R1) = mm_blockpcl_checkdotchain(asu64(R2), asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pdot;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pname;
	a = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asi64(R1) = offset;
	if (!asi64(R1)) goto L2347;
	asi64(R1) = offset;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
L2347:
	asi64(R1) = imode;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_dot(u64 pdot) {
    u64 R1, R2, R3; 
	i64 offset;
	u64 a;
	u64 pname;
	asu64(R1) = pdot;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 0;
	pname = asu64(R1);
	R1 = (u64)&pname;
	asu64(R2) = a;
	asi64(R1) = mm_blockpcl_checkdotchain(asu64(R2), asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pdot;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pname;
	a = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asi64(R1) = offset;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pdot;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_storedot(u64 pdot, u64 pfield, u64 rhs) {
    u64 R1, R2, R3; 
	i64 offset;
	u64 a;
	u64 pname;
	asu64(R1) = rhs;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pdot;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2351;
	R1 = 0;
	R2 = 9;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2351:
	asu64(R1) = pdot;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = 0;
	pname = asu64(R1);
	R1 = (u64)&pname;
	asu64(R2) = a;
	asi64(R1) = mm_blockpcl_checkdotchain(asu64(R2), asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pdot;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = pname;
	a = asu64(R1);
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asi64(R1) = offset;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 1;
	R3 = 6;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pdot;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_index(u64 p, u64 parray, u64 pindex) {
    u64 R1, R2, R3, R4; 
	i64 addoffset;
	i64 scale;
	i64 offset;
	R1 = (u64)&pindex;
	asu64(R2) = parray;
	asi64(R1) = mm_blockpcl_getindexoffset(asu64(R2), asu64(R1));
	addoffset = asi64(R1);
	asu64(R1) = parray;
	mm_blockpcl_evalarray(asu64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = parray;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	scale = asi64(R1);
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = parray;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = addoffset;
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	offset = asi64(R1);
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = offset;
	asi64(R2) = scale;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_storeindex(u64 p, u64 parray, u64 pindex, u64 rhs) {
    u64 R1, R2, R3, R4; 
	i64 addoffset;
	i64 scale;
	R1 = (u64)&pindex;
	asu64(R2) = parray;
	asi64(R1) = mm_blockpcl_getindexoffset(asu64(R2), asu64(R1));
	addoffset = asi64(R1);
	asu64(R1) = rhs;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2355;
	R1 = 0;
	R2 = 9;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2355:
	asu64(R1) = parray;
	mm_blockpcl_evalarray(asu64(R1));
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = parray;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	scale = asi64(R1);
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = parray;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = addoffset;
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = scale;
	R3 = 6;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_indexref(u64 parray, u64 pindex) {
    u64 R1, R2, R3, R4; 
	i64 addoffset;
	i64 scale;
	R1 = (u64)&pindex;
	asu64(R2) = parray;
	asi64(R1) = mm_blockpcl_getindexoffset(asu64(R2), asu64(R1));
	addoffset = asi64(R1);
	asu64(R1) = parray;
	mm_blockpcl_evalarray(asu64(R1));
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = parray;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	scale = asi64(R1);
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = parray;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	asi64(R2) = addoffset;
	asi64(R3) = scale;
	asi64(R2) *= asi64(R3);
	asi64(R1) += asi64(R2);
	asi64(R2) = scale;
	R3 = 57;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = parray;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	return;
}

static i64 mm_blockpcl_getindexoffset(u64 parray, u64 pindex) {
    u64 R1, R2; 
	i64 offset;
	i64 addoffset;
	R1 = 0;
	addoffset = asi64(R1);
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 35;
	if (asi64(R1) != asi64(R2)) goto L2359;
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L2360;
	R2 = 44;
	if (asi64(R1) != asi64(R2)) goto L2359;
L2360:
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2362;
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) != asi64(R2)) goto L2364;
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L2363;
L2364:
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R1) = -asi64(R1);
L2363:
	addoffset = asi64(R1);
	asu64(R1) = pindex;
	asu64(R1) = *tou64p(R1);
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pindex;
	*tou64p(R2) = asu64(R1);
L2362:
L2359:
	asi64(R1) = addoffset;
	goto L2357;
L2357:
	return asi64(R1);
}

static void mm_blockpcl_do_switch(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 isref) {
    u64 R1, R2, R3, R4; struct $B18 R1_B18; 
	i64 minlab;
	i64 maxlab;
	i64 n;
	i64 iscomplex;
	i64 i;
	i64 lab_a;
	i64 lab_d;
	i64 labjump;
	i64 elselab;
	i64 labstmt;
	i64 ax;
	i64 bx;
	i64 ismult;
	i64 mode;
	u8 looptype;
	u8 opc;
	struct $B79 labels;
	u64 w;
	u64 wt;
	u64 pjump;
	u64 psetup;
	u64 djump;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 107;
	if (asi64(R1) == asi64(R2)) goto L2367;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L2368;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L2369;
	goto L2370;
L2367:
	R1 = 0;
	looptype = asu8(R1);
	R1 = 37;
	opc = asu8(R1);
	goto L2366;
L2368:
// mm_blockpcl.do_switch.dodosw:
L2371:
	R1 = 1;
	looptype = asu8(R1);
	R1 = 37;
	opc = asu8(R1);
	goto L2366;
L2369:
	asu8(R1) = pclint_ctarget;
	if (!asu8(R1)) goto L2373;
	goto L2371;
L2373:
	R1 = 2;
	looptype = asu8(R1);
	R1 = 38;
	opc = asu8(R1);
	goto L2366;
L2370:
	R1 = 3;
	looptype = asu8(R1);
L2366:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2374;
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2374;
	R1 = 1;
	goto L2375;
L2374:
	R1 = 0;
L2375:
	ismult = asi64(R1);
	R1 = 1000000;
	minlab = asi64(R1);
	R1 = -1000000;
	maxlab = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 0;
	iscomplex = asi64(R1);
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L2377;
L2376:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L2380;
L2379:
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L2383;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2384;
	goto L2385;
L2383:
	asu64(R1) = w;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ax = asi64(R1);
	asu64(R1) = w;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	bx = asi64(R1);
// mm_blockpcl.do_switch.dorange:
L2386:
	asi64(R1) = ax;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = bx;
	if (asi64(R1) > asi64(R2)) goto L2389;
L2387:
	asi64(R1) = i;
	asi64(R2) = minlab;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	minlab = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = maxlab;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	maxlab = asi64(R1);
	i += 1; if (i <= bx) goto L2387;
L2389:
	goto L2382;
L2384:
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	bx = asi64(R2);
	ax = asi64(R1);
	goto L2386;
	goto L2382;
L2385:
	R1 = 0;
	asu64(R2) = w;
	asu64(R2) = mm_lib_strexpr(asu64(R2));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Switch when2: not const: #");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L2382:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L2380:
	asu64(R1) = w;
	if (asu64(R1)) goto L2379;
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L2377:
	asu64(R1) = wt;
	if (asu64(R1)) goto L2376;
	asi64(R1) = maxlab;
	asi64(R2) = minlab;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 1000;
	if (asi64(R1) <= asi64(R2)) goto L2391;
	R1 = 0;
	R2 = tou64("Switch too big");
	mm_support_gerror(asu64(R2), asu64(R1));
L2391:
	asu8(R1) = looptype;
	if (!asu8(R1)) goto L2393;
	asi64(R1) = mm_genpcl_definelabel();
	lab_a = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_a;
	asi64(R3) = lab_a;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	goto L2392;
L2393:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
L2392:
	asi64(R1) = mm_genpcl_createfwdlabel();
	labjump = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	elselab = asi64(R1);
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L2395;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2395:
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L2397;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pjump = asu64(R1);
	asu64(R1) = pjump;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2399;
	R1 = 0;
	R2 = tou64("doswx not name");
	mm_support_gerror(asu64(R2), asu64(R1));
L2399:
	asu64(R1) = pjump;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	djump = asu64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = djump;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L2401;
	R1 = 0;
	R2 = tou64("doswx not ref");
	mm_support_gerror(asu64(R2), asu64(R1));
L2401:
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = pc_api_pccurr;
	psetup = asu64(R1);
	asu64(R1) = pjump;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = mm_genpcl_pcldoswx;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2403;
	R1 = 0;
	R2 = tou64("doswx in main?");
	mm_support_gerror(asu64(R2), asu64(R1));
L2403:
	asu64(R1) = psetup;
	(R1_B18) = *(struct $B18*)(R1);
	asu64(R2) = mm_genpcl_pcldoswx;
	*(struct $B18*)(R2) = (R1_B18);
	asu64(R1) = psetup;
	R2 = 1;
	R1 += (i64)R2*32;
	(R1_B18) = *(struct $B18*)(R1);
	asu64(R2) = mm_genpcl_pcldoswx;
	R3 = 1;
	R2 += (i64)R3*32;
	*(struct $B18*)(R2) = (R1_B18);
	R1 = 2;
	R2 = (u64)&pc_api_pccurr;
	*tou64p(R2) -= asu64(R1)*32;
L2397:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2405;
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asu8(R4) = opc;
	R4 = toi64(tou8(R4));
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L2407;
	asi64(R1) = elselab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
L2407:
	goto L2404;
L2405:
	R1 = tou64("J1");
	pc_api_gencomment(asu64(R1));
	R1 = 0;
	R2 = 25;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
L2404:
	asi64(R1) = labjump;
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = minlab;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = maxlab;
	if (asi64(R1) > asi64(R2)) goto L2410;
L2408:
	asi64(R1) = elselab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 39;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pc_api_pccurr;
	R2 = (u64)&labels;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	i += 1; if (i <= maxlab) goto L2408;
L2410:
	R1 = 0;
	R2 = 40;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L2412;
L2411:
	asi64(R1) = mm_genpcl_definelabel();
	labstmt = asi64(R1);
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L2415;
L2414:
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L2418;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2419;
	goto L2420;
L2418:
	asu64(R1) = w;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ax = asi64(R1);
	asu64(R1) = w;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	bx = asi64(R1);
	goto L2417;
L2419:
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	bx = asi64(R2);
	ax = asi64(R1);
	goto L2417;
L2420:
L2417:
	asi64(R1) = ax;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = bx;
	if (asi64(R1) > asi64(R2)) goto L2423;
L2421:
	asi64(R1) = labstmt;
	R2 = (u64)&labels;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	i += 1; if (i <= bx) goto L2421;
L2423:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L2415:
	asu64(R1) = w;
	if (asu64(R1)) goto L2414;
	asi64(R1) = isref;
	if (!asi64(R1)) goto L2425;
	R1 = 0;
	asu64(R2) = wt;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L2424;
L2425:
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
L2424:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L2427;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L2427:
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2429;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2430;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2431;
	goto L2432;
L2429:
	asi64(R1) = lab_d;
	mm_blockpcl_genjumpl(asi64(R1));
	goto L2428;
L2430:
	asi64(R1) = lab_a;
	mm_blockpcl_genjumpl(asi64(R1));
	goto L2428;
L2431:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asu8(R4) = opc;
	R4 = toi64(tou8(R4));
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L2428;
L2432:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("J2");
	pc_api_gencomment(asu64(R1));
	R1 = 0;
	R2 = 25;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
L2428:
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L2412:
	asu64(R1) = wt;
	if (asu64(R1)) goto L2411;
	asi64(R1) = elselab;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L2434;
	asi64(R1) = isref;
	if (!asi64(R1)) goto L2436;
	R1 = 0;
	asu64(R2) = pelse;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L2435;
L2436:
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L2435:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L2438;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L2438:
L2434:
	asu8(R1) = looptype;
	if (!asu8(R1)) goto L2440;
	asu8(R1) = looptype;
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2442;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2443;
	goto L2444;
L2442:
	asi64(R1) = lab_a;
	mm_blockpcl_genjumpl(asi64(R1));
	goto L2441;
L2443:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = maxlab;
	asi64(R3) = minlab;
	asu8(R4) = opc;
	R4 = toi64(tou8(R4));
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L2441;
L2444:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("J3");
	pc_api_gencomment(asu64(R1));
	R1 = 0;
	R2 = 25;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
L2441:
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
L2440:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_select(u64 p, u64 a, u64 b, u64 c, i64 isref) {
    u64 R1, R2, R3, R4; 
	struct $B80 labels;
	i64 labend;
	i64 labjump;
	i64 n;
	i64 i;
	i64 elselab;
	i64 labstmt;
	i64 ismult;
	u64 q;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2446;
	asu64(R1) = p;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2446;
	R1 = 1;
	goto L2447;
L2446:
	R1 = 0;
L2447:
	ismult = asi64(R1);
	asu64(R1) = b;
	q = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L2449;
L2448:
	asi64(R1) = n;
	R2 = 256;
	if (asi64(R1) < asi64(R2)) goto L2452;
	R1 = 0;
	R2 = tou64("selectx: too many labels");
	mm_support_gerror(asu64(R2), asu64(R1));
L2452:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L2449:
	asu64(R1) = q;
	if (asu64(R1)) goto L2448;
	asi64(R1) = mm_genpcl_createfwdlabel();
	labend = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	labjump = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	elselab = asi64(R1);
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L2454;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2454:
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asi64(R1) = labjump;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	asi64(R2) = n;
	R3 = 1;
	R4 = 37;
	pc_api_pc_genxy(asi64(R4), asi64(R3), asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = elselab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 12;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = labjump;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = b;
	q = asu64(R1);
	R1 = 0;
	i = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2457;
L2455:
	asi64(R1) = elselab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 39;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pc_api_pccurr;
	R2 = (u64)&labels;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= n) goto L2455;
L2457:
	R1 = 0;
	R2 = 40;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = b;
	q = asu64(R1);
	R1 = 0;
	i = asi64(R1);
	goto L2459;
L2458:
	asi64(R1) = mm_genpcl_definelabel();
	labstmt = asi64(R1);
	R1 = (u64)&i;
	(*toi64p(R1)) += 1;
	asi64(R1) = labstmt;
	R2 = (u64)&labels;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = isref;
	if (!asi64(R1)) goto L2462;
	R1 = 0;
	asu64(R2) = q;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L2461;
L2462:
	asu64(R1) = q;
	mm_blockpcl_evalunit(asu64(R1));
L2461:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L2464;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L2464:
	asi64(R1) = labend;
	mm_blockpcl_genjumpl(asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L2459:
	asu64(R1) = q;
	if (asu64(R1)) goto L2458;
	asi64(R1) = elselab;
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = isref;
	if (!asi64(R1)) goto L2466;
	R1 = 0;
	asu64(R2) = c;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L2465;
L2466:
	asu64(R1) = c;
	mm_blockpcl_evalunit(asu64(R1));
L2465:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L2468;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L2468:
	asi64(R1) = labend;
	mm_genpcl_definefwdlabel(asi64(R1));
	return;
}

static void mm_blockpcl_do_case(u64 p, u64 pindex, u64 pwhenthen, u64 pelse, i64 loopsw, i64 isref) {
    u64 R1, R2, R3, R4; 
	struct $B78 labtable;
	struct $B78 unittable;
	i64 ncases;
	i64 ismult;
	i64 a;
	i64 b;
	i64 lab_abc;
	i64 lab_d;
	i64 labelse;
	u64 w;
	u64 wt;
	u64 plower;
	u64 pupper;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 106;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	loopsw = asi64(R1);
	asu64(R1) = pindex;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2471;
	R1 = 0;
	R2 = tou64("EMPTY CASE NOT DONE");
	mm_support_gerror(asu64(R2), asu64(R1));
L2471:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2472;
	asi64(R1) = loopsw;
	if (asi64(R1)) goto L2472;
	R1 = 1;
	goto L2473;
L2472:
	R1 = 0;
L2473:
	ismult = asi64(R1);
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L2475;
	asi64(R1) = mm_genpcl_definelabel();
	lab_abc = asi64(R1);
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
	asi64(R1) = lab_d;
	asi64(R2) = lab_abc;
	asi64(R3) = lab_abc;
	mm_genpcl_stacklooplabels(asi64(R3), asi64(R2), asi64(R1));
	goto L2474;
L2475:
	asi64(R1) = mm_genpcl_createfwdlabel();
	lab_d = asi64(R1);
L2474:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L2477;
	R1 = 0;
	R2 = 117;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2477:
	R1 = 0;
	ncases = asi64(R1);
	asi64(R1) = mm_blockpcl_casedepth;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L2479;
	R1 = 0;
	R2 = tou64("case nested too deeply");
	mm_support_gerror(asu64(R2), asu64(R1));
L2479:
	asu64(R1) = p;
	R2 = (u64)&mm_blockpcl_casestmt;
	R3 = (u64)&mm_blockpcl_casedepth;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pwhenthen;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2481;
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L2483;
	R1 = 0;
	R2 = tou64("case");
	mm_support_gerror(asu64(R2), asu64(R1));
L2483:
	goto L2484;
L2481:
	asu64(R1) = pindex;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = pwhenthen;
	wt = asu64(R1);
	goto L2486;
L2485:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	asi64(R1) = ncases;
	R2 = 500;
	if (asi64(R1) < asi64(R2)) goto L2489;
	R1 = 0;
	R2 = tou64("too many cases");
	mm_support_gerror(asu64(R2), asu64(R1));
L2489:
	asi64(R1) = mm_genpcl_createfwdlabel();
	R2 = (u64)&labtable;
	R3 = (u64)&ncases;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&unittable;
	asi64(R3) = ncases;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L2491;
L2490:
	asu64(R1) = w;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = (u64)&labtable;
	asi64(R2) = ncases;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	R2 = R1;
	asu64(R3) = w;
	R4 = 40;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 1;
	R3 = 26;
	pc_api_pc_gencond(asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L2495;
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2494;
L2495:
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L2494:
	asu64(R1) = w;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L2491:
	asu64(R1) = w;
	if (asu64(R1)) goto L2490;
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L2486:
	asu64(R1) = wt;
	if (asu64(R1)) goto L2485;
// mm_blockpcl.do_case.skip:
L2484:
	asi64(R1) = mm_genpcl_createfwdlabel();
	labelse = asi64(R1);
	asi64(R1) = labelse;
	R2 = (u64)&mm_blockpcl_caseelse;
	asi64(R3) = mm_blockpcl_casedepth;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = labelse;
	mm_blockpcl_genjumpl(asi64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncases;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2498;
L2496:
	R1 = (u64)&labtable;
	asi64(R2) = i;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	mm_genpcl_definefwdlabel(asi64(R1));
	asi64(R1) = isref;
	if (!asi64(R1)) goto L2500;
	R1 = 0;
	R2 = (u64)&unittable;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L2499;
L2500:
	R1 = (u64)&unittable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_blockpcl_evalunit(asu64(R1));
L2499:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L2502;
	R1 = 0;
	R2 = 118;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L2502:
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L2504;
	asi64(R1) = lab_abc;
	mm_blockpcl_genjumpl(asi64(R1));
	goto L2503;
L2504:
	asi64(R1) = lab_d;
	mm_blockpcl_genjumpl(asi64(R1));
L2503:
	i += 1; if (i <= ncases) goto L2496;
L2498:
	asi64(R1) = labelse;
	mm_genpcl_definefwdlabel(asi64(R1));
	asu64(R1) = pelse;
	if (!asu64(R1)) goto L2506;
	asi64(R1) = isref;
	if (!asi64(R1)) goto L2508;
	R1 = 0;
	asu64(R2) = pelse;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	goto L2507;
L2508:
	asu64(R1) = pelse;
	mm_blockpcl_evalunit(asu64(R1));
L2507:
	asi64(R1) = ismult;
	if (!asi64(R1)) goto L2510;
	R1 = 0;
	R2 = 119;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L2510:
L2506:
	asi64(R1) = loopsw;
	if (!asi64(R1)) goto L2512;
	asi64(R1) = lab_abc;
	mm_blockpcl_genjumpl(asi64(R1));
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) -=1;
	goto L2511;
L2512:
	asi64(R1) = lab_d;
	mm_genpcl_definefwdlabel(asi64(R1));
L2511:
	R1 = (u64)&mm_blockpcl_casedepth;
	(*toi64p(R1)) -=1;
	return;
}

static void mm_blockpcl_do_dotindex(u64 p, u64 a, u64 b) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 14;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_dotslice(u64 p, u64 a, u64 b) {
    u64 R1, R2; 
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 15;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_read(u64 p, u64 a) {
    u64 R1, R2, R3, R4; 
	i64 m;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2517;
	asu64(R1) = mm_genpcl_pzero;
	a = asu64(R1);
L2517:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2519;
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	R4 = 23;
	mm_genpcl_genpc_sysfn(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L2518;
L2519:
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2520;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L2520;
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	R4 = 24;
	mm_genpcl_genpc_sysfn(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L2518;
L2520:
	asi64(R1) = m;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L2521;
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	R4 = 25;
	mm_genpcl_genpc_sysfn(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L2518;
L2521:
	msysc_m$print_startcon();
	R1 = tou64("STRMODE(M)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("CAN'T READ THIS ITEM");
	mm_support_gerror(asu64(R2), asu64(R1));
L2518:
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_readln(u64 a) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L2524;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L2526;
	R1 = 0;
	R2 = tou64("@dev no ref");
	mm_support_gerror(asu64(R2), asu64(R1));
L2526:
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2528;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L2529;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L2529;
	goto L2530;
L2528:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 26;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L2527;
L2529:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	asu64(R4) = a;
	R5 = 27;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L2527;
L2530:
	R1 = 0;
	R2 = tou64("rd@dev?");
	mm_support_gerror(asu64(R2), asu64(R1));
L2527:
	goto L2523;
L2524:
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 28;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L2523:
	return;
}

static void mm_blockpcl_docond(i64 opc, u64 p, i64 lab) {
    u64 R1, R2, R3; 
	asi64(R1) = lab;
	asu64(R2) = p;
	asi64(R3) = opc;
	mm_blockpcl_genjumpcond(asi64(R3), asu64(R2), asi64(R1));
	return;
}

static void mm_blockpcl_do_syscall(u64 p, u64 a) {
    u64 R1, R2, R3; 
	mm_genpcl_setfunctab();
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L2534;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L2535;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L2536;
	goto L2537;
L2534:
	asu64(R1) = mm_blockpcl_pnprocs;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2533;
L2535:
	asu64(R1) = mm_blockpcl_pprocname;
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = -8;
	R2 = 8;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	goto L2533;
L2536:
	asu64(R1) = mm_blockpcl_pprocaddr;
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = -8;
	R2 = 8;
	R3 = 3;
	pc_api_pc_genix(asi64(R3), asi64(R2), asi64(R1));
	goto L2533;
L2537:
	R1 = tou64("SYSCALL/GENERIC");
	pc_api_gencomment(asu64(R1));
L2533:
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_slice(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2540;
	asu64(R1) = a;
	mm_blockpcl_evalarray(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2542;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	mm_genpcl_genpushint(asi64(R1));
	goto L2541;
L2542:
	R1 = (u64)&mm_decls_ttlength;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mm_genpcl_genpushint(asi64(R1));
L2541:
	goto L2539;
L2540:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	mm_blockpcl_do_indexref(asu64(R2), asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L2544;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2544;
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	mm_genpcl_genpushint(asi64(R1));
	goto L2543;
L2544:
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 44;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	R1 = 1;
	mm_genpcl_genpushint(asi64(R1));
	R1 = 0;
	R2 = 43;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2543:
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
L2539:
	R1 = 0;
	R2 = 7;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 11;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_blockpcl_do_assignblock(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L2547;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L2549;
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignarray(asu64(R2), asu64(R1));
	goto L2548;
L2549:
	asu64(R1) = b;
	asu64(R2) = a;
	mm_blockpcl_do_assignrecord(asu64(R2), asu64(R1));
L2548:
	goto L2546;
L2547:
	R1 = 0;
	R2 = tou64("ASSIGN BLOCK");
	mm_support_gerror(asu64(R2), asu64(R1));
L2546:
	return;
}

static void mm_blockpcl_do_assignarray(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 passign;
	u64 pindex;
	u64 pconst;
	u64 q;
	i64 index;
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L2552;
	R1 = 0;
	R2 = tou64("Assignment not suitable for []char type");
	mm_support_gerror(asu64(R2), asu64(R1));
L2552:
	R1 = 3;
	R2 = 1;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	pconst = asu64(R1);
	asu64(R1) = pconst;
	asu64(R2) = a;
	R3 = 46;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	pindex = asu64(R1);
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pindex;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	passign = asu64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = R1;
	asu64(R3) = pindex;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = passign;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&mm_decls_ttlower;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	index = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L2554;
L2553:
	asi64(R1) = index;
	asu64(R2) = pconst;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = pconst;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	asu64(R2) = passign;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = passign;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = (u64)&index;
	(*toi64p(R1)) += 1;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L2554:
	asu64(R1) = q;
	if (asu64(R1)) goto L2553;
	return;
}

static void mm_blockpcl_do_assignrecord(u64 a, u64 b) {
    u64 R1, R2, R3, R4; 
	u64 passign;
	u64 pdot;
	u64 pfield;
	u64 q;
	i64 m;
	i64 fieldtype;
	u64 d;
	u64 e;
	R1 = 4;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	pfield = asu64(R1);
	asu64(R1) = pfield;
	asu64(R2) = a;
	R3 = 49;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	pdot = asu64(R1);
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pdot;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	passign = asu64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = R1;
	asu64(R3) = pdot;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = passign;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L2558;
L2557:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L2561;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L2561;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	fieldtype = asi64(R1);
	asu64(R1) = e;
	asu64(R2) = pfield;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = fieldtype;
	R2 = R1;
	asu64(R3) = pdot;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	R2 = R1;
	asu64(R3) = pfield;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = passign;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = q;
	asu64(R2) = passign;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pdot;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = passign;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L2561:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L2558:
	asu64(R1) = e;
	if (asu64(R1)) goto L2557;
	return;
}

static void mm_blockpcl_pushrhs(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2564;
	goto L2562;
L2564:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_pushrhs(asu64(R1));
	asu64(R1) = a;
	mm_blockpcl_evalunit(asu64(R1));
L2562:
	return;
}

static void mm_blockpcl_do_assignms(u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 nlhs;
	i64 nrhs;
	u64 d;
	i64 i;
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	nlhs = asi64(R1);
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L2567;
	goto L2568;
L2567:
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2570;
	R1 = 0;
	R2 = tou64("multassign from fn: not simple fn");
	mm_support_gerror(asu64(R2), asu64(R1));
L2570:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nrhs = asi64(R1);
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L2566;
L2568:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L2572;
	R1 = 0;
	R2 = tou64("DECONSTR SLICE NOT READY");
	mm_support_gerror(asu64(R2), asu64(R1));
	goto L2571;
L2572:
	R1 = 0;
	R2 = tou64("(a,b):=x; var only");
	mm_support_gerror(asu64(R2), asu64(R1));
L2571:
L2566:
	asu64(R1) = a;
	mm_blockpcl_poptomult(asu64(R1));
	asi64(R1) = nrhs;
	asi64(R2) = nlhs;
	if (asi64(R1) <= asi64(R2)) goto L2574;
	asu64(R1) = b;
	asu64(R1) = mm_lib_getprocretmodes(asu64(R1));
	d = asu64(R1);
	asi64(R1) = nlhs;
	R2 = 1;
	asi64(R1) += asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = nrhs;
	if (asi64(R1) > asi64(R2)) goto L2577;
L2575:
	R1 = 0;
	R2 = 11;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = (u64)&mm_decls_ttmult;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	i += 1; if (i <= nrhs) goto L2575;
L2577:
L2574:
	return;
}

static void mm_blockpcl_do_assignmm(u64 a, u64 b) {
    u64 R1, R2; 
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_pushrhs(asu64(R1));
	R1 = 0;
	R2 = 133;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_poptomult(asu64(R1));
	return;
}

static void mm_blockpcl_do_assignmdrem(u64 a, u64 b) {
    u64 R1, R2; 
	asu64(R1) = b;
	mm_blockpcl_evalunit(asu64(R1));
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_poptomult(asu64(R1));
	return;
}

static void mm_blockpcl_poptomult(u64 a) {
    u64 R1, R2, R3; 
L2581:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2585;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L2586;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L2586;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L2586;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L2587;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L2588;
	R2 = 105;
	if (asi64(R1) == asi64(R2)) goto L2588;
	R2 = 107;
	if (asi64(R1) == asi64(R2)) goto L2588;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L2588;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L2589;
	goto L2590;
L2585:
	asu64(R1) = a;
	asu64(R1) = mm_genpcl_genmem_u(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2584;
L2586:
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2584;
L2587:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2584;
L2588:
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 5;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2584;
L2589:
	R1 = 0;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 16;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2584;
L2590:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Bad mult assign element");
	mm_support_gerror(asu64(R2), asu64(R1));
L2584:
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2581;
	return;
}

static void mm_blockpcl_do_recase(u64 p, u64 a) {
    u64 R1, R2, R3; 
	u64 q;
	u64 wt;
	u64 w;
	i64 destlab;
	i64 casevalue;
	asi64(R1) = mm_blockpcl_casedepth;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2593;
	R1 = 0;
	R2 = tou64("recase outside case stmt");
	mm_support_gerror(asu64(R2), asu64(R1));
L2593:
	asu64(R1) = a;
	if (!asu64(R1)) goto L2595;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	casevalue = asi64(R1);
	goto L2594;
L2595:
	R1 = (u64)&mm_blockpcl_caseelse;
	asi64(R2) = mm_blockpcl_casedepth;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	mm_blockpcl_genjumpl(asi64(R1));
L2594:
	R1 = (u64)&mm_blockpcl_casestmt;
	asi64(R2) = mm_blockpcl_casedepth;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	R1 = 0;
	destlab = asi64(R1);
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
	goto L2597;
L2596:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L2600;
L2599:
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2603;
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = w;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2603;
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = casevalue;
	if (asi64(R1) != asi64(R2)) goto L2603;
	asu64(R1) = w;
	R2 = 40;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	destlab = asi64(R1);
	goto L2598;
L2603:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L2600:
	asu64(R1) = w;
	if (asu64(R1)) goto L2599;
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L2597:
	asu64(R1) = wt;
	if (asu64(R1)) goto L2596;
L2598:
	asi64(R1) = destlab;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2605;
	R1 = (u64)&mm_blockpcl_caseelse;
	asi64(R2) = mm_blockpcl_casedepth;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	mm_blockpcl_genjumpl(asi64(R1));
	goto L2604;
L2605:
	asi64(R1) = destlab;
	mm_blockpcl_genjumpl(asi64(R1));
L2604:
	return;
}

static void mm_blockpcl_do_empty(u64 p, u64 a) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = a;
	mm_blockpcl_evalref(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 41;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = a;
	mm_libpcl_setmode_u(asu64(R1));
	return;
}

static void mm_blockpcl_do_typeconst(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	mm_genpcl_genpushint(asi64(R1));
	return;
}

static void mm_blockpcl_do_setinplace() {
    u64 R1, R2, R3; 
	asu64(R1) = pc_api_pccurr;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2610;
	asu64(R1) = pc_api_pccurr;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2610;
	R1 = 1;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L2610:
	return;
}

static u64 mm_assem_dummy_readassemline() {
    u64 R1; 
	mm_lex_lex();
	R1 = 0;
	goto L2611;
L2611:
	return asu64(R1);
}

static u64 mm_assem_dummy_readassemblock() {
    u64 R1; 
	R1 = 0;
	goto L2612;
L2612:
	return asu64(R1);
}

static void mm_assem_dummy_initassemsymbols() {
	return;
}

static void mm_assemaux_dummy_domcl_assem(u64 pcode) {
    u64 R1, R2; 
	asu64(R1) = pcode;
	if (!asu64(R1)) goto L2617;
	asu64(R1) = pcode;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2616;
L2617:
	goto L2614;
L2616:
L2614:
	return;
}

static i64 mm_assemaux_dummy_checkasmlabel(u64 p) {
    u64 R1; 
	R1 = 0;
	goto L2618;
L2618:
	return asi64(R1);
}

static void mm_diags_dummy_printmodelist(u64 f) {
	return;
}

static void mm_diags_dummy_printst(u64 f, u64 p, i64 level) {
	return;
}

static void mm_diags_dummy_printstrec(u64 f, u64 p, i64 level) {
	return;
}

static void mm_diags_dummy_printstflat(u64 f) {
	return;
}

static void mm_diags_dummy_printcode(u64 f, u64 caption) {
	return;
}

static void mm_diags_dummy_printunit(u64 p, i64 level, u64 prefix, u64 dev) {
	return;
}

static void mm_diags_dummy_printunitlist(u64 dev, u64 p, i64 level, u64 prefix) {
	return;
}

static void mm_diags_dummy_showprojectinfo(u64 dev) {
	return;
}

static void mm_diags_dummy_showlogfile() {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("NO DIAGS MODULE");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_diags_dummy_showast(u64 filename) {
	return;
}

static void mm_diags_dummy_printsymbol(u64 lp) {
	return;
}

static void mm_diags_dummy_showtimings() {
	return;
}

static void mm_exportm_writeexports(u64 basefile, u64 modulename) {
    u64 R1, R2, R3; 
	u64 d;
	u64 pp;
	u64 f;
	struct $B15 filespec;
	u64 outfile;
	i64 i;
	R1 = tou64("");
	asu64(R2) = basefile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	R2 = (u64)&filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("_lib.m");
	R2 = (u64)&filespec;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	outfile = asu64(R1);
	msysc_m$print_startcon();
	R1 = tou64("Writing exports file to");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = outfile;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = mm_exportm_dest;
	mlib_gs_init(asu64(R1));
	R1 = tou64("importdll ");
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = modulename;
	mm_exportm_wxstr(asu64(R1));
	R1 = tou64(" =");
	mm_exportm_wxstrln(asu64(R1));
	R1 = 31;
	i = asi64(R1);
	asi64(R1) = mm_decls_ntypes;
	R2 = 31;
	if (asi64(R1) < asi64(R2)) goto L2634;
L2632:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L2636;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L2636;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L2638;
	goto L2639;
L2638:
	asu64(R1) = d;
	mm_exportm_exportrecord(asu64(R1));
	goto L2637;
L2639:
	R1 = tou64("    type ");
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_exportm_wxstr(asu64(R1));
	R1 = tou64(" = ");
	mm_exportm_wxstr(asu64(R1));
	R1 = 0;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	mm_exportm_wxstr(asu64(R1));
	mm_exportm_wxline();
L2637:
L2636:
	i += 1; if (i <= mm_decls_ntypes) goto L2632;
L2634:
	asu64(R1) = mm_decls_staticlist;
	pp = asu64(R1);
	goto L2643;
L2640:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L2645;
	asu64(R1) = d;
	mm_exportm_exportstatic(asu64(R1));
L2645:
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L2643:
	asu64(R1) = pp;
	if (asu64(R1)) goto L2640;
	asu64(R1) = mm_decls_staticlist;
	if (!asu64(R1)) goto L2647;
	mm_exportm_wxline();
L2647:
	asu64(R1) = mm_decls_constlist;
	pp = asu64(R1);
	goto L2651;
L2648:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L2653;
	asu64(R1) = d;
	mm_exportm_exportconst(asu64(R1));
L2653:
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L2651:
	asu64(R1) = pp;
	if (asu64(R1)) goto L2648;
	asu64(R1) = mm_decls_constlist;
	if (!asu64(R1)) goto L2655;
	mm_exportm_wxline();
L2655:
	asu64(R1) = mm_decls_proclist;
	pp = asu64(R1);
	goto L2659;
L2656:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L2661;
	asu64(R1) = d;
	mm_exportm_exportproc(asu64(R1));
L2661:
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L2659:
	asu64(R1) = pp;
	if (asu64(R1)) goto L2656;
	R1 = tou64("end");
	mm_exportm_wxstrln(asu64(R1));
	R1 = tou64("wb");
	asu64(R2) = outfile;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = mm_exportm_dest;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	return;
}

static void mm_exportm_exportstatic(u64 d) {
    u64 R1, R2; 
	R1 = tou64("    var ");
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_exportm_wxmode(asi64(R1));
	R1 = tou64(" ");
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_exportm_wxstr(asu64(R1));
	mm_exportm_wxline();
	return;
}

static void mm_exportm_exportconst(u64 d) {
    u64 R1, R2; 
	R1 = tou64("    const ");
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_exportm_wxmode(asi64(R1));
	R1 = tou64(" ");
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_exportm_wxstr(asu64(R1));
	R1 = tou64(" = ");
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mm_exportm_dest;
	mm_lib_jevalx2(asu64(R2), asu64(R1));
	mm_exportm_wxline();
	return;
}

static void mm_exportm_exportproc(u64 d) {
    u64 R1, R2, R3; 
	u64 e;
	i64 currmode;
	i64 needcomma;
	R1 = tou64("    ");
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2666;
	R1 = tou64("proc ");
	goto L2665;
L2666:
	R1 = tou64("func ");
L2665:
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_exportm_wxstr(asu64(R1));
	R1 = tou64("(");
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	needcomma = asi64(R1);
	R1 = 0;
	currmode = asi64(R1);
	goto L2668;
L2667:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L2671;
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L2673;
	R1 = tou64(",");
	mm_exportm_wxstr(asu64(R1));
L2673:
	asu64(R1) = e;
	R2 = 160;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2675;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = currmode;
	if (asi64(R1) == asi64(R2)) goto L2677;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_exportm_wxmode(asi64(R1));
	R1 = tou64(" ");
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	currmode = asi64(R1);
L2677:
	goto L2674;
L2675:
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = e;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mm_exportm_wxmode(asi64(R1));
	R1 = tou64(" &");
	mm_exportm_wxstr(asu64(R1));
	R1 = 0;
	currmode = asi64(R1);
L2674:
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = e;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2679;
	R1 = tou64("=");
	mm_exportm_wxstr(asu64(R1));
	R1 = (u64)&mm_decls_ttisref;
	asu64(R2) = e;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2681;
	asu64(R1) = e;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2681;
	asu64(R1) = e;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2681;
	R1 = tou64("nil");
	mm_exportm_wxstr(asu64(R1));
	goto L2680;
L2681:
	asu64(R1) = e;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mm_exportm_dest;
	mm_lib_jevalx2(asu64(R2), asu64(R1));
L2680:
L2679:
	R1 = 1;
	needcomma = asi64(R1);
L2671:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L2668:
	asu64(R1) = e;
	if (asu64(R1)) goto L2667;
	R1 = tou64(")");
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L2683;
	R1 = tou64(" => ");
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_exportm_wxmode(asi64(R1));
L2683:
	mm_exportm_wxline();
	return;
}

static void mm_exportm_wxstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = mm_exportm_dest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static void mm_exportm_wxstrln(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = mm_exportm_dest;
	mlib_gs_strln(asu64(R2), asu64(R1));
	return;
}

static void mm_exportm_wxline() {
    u64 R1; 
	asu64(R1) = mm_exportm_dest;
	mlib_gs_line(asu64(R1));
	return;
}

static void mm_exportm_exportrecord(u64 d) {
    u64 R1, R2; 
	u64 e;
	u64 flags;
	i64 flag;
	i64 indent;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = tou64("    record ");
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_exportm_wxstr(asu64(R1));
	R1 = tou64(" = ");
	mm_exportm_wxstr(asu64(R1));
	mm_exportm_wxline();
	R1 = 2;
	indent = asi64(R1);
	goto L2689;
L2688:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L2692;
	asu64(R1) = e;
	R2 = 136;
	R1 += (i64)R2;
	flags = asu64(R1);
L2693:
	asu64(R1) = flags;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 83;
	if (asu64(R1) == asu64(R2)) goto L2695;
	R2 = 85;
	if (asu64(R1) == asu64(R2)) goto L2696;
	goto L2697;
L2695:
	asi64(R1) = indent;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2700;
L2698:
	R1 = tou64("    ");
	mm_exportm_wxstr(asu64(R1));
	if (--asi64(av_1)) goto L2698;
L2700:
	R1 = tou64("struct");
	mm_exportm_wxstrln(asu64(R1));
	R1 = (u64)&indent;
	(*toi64p(R1)) += 1;
	R1 = (u64)&flags;
	(*tou64p(R1)) += 1;
	goto L2693;
L2696:
	asi64(R1) = indent;
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2703;
L2701:
	R1 = tou64("    ");
	mm_exportm_wxstr(asu64(R1));
	if (--asi64(av_2)) goto L2701;
L2703:
	R1 = tou64("union");
	mm_exportm_wxstrln(asu64(R1));
	R1 = (u64)&indent;
	(*toi64p(R1)) += 1;
	R1 = (u64)&flags;
	(*tou64p(R1)) += 1;
	goto L2693;
L2697:
	goto L2694;
	goto L2693;
L2694:
	asi64(R1) = indent;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2706;
L2704:
	R1 = tou64("    ");
	mm_exportm_wxstr(asu64(R1));
	if (--asi64(av_3)) goto L2704;
L2706:
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_exportm_wxmode(asi64(R1));
	R1 = tou64(" ");
	mm_exportm_wxstr(asu64(R1));
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_exportm_wxstrln(asu64(R1));
L2707:
	R1 = (u64)&flags;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	flag = asi64(R1);
	asi64(R1) = flag;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L2710;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L2711;
	goto L2712;
L2710:
	goto L2709;
L2711:
	R1 = (u64)&indent;
	(*toi64p(R1)) -=1;
	asi64(R1) = indent;
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L2715;
L2713:
	R1 = tou64("    ");
	mm_exportm_wxstr(asu64(R1));
	if (--asi64(av_4)) goto L2713;
L2715:
	R1 = tou64("end");
	mm_exportm_wxstrln(asu64(R1));
	goto L2709;
L2712:
	goto L2708;
L2709:
	goto L2707;
L2708:
L2692:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L2689:
	asu64(R1) = e;
	if (asu64(R1)) goto L2688;
	R1 = tou64("    end");
	mm_exportm_wxstrln(asu64(R1));
	mm_exportm_wxline();
	return;
}

static void mm_exportm_wxmode(i64 mode) {
    u64 R1, R2; 
	u64 name;
	asi64(R1) = mode;
	R2 = 31;
	if (asi64(R1) < asi64(R2)) goto L2718;
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = mode;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = name;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L2720;
	asu64(R1) = name;
	mm_exportm_wxstr(asu64(R1));
	goto L2716;
L2720:
L2718:
	R1 = 0;
	asi64(R2) = mode;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	mm_exportm_wxstr(asu64(R1));
L2716:
	return;
}

static void mm_genpcl_codegen_il(u64 dummy) {
    u64 R1, R2; 
	u64 d;
	u64 pp;
	i64 i;
	asi64(R1) = mm_decls_nunits;
	R2 = 0;
	asu64(R1) = pc_api_pcl_start(asu64(R2), asi64(R1));
	mm_genpcl_dolibs();
	asu64(R1) = mm_decls_staticlist;
	pp = asu64(R1);
	goto L2723;
L2722:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	mm_genpcl_dostaticvar(asu64(R1));
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L2723:
	asu64(R1) = pp;
	if (asu64(R1)) goto L2722;
	R1 = tou64("");
	pc_api_gencomment(asu64(R1));
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_ndllproctable;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2727;
L2725:
	R1 = (u64)&mm_decls_dllproctable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_genpcl_gendllproc(asu64(R1));
	i += 1; if (i <= mm_decls_ndllproctable) goto L2725;
L2727:
	asu64(R1) = mm_decls_proclist;
	pp = asu64(R1);
	goto L2729;
L2728:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = R1;
	mm_decls_currproc = asu64(R2);
	mm_genpcl_genprocdef(asu64(R1));
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L2729:
	asu64(R1) = pp;
	if (asu64(R1)) goto L2728;
	mm_genpcl_scanprocs();
	pc_api_pcl_end();
	return;
}

static void mm_genpcl_genprocdef(u64 p) {
    u64 R1, R2, R3; 
	u64 ms;
	R1 = (u64)&mm_decls_modules;
	asu64(R2) = p;
	R3 = 94;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ms = asu64(R1);
	R1 = 0;
	mm_genpcl_pcldoswx = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = ms;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2733;
	R1 = (u64)&mm_decls_moduletosub;
	asu64(R2) = p;
	R3 = 94;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mm_decls_mainsubprogno;
	if (asi64(R1) != asi64(R2)) goto L2733;
	asu64(R1) = p;
	mm_genpcl_genmaindef(asu64(R1));
	goto L2731;
	goto L2732;
L2733:
	asu64(R1) = p;
	asu64(R2) = ms;
	R3 = 48;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L2734;
	asu64(R1) = p;
	mm_genpcl_genstartdef(asu64(R1));
	goto L2731;
L2734:
L2732:
	asu64(R1) = p;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	mm_genpcl_doprocdef(asu64(R2), asi64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	mm_genpcl_retindex = asi64(R1);
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2736;
	R1 = 0;
	R2 = 126;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	R2 = 0;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pc_api_pccurr;
	mm_genpcl_pcldoswx = asu64(R1);
	R1 = 0;
	R2 = 0;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2736:
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asi64(R1) = mm_genpcl_retindex;
	mm_genpcl_definefwdlabel(asi64(R1));
	mm_genpcl_genreturn();
	pc_api_pc_endproc();
L2731:
	return;
}

static void mm_genpcl_gendllproc(u64 p) {
    u64 R1, R2; 
	u64 e;
	asu64(R1) = p;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_setimport(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L2741;
L2738:
	asu64(R1) = e;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addparam(asu64(R1));
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L2741:
	asu64(R1) = e;
	if (asu64(R1)) goto L2738;
	R1 = 0;
	pc_api_pc_setimport(asu64(R1));
	return;
}

static void mm_genpcl_dolibs() {
    u64 R1, R2; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2745;
L2743:
	R1 = (u64)&mm_decls_libfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L2747;
	R1 = (u64)&mm_decls_libfiles;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pc_api_pc_addplib(asu64(R1));
L2747:
	i += 1; if (i <= mm_decls_nlibfiles) goto L2743;
L2745:
	return;
}

static void mm_genpcl_dostaticvar(u64 d) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2750;
	goto L2748;
L2750:
	asu64(R1) = d;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L2752;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) != asu64(R2)) goto L2752;
	R1 = tou64("$cmdskip");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2754;
	R1 = 3;
	asu64(R2) = d;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2754:
L2752:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2756;
	goto L2748;
	goto L2755;
L2756:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2757;
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getalignment(asi64(R1));
	pc_api_pc_setalign(asi64(R1));
	R1 = 0;
	R2 = 65;
	R3 = 1;
	asu64(R4) = d;
	R5 = 64;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	mm_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L2755;
L2757:
// mm_genpcl.dostaticvar.dozstatic:
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 124;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getalignment(asi64(R1));
	pc_api_pc_setalign(asi64(R1));
L2755:
L2748:
	return;
}

static void mm_genpcl_genidata(u64 p, i64 doterm, i64 am, i64 offset) {
    u64 R1, R2, R3, R4, R5; 
	struct $B81 data;
	i64 t;
	i64 tbase;
	u8 allbytes;
	u8 nbytes;
	u64 q;
	u64 a;
	u64 d;
	u64 s;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	t = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tbase = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2761;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L2762;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2763;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L2764;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L2765;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L2766;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L2766;
	goto L2767;
L2761:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2769;
	asi64(R1) = t;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L2771;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2773;
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 66;
	if (asu64(R1) != asu64(R2)) goto L2775;
	R1 = 0;
	R2 = tou64("1:B-str?");
	mm_support_gerror(asu64(R2), asu64(R1));
L2775:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genstring(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2772;
L2773:
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2772:
	goto L2770;
L2771:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2770:
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L2768;
L2769:
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2776;
	asi64(R1) = t;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_genrealimm(asr64(R2), asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = t;
	mm_libpcl_setmode(asi64(R1));
	goto L2768;
L2776:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L2777;
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2779;
	R1 = 0;
	R2 = tou64("IDATA/ARRAY/NOT BLOCKDATA");
	mm_support_gerror(asu64(R2), asu64(R1));
L2779:
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = pc_api_gendata(asu64(R2), asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2768;
L2777:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
L2768:
	goto L2760;
L2762:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 1;
	allbytes = asu8(R1);
	R1 = 0;
	nbytes = asu8(R1);
	goto L2783;
L2780:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2785;
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L2785;
	asu8(R1) = nbytes;
	R1 = toi64(tou8(R1));
	R2 = 2000;
	if (asi64(R1) >= asi64(R2)) goto L2785;
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&data;
	R3 = (u64)&nbytes;
	asu8(R3) = *(tou8p(R3)) += 1;
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L2784;
L2785:
	R1 = 0;
	allbytes = asu8(R1);
	goto L2782;
L2784:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L2783:
	asu64(R1) = q;
	if (asu64(R1)) goto L2780;
L2782:
	asu8(R1) = allbytes;
	if (!asu8(R1)) goto L2787;
	asu8(R1) = nbytes;
	if (!asu8(R1)) goto L2787;
	asu8(R1) = nbytes;
	R1 = toi64(tou8(R1));
	asu8(R2) = nbytes;
	R2 = toi64(tou8(R2));
	R3 = (u64)&data;
	asu64(R2) = mlib_pcm_copyheapstringn(asu64(R3), asi64(R2));
	asu64(R1) = pc_api_gendata(asu64(R2), asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2786;
L2787:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L2791;
L2788:
	R1 = 0;
	R2 = 65;
	R3 = 1;
	asu64(R4) = q;
	mm_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L2791:
	asu64(R1) = q;
	if (asu64(R1)) goto L2788;
L2786:
	goto L2760;
L2763:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2793;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2793;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L2793;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L2794;
	goto L2795;
L2793:
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmemaddr_d(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = offset;
	if (!asi64(R1)) goto L2797;
	asi64(R1) = offset;
	R2 = 1;
	pc_api_pc_setscaleoff(asi64(R2), asi64(R1));
L2797:
	asi64(R1) = am;
	R2 = 80;
	if (asi64(R1) != asi64(R2)) goto L2799;
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	goto L2798;
L2799:
	asi64(R1) = t;
	mm_libpcl_setmode(asi64(R1));
L2798:
	goto L2792;
L2794:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2801;
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R2) = d;
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L2801:
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	goto L2792;
L2795:
	R1 = 0;
	R2 = tou64("Idata &frameXXX");
	mm_support_gerror(asu64(R2), asu64(R1));
L2792:
	goto L2759;
	goto L2760;
L2764:
	R1 = 0;
	R2 = 65;
	R3 = 1;
	asu64(R4) = p;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	mm_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L2760;
L2765:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = t;
	mm_libpcl_setmode(asi64(R1));
	goto L2760;
L2766:
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2803;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L2802;
L2803:
	R1 = 0;
L2802:
	R2 = 80;
	R3 = 1;
	asu64(R4) = p;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	mm_genpcl_genidata(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L2760;
L2767:
	asu64(R1) = p;
	R2 = (u64)&mm_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("IDATA: ");
	mm_support_gerror_s(asu64(R3), asu64(R2), asu64(R1));
L2760:
L2759:
	return;
}

static u64 mm_genpcl_genmem_u(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L2804;
L2804:
	return asu64(R1);
}

static u64 mm_genpcl_genmem_d(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	goto L2805;
L2805:
	return asu64(R1);
}

static void mm_genpcl_genpushmem_d(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static u64 mm_genpcl_genmemaddr_d(u64 d) {
    u64 R1; 
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	goto L2807;
L2807:
	return asu64(R1);
}

static void mm_genpcl_genpushmemaddr_d(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static i64 mm_genpcl_definelabel() {
    u64 R1, R2; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = pc_api_mlabelno;
	goto L2809;
L2809:
	return asi64(R1);
}

static i64 mm_genpcl_createfwdlabel() {
    u64 R1; 
	R1 = (u64)&pc_api_mlabelno;
	asi64(R1) = *(toi64p(R1)) += 1;
	goto L2810;
L2810:
	return asi64(R1);
}

static void mm_genpcl_definefwdlabel(i64 lab) {
    u64 R1, R2; 
	asi64(R1) = lab;
	asu64(R1) = pc_api_genlabel(asi64(R1));
	R2 = 127;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_genpcl_genreturn() {
    u64 R1, R2, R3; 
	asu64(R1) = mm_decls_currproc;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2814;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2815;
	goto L2816;
L2814:
	R1 = 0;
	R2 = 20;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	goto L2813;
L2815:
	R1 = 0;
	R2 = 23;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = mm_decls_currproc;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_libpcl_setmode(asi64(R1));
	goto L2813;
L2816:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	R3 = 122;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 23;
	pc_api_pc_genx(asi64(R3), asi64(R2), asu64(R1));
L2813:
	return;
}

static i64 mm_genpcl_reversecond(i64 cc) {
    u64 R1, R2; 
	asi64(R1) = cc;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2819;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2820;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2821;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2822;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2823;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2824;
	goto L2825;
L2819:
	R1 = 2;
	cc = asi64(R1);
	goto L2818;
L2820:
	R1 = 1;
	cc = asi64(R1);
	goto L2818;
L2821:
	R1 = 5;
	cc = asi64(R1);
	goto L2818;
L2822:
	R1 = 6;
	cc = asi64(R1);
	goto L2818;
L2823:
	R1 = 3;
	cc = asi64(R1);
	goto L2818;
L2824:
	R1 = 4;
	cc = asi64(R1);
	goto L2818;
L2825:
L2818:
	asi64(R1) = cc;
	goto L2817;
L2817:
	return asi64(R1);
}

static i64 mm_genpcl_reversecond_order(i64 cc) {
    u64 R1, R2; 
	asi64(R1) = cc;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2828;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2829;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2830;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L2831;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L2832;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L2833;
	goto L2834;
L2828:
	R1 = 1;
	cc = asi64(R1);
	goto L2827;
L2829:
	R1 = 2;
	cc = asi64(R1);
	goto L2827;
L2830:
	R1 = 6;
	cc = asi64(R1);
	goto L2827;
L2831:
	R1 = 5;
	cc = asi64(R1);
	goto L2827;
L2832:
	R1 = 4;
	cc = asi64(R1);
	goto L2827;
L2833:
	R1 = 3;
	cc = asi64(R1);
	goto L2827;
L2834:
L2827:
	asi64(R1) = cc;
	goto L2826;
L2826:
	return asi64(R1);
}

static void mm_genpcl_stacklooplabels(i64 a, i64 b, i64 c) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_genpcl_loopindex;
	(*toi64p(R1)) += 1;
	asi64(R1) = mm_genpcl_loopindex;
	R2 = 50;
	if (asi64(R1) <= asi64(R2)) goto L2837;
	R1 = 0;
	R2 = tou64("Too many nested loops");
	mm_support_gerror(asu64(R2), asu64(R1));
L2837:
	asi64(R1) = a;
	R2 = (u64)&mm_genpcl_loopstack;
	asi64(R3) = mm_genpcl_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = b;
	R2 = (u64)&mm_genpcl_loopstack;
	asi64(R3) = mm_genpcl_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 2;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&mm_genpcl_loopstack;
	asi64(R3) = mm_genpcl_loopindex;
	R2 += (i64)R3*32-32;
	R3 = 3;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	return;
}

static i64 mm_genpcl_findlooplabel(i64 k, i64 n) {
    u64 R1, R2, R3; 
	i64 i;
	asi64(R1) = mm_genpcl_loopindex;
	asi64(R2) = n;
	R3 = 1;
	asi64(R2) -= asi64(R3);
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2841;
	asi64(R1) = i;
	asi64(R2) = mm_genpcl_loopindex;
	if (asi64(R1) <= asi64(R2)) goto L2840;
L2841:
	R1 = 0;
	R2 = tou64("Bad loop index");
	mm_support_gerror(asu64(R2), asu64(R1));
L2840:
	R1 = (u64)&mm_genpcl_loopstack;
	asi64(R2) = i;
	R1 += (i64)R2*32-32;
	asi64(R2) = k;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	goto L2838;
L2838:
	return asi64(R1);
}

static void mm_genpcl_genpc_sysfn(i64 fnindex, u64 a, u64 b, u64 c) {
    u64 R1, R2, R3, R4, R5; 
	R1 = 1;
	asu64(R2) = c;
	asu64(R3) = b;
	asu64(R4) = a;
	asi64(R5) = fnindex;
	mm_genpcl_genpc_sysproc(asi64(R5), asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mm_genpcl_genpc_sysproc(i64 fnindex, u64 a, u64 b, u64 c, i64 asfunc) {
    u64 R1, R2, R3; 
	i64 nargs;
	i64 opc;
	u64 d;
	u64 p;
	R1 = 0;
	nargs = asi64(R1);
	R1 = 0;
	opc = asi64(R1);
	R1 = 0;
	R2 = 131;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = pc_api_pccurr;
	p = asu64(R1);
	R1 = (u64)&nargs;
	R2 = 3;
	asu64(R3) = c;
	mm_genpcl_pushsysarg(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&nargs;
	R2 = 2;
	asu64(R3) = b;
	mm_genpcl_pushsysarg(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&nargs;
	R2 = 1;
	asu64(R3) = a;
	mm_genpcl_pushsysarg(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = nargs;
	asu64(R2) = p;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = fnindex;
	asu64(R1) = mm_genpcl_getsysfnhandler(asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L2845;
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	asi64(R2) = asfunc;
	if (!asi64(R2)) goto L2847;
	R2 = 21;
	goto L2846;
L2847:
	R2 = 18;
L2846:
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = nargs;
	pc_api_pc_setnargs(asi64(R1));
	goto L2844;
L2845:
	R1 = (u64)&mm_tables_sysfnnames;
	asi64(R2) = fnindex;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	asu64(R1) = pc_api_gennameaddr(asu64(R1));
	asi64(R2) = asfunc;
	if (!asi64(R2)) goto L2849;
	R2 = 21;
	goto L2848;
L2849:
	R2 = 18;
L2848:
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2844:
	asi64(R1) = nargs;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_genpcl_pushsysarg(u64 p, i64 n, u64 nargs) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	if (!asu64(R1)) goto L2852;
	asu64(R1) = p;
	mm_blockpcl_evalunit(asu64(R1));
	R1 = 0;
	R2 = 132;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asu64(R1) = p;
	mm_libpcl_setmode_u(asu64(R1));
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 16;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = n;
	asu64(R2) = pc_api_pccurr;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = nargs;
	(*toi64p(R1)) += 1;
L2852:
	return;
}

static void mm_genpcl_start() {
    u64 R1, R2, R3; 
	R1 = 1;
	R2 = (u64)&mm_genpcl_zero_unit;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&mm_genpcl_zero_unit;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = (u64)&mm_genpcl_zero_unit;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	R2 = (u64)&mm_genpcl_zero_unit;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 mm_genpcl_getsysfnhandler(i64 fn) {
    u64 R1, R2, R3; 
	u64 p;
	struct $B15 str;
	i64 report;
	u64 pp;
	R1 = (u64)&mm_tables_sysfnhandlers;
	asi64(R2) = fn;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L2856;
	R1 = (u64)&mm_tables_sysfnhandlers;
	asi64(R2) = fn;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	goto L2854;
L2856:
	R1 = tou64("m$");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_tables_sysfnnames;
	asi64(R2) = fn;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = mm_decls_proclist;
	pp = asu64(R1);
	goto L2860;
L2857:
	R1 = (u64)&str;
	asu64(R2) = pp;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L2862;
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_tables_sysfnhandlers;
	asi64(R3) = fn;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L2854;
L2862:
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L2860:
	asu64(R1) = pp;
	if (asu64(R1)) goto L2857;
	R1 = 1;
	report = asi64(R1);
	R1 = 0;
	report = asi64(R1);
	asi64(R1) = report;
	if (!asi64(R1)) goto L2864;
	msysc_m$print_startcon();
	R1 = tou64("Sysfn not found:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L2864:
	asi64(R1) = fn;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L2866;
	R1 = 33;
	asu64(R1) = mm_genpcl_getsysfnhandler(asi64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2868;
	asi64(R1) = report;
	if (!asi64(R1)) goto L2868;
	R1 = 0;
	R2 = tou64("No m$unimpl");
	mm_support_gerror(asu64(R2), asu64(R1));
L2868:
	asu64(R1) = p;
	goto L2854;
L2866:
	R1 = 0;
	goto L2854;
L2854:
	return asu64(R1);
}

static u64 mm_genpcl_findhostfn(i64 opc) {
    u64 R1, R2; 
	asi64(R1) = opc;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2871;
	goto L2872;
L2871:
	R1 = 32;
	asu64(R1) = mm_genpcl_getsysfnhandler(asi64(R1));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	goto L2870;
L2872:
	R1 = 0;
L2870:
	goto L2869;
L2869:
	return asu64(R1);
}

static void mm_genpcl_genpushint(i64 a) {
    u64 R1, R2; 
	asi64(R1) = a;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_genpcl_genpushreal(r64 x, i64 mode) {
    u64 R1, R2; 
	asi64(R1) = mode;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asr64(R2) = x;
	asu64(R1) = pc_api_genreal(asr64(R2), asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	asi64(R1) = mode;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_genpcl_genpushstring(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R1) = pc_api_genstring(asu64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_genpcl_genmaindef(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	i64 i;
	asu64(R1) = p;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	mm_genpcl_doprocdef(asu64(R2), asi64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	mm_genpcl_retindex = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2879;
L2877:
	asi64(R1) = i;
	asi64(R2) = mm_decls_mainsubprogno;
	if (asi64(R1) == asi64(R2)) goto L2881;
	R1 = (u64)&mm_decls_modules;
	R2 = (u64)&mm_decls_subprogs;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 10;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	mm_genpcl_docallproc(asu64(R1));
L2881:
	i += 1; if (i <= mm_decls_nsubprogs) goto L2877;
L2879:
	R1 = (u64)&mm_decls_modules;
	R2 = (u64)&mm_decls_subprogs;
	asi64(R3) = mm_decls_mainsubprogno;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 10;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	mm_genpcl_docallproc(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asi64(R1) = mm_genpcl_retindex;
	mm_genpcl_definefwdlabel(asi64(R1));
	R1 = 0;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 1;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	R1 = 0;
	R2 = 32;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	mm_genpcl_genreturn();
	pc_api_pc_endproc();
	return;
}

static void mm_genpcl_genstartdef(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	i64 lead;
	i64 m;
	i64 s;
	i64 i;
	R1 = 0;
	lead = asi64(R1);
	asu64(R1) = p;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	s = asi64(R1);
	asi64(R1) = s;
	asi64(R2) = mm_decls_mainsubprogno;
	if (asi64(R1) != asi64(R2)) goto L2884;
	asu64(R1) = p;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_subprogs;
	asi64(R3) = s;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 10;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) != asi64(R2)) goto L2884;
	R1 = 1;
	lead = asi64(R1);
	goto L2883;
L2884:
	asu64(R1) = p;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_subprogs;
	asi64(R3) = s;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 8;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	if (asi64(R1) != asi64(R2)) goto L2885;
	R1 = 2;
	lead = asi64(R1);
L2885:
L2883:
	asu64(R1) = p;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = 0;
	asu64(R2) = p;
	mm_genpcl_doprocdef(asu64(R2), asi64(R1));
	asi64(R1) = mm_genpcl_createfwdlabel();
	mm_genpcl_retindex = asi64(R1);
	asi64(R1) = lead;
	if (!asi64(R1)) goto L2887;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2890;
L2888:
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = s;
	if (asi64(R1) != asi64(R2)) goto L2892;
	asi64(R1) = i;
	asi64(R2) = m;
	if (asi64(R1) == asi64(R2)) goto L2892;
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	mm_genpcl_docallproc(asu64(R1));
L2892:
	i += 1; if (i <= mm_decls_nmodules) goto L2888;
L2890:
L2887:
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
	R1 = tou64("------------------------");
	pc_api_gencomment(asu64(R1));
	asi64(R1) = mm_genpcl_retindex;
	mm_genpcl_definefwdlabel(asi64(R1));
	mm_genpcl_genreturn();
	pc_api_pc_endproc();
	return;
}

static void mm_genpcl_initstaticvar(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L2895;
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_blockpcl_evalunit(asu64(R1));
L2895:
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmem_d(asu64(R1));
	R2 = 4;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	return;
}

static void mm_genpcl_docallproc(u64 d) {
    u64 R1, R2; 
	asu64(R1) = d;
	if (asu64(R1)) goto L2898;
	goto L2896;
L2898:
	R1 = 0;
	R2 = 131;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 0;
	pc_api_pc_setnargs(asi64(R1));
	asu64(R1) = d;
	asu64(R1) = mm_genpcl_genmemaddr_d(asu64(R1));
	R2 = 18;
	pc_api_pc_gen(asi64(R2), asu64(R1));
L2896:
	return;
}

static void mm_genpcl_doprocdef(u64 d, i64 ismain) {
    u64 R1, R2, R3, R4, R5; 
	u64 p;
	u64 e;
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = ismain;
	R3 = 0;
	asu64(R4) = d;
	asu64(R4) = mm_libpcl_getpsymbol(asu64(R4));
	R5 = R4;
	p = asu64(R5);
	pc_api_pc_defproc(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L2903;
L2900:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L2905;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2906;
	goto L2907;
L2905:
	asu64(R1) = e;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addparam(asu64(R1));
	goto L2904;
L2906:
	asu64(R1) = e;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L2910;
	asu64(R1) = e;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L2909;
L2910:
	asu64(R1) = e;
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	pc_api_pc_addlocal(asu64(R1));
L2909:
	goto L2904;
L2907:
L2904:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L2903:
	asu64(R1) = e;
	if (asu64(R1)) goto L2900;
	return;
}

static void mm_genpcl_scanprocs() {
    u64 R1, R2, R3; 
	struct $B54 proctable;
	u64 currpcl;
	i64 nprocs;
	i64 i;
	R1 = 0;
	nprocs = asi64(R1);
	asu64(R1) = pc_api_pcstart;
	currpcl = asu64(R1);
L2912:
	asu64(R1) = currpcl;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L2917;
	R2 = 121;
	if (asi64(R1) != asi64(R2)) goto L2916;
L2917:
	asu64(R1) = currpcl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 109;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L2916;
	asi64(R1) = nprocs;
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L2919;
	R1 = 0;
	R2 = tou64("PCL proctab overflow");
	mm_support_gerror(asu64(R2), asu64(R1));
L2919:
	asu64(R1) = currpcl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&proctable;
	R3 = (u64)&nprocs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L2916:
	R1 = (u64)&currpcl;
	(*tou64p(R1)) += 32;
	asu64(R1) = currpcl;
	asu64(R2) = pc_api_pccurr;
	if (asu64(R1) <= asu64(R2)) goto L2912;
	asi64(R1) = nprocs;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L2921;
	asu64(R1) = mm_blockpcl_pnprocs;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2921;
	R1 = 3;
	R2 = tou64("$nprocs");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	mm_blockpcl_pnprocs = asu64(R1);
	R1 = 10;
	asu64(R2) = mm_blockpcl_pnprocs;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2922;
L2921:
	mm_genpcl_setfunctab();
	asu64(R1) = mm_blockpcl_pprocaddr;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 11;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = nprocs;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 11;
	asu64(R2) = mm_blockpcl_pprocaddr;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_api_pccurr;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = mm_blockpcl_pprocaddr;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nprocs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2925;
L2923:
	R1 = (u64)&proctable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = pc_api_genmemaddr(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	i += 1; if (i <= nprocs) goto L2923;
L2925:
	asu64(R1) = mm_blockpcl_pprocname;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 11;
	asu64(R2) = pc_api_pccurr;
	R3 = 3;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = nprocs;
	R2 = 8;
	asi64(R1) *= asi64(R2);
	asu64(R2) = pc_api_pccurr;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 11;
	asu64(R2) = mm_blockpcl_pprocname;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pc_api_pccurr;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = mm_blockpcl_pprocname;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nprocs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L2928;
L2926:
	R1 = (u64)&proctable;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = pc_api_getbasename(asu64(R1));
	asu64(R1) = pc_api_genstring(asu64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 4;
	mm_libpcl_setmode(asi64(R1));
	i += 1; if (i <= nprocs) goto L2926;
L2928:
// mm_genpcl.scanprocs.finish:
L2922:
	asu64(R1) = mm_blockpcl_pnprocs;
	asu64(R1) = pc_api_genmem(asu64(R1));
	R2 = 123;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	asi64(R1) = nprocs;
	asu64(R1) = pc_api_genint(asi64(R1));
	R2 = 125;
	pc_api_pc_gen(asi64(R2), asu64(R1));
	R1 = 3;
	mm_libpcl_setmode(asi64(R1));
	return;
}

static void mm_genpcl_setfunctab() {
    u64 R1, R2, R3; 
	asu64(R1) = mm_blockpcl_pnprocs;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L2931;
	R1 = 3;
	R2 = tou64("$nprocs");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	mm_blockpcl_pnprocs = asu64(R1);
	R1 = 10;
	asu64(R2) = mm_blockpcl_pnprocs;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = tou64("$procname");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	mm_blockpcl_pprocname = asu64(R1);
	R1 = 3;
	R2 = tou64("$procaddr");
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	mm_blockpcl_pprocaddr = asu64(R1);
L2931:
	return;
}

static void mm_lex_lex() {
    u64 R1, R2, R3, R4; struct $B3 R1_B3; 
	i64 lena;
	i64 lenb;
	u64 p;
	(R1_B3) = mm_decls_nextlx;
	mm_decls_lx = (R1_B3);
	asu64(R1) = mm_lex_lxstart;
	asu64(R2) = mm_lex_lxsource;
	asu64(R1) -= asu64(R2);
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 0;
	R4 = 23;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
L2933:
	mm_lex_lexreadtoken();
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L2935;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L2936;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L2937;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L2938;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L2939;
	goto L2940;
L2935:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L2943;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L2943;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L2943;
	R1 = (u64)&mm_tables_symboloptypes;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L2942;
	asi64(R1) = mm_decls_assemmode;
	if (asi64(R1)) goto L2942;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L2942;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L2942;
L2943:
	goto L2941;
L2942:
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2934;
L2941:
	goto L2933;
L2936:
	mm_lex_doinclude();
	goto L2933;
L2937:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L2945;
	goto L2946;
L2945:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L2948;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L2949;
	goto L2950;
L2948:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2952;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2953;
	goto L2954;
L2952:
	R1 = 1000000;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) *= asi64(R1);
	goto L2951;
L2953:
	R1 = 1000000000;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	R2 += (i64)R3;
	*toi64p(R2) *= asi64(R1);
	goto L2951;
L2954:
	R1 = tou64("Can't do this unit index");
	mm_support_lxerror(asu64(R1));
L2951:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2947;
L2949:
	R1 = tou64("Unit suffix after float not implem");
	mm_support_lxerror(asu64(R1));
	goto L2947;
L2950:
	R1 = 67;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2934;
L2947:
	goto L2944;
L2946:
	R1 = 67;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2934;
L2944:
	goto L2933;
L2938:
	R1 = 67;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2934;
	goto L2933;
L2939:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 47;
	if (asi64(R1) != asi64(R2)) goto L2956;
	R1 = 45;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2955;
L2956:
	goto L2934;
L2955:
	goto L2933;
L2940:
	goto L2934;
	goto L2933;
L2934:
	asi64(R1) = mm_lex_lxfileno;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 4;
	R2 += (i64)R3;
	R3 = 24;
	R4 = 31;
    *toi64p(R2) = Setdotslice(*toi64p(R2), (i64)R3, (i64)R4, (i64)R1);
	return;
}

static void mm_lex_lexreadtoken() {
    u64 R1, R2, R3; 
	i64 c;
	i64 hsum;
	u64 sptr;
	u64 lxsvalue;
	i64 length;
	i64 commentseen;
	u64 p;
	u64 q;
	u8 instr;
	struct $B16 str;
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L2958:
	asu64(R1) = mm_lex_lxsptr;
	mm_lex_lxstart = asu64(R1);
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 0: goto L3081;
	case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 11: case 12: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: goto L2961;
	case 9: case 32: goto L3078;
	case 10: goto L3080;
	case 13: goto L3079;
	case 33: goto L2987;
	case 34: goto L3076;
	case 35: goto L2995;
	case 36: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: goto L2962;
	case 37: goto L3054;
	case 38: goto L3070;
	case 39: goto L3075;
	case 40: goto L3029;
	case 41: goto L3030;
	case 42: goto L3050;
	case 43: goto L3042;
	case 44: goto L3023;
	case 45: goto L3045;
	case 46: goto L3015;
	case 47: goto L3053;
	case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: goto L2978;
	case 58: goto L3025;
	case 59: goto L3024;
	case 60: goto L3059;
	case 61: goto L3055;
	case 62: goto L3065;
	case 63: goto L3036;
	case 64: goto L3035;
	case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: goto L2977;
	case 91: goto L3031;
	case 92: goto L2996;
	case 93: goto L3032;
	case 94: goto L3034;
	case 96: goto L3077;
	case 123: goto L3013;
	case 124: goto L3033;
	case 125: goto L3014;
	case 126: goto L3041;
	default: goto L2961;
    };
// SWITCH
L2962:
	asu64(R1) = mm_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	lxsvalue = asu64(R1);
// mm_lex.lexreadtoken.doname:
L2963:
	asu64(R1) = lxsvalue;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	hsum = asi64(R1);
	asu64(R1) = mm_lex_lxsptr;
	sptr = asu64(R1);
L2964:
	R1 = (u64)&mm_lex_namemap;
	R2 = (u64)&sptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	R3 = R2;
	c = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L2966;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L2967;
	goto L2968;
L2966:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L2964;
L2967:
	asi64(R1) = c;
	R2 = 32;
	asu64(R1) += asu64(R2);
	asu64(R2) = sptr;
	R3 = 1;
	R2 -= (i64)R3;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 32;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L2964;
L2968:
	asu64(R1) = sptr;
	R2 = 1;
	R1 -= (i64)R2;
	mm_lex_lxsptr = asu64(R1);
	goto L2965;
	goto L2964;
L2965:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) != asi64(R2)) goto L2970;
	asu64(R1) = lxsvalue;
	R2 = 1;
	R1 += (i64)R2;
	asu64(R2) = mm_lex_lxsptr;
	if (asu64(R1) != asu64(R2)) goto L2972;
	asu64(R1) = lxsvalue;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	asi32(R1) = toupper(asi32(R1));
	R1 = toi64(toi32(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L2974;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L2974;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L2975;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L2975;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L2975;
	goto L2976;
L2974:
	mm_lex_readrawstring();
	goto L2957;
	goto L2973;
L2975:
	asi64(R1) = c;
	mm_lex_readarraystring(asi64(R1));
	goto L2957;
	goto L2973;
L2976:
L2973:
L2972:
L2970:
	asi64(R1) = hsum;
	asu64(R2) = mm_lex_lxsptr;
	asu64(R3) = lxsvalue;
	asi64(R2) -= asi64(R3);
	asu64(R3) = lxsvalue;
	mm_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	goto L2957;
	goto L2958;
L2977:
	asu64(R1) = mm_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	lxsvalue = asu64(R1);
	R1 = 32;
	asu64(R2) = lxsvalue;
	*tou8p(R2) += asu8(R1);
	goto L2963;
	goto L2958;
L2978:
	asu64(R1) = mm_lex_lxsptr;
	R2 = 1;
	R1 -= (i64)R2;
	mm_lex_lxstart = asu64(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 41;
	if (asu64(R1) == asu64(R2)) goto L2980;
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L2980;
	R2 = 44;
	if (asu64(R1) == asu64(R2)) goto L2980;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L2980;
	R2 = 120;
	if (asu64(R1) == asu64(R2)) goto L2981;
	R2 = 88;
	if (asu64(R1) == asu64(R2)) goto L2981;
	goto L2982;
L2980:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxstart;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L2979;
L2981:
	asu64(R1) = mm_lex_lxstart;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 48;
	if (asu64(R1) == asu64(R2)) goto L2984;
	R2 = 50;
	if (asu64(R1) == asu64(R2)) goto L2985;
	goto L2986;
L2984:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	mm_lex_readhex();
	goto L2983;
L2985:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	mm_lex_readbin();
	goto L2983;
L2986:
	R1 = tou64("Bad base");
	mm_support_lxerror(asu64(R1));
L2983:
	goto L2979;
L2982:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	mm_lex_readdec();
L2979:
	goto L2957;
	goto L2958;
L2987:
// mm_lex.lexreadtoken.docomment:
L2989:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L2991;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L2992;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L2993;
	goto L2994;
L2991:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L2990;
	goto L2989;
L2992:
	goto L2990;
	goto L2989;
L2993:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2990;
	goto L2989;
L2994:
	goto L2989;
L2990:
	R1 = 58;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L2995:
	R1 = 23;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L2996:
	R1 = 0;
	commentseen = asi64(R1);
L2997:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L2999;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3000;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3001;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L3002;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L3002;
	R2 = 33;
	if (asu64(R1) == asu64(R2)) goto L3003;
	goto L3004;
L2999:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L2998;
	goto L2997;
L3000:
	goto L2998;
	goto L2997;
L3001:
	R1 = 59;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2957;
	goto L2997;
L3002:
	goto L2997;
L3003:
	R1 = 1;
	commentseen = asi64(R1);
	goto L2997;
L3004:
	asi64(R1) = commentseen;
	if (asi64(R1)) goto L3006;
	R1 = tou64("\\ not followed by eol");
	mm_support_lxerror(asu64(R1));
L3006:
	goto L2997;
L2998:
L3007:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 13;
	if (asu64(R1) == asu64(R2)) goto L3009;
	R2 = 10;
	if (asu64(R1) == asu64(R2)) goto L3010;
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L3011;
	R2 = 9;
	if (asu64(R1) == asu64(R2)) goto L3011;
	goto L3012;
L3009:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3007;
L3010:
	goto L3007;
L3011:
	goto L3007;
L3012:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3008;
	goto L3007;
L3008:
	goto L2958;
L3013:
	R1 = 13;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3014:
	R1 = 14;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3015:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L3017;
	goto L3018;
L3017:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) != asu64(R2)) goto L3020;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 22;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3019;
L3020:
	R1 = 21;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 21;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3019:
	goto L2957;
	goto L3016;
L3018:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L3022;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L3022;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	R1 = tou64(".123 not done");
	mm_support_lxerror(asu64(R1));
	goto L2957;
	goto L3021;
L3022:
	R1 = 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
L3021:
L3016:
	goto L2958;
L3023:
	R1 = 3;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3024:
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3025:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3027;
	goto L3028;
L3027:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 6;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 28;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3026;
L3028:
	R1 = 5;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3026:
	goto L2957;
	goto L2958;
L3029:
	R1 = 9;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3030:
	R1 = 10;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3031:
	R1 = 11;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3032:
	R1 = 12;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3033:
	R1 = 16;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3034:
	R1 = 15;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3035:
	R1 = 17;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3036:
	R1 = (u64)&str;
	p = asu64(R1);
	asu64(R1) = mm_lex_lxsptr;
	R2 = 1;
	R1 += (i64)R2;
	q = asu64(R1);
	goto L3038;
L3037:
	R1 = (u64)&q;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&p;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3038:
	asu64(R1) = q;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3040;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3040;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3037;
L3040:
	R1 = 0;
	asu64(R2) = p;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 18;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3041:
	goto L2958;
L3042:
	R1 = 24;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 43;
	if (asu64(R1) != asu64(R2)) goto L3044;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 61;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 84;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
L3044:
	goto L2957;
	goto L2958;
L3045:
	R1 = 25;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) == asu64(R2)) goto L3047;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L3048;
	goto L3049;
L3047:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 61;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 85;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L3046;
L3048:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 8;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L3046;
L3049:
L3046:
	goto L2957;
	goto L2958;
L3050:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 42;
	if (asu64(R1) != asu64(R2)) goto L3052;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 43;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3051;
L3052:
	R1 = 26;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3051:
	goto L2957;
	goto L2958;
L3053:
	R1 = 27;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3054:
	R1 = 28;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3055:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L3057;
	goto L3058;
L3057:
	R1 = 7;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3056;
L3058:
	R1 = 41;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3056:
	goto L2957;
	goto L2958;
L3059:
	R1 = 42;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3061;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L3062;
	R2 = 60;
	if (asu64(R1) == asu64(R2)) goto L3063;
	goto L3064;
L3061:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3060;
L3062:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 2;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3060;
L3063:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 34;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3060;
L3064:
	R1 = 3;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3060:
	goto L2957;
	goto L2958;
L3065:
	R1 = 42;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) == asu64(R2)) goto L3067;
	R2 = 62;
	if (asu64(R1) == asu64(R2)) goto L3068;
	goto L3069;
L3067:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 42;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 5;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3066;
L3068:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 35;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3066;
L3069:
	R1 = 42;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 6;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3066:
	goto L2957;
	goto L2958;
L3070:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 38;
	if (asu64(R1) == asu64(R2)) goto L3072;
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L3073;
	goto L3074;
L3072:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 20;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 57;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3071;
L3073:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 2;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3071;
L3074:
	R1 = 19;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 55;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3071:
	goto L2957;
	goto L2958;
L3075:
	R1 = 39;
	mm_lex_lxreadstring(asi64(R1));
	goto L2957;
	goto L2958;
L3076:
	R1 = 34;
	mm_lex_lxreadstring(asi64(R1));
	goto L2957;
	goto L2958;
L3077:
	mm_lex_readrawxname();
	goto L2957;
	goto L2958;
L3078:
	goto L2958;
L3079:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 58;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3080:
	R1 = 58;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L2957;
	goto L2958;
L3081:
	asi64(R1) = mm_lex_sourcelevel;
	if (!asi64(R1)) goto L3083;
	mm_lex_unstacksource();
	goto L2957;
	goto L3082;
L3083:
	R1 = 59;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L2957;
L3082:
	goto L2958;
L2961:
	R1 = tou64("Unknown char");
	mm_support_lxerror(asu64(R1));
	goto L2957;
	goto L2958;
L2957:
	return;
}

static void mm_lex_lexsetup() {
	mm_lex_inithashtable();
	return;
}

static void mm_lex_printstrn(u64 s, i64 length) {
    u64 R1, R2; 
	asi64(R1) = length;
	if (!asi64(R1)) goto L3087;
	msysc_m$print_startcon();
	R1 = tou64("v");
	asi64(R2) = length;
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64(".*");
	asu64(R2) = s;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
L3087:
	return;
}

static void mm_lex_readrawstring() {
    u64 R1, R2, R3; 
	u64 dest;
	i64 c;
	R1 = 65;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R1) = *(tou64p(R1)) += 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = mm_lex_lxsptr;
	dest = asu64(R1);
L3089:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L3091;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3092;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3092;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3092;
	goto L3093;
L3091:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 34;
	if (asu64(R1) != asu64(R2)) goto L3095;
	R1 = 34;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	goto L3094;
L3095:
	goto L3090;
L3094:
	goto L3089;
L3092:
	R1 = tou64("Raw string not terminated");
	mm_support_lxerror(asu64(R1));
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3090;
	goto L3089;
L3093:
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3089;
L3090:
	asu64(R1) = mm_lex_lxsptr;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mm_decls_nextlx;
	R3 = 2;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = (u64)&mm_decls_nextlx;
	R2 = 2;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_lex_lookup(u64 name, i64 length, i64 hashindex) {
    u64 R1, R2, R3, R4; 
	i64 wrapped;
	i64 j;
	u64 d;
	asi64(R1) = hashindex;
	R2 = 65535;
	asi64(R1) &= asi64(R2);
	j = asi64(R1);
	R1 = (u64)&mm_lex_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L3097:
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3100;
	goto L3098;
L3100:
	asu64(R1) = d;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = length;
	if (asi64(R1) != asi64(R2)) goto L3102;
	asi64(R1) = length;
	asu64(R2) = name;
	asu64(R3) = d;
	R4 = 0;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asi32(R1) = memcmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3102;
	asu64(R1) = d;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 77;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 79;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3096;
L3102:
	R1 = (u64)&j;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 65536;
	if (asi64(R1) < asi64(R2)) goto L3104;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L3106;
	R1 = tou64("HASHTABLE FULL");
	mlib_abortprogram(asu64(R1));
L3106:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	j = asi64(R1);
L3104:
	R1 = (u64)&mm_lex_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	goto L3097;
L3098:
	R1 = 176;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = (u64)&mm_lex_hashtable;
	asi64(R3) = j;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = name;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	asu64(R2) = d;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = d;
	R3 = 76;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = d;
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 77;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3096:
	return;
}

static i64 mm_lex_lookupsys(u64 name) {
    u64 R1, R2, R3; 
	i64 j;
	i64 wrapped;
	i64 hashvalue;
	asu64(R1) = name;
	asi64(R1) = mm_lex_gethashvaluez(asu64(R1));
	R2 = 65535;
	asi64(R1) &= asi64(R2);
	j = asi64(R1);
	R1 = (u64)&mm_lex_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	wrapped = asi64(R1);
L3108:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3111;
	goto L3109;
	goto L3110;
L3111:
	asu64(R1) = name;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3112;
	msysc_m$print_startcon();
	R1 = tou64("Lex dupl name:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
L3112:
L3110:
	R1 = (u64)&j;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 65536;
	if (asi64(R1) < asi64(R2)) goto L3114;
	asi64(R1) = wrapped;
	if (!asi64(R1)) goto L3116;
	R1 = tou64("SYS:HASHTABLE FULL");
	mlib_abortprogram(asu64(R1));
L3116:
	R1 = 1;
	wrapped = asi64(R1);
	R1 = 0;
	j = asi64(R1);
L3114:
	R1 = (u64)&mm_lex_hashtable;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3108;
L3109:
	R1 = 176;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_lex_hashtable;
	asi64(R3) = j;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = name;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = name;
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 76;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	goto L3107;
L3107:
	return asi64(R1);
}

static i64 mm_lex_gethashvaluez(u64 s) {
    u64 R1, R2; 
	i64 c;
	i64 hsum;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3119;
	R1 = 0;
	goto L3117;
L3119:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	hsum = asi64(R1);
L3120:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3123;
	goto L3121;
L3123:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
	goto L3120;
L3121:
	asi64(R1) = hsum;
	goto L3117;
L3117:
	return asi64(R1);
}

static void mm_lex_inithashtable() {
    u64 R1, R2, R3; 
	i64 i;
	i64 av_1;
	R1 = 524288;
	R2 = 0;
	R3 = (u64)&mm_lex_hashtable;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 1;
	i = asi64(R1);
	R1 = 174;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3127;
L3125:
	R1 = (u64)&mm_tables_stnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = mm_lex_lookupsys(asu64(R1));
	R1 = (u64)&mm_tables_stsymbols;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_tables_stsymbols;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L3129;
	goto L3130;
L3129:
	R1 = (u64)&mm_tables_stsubcodes;
	asi64(R2) = i;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&mm_tables_stsymbols;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 79;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3128;
L3130:
	R1 = (u64)&mm_tables_stsubcodes;
	asi64(R2) = i;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 79;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3128:
	i += 1; if (i <= av_1) goto L3125;
L3127:
	return;
}

static void mm_lex_printhashtable() {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("Hashtable:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_lex_addreservedword(u64 name, i64 symbol, i64 subcode, i64 regsize) {
    u64 R1, R2, R3; 
	asu64(R1) = name;
	asi64(R1) = mm_lex_lookupsys(asu64(R1));
	R1 = 67;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = symbol;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 79;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = subcode;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 80;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = regsize;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 164;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	return;
}

static void mm_lex_doinclude() {
    u64 R1, R2, R3; 
	u64 file;
	u64 pf;
	mm_lex_lexreadtoken();
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L3135;
	R1 = tou64("include: string expected");
	mm_support_lxerror(asu64(R1));
L3135:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	file = asu64(R1);
	asu64(R1) = file;
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = tou64("m");
	asu64(R2) = file;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	file = asu64(R1);
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = mm_lex_lxfileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("");
	asu64(R3) = file;
	asu64(R1) = mm_support_getsupportfile(asu64(R3), asu64(R2), asu64(R1));
	pf = asu64(R1);
	mm_lex_lexreadtoken();
	R1 = 0;
	asu64(R2) = pf;
	R3 = 64;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	mm_lex_stacksource(asi64(R2), asi64(R1));
	return;
}

static void mm_lex_startlex(u64 file) {
    u64 R1, R2, R3; 
	asu64(R1) = file;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	mm_lex_lxsptr = asu64(R2);
	mm_lex_lxsource = asu64(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = file;
	R2 = 64;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	mm_lex_lxfileno = asi64(R1);
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 mm_lex_addnamestr(u64 name) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	struct $B3 oldlx;
	u64 symptr;
	(R1_B3) = mm_decls_nextlx;
	oldlx = (R1_B3);
	asu64(R1) = name;
	asi64(R1) = mm_lex_gethashvaluez(asu64(R1));
	asu64(R2) = name;
	asi64(R2) = strlen(asu64(R2));
	asu64(R3) = name;
	mm_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_nextlx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	symptr = asu64(R1);
	(R1_B3) = oldlx;
	mm_decls_nextlx = (R1_B3);
	asu64(R1) = symptr;
	goto L3137;
L3137:
	return asu64(R1);
}

static void mm_lex_ps(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("PS:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_decls_lx;
	mm_diags_dummy_printsymbol(asu64(R1));
	return;
}

static void mm_lex_psnext(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_decls_nextlx;
	mm_diags_dummy_printsymbol(asu64(R1));
	return;
}

static void mm_lex_psx(u64 caption) {
    u64 R1; 
	msysc_m$print_startcon();
	asu64(R1) = caption;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = tou64(": ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_decls_lx;
	mm_diags_dummy_printsymbol(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_decls_nextlx;
	mm_diags_dummy_printsymbol(asu64(R1));
	return;
}

static void mm_lex_stacksource(i64 fileno, i64 isimport) {
    u64 R1, R2, R3; struct $B3 R1_B3; 
	asi64(R1) = mm_lex_sourcelevel;
	R2 = 20;
	if (asi64(R1) < asi64(R2)) goto L3143;
	R1 = tou64("Include file/macro overflow");
	mm_support_lxerror(asu64(R1));
L3143:
	R1 = (u64)&mm_lex_sourcelevel;
	(*toi64p(R1)) += 1;
	asu64(R1) = mm_lex_lxstart;
	R2 = (u64)&mm_lex_lxstart_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mm_lex_lxsource;
	R2 = (u64)&mm_lex_lxsource_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mm_lex_lxsptr;
	R2 = (u64)&mm_lex_lxsptr_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = mm_lex_lxfileno;
	R2 = (u64)&mm_lex_lxfileno_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	(R1_B3) = mm_decls_nextlx;
	R2 = (u64)&mm_lex_lxnextlx_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*(struct $B3*)(((i64)R2+(i64)R3*16-16)) = (R1_B3);
	asi64(R1) = mm_lex_lximport;
	R2 = (u64)&mm_lex_lximport_stack;
	asi64(R3) = mm_lex_sourcelevel;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	asi64(R1) = isimport;
	mm_lex_lximport = asi64(R1);
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	mm_lex_lxsptr = asu64(R2);
	mm_lex_lxsource = asu64(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = fileno;
	mm_lex_lxfileno = asi64(R1);
	R1 = 4;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_lex_unstacksource() {
    u64 R1, R2; struct $B3 R1_B3; 
	asi64(R1) = mm_lex_sourcelevel;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3146;
	R1 = (u64)&mm_lex_lxstart_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_lex_lxstart = asu64(R1);
	R1 = (u64)&mm_lex_lxsource_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_lex_lxsource = asu64(R1);
	R1 = (u64)&mm_lex_lxsptr_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_lex_lxsptr = asu64(R1);
	R1 = (u64)&mm_lex_lxnextlx_stack;
	asi64(R2) = mm_lex_sourcelevel;
	(R1_B3) = *(struct $B3*)(((i64)R1+(i64)R2*16-16));
	mm_decls_nextlx = (R1_B3);
	R1 = (u64)&mm_lex_lxfileno_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2*8-8));
	mm_lex_lxfileno = asi64(R1);
	R1 = (u64)&mm_lex_lximport_stack;
	asi64(R2) = mm_lex_sourcelevel;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	mm_lex_lximport = asi64(R1);
	R1 = (u64)&mm_lex_sourcelevel;
	(*toi64p(R1)) -=1;
L3146:
	return;
}

static void mm_lex_readarraystring(i64 prefix) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
	R1 = 34;
	mm_lex_lxreadstring(asi64(R1));
	asi64(R1) = prefix;
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L3149;
	R1 = 83;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3148;
L3149:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 2;
	R1 += (i64)R2;
	(*tou16p(R1)) -=1;
	R1 = 66;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3148:
	return;
}

static i64 mm_lex_setinttype(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 9223372036854775807;
	if (asu64(R1) > asu64(R2)) goto L3152;
	R1 = 3;
	goto L3151;
L3152:
	R1 = 4;
L3151:
	goto L3150;
L3150:
	return asi64(R1);
}

static void mm_lex_readrawxname() {
    u64 R1, R2, R3, R4; 
	i64 c;
	i64 hsum;
	i64 length;
	asu64(R1) = mm_lex_lxsptr;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	hsum = asi64(R1);
	goto L3155;
L3154:
	asi64(R1) = hsum;
	R2 = 4;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = hsum;
	asi64(R1) -= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	hsum = asi64(R1);
L3155:
	R1 = (u64)&mm_lex_namemap;
	R2 = (u64)&mm_lex_lxsptr;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	R3 = R2;
	c = asi64(R3);
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3154;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	asu64(R1) = mm_lex_lxsptr;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3158;
	R1 = tou64("Bad ` name");
	mm_support_lxerror(asu64(R1));
L3158:
	asi64(R1) = hsum;
	asi64(R2) = length;
	R3 = (u64)&mm_decls_nextlx;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_lex_lookup(asu64(R3), asi64(R2), asi64(R1));
	R1 = 60;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3153;
L3153:
	return;
}

static void mm_lex_lxerror_s(u64 mess, u64 s) {
    u64 R1; 
	asu64(R1) = mess;
	mm_support_lxerror(asu64(R1));
	return;
}

static void mm_lex_lxreadstring(i64 termchar) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 t;
	i64 c;
	i64 d;
	i64 length;
	i64 hasescape;
	i64 a;
	i64 n;
	u64 str;
	i64 pass;
	asi64(R1) = termchar;
	R2 = 34;
	if (asi64(R1) != asi64(R2)) goto L3162;
	R1 = 65;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3161;
L3162:
	R1 = 64;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3161:
	R1 = 0;
	length = asi64(R1);
	R1 = 0;
	hasescape = asi64(R1);
	R1 = 0;
	t = asu64(R1);
	R1 = 1;
	pass = asi64(R1);
L3163:
	asu64(R1) = mm_lex_lxsptr;
	s = asu64(R1);
L3166:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L3169;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L3170;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3170;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3171;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3171;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3171;
	goto L3172;
L3169:
	R1 = 1;
	hasescape = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L3174;
	asi64(R1) = c;
	R2 = 90;
	if (asi64(R1) > asi64(R2)) goto L3174;
	R1 = 32;
	R2 = (u64)&c;
	*toi64p(R2) += asi64(R1);
L3174:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) == asi64(R2)) goto L3176;
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L3177;
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L3178;
	R2 = 114;
	if (asi64(R1) == asi64(R2)) goto L3178;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L3179;
	R2 = 102;
	if (asi64(R1) == asi64(R2)) goto L3180;
	R2 = 104;
	if (asi64(R1) == asi64(R2)) goto L3181;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L3182;
	R2 = 110;
	if (asi64(R1) == asi64(R2)) goto L3182;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L3183;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L3184;
	R2 = 118;
	if (asi64(R1) == asi64(R2)) goto L3184;
	R2 = 119;
	if (asi64(R1) == asi64(R2)) goto L3185;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L3186;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L3187;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L3188;
	goto L3189;
L3176:
	R1 = 7;
	c = asi64(R1);
	goto L3175;
L3177:
	R1 = 8;
	c = asi64(R1);
	goto L3175;
L3178:
	R1 = 13;
	c = asi64(R1);
	goto L3175;
L3179:
	R1 = 27;
	c = asi64(R1);
	goto L3175;
L3180:
	R1 = 12;
	c = asi64(R1);
	goto L3175;
L3181:
	goto L3191;
L3190:
	R1 = 1;
	R2 = 2;
	R3 = (u64)&s;
	asi64(R1) = mm_lex_readhexcode(asu64(R3), asi64(R2), asi64(R1));
	c = asi64(R1);
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3194;
	asi64(R1) = c;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L3194:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
L3191:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 92;
	if (asu64(R1) != asu64(R2)) goto L3190;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	R1 = (u64)&t;
	(*tou64p(R1)) -=1;
	goto L3175;
L3182:
	R1 = 10;
	c = asi64(R1);
	goto L3175;
L3183:
	R1 = 9;
	c = asi64(R1);
	goto L3175;
L3184:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3196;
	asu64(R1) = t;
	goto L3195;
L3196:
	R1 = 0;
L3195:
	R2 = 0;
	asi64(R3) = c;
	R4 = 117;
	if (asi64(R3) != asi64(R4)) goto L3198;
	R3 = 4;
	goto L3197;
L3198:
	R3 = 6;
L3197:
	R4 = (u64)&s;
	asi64(R2) = mm_lex_readhexcode(asu64(R4), asi64(R3), asi64(R2));
	asi64(R1) = mm_lex_getutf8(asi64(R2), asu64(R1));
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	goto L3166;
	goto L3175;
L3185:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3200;
	R1 = 13;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L3200:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	R1 = 10;
	c = asi64(R1);
	goto L3175;
L3186:
	R1 = 0;
	R2 = 2;
	R3 = (u64)&s;
	asi64(R1) = mm_lex_readhexcode(asu64(R3), asi64(R2), asi64(R1));
	c = asi64(R1);
	goto L3175;
L3187:
	R1 = 16;
	c = asi64(R1);
	goto L3175;
L3188:
	R1 = 0;
	c = asi64(R1);
	goto L3175;
L3189:
	asi64(R1) = c;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L3202;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L3203;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3204;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L3205;
	goto L3206;
L3202:
	R1 = 34;
	c = asi64(R1);
	goto L3201;
L3203:
	R1 = 92;
	c = asi64(R1);
	goto L3201;
L3204:
	R1 = 39;
	c = asi64(R1);
	goto L3201;
L3205:
	R1 = 0;
	c = asi64(R1);
	goto L3201;
L3206:
	asi64(R1) = c;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&str;
	R2 = tou64("Unknown string escape: \\%s");
	mm_lex_lxerror_s(asu64(R2), asu64(R1));
L3201:
L3175:
	goto L3168;
L3170:
	asi64(R1) = c;
	asi64(R2) = termchar;
	if (asi64(R1) != asi64(R2)) goto L3208;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	asi64(R2) = c;
	if (asi64(R1) != asi64(R2)) goto L3210;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	goto L3209;
L3210:
	goto L3167;
L3209:
L3208:
	R1 = 1;
	hasescape = asi64(R1);
	goto L3168;
L3171:
	R1 = tou64("String not terminated");
	mm_support_lxerror(asu64(R1));
	goto L3168;
L3172:
L3168:
	asi64(R1) = pass;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L3212;
	asi64(R1) = c;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
L3212:
	R1 = (u64)&t;
	(*tou64p(R1)) += 1;
	goto L3166;
L3167:
	asi64(R1) = pass;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3214;
	asu64(R1) = t;
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	R2 = (u64)&mm_decls_nextlx;
	R3 = 2;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asi64(R1) = hasescape;
	if (!asi64(R1)) goto L3216;
	asi64(R1) = length;
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	t = asu64(R2);
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3215;
L3216:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3217;
	R1 = tou64("");
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = s;
	mm_lex_lxsptr = asu64(R1);
	goto L3160;
	goto L3215;
L3217:
	asi64(R1) = length;
	asu64(R2) = mm_lex_lxsptr;
	asu64(R1) = mlib_pcm_copyheapstringn(asu64(R2), asi64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = s;
	mm_lex_lxsptr = asu64(R1);
	goto L3160;
L3215:
	goto L3213;
L3214:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	asu64(R1) = s;
	mm_lex_lxsptr = asu64(R1);
L3213:
	pass += 1; if (pass <= 2) goto L3163;
L3160:
	return;
}

static i64 mm_lex_readhexcode(u64 s, i64 n, i64 sp) {
    u64 R1, R2; 
	i64 a;
	i64 c;
	i64 i;
	R1 = 0;
	a = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3221;
L3219:
	asi64(R1) = sp;
	if (!asi64(R1)) goto L3223;
	asi64(R1) = i;
	R2 = 0;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L3223;
L3224:
	asu64(R1) = s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L3224;
	goto L3222;
L3223:
	asu64(R1) = s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	c = asi64(R1);
L3222:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L3228;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L3228;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	a = asi64(R1);
	goto L3227;
L3228:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L3229;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L3229;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asi64(R1) += asi64(R2);
	a = asi64(R1);
	goto L3227;
L3229:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L3230;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L3230;
	asi64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	a = asi64(R1);
	goto L3227;
L3230:
	R1 = tou64("Bad hex digit");
	mm_support_lxerror(asu64(R1));
L3227:
	i += 1; if (i <= n) goto L3219;
L3221:
	asi64(R1) = a;
	goto L3218;
L3218:
	return asi64(R1);
}

static i64 mm_lex_getutf8(i64 c, u64 s) {
    u64 R1, R2, R3, R4; 
	i64 n;
	struct $B3 str;
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3233;
	R1 = (u64)&str;
	s = asu64(R1);
L3233:
	asi64(R1) = c;
	R2 = 127;
	if (asi64(R1) > asi64(R2)) goto L3235;
	R1 = 1;
	n = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3234;
L3235:
	asi64(R1) = c;
	R2 = 2047;
	if (asi64(R1) > asi64(R2)) goto L3236;
	R1 = 2;
	n = asi64(R1);
	R1 = 192;
	asi64(R2) = c;
	R3 = 6;
	R4 = 10;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3234;
L3236:
	asi64(R1) = c;
	R2 = 65535;
	if (asi64(R1) > asi64(R2)) goto L3237;
	R1 = 3;
	n = asi64(R1);
	R1 = 224;
	asi64(R2) = c;
	R3 = 12;
	R4 = 15;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 6;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3234;
L3237:
	asi64(R1) = c;
	R2 = 1114111;
	if (asi64(R1) > asi64(R2)) goto L3238;
	R1 = 4;
	n = asi64(R1);
	R1 = 240;
	asi64(R2) = c;
	R3 = 18;
	R4 = 20;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 12;
	R4 = 17;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 6;
	R4 = 11;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = 128;
	asi64(R2) = c;
	R3 = 0;
	R4 = 5;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) += asu64(R2);
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3234;
L3238:
	R1 = 0;
	n = asi64(R1);
L3234:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = n;
	goto L3231;
L3231:
	return asi64(R1);
}

static void mm_lex_readdec() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 islong;
	i64 length;
	struct $B39 str;
	u64 a;
	i64 av_1;
	R1 = 0;
	islong = asi64(R1);
	asu64(R1) = mm_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L3240:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L3243;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L3243;
	asu64(R1) = a;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3242;
L3243:
	asi64(R1) = c;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L3245;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L3245;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L3246;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L3247;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3247;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L3248;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L3248;
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L3249;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L3249;
	goto L3250;
L3245:
	asu64(R1) = pstart;
	mm_lex_lxsptr = asu64(R1);
	mm_lex_readreal();
	goto L3239;
	goto L3244;
L3246:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 46;
	if (asu64(R1) == asu64(R2)) goto L3252;
	asu64(R1) = pstart;
	mm_lex_lxsptr = asu64(R1);
	mm_lex_readreal();
	goto L3239;
L3252:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3241;
	goto L3244;
L3247:
	goto L3244;
L3248:
	mm_lex_nodecimal();
	goto L3244;
L3249:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L3254;
	R1 = tou64("bin overflow");
	mm_support_lxerror(asu64(R1));
L3254:
	R1 = (u64)&str;
	dest = asu64(R1);
	R1 = 0;
	a = asu64(R1);
	asi64(R1) = length;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3257;
L3255:
	asu64(R1) = dest;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 50;
	if (asu64(R1) < asu64(R2)) goto L3259;
	R1 = tou64("bad bin digit");
	mm_support_lxerror(asu64(R1));
L3259:
	asu64(R1) = a;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	if (--asi64(av_1)) goto L3255;
L3257:
	goto L3260;
	goto L3244;
L3250:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3241;
L3244:
L3242:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L3262;
	R1 = tou64("Numlit too long");
	mm_support_lxerror(asu64(R1));
L3262:
	goto L3240;
L3241:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) > asi64(R2)) goto L3265;
	asi64(R1) = length;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L3264;
	R1 = 20;
	asu64(R2) = mm_lex_u64maxstr;
	R3 = (u64)&str;
	asi32(R1) = strncmp(asu64(R3), asu64(R2), asu64(R1));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3264;
L3265:
	mm_lex_nodecimal();
L3264:
// mm_lex.readdec.finish:
L3260:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L3239:
	return;
}

static void mm_lex_readhex() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 length;
	struct $B39 str;
	u64 a;
	asu64(R1) = mm_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L3267:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L3270;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L3270;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3269;
L3270:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L3271;
	R2 = 70;
	if (asi64(R1) > asi64(R2)) goto L3271;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 65;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	a = asu64(R1);
	goto L3269;
L3271:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L3272;
	R2 = 102;
	if (asi64(R1) > asi64(R2)) goto L3272;
	asi64(R1) = c;
	R2 = 32;
	asu64(R1) -= asu64(R2);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 97;
	asi64(R1) -= asi64(R2);
	R2 = 10;
	asu64(R1) += asu64(R2);
	a = asu64(R1);
	goto L3269;
L3272:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L3274;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3274;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L3275;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L3275;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L3276;
	goto L3277;
L3274:
	goto L3273;
L3275:
	mm_lex_nodecimal();
	goto L3273;
L3276:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3268;
	goto L3273;
L3277:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3268;
L3273:
L3269:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L3279;
	R1 = tou64("Numlit too long");
	mm_support_lxerror(asu64(R1));
L3279:
	goto L3267;
L3268:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 16;
	if (asi64(R1) <= asi64(R2)) goto L3281;
	R1 = tou64("MAKEDEC");
	mm_support_lxerror(asu64(R1));
	goto L3266;
L3281:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L3266:
	return;
}

static void mm_lex_readbin() {
    u64 R1, R2, R3; 
	i64 c;
	u64 dest;
	u64 destend;
	u64 pstart;
	i64 length;
	struct $B39 str;
	u64 a;
	asu64(R1) = mm_lex_lxsptr;
	pstart = asu64(R1);
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 10;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	a = asu64(R1);
L3283:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L3286;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L3286;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L3287;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3287;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L3288;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L3288;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L3289;
	goto L3290;
L3286:
	asu64(R1) = a;
	R2 = 2;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3285;
L3287:
	goto L3285;
L3288:
	mm_lex_nodecimal();
	goto L3285;
L3289:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3284;
	goto L3285;
L3290:
	asi64(R1) = c;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L3292;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L3292;
	R1 = tou64("bin bad digit");
	mm_support_lxerror(asu64(R1));
	goto L3291;
L3292:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3284;
L3291:
L3285:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L3294;
	R1 = tou64("bin overflow");
	mm_support_lxerror(asu64(R1));
L3294:
	goto L3283;
L3284:
	asu64(R1) = dest;
	R2 = (u64)&str;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 64;
	if (asi64(R1) <= asi64(R2)) goto L3296;
	mm_lex_nodecimal();
L3296:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	return;
}

static void mm_lex_readreal() {
    u64 R1, R2, R3; 
	i64 c;
	i64 negexpon;
	i64 dotseen;
	i64 length;
	i64 fractlen;
	i64 expon;
	i64 expseen;
	r64 x;
	struct $B39 str;
	u64 dest;
	u64 destend;
	u64 a;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	i64 av_4;
	i64 i;
	R1 = (u64)&str;
	dest = asu64(R1);
	asu64(R1) = dest;
	R2 = 1024;
	R1 += (i64)R2;
	R2 = 100;
	R1 -= (i64)R2;
	destend = asu64(R1);
	R1 = 0;
	R2 = R1;
	fractlen = asi64(R2);
	R2 = R1;
	expon = asi64(R2);
	R2 = R1;
	expseen = asi64(R2);
	R2 = R1;
	dotseen = asi64(R2);
	R2 = R1;
	negexpon = asi64(R2);
	length = asi64(R1);
L3298:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L3301;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L3301;
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asi64(R1) = dotseen;
	if (!asi64(R1)) goto L3303;
	R1 = (u64)&fractlen;
	(*toi64p(R1)) += 1;
L3303:
	goto L3300;
L3301:
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L3305;
	R2 = 101;
	if (asi64(R1) == asi64(R2)) goto L3306;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L3306;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L3307;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3307;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L3308;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L3308;
	goto L3309;
L3305:
	asi64(R1) = dotseen;
	if (!asi64(R1)) goto L3311;
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3299;
L3311:
	R1 = 1;
	dotseen = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3304;
L3306:
	asi64(R1) = expseen;
	if (!asi64(R1)) goto L3313;
	R1 = tou64("double expon");
	mm_support_lxerror(asu64(R1));
L3313:
	R1 = 1;
	expseen = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	goto L3315;
L3314:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) += 1;
L3315:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 32;
	if (asu64(R1) == asu64(R2)) goto L3314;
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L3319;
	R2 = 45;
	if (asi64(R1) != asi64(R2)) goto L3318;
L3319:
	asu64(R1) = mm_lex_lxsptr;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 45;
	if (asu64(R1) != asu64(R2)) goto L3321;
	R1 = 1;
	negexpon = asi64(R1);
L3321:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3318:
	R1 = 0;
	expon = asi64(R1);
L3322:
	R1 = (u64)&mm_lex_lxsptr;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L3325;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L3325;
	asi64(R1) = expon;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	asi64(R2) = c;
	asi64(R1) += asi64(R2);
	R2 = 48;
	asi64(R1) -= asi64(R2);
	expon = asi64(R1);
	asi64(R1) = c;
	R2 = (u64)&dest;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L3327;
	R1 = tou64("expon?");
	mm_support_lxerror(asu64(R1));
L3327:
	goto L3324;
L3325:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L3329;
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L3329;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L3330;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L3330;
	goto L3331;
L3329:
	goto L3328;
L3330:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	mm_lex_nodecimal();
	goto L3297;
	goto L3328;
L3331:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3299;
L3328:
L3324:
	goto L3322;
	goto L3304;
L3307:
	goto L3304;
L3308:
	mm_lex_nodecimal();
	goto L3297;
	goto L3304;
L3309:
	R1 = (u64)&mm_lex_lxsptr;
	(*tou64p(R1)) -=1;
	goto L3299;
L3304:
L3300:
	asu64(R1) = dest;
	asu64(R2) = destend;
	if (asu64(R1) < asu64(R2)) goto L3333;
	R1 = tou64("r64lit too long");
	mm_support_lxerror(asu64(R1));
L3333:
	goto L3298;
L3299:
	R1 = 0;
	asu64(R2) = dest;
	*tou8p(R2) = asu8(R1);
	asi64(R1) = expseen;
	if (!asi64(R1)) goto L3335;
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L3335;
	asi64(R1) = dotseen;
	if (asi64(R1)) goto L3335;
	R1 = 0;
	a = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3338;
L3336:
	asu64(R1) = a;
	R2 = 10;
	asi64(R1) *= asi64(R2);
	R2 = (u64)&str;
	asi64(R3) = i;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3-1));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 48;
	asu64(R1) -= asu64(R2);
	a = asu64(R1);
	i += 1; if (i <= length) goto L3336;
L3338:
	asi64(R1) = expon;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3341;
L3339:
	asu64(R1) = a;
	R2 = 10;
	asu64(R1) *= asu64(R2);
	a = asu64(R1);
	if (--asi64(av_1)) goto L3339;
L3341:
	R1 = 62;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asi64(R1) = mm_lex_setinttype(asu64(R1));
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L3297;
L3335:
	asi64(R1) = negexpon;
	if (!asi64(R1)) goto L3343;
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	expon = asi64(R1);
L3343:
	asi64(R1) = fractlen;
	R2 = (u64)&expon;
	*toi64p(R2) -= asi64(R1);
	asr64(R1) = 0.000000000000000000e+000;
	x = asr64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = length;
	asi64(R2) = dotseen;
	asi64(R1) += asi64(R2);
	av_2 = asi64(R1);
	asi64(R1) = av_2;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3346;
L3344:
	R1 = (u64)&str;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L3348;
	asr64(R1) = x;
	asr64(R2) = 1.000000000000000000e+001;
	asr64(R1) *= asr64(R2);
	asi64(R2) = c;
	asr64(R2) = tor64(asi64(R2));
	asr64(R1) += asr64(R2);
	R2 = 48;
	asr64(R2) = tor64(asu64(R2));
	asr64(R1) -= asr64(R2);
	x = asr64(R1);
L3348:
	i += 1; if (i <= av_2) goto L3344;
L3346:
	asi64(R1) = expon;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L3350;
	asi64(R1) = expon;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3353;
L3351:
	asr64(R1) = 1.000000000000000000e+001;
	R2 = (u64)&x;
	*tor64p(R2) *= asr64(R1);
	if (--asi64(av_3)) goto L3351;
L3353:
	goto L3349;
L3350:
	asi64(R1) = expon;
	asi64(R1) = -asi64(R1);
	av_4 = asi64(R1);
	asi64(R1) = av_4;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L3356;
L3354:
	asr64(R1) = 1.000000000000000000e+001;
	R2 = (u64)&x;
	*tor64p(R2) /= asr64(R1);
	if (--asi64(av_4)) goto L3354;
L3356:
L3349:
	asr64(R1) = x;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	*tor64p(((i64)R2+(i64)R3)) = asr64(R1);
	R1 = 63;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_nextlx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3297:
	return;
}

static void mm_lex_nodecimal() {
    u64 R1; 
	R1 = tou64("Decimal not ready");
	mm_support_lxerror(asu64(R1));
	return;
}

static void mm_lex_start() {
    u64 R1, R2, R3; 
	i64 av_1;
	i64 c;
	R1 = 0;
	c = asi64(R1);
	R1 = 255;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L3361;
L3359:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L3365;
	R2 = 122;
	if (asi64(R1) <= asi64(R2)) goto L3364;
L3365:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L3366;
	R2 = 57;
	if (asi64(R1) <= asi64(R2)) goto L3364;
L3366:
	asi64(R1) = c;
	R2 = 95;
	if (asi64(R1) == asi64(R2)) goto L3367;
	R2 = 36;
	if (asi64(R1) != asi64(R2)) goto L3363;
L3367:
L3364:
	R1 = 1;
	R2 = (u64)&mm_lex_namemap;
	asi64(R3) = c;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L3362;
L3363:
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L3368;
	R2 = 90;
	if (asi64(R1) > asi64(R2)) goto L3368;
	R1 = 2;
	R2 = (u64)&mm_lex_namemap;
	asi64(R3) = c;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3368:
L3362:
	c += 1; if (c <= av_1) goto L3359;
L3361:
	return;
}

static u64 mm_lib_newstrec() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = 176;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 88;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mm_decls_currmoduleno;
	asu64(R2) = p;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = mm_decls_currmoduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 95;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3369;
L3369:
	return asu64(R1);
}

static u64 mm_lib_getduplnameptr(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3; 
	u64 p;
	asu64(R1) = mm_lib_newstrec();
	p = asu64(R1);
	asu64(R1) = symptr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 76;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = p;
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = owner;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = id;
	asu64(R2) = p;
	R3 = 78;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = symptr;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = symptr;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	asu64(R2) = p;
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	goto L3370;
L3370:
	return asu64(R1);
}

static void mm_lib_adddef(u64 owner, u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	q = asu64(R2);
	if (!asu64(R1)) goto L3373;
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	if (asu64(R1) != asu64(R2)) goto L3375;
	msysc_m$print_startcon();
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("in");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Duplicate name");
	mm_support_serror(asu64(R1));
L3375:
L3373:
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3377;
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3376;
L3377:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3376:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 mm_lib_createname(u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	R1 = 4;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L3378;
L3378:
	return asu64(R1);
}

static u64 mm_lib_createunit0(i64 tag) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L3379;
L3379:
	return asu64(R1);
}

static u64 mm_lib_createunit1(i64 tag, u64 p) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L3380;
L3380:
	return asu64(R1);
}

static u64 mm_lib_createunit2(i64 tag, u64 p, u64 q) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L3381;
L3381:
	return asu64(R1);
}

static u64 mm_lib_createunit3(i64 tag, u64 p, u64 q, u64 r) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	asi64(R1) = tag;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = u;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = r;
	asu64(R2) = u;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = u;
	goto L3382;
L3382:
	return asu64(R1);
}

static void mm_lib_insertunit(u64 p, i64 tag) {
    u64 R1, R2, R3; struct $B56 R1_B56; 
	u64 q;
	u64 nextunit;
	i64 mode;
	asu64(R1) = mm_lib_allocunitrec();
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B56) = *(struct $B56*)(R1);
	asu64(R2) = q;
	*(struct $B56*)(R2) = (R1_B56);
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mode = asi64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nextunit = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	memset(R1, 0, 65);
	asi64(R1) = tag;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = nextunit;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 61;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_lib_deleteunit(u64 p, u64 q) {
    u64 R1, R2, R3; struct $B56 R1_B56; 
	u64 r;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = q;
	(R1_B56) = *(struct $B56*)(R1);
	asu64(R2) = p;
	*(struct $B56*)(R2) = (R1_B56);
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 mm_lib_createconstunit(u64 a, i64 t) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = u;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = t;
	asu64(R2) = u;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = u;
	goto L3385;
L3385:
	return asu64(R1);
}

static u64 mm_lib_createstringconstunit(u64 s, i64 length) {
    u64 R1, R2, R3; 
	u64 u;
	asu64(R1) = mm_lib_allocunitrec();
	u = asu64(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = s;
	asu64(R2) = u;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 20;
	asu64(R2) = u;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = u;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = length;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L3388;
	asu64(R1) = s;
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = u;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L3387;
L3388:
	asi64(R1) = length;
	asu64(R2) = u;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L3387:
	asu64(R1) = u;
	goto L3386;
L3386:
	return asu64(R1);
}

static i64 mm_lib_newtypename(u64 a, u64 b) {
    u64 R1, R2, R3; 
	asi64(R1) = mm_decls_ntypenames;
	R2 = 38000;
	if (asi64(R1) < asi64(R2)) goto L3391;
	R1 = tou64("Too many type names");
	mm_support_serror(asu64(R1));
L3391:
	R1 = (u64)&mm_decls_ntypenames;
	(*toi64p(R1)) += 1;
	asu64(R1) = a;
	R2 = (u64)&mm_decls_typenames;
	asi64(R3) = mm_decls_ntypenames;
	R2 += (i64)R3*32;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	R2 = (u64)&mm_decls_typenames;
	asi64(R3) = mm_decls_ntypenames;
	R2 += (i64)R3*32;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_typenamepos;
	asi64(R3) = mm_decls_ntypenames;
	R2 += (i64)R3*4;
	R3 = 0;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mm_decls_ntypenames;
	asi64(R1) = -asi64(R1);
	goto L3389;
L3389:
	return asi64(R1);
}

static i64 mm_lib_createusertype(u64 stname) {
    u64 R1, R2, R3; 
	asi64(R1) = mm_decls_ntypes;
	R2 = 16000;
	if (asi64(R1) < asi64(R2)) goto L3394;
	msysc_m$print_startcon();
	asi64(R1) = mm_decls_ntypes;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Too many types");
	mm_support_serror(asu64(R1));
L3394:
	R1 = (u64)&mm_decls_ntypes;
	(*toi64p(R1)) += 1;
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttname;
	asi64(R3) = mm_decls_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asu64(R1) = stname;
	R2 = (u64)&mm_decls_ttnamedef;
	asi64(R3) = mm_decls_ntypes;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = mm_decls_ntypes;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttlineno;
	asi64(R3) = mm_decls_ntypes;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = mm_decls_ntypes;
	asu64(R2) = stname;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = mm_decls_ntypes;
	goto L3392;
L3392:
	return asi64(R1);
}

static i64 mm_lib_createusertypefromstr(u64 name) {
    u64 R1, R2, R3; 
	u64 stname;
	R1 = 5;
	asu64(R2) = name;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = mm_decls_stmodule;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	goto L3395;
L3395:
	return asi64(R1);
}

static u64 mm_lib_getrangelwbunit(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L3398;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L3397;
L3398:
	asu64(R1) = p;
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
L3397:
	goto L3396;
L3396:
	return asu64(R1);
}

static u64 mm_lib_getrangeupbunit(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L3401;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L3400;
L3401:
	asu64(R1) = p;
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
L3400:
	goto L3399;
L3399:
	return asu64(R1);
}

static i64 mm_lib_createarraymode(u64 owner, i64 target, u64 dimexpr, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 k;
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3404;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L3403;
L3404:
	asi64(R1) = typedefx;
	m = asi64(R1);
L3403:
	R1 = 10;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = dimexpr;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L3402;
L3402:
	return asi64(R1);
}

static i64 mm_lib_sameunit(u64 p, u64 q, u64 powner, u64 qowner) {
    u64 R1, R2, R3, R4, R5; 
	asu64(R1) = p;
	asu64(R2) = q;
	if (asu64(R1) != asu64(R2)) goto L3407;
	R1 = 1;
	goto L3405;
L3407:
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3410;
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3409;
L3410:
	R1 = 0;
	goto L3405;
L3409:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = q;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) == asi64(R2)) goto L3412;
	R1 = 0;
	goto L3405;
L3412:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3414;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L3415;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L3415;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3416;
	goto L3417;
L3414:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	goto L3405;
	goto L3413;
L3415:
	R1 = 0;
	R2 = 0;
	asu64(R3) = q;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = p;
	R5 = 16;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asi64(R1) = mm_lib_sameunit(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3418;
	R1 = 0;
	R2 = 0;
	asu64(R3) = q;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = p;
	R5 = 24;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5));
	asi64(R1) = mm_lib_sameunit(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3418;
	R1 = 1;
	goto L3419;
L3418:
	R1 = 0;
L3419:
	goto L3405;
	goto L3413;
L3416:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L3421;
	asu64(R1) = powner;
	asu64(R2) = qowner;
	if (asu64(R1) != asu64(R2)) goto L3421;
	R1 = 1;
	goto L3405;
L3421:
	goto L3413;
L3417:
L3413:
	R1 = 0;
	goto L3405;
L3405:
	return asi64(R1);
}

static i64 mm_lib_createarraymodek(u64 owner, i64 target, i64 lower, i64 length, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 atype;
	i64 m;
	R1 = 10;
	atype = asi64(R1);
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3424;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L3423;
L3424:
	asi64(R1) = typedefx;
	m = asi64(R1);
L3423:
	asi64(R1) = atype;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = lower;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = length;
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = target;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3426;
	R1 = tou64("CREATEARRAYMODEK/TARGET NOT RESOLVED");
	mm_support_serror(asu64(R1));
L3426:
	asi64(R1) = length;
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = target;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asi64(R1) *= asi64(R2);
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L3422;
L3422:
	return asi64(R1);
}

static u64 mm_lib_nextautotype() {
    u64 R1; 
	R1 = (u64)&mm_lib_nextautotype_str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("$T");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_lib_autotypeno;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	R1 = (u64)&mm_lib_nextautotype_str;
	goto L3427;
L3427:
	return asu64(R1);
}

static i64 mm_lib_createslicemode(u64 owner, i64 slicetype, i64 target, u64 dimexpr, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3430;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L3429;
L3430:
	asi64(R1) = typedefx;
	m = asi64(R1);
L3429:
	asi64(R1) = slicetype;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = dimexpr;
	if (!asu64(R1)) goto L3432;
	asu64(R1) = dimexpr;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L3431;
L3432:
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L3431:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L3428;
L3428:
	return asi64(R1);
}

static i64 mm_lib_createslicemodek(u64 owner, i64 target, i64 lower, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3435;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L3434;
L3435:
	asi64(R1) = typedefx;
	m = asi64(R1);
L3434:
	R1 = 11;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = lower;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L3433;
L3433:
	return asi64(R1);
}

static i64 mm_lib_createrefmode(u64 owner, i64 target, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 k;
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3438;
	R1 = 31;
	k = asi64(R1);
	asi64(R1) = mm_decls_ntypes;
	R2 = 31;
	if (asi64(R1) < asi64(R2)) goto L3441;
L3439:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = k;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3443;
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = k;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R2) = target;
	if (asi64(R1) != asi64(R2)) goto L3445;
	asi64(R1) = k;
	goto L3436;
L3445:
L3443:
	k += 1; if (k <= mm_decls_ntypes) goto L3439;
L3441:
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L3437;
L3438:
	asi64(R1) = typedefx;
	m = asi64(R1);
L3437:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = target;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = 7;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttsize;
	R2 = 7;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisref;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L3436;
L3436:
	return asi64(R1);
}

static i64 mm_lib_createrefprocmode(u64 owner, u64 stproc, u64 paramlist, i64 kwd, i64 prettype, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	i64 mproc;
	asu64(R1) = stproc;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	mproc = asi64(R1);
	asu64(R1) = paramlist;
	asu64(R2) = stproc;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = prettype;
	asu64(R2) = stproc;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 24;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = mproc;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3448;
	asu64(R1) = mm_lib_nextautotype();
	asi64(R1) = mm_lib_createusertypefromstr(asu64(R1));
	m = asi64(R1);
	goto L3447;
L3448:
	asi64(R1) = typedefx;
	m = asi64(R1);
L3447:
	asi64(R1) = mproc;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 7;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttsize;
	R2 = 7;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisref;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L3446;
L3446:
	return asi64(R1);
}

static void mm_lib_copyttvalues(i64 dest, i64 source) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_decls_ttsigned;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttsigned;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisreal;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisinteger;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisshort;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisref;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisblock;
	asi64(R2) = source;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = dest;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static u64 mm_lib_getdottedname(u64 p) {
    u64 R1, R2; 
	struct $B16 str2;
	u64 owner;
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_lib_getdottedname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
	goto L3452;
L3451:
	R1 = (u64)&mm_lib_getdottedname_str;
	R2 = (u64)&str2;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_lib_getdottedname_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&mm_lib_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str2;
	R2 = (u64)&mm_lib_getdottedname_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
L3452:
	asu64(R1) = owner;
	if (!asu64(R1)) goto L3454;
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3451;
L3454:
	R1 = (u64)&mm_lib_getdottedname_str;
	goto L3450;
L3450:
	return asu64(R1);
}

static u64 mm_lib_getavname(u64 owner, i64 id) {
    u64 R1, R2, R3; 
	u64 p;
	struct $B18 str;
	u64 name;
	asi64(R1) = id;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3457;
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3457;
	R1 = tou64("Auto frame not in proc");
	mm_support_serror(asu64(R1));
L3457:
	asi64(R1) = id;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3459;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("av_");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_lib_nextavindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L3458;
L3459:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("sv_");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_nogap();
	R1 = (u64)&mm_lib_nextsvindex;
	asi64(R1) = *(toi64p(R1)) += 1;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L3458:
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	name = asu64(R1);
	asu64(R1) = name;
	asu64(R1) = mm_lex_addnamestr(asu64(R1));
	asi64(R1) = id;
	asu64(R2) = name;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 168;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = p;
	goto L3455;
L3455:
	return asu64(R1);
}

static void mm_lib_unionstr_clear(u64 u) {
    u64 R1, R2; 
	R1 = 0;
	asu64(R2) = u;
	*tou64p(R2) = asu64(R1);
	return;
}

static void mm_lib_unionstr_append(u64 u, i64 c) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = u;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3463;
	R1 = tou64("Uflags overflow/a");
	mm_support_serror(asu64(R1));
L3463:
	asu64(R1) = u;
	R2 = 7;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	asi64(R1) = c;
	asu64(R2) = u;
	asu64(R3) = u;
	R4 = 7;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	return;
}

static void mm_lib_unionstr_concat(u64 u, u64 v) {
    u64 R1, R2, R3, R4; 
	i64 ulen;
	i64 vlen;
	i64 i;
	asu64(R1) = u;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	ulen = asi64(R1);
	asu64(R1) = v;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	vlen = asi64(R1);
	asi64(R1) = ulen;
	asi64(R2) = vlen;
	asi64(R1) += asi64(R2);
	R2 = 7;
	if (asi64(R1) <= asi64(R2)) goto L3466;
	R1 = tou64("Uflags overflow/c");
	mm_support_serror(asu64(R1));
L3466:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = vlen;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3469;
L3467:
	asu64(R1) = v;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = u;
	asi64(R3) = i;
	asi64(R4) = ulen;
	asi64(R3) += asi64(R4);
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= vlen) goto L3467;
L3469:
	asi64(R1) = ulen;
	asi64(R2) = vlen;
	asi64(R1) += asi64(R2);
	asu64(R2) = u;
	R3 = 7;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static i64 mm_lib_unionstr_last(u64 u) {
    u64 R1, R2, R3; 
	asu64(R1) = u;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3472;
	asu64(R1) = u;
	asu64(R2) = u;
	R3 = 7;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	goto L3470;
L3472:
	R1 = 0;
	goto L3470;
L3470:
	return asi64(R1);
}

static void mm_lib_unionstr_copy(u64 u, u64 v) {
    u64 R1, R2, R3; 
	R1 = 8;
	asu64(R2) = v;
	asu64(R3) = u;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	return;
}

static i64 mm_lib_createrecordmode(u64 owner, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3476;
	asu64(R1) = owner;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	m = asi64(R1);
	goto L3475;
L3476:
	asi64(R1) = typedefx;
	m = asi64(R1);
L3475:
	R1 = 8;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttusercat;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L3474;
L3474:
	return asi64(R1);
}

static i64 mm_lib_createtuplemode(u64 owner, u64 elements, i64 elementslen, i64 typedefx) {
    u64 R1, R2, R3; 
	i64 m;
	i64 i;
	asi64(R1) = typedefx;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3479;
	asu64(R1) = owner;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	m = asi64(R1);
	goto L3478;
L3479:
	asi64(R1) = typedefx;
	m = asi64(R1);
L3478:
	R1 = 28;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttusercat;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = elementslen;
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = elementslen;
	R2 = 4;
	asi64(R1) *= asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = (u64)&mm_decls_ttmult;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = elementslen;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3482;
L3480:
	R1 = (u64)&mm_decls_ttmult;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	asi64(R2) = i;
	R1 += (i64)R2*4-4;
	asu64(R2) = elements;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	i += 1; if (i <= elementslen) goto L3480;
L3482:
	asi64(R1) = m;
	goto L3477;
L3477:
	return asi64(R1);
}

static u64 mm_lib_strexpr(u64 p) {
    u64 R1, R2; 
	asu64(R1) = mm_lib_exprstr;
	mlib_gs_init(asu64(R1));
	asu64(R1) = p;
	asu64(R2) = mm_lib_exprstr;
	mm_lib_jevalx2(asu64(R2), asu64(R1));
	asu64(R1) = mm_lib_exprstr;
	goto L3483;
L3483:
	return asu64(R1);
}

static void mm_lib_jevalx2(u64 dest, u64 p) {
    u64 R1; 
	asu64(R1) = dest;
	mm_lib_jdest = asu64(R1);
	asu64(R1) = p;
	mm_lib_jevalx(asu64(R1));
	return;
}

static void mm_lib_jevalx(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	u64 a;
	u64 b;
	struct $B82 str;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3487;
	goto L3485;
L3487:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3489;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3490;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L3491;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L3491;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L3492;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L3492;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L3492;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L3493;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L3494;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L3495;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L3495;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L3495;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L3495;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L3496;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L3497;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L3498;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L3499;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L3500;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L3501;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L3502;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L3502;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L3503;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L3504;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L3505;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L3506;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3507;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3508;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L3509;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L3510;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L3511;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L3512;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L3512;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L3513;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L3514;
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L3515;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L3516;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L3517;
	goto L3518;
L3489:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3520;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3520;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L3520;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L3520;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L3521;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3521;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L3521;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L3521;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L3522;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3522;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3523;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3523;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3524;
	goto L3525;
L3520:
	R1 = (u64)&str;
	asu64(R2) = p;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	msysc_getstrint(asi64(R2), asu64(R1));
	goto L3519;
L3521:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = msysc_strword(asu64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L3519;
L3522:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3519;
L3523:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asr64(R2) = *tor64p(((i64)R2+(i64)R3));
	msysc_m$print_r64(asr64(R2), asi64(R1));
	msysc_m$print_end();
	goto L3519;
L3524:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L3527;
	asu64(R1) = p;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3527;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 250;
	if (asi64(R1) <= asi64(R2)) goto L3529;
	R1 = tou64("LONGSTR)");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L3528;
L3529:
	R1 = (u64)&str;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = pc_api_convertstring(asu64(R2), asu64(R1));
L3528:
	R1 = tou64("\"");
	mm_lib_jadditem(asu64(R1));
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	R1 = tou64("\"");
	mm_lib_jadditem(asu64(R1));
	goto L3485;
	goto L3526;
L3527:
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_ptr_nf(asu64(R1));
	msysc_m$print_end();
L3526:
	goto L3519;
L3525:
	R1 = tou64("<EVAL/CONST PROBABLY VOID>");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L3519:
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3490:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3491:
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3492:
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L3531;
	R1 = 1;
	asu64(R2) = a;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	mm_lib_jadditem(asu64(R1));
	goto L3530;
L3531:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
L3530:
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3493:
	R1 = (u64)&mm_tables_propnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	mm_lib_jadditem(asu64(R1));
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3494:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	q = asu64(R1);
	goto L3533;
L3532:
	asu64(R1) = q;
	mm_lib_jevalx(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L3536;
	R1 = tou64(",");
	mm_lib_jadditem(asu64(R1));
L3536:
L3533:
	asu64(R1) = q;
	if (asu64(R1)) goto L3532;
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3495:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L3539;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 52;
	if (asi64(R1) != asi64(R2)) goto L3538;
L3539:
	R1 = tou64(".");
	mm_lib_jadditem(asu64(R1));
L3538:
	R1 = tou64("[");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("]");
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3496:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(".");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	goto L3488;
L3497:
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	q = asu64(R1);
	goto L3541;
L3540:
	asu64(R1) = q;
	mm_lib_jevalx(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L3544;
	R1 = tou64(",");
	mm_lib_jadditem(asu64(R1));
L3544:
L3541:
	asu64(R1) = q;
	if (asu64(R1)) goto L3540;
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3498:
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("..");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3499:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(":=");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	goto L3488;
L3500:
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("|");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("|");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3501:
	R1 = 1;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3502:
	R1 = 1;
	asu64(R2) = p;
	R3 = 53;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L3546;
	R1 = tou64("@");
	mm_lib_jadditem(asu64(R1));
L3546:
	R1 = tou64("(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3503:
	R1 = tou64("shorten(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3504:
	R1 = tou64("cast(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3505:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(":");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = b;
	if (!asu64(R1)) goto L3548;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lib_jevalx(asu64(R1));
	goto L3547;
L3548:
	R1 = tou64("-");
	mm_lib_jaddstr(asu64(R1));
L3547:
	goto L3488;
L3506:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64("^");
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3507:
	R1 = tou64("<JBLOCK>");
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3508:
	R1 = tou64("<nullunit>");
	mm_lib_jaddstr(asu64(R1));
	goto L3488;
L3509:
	R1 = tou64("&");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	asu64(R1) = b;
	if (!asu64(R1)) goto L3550;
	R1 = tou64("+");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = mm_lib_jdest;
	mlib_gs_strint(asu64(R2), asi64(R1));
L3550:
	goto L3488;
L3510:
	R1 = tou64("&.");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	goto L3488;
L3511:
	R1 = tou64("TYPESTR(");
	mm_lib_jadditem(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(")");
	mm_lib_jadditem(asu64(R1));
	goto L3488;
L3512:
	R1 = tou64("$");
	mm_lib_jaddstr(asu64(R1));
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 1;
	R1 += (i64)R2;
	mm_lib_jaddstr(asu64(R1));
	goto L3488;
L3513:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(".");
	mm_lib_jaddstr(asu64(R1));
	R1 = (u64)&mm_tables_bitfieldnames;
	asu64(R2) = p;
	R3 = 40;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_lib_jaddstr(asu64(R1));
	goto L3488;
L3514:
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	R1 = tou64(":");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = b;
	mm_lib_jevalx(asu64(R1));
	goto L3488;
L3515:
	R1 = (u64)&mm_tables_sysfnnames;
	asu64(R2) = p;
	R3 = 40;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 3;
	R1 += (i64)R2;
	mm_lib_jaddstr(asu64(R1));
	R1 = tou64("(");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = a;
	if (!asu64(R1)) goto L3552;
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
L3552:
	R1 = tou64(")");
	mm_lib_jaddstr(asu64(R1));
	goto L3488;
L3516:
	R1 = tou64("incr ");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	goto L3488;
L3517:
	R1 = tou64("strinclude ");
	mm_lib_jaddstr(asu64(R1));
	asu64(R1) = a;
	mm_lib_jevalx(asu64(R1));
	goto L3488;
L3518:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = tou64("CAN'T DO JEVAL");
	mm_support_gerror(asu64(R2), asu64(R1));
L3488:
L3485:
	return;
}

static void mm_lib_jadditem(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = mm_lib_jdest;
	mm_support_gs_additem(asu64(R2), asu64(R1));
	return;
}

static void mm_lib_jaddstr(u64 s) {
    u64 R1, R2; 
	asu64(R1) = s;
	asu64(R2) = mm_lib_jdest;
	mlib_gs_str(asu64(R2), asu64(R1));
	return;
}

static u64 mm_lib_strmode(i64 m, i64 expand) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_lib_strmode_str;
	asi64(R2) = expand;
	asi64(R3) = m;
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mm_lib_strmode_str;
	goto L3555;
L3555:
	return asu64(R1);
}

static u64 mm_lib_strmode2(i64 m, i64 expand) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_lib_strmode2_str;
	asi64(R2) = expand;
	asi64(R3) = m;
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mm_lib_strmode2_str;
	goto L3556;
L3556:
	return asu64(R1);
}

static void mm_lib_istrmode(i64 m, i64 expand, u64 dest) {
    u64 R1, R2, R3, R4; struct $B18 R1_B18; 
	u64 d;
	u64 q;
	i64 needcomma;
	i64 i;
	i64 target;
	i64 mbase;
	i64 n;
	struct $B3 sxx;
	u64 xx;
	u64 sdim;
	struct $B5 strdim;
	u64 prefix;
	struct $B18 tn;
	R1 = (u64)&sxx;
	xx = asu64(R1);
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L3559;
	R1 = tou64("*");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = m;
	asi64(R2) = -asi64(R2);
	(R1_B18) = *(struct $B18*)(((i64)R1+(i64)R2*32));
	tn = (R1_B18);
	R1 = (u64)&tn;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3561;
	R1 = (u64)&tn;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3561:
	R1 = (u64)&tn;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3557;
L3559:
	asi64(R1) = m;
	R2 = 31;
	if (asi64(R1) >= asi64(R2)) goto L3563;
	asi64(R1) = m;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3563;
	asi64(R1) = m;
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L3557;
L3563:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = R1;
	mbase = asi64(R2);
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3565;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3566;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3567;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3568;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3569;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L3570;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L3571;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L3572;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L3573;
	goto L3574;
L3565:
	R1 = tou64("ref ");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	target = asi64(R1);
	asi64(R1) = target;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L3576;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = target;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3576;
	asi64(R1) = target;
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3575;
L3576:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
L3575:
	goto L3564;
L3566:
	R1 = (u64)&mm_decls_ttdimexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L3578;
	R1 = (u64)&strdim;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R2) = mm_lib_strexpr(asu64(R2));
	mm_support_gs_copytostr(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("@[#<#>");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&strdim;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L3577;
L3578:
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	if (!asi32(R1)) goto L3580;
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3582;
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
	goto L3581;
L3582:
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#..#]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L3581:
	goto L3579;
L3580:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3584;
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[]");
	msysc_m$print_setfmt(asu64(R1));
	msysc_m$print_end();
	goto L3583;
L3584:
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("[#:]");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L3583:
L3579:
L3577:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L3564;
L3567:
	R1 = (u64)&mm_tables_stdnames;
	asi64(R2) = mbase;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	prefix = asu64(R1);
	R1 = (u64)&mm_decls_ttdimexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	if (!asu64(R1)) goto L3586;
	R1 = (u64)&strdim;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asu64(R2) = mm_lib_strexpr(asu64(R2));
	mm_support_gs_copytostr(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("@#[#:]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = prefix;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&strdim;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	goto L3585;
L3586:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3588;
	asu64(R1) = prefix;
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = tou64("[]");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3587;
L3588:
	asu64(R1) = dest;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#[#:]");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = prefix;
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L3587:
L3585:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L3564;
L3568:
	asi64(R1) = expand;
	if (asi64(R1)) goto L3590;
	asi64(R1) = m;
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L3557;
L3590:
	R1 = tou64("");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = expand;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3592;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3592:
	R1 = tou64("(");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = 0;
	needcomma = asi64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L3596;
L3593:
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L3598;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3598:
	R1 = 1;
	needcomma = asi64(R1);
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = q;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L3596:
	asu64(R1) = q;
	if (asu64(R1)) goto L3593;
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3564;
L3569:
	R1 = tou64("void");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L3564;
L3570:
	asi64(R1) = m;
	asu64(R1) = mm_lib_typename(asi64(R1));
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L3564;
L3571:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = tou64("proc(");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 0;
	needcomma = asi64(R1);
	goto L3600;
L3599:
	asi64(R1) = needcomma;
	if (!asi64(R1)) goto L3603;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3603:
	R1 = 1;
	needcomma = asi64(R1);
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = q;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	R1 = tou64(" ");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L3600:
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3599;
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3605;
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	asu64(R3) = d;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
L3605:
	goto L3564;
L3572:
	R1 = tou64("Tuple(");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3608;
L3606:
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_ttmult;
	asi64(R4) = m;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8));
	asi64(R4) = i;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4-4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = n;
	if (asi64(R1) >= asi64(R2)) goto L3610;
	R1 = tou64(",");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3610:
	i += 1; if (i <= n) goto L3606;
L3608:
	R1 = tou64(")");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3564;
L3573:
	R1 = tou64("bitfield");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L3564;
L3574:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 31;
	if (asi64(R1) >= asi64(R2)) goto L3612;
	R1 = tou64("Alias for:");
	asu64(R2) = dest;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = dest;
	asu64(R2) = dest;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	R2 = 0;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	mm_lib_istrmode(asi64(R3), asi64(R2), asu64(R1));
	goto L3611;
L3612:
	msysc_m$print_startcon();
	asi64(R1) = m;
	asu64(R1) = mm_lib_typename(asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("NEWSTRMODE");
	mm_support_mcerror(asu64(R1));
L3611:
L3564:
L3557:
	return;
}

static void mm_lib_addtoproclist(u64 d) {
    u64 R1, R2, R3; 
	u64 pp;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	pp = asu64(R1);
	asu64(R1) = mm_decls_proclist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3615;
	asu64(R1) = pp;
	R2 = R1;
	mm_decls_proclistx = asu64(R2);
	mm_decls_proclist = asu64(R1);
	goto L3614;
L3615:
	asu64(R1) = pp;
	asu64(R2) = mm_decls_proclistx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pp;
	mm_decls_proclistx = asu64(R1);
L3614:
	asu64(R1) = d;
	asu64(R2) = pp;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_lib_addstatic(u64 d) {
    u64 R1, R2, R3; 
	u64 pp;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	pp = asu64(R1);
	asu64(R1) = mm_decls_staticlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3618;
	asu64(R1) = pp;
	R2 = R1;
	mm_decls_staticlistx = asu64(R2);
	mm_decls_staticlist = asu64(R1);
	goto L3617;
L3618:
	asu64(R1) = pp;
	asu64(R2) = mm_decls_staticlistx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pp;
	mm_decls_staticlistx = asu64(R1);
L3617:
	asu64(R1) = d;
	asu64(R2) = pp;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_lib_addexpconst(u64 d) {
    u64 R1, R2, R3; 
	u64 pp;
	R1 = 16;
	asu64(R1) = mlib_pcm_allocnfz(asi64(R1));
	pp = asu64(R1);
	asu64(R1) = mm_decls_constlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3621;
	asu64(R1) = pp;
	R2 = R1;
	mm_decls_constlistx = asu64(R2);
	mm_decls_constlist = asu64(R1);
	goto L3620;
L3621:
	asu64(R1) = pp;
	asu64(R2) = mm_decls_constlistx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pp;
	mm_decls_constlistx = asu64(R1);
L3620:
	asu64(R1) = d;
	asu64(R2) = pp;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 mm_lib_typename(i64 m) {
    u64 R1, R2; 
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L3624;
	R1 = (u64)&mm_decls_ttname;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L3622;
L3624:
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = m;
	asi64(R2) = -asi64(R2);
	R1 += (i64)R2*32;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L3622;
L3622:
	return asu64(R1);
}

static u64 mm_lib_allocunitrec() {
    u64 R1, R2, R3; 
	u64 p;
	R1 = (u64)&mm_decls_nunits;
	(*toi64p(R1)) += 1;
	R1 = 65;
	R2 = (u64)&mm_decls_nunitsmem;
	*toi64p(R2) += asi64(R1);
	R1 = (u64)&mm_lib_remainingunits;
	asi64(R2) = *toi64p(R1); *(toi64p(R1)) -= 1; asi64(R1) = asi64(R2);
	if (!asi64(R1)) goto L3627;
	asu64(R1) = mm_lib_unitheapptr;
	p = asu64(R1);
	R1 = (u64)&mm_lib_unitheapptr;
	(*tou64p(R1)) += 65;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mm_decls_currmoduleno;
	asu64(R2) = p;
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = mm_decls_currmoduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 58;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3625;
L3627:
	R1 = 2129920;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	mm_lib_unitheapptr = asu64(R2);
	p = asu64(R1);
	R1 = 2129920;
	R2 = 0;
	asu64(R3) = p;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 32767;
	mm_lib_remainingunits = asi64(R1);
	R1 = (u64)&mm_lib_unitheapptr;
	(*tou64p(R1)) += 65;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = mm_decls_currmoduleno;
	asu64(R2) = p;
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = mm_decls_currmoduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 58;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L3625;
L3625:
	return asu64(R1);
}

static u64 mm_lib_createdupldef(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3, R4; 
	u64 p;
	asu64(R1) = mm_lib_newstrec();
	p = asu64(R1);
	asu64(R1) = symptr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = symptr;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 76;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 67;
	asu64(R2) = p;
	R3 = 77;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = owner;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = id;
	asu64(R2) = p;
	R3 = 78;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = symptr;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = symptr;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = owner;
	if (!asu64(R1)) goto L3630;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3632;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = owner;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = owner;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L3631;
L3632:
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3631:
L3630:
	asu64(R1) = p;
	goto L3628;
L3628:
	return asu64(R1);
}

static u64 mm_lib_createnewmoduledef(u64 owner, u64 symptr, i64 id) {
    u64 R1, R2, R3; 
	asi64(R1) = id;
	asu64(R2) = symptr;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	goto L3633;
L3633:
	return asu64(R1);
}

static u64 mm_lib_duplunit(u64 p, i64 lineno) {
    u64 R1, R2, R3; struct $B56 R1_B56; 
	u64 q;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3636;
	R1 = 0;
	goto L3634;
L3636:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B56) = *(struct $B56*)(R1);
	asu64(R2) = q;
	*(struct $B56*)(R2) = (R1_B56);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_tables_jsubs;
	asu64(R2) = q;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3639;
L3637:
	R1 = 0;
	asu64(R2) = q;
	R3 = 16;
	R2 += (i64)R3;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	asu64(R2) = q;
	R3 = 16;
	R2 += (i64)R3;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= av_1) goto L3637;
L3639:
	asu64(R1) = q;
	goto L3634;
L3634:
	return asu64(R1);
}

static i64 mm_lib_isconstunit(u64 a) {
    u64 R1, R2; 
	asu64(R1) = a;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	goto L3640;
L3640:
	return asi64(R1);
}

static void mm_lib_getownername(u64 d, u64 dest) {
    u64 R1, R2; 
	u64 owner;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	owner = asu64(R1);
	asu64(R1) = owner;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3644;
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3643;
L3644:
	goto L3641;
L3643:
	asu64(R1) = dest;
	asu64(R2) = owner;
	mm_lib_getownername(asu64(R2), asu64(R1));
	asu64(R1) = owner;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	asu64(R2) = dest;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3641:
	return;
}

static i64 mm_lib_getalignment(i64 m) {
    u64 R1, R2; 
	i64 a;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3647;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3648;
	goto L3649;
L3647:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getalignment(asi64(R1));
	goto L3645;
	goto L3646;
L3648:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 166;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L3651;
	R1 = 8;
	a = asi64(R1);
L3651:
	asi64(R1) = a;
	goto L3645;
	goto L3646;
L3649:
	R1 = (u64)&mm_decls_ttisblock;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3653;
	R1 = 8;
	goto L3645;
L3653:
L3646:
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	a = asi64(R1);
	asi64(R1) = a;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3655;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3655;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3655;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3655;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3656;
	goto L3657;
L3655:
	asi64(R1) = a;
	goto L3645;
	goto L3654;
L3656:
	R1 = 8;
	goto L3645;
	goto L3654;
L3657:
L3654:
	msysc_m$print_startcon();
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("GETALIGN SIZE NOT 1248");
	mm_support_gerror(asu64(R2), asu64(R1));
	R1 = 0;
	goto L3645;
L3645:
	return asi64(R1);
}

static void mm_lib_addlistunit(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3660;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L3659;
L3660:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3659:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static i64 mm_lib_storemode(u64 owner, i64 m, u64 pmode) {
    u64 R1, R2, R3; 
	u64 r;
	asi64(R1) = m;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L3663;
	asi64(R1) = m;
	asu64(R2) = pmode;
	*toi32p(R2) = asi32(R1);
	asi64(R1) = m;
	goto L3661;
L3663:
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = m;
	asi64(R2) = -asi64(R2);
	R1 += (i64)R2*32;
	r = asu64(R1);
	asu64(R1) = r;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3665;
	asu64(R1) = owner;
	asu64(R2) = r;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = pmode;
	*toi32p(R2) = asi32(R1);
	asu64(R1) = pmode;
	asu64(R2) = r;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = r;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3667;
	R1 = tou64("PMODE=NIL");
	mm_support_serror(asu64(R1));
L3667:
	asi64(R1) = m;
	goto L3661;
L3665:
	asu64(R1) = r;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = r;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mm_lib_newtypename(asu64(R2), asu64(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = m;
	asi64(R2) = -asi64(R2);
	R1 += (i64)R2*32;
	r = asu64(R1);
	asu64(R1) = owner;
	asu64(R2) = r;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	asu64(R2) = pmode;
	*toi32p(R2) = asi32(R1);
	asu64(R1) = pmode;
	asu64(R2) = r;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = m;
	goto L3661;
L3661:
	return asi64(R1);
}

static i64 mm_lib_gettypebase(i64 m) {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L3670;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L3670;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L3670;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L3671;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L3671;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L3671;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3672;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L3673;
	goto L3674;
L3670:
	R1 = 3;
	goto L3669;
L3671:
	R1 = 3;
	goto L3669;
L3672:
	R1 = 1;
	goto L3669;
L3673:
	R1 = 5;
	goto L3669;
L3674:
	asi64(R1) = m;
L3669:
	goto L3668;
L3668:
	return asi64(R1);
}

static void mm_lib_writegsfile(u64 filename, u64 d) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	asu64(R2) = d;
	mlib_gs_println(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	return;
}

static void mm_lib_addtolog(u64 filename, u64 logdest) {
    u64 R1, R2; 
	u64 f;
	i64 c;
	R1 = tou64("rb");
	asu64(R2) = filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3678;
	msysc_m$print_startcon();
	R1 = tou64("ATL ERROR");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L3676;
L3678:
L3679:
	asu64(R1) = f;
	asi32(R1) = fgetc(asu64(R1));
	R1 = toi64(toi32(R1));
	c = asi64(R1);
	asi64(R1) = c;
	R2 = -1;
	if (asi64(R1) != asi64(R2)) goto L3682;
	goto L3680;
L3682:
	asu64(R1) = logdest;
	asi64(R2) = c;
	asi32(R1) = fputc(asi32(R2), asu64(R1));
	goto L3679;
L3680:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L3676:
	return;
}

static u64 mm_lib_getprocretmodes(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 a;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L3685;
	R1 = 0;
	R2 = tou64("multass/need multfn");
	mm_support_txerror(asu64(R2), asu64(R1));
L3685:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3687;
	goto L3688;
L3687:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L3686;
L3688:
	R1 = (u64)&mm_decls_ttnamedef;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
L3686:
	goto L3683;
L3683:
	return asu64(R1);
}

static i64 mm_lib_getpclmode(i64 t) {
    u64 R1, R2, R3; 
	i64 u;
	R1 = (u64)&mm_tables_stdpcl;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = t;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	u = asi64(R1);
	asi64(R1) = u;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L3691;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = t;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L3693;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3694;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3695;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3696;
	goto L3697;
L3693:
	R1 = 6;
	u = asi64(R1);
	goto L3692;
L3694:
	R1 = 5;
	u = asi64(R1);
	goto L3692;
L3695:
	R1 = 4;
	u = asi64(R1);
	goto L3692;
L3696:
	R1 = 3;
	u = asi64(R1);
	goto L3692;
L3697:
L3692:
L3691:
	asi64(R1) = u;
	goto L3689;
L3689:
	return asi64(R1);
}

static u64 mm_libpcl_getpsymbol(u64 d) {
    u64 R1, R2, R3; 
	u64 p;
	u64 e;
	struct $B16 str;
	struct $B21 chain;
	i64 n;
	i64 i;
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3700;
	R1 = 0;
	goto L3698;
L3700:
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3702;
	asu64(R1) = d;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L3698;
L3702:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L3704;
	asu64(R1) = d;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3704;
	asu64(R1) = d;
	asu64(R1) = mm_libpcl_getequivdef(asu64(R1));
	R2 = R1;
	e = asu64(R2);
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R1) = e;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L3698;
L3704:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3707;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L3707;
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L3706;
L3707:
	asu64(R1) = d;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3709;
	asu64(R1) = d;
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L3708;
L3709:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
L3708:
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L3705;
L3706:
	asu64(R1) = d;
	e = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L3710:
	asu64(R1) = e;
	R2 = (u64)&chain;
	R3 = (u64)&n;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = e;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L3713;
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3710;
L3713:
	R1 = (u64)&chain;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = n;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3716;
L3714:
	R1 = tou64(".");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&chain;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3718;
	R1 = (u64)&chain;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 104;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	goto L3717;
L3718:
	R1 = (u64)&chain;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
L3717:
	i += -1; if (i >= 1) goto L3714;
L3716:
L3705:
	R1 = (u64)&mm_tables_name2pid;
	asu64(R2) = d;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&str;
	asu64(R1) = pc_api_pc_makesymbol(asu64(R2), asi64(R1));
	R2 = R1;
	p = asu64(R2);
	asu64(R2) = d;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 82;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 84;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3720;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3720;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_libpcl_getpsymbol(asu64(R1));
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3720:
	asu64(R1) = d;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L3722;
	R1 = 1;
	asu64(R2) = p;
	R3 = 81;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3722:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3725;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3724;
L3725:
	R1 = 1;
	asu64(R2) = p;
	R3 = 80;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L3724:
	asu64(R1) = d;
	R2 = 168;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 92;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 80;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 100;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 6;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = p;
	R3 = 109;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 124;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 108;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 107;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu8(R1) = pclint_ctarget;
	if (!asu8(R1)) goto L3727;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L3727;
	asu64(R1) = e;
	if (!asu64(R1)) goto L3727;
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3727;
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3727;
	asu64(R1) = e;
	R2 = 56;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = e;
	R3 = 56;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 104;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L3727:
	asu64(R1) = p;
	goto L3698;
L3698:
	return asu64(R1);
}

static void mm_libpcl_setmode(i64 mode) {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = mode;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	asi64(R2) = mode;
	asi64(R2) = mm_lib_getpclmode(asi64(R2));
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	return;
}

static void mm_libpcl_setmode2(i64 mode) {
    u64 R1; 
	asi64(R1) = mode;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	pc_api_pc_setmode2(asi64(R1));
	return;
}

static void mm_libpcl_setmode_u(u64 p) {
    u64 R1, R2; 
	i64 mode;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mode = asi64(R1);
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = mode;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	asi64(R2) = mode;
	asi64(R2) = mm_lib_getpclmode(asi64(R2));
	pc_api_pc_setmode(asi64(R2), asi64(R1));
	return;
}

static u64 mm_libpcl_getequivdef(u64 d) {
    u64 R1, R2; 
	u64 p;
	asu64(R1) = d;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3733;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L3734;
	goto L3735;
L3733:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L3732;
L3734:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L3732;
L3735:
	R1 = 0;
	R2 = tou64("geteqv");
	mm_support_gerror(asu64(R2), asu64(R1));
	R1 = 0;
L3732:
	goto L3731;
L3731:
	return asu64(R1);
}

static void mm_libsources_loadbuiltins() {
    u64 R1, R2, R3; 
	u64 pf;
	u64 filename;
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 13;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3739;
L3737:
	R1 = (u64)&mm_libsources_syslibnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	filename = asu64(R1);
	asu64(R1) = mm_support_newsourcefile();
	pf = asu64(R1);
	asu64(R1) = filename;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_libsources_syslibtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_libsources_syslibtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_libsources_syslibtext;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asi64(R1) = strlen(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = tou64("");
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 56;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = mm_decls_nsourcefiles;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L3737;
L3739:
	return;
}

static u64 mm_modules_loadsp(u64 filename, i64 mainsub) {
    u64 R1, R2, R3, R4, R5; 
	u64 sp;
	struct $B81 modnames;
	struct $B81 aliases;
	struct $B81 paths;
	struct $B81 subnames;
	struct $B81 subpaths;
	i64 nmods;
	i64 nsubs;
	i64 hdrcode;
	i64 firstmod;
	i64 lastmod;
	i64 issyslib;
	u64 pm;
	u64 d;
	u64 stalias;
	u64 path;
	u64 name;
	u64 ext;
	u64 file2;
	u8 proj;
	u8 sepheader;
	i64 i;
	i64 j;
	R1 = 0;
	nmods = asi64(R1);
	R1 = 0;
	nsubs = asi64(R1);
	R1 = 0;
	issyslib = asi64(R1);
	R1 = 0;
	proj = asu8(R1);
	R1 = 0;
	sepheader = asu8(R1);
	asu64(R1) = mm_cli_syslibname;
	asu64(R2) = filename;
	asu64(R2) = mlib_extractbasefile(asu64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3742;
	R1 = 1;
	issyslib = asi64(R1);
L3742:
	R1 = 0;
	asu64(R2) = filename;
	asu64(R1) = mlib_extractext(asu64(R2), asi64(R1));
	ext = asu64(R1);
	R1 = tou64("m");
	asu64(R2) = ext;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L3744;
	asu64(R1) = ext;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_modules_fileext = asu64(R1);
L3744:
	asi64(R1) = issyslib;
	asu64(R2) = filename;
	asu64(R1) = mm_modules_loadmodule(asu64(R2), asi64(R1));
	pm = asu64(R1);
	asu64(R1) = pm;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3746;
	R1 = tou64("");
	asu64(R2) = filename;
	R3 = tou64("Can't load lead module: ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L3746:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	path = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3749;
L3747:
	R1 = (u64)&mm_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3751;
	R1 = tou64("");
	asu64(R2) = sp;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Subprog already loaded: ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L3751:
	i += 1; if (i <= mm_decls_nsubprogs) goto L3747;
L3749:
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lex_startlex(asu64(R1));
	mm_lex_lex();
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 115;
	if (asi64(R1) != asi64(R2)) goto L3753;
	R1 = 1;
	proj = asu8(R1);
	R1 = 41;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
L3753:
L3754:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 125;
	if (asi64(R1) == asi64(R2)) goto L3757;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3758;
	goto L3759;
L3757:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	hdrcode = asi64(R1);
	mm_lex_lex();
	asi64(R1) = hdrcode;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3761;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3762;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3763;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3764;
	goto L3765;
L3761:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L3767;
	asi64(R1) = nmods;
	R2 = 250;
	if (asi64(R1) < asi64(R2)) goto L3769;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many modules in header");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L3769:
	asu64(R1) = name;
	R2 = (u64)&modnames;
	R3 = (u64)&nmods;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = path;
	R2 = (u64)&paths;
	asi64(R3) = nmods;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&aliases;
	asi64(R3) = nmods;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L3767:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L3771;
	R1 = tou64("as");
	R2 = (u64)&mm_decls_nextlx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3771;
	mm_lex_lex();
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L3773;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stalias = asu64(R1);
	mm_lex_lex();
	goto L3772;
L3773:
	R1 = 65;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lex_addnamestr(asu64(R1));
	stalias = asu64(R1);
L3772:
	asu64(R1) = stalias;
	R2 = (u64)&aliases;
	asi64(R3) = nmods;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L3771:
	goto L3760;
L3762:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	asi64(R1) = nsubs;
	R2 = 250;
	if (asi64(R1) < asi64(R2)) goto L3775;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many imports in header");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L3775:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&subnames;
	R3 = (u64)&nsubs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = path;
	R2 = (u64)&subpaths;
	asi64(R3) = nsubs;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L3760;
L3763:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_modules_addlib(asu64(R1));
	goto L3760;
L3764:
	R1 = 65;
	mm_parse_checksymbol(asi64(R1));
	asu8(R1) = mm_decls_loadedfromma;
	if (asu8(R1)) goto L3777;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	path = asu64(R1);
L3777:
	goto L3760;
L3765:
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Hdr cmd not ready");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L3760:
	mm_lex_lex();
	goto L3756;
L3758:
	goto L3756;
L3759:
	goto L3755;
L3756:
	goto L3754;
L3755:
	asu8(R1) = proj;
	if (!asu8(R1)) goto L3779;
	R1 = 0;
	R2 = 0;
	R3 = 115;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L3779:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L3781;
	R1 = 1;
	sepheader = asu8(R1);
L3781:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nsubs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3784;
L3782:
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&subnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3786;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Importing self");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L3786:
	R1 = 0;
	R2 = 0;
	R3 = (u64)&subnames;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	R4 = (u64)&subpaths;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	asu64(R2) = mm_modules_getmodulefilename(asu64(R4), asu64(R3), asi64(R2));
	asu64(R1) = mm_modules_loadsp(asu64(R2), asi64(R1));
	i += 1; if (i <= nsubs) goto L3782;
L3784:
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 30;
	if (asi64(R1) < asi64(R2)) goto L3788;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many subprogs");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L3788:
	R1 = 16;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	sp = asu64(R1);
	asu64(R1) = sp;
	R2 = (u64)&mm_decls_subprogs;
	R3 = (u64)&mm_decls_nsubprogs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = sp;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mainsub;
	if (!asi64(R1)) goto L3790;
	asi64(R1) = mm_decls_nsubprogs;
	mm_decls_mainsubprogno = asi64(R1);
L3790:
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	asi64(R1) += asi64(R2);
	firstmod = asi64(R1);
	asi64(R1) = firstmod;
	asi64(R2) = nmods;
	asi64(R1) += asi64(R2);
	lastmod = asi64(R1);
	asi64(R1) = lastmod;
	R2 = 300;
	if (asi64(R1) <= asi64(R2)) goto L3792;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many modules");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L3792:
	asi64(R1) = lastmod;
	mm_decls_nmodules = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = pm;
	R3 = 18;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 1;
	asu64(R2) = pm;
	R3 = 23;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = firstmod;
	asu64(R2) = pm;
	R3 = 16;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 3;
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = mm_decls_stprogram;
	asu64(R1) = mm_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	d = asu64(R2);
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = firstmod;
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = d;
	R3 = 95;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = (u64)&mm_decls_moduletosub;
	asi64(R3) = firstmod;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = sp;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = firstmod;
	asu64(R2) = sp;
	R3 = 8;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	R1 = 0;
	asu64(R2) = sp;
	R3 = 10;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = lastmod;
	asu64(R2) = sp;
	R3 = 12;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = issyslib;
	asu64(R2) = sp;
	R3 = 14;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = pm;
	R2 = (u64)&mm_decls_modules;
	asi64(R3) = firstmod;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nmods;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3795;
L3793:
	asi64(R1) = issyslib;
	asi64(R2) = issyslib;
	R3 = (u64)&modnames;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	R4 = (u64)&paths;
	asi64(R5) = i;
	asu64(R4) = *tou64p(((i64)R4+(i64)R5*8-8));
	asu64(R2) = mm_modules_getmodulefilename(asu64(R4), asu64(R3), asi64(R2));
	asu64(R1) = mm_modules_loadmodule(asu64(R2), asi64(R1));
	pm = asu64(R1);
	R1 = (u64)&aliases;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	stalias = asu64(R1);
	asu64(R1) = pm;
	if (asu64(R1)) goto L3797;
	R1 = tou64("");
	R2 = (u64)&modnames;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = tou64("Can't load: ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L3797:
	asu64(R1) = pm;
	R2 = (u64)&mm_decls_modules;
	asi64(R3) = firstmod;
	asi64(R4) = i;
	asi64(R3) += asi64(R4);
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 3;
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = mm_decls_stprogram;
	asu64(R1) = mm_lib_createdupldef(asu64(R3), asu64(R2), asi64(R1));
	R2 = R1;
	d = asu64(R2);
	asu64(R2) = pm;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = pm;
	R3 = 18;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = stalias;
	if (!asu64(R1)) goto L3799;
	R1 = 15;
	asu64(R2) = stalias;
	asu64(R3) = mm_decls_stprogram;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	asu64(R2) = pm;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mm_decls_stprogram;
	mm_lib_adddef(asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = pm;
	R3 = 40;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	asu64(R1) = mm_lib_createname(asu64(R1));
	asu64(R2) = pm;
	R3 = 40;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3799:
	asi64(R1) = firstmod;
	asi64(R2) = i;
	asi64(R1) += asi64(R2);
	R2 = R1;
	asu64(R3) = pm;
	R4 = 16;
	*toi16p(((i64)R3+(i64)R4)) = asi16(R2);
	asu64(R2) = d;
	R3 = 94;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsubprogs;
	asu64(R2) = d;
	R3 = 95;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = (u64)&mm_decls_moduletosub;
	asu64(R3) = d;
	R4 = 94;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	j = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3802;
L3800:
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_modules;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3804;
	asu64(R1) = pm;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("Dupl mod name:");
	mm_support_serror_s(asu64(R2), asu64(R1));
L3804:
	j += 1; if (j <= mm_decls_nmodules) goto L3800;
L3802:
	i += 1; if (i <= nmods) goto L3793;
L3795:
	asu64(R1) = sp;
	goto L3740;
L3740:
	return asu64(R1);
}

static u64 mm_modules_loadmodule(u64 filespec, i64 issyslib) {
    u64 R1, R2, R3; 
	u64 pm;
	u64 pf;
	asi64(R1) = issyslib;
	asu64(R2) = filespec;
	asu64(R1) = mm_modules_loadsourcefile(asu64(R2), asi64(R1));
	pf = asu64(R1);
	asu64(R1) = pf;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3807;
	R1 = 0;
	goto L3805;
L3807:
	R1 = 64;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pm = asu64(R1);
	asu64(R1) = pf;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pm;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pf;
	asu64(R2) = pm;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pf;
	R2 = 64;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	asu64(R2) = pm;
	R3 = 20;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = issyslib;
	asu64(R2) = pm;
	R3 = 22;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pm;
	goto L3805;
L3805:
	return asu64(R1);
}

static u64 mm_modules_loadsourcefile(u64 filespec, i64 issyslib) {
    u64 R1, R2, R3; 
	u64 pf;
	u64 s;
	u64 filename;
	struct $B15 str;
	i64 i;
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractfile(asu64(R1));
	filename = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3811;
L3809:
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = filename;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3813;
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = issyslib;
	if (asi64(R1) != asi64(R2)) goto L3813;
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L3808;
L3813:
	i += 1; if (i <= mm_decls_nsourcefiles) goto L3809;
L3811:
	asu64(R1) = mm_support_newsourcefile();
	pf = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = filename;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = issyslib;
	asu64(R2) = pf;
	R3 = 56;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	asu64(R2) = pf;
	R3 = 64;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = filespec;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	if (asu64(R1)) goto L3815;
	R1 = 0;
	goto L3808;
L3815:
	asu64(R1) = s;
	asu64(R2) = pf;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = mlib_rfsize;
	asu64(R2) = pf;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asi64(R1) = mm_decls_passlevel;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L3817;
	asu64(R1) = s;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 40;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3817:
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = mlib_rfsize;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pf;
	goto L3808;
L3808:
	return asu64(R1);
}

static u64 mm_modules_getmodulefilename(u64 path, u64 name, i64 issyslib) {
    u64 R1, R2; 
	asu64(R1) = path;
	R2 = (u64)&mm_modules_getmodulefilename_str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = name;
	R2 = (u64)&mm_modules_getmodulefilename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = tou64(".");
	R2 = (u64)&mm_modules_getmodulefilename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	asi64(R1) = issyslib;
	if (!asi64(R1)) goto L3820;
	R1 = tou64("m");
	goto L3819;
L3820:
	asu64(R1) = mm_modules_fileext;
L3819:
	R2 = (u64)&mm_modules_getmodulefilename_str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&mm_modules_getmodulefilename_str;
	goto L3818;
L3818:
	return asu64(R1);
}

static void mm_modules_addlib(u64 libname) {
    u64 R1, R2, R3; 
	i64 i;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3824;
L3822:
	asu64(R1) = libname;
	R2 = (u64)&mm_decls_libfiles;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3826;
	goto L3821;
L3826:
	i += 1; if (i <= mm_decls_nlibfiles) goto L3822;
L3824:
	asi64(R1) = mm_decls_nlibfiles;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L3828;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many libs");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L3828:
	asu64(R1) = libname;
	R2 = (u64)&mm_decls_libfiles;
	R3 = (u64)&mm_decls_nlibfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
L3821:
	return;
}

static void mm_modules_loadsyslib() {
    u64 R1, R2, R3; 
	struct $B15 str;
	u64 name;
	u8 frunpcl;
	u8 fgenpcl;
	asi64(R1) = mm_decls_passlevel;
	R2 = 5;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	frunpcl = asu8(R1);
	asi64(R1) = mm_decls_passlevel;
	R2 = 4;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	fgenpcl = asu8(R1);
	asu8(R1) = mm_decls_dointlibs;
	if (!asu8(R1)) goto L3831;
	R1 = 0;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	goto L3830;
L3831:
	R1 = tou64("C:/mx/");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
L3830:
	asu8(R1) = mm_decls_msyslevel;
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3833;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3834;
	goto L3835;
L3833:
	goto L3829;
	goto L3832;
L3834:
	asu8(R1) = pclint_ctarget;
	if (asu8(R1)) goto L3838;
	asi64(R1) = mwindows_os_iswindows();
	if (asi64(R1)) goto L3837;
L3838:
	R1 = tou64("msysminc");
	goto L3836;
L3837:
	R1 = tou64("msysmin");
L3836:
	name = asu64(R1);
	goto L3832;
L3835:
	asi64(R1) = mwindows_os_iswindows();
	if (!asi64(R1)) goto L3840;
	asu8(R1) = mm_decls_clinux;
	if (asu8(R1)) goto L3840;
	asu8(R1) = pclint_ctarget;
	if (!asu8(R1)) goto L3842;
	R1 = tou64("msyswinc");
	name = asu64(R1);
	goto L3841;
L3842:
	asu8(R1) = frunpcl;
	if (asu8(R1)) goto L3844;
	asu8(R1) = fgenpcl;
	if (!asu8(R1)) goto L3843;
L3844:
	R1 = tou64("msyswini");
	name = asu64(R1);
	goto L3841;
L3843:
	R1 = tou64("msyswin");
	name = asu64(R1);
L3841:
	goto L3839;
L3840:
	R1 = tou64("msyslinc");
	name = asu64(R1);
L3839:
L3832:
	asu64(R1) = name;
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	mm_cli_syslibname = asu64(R1);
	asi64(R1) = mm_decls_fverbose;
	R2 = 2;
	if (asi64(R1) < asi64(R2)) goto L3846;
	msysc_m$print_startcon();
	R1 = tou64("SYSLIBNAME=");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mm_cli_syslibname;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L3846:
	R1 = tou64(".m");
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&str;
	asu64(R1) = mm_modules_loadsp(asu64(R2), asi64(R1));
L3829:
	return;
}

static void mm_modules_loadproject(u64 file) {
    u64 R1, R2, R3; 
	struct $B15 str;
	u64 file2;
	i64 tt;
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	tt = asi64(R1);
	asu8(R1) = mm_decls_dointlibs;
	if (!asu8(R1)) goto L3849;
	mm_libsources_loadbuiltins();
L3849:
	mm_modules_loadsyslib();
	asu64(R1) = file;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (asi64(R1)) goto L3851;
	R1 = tou64("ma");
	asu64(R2) = file;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	file2 = asu64(R1);
	asu64(R1) = file2;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (!asi64(R1)) goto L3853;
	asu64(R1) = file2;
	file = asu64(R1);
L3853:
L3851:
	R1 = tou64("ma");
	R2 = 0;
	asu64(R3) = file;
	asu64(R2) = mlib_extractext(asu64(R3), asi64(R2));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3855;
	msysc_m$print_startcon();
	R1 = tou64("LOADING FROM MA FILE");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	asu64(R2) = file;
	mm_modules_loadmafile(asu64(R2), asu64(R1));
	R1 = 1;
	mm_decls_loadedfromma = asu8(R1);
	R1 = tou64("m");
	asu64(R2) = file;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	file = asu64(R1);
L3855:
	R1 = 1;
	asu64(R2) = file;
	asu64(R1) = mm_modules_loadsp(asu64(R2), asi64(R1));
	R1 = tou64("msvcrt");
	mm_modules_addlib(asu64(R1));
	asi64(R1) = mwindows_os_iswindows();
	if (!asi64(R1)) goto L3857;
	R1 = tou64("user32");
	mm_modules_addlib(asu64(R1));
	R1 = tou64("gdi32");
	mm_modules_addlib(asu64(R1));
	R1 = tou64("kernel32");
	mm_modules_addlib(asu64(R1));
L3857:
	asi32(R1) = clock();
	R1 = toi64(toi32(R1));
	asi64(R2) = tt;
	asi64(R1) -= asi64(R2);
	mm_cli_loadtime = asi64(R1);
	return;
}

static u64 mm_modules_readfileline(u64 s) {
    u64 R1, R2, R3; 
	struct $B80 str;
	u64 t;
	i64 n;
	i64 c;
	R1 = (u64)&str;
	t = asu64(R1);
	R1 = 0;
	n = asi64(R1);
L3859:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3861;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3862;
	goto L3863;
L3861:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	goto L3860;
	goto L3859;
L3862:
	goto L3860;
	goto L3859;
L3863:
	asi64(R1) = n;
	R2 = 2048;
	if (asi64(R1) >= asi64(R2)) goto L3865;
	asi64(R1) = c;
	R2 = (u64)&t;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
L3865:
	goto L3859;
L3860:
	R1 = 0;
	asu64(R2) = t;
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&str;
	msysc_m$read_strline(asu64(R1));
	asu64(R1) = s;
	goto L3858;
L3858:
	return asu64(R1);
}

static u64 mm_modules_findnextlineheader(u64 s) {
    u64 R1, R2; 
	i64 c;
L3867:
	R1 = (u64)&s;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = R1;
	c = asi64(R2);
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L3869;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3870;
	goto L3871;
L3869:
	R1 = 0;
	goto L3866;
	goto L3867;
L3870:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3873;
	asu64(R1) = s;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3873;
	asu64(R1) = s;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 61;
	if (asu64(R1) != asu64(R2)) goto L3873;
	asu64(R1) = s;
	R2 = 3;
	R1 += (i64)R2;
	goto L3866;
L3873:
	goto L3867;
L3871:
	goto L3867;
	R1 = 0;
	goto L3866;
L3866:
	return asu64(R1);
}

static void mm_modules_loadmafile(u64 filespec, u64 builtinstr) {
    u64 R1, R2, R3, R4; 
	u64 s;
	u64 t;
	struct $B5 name;
	i64 sys;
	i64 support;
	u64 pf;
	i64 i;
	asu64(R1) = filespec;
	if (!asu64(R1)) goto L3876;
	asu64(R1) = filespec;
	asu64(R1) = mlib_readfile(asu64(R1));
	s = asu64(R1);
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3878;
	R1 = tou64("");
	asu64(R2) = filespec;
	R3 = tou64("Can't find MA file ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L3878:
	goto L3875;
L3876:
	asu64(R1) = builtinstr;
	s = asu64(R1);
L3875:
	asu64(R1) = s;
	R2 = 3;
	R1 += (i64)R2;
	asu64(R1) = mm_modules_readfileline(asu64(R1));
	s = asu64(R1);
	R1 = 0;
	R2 = 110;
	R3 = (u64)&name;
	msysc_readstr(asu64(R3), asi64(R2), asi64(R1));
	R1 = tou64("ma");
	R2 = (u64)&name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L3880;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("MA: bad header");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L3880:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
	asu64(R1) = s;
	asu64(R1) = mm_modules_findnextlineheader(asu64(R1));
	s = asu64(R1);
L3881:
	asu64(R1) = s;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3884;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Unexpected EOF in MA file");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
	goto L3882;
L3884:
	asu64(R1) = s;
	asu64(R1) = mm_modules_readfileline(asu64(R1));
	s = asu64(R1);
	R1 = 0;
	R2 = 110;
	R3 = (u64)&name;
	msysc_readstr(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	sys = asi64(R1);
	R1 = 0;
	asi64(R1) = msysc_m$read_i64(asi64(R1));
	support = asi64(R1);
	R1 = tou64("end");
	R2 = (u64)&name;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L3886;
	goto L3882;
L3886:
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 300;
	if (asi64(R1) < asi64(R2)) goto L3888;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many files in MA");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L3888:
	asu64(R1) = s;
	asu64(R1) = mm_modules_findnextlineheader(asu64(R1));
	t = asu64(R1);
	asu64(R1) = t;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L3890;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("MA error");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L3890:
	asu64(R1) = mm_support_newsourcefile();
	pf = asu64(R1);
	R1 = (u64)&name;
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	R2 = R1;
	asu64(R3) = pf;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = pf;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&name;
	asu64(R1) = mlib_extractbasefile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = pf;
	R3 = 0;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = t;
	asu64(R2) = s;
	asi64(R1) -= asi64(R2);
	R2 = 3;
	asi64(R1) -= asi64(R2);
	asu64(R2) = pf;
	R3 = 48;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = s;
	asu64(R2) = pf;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = tou64("");
	R2 = R1;
	asu64(R3) = pf;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = pf;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = sys;
	asu64(R2) = pf;
	R3 = 56;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = support;
	asu64(R2) = pf;
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = t;
	s = asu64(R1);
	goto L3881;
L3882:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3893;
L3891:
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pf = asu64(R1);
	R1 = 0;
	asu64(R2) = pf;
	R3 = 32;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = pf;
	R4 = 48;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= mm_decls_nsourcefiles) goto L3891;
L3893:
	return;
}

static void mm_name_rx_typetable() {
    u64 R1, R2; 
	u64 d;
	i64 i;
	R1 = 31;
	i = asi64(R1);
	asi64(R1) = mm_decls_ntypes;
	R2 = 31;
	if (asi64(R1) < asi64(R2)) goto L3897;
L3895:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L3899;
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 144;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L3901;
	asu64(R1) = d;
	mm_name_do_baseclass(asu64(R1));
L3901:
L3899:
	i += 1; if (i <= mm_decls_ntypes) goto L3895;
L3897:
	return;
}

static void mm_name_rx_unit(u64 owner, u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	u64 a;
	u64 b;
	i64 n;
	i64 oldnoexpand;
	i64 oldnoassem;
	i64 oldtag;
	i64 useparams;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 4: goto L3906;
	case 5: case 6: case 7: case 8: case 10: case 11: case 12: case 13: case 14: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 27: case 28: case 29: case 30: case 31: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: goto L3905;
	case 9: goto L3946;
	case 15: case 16: goto L3929;
	case 17: goto L3938;
	case 18: goto L3934;
	case 26: goto L3909;
	case 32: goto L3911;
	case 49: goto L3910;
	default: goto L3905;
    };
// SWITCH
L3906:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_resolvename(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3908;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 15;
	if (asi64(R1) != asi64(R2)) goto L3908;
	asi64(R1) = mm_name_noexpand;
	if (asi64(R1)) goto L3908;
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = p;
	asu64(R3) = p;
	mm_name_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) -=1;
L3908:
	goto L3903;
L3909:
	asu64(R1) = b;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	goto L3903;
L3910:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_resolvedot(asu64(R2), asu64(R1));
	goto L3903;
L3911:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	oldtag = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3913;
	asi64(R1) = mm_name_noexpand;
	oldnoexpand = asi64(R1);
	R1 = 1;
	mm_name_noexpand = asi64(R1);
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asi64(R1) = oldnoexpand;
	mm_name_noexpand = asi64(R1);
	goto L3912;
L3913:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
L3912:
	asu64(R1) = b;
	asu64(R2) = owner;
	mm_name_rx_unitlist(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L3915;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3917;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L3918;
	goto L3919;
L3917:
	R1 = 58;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 53;
	R1 += (i64)R2;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = b;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3921;
	asu64(R1) = b;
	R2 = 20;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	goto L3923;
L3922:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
L3923:
	asu64(R1) = b;
	if (asu64(R1)) goto L3922;
	asi64(R1) = n;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L3921:
	goto L3916;
L3918:
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) += 1;
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3926;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_name_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	b = asu64(R1);
	R1 = 0;
	useparams = asi64(R1);
	goto L3925;
L3926:
	R1 = 0;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_name_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	useparams = asi64(R1);
L3925:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) -=1;
	asi64(R1) = useparams;
	if (!asi64(R1)) goto L3928;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L3928;
	asi64(R1) = oldtag;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L3928:
	goto L3916;
L3919:
L3916:
L3915:
	goto L3903;
L3929:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = b;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3931;
	R1 = 18;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
L3931:
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = b;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3933;
	R1 = 18;
	asu64(R2) = b;
	mm_lib_insertunit(asu64(R2), asi64(R1));
L3933:
	goto L3903;
L3934:
// mm_name.rx_unit.doistruel:
L3935:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3937;
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L3937:
	goto L3903;
L3938:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L3940;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L3941;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L3942;
	goto L3943;
L3940:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	R1 = 18;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L3935;
	goto L3939;
L3941:
	R1 = 19;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L3939;
L3942:
	R1 = 18;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	goto L3939;
L3943:
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L3945;
	R1 = 19;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L3945:
L3939:
	goto L3903;
L3946:
	asu64(R1) = a;
	asu64(R2) = owner;
	mm_name_resolvename(asu64(R2), asu64(R1));
	asi64(R1) = mm_name_noexpand;
	if (asi64(R1)) goto L3948;
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) += 1;
	asi64(R1) = mm_name_noassem;
	oldnoassem = asi64(R1);
	R1 = 1;
	mm_name_noassem = asi64(R1);
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_name_expandmacro(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = oldnoassem;
	mm_name_noassem = asi64(R1);
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = (u64)&mm_name_macrolevels;
	(*toi64p(R1)) -=1;
L3948:
	goto L3903;
L3905:
// mm_name.rx_unit.doabc:
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_tables_jsubs;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L3952;
L3950:
	asu64(R1) = p;
	R2 = 16;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = owner;
	mm_name_rx_unitlist(asu64(R2), asu64(R1));
	i += 1; if (i <= av_1) goto L3950;
L3952:
L3903:
	return;
}

static i64 mm_name_rx_module(i64 n) {
    u64 R1, R2; 
	asi64(R1) = n;
	mm_decls_currmoduleno = asi64(R1);
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = mm_decls_stprogram;
	mm_name_rx_passdef(asu64(R2), asu64(R1));
	R1 = 1;
	goto L3953;
L3953:
	return asi64(R1);
}

static void mm_name_rx_deflist(u64 owner, u64 p) {
    u64 R1, R2; 
	u64 pstart;
	asu64(R1) = p;
	pstart = asu64(R1);
	goto L3956;
L3955:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_passdef(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L3956:
	asu64(R1) = p;
	if (asu64(R1)) goto L3955;
	return;
}

static void mm_name_rx_passdef(u64 owner, u64 p) {
    u64 R1, R2; 
	u64 d;
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3960;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L3960;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L3961;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L3962;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L3963;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L3963;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L3963;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L3963;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3964;
	goto L3965;
L3960:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_deflist(asu64(R2), asu64(R1));
	goto L3959;
L3961:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_deflist(asu64(R2), asu64(R1));
	asu64(R1) = p;
	mm_name_currstproc = asu64(R1);
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = 0;
	mm_name_currstproc = asu64(R1);
	goto L3959;
L3962:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_deflist(asu64(R2), asu64(R1));
	goto L3959;
L3963:
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L3967;
	asu64(R1) = p;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
L3967:
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L3969;
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
L3969:
	goto L3959;
L3964:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_name_rx_deflist(asu64(R2), asu64(R1));
	goto L3959;
L3965:
L3959:
	return;
}

static void mm_name_rx_unitlist(u64 owner, u64 p) {
    u64 R1, R2; 
	goto L3972;
L3971:
	asu64(R1) = p;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L3972:
	asu64(R1) = p;
	if (asu64(R1)) goto L3971;
	return;
}

static u64 mm_name_resolvetopname(u64 owner, u64 stnewname, i64 moduleno, i64 allowmod) {
    u64 R1, R2, R3, R4; 
	i64 extcount;
	i64 subprogno;
	u64 p;
	u64 q;
	u64 powner;
	u64 extdef;
	u64 moddef;
	struct $B1 ambiglist;
	i64 i;
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L3976;
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L3980;
L3977:
	asu64(R1) = q;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stnewname;
	if (asu64(R1) != asu64(R2)) goto L3982;
	asu64(R1) = q;
	goto L3974;
L3982:
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L3980:
	asu64(R1) = q;
	if (asu64(R1)) goto L3977;
L3976:
	asu64(R1) = stnewname;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	R1 = (u64)&mm_decls_moduletosub;
	asi64(R2) = moduleno;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	subprogno = asi64(R1);
	R1 = 0;
	extcount = asi64(R1);
	R1 = 0;
	R2 = R1;
	moddef = asu64(R2);
	extdef = asu64(R1);
	goto L3986;
L3983:
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	powner = asu64(R1);
	asu64(R1) = powner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L3988;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L3989;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L3990;
	goto L3991;
L3988:
	asu64(R1) = powner;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = moduleno;
	if (asi64(R1) != asi64(R2)) goto L3993;
	asu64(R1) = p;
	goto L3974;
	goto L3992;
L3993:
	asu64(R1) = p;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L3994;
	asu64(R1) = powner;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) == asi64(R2)) goto L3997;
	asu64(R1) = p;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L3997;
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L3996;
L3997:
	R1 = (u64)&extcount;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	extdef = asu64(R1);
	asi64(R1) = extcount;
	R2 = 10;
	if (asi64(R1) >= asi64(R2)) goto L3999;
	asu64(R1) = extdef;
	R2 = (u64)&ambiglist;
	asi64(R3) = extcount;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L3999:
L3996:
L3994:
L3992:
	goto L3987;
L3989:
	asu64(R1) = powner;
	asu64(R2) = owner;
	if (asu64(R1) == asu64(R2)) goto L4002;
	asu64(R1) = powner;
	asu64(R2) = owner;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L4001;
L4002:
	asu64(R1) = p;
	goto L3974;
L4001:
	goto L3987;
L3990:
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4004;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4004;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L4005;
	goto L4006;
L4004:
	asi64(R1) = subprogno;
	R2 = (u64)&mm_decls_moduletosub;
	asu64(R3) = p;
	R4 = 94;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	if (asi64(R1) != asi64(R2)) goto L4008;
	asu64(R1) = p;
	moddef = asu64(R1);
	goto L4007;
L4008:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsubprogs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4011;
L4009:
	R1 = (u64)&mm_decls_subprogs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4013;
	R1 = 1;
	asu64(R2) = p;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 10;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	moddef = asu64(R1);
	goto L4011;
L4013:
	i += 1; if (i <= mm_decls_nsubprogs) goto L4009;
L4011:
L4007:
	goto L4003;
L4005:
	asu64(R1) = p;
	goto L3974;
	goto L4003;
L4006:
L4003:
	goto L3987;
L3991:
L3987:
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L3986:
	asu64(R1) = p;
	if (asu64(R1)) goto L3983;
	asi64(R1) = allowmod;
	if (!asi64(R1)) goto L4015;
	asu64(R1) = moddef;
	if (!asu64(R1)) goto L4015;
	asu64(R1) = moddef;
	goto L3974;
L4015:
	asu64(R1) = extdef;
	if (!asu64(R1)) goto L4017;
	asi64(R1) = extcount;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L4019;
	R1 = tou64("mclib");
	asu64(R2) = extdef;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L4021;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = extcount;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4024;
L4022:
	R1 = (u64)&ambiglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	extdef = asu64(R1);
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = extdef;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = extdef;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= extcount) goto L4022;
L4024:
	R1 = tou64("mclib");
	asu64(R2) = extdef;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (asi64(R1)) goto L4026;
	R1 = 0;
	asu64(R2) = extdef;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Ambiguous ext name: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L4026:
L4021:
L4019:
	asu64(R1) = extdef;
	goto L3974;
L4017:
	R1 = 0;
	goto L3974;
L3974:
	return asu64(R1);
}

static void mm_name_resolvename(u64 owner, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	i64 moduleno;
	i64 mode;
	i64 islet;
	struct $B15 str;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = p;
	R2 = 57;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	moduleno = asi64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4029;
	goto L4027;
L4029:
	asi64(R1) = mm_name_allowmodname;
	asi64(R2) = moduleno;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = mm_name_resolvetopname(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (asu64(R1)) goto L4031;
	R1 = 0;
	islet = asi64(R1);
	R1 = 0;
	mode = asi64(R1);
	asu64(R1) = p;
	R2 = 41;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L4033;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L4033;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L4033;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L4034;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L4034;
	goto L4035;
L4033:
	R1 = 3;
	mode = asi64(R1);
	R1 = 1;
	islet = asi64(R1);
	goto L4032;
L4034:
	R1 = 23;
	mode = asi64(R1);
	goto L4032;
L4035:
L4032:
	asi64(R1) = mode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4037;
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&str;
	asu64(R1) = mlib_convucstring(asu64(R1));
	asu64(R1) = p;
	R2 = (u64)&str;
	R3 = tou64("pcl:Undefined: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L4036;
L4037:
	asi64(R1) = mode;
	asi64(R2) = moduleno;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = mm_name_addframevar(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = e;
	R3 = 88;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = islet;
	asu64(R2) = e;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 4;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L4036:
L4031:
	asu64(R1) = e;
	R2 = 168;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 255;
	if (asi64(R1) >= asi64(R2)) goto L4039;
	asu64(R1) = e;
	R2 = 168;
	R1 += (i64)R2;
	(*tou16p(R1)) += 1;
L4039:
	asu64(R1) = e;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4027:
	return;
}

static u64 mm_name_finddupl(u64 d, u64 pdupl) {
    u64 R1, R2; 
	asu64(R1) = pdupl;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4042;
	asu64(R1) = pdupl;
	goto L4040;
L4042:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
	goto L4044;
L4043:
	asu64(R1) = pdupl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L4047;
	asu64(R1) = pdupl;
	goto L4040;
L4047:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
L4044:
	asu64(R1) = pdupl;
	if (asu64(R1)) goto L4043;
	R1 = 0;
	goto L4040;
L4040:
	return asu64(R1);
}

static u64 mm_name_finddupl_sub(u64 d, u64 pdupl) {
    u64 R1, R2; 
	i64 subprogno;
	asu64(R1) = pdupl;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4050;
	asu64(R1) = pdupl;
	goto L4048;
L4050:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
	asu64(R1) = d;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	subprogno = asi64(R1);
	goto L4052;
L4051:
	asu64(R1) = pdupl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) != asi64(R2)) goto L4055;
	asu64(R1) = pdupl;
	goto L4048;
L4055:
	asu64(R1) = pdupl;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pdupl = asu64(R1);
L4052:
	asu64(R1) = pdupl;
	if (asu64(R1)) goto L4051;
	R1 = 0;
	goto L4048;
L4048:
	return asu64(R1);
}

static void mm_name_resolvedot(u64 owner, u64 p) {
    u64 R1, R2, R3, R4; 
	u64 lhs;
	u64 rhs;
	u64 d;
	u64 e;
	u64 t;
	i64 m;
	i64 moduleno;
	i64 subprogno;
	i64 oldallowmod;
	asu64(R1) = p;
	R2 = 57;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	moduleno = asi64(R1);
	asu64(R1) = p;
	R2 = 58;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	subprogno = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	lhs = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rhs = asu64(R1);
	asu64(R1) = rhs;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asi64(R1) = mm_name_allowmodname;
	oldallowmod = asi64(R1);
	asu64(R1) = lhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	mm_name_allowmodname = asi64(R1);
	asu64(R1) = lhs;
	asu64(R2) = owner;
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asi64(R1) = oldallowmod;
	mm_name_allowmodname = asi64(R1);
	asu64(R1) = lhs;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = lhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4058;
	goto L4059;
L4058:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4061;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4061;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4061;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4061;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4062;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4062;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4062;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4063;
	goto L4064;
L4061:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4066;
	asu64(R1) = d;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) == asi64(R2)) goto L4066;
	goto L4067;
L4066:
	asu64(R1) = e;
	asu64(R2) = d;
	asu64(R1) = mm_name_finddupl(asu64(R2), asu64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L4069;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4071;
	asu64(R1) = e;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) == asi64(R2)) goto L4073;
	asu64(R1) = e;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L4075;
	asu64(R1) = e;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L4075;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Need export to import '#'");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L4075:
	goto L4072;
L4073:
	asu64(R1) = e;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = moduleno;
	if (asi64(R1) == asi64(R2)) goto L4076;
	asu64(R1) = e;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4078;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Need global to import '#'");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L4078:
L4076:
L4072:
L4071:
// mm_name.resolvedot.domodule:
L4079:
	R1 = 4;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L4081;
	goto L4082;
L4081:
	goto L4080;
L4082:
L4080:
	goto L4068;
L4069:
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't resolve .#");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L4068:
	goto L4060;
L4062:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4084;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4085;
	goto L4086;
L4084:
	goto L4083;
L4085:
L4087:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4090;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4091;
	goto L4092;
L4090:
	goto L4088;
	goto L4089;
L4091:
	goto L4089;
L4092:
	R1 = 0;
	R2 = tou64("2:Record expected");
	mm_support_rxerror(asu64(R2), asu64(R1));
L4089:
	goto L4087;
L4088:
	goto L4083;
L4086:
	R1 = 0;
	R2 = tou64("Record expected");
	mm_support_rxerror(asu64(R2), asu64(R1));
L4083:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	t = asu64(R1);
	asu64(R1) = e;
	asu64(R2) = t;
	asu64(R1) = mm_name_finddupl(asu64(R2), asu64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L4094;
	asu64(R1) = e;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4093;
L4094:
	R1 = 0;
	asu64(R2) = rhs;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Not a field: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L4093:
	goto L4060;
L4063:
// mm_name.resolvedot.dosubprogid:
L4067:
	asu64(R1) = e;
	asu64(R2) = d;
	asu64(R1) = mm_name_finddupl_sub(asu64(R2), asu64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (!asu64(R1)) goto L4096;
	asu64(R1) = e;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = subprogno;
	if (asi64(R1) == asi64(R2)) goto L4098;
	asu64(R1) = e;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) >= asi64(R2)) goto L4100;
	asu64(R1) = e;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (asu64(R1)) goto L4100;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Need export to import '#'");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L4100:
L4098:
	goto L4079;
	goto L4095;
L4096:
	asu64(R1) = p;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't resolve sub.#");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L4095:
	goto L4060;
L4064:
L4060:
	goto L4057;
L4059:
	asu64(R1) = e;
	R2 = 40;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L4102;
	R1 = 0;
	asu64(R2) = e;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Not a field: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L4102:
L4057:
	return;
}

static void mm_name_fixmode(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 pmode;
	u64 a;
	u64 d;
	u64 e;
	u64 f;
	u64 owner;
	i64 m;
	i64 moduleno;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pmode = asu64(R1);
	asu64(R1) = pmode;
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	asi64(R1) = -asi64(R1);
	m = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = R1;
	owner = asu64(R2);
	d = asu64(R1);
	goto L4105;
L4104:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4105:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4104;
	asu64(R1) = d;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	moduleno = asi64(R1);
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4108;
	asu64(R1) = d;
	if (!asu64(R1)) goto L4108;
	R1 = 0;
	asi64(R2) = moduleno;
	asu64(R3) = d;
	asu64(R4) = owner;
	asu64(R1) = mm_name_resolvetopname(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	e = asu64(R1);
L4108:
	asu64(R1) = e;
	if (!asu64(R1)) goto L4110;
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4110;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pmode;
	*toi32p(R2) = asi32(R1);
	goto L4109;
L4110:
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("2:Can't resolve tentative type: #");
	mm_support_rxerror_s(asu64(R3), asu64(R2), asu64(R1));
L4109:
	return;
}

static void mm_name_fixusertypes() {
    u64 R1, R2; 
	u64 p;
	i64 npasses;
	i64 notresolved;
	u64 d;
	i64 i;
	R1 = 0;
	npasses = asi64(R1);
L4112:
	R1 = (u64)&npasses;
	(*toi64p(R1)) += 1;
	R1 = 0;
	notresolved = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_ntypenames;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4117;
L4115:
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = i;
	R1 += (i64)R2*32;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L4119;
	R1 = (u64)&mm_decls_typenamepos;
	asi64(R2) = i;
	R1 += (i64)R2*4;
	R2 = 0;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	mm_name_fixmode(asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L4121;
	R1 = (u64)&notresolved;
	(*toi64p(R1)) += 1;
L4121:
L4119:
	i += 1; if (i <= mm_decls_ntypenames) goto L4115;
L4117:
	asi64(R1) = npasses;
	R2 = 5;
	if (asi64(R1) <= asi64(R2)) goto L4123;
	msysc_m$print_startcon();
	R1 = tou64("Type phase errors - check these user types:");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_ntypenames;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4126;
L4124:
	R1 = (u64)&mm_decls_typenames;
	asi64(R2) = i;
	R1 += (i64)R2*32;
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi32(R1) = *toi32p(R1);
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L4128;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4130;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4130:
	msysc_m$print_startcon();
	R1 = tou64("\t");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L4128:
	i += 1; if (i <= mm_decls_ntypenames) goto L4124;
L4126:
	R1 = 0;
	R2 = tou64("Fixtypes: too many passes (cyclic ref?)");
	mm_support_rxerror(asu64(R2), asu64(R1));
L4123:
	asi64(R1) = notresolved;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4112;
	return;
}

static u64 mm_name_addframevar(u64 owner, u64 d, i64 moduleno, i64 mode) {
    u64 R1, R2, R3; 
	u64 e;
	R1 = 11;
	asu64(R2) = d;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = mode;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = e;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = e;
	goto L4131;
L4131:
	return asu64(R1);
}

static u64 mm_name_copylistunit(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	u64 plist;
	u64 plistx;
	R1 = 0;
	R2 = R1;
	plistx = asu64(R2);
	plist = asu64(R1);
	goto L4134;
L4133:
	asu64(R1) = p;
	asu64(R1) = mm_name_copyunit(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&plistx;
	R3 = (u64)&plist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L4134:
	asu64(R1) = p;
	if (asu64(R1)) goto L4133;
	asu64(R1) = plist;
	goto L4132;
L4132:
	return asu64(R1);
}

static u64 mm_name_copyunit(u64 p) {
    u64 R1, R2, R3; struct $B56 R1_B56; 
	u64 q;
	u64 d;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4138;
	R1 = 0;
	goto L4136;
L4138:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4140;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_name_nmacroparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4143;
L4141:
	R1 = (u64)&mm_name_macroparamsgen;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = d;
	if (asu64(R1) != asu64(R2)) goto L4145;
	R1 = (u64)&mm_name_macroargs;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mm_name_copyunit(asu64(R1));
	goto L4136;
	goto L4143;
L4145:
	i += 1; if (i <= mm_name_nmacroparams) goto L4141;
L4143:
L4140:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B56) = *(struct $B56*)(R1);
	asu64(R2) = q;
	*(struct $B56*)(R2) = (R1_B56);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_tables_jsubs;
	asu64(R2) = q;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4148;
L4146:
	asu64(R1) = q;
	R2 = 16;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R1) = mm_name_copylistunit(asu64(R1));
	asu64(R2) = q;
	R3 = 16;
	R2 += (i64)R3;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= av_1) goto L4146;
L4148:
	asu64(R1) = q;
	goto L4136;
L4136:
	return asu64(R1);
}

static void mm_name_replaceunit(u64 p, u64 q) {
    u64 R1, R2, R3; struct $B56 R1_B56; 
	u64 pnext;
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pnext = asu64(R1);
	asu64(R1) = q;
	(R1_B56) = *(struct $B56*)(R1);
	asu64(R2) = p;
	*(struct $B56*)(R2) = (R1_B56);
	asu64(R1) = pnext;
	asu64(R2) = p;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_name_expandmacro(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 d;
	u64 pm;
	u64 pnew;
	i64 ignoreargs;
	asi64(R1) = mm_name_macrolevels;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L4152;
	R1 = 0;
	R2 = tou64("Too many macro levels (recursive macro?)");
	mm_support_rxerror(asu64(R2), asu64(R1));
L4152:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
	R1 = 0;
	mm_name_nmacroparams = asi64(R1);
	goto L4154;
L4153:
	asi64(R1) = mm_name_nmacroparams;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L4157;
	R1 = 0;
	R2 = tou64("macro param overflow");
	mm_support_rxerror(asu64(R2), asu64(R1));
L4157:
	asu64(R1) = pm;
	R2 = (u64)&mm_name_macroparams;
	R3 = (u64)&mm_name_nmacroparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 48;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_name_macroparamsgen;
	asi64(R3) = mm_name_nmacroparams;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = pm;
	R2 = 152;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pm = asu64(R1);
L4154:
	asu64(R1) = pm;
	if (asu64(R1)) goto L4153;
	R1 = 0;
	mm_name_nmacroargs = asi64(R1);
	goto L4159;
L4158:
	asi64(R1) = mm_name_nmacroargs;
	R2 = 50;
	if (asi64(R1) < asi64(R2)) goto L4162;
	R1 = 0;
	R2 = tou64("macro arg overflow");
	mm_support_rxerror(asu64(R2), asu64(R1));
L4162:
	asu64(R1) = b;
	R2 = (u64)&mm_name_macroargs;
	R3 = (u64)&mm_name_nmacroargs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
L4159:
	asu64(R1) = b;
	if (asu64(R1)) goto L4158;
	asi64(R1) = mm_name_nmacroargs;
	asi64(R2) = mm_name_nmacroparams;
	if (asi64(R1) >= asi64(R2)) goto L4164;
	msysc_m$print_startcon();
	R1 = tou64("NMACROARGS=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = mm_name_nmacroargs;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mm_name_nmacroparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Too few macro args");
	mm_support_rxerror(asu64(R2), asu64(R1));
L4164:
	R1 = 0;
	ignoreargs = asi64(R1);
	asi64(R1) = mm_name_nmacroargs;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4166;
	asi64(R1) = mm_name_nmacroparams;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4166;
	R1 = 1;
	ignoreargs = asi64(R1);
	R1 = 0;
	R2 = R1;
	mm_name_nmacroparams = asi64(R2);
	mm_name_nmacroargs = asi64(R1);
	goto L4165;
L4166:
	asi64(R1) = mm_name_nmacroargs;
	asi64(R2) = mm_name_nmacroparams;
	if (asi64(R1) <= asi64(R2)) goto L4167;
	R1 = 0;
	R2 = tou64("Too many macro args");
	mm_support_rxerror(asu64(R2), asu64(R1));
L4167:
L4165:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_name_copyunit(asu64(R1));
	pnew = asu64(R1);
	asi64(R1) = ignoreargs;
	if (asi64(R1)) goto L4169;
	asu64(R1) = pnew;
	asu64(R2) = p;
	mm_name_replaceunit(asu64(R2), asu64(R1));
	goto L4168;
L4169:
	asu64(R1) = pnew;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4168:
	return;
}

static void mm_name_duplfield(u64 owner, u64 p, u64 q) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L4172;
	R1 = tou64("DUPLFIELD");
	mm_support_serror(asu64(R1));
L4172:
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	asu64(R2) = q;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 7;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 92;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	asu64(R1) = p;
	R2 = 136;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 136;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = 72;
	R1 += (i64)R2;
	asu64(R2) = p;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	return;
}

static void mm_name_do_baseclass(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	u64 newd;
	u64 dbase;
	i64 normalexit;
	R1 = (u64)&mm_decls_ttnamedef;
	asu64(R2) = p;
	R3 = 144;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	dbase = asu64(R1);
	asu64(R1) = dbase;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L4175;
L4174:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 1;
	normalexit = asi64(R1);
	goto L4178;
L4177:
	asu64(R1) = e;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4181;
	R1 = 0;
	normalexit = asi64(R1);
	goto L4179;
L4181:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L4178:
	asu64(R1) = e;
	if (asu64(R1)) goto L4177;
L4179:
	asi64(R1) = normalexit;
	if (!asi64(R1)) goto L4183;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4185;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L4185;
	goto L4186;
L4185:
	R1 = 17;
	asu64(R2) = d;
	asu64(R3) = p;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	newd = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = newd;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4184;
L4186:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = d;
	asu64(R3) = p;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	newd = asu64(R1);
	asu64(R1) = newd;
	asu64(R2) = d;
	asu64(R3) = p;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_name_duplfield(asu64(R3), asu64(R2), asu64(R1));
L4184:
	asu64(R1) = newd;
	asu64(R2) = p;
	mm_lib_adddef(asu64(R2), asu64(R1));
L4183:
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L4175:
	asu64(R1) = d;
	if (asu64(R1)) goto L4174;
	return;
}

static i64 mm_parse_parsemodule(u64 pm) {
    u64 R1, R2; 
	u64 owner;
	mm_parse_initparser();
	asu64(R1) = pm;
	R2 = 16;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	mm_decls_currmoduleno = asi64(R1);
	asu64(R1) = pm;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_decls_stmodule = asu64(R1);
	asu64(R1) = mm_decls_stmodule;
	mm_decls_currproc = asu64(R1);
	asu64(R1) = pm;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_lex_startlex(asu64(R1));
	asu64(R1) = mm_decls_stmodule;
	owner = asu64(R1);
	mm_lex_lex();
	asu64(R1) = owner;
	mm_parse_readmoduledefs(asu64(R1));
	R1 = 1;
	goto L4187;
L4187:
	return asi64(R1);
}

static void mm_parse_readmoduledefs(u64 owner) {
    u64 R1, R2, R3, R4, R5; 
	i64 globalflag;
	R1 = 0;
	globalflag = asi64(R1);
L4189:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: goto L4220;
	case 2: case 3: case 5: case 6: case 7: case 8: case 9: case 10: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 110: case 112: case 113: case 118: case 119: case 124: case 127: case 128: case 129: case 130: case 131: goto L4193;
	case 4: goto L4208;
	case 11: case 79: case 80: case 117: case 121: goto L4200;
	case 59: goto L4209;
	case 67: goto L4221;
	case 108: case 109: goto L4199;
	case 111: goto L4206;
	case 114: goto L4203;
	case 115: goto L4211;
	case 116: goto L4204;
	case 120: goto L4202;
	case 122: goto L4210;
	case 123: goto L4205;
	case 125: goto L4216;
	case 126: goto L4194;
	case 132: goto L4207;
	default: goto L4193;
    };
// SWITCH
L4194:
	asi64(R1) = globalflag;
	if (!asi64(R1)) goto L4196;
	R1 = tou64("global global?");
	mm_support_serror(asu64(R1));
L4196:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	globalflag = asi64(R1);
	asi64(R1) = globalflag;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4198;
	asu64(R1) = mm_decls_stmodule;
	R2 = 95;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mm_decls_nsubprogs;
	if (asi64(R1) == asi64(R2)) goto L4198;
	R1 = 2;
	globalflag = asi64(R1);
L4198:
	mm_lex_lex();
	goto L4191;
L4199:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readprocdef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L4191;
L4200:
// mm_parse.readmoduledefs.dovar:
L4201:
	R1 = 0;
	R2 = 10;
	R3 = 0;
	asi64(R4) = globalflag;
	asu64(R5) = owner;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L4191;
L4202:
	mm_lex_lex();
	R1 = 120;
	R2 = 10;
	R3 = 0;
	asi64(R4) = globalflag;
	asu64(R5) = owner;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L4191;
L4203:
	asu64(R1) = owner;
	mm_parse_readimportmodule(asu64(R1));
	goto L4191;
L4204:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readtypedef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L4191;
L4205:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readconstdef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L4191;
L4206:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readclassdef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L4191;
L4207:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readtabledef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L4191;
L4208:
	mm_lex_lex();
	goto L4191;
L4209:
	goto L4190;
	goto L4191;
L4210:
	asi64(R1) = globalflag;
	asu64(R2) = owner;
	mm_parse_readmacrodef(asu64(R2), asi64(R1));
	R1 = 0;
	globalflag = asi64(R1);
	goto L4191;
L4211:
L4212:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L4215;
	R2 = 59;
	if (asi64(R1) != asi64(R2)) goto L4212;
L4215:
	R1 = 0;
	R2 = 0;
	R3 = 115;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L4191;
L4216:
L4217:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4217;
	goto L4191;
L4220:
	R1 = tou64("MODULE/DOT");
	mm_support_serror(asu64(R1));
	goto L4191;
L4221:
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L4223;
	goto L4201;
L4223:
	goto L4224;
	goto L4191;
L4193:
// mm_parse.readmoduledefs.doexec:
L4224:
	R1 = tou64("Code outside a function");
	mm_support_serror(asu64(R1));
L4191:
	goto L4189;
L4190:
	return;
}

static void mm_parse_initparser() {
    u64 R1; 
	u64 tabledataname;
	asu64(R1) = mm_decls_nullunit;
	if (asu64(R1)) goto L4227;
	R1 = 2;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	mm_decls_nullunit = asu64(R1);
L4227:
	R1 = 0;
	mm_decls_currproc = asu64(R1);
	R1 = 0;
	mm_parse_varattribs = asi64(R1);
	R1 = 0;
	mm_parse_intabledata = asi64(R1);
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	R1 = 0;
	mm_parse_inparamlist = asi64(R1);
	R1 = 0;
	mm_parse_inrecordbody = asi64(R1);
	R1 = 0;
	mm_parse_inimportmodule = asi64(R1);
	R1 = tou64("");
	tabledataname = asu64(R1);
	R1 = 0;
	mm_parse_labelseen = asi64(R1);
	R1 = 0;
	mm_parse_ndollar = asi64(R1);
	return;
}

static void mm_parse_skipsemi() {
    u64 R1, R2; 
	goto L4230;
L4229:
	mm_lex_lex();
L4230:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4229;
	return;
}

static u64 mm_parse_makeblock(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	if (!asu64(R1)) goto L4234;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L4234;
	asu64(R1) = p;
	goto L4232;
L4234:
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L4232;
L4232:
	return asu64(R1);
}

static void mm_parse_checkequals() {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4237;
	R1 = tou64("\"=\" expected");
	mm_support_serror(asu64(R1));
L4237:
	return;
}

static i64 mm_parse_getcurrline() {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	goto L4238;
L4238:
	return asi64(R1);
}

static i64 mm_parse_checkbegin(i64 fbrack) {
    u64 R1, R2; 
	i64 closesym;
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4241;
	asi64(R1) = fbrack;
	if (!asi64(R1)) goto L4241;
	R1 = 10;
	closesym = asi64(R1);
	mm_lex_lex();
	goto L4240;
L4241:
	R1 = 87;
	closesym = asi64(R1);
L4240:
	asi64(R1) = closesym;
	goto L4239;
L4239:
	return asi64(R1);
}

static void mm_parse_checkbeginend(i64 closesym, i64 kwd, i64 startline) {
    u64 R1, R2, R3, R4; 
	mm_parse_skipsemi();
	asi64(R1) = closesym;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4244;
	asi64(R1) = closesym;
	mm_parse_checksymbollex(asi64(R1));
	goto L4243;
L4244:
	asi64(R1) = startline;
	R2 = 0;
	asi64(R3) = kwd;
	asi64(R4) = closesym;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L4243:
	return;
}

static void mm_parse_checkend(i64 endsym, i64 endkwd1, i64 endkwd2, i64 startline) {
    u64 R1, R2, R3; 
	struct $B5 str;
	mm_parse_skipsemi();
	asi64(R1) = endsym;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L4247;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4247;
	goto L4245;
L4247:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L4249;
	R1 = tou64("'End' expected");
	mm_support_serror(asu64(R1));
L4249:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4251;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = endkwd1;
	if (asi64(R1) == asi64(R2)) goto L4254;
	asi64(R2) = endkwd2;
	if (asi64(R1) != asi64(R2)) goto L4253;
L4254:
	mm_lex_lex();
	goto L4245;
	goto L4252;
L4253:
// mm_parse.checkend.error:
	R1 = tou64("Mismatched end ");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asi64(R1) = startline;
	if (!asi64(R1)) goto L4257;
	R1 = (u64)&str;
	R2 = (u64)&str;
	asi64(R2) = strlen(asu64(R2));
	R1 += (i64)R2;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64(" (from line #)");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = startline;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_end();
L4257:
	R1 = (u64)&str;
	mm_support_serror(asu64(R1));
L4252:
L4251:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = endkwd1;
	if (asi64(R1) == asi64(R2)) goto L4260;
	asi64(R2) = endkwd2;
	if (asi64(R1) != asi64(R2)) goto L4259;
L4260:
	mm_lex_lex();
L4259:
L4245:
	return;
}

static u64 mm_parse_readvardef(u64 owner, i64 scope, i64 isstatic, i64 varid, i64 k) {
    u64 R1, R2, R3; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	i64 nvars;
	i64 m;
	i64 initcode;
	u64 stname;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L4263;
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	m = asi64(R1);
	goto L4262;
L4263:
	R1 = tou64("Readvar?");
	mm_support_serror(asu64(R1));
L4262:
	R1 = 0;
	nvars = asi64(R1);
	goto L4265;
L4264:
	R1 = (u64)&nvars;
	(*toi64p(R1)) += 1;
	asi64(R1) = varid;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stname;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = isstatic;
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 0;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = k;
	R2 = 120;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 4;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = varid;
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L4268;
	R1 = 1;
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 11;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L4268:
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asi64(R1) = varid;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4270;
	asu64(R1) = stname;
	mm_lib_addstatic(asu64(R1));
L4270:
	mm_lex_lex();
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4273;
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4272;
L4273:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4275;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4276;
	goto L4277;
L4275:
	R1 = 1;
	initcode = asi64(R1);
	goto L4274;
L4276:
	R1 = 2;
	initcode = asi64(R1);
	goto L4274;
L4277:
	R1 = 3;
	initcode = asi64(R1);
L4274:
	R1 = 1;
	asu64(R2) = stname;
	R3 = 168;
	*tou16p(((i64)R2+(i64)R3)) = asu16(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4279;
	asi64(R1) = varid;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4281;
	R1 = tou64("Non-variants can't use :=");
	mm_support_serror(asu64(R1));
	asu64(R1) = owner;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L4283;
	R1 = tou64("Can't use := for statics inside procs");
	mm_support_serror(asu64(R1));
L4283:
L4281:
	goto L4278;
L4279:
	asi64(R1) = varid;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L4285;
	R1 = tou64("Need 'static' for '='");
	mm_support_serror(asu64(R1));
	asu64(R1) = stname;
	mm_lib_addstatic(asu64(R1));
L4285:
L4278:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stname;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = initcode;
	asu64(R2) = stname;
	R3 = 171;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = varid;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L4287;
	asu64(R1) = stname;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = stname;
	asu64(R2) = mm_lib_createname(asu64(R2));
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 59;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L4287:
	goto L4271;
L4272:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4288;
	asi64(R1) = k;
	R2 = 120;
	if (asi64(R1) != asi64(R2)) goto L4290;
	R1 = tou64("let@");
	mm_support_serror(asu64(R1));
L4290:
	mm_lex_lex();
	R1 = 1;
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 8;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stname;
	R3 = 96;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4271;
L4288:
	asi64(R1) = k;
	R2 = 120;
	if (asi64(R1) != asi64(R2)) goto L4291;
	R1 = tou64("let needs :=/=");
	mm_support_serror(asu64(R1));
L4291:
L4271:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4293;
	goto L4266;
L4293:
	mm_lex_lex();
L4265:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4264;
L4266:
	asi64(R1) = nvars;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4295;
	R1 = tou64("No vars declared");
	mm_support_serror(asu64(R1));
L4295:
	asu64(R1) = ulist;
	goto L4261;
L4261:
	return asu64(R1);
}

static void mm_parse_readconstdef(u64 owner, i64 scope) {
    u64 R1, R2, R3; 
	i64 nconsts;
	i64 deft;
	i64 m;
	u64 stname;
	mm_lex_lex();
	R1 = 0;
	nconsts = asi64(R1);
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L4298;
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	deft = asi64(R1);
	goto L4297;
L4298:
	R1 = 22;
	deft = asi64(R1);
L4297:
	goto L4300;
L4299:
	R1 = 9;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	mm_lex_lex();
	mm_parse_checkequals();
	mm_lex_lex();
	R1 = 1;
	asu64(R1) = mm_parse_readconstexpr(asi64(R1));
	asu64(R2) = stname;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = deft;
	m = asi64(R1);
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&nconsts;
	(*toi64p(R1)) += 1;
	asi64(R1) = scope;
	asu64(R2) = stname;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4303;
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 36;
	if (asu64(R1) == asu64(R2)) goto L4303;
	asu64(R1) = stname;
	mm_lib_addexpconst(asu64(R1));
L4303:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4305;
	goto L4301;
L4305:
	mm_lex_lex();
L4300:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4299;
L4301:
	asi64(R1) = nconsts;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4307;
	R1 = tou64("No consts declared");
	mm_support_serror(asu64(R1));
L4307:
	return;
}

static u64 mm_parse_readlbrack() {
    u64 R1, R2, R3, R4; 
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 q;
	u64 r;
	u64 plower;
	i64 oldirp;
	i64 length;
	i64 usecomma;
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	R1 = 0;
	plower = asu64(R1);
	R1 = 0;
	length = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4310;
	mm_lex_lex();
	asi64(R1) = mm_parse_inreadprint;
	oldirp = asi64(R1);
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = mm_parse_readunit();
	plower = asu64(R1);
	asi64(R1) = oldirp;
	mm_parse_inreadprint = asi64(R1);
	R1 = 5;
	mm_parse_checksymbollex(asi64(R1));
	goto L4309;
L4310:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L4311;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4311;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	plower = asu64(R1);
	mm_lex_lex();
	mm_lex_lex();
	goto L4309;
L4311:
	R1 = (u64)&mm_tables_symboloptypes;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4312;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4312;
	R1 = 63;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	mm_lex_lex();
	mm_lex_lex();
	asu64(R1) = p;
	goto L4308;
	goto L4309;
L4312:
	R1 = (u64)&mm_tables_symboloptypes;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4313;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L4313;
	R1 = 63;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgentoops;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	mm_lex_lex();
	R1 = 10;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	asu64(R1) = p;
	goto L4308;
L4313:
L4309:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4315;
	goto L4316;
L4315:
	mm_lex_lex();
	R1 = 20;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asu64(R1) = plower;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L4308;
	goto L4314;
L4316:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
L4314:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4318;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4319;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L4320;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4321;
	goto L4322;
L4318:
	mm_lex_lex();
	asu64(R1) = p;
	goto L4308;
	goto L4317;
L4319:
	R1 = 1;
	usecomma = asi64(R1);
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4324;
	mm_lex_lex();
	mm_lex_lex();
	asu64(R1) = p;
	R2 = 20;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = plower;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	goto L4308;
L4324:
// mm_parse.readlbrack.docomma:
L4325:
	R1 = 1;
	length = asi64(R1);
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	asi64(R1) = usecomma;
	if (!asi64(R1)) goto L4327;
L4328:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4332;
	goto L4330;
L4332:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4334;
	R1 = tou64(",, null expr not allowed");
	mm_support_serror(asu64(R1));
L4334:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4328;
L4330:
	goto L4326;
L4327:
L4335:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4339;
	goto L4337;
L4339:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4341;
	R1 = tou64(",, null expr not allowed");
	mm_support_serror(asu64(R1));
L4341:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4335;
L4337:
L4326:
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = ulist;
	R2 = 20;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = plower;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	goto L4308;
	goto L4317;
L4320:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L4343;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4344;
	goto L4345;
L4343:
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	r = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = r;
	asu64(R2) = q;
	asu64(R3) = p;
	asu64(R3) = mm_parse_fixcond(asu64(R3));
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 48;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L4308;
	goto L4342;
L4344:
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = q;
	asu64(R3) = p;
	asu64(R3) = mm_parse_fixcond(asu64(R3));
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 48;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L4308;
	goto L4342;
L4345:
L4342:
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = 3;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L4347;
L4348:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4348;
	R1 = 16;
	mm_parse_checksymbol(asi64(R1));
	goto L4346;
L4347:
	mm_lex_lex();
L4346:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	r = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = r;
	asu64(R2) = ulist;
	asu64(R3) = p;
	R4 = 112;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L4308;
	goto L4317;
L4321:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4352;
	R1 = 0;
	usecomma = asi64(R1);
	goto L4325;
L4352:
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L4353:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4357;
	goto L4355;
L4357:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4353;
L4355:
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = ulist;
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	goto L4308;
	goto L4317;
L4322:
	R1 = tou64("(x ...");
	mm_support_serror(asu64(R1));
L4317:
	R1 = 0;
	goto L4308;
L4308:
	return asu64(R1);
}

static void mm_parse_addlistparam(u64 ulist, u64 ulistx, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = ulist;
	asu64(R1) = *tou64p(R1);
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4360;
	asu64(R1) = p;
	R2 = R1;
	asu64(R3) = ulistx;
	*tou64p(R3) = asu64(R2);
	asu64(R2) = ulist;
	*tou64p(R2) = asu64(R1);
	goto L4359;
L4360:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	asu64(R2) = *tou64p(R2);
	R3 = 152;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4359:
	asu64(R1) = p;
	asu64(R2) = ulistx;
	*tou64p(R2) = asu64(R1);
	return;
}

static u64 mm_parse_readcast() {
    u64 R1, R2, R3; 
	u64 p;
	i64 opc;
	i64 t;
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4363;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L4364;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4365;
	goto L4366;
L4363:
	R1 = 62;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 26;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	goto L4361;
	goto L4362;
L4364:
	R1 = 61;
	opc = asi64(R1);
	mm_lex_lex();
	goto L4362;
L4365:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 116;
	if (asi64(R1) != asi64(R2)) goto L4368;
	mm_lex_lex();
	R1 = 62;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 26;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	mm_lex_lex();
	goto L4367;
L4368:
	R1 = 62;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L4367:
	asu64(R1) = p;
	goto L4361;
	goto L4362;
L4366:
	R1 = 58;
	opc = asi64(R1);
L4362:
	R1 = 9;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 53;
	R1 += (i64)R2;
	asi64(R2) = t;
	asu64(R3) = mm_decls_currproc;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	goto L4361;
L4361:
	return asu64(R1);
}

static u64 mm_parse_readopc() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 r;
	i64 tag;
	i64 opc;
	i64 firstsym;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	firstsym = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L4371;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L4372;
	goto L4373;
L4371:
	R1 = 36;
	tag = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	goto L4370;
L4372:
	R1 = 35;
	tag = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	goto L4370;
L4373:
	R1 = 36;
	tag = asi64(R1);
	R1 = (u64)&mm_tables_symbolgenops;
	asi64(R2) = firstsym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
L4370:
	mm_lex_lex();
	asi64(R1) = firstsym;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L4375;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4376;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L4377;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L4377;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L4377;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L4377;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L4377;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L4377;
	goto L4378;
L4375:
	asu64(R1) = mm_parse_readterm2();
	goto L4369;
	goto L4374;
L4376:
	R1 = 60;
	opc = asi64(R1);
	goto L4374;
L4377:
	asu64(R1) = mm_parse_readterm2();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L4380;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L4382;
	R1 = tou64("Needs (x,y)");
	mm_support_serror(asu64(R1));
L4382:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = r;
	asu64(R2) = q;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L4369;
	goto L4379;
L4380:
	R1 = tou64("READOPC/SINGLE OPND?");
	mm_support_serror(asu64(R1));
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L4369;
L4379:
	goto L4374;
L4378:
	R1 = (u64)&mm_tables_symboloptypes;
	asi64(R2) = firstsym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4384;
	R1 = tou64("Can't be used as unary op");
	mm_support_serror(asu64(R1));
L4384:
L4374:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L4386;
	mm_lex_lex();
	R1 = 39;
	tag = asi64(R1);
	asi64(R1) = firstsym;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L4388;
	goto L4389;
L4388:
	R1 = 105;
	opc = asi64(R1);
	goto L4387;
L4389:
	R1 = (u64)&mm_tables_symbolgentoops;
	asi64(R2) = firstsym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	asi64(R1) = opc;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4391;
	R1 = tou64("op:= not available");
	mm_support_serror(asu64(R1));
L4391:
L4387:
L4386:
	asu64(R1) = mm_parse_readterm2();
	R2 = R1;
	q = asu64(R2);
	asi64(R2) = tag;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L4393;
	R1 = tou64("Too many opnds");
	mm_support_serror(asu64(R1));
L4393:
	asu64(R1) = p;
	goto L4369;
L4369:
	return asu64(R1);
}

static u64 mm_parse_readcompilervar() {
    u64 R1, R2, R3; 
	struct $B5 str;
	struct $B3 tm;
	u64 p;
	u64 currmodule;
// PROC LOCAL STATICS GO HERE
	static struct $B59 mm_parse_readcompilervar_monthnames = {{
	(u64)"Jan",
	(u64)"Feb",
	(u64)"Mar",
	(u64)"Apr",
	(u64)"May",
	(u64)"Jun",
	(u64)"Jul",
	(u64)"Aug",
	(u64)"Sep",
	(u64)"Oct",
	(u64)"Nov",
	(u64)"Dec"    }};
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = mm_decls_currmoduleno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	currmodule = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 71: goto L4401;
	case 72: goto L4402;
	case 73: goto L4403;
	case 74: goto L4404;
	case 75: goto L4405;
	case 76: goto L4406;
	case 77: goto L4407;
	case 78: goto L4408;
	case 79: goto L4397;
	case 80: goto L4398;
	case 81: goto L4399;
	case 82: goto L4400;
	case 83: case 84: goto L4409;
	default: goto L4397;
    };
// SWITCH
L4398:
	R1 = 7;
	R2 = 0;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L4394;
	goto L4395;
L4399:
	R1 = 1;
	asr64(R2) = 3.141592653589793100e+000;
	asi64(R2) = asi64(R2);
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L4394;
	goto L4395;
L4400:
	R1 = 1;
	asr64(R2) = (1.0/0.0);
	asi64(R2) = asi64(R2);
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L4394;
	goto L4395;
L4401:
	R1 = 3;
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = tou64(tou32(R2));
	asu64(R2) = mm_support_getlineno(asu64(R2));
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L4394;
	goto L4395;
L4402:
	R1 = (u64)&str;
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = tou64(tou32(R2));
	asi64(R2) = mm_support_getlineno(asu64(R2));
	msysc_getstrint(asi64(R2), asu64(R1));
	goto L4395;
L4403:
	asu64(R1) = mm_decls_stmodule;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4395;
L4404:
	R1 = (u64)&mm_decls_sources;
	asu64(R2) = currmodule;
	R3 = 20;
	asi16(R2) = *toi16p(((i64)R2+(i64)R3));
	R2 = toi64(toi16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4395;
L4405:
	asu64(R1) = mm_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4395;
L4406:
	R1 = (u64)&tm;
	mwindows_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#-#-#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&tm;
	R2 = 6;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = (u64)&mm_parse_readcompilervar_monthnames;
	R2 = (u64)&tm;
	R3 = 2;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("4");
	R2 = (u64)&tm;
	R3 = 0;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	goto L4395;
L4407:
	R1 = (u64)&tm;
	mwindows_os_getsystime(asu64(R1));
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("#:#:#");
	msysc_m$print_setfmt(asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 8;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 10;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	R1 = tou64("z2");
	R2 = (u64)&tm;
	R3 = 12;
	asu16(R2) = *tou16p(((i64)R2+(i64)R3));
	R2 = toi64(tou16(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_end();
	goto L4395;
L4408:
	R1 = tou64("Compiler:M6.4");
	R2 = (u64)&str;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	goto L4395;
L4409:
	R1 = 6;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 83;
	asi64(R2) = asi64(R2)  ==  asi64(R3);
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	asu64(R1) = p;
	goto L4394;
	goto L4395;
L4397:
	R1 = (u64)&mm_tables_jtagnames;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = tou64("compiler var not impl: #");
	mm_support_serror_s(asu64(R2), asu64(R1));
L4395:
	mm_lex_lex();
	R1 = -1;
	R2 = (u64)&str;
	asu64(R2) = mlib_pcm_copyheapstring(asu64(R2));
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	goto L4394;
L4394:
	return asu64(R1);
}

static u64 mm_parse_readcastx() {
    u64 R1, R2, R3; 
	i64 opc;
	i64 m;
	u64 p;
	mm_lex_lex();
	R1 = 58;
	opc = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4412;
	R1 = 61;
	opc = asi64(R1);
	mm_lex_lex();
L4412:
	R1 = 9;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	m = asi64(R1);
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4414;
	asi64(R1) = opc;
	R2 = 61;
	if (asi64(R1) != asi64(R2)) goto L4416;
	R1 = tou64("@ type missing");
	mm_support_serror(asu64(R1));
L4416:
	R1 = 60;
	opc = asi64(R1);
	goto L4413;
L4414:
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	m = asi64(R1);
L4413:
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = p;
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 53;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = mm_decls_currproc;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = p;
	goto L4410;
L4410:
	return asu64(R1);
}

static void mm_parse_checksymbol(i64 symbol) {
    u64 R1, R2, R3; 
	struct $B5 str;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = symbol;
	if (asi64(R1) == asi64(R2)) goto L4419;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	R1 = tou64("# expected, not #");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_tables_symbolnames;
	asi64(R2) = symbol;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_symbolnames;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	mm_support_serror(asu64(R1));
L4419:
	return;
}

static void mm_parse_lexchecksymbol(i64 symbol) {
    u64 R1; 
	mm_lex_lex();
	asi64(R1) = symbol;
	mm_parse_checksymbol(asi64(R1));
	return;
}

static void mm_parse_checksymbollex(i64 symbol) {
    u64 R1; 
	asi64(R1) = symbol;
	mm_parse_checksymbol(asi64(R1));
	mm_lex_lex();
	return;
}

static i64 mm_parse_readtypespec(u64 owner, i64 typedefx) {
    u64 R1, R2, R3, R4; 
	u64 d;
	u64 e;
	i64 t;
	i64 kwd;
	i64 sltype;
	i64 w;
	u64 x;
	u64 pupper;
	u64 plx;
	u64 dim;
	u64 length;
	struct $B83 dims;
	i64 ndims;
	i64 i;
	i64 n;
	i64 k;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4424;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L4425;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4426;
	R2 = 111;
	if (asi64(R1) == asi64(R2)) goto L4427;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L4427;
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L4428;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L4429;
	R2 = 80;
	if (asi64(R1) == asi64(R2)) goto L4430;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L4431;
	goto L4432;
L4424:
// mm_parse.readtypespec.arraybounds:
	mm_lex_lex();
	R1 = 0;
	ndims = asi64(R1);
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
L4434:
	R1 = 0;
	length = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4438;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4437;
L4438:
	R1 = 0;
	dim = asu64(R1);
	goto L4436;
L4437:
	asu64(R1) = mm_parse_readunit();
	dim = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4440;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4440;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4441;
	goto L4442;
L4440:
	goto L4439;
L4441:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4444;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4444;
	asu64(R1) = mm_parse_readunit();
	length = asu64(R1);
	asu64(R1) = length;
	asu64(R2) = dim;
	R3 = 27;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	dim = asu64(R1);
	goto L4443;
L4444:
	asu64(R1) = dim;
	R2 = 27;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	dim = asu64(R1);
L4443:
	goto L4439;
L4442:
L4439:
L4436:
	asi64(R1) = ndims;
	R2 = 30;
	if (asi64(R1) < asi64(R2)) goto L4446;
	R1 = tou64("Too many array dims");
	mm_support_serror(asu64(R1));
L4446:
	asu64(R1) = dim;
	R2 = (u64)&dims;
	R3 = (u64)&ndims;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4448;
	goto L4435;
L4448:
	mm_lex_lex();
	goto L4434;
L4435:
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	R1 = 12;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	asi64(R1) = ndims;
	i = asi64(R1);
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4451;
L4449:
	asi64(R1) = i;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4453;
	asi64(R1) = typedefx;
	goto L4452;
L4453:
	R1 = 0;
L4452:
	R2 = (u64)&dims;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asi64(R3) = t;
	asu64(R4) = owner;
	asi64(R1) = mm_lib_createarraymode(asu64(R4), asi64(R3), asu64(R2), asi64(R1));
	t = asi64(R1);
	i += -1; if (i >= 1) goto L4449;
L4451:
	asi64(R1) = t;
	goto L4422;
	goto L4423;
L4425:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	t = asi64(R1);
	mm_lex_lex();
	goto L4423;
L4426:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4455;
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	asi64(R1) = mm_lib_newtypename(asu64(R2), asu64(R1));
	t = asi64(R1);
	mm_lex_lex();
	goto L4454;
L4455:
	asu64(R1) = d;
	R2 = 0;
	asi64(R1) = mm_lib_newtypename(asu64(R2), asu64(R1));
	t = asi64(R1);
L4454:
	goto L4423;
L4427:
	R1 = tou64("Use 'record name =' syntax");
	mm_support_serror(asu64(R1));
	goto L4423;
L4428:
	R1 = tou64("Top-level union not allowed");
	mm_support_serror(asu64(R1));
	goto L4423;
L4429:
// mm_parse.readtypespec.retry:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 94;
	if (asi64(R1) != asi64(R2)) goto L4458;
	mm_lex_lex();
L4458:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L4460;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L4460;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L4461;
	R2 = 118;
	if (asi64(R1) == asi64(R2)) goto L4462;
	goto L4463;
L4460:
	asi64(R1) = typedefx;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readrefproc(asu64(R2), asi64(R1));
	t = asi64(R1);
	goto L4459;
L4461:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4465;
	goto L4466;
L4465:
	R1 = 20;
	t = asi64(R1);
	asi64(R1) = typedefx;
	if (!asi64(R1)) goto L4468;
	R1 = 12;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = typedefx;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L4468:
	goto L4464;
L4466:
	goto L4469;
L4464:
	mm_lex_lex();
	goto L4459;
L4462:
	mm_lex_lex();
	R1 = 0;
	t = asi64(R1);
	goto L4470;
	goto L4459;
L4463:
// mm_parse.readtypespec.readtarget:
L4469:
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
// mm_parse.readtypespec.gottarget:
L4470:
	asi64(R1) = typedefx;
	asi64(R2) = t;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	t = asi64(R1);
L4459:
	goto L4423;
L4430:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L4472;
	R1 = 20;
	t = asi64(R1);
	goto L4471;
L4472:
	R1 = 7;
	t = asi64(R1);
L4471:
	asi64(R1) = typedefx;
	if (!asi64(R1)) goto L4474;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = typedefx;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L4474:
	mm_lex_lex();
	goto L4423;
L4431:
	asi64(R1) = typedefx;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R3) = owner;
	asi64(R1) = mm_parse_readslicetype(asu64(R3), asi64(R2), asi64(R1));
	t = asi64(R1);
	goto L4423;
L4432:
	R1 = tou64("Bad type starter");
	mm_support_serror(asu64(R1));
L4423:
	asi64(R1) = typedefx;
	if (!asi64(R1)) goto L4476;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = typedefx;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L4476:
	asi64(R1) = t;
	goto L4422;
L4422:
	return asi64(R1);
}

static i64 mm_parse_readslicetype(u64 owner, i64 slicetype, i64 typedefx) {
    u64 R1, R2, R3, R4, R5; 
	u64 plower;
	i64 t;
	R1 = 11;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4479;
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = mm_parse_readunit();
	plower = asu64(R1);
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	R1 = 5;
	mm_parse_checksymbol(asi64(R1));
	R1 = 12;
	mm_parse_lexchecksymbol(asi64(R1));
	goto L4478;
L4479:
	R1 = 0;
	plower = asu64(R1);
L4478:
	mm_lex_lex();
	asi64(R1) = typedefx;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	asi64(R1) = typedefx;
	asu64(R2) = plower;
	asi64(R3) = t;
	asi64(R4) = slicetype;
	asu64(R5) = owner;
	asi64(R1) = mm_lib_createslicemode(asu64(R5), asi64(R4), asi64(R3), asu64(R2), asi64(R1));
	goto L4477;
L4477:
	return asi64(R1);
}

static u64 mm_parse_readslist(i64 iscall, i64 donulls) {
    u64 R1, R2, R3; 
	u64 ulist;
	u64 ulistx;
	i64 oldinparamlist;
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4482;
	asu64(R1) = ulist;
	goto L4480;
L4482:
	asi64(R1) = mm_parse_inparamlist;
	oldinparamlist = asi64(R1);
	asi64(R1) = iscall;
	mm_parse_inparamlist = asi64(R1);
L4483:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4486;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4487;
	goto L4488;
L4486:
	asi64(R1) = donulls;
	if (!asi64(R1)) goto L4490;
	R1 = 2;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L4489;
L4490:
	R1 = tou64("null comma expr not allowed");
	mm_support_serror(asu64(R1));
L4489:
	mm_lex_lex();
	goto L4485;
L4487:
	asi64(R1) = donulls;
	if (!asi64(R1)) goto L4492;
	asu64(R1) = mm_decls_nullunit;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L4492:
	goto L4484;
	goto L4485;
L4488:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4495;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4494;
L4495:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4497;
	goto L4484;
L4497:
	goto L4493;
L4494:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4499;
	goto L4484;
L4499:
	R1 = tou64("SLIST?");
	mm_support_serror(asu64(R1));
L4493:
L4485:
	goto L4483;
L4484:
	asi64(R1) = oldinparamlist;
	mm_parse_inparamlist = asi64(R1);
	asu64(R1) = ulist;
	goto L4480;
L4480:
	return asu64(R1);
}

static u64 mm_parse_readindex(u64 p, i64 dot) {
    u64 R1, R2, R3; 
	u64 q;
	u64 plower;
	u64 pupper;
	mm_lex_lex();
	asi64(R1) = dot;
	if (asi64(R1)) goto L4502;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L4504;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L4505;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4505;
	goto L4506;
L4504:
// mm_parse.readindex.fullslice:
L4507:
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 36;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	plower = asu64(R1);
	R1 = 3;
	asu64(R2) = plower;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 36;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	pupper = asu64(R1);
	R1 = 4;
	asu64(R2) = pupper;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pupper;
	asu64(R2) = plower;
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	asu64(R2) = p;
	R3 = 48;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	goto L4500;
	goto L4503;
L4505:
	R1 = 12;
	mm_parse_lexchecksymbol(asi64(R1));
	goto L4507;
	goto L4503;
L4506:
L4503:
L4502:
L4508:
	asi64(R1) = mm_parse_ndollar;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4511;
	R1 = tou64("Too many nested a[$]");
	mm_support_serror(asu64(R1));
L4511:
	asu64(R1) = p;
	R2 = (u64)&mm_parse_dollarstack;
	R3 = (u64)&mm_parse_ndollar;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = (u64)&mm_parse_ndollar;
	(*toi64p(R1)) -=1;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L4513;
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = dot;
	if (!asi64(R3)) goto L4515;
	R3 = 52;
	goto L4514;
L4515:
	R3 = 48;
L4514:
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4512;
L4513:
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = dot;
	if (!asi64(R3)) goto L4517;
	R3 = 51;
	goto L4516;
L4517:
	R3 = 46;
L4516:
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L4512:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4519;
	goto L4509;
L4519:
	mm_lex_lex();
	goto L4508;
L4509:
	R1 = 12;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = p;
	goto L4500;
L4500:
	return asu64(R1);
}

static u64 mm_parse_readdotsuffix(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	u64 r;
	u64 p2;
	goto L4522;
L4521:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4525;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4526;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L4527;
	R2 = 57;
	if (asi64(R1) == asi64(R2)) goto L4528;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L4529;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L4530;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L4531;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L4532;
	goto L4533;
L4525:
	R1 = 1;
	asu64(R2) = p;
	asu64(R1) = mm_parse_readindex(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L4524;
L4526:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_createname(asu64(R1));
	asu64(R2) = p;
	R3 = 49;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	mm_lex_lex();
	goto L4524;
L4527:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4535;
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	r = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L4537;
	R1 = 9;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	asu64(R2) = r;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4536;
L4537:
	R1 = 3;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 4;
	asu64(R2) = r;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4536:
	asu64(R1) = r;
	asu64(R2) = q;
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p2 = asu64(R1);
	asu64(R1) = p2;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L4534;
L4535:
// mm_parse.readdotsuffix.doprop:
L4538:
	asu64(R1) = p;
	R2 = 37;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4534:
	mm_lex_lex();
	goto L4524;
L4528:
	asu64(R1) = p;
	R2 = 68;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	mm_lex_lex();
	goto L4524;
L4529:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L4540;
	goto L4541;
L4540:
	goto L4539;
L4541:
	R1 = tou64("RDS:TYPEOF");
	mm_support_serror(asu64(R1));
L4539:
	mm_lex_lex();
	goto L4524;
L4530:
	R1 = 10;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4538;
	goto L4524;
L4531:
	R1 = 9;
	R2 = (u64)&mm_decls_lx;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4538;
	goto L4524;
L4532:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L4543;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4543;
	asu64(R1) = p;
	R2 = 36;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = p;
	R3 = 36;
	asu64(R2) = mm_lib_createunit1(asi64(R3), asu64(R2));
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 9;
	asu64(R2) = q;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 10;
	asu64(R2) = q;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4542;
L4543:
	goto L4544;
L4542:
	mm_lex_lex();
	asu64(R1) = q;
	p = asu64(R1);
	goto L4524;
L4533:
// mm_parse.readdotsuffix.error:
L4544:
	R1 = tou64("Unknown dot suffix");
	mm_support_serror(asu64(R1));
L4524:
L4522:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4521;
	asu64(R1) = p;
	goto L4520;
L4520:
	return asu64(R1);
}

static u64 mm_parse_readconstexpr(i64 needconst) {
    u64 R1; 
	asu64(R1) = mm_parse_readunit();
	goto L4545;
L4545:
	return asu64(R1);
}

static i64 mm_parse_readconstint() {
    u64 R1, R2; 
	i64 x;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L4548;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	x = asi64(R1);
	mm_lex_lex();
	asi64(R1) = x;
	goto L4546;
	goto L4547;
L4548:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 25;
	if (asi64(R1) != asi64(R2)) goto L4549;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L4551;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	x = asi64(R1);
	mm_lex_lex();
	asi64(R1) = x;
	asi64(R1) = -asi64(R1);
	goto L4546;
L4551:
L4549:
L4547:
	R1 = tou64("Can't do complex expr");
	mm_support_serror(asu64(R1));
	R1 = 0;
	goto L4546;
L4546:
	return asi64(R1);
}

static void mm_parse_readprocdef(u64 procowner, i64 scope) {
    u64 R1, R2, R3; 
	i64 kwd;
	i64 startline;
	i64 closesym;
	i64 shortfun;
	u64 stproc;
	u64 stname;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	shortfun = asi64(R1);
	R1 = 0;
	mm_parse_nforloops = asi64(R1);
	R1 = 1;
	mm_decls_assemmode = asi64(R1);
	asi64(R1) = scope;
	asu64(R2) = procowner;
	asu64(R1) = mm_parse_readprocdecl(asu64(R2), asi64(R1));
	stproc = asu64(R1);
	R1 = 0;
	mm_decls_assemmode = asi64(R1);
	mm_parse_checkequals();
	mm_lex_lex();
	asi64(R1) = mm_parse_getcurrline();
	startline = asi64(R1);
	asi64(R1) = shortfun;
	if (asi64(R1)) goto L4554;
	R1 = 0;
	asi64(R1) = mm_parse_checkbegin(asi64(R1));
	closesym = asi64(R1);
L4554:
	asu64(R1) = stproc;
	mm_parse_pushproc(asu64(R1));
	R1 = 0;
	mm_lib_nextavindex = asi64(R1);
	asu64(R1) = mm_parse_dretvar;
	if (!asu64(R1)) goto L4556;
	R1 = 11;
	asu64(R2) = mm_parse_dretvar;
	asu64(R3) = stproc;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asu64(R2) = stproc;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = procowner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = stname;
	asu64(R2) = stproc;
	mm_lib_adddef(asu64(R2), asu64(R1));
L4556:
	asu64(R1) = stproc;
	mm_lib_addtoproclist(asu64(R1));
	asi64(R1) = shortfun;
	if (!asi64(R1)) goto L4558;
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4;
	mm_parse_checksymbollex(asi64(R1));
	goto L4557;
L4558:
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = startline;
	asi64(R2) = kwd;
	asi64(R3) = closesym;
	mm_parse_checkbeginend(asi64(R3), asi64(R2), asi64(R1));
L4557:
	asu64(R1) = stproc;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	mm_parse_popproc();
	return;
}

static u64 mm_parse_readprocdecl(u64 procowner, i64 scope) {
    u64 R1, R2, R3, R4; 
	i64 kwd;
	i64 varparams;
	i64 nparams;
	i64 nretvalues;
	i64 isthreaded;
	i64 subprogno;
	struct $B18 retmodes;
	u64 ms;
	u64 ps;
	u64 metadata;
	u64 truename;
	u64 pequiv;
	u64 stproc;
	u64 owner;
	u64 paramlist;
	u64 nameptr;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	isthreaded = asi64(R1);
	R1 = 0;
	pequiv = asu64(R1);
	R1 = tou64("");
	metadata = asu64(R1);
	R1 = 0;
	truename = asu64(R1);
	R1 = 0;
	varparams = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L4561;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	truename = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mlib_convlcstring(asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lex_addnamestr(asu64(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L4560;
L4561:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
L4560:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nameptr = asu64(R1);
	asi64(R1) = mm_parse_insidedllimport;
	if (!asi64(R1)) goto L4563;
	R1 = 7;
	goto L4562;
L4563:
	R1 = 6;
L4562:
	asu64(R2) = nameptr;
	asu64(R3) = procowner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stproc = asu64(R1);
	asi64(R1) = mm_parse_insidedllimport;
	if (!asi64(R1)) goto L4565;
	R1 = 1;
	scope = asi64(R1);
L4565:
	asi64(R1) = isthreaded;
	asu64(R2) = stproc;
	R3 = 124;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = truename;
	if (!asu64(R1)) goto L4567;
	asu64(R1) = truename;
	asu64(R2) = stproc;
	R3 = 104;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4567:
	asu64(R1) = stproc;
	asu64(R2) = procowner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stproc;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L4569;
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 11;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L4569:
	asu64(R1) = stproc;
	owner = asu64(R1);
	asu64(R1) = stproc;
	mm_parse_pushproc(asu64(R1));
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) != asi64(R2)) goto L4571;
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 6;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	mm_lex_lex();
L4571:
	R1 = 0;
	paramlist = asu64(R1);
	R1 = 0;
	R2 = (u64)&retmodes;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 0;
	nparams = asi64(R1);
	R1 = 0;
	nretvalues = asi64(R1);
	R1 = 0;
	nretvalues = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4573;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4575;
	R1 = (u64)&nparams;
	R2 = (u64)&varparams;
	asu64(R3) = stproc;
	asu64(R4) = procowner;
	asu64(R1) = mm_parse_readparams(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	paramlist = asu64(R1);
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
L4575:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4578;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L4577;
L4578:
	mm_lex_lex();
	R1 = (u64)&retmodes;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
	goto L4576;
L4577:
	R1 = (u64)&mm_decls_typestarterset;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4580;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L4579;
L4580:
	R1 = (u64)&retmodes;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
L4579:
L4576:
	goto L4572;
L4573:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4582;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L4581;
L4582:
	mm_lex_lex();
	R1 = (u64)&retmodes;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
L4581:
L4572:
	R1 = 0;
	mm_parse_dretvar = asu64(R1);
	asi64(R1) = nretvalues;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4584;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L4586;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_parse_dretvar = asu64(R1);
	mm_lex_lex();
L4586:
L4584:
	asi64(R1) = nretvalues;
	if (asi64(R1)) goto L4588;
	asi64(R1) = kwd;
	R2 = 109;
	if (asi64(R1) != asi64(R2)) goto L4588;
	R1 = tou64("Function needs ret type");
	mm_support_serror(asu64(R1));
L4588:
	asi64(R1) = nretvalues;
	if (!asi64(R1)) goto L4590;
	asi64(R1) = kwd;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L4590;
	R1 = tou64("Proc can't return value");
	mm_support_serror(asu64(R1));
L4590:
	asu64(R1) = paramlist;
	asu64(R2) = stproc;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = nretvalues;
	asu64(R2) = stproc;
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = nretvalues;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4592;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4593;
	goto L4594;
L4592:
	R1 = 0;
	asu64(R2) = stproc;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L4591;
L4593:
	asu64(R1) = stproc;
	R2 = 72;
	R1 += (i64)R2;
	R2 = (u64)&retmodes;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = procowner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	goto L4591;
L4594:
	R1 = 0;
	asi64(R2) = nretvalues;
	R3 = (u64)&retmodes;
	asu64(R4) = procowner;
	asi64(R1) = mm_lib_createtuplemode(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = stproc;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L4591:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4596;
	R1 = tou64("READPROCDEF @");
	mm_support_serror(asu64(R1));
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 8;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L4596:
	R1 = 0;
	asu64(R2) = stproc;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stproc;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = varparams;
	asu64(R2) = stproc;
	R3 = 123;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = procowner;
	asu64(R2) = mm_decls_stmodule;
	if (asu64(R1) != asu64(R2)) goto L4598;
	asu64(R1) = stproc;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4600;
	R1 = tou64("start");
	asu64(R2) = stproc;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4600;
	asu64(R1) = stproc;
	R2 = (u64)&mm_decls_modules;
	asu64(R3) = mm_decls_stmodule;
	R4 = 94;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 48;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = stproc;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4601;
	goto L4599;
L4600:
	asu64(R1) = stproc;
	R2 = 76;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L4602;
	R1 = tou64("main");
	asu64(R2) = stproc;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4602;
	R1 = (u64)&mm_decls_modules;
	asu64(R2) = mm_decls_stmodule;
	R3 = 94;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ms = asu64(R1);
	R1 = (u64)&mm_decls_subprogs;
	asu64(R2) = mm_decls_stmodule;
	R3 = 95;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	ps = asu64(R1);
	asu64(R1) = ps;
	R2 = 10;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	if (!asi16(R1)) goto L4604;
	R1 = tou64("More than one main() in SP");
	mm_support_serror(asu64(R1));
L4604:
	asu64(R1) = mm_decls_stmodule;
	R2 = 94;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = ps;
	R3 = 10;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = stproc;
	asu64(R2) = ms;
	R3 = 56;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = ps;
	R2 = 15;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = mm_decls_mainsubprogno;
	if (asi64(R1) != asi64(R2)) goto L4606;
	R1 = 3;
	asu64(R2) = stproc;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
// mm_parse.readprocdecl.dosigcheck:
L4601:
	asu64(R1) = stproc;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L4609;
	asu64(R1) = stproc;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L4608;
L4609:
	R1 = tou64("Wrong 'main/start' sig");
	mm_support_serror(asu64(R1));
L4608:
L4606:
L4602:
L4599:
L4598:
	mm_parse_popproc();
	asu64(R1) = stproc;
	goto L4559;
L4559:
	return asu64(R1);
}

static u64 mm_parse_readparams(u64 procowner, u64 owner, u64 varparams, u64 nparams) {
    u64 R1, R2, R3; 
	u64 stlist;
	u64 stlistx;
	u64 stname;
	i64 parammode;
	i64 pmode;
	i64 m;
	i64 isoptional;
	i64 types;
	struct $B18 str;
	R1 = 0;
	R2 = R1;
	stlistx = asu64(R2);
	stlist = asu64(R1);
	R1 = 0;
	pmode = asi64(R1);
	R1 = 0;
	asu64(R2) = nparams;
	*toi64p(R2) = asi64(R1);
	R1 = 0;
	parammode = asi64(R1);
	R1 = 0;
	types = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L4612;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4613;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4612;
L4613:
	R1 = 1;
	types = asi64(R1);
L4612:
L4614:
	R1 = 0;
	parammode = asi64(R1);
	R1 = 0;
	isoptional = asi64(R1);
	asi64(R1) = types;
	if (asi64(R1)) goto L4618;
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L4617;
L4618:
	R1 = 0;
	asu64(R2) = procowner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	pmode = asi64(R1);
// mm_parse.readparams.gotmode:
	asu64(R1) = nparams;
	asi64(R1) = *toi64p(R1);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4621;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4622;
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4621;
L4622:
L4623:
	asu64(R1) = nparams;
	(*toi64p(R1)) += 1;
	R1 = 36;
	R2 = (u64)&str;
	R3 = 1;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	R2 = (u64)&str;
	R3 = 2;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = 0;
	asu64(R2) = nparams;
	asi64(R2) = *toi64p(R2);
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = (u64)&str;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = 12;
	R2 = (u64)&str;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = pmode;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = parammode;
	asu64(R2) = stname;
	R3 = 160;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stname;
	R2 = (u64)&stlistx;
	R3 = (u64)&stlist;
	mm_parse_addlistparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4626;
	goto L4627;
L4626:
	goto L4624;
	goto L4625;
L4627:
L4625:
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L4629;
	asu64(R1) = nparams;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = varparams;
	*toi64p(R2) = asi64(R1);
	mm_lex_lex();
	goto L4624;
L4629:
	R1 = 0;
	asu64(R2) = procowner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	pmode = asi64(R1);
	goto L4623;
L4624:
	asu64(R1) = stlist;
	goto L4610;
L4621:
	goto L4616;
L4617:
	asi64(R1) = pmode;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4630;
	R1 = tou64("Type expected");
	mm_support_serror(asu64(R1));
L4630:
L4616:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L4632;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L4633;
	goto L4634;
L4632:
	R1 = 1;
	parammode = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4636;
	mm_lex_lex();
L4636:
	goto L4631;
L4633:
	asu64(R1) = nparams;
	asi64(R1) = *toi64p(R1);
	asu64(R2) = varparams;
	*toi64p(R2) = asi64(R1);
	mm_lex_lex();
	asu64(R1) = stlist;
	goto L4610;
	goto L4631;
L4634:
L4631:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	asu64(R1) = nparams;
	(*toi64p(R1)) += 1;
	R1 = 12;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	mm_lex_lex();
	asi64(R1) = parammode;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4638;
	R1 = 0;
	asi64(R2) = pmode;
	asu64(R3) = procowner;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	m = asi64(R1);
	goto L4637;
L4638:
	asi64(R1) = pmode;
	m = asi64(R1);
L4637:
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = parammode;
	asu64(R2) = stname;
	R3 = 160;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = isoptional;
	asu64(R2) = stname;
	R3 = 161;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stname;
	R2 = (u64)&stlistx;
	R3 = (u64)&stlist;
	mm_parse_addlistparam(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4640;
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L4640;
	goto L4641;
L4640:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stname;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 171;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = stname;
	R3 = 161;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L4639;
L4641:
L4639:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4643;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4644;
	goto L4645;
L4643:
	mm_lex_lex();
	goto L4642;
L4644:
	goto L4615;
	goto L4642;
L4645:
	R1 = tou64("nameparams1");
	mm_support_serror(asu64(R1));
L4642:
	goto L4614;
L4615:
	asu64(R1) = stlist;
	goto L4610;
L4610:
	return asu64(R1);
}

static u64 mm_parse_readcondsuffix(u64 p) {
    u64 R1, R2, R3; 
	u64 q;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L4648;
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L4649;
	goto L4650;
L4648:
	mm_lex_lex();
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = mm_parse_readunit();
	asu64(R2) = mm_parse_fixcond(asu64(R2));
	R3 = 92;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L4647;
L4649:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	R2 = 17;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 63;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = q;
	R3 = 92;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	goto L4647;
L4650:
	asu64(R1) = p;
L4647:
	goto L4646;
L4646:
	return asu64(R1);
}

static u64 mm_parse_readif() {
    u64 R1, R2, R3, R4; 
	i64 pos1;
	i64 kwd;
	u64 clist;
	u64 clistx;
	u64 plist;
	u64 plistx;
	u64 pelse;
	u64 p;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos1 = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	mm_lex_lex();
	mm_parse_skipsemi();
	R1 = 0;
	R2 = R1;
	pelse = asu64(R2);
	R2 = R1;
	plistx = asu64(R2);
	R2 = R1;
	plist = asu64(R2);
	R2 = R1;
	clistx = asu64(R2);
	clist = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L4653;
	mm_lex_lex();
L4653:
	goto L4654;
L4655:
	mm_lex_lex();
// mm_parse.readif.nextif:
L4654:
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	R2 = (u64)&clistx;
	R3 = (u64)&clist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	mm_parse_skipsemi();
	R1 = 82;
	mm_parse_checksymbollex(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4659;
	asu64(R1) = clist;
	asu64(R2) = clistx;
	if (asu64(R1) != asu64(R2)) goto L4661;
	asi64(R1) = kwd;
	R2 = 81;
	if (asi64(R1) != asi64(R2)) goto L4661;
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = mm_parse_readunit();
	asu64(R3) = clist;
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos1;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L4651;
	goto L4660;
L4661:
	R1 = tou64("then: not allowed");
	mm_support_serror(asu64(R1));
L4660:
L4659:
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	R2 = (u64)&plistx;
	R3 = (u64)&plist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L4655;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L4663;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L4664;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L4664;
	goto L4665;
L4663:
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L4662;
L4664:
	asi64(R1) = kwd;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_parse_readswitchcase();
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	pelse = asu64(R1);
	goto L4662;
L4665:
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L4662:
	asu64(R1) = pelse;
	asu64(R2) = plist;
	asu64(R3) = clist;
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos1;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L4651;
L4651:
	return asu64(R1);
}

static u64 mm_parse_readgoto(i64 gototag) {
    u64 R1, R2; 
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asi64(R2) = gototag;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	goto L4666;
L4666:
	return asu64(R1);
}

static u64 mm_parse_readunless() {
    u64 R1, R2, R3, R4; 
	i64 pos;
	u64 pcond;
	u64 pthen;
	u64 pelse;
	u64 p;
	u64 q;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	pcond = asu64(R1);
	R1 = 82;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pthen = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) != asi64(R2)) goto L4669;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	goto L4668;
L4669:
	R1 = 0;
	pelse = asu64(R1);
L4668:
	R1 = 0;
	R2 = 0;
	R3 = 88;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pelse;
	asu64(R2) = pthen;
	asu64(R3) = pcond;
	R4 = 17;
	asu64(R3) = mm_lib_createunit1(asi64(R4), asu64(R3));
	R4 = R3;
	q = asu64(R4);
	R4 = 92;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 63;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L4667;
L4667:
	return asu64(R1);
}

static u64 mm_parse_readswitchcase() {
    u64 R1, R2, R3, R4; 
	i64 pos1;
	i64 kwd;
	i64 opc;
	i64 pos2;
	i64 rangeused;
	i64 nwhen;
	u64 pexpr;
	u64 pwhenlist;
	u64 pwhenlistx;
	u64 pwhen;
	u64 pwhenx;
	u64 pelse;
	u64 p;
	u64 pthen;
	u64 pwhenthen;
	u64 pjump;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos1 = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	R1 = 0;
	pjump = asu64(R1);
	mm_lex_lex();
	mm_parse_skipsemi();
	asi64(R1) = opc;
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L4672;
	R1 = 9;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	pjump = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 1;
	asu64(R2) = mm_decls_currproc;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 1;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L4672:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) != asi64(R2)) goto L4674;
	asi64(R1) = kwd;
	R2 = 104;
	if (asi64(R1) != asi64(R2)) goto L4676;
	R1 = tou64("switch expr missing");
	mm_support_serror(asu64(R1));
L4676:
	R1 = 0;
	pexpr = asu64(R1);
	goto L4673;
L4674:
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pexpr = asu64(R1);
	asu64(R1) = pjump;
	asu64(R2) = pexpr;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L4673:
	R1 = 0;
	R2 = R1;
	pwhenlistx = asu64(R2);
	pwhenlist = asu64(R1);
	R1 = 0;
	rangeused = asi64(R1);
	R1 = 0;
	nwhen = asi64(R1);
	mm_parse_skipsemi();
	goto L4678;
L4677:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos2 = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	pwhenx = asu64(R2);
	pwhen = asu64(R1);
L4680:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = (u64)&nwhen;
	(*toi64p(R1)) += 1;
	asi64(R1) = pos2;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L4683;
	R1 = 1;
	rangeused = asi64(R1);
L4683:
	asu64(R1) = p;
	R2 = (u64)&pwhenx;
	R3 = (u64)&pwhen;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4685;
	goto L4681;
L4685:
	mm_lex_lex();
	goto L4680;
L4681:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L4687;
	R1 = 82;
	mm_parse_checksymbol(asi64(R1));
L4687:
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pthen = asu64(R1);
	asu64(R1) = pthen;
	asu64(R2) = pwhen;
	R3 = 85;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	pwhenthen = asu64(R1);
	asi64(R1) = pos2;
	asu64(R2) = pwhenthen;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = pwhenthen;
	R2 = (u64)&pwhenlistx;
	R3 = (u64)&pwhenlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L4678:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L4677;
	asi64(R1) = opc;
	R2 = 107;
	if (asi64(R1) != asi64(R2)) goto L4689;
	asi64(R1) = rangeused;
	if (asi64(R1)) goto L4689;
	asi64(R1) = nwhen;
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L4691;
	R1 = 105;
	opc = asi64(R1);
L4691:
L4689:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L4693;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L4694;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L4695;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L4695;
	goto L4696;
L4693:
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L4692;
L4694:
	asi64(R1) = kwd;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_parse_readif();
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	pelse = asu64(R1);
	goto L4692;
L4695:
	asi64(R1) = kwd;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = mm_parse_readswitchcase();
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	pelse = asu64(R1);
	goto L4692;
L4696:
	R1 = 0;
	pelse = asu64(R1);
	R1 = 0;
	R2 = 0;
	asi64(R3) = kwd;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L4692:
	asu64(R1) = pelse;
	asu64(R2) = pwhenlist;
	asu64(R3) = pexpr;
	asi64(R4) = opc;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos1;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L4670;
L4670:
	return asu64(R1);
}

static u64 mm_parse_readstop() {
    u64 R1, R2, R3; 
	u64 p;
	i64 i;
	mm_lex_lex();
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4699;
	asu64(R1) = mm_parse_readunit();
	R2 = 120;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L4698;
L4699:
	R1 = 120;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
L4698:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	goto L4697;
L4697:
	return asu64(R1);
}

static u64 mm_parse_readreturn() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	mm_lex_lex();
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4702;
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 89;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L4701;
L4702:
	R1 = 89;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L4701:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	goto L4700;
L4700:
	return asu64(R1);
}

static u64 mm_parse_readdo() {
    u64 R1, R2, R3, R4; 
	u64 p;
	i64 pos;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	p = asu64(R1);
	R1 = 0;
	R2 = 0;
	R3 = 96;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 104;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L4703;
L4703:
	return asu64(R1);
}

static u64 mm_parse_readto() {
    u64 R1, R2, R3, R4; 
	i64 pos;
	i64 id;
	u64 p;
	u64 pcount;
	u64 pbody;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pcount = asu64(R1);
	R1 = 96;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	R2 = 96;
	R3 = 94;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	R1 = 11;
	id = asi64(R1);
	asu64(R1) = mm_decls_currproc;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L4706;
	R1 = 10;
	id = asi64(R1);
L4706:
	asi64(R1) = id;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_createname(asu64(R1));
	asu64(R2) = pbody;
	asu64(R3) = pcount;
	R4 = 91;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L4704;
L4704:
	return asu64(R1);
}

static u64 mm_parse_readwhile() {
    u64 R1, R2, R3, R4; 
	i64 pos;
	u64 pcond;
	u64 pbody;
	u64 pincr;
	u64 p;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 1;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	pcond = asu64(R1);
	R1 = 0;
	pincr = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4709;
	mm_lex_lex();
	R1 = 1;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pincr = asu64(R1);
L4709:
	R1 = 96;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	R2 = 96;
	R3 = 97;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pincr;
	asu64(R2) = pbody;
	asu64(R3) = pcond;
	R4 = 97;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L4707;
L4707:
	return asu64(R1);
}

static u64 mm_parse_readrepeat() {
    u64 R1, R2, R3; 
	i64 pos;
	u64 pbody;
	u64 pcond;
	u64 p;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 99;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	pcond = asu64(R1);
	asu64(R1) = pcond;
	asu64(R2) = pbody;
	R3 = 98;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L4710;
L4710:
	return asu64(R1);
}

static u64 mm_parse_readloopcontrol() {
    u64 R1, R2, R3; 
	i64 opc;
	u64 p;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L4713;
	R1 = tou64("all");
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4713;
	mm_lex_lex();
	R1 = 3;
	R2 = 0;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L4712;
L4713:
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L4714;
	R1 = 1;
	asu64(R1) = mm_parse_readconstexpr(asi64(R1));
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L4712;
L4714:
	R1 = 3;
	R2 = 1;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L4712:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	goto L4711;
L4711:
	return asu64(R1);
}

static u64 mm_parse_readprint() {
    u64 R1, R2, R3, R4; 
	i64 oldinreadprint;
	i64 opc;
	i64 isfprint;
	i64 fshowname;
	u64 pformat;
	u64 pdev;
	u64 printlist;
	u64 printlistx;
	u64 p;
	u64 q;
	u64 expr;
	u64 s;
	asi64(R1) = mm_parse_inreadprint;
	oldinreadprint = asi64(R1);
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	asi64(R1) = opc;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L4717;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L4717;
	goto L4718;
L4717:
	R1 = 1;
	isfprint = asi64(R1);
	goto L4716;
L4718:
	R1 = 0;
	isfprint = asi64(R1);
L4716:
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	printlistx = asu64(R2);
	printlist = asu64(R1);
	R1 = 0;
	R2 = R1;
	pdev = asu64(R2);
	pformat = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4720;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pdev = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4722;
	mm_lex_lex();
	goto L4721;
L4722:
	goto L4723;
L4721:
L4720:
	asi64(R1) = isfprint;
	if (!asi64(R1)) goto L4725;
	asu64(R1) = mm_parse_readunit();
	pformat = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4727;
	mm_lex_lex();
	goto L4726;
L4727:
	goto L4723;
L4726:
L4725:
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L4729;
	goto L4723;
L4729:
L4730:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4733;
	R2 = 130;
	if (asi64(R1) == asi64(R2)) goto L4734;
	goto L4735;
L4733:
	R1 = 87;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L4732;
L4734:
	R1 = 88;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	mm_lex_lex();
	goto L4732;
L4735:
	R1 = 0;
	fshowname = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4737;
	R1 = 1;
	fshowname = asi64(R1);
	mm_lex_lex();
L4737:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4739;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = p;
	R3 = 86;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L4739:
	asi64(R1) = fshowname;
	if (!asi64(R1)) goto L4741;
	asu64(R1) = p;
	asu64(R1) = mm_lib_strexpr(asu64(R1));
	expr = asu64(R1);
	R1 = -1;
	R2 = tou64("=");
	asu64(R3) = expr;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	asu64(R1) = expr;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	s = asu64(R1);
	asu64(R1) = expr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = expr;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mlib_iconvucn(asu64(R2), asi64(R1));
	asu64(R1) = expr;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = s;
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	R2 = R1;
	q = asu64(R2);
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L4741:
	asu64(R1) = p;
	R2 = (u64)&printlistx;
	R3 = (u64)&printlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L4732:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4743;
	goto L4731;
L4743:
	mm_lex_lex();
	goto L4730;
L4731:
// mm_parse.readprint.finish:
L4723:
	asi64(R1) = oldinreadprint;
	mm_parse_inreadprint = asi64(R1);
	asi64(R1) = opc;
	R2 = 114;
	if (asi64(R1) != asi64(R2)) goto L4745;
	asu64(R1) = printlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4745;
	R1 = tou64("No print items");
	mm_support_serror(asu64(R1));
L4745:
	asi64(R1) = opc;
	R2 = 116;
	if (asi64(R1) != asi64(R2)) goto L4747;
	asu64(R1) = printlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4747;
	asu64(R1) = pformat;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4747;
	R1 = tou64("No print items");
	mm_support_serror(asu64(R1));
L4747:
	asi64(R1) = isfprint;
	if (!asi64(R1)) goto L4749;
	asu64(R1) = pformat;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4751;
	R1 = tou64("No fmt str");
	mm_support_serror(asu64(R1));
L4751:
	asu64(R1) = printlist;
	asu64(R2) = pformat;
	asu64(R3) = pdev;
	asi64(R4) = opc;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	goto L4748;
L4749:
	asu64(R1) = printlist;
	asu64(R2) = pdev;
	asi64(R3) = opc;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
L4748:
	goto L4715;
L4715:
	return asu64(R1);
}

static u64 mm_parse_readread() {
    u64 R1, R2, R3; 
	i64 oldinreadprint;
	i64 opc;
	u64 pformat;
	u64 pdev;
	u64 readlist;
	u64 readlistx;
	u64 p;
	u64 pread;
	asi64(R1) = mm_parse_inreadprint;
	oldinreadprint = asi64(R1);
	R1 = 1;
	mm_parse_inreadprint = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	readlistx = asu64(R2);
	readlist = asu64(R1);
	R1 = 0;
	R2 = R1;
	pdev = asu64(R2);
	pformat = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4754;
	asi64(R1) = opc;
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L4756;
	R1 = tou64("@ on read");
	mm_support_serror(asu64(R1));
L4756:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pdev = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4758;
	mm_lex_lex();
L4758:
L4754:
	asi64(R1) = opc;
	R2 = 119;
	if (asi64(R1) != asi64(R2)) goto L4760;
	asu64(R1) = pdev;
	R2 = 119;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	R2 = (u64)&readlistx;
	R3 = (u64)&readlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
L4760:
	R1 = (u64)&mm_tables_exprstarter;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (asu8(R1)) goto L4762;
	goto L4763;
L4762:
L4764:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L4767;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pformat = asu64(R1);
	goto L4766;
L4767:
	R1 = 0;
	pformat = asu64(R1);
L4766:
	asu64(R1) = pformat;
	R2 = 118;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	pread = asu64(R1);
	asu64(R1) = pread;
	asu64(R2) = p;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = (u64)&readlistx;
	R3 = (u64)&readlist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4769;
	goto L4765;
L4769:
	mm_lex_lex();
	goto L4764;
L4765:
// mm_parse.readread.finish:
L4763:
	asi64(R1) = oldinreadprint;
	mm_parse_inreadprint = asi64(R1);
	asi64(R1) = opc;
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L4771;
	asu64(R1) = readlist;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4771;
	R1 = tou64("No read items");
	mm_support_serror(asu64(R1));
L4771:
	asu64(R1) = readlist;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L4752;
L4752:
	return asu64(R1);
}

static u64 mm_parse_readfor() {
    u64 R1, R2, R3, R4; 
	i64 pos;
	i64 opc;
	u64 pindex;
	u64 plocal;
	u64 pfrom;
	u64 pto;
	u64 pstep;
	u64 ptoinit;
	u64 plist;
	u64 passign;
	u64 pcond;
	u64 pbody;
	u64 pelse;
	u64 p;
	i64 i;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	plocal = asu64(R1);
	R1 = 0;
	ptoinit = asu64(R1);
	asu64(R1) = mm_parse_readname();
	pindex = asu64(R1);
	asi64(R1) = mm_parse_nforloops;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L4774;
	R1 = tou64("Too many for-loops");
	mm_support_serror(asu64(R1));
L4774:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_parse_nforloops;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4777;
L4775:
	R1 = (u64)&mm_parse_forindexvars;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	asu64(R2) = pindex;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	if (asu64(R1) != asu64(R2)) goto L4779;
	R1 = tou64("Re-using nested loop index");
	mm_support_serror(asu64(R1));
L4779:
	i += 1; if (i <= mm_parse_nforloops) goto L4775;
L4777:
	asu64(R1) = pindex;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_parse_forindexvars;
	R3 = (u64)&mm_parse_nforloops;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4781;
	mm_lex_lex();
	asu64(R1) = mm_parse_readname();
	plocal = asu64(R1);
L4781:
	R1 = 93;
	opc = asi64(R1);
	R1 = 0;
	pstep = asu64(R1);
	R1 = 0;
	pcond = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L4784;
	R2 = 46;
	if (asi64(R1) != asi64(R2)) goto L4783;
L4784:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 42;
	if (asi64(R1) != asi64(R2)) goto L4786;
	R1 = 94;
	opc = asi64(R1);
L4786:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	plist = asu64(R1);
	asu64(R1) = plist;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L4788;
	asu64(R1) = plist;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfrom = asu64(R1);
	asu64(R1) = plist;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	goto L4787;
L4788:
	asi64(R1) = opc;
	R2 = 93;
	if (asi64(R1) != asi64(R2)) goto L4790;
	R1 = 95;
	goto L4789;
L4790:
	R1 = 96;
L4789:
	opc = asi64(R1);
	R1 = 0;
	asu64(R2) = plist;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_getrangelwbunit(asu64(R1));
	pfrom = asu64(R1);
	R1 = 0;
	asu64(R2) = plist;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_getrangeupbunit(asu64(R1));
	pto = asu64(R1);
L4787:
	goto L4782;
L4783:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L4792;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pfrom = asu64(R1);
	goto L4791;
L4792:
	R1 = 3;
	R2 = 1;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	pfrom = asu64(R1);
L4791:
	R1 = 94;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4794;
	R1 = 94;
	goto L4793;
L4794:
	R1 = 93;
L4793:
	opc = asi64(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	pto = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 95;
	if (asi64(R1) != asi64(R2)) goto L4796;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readconstexpr(asi64(R1));
	pstep = asu64(R1);
	asu64(R1) = pstep;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4798;
	asu64(R1) = pstep;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4800;
	R1 = 0;
	pstep = asu64(R1);
L4800:
L4798:
L4796:
L4782:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) != asi64(R2)) goto L4802;
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R1) = mm_parse_fixcond(asu64(R1));
	pcond = asu64(R1);
L4802:
	R1 = 96;
	mm_parse_checksymbollex(asi64(R1));
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pbody = asu64(R1);
	R1 = 0;
	pelse = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) != asi64(R2)) goto L4804;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readsunit(asi64(R1));
	pelse = asu64(R1);
L4804:
	R1 = 0;
	R2 = 96;
	R3 = 93;
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pcond;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L4806;
	asu64(R1) = pbody;
	asu64(R2) = pcond;
	R3 = 92;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	asu64(R1) = mm_parse_makeblock(asu64(R1));
	pbody = asu64(R1);
L4806:
	asu64(R1) = pelse;
	asu64(R2) = pbody;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = opc;
	R2 = 93;
	if (asi64(R1) == asi64(R2)) goto L4808;
	R2 = 94;
	if (asi64(R1) == asi64(R2)) goto L4808;
	goto L4809;
L4808:
	asu64(R1) = plocal;
	if (!asu64(R1)) goto L4811;
	R1 = tou64("for i,x?");
	mm_support_serror(asu64(R1));
L4811:
	R1 = 73;
	asu64(R2) = pindex;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pto;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4813;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4813;
	R1 = 11;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_createname(asu64(R1));
	plocal = asu64(R1);
	R1 = 73;
	asu64(R2) = plocal;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pto;
	asu64(R2) = plocal;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	ptoinit = asu64(R1);
	asu64(R1) = ptoinit;
	asu64(R2) = pindex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = plocal;
	pto = asu64(R1);
L4813:
	asu64(R1) = pto;
	asu64(R2) = pfrom;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pstep;
	asu64(R2) = pto;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = pfrom;
	asu64(R3) = pindex;
	asi64(R4) = opc;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L4807;
L4809:
	asu64(R1) = plocal;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L4815;
	asu64(R1) = pindex;
	plocal = asu64(R1);
	R1 = 11;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	asu64(R1) = mm_lib_createname(asu64(R1));
	pindex = asu64(R1);
L4815:
	R1 = 73;
	asu64(R2) = pindex;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 76;
	asu64(R2) = plocal;
	R3 = 41;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = plocal;
	asu64(R2) = pindex;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pfrom;
	asu64(R2) = plocal;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pto;
	asu64(R2) = pfrom;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = pindex;
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = 0;
	asu64(R3) = plist;
	asu64(R2) = mm_lib_duplunit(asu64(R3), asi64(R2));
	R3 = 46;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	R2 = 0;
	asu64(R3) = plocal;
	asu64(R2) = mm_lib_duplunit(asu64(R3), asi64(R2));
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	passign = asu64(R1);
	asu64(R1) = passign;
	asu64(R2) = plist;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pbody;
	asu64(R2) = plist;
	asu64(R3) = pindex;
	asi64(R4) = opc;
	asu64(R1) = mm_lib_createunit3(asi64(R4), asu64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L4807:
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = (u64)&mm_parse_nforloops;
	(*toi64p(R1)) -=1;
	asu64(R1) = p;
	goto L4772;
L4772:
	return asu64(R1);
}

static u64 mm_parse_readname() {
    u64 R1, R2; 
	u64 p;
	asu64(R1) = mm_parse_readterm2();
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4818;
	R1 = tou64("Name expected");
	mm_support_serror(asu64(R1));
L4818:
	asu64(R1) = p;
	goto L4816;
L4816:
	return asu64(R1);
}

static void mm_parse_readtypedef(u64 owner, i64 scope) {
    u64 R1, R2, R3; 
	u64 sttype;
	u64 stname;
	i64 t;
	i64 m;
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stname = asu64(R1);
	mm_lex_lex();
	mm_parse_checkequals();
	mm_lex_lex();
	R1 = 5;
	asu64(R2) = stname;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	sttype = asu64(R1);
	asu64(R1) = sttype;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = sttype;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	m = asi64(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttusercat;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	asu64(R2) = sttype;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	asi64(R1) = scope;
	asu64(R2) = sttype;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = sttype;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = t;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4821;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_ttisreal;
	asi64(R3) = t;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	if (!asi64(R1)) goto L4823;
	asi64(R1) = t;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	goto L4822;
L4823:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4824;
	goto L4822;
L4824:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4826;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4827;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L4828;
	goto L4829;
L4826:
	goto L4825;
L4827:
	goto L4825;
L4828:
	goto L4825;
L4829:
	asi64(R1) = t;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L4825:
L4822:
	goto L4820;
L4821:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	R1 += (i64)R2*4;
	asi64(R2) = t;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
L4820:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L4831;
	asi64(R1) = t;
	asi64(R2) = m;
	mm_lib_copyttvalues(asi64(R2), asi64(R1));
	goto L4830;
L4831:
	R1 = 29;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L4830:
	return;
}

static void mm_parse_readrecordfields(u64 owner, i64 m) {
    u64 R1, R2, R3; 
	i64 nvars;
	i64 offset;
	u64 stname;
	u64 stbitfield;
	R1 = 0;
	nvars = asi64(R1);
	goto L4834;
L4833:
	R1 = 13;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = m;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	R1 = (u64)&nvars;
	(*toi64p(R1)) += 1;
	R1 = (u64)&mm_parse_unionpend;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4837;
	R1 = (u64)&mm_parse_unionpend;
	asu64(R2) = stname;
	R3 = 136;
	R2 += (i64)R3;
	mm_lib_unionstr_copy(asu64(R2), asu64(R1));
	R1 = (u64)&mm_parse_unionpend;
	R2 = (u64)&mm_parse_unionstring;
	mm_lib_unionstr_concat(asu64(R2), asu64(R1));
	R1 = (u64)&mm_parse_unionpend;
	mm_lib_unionstr_clear(asu64(R1));
	goto L4836;
L4837:
	asu64(R1) = stname;
	R2 = 136;
	R1 += (i64)R2;
	mm_lib_unionstr_clear(asu64(R1));
L4836:
	asu64(R1) = stname;
	mm_parse_unionlastvar = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L4839;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4840;
	goto L4841;
L4839:
	mm_lex_lex();
	R1 = 1;
	asu64(R2) = stname;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 7;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = owner;
	asu64(R1) = mm_parse_readequivfield(asu64(R1));
	asu64(R2) = stname;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) != asi64(R2)) goto L4843;
	mm_lex_lex();
	asi64(R1) = mm_parse_readconstint();
	offset = asi64(R1);
	asi64(R1) = offset;
	R2 = 9223372036854775807;
	if (asi64(R1) <= asi64(R2)) goto L4845;
	R1 = tou64("Offset>255");
	mm_support_serror(asu64(R1));
L4845:
	asi64(R1) = offset;
	asu64(R2) = stname;
	R3 = 151;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L4843:
	goto L4838;
L4840:
	R1 = 9;
	mm_parse_lexchecksymbol(asi64(R1));
L4846:
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = 13;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stbitfield = asu64(R1);
	R1 = 27;
	asu64(R2) = stbitfield;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = stbitfield;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	R1 = 1;
	asu64(R2) = stbitfield;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 7;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = stname;
	asu64(R2) = stbitfield;
	R3 = 128;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 5;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = 62;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = stbitfield;
	R3 = 148;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4846;
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	goto L4838;
L4841:
L4838:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4850;
	goto L4835;
L4850:
	mm_lex_lex();
L4834:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4833;
L4835:
	asi64(R1) = nvars;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4852;
	R1 = tou64("No fields declared");
	mm_support_serror(asu64(R1));
L4852:
	return;
}

static void mm_parse_readtabledef(u64 owner, i64 scope) {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 ncols;
	i64 nrows;
	i64 enums;
	i64 nextenumvalue;
	i64 firstval;
	i64 lastval;
	i64 startline;
	i64 closesym;
	i64 ltype;
	u64 stvar;
	u64 stenum;
	u64 stgen;
	struct $B30 varnameptrs;
	struct $B30 varlisttypes;
	struct $B30 plist;
	struct $B30 plistx;
	struct $B78 enumvalues;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	enums = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	mm_parse_tabledataname = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4855;
	asi64(R1) = enums;
	if (asi64(R1)) goto L4857;
	R1 = tou64("Use 'enumdata'");
	mm_support_serror(asu64(R1));
L4857:
	R1 = 1;
	enums = asi64(R1);
	mm_lex_lex();
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
L4855:
	R1 = 1;
	nextenumvalue = asi64(R1);
	R1 = 0;
	nrows = asi64(R1);
	R1 = 0;
	ncols = asi64(R1);
	goto L4859;
L4858:
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	ltype = asi64(R1);
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&ncols;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 20;
	if (asi64(R1) <= asi64(R2)) goto L4862;
	R1 = tou64("tabledata/too many columns");
	mm_support_serror(asu64(R1));
L4862:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&varnameptrs;
	asi64(R3) = ncols;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asi64(R1) = ltype;
	R2 = (u64)&varlisttypes;
	asi64(R3) = ncols;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4864;
	mm_lex_lex();
	goto L4863;
L4864:
	goto L4860;
L4863:
L4859:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4858;
L4860:
	mm_lex_lex();
	mm_parse_skipsemi();
	asi64(R1) = mm_parse_getcurrline();
	startline = asi64(R1);
	R1 = 0;
	asi64(R1) = mm_parse_checkbegin(asi64(R1));
	closesym = asi64(R1);
	mm_parse_skipsemi();
	R1 = 0;
	R2 = R1;
	lastval = asi64(R2);
	firstval = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4867;
L4865:
	R1 = 0;
	R2 = R1;
	R3 = (u64)&plistx;
	asi64(R4) = i;
	*tou64p(((i64)R3+(i64)R4*8-8)) = asu64(R2);
	R2 = (u64)&plist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= ncols) goto L4865;
L4867:
	R1 = 1;
	mm_parse_intabledata = asi64(R1);
L4868:
	mm_parse_skipsemi();
	asi64(R1) = ncols;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L4871;
	R1 = 9;
	mm_parse_checksymbollex(asi64(R1));
L4871:
	R1 = (u64)&nrows;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 500;
	if (asi64(R1) <= asi64(R2)) goto L4873;
	R1 = tou64("tabledata:too many rows");
	mm_support_serror(asu64(R1));
L4873:
	asi64(R1) = enums;
	if (!asi64(R1)) goto L4875;
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stgen = asu64(R1);
	asu64(R1) = stgen;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_parse_tabledataname = asu64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) != asi64(R2)) goto L4877;
	asi64(R1) = nrows;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L4879;
	R1 = tou64("enum=x, 1st row only");
	mm_support_serror(asu64(R1));
L4879:
	mm_lex_lex();
	asi64(R1) = mm_parse_readconstint();
	nextenumvalue = asi64(R1);
L4877:
	asi64(R1) = nextenumvalue;
	R2 = (u64)&enumvalues;
	asi64(R3) = nrows;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 9;
	asu64(R2) = stgen;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stenum = asu64(R1);
	R1 = 3;
	asu64(R2) = stenum;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 3;
	asi64(R2) = nextenumvalue;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = stenum;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stenum;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stenum;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asi64(R1) = scope;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L4881;
	asu64(R1) = stenum;
	mm_lib_addexpconst(asu64(R1));
L4881:
	asi64(R1) = nrows;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L4883;
	asi64(R1) = nextenumvalue;
	firstval = asi64(R1);
L4883:
	asi64(R1) = nextenumvalue;
	lastval = asi64(R1);
	R1 = (u64)&nextenumvalue;
	(*toi64p(R1)) += 1;
	asi64(R1) = ncols;
	if (!asi64(R1)) goto L4885;
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
L4885:
L4875:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4888;
L4886:
	asu64(R1) = mm_parse_readunit();
	R2 = (u64)&plistx;
	asi64(R3) = i;
	R2 += (i64)R3*8-8;
	R3 = (u64)&plist;
	asi64(R4) = i;
	R3 += (i64)R4*8-8;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = i;
	asi64(R2) = ncols;
	if (asi64(R1) != asi64(R2)) goto L4890;
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	goto L4889;
L4890:
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
L4889:
	i += 1; if (i <= ncols) goto L4886;
L4888:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L4892;
	goto L4869;
L4892:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asi64(R2) = closesym;
	if (asi64(R1) != asi64(R2)) goto L4894;
	goto L4869;
L4894:
	goto L4868;
L4869:
	R1 = 0;
	mm_parse_intabledata = asi64(R1);
	mm_parse_skipsemi();
	asi64(R1) = startline;
	R2 = 132;
	asi64(R3) = closesym;
	mm_parse_checkbeginend(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = nrows;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4896;
	R1 = tou64("No table data");
	mm_support_serror(asu64(R1));
L4896:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = ncols;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4899;
L4897:
	R1 = 10;
	R2 = (u64)&varnameptrs;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stvar = asu64(R1);
	R1 = (u64)&plist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 20;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	asu64(R2) = stvar;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = nrows;
	asu64(R2) = stvar;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = stvar;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 9;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = stvar;
	R2 = 72;
	R1 += (i64)R2;
	R2 = (u64)&varlisttypes;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = scope;
	asu64(R2) = stvar;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stvar;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stvar;
	mm_lib_addstatic(asu64(R1));
	i += 1; if (i <= ncols) goto L4897;
L4899:
	return;
}

static void mm_parse_readclassdef(u64 owner, i64 scope) {
    u64 R1, R2, R3; 
	i64 kwd;
	i64 baseclass;
	i64 m;
	i64 startline;
	i64 closesym;
	i64 mrec;
	i64 isrecord;
	i64 align;
	u64 nameptr;
	u64 sttype;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	asi64(R1) = kwd;
	R2 = 111;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	isrecord = asi64(R1);
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nameptr = asu64(R1);
	mm_lex_lex();
	R1 = 0;
	baseclass = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4902;
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	baseclass = asi64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
L4902:
	mm_parse_checkequals();
	mm_lex_lex();
	R1 = 0;
	align = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L4904;
	mm_lex_lex();
	R1 = 1;
	align = asi64(R1);
L4904:
	R1 = 5;
	asu64(R2) = nameptr;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	sttype = asu64(R1);
	asu64(R1) = sttype;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = sttype;
	asi64(R1) = mm_lib_createusertype(asu64(R1));
	m = asi64(R1);
	asi64(R1) = m;
	asu64(R2) = owner;
	asi64(R1) = mm_lib_createrecordmode(asu64(R2), asi64(R1));
	mrec = asi64(R1);
	asu64(R1) = sttype;
	R2 = 72;
	R1 += (i64)R2;
	asi64(R2) = mrec;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asu64(R1) = sttype;
	R2 = 144;
	R1 += (i64)R2;
	asi64(R2) = baseclass;
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = align;
	asu64(R2) = sttype;
	R3 = 149;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asi64(R1) = mm_parse_checkbegin(asi64(R1));
	closesym = asi64(R1);
	asi64(R1) = mm_parse_getcurrline();
	startline = asi64(R1);
	asi64(R1) = kwd;
	asu64(R2) = sttype;
	mm_parse_readclassbody(asu64(R2), asi64(R1));
	asi64(R1) = startline;
	asi64(R2) = kwd;
	asi64(R3) = closesym;
	mm_parse_checkbeginend(asi64(R3), asi64(R2), asi64(R1));
	asi64(R1) = scope;
	asu64(R2) = sttype;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_parse_readclassbody(u64 owner, i64 classkwd) {
    u64 R1, R2, R3, R4; 
	i64 kwd;
	i64 t;
	i64 lbcount;
	R1 = 0;
	lbcount = asi64(R1);
	R1 = (u64)&mm_parse_unionstring;
	mm_lib_unionstr_clear(asu64(R1));
	R1 = (u64)&mm_parse_unionpend;
	mm_lib_unionstr_clear(asu64(R1));
L4906:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L4908;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L4909;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L4909;
	R2 = 111;
	if (asi64(R1) == asi64(R2)) goto L4910;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L4911;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L4912;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L4913;
	R2 = 132;
	if (asi64(R1) == asi64(R2)) goto L4914;
	R2 = 122;
	if (asi64(R1) == asi64(R2)) goto L4915;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L4916;
	R2 = 113;
	if (asi64(R1) == asi64(R2)) goto L4916;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L4917;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4917;
	R2 = 119;
	if (asi64(R1) == asi64(R2)) goto L4918;
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L4919;
	goto L4920;
L4908:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readconstdef(asu64(R2), asi64(R1));
	goto L4906;
L4909:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	asu64(R1) = owner;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L4922;
	R1 = 0;
	asu64(R2) = owner;
	asu64(R1) = mm_parse_readprocdecl(asu64(R2), asi64(R1));
	goto L4921;
L4922:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readprocdef(asu64(R2), asi64(R1));
L4921:
	goto L4906;
L4910:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readclassdef(asu64(R2), asi64(R1));
	goto L4906;
L4911:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readtypedef(asu64(R2), asi64(R1));
	goto L4906;
L4912:
	R1 = tou64("Class eof?");
	mm_support_serror(asu64(R1));
	goto L4907;
	goto L4906;
L4913:
	mm_lex_lex();
	goto L4906;
L4914:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readtabledef(asu64(R2), asi64(R1));
	goto L4906;
L4915:
	R1 = 0;
	asu64(R2) = owner;
	mm_parse_readmacrodef(asu64(R2), asi64(R1));
	goto L4906;
L4916:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 112;
	if (asi64(R1) != asi64(R2)) goto L4924;
	R1 = 83;
	goto L4923;
L4924:
	R1 = 85;
L4923:
	R2 = (u64)&mm_parse_unionpend;
	mm_lib_unionstr_append(asu64(R2), asi64(R1));
	R1 = 0;
	mm_parse_unionlastvar = asu64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4926;
	R1 = (u64)&lbcount;
	(*toi64p(R1)) += 1;
	mm_lex_lex();
L4926:
	goto L4906;
L4917:
	R1 = (u64)&mm_parse_unionstring;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4928;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L4930;
	asi64(R1) = lbcount;
	if (!asi64(R1)) goto L4930;
	mm_lex_lex();
	R1 = (u64)&lbcount;
	(*toi64p(R1)) -=1;
	goto L4929;
L4930:
	R1 = 0;
	R2 = 0;
	R3 = (u64)&mm_parse_unionstring;
	asi64(R3) = mm_lib_unionstr_last(asu64(R3));
	R4 = 83;
	if (asi64(R3) != asi64(R4)) goto L4932;
	R3 = 112;
	goto L4931;
L4932:
	R3 = 113;
L4931:
	R4 = 87;
	mm_parse_checkend(asi64(R4), asi64(R3), asi64(R2), asi64(R1));
L4929:
	asu64(R1) = mm_parse_unionlastvar;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L4935;
	R1 = (u64)&mm_parse_unionpend;
	R2 = 7;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L4934;
L4935:
	R1 = tou64("Empty union group");
	mm_support_serror(asu64(R1));
L4934:
	asu64(R1) = mm_parse_unionlastvar;
	R2 = 136;
	R1 += (i64)R2;
	asi64(R1) = mm_lib_unionstr_last(asu64(R1));
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L4937;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L4937;
	goto L4938;
L4937:
	goto L4936;
L4938:
	R1 = 42;
	asu64(R2) = mm_parse_unionlastvar;
	R3 = 136;
	R2 += (i64)R3;
	mm_lib_unionstr_append(asu64(R2), asi64(R1));
L4936:
	R1 = 69;
	asu64(R2) = mm_parse_unionlastvar;
	R3 = 136;
	R2 += (i64)R3;
	mm_lib_unionstr_append(asu64(R2), asi64(R1));
	R1 = (u64)&mm_parse_unionstring;
	R2 = 7;
	R1 += (i64)R2;
	(*tou8p(R1)) -=1;
	goto L4927;
L4928:
	goto L4907;
L4927:
	goto L4906;
L4918:
	mm_lex_lex();
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L4940;
// mm_parse.readclassbody.readmut:
L4941:
	R1 = (u64)&mm_parse_insiderecord;
	(*toi64p(R1)) += 1;
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	t = asi64(R1);
	R1 = (u64)&mm_parse_insiderecord;
	(*toi64p(R1)) -=1;
	goto L4939;
L4940:
	R1 = 22;
	t = asi64(R1);
L4939:
	asi64(R1) = t;
	asu64(R2) = owner;
	mm_parse_readrecordfields(asu64(R2), asi64(R1));
	goto L4906;
L4919:
	R1 = tou64("Let not allowed");
	mm_support_serror(asu64(R1));
	goto L4906;
L4920:
	asi64(R1) = mm_parse_istypestarter();
	if (!asi64(R1)) goto L4943;
	goto L4941;
	goto L4942;
L4943:
	goto L4907;
L4942:
	goto L4906;
L4907:
	asi64(R1) = lbcount;
	if (!asi64(R1)) goto L4945;
	R1 = tou64("LB?");
	mm_support_serror(asu64(R1));
L4945:
	return;
}

static void mm_parse_readimportmodule(u64 owner) {
    u64 R1, R2, R3; 
	i64 isnew;
	i64 startline;
	i64 closesym;
	u64 stname;
	u64 stname0;
	i64 i;
	asi64(R1) = mm_parse_insidedllimport;
	if (!asi64(R1)) goto L4948;
	R1 = tou64("nested importdll");
	mm_support_serror(asu64(R1));
L4948:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 65;
	if (asi64(R1) != asi64(R2)) goto L4950;
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lex_addnamestr(asu64(R1));
	stname = asu64(R1);
	goto L4949;
L4950:
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	stname = asu64(R1);
L4949:
	mm_lex_lex();
	mm_parse_checkequals();
	mm_lex_lex();
	R1 = 1;
	isnew = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nlibfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L4953;
L4951:
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_libfiles;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4955;
	R1 = 0;
	isnew = asi64(R1);
	goto L4953;
L4955:
	i += 1; if (i <= mm_decls_nlibfiles) goto L4951;
L4953:
	asi64(R1) = isnew;
	if (!asi64(R1)) goto L4957;
	asu64(R1) = stname;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_modules_addlib(asu64(R1));
L4957:
	asi64(R1) = mm_parse_getcurrline();
	startline = asi64(R1);
	R1 = 0;
	asi64(R1) = mm_parse_checkbegin(asi64(R1));
	closesym = asi64(R1);
	R1 = 1;
	mm_parse_insidedllimport = asi64(R1);
	asu64(R1) = owner;
	mm_parse_readimportbody(asu64(R1));
	R1 = 0;
	mm_parse_insidedllimport = asi64(R1);
	asi64(R1) = startline;
	R2 = 114;
	asi64(R3) = closesym;
	mm_parse_checkbeginend(asi64(R3), asi64(R2), asi64(R1));
	return;
}

static void mm_parse_readimportbody(u64 owner) {
    u64 R1, R2, R3, R4, R5; 
	i64 pos;
	u64 d;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
L4959:
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L4962;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L4962;
	R2 = 116;
	if (asi64(R1) == asi64(R2)) goto L4963;
	R2 = 123;
	if (asi64(R1) == asi64(R2)) goto L4964;
	R2 = 111;
	if (asi64(R1) == asi64(R2)) goto L4965;
	R2 = 119;
	if (asi64(R1) == asi64(R2)) goto L4966;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L4967;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L4967;
	R2 = 117;
	if (asi64(R1) == asi64(R2)) goto L4967;
	R2 = 80;
	if (asi64(R1) == asi64(R2)) goto L4967;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L4967;
	R2 = 121;
	if (asi64(R1) == asi64(R2)) goto L4967;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L4968;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L4969;
	goto L4970;
L4962:
// mm_parse.readimportbody.doproc:
	R1 = 0;
	asu64(R2) = owner;
	asu64(R1) = mm_parse_readprocdecl(asu64(R2), asi64(R1));
	d = asu64(R1);
	asi64(R1) = mm_decls_ndllproctable;
	R2 = 1000;
	if (asi64(R1) < asi64(R2)) goto L4973;
	R1 = tou64("Too many dll procs");
	mm_support_serror(asu64(R1));
L4973:
	asu64(R1) = d;
	R2 = (u64)&mm_decls_dllproctable;
	R3 = (u64)&mm_decls_ndllproctable;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L4961;
L4963:
	R1 = 1;
	asu64(R2) = owner;
	mm_parse_readtypedef(asu64(R2), asi64(R1));
	goto L4961;
L4964:
	R1 = 1;
	asu64(R2) = owner;
	mm_parse_readconstdef(asu64(R2), asi64(R1));
	goto L4961;
L4965:
	R1 = 1;
	asu64(R2) = owner;
	mm_parse_readclassdef(asu64(R2), asi64(R1));
	goto L4961;
L4966:
	mm_lex_lex();
	R1 = 119;
	R2 = 8;
	R3 = 0;
	R4 = 1;
	asu64(R5) = owner;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L4961;
L4967:
	R1 = 0;
	R2 = 8;
	R3 = 0;
	R4 = 1;
	asu64(R5) = owner;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L4961;
L4968:
	goto L4960;
	goto L4961;
L4969:
	goto L4960;
	goto L4961;
L4970:
	R1 = tou64("symbol");
	mm_lex_ps(asu64(R1));
	R1 = tou64("Not allowed in importmodule");
	mm_support_serror(asu64(R1));
L4961:
	goto L4959;
L4960:
	return;
}

static u64 mm_parse_readequivfield(u64 owner) {
    u64 R1, R2, R3; 
	u64 p;
	u64 d;
	R1 = 67;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	mm_lex_lex();
	asu64(R1) = owner;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	goto L4976;
L4975:
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L4979;
	asu64(R1) = p;
	goto L4974;
L4979:
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L4976:
	asu64(R1) = p;
	if (asu64(R1)) goto L4975;
	msysc_m$print_startcon();
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Can't find @ field");
	mm_support_serror(asu64(R1));
	R1 = 0;
	goto L4974;
L4974:
	return asu64(R1);
}

static i64 mm_parse_readrefproc(u64 owner, i64 typedefx) {
    u64 R1, R2, R3, R4, R5, R6; 
	i64 kwd;
	i64 prettype;
	i64 m;
	i64 varparams;
	i64 nparams;
	struct $B18 retmodes;
	u64 paramlist;
	u64 stproc;
	i64 rettype2;
	i64 rettype3;
	i64 nretvalues;
	u64 name;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	kwd = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	paramlist = asu64(R1);
	R1 = 0;
	prettype = asi64(R1);
	R1 = 0;
	nretvalues = asi64(R1);
	R1 = 0;
	varparams = asi64(R1);
	asu64(R1) = mm_lib_nextautotype();
	name = asu64(R1);
	R1 = 5;
	asu64(R2) = name;
	asu64(R2) = mm_lex_addnamestr(asu64(R2));
	asu64(R3) = mm_decls_stmodule;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stproc = asu64(R1);
	asu64(R1) = stproc;
	asu64(R2) = mm_decls_stmodule;
	mm_lib_adddef(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&retmodes;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	asi64(R1) = kwd;
	R2 = 109;
	if (asi64(R1) != asi64(R2)) goto L4982;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4984;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L4986;
	R1 = (u64)&nparams;
	R2 = (u64)&varparams;
	asu64(R3) = stproc;
	asu64(R4) = owner;
	asu64(R1) = mm_parse_readparams(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	paramlist = asu64(R1);
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
L4986:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4989;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L4988;
L4989:
	mm_lex_lex();
	R1 = (u64)&retmodes;
	asu64(R2) = stproc;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
	goto L4987;
L4988:
	R1 = (u64)&mm_decls_typestarterset;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L4991;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L4990;
L4991:
	R1 = (u64)&retmodes;
	asu64(R2) = stproc;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
L4990:
L4987:
	goto L4983;
L4984:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L4993;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L4992;
L4993:
	mm_lex_lex();
	R1 = (u64)&retmodes;
	asu64(R2) = stproc;
	asi64(R1) = mm_parse_readreturntype(asu64(R2), asu64(R1));
	nretvalues = asi64(R1);
L4992:
L4983:
	asi64(R1) = nretvalues;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L4995;
	R1 = tou64("Function needs return type");
	mm_support_serror(asu64(R1));
L4995:
	asi64(R1) = nretvalues;
	if (!asi64(R1)) goto L4997;
	asi64(R1) = kwd;
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L4997;
	R1 = tou64("Proc can't return value");
	mm_support_serror(asu64(R1));
L4997:
	goto L4981;
L4982:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L4999;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5001;
	R1 = (u64)&nparams;
	R2 = (u64)&varparams;
	asu64(R3) = stproc;
	asu64(R4) = owner;
	asu64(R1) = mm_parse_readparams(asu64(R4), asu64(R3), asu64(R2), asu64(R1));
	paramlist = asu64(R1);
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
L5001:
	mm_lex_lex();
L4999:
	R1 = (u64)&mm_decls_typestarterset;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5004;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5004;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5003;
L5004:
	R1 = tou64("proc can't have ret value");
	mm_support_serror(asu64(R1));
L5003:
L4981:
	asi64(R1) = typedefx;
	asi64(R2) = prettype;
	asi64(R3) = kwd;
	asu64(R4) = paramlist;
	asu64(R5) = stproc;
	asu64(R6) = owner;
	asi64(R1) = mm_lib_createrefprocmode(asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	m = asi64(R1);
	asu64(R1) = stproc;
	R2 = 72;
	R1 += (i64)R2;
	R2 = (u64)&retmodes;
	R3 = 1;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R3) = owner;
	asi64(R1) = mm_lib_storemode(asu64(R3), asi64(R2), asu64(R1));
	asi64(R1) = nretvalues;
	asu64(R2) = stproc;
	R3 = 122;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = stproc;
	R2 = (u64)&mm_decls_ttnamedef;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = varparams;
	asu64(R2) = stproc;
	R3 = 123;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	goto L4980;
L4980:
	return asi64(R1);
}

static void mm_parse_pushproc(u64 p) {
    u64 R1, R2, R3; 
	asi64(R1) = mm_parse_nprocstack;
	R2 = 10;
	if (asi64(R1) < asi64(R2)) goto L5007;
	R1 = tou64("Too many nested proc");
	mm_support_serror(asu64(R1));
L5007:
	asu64(R1) = mm_decls_currproc;
	R2 = (u64)&mm_parse_procstack;
	R3 = (u64)&mm_parse_nprocstack;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = p;
	mm_decls_currproc = asu64(R1);
	return;
}

static void mm_parse_popproc() {
    u64 R1, R2, R3; 
	asi64(R1) = mm_parse_nprocstack;
	if (!asi64(R1)) goto L5010;
	R1 = (u64)&mm_parse_procstack;
	R2 = (u64)&mm_parse_nprocstack;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) -= 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	mm_decls_currproc = asu64(R1);
	goto L5009;
L5010:
	asu64(R1) = mm_decls_stmodule;
	mm_decls_currproc = asu64(R1);
L5009:
	return;
}

static i64 mm_parse_readreturntype(u64 owner, u64 retmodes) {
    u64 R1, R2, R3; 
	i64 nretvalues;
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	asu64(R2) = retmodes;
	R3 = 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
	R1 = 1;
	nretvalues = asi64(R1);
	goto L5013;
L5012:
	asi64(R1) = nretvalues;
	R2 = 4;
	if (asi64(R1) < asi64(R2)) goto L5016;
	R1 = tou64("Too many return values");
	mm_support_serror(asu64(R1));
L5016:
	mm_lex_lex();
	R1 = 0;
	asu64(R2) = owner;
	asi64(R1) = mm_parse_readtypespec(asu64(R2), asi64(R1));
	asu64(R2) = retmodes;
	R3 = (u64)&nretvalues;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L5013:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5012;
	asi64(R1) = nretvalues;
	goto L5011;
L5011:
	return asi64(R1);
}

static u64 mm_parse_readset() {
    u64 R1, R2, R3; 
	i64 length;
	i64 nkeyvalues;
	i64 oldirp;
	u64 p;
	u64 ulist;
	u64 ulistx;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5019;
	goto L5020;
L5019:
	mm_lex_lex();
	R1 = 0;
	R2 = 22;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L5017;
	goto L5018;
L5020:
L5018:
	R1 = 0;
	length = asi64(R1);
	R1 = 0;
	nkeyvalues = asi64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L5021:
	asi64(R1) = mm_parse_inreadprint;
	oldirp = asi64(R1);
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	asi64(R1) = oldirp;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L5024;
	R1 = (u64)&nkeyvalues;
	(*toi64p(R1)) += 1;
L5024:
	R1 = (u64)&length;
	(*toi64p(R1)) += 1;
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5026;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5027;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5028;
	goto L5029;
L5026:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5031;
	goto L5022;
L5031:
	goto L5025;
L5027:
	R1 = 12;
	mm_parse_lexchecksymbol(asi64(R1));
	goto L5022;
	goto L5025;
L5028:
	goto L5022;
	goto L5025;
L5029:
	R1 = tou64("readset?");
	mm_support_serror(asu64(R1));
L5025:
	mm_parse_skipsemi();
	goto L5021;
L5022:
	mm_lex_lex();
	asi64(R1) = nkeyvalues;
	if (!asi64(R1)) goto L5033;
	asi64(R1) = length;
	asi64(R2) = nkeyvalues;
	if (asi64(R1) <= asi64(R2)) goto L5035;
	R1 = tou64("dict: mixed elements");
	mm_support_serror(asu64(R1));
L5035:
	asu64(R1) = ulist;
	R2 = 23;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L5032;
L5033:
	asu64(R1) = ulist;
	R2 = 22;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L5032:
	asi64(R1) = length;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L5017;
L5017:
	return asu64(R1);
}

static i64 mm_parse_istypestarter() {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_decls_typestarterset;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5038;
	R1 = 1;
	goto L5036;
L5038:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L5040;
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5042;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5043;
	goto L5044;
L5042:
	R1 = 1;
	goto L5036;
	goto L5041;
L5043:
	R1 = 1;
	goto L5036;
	goto L5041;
L5044:
L5041:
L5040:
	R1 = 0;
	goto L5036;
L5036:
	return asi64(R1);
}

static u64 mm_parse_readunit() {
    u64 R1, R2, R3; 
	u64 p;
	u64 pt;
	i64 pos;
	R1 = 0;
	pt = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	asu64(R1) = mm_parse_readterm2();
	pt = asu64(R1);
	R1 = (u64)&mm_tables_jisexpr;
	asu64(R2) = pt;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5047;
	asu64(R1) = pt;
	goto L5045;
L5047:
	R1 = (u64)&mm_tables_endsexpr;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L5049;
	asu64(R1) = pt;
	goto L5045;
L5049:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5051;
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	p = asu64(R1);
	R1 = (u64)&mm_tables_endsexpr;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	if (!asu8(R1)) goto L5053;
	asu64(R1) = p;
	asu64(R2) = pt;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L5045;
L5053:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	asu64(R2) = pt;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L5050;
L5051:
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L5050:
	goto L5055;
L5054:
	mm_lex_lex();
	asu64(R1) = p;
	R2 = 0;
	asu64(R2) = mm_parse_readassignment(asu64(R2));
	R3 = 32;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L5055:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5054;
	asu64(R1) = p;
	goto L5045;
L5045:
	return asu64(R1);
}

static u64 mm_parse_readassignment(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 opc;
	u64 q;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readorterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	opc = asi64(R2);
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5059;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 28;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L5059:
	asu64(R1) = p;
	goto L5057;
L5057:
	return asu64(R1);
}

static u64 mm_parse_readorterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readandterms(asu64(R1));
	p = asu64(R1);
	goto L5062;
L5061:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5065;
	R1 = tou64("OR:=");
	mm_support_serror(asu64(R1));
L5065:
	R1 = 0;
	asu64(R1) = mm_parse_readandterms(asu64(R1));
	asu64(R2) = p;
	R3 = 16;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L5062:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 39;
	if (asi64(R1) == asi64(R2)) goto L5061;
	asu64(R1) = p;
	goto L5060;
L5060:
	return asu64(R1);
}

static u64 mm_parse_readandterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readcmpterms(asu64(R1));
	p = asu64(R1);
	goto L5068;
L5067:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5071;
	R1 = tou64("AND:=");
	mm_support_serror(asu64(R1));
L5071:
	R1 = 0;
	asu64(R1) = mm_parse_readcmpterms(asu64(R1));
	asu64(R2) = p;
	R3 = 15;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L5068:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 38;
	if (asi64(R1) == asi64(R2)) goto L5067;
	asu64(R1) = p;
	goto L5066;
L5066:
	return asu64(R1);
}

static u64 mm_parse_readcmpterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 opc;
	i64 n;
	u64 ulist;
	u64 ulistx;
	u64 q;
	u32 genops;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readinterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L5074;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L5074;
	asu64(R1) = p;
	goto L5072;
L5074:
	asu64(R1) = p;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
	asu64(R1) = p;
	R2 = 34;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = (u64)&genops;
	memset(R1, 0, 4);
L5075:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 41;
	if (asi64(R1) == asi64(R2)) goto L5077;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L5077;
	goto L5078;
L5077:
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	asi64(R1) = n;
	R2 = 4;
	if (asi64(R1) <= asi64(R2)) goto L5080;
	R1 = tou64("cmpchain: Too many items");
	mm_support_serror(asu64(R1));
L5080:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R2 = (u64)&genops;
	asi64(R3) = n;
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readinterms(asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = pos;
	asu64(R2) = q;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L5075;
L5078:
	goto L5076;
	goto L5075;
L5076:
	asi64(R1) = n;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5082;
	R1 = 33;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = (u64)&genops;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 64;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5081;
L5082:
	asu32(R1) = genops;
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L5081:
	asu64(R1) = p;
	goto L5072;
L5072:
	return asu64(R1);
}

static u64 mm_parse_readinterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 opc;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readrangeterm(asu64(R1));
	p = asu64(R1);
L5084:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L5086;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L5086;
	goto L5087;
L5086:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readrangeterm(asu64(R1));
	asu64(R2) = p;
	R3 = 41;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L5084;
L5087:
	goto L5085;
	goto L5084;
L5085:
	asu64(R1) = p;
	goto L5083;
L5083:
	return asu64(R1);
}

static u64 mm_parse_readrangeterm(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 opc;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readaddterms(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L5090;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readaddterms(asu64(R1));
	asu64(R2) = p;
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L5090:
	asu64(R1) = p;
	goto L5088;
L5088:
	return asu64(R1);
}

static u64 mm_parse_readaddterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 sym;
	i64 tag;
	i64 genop;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readmulterms(asu64(R1));
	p = asu64(R1);
L5092:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	sym = asi64(R2);
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L5094;
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L5094;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L5094;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L5094;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L5094;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L5094;
	R2 = 37;
	if (asi64(R1) == asi64(R2)) goto L5094;
	goto L5095;
L5094:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	genop = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5097;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	asu64(R2) = p;
	R3 = 38;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgentoops;
	asi64(R2) = sym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L5093;
L5097:
	R1 = 0;
	asu64(R1) = mm_parse_readmulterms(asu64(R1));
	asu64(R2) = p;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgenops;
	asi64(R2) = sym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L5092;
L5095:
	goto L5093;
	goto L5092;
L5093:
	asu64(R1) = p;
	goto L5091;
L5091:
	return asu64(R1);
}

static u64 mm_parse_readmulterms(u64 pt) {
    u64 R1, R2, R3; 
	u64 p;
	i64 pos;
	i64 sym;
	asu64(R1) = pt;
	asu64(R1) = mm_parse_readpowerterms(asu64(R1));
	p = asu64(R1);
L5099:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = R1;
	sym = asi64(R2);
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L5101;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L5101;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5101;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L5101;
	R2 = 34;
	if (asi64(R1) == asi64(R2)) goto L5101;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L5101;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L5101;
	goto L5102;
L5101:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5104;
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readassignment(asu64(R1));
	asu64(R2) = p;
	R3 = 38;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgentoops;
	asi64(R2) = sym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L5100;
L5104:
	R1 = 0;
	asu64(R1) = mm_parse_readpowerterms(asu64(R1));
	asu64(R2) = p;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_tables_symbolgenops;
	asi64(R2) = sym;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L5099;
L5102:
	goto L5100;
	goto L5099;
L5100:
	asu64(R1) = p;
	goto L5098;
L5098:
	return asu64(R1);
}

static u64 mm_parse_readpowerterms(u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5107;
	asu64(R1) = mm_parse_readterm2();
	p = asu64(R1);
L5107:
	goto L5109;
L5108:
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	mm_lex_lex();
	R1 = 0;
	asu64(R1) = mm_parse_readpowerterms(asu64(R1));
	asu64(R2) = p;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 82;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
L5109:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L5108;
	asu64(R1) = p;
	goto L5105;
L5105:
	return asu64(R1);
}

static u64 mm_parse_readterm2() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 r;
	u64 pbyte;
	u64 a;
	i64 oldipl;
	i64 opc;
	i64 oldinrp;
	i64 pos;
	i64 shift;
	i64 t;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	asu64(R1) = mm_parse_readterm();
	p = asu64(R1);
L5112:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5114;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5115;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5116;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5117;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5118;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L5119;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5120;
	goto L5121;
L5114:
	mm_lex_lex();
	asi64(R1) = mm_parse_inreadprint;
	oldinrp = asi64(R1);
	R1 = 0;
	mm_parse_inreadprint = asi64(R1);
	R1 = 1;
	R2 = 1;
	asu64(R1) = mm_parse_readslist(asi64(R2), asi64(R1));
	q = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 90;
	if (asi64(R1) != asi64(R2)) goto L5123;
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5122;
L5123:
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 32;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
L5122:
	asi64(R1) = oldinrp;
	mm_parse_inreadprint = asi64(R1);
	asu64(R1) = p;
	asu64(R1) = mm_parse_readcondsuffix(asu64(R1));
	p = asu64(R1);
	goto L5112;
L5115:
	asu64(R1) = p;
	R2 = 53;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	mm_lex_lex();
	goto L5112;
L5116:
	R1 = 0;
	asu64(R2) = p;
	asu64(R1) = mm_parse_readindex(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L5112;
L5117:
	asu64(R1) = p;
	asu64(R1) = mm_parse_readdotsuffix(asu64(R1));
	p = asu64(R1);
	goto L5112;
L5118:
	asi64(R1) = mm_parse_inreadprint;
	if (!asi64(R1)) goto L5125;
	goto L5113;
L5125:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	asu64(R1) = q;
	asu64(R2) = p;
	asi64(R3) = mm_parse_inparamlist;
	if (!asi64(R3)) goto L5127;
	R3 = 26;
	goto L5126;
L5127:
	R3 = 27;
L5126:
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L5112;
L5119:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L5129;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L5130;
	goto L5131;
L5129:
	R1 = 88;
	opc = asi64(R1);
	goto L5128;
L5130:
	R1 = 89;
	opc = asi64(R1);
	goto L5128;
L5131:
L5128:
	mm_lex_lex();
	asu64(R1) = p;
	R2 = 40;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5112;
L5120:
	R1 = tou64("X{...} not ready");
	mm_support_serror(asu64(R1));
	goto L5112;
L5121:
	goto L5113;
	goto L5112;
L5113:
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L5111;
L5111:
	return asu64(R1);
}

static u64 mm_parse_readterm() {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 r;
	u64 a;
	i64 opc;
	i64 pos;
	i64 length;
	u8 strtype;
	u64 s;
	struct $B16 cstr;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 2: goto L5162;
	case 3: case 4: case 5: case 6: case 7: case 8: case 10: case 12: case 14: case 15: case 16: case 17: case 18: case 21: case 22: case 23: case 26: case 27: case 28: case 29: case 30: case 34: case 35: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 54: case 57: case 58: case 59: case 60: case 66: case 68: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 82: case 83: case 84: case 85: case 86: case 87: case 92: case 95: case 99: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 118: case 119: case 120: case 122: case 123: case 125: case 126: case 127: case 132: goto L5135;
	case 9: goto L5146;
	case 11: goto L5155;
	case 13: goto L5200;
	case 19: case 20: goto L5157;
	case 24: case 25: case 31: case 32: case 33: case 36: case 37: case 49: case 50: case 51: case 52: case 53: case 55: case 56: goto L5148;
	case 47: goto L5149;
	case 48: goto L5152;
	case 61: goto L5156;
	case 62: case 63: goto L5139;
	case 64: goto L5141;
	case 65: goto L5140;
	case 67: goto L5136;
	case 69: goto L5198;
	case 79: case 80: case 117: goto L5147;
	case 81: goto L5178;
	case 88: goto L5179;
	case 89: case 90: case 104: case 105: goto L5180;
	case 91: goto L5181;
	case 93: goto L5182;
	case 94: goto L5183;
	case 96: goto L5184;
	case 97: goto L5185;
	case 98: goto L5186;
	case 100: goto L5188;
	case 101: goto L5189;
	case 102: goto L5187;
	case 103: goto L5177;
	case 106: goto L5190;
	case 107: goto L5191;
	case 121: goto L5201;
	case 124: goto L5199;
	case 128: goto L5173;
	case 129: goto L5163;
	case 130: goto L5164;
	case 131: goto L5193;
	case 133: goto L5174;
	case 134: goto L5192;
	case 135: goto L5194;
	case 136: goto L5197;
	default: goto L5135;
    };
// SWITCH
L5136:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L5138;
	asu64(R1) = mm_parse_readcast();
	p = asu64(R1);
	goto L5137;
L5138:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R1) = mm_lib_createname(asu64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	mm_lex_lex();
L5137:
	goto L5133;
L5139:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	goto L5133;
L5140:
	R1 = (u64)&mm_decls_lx;
	R2 = 2;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	mm_lex_lex();
	goto L5133;
L5141:
	R1 = (u64)&mm_decls_lx;
	R2 = 2;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 1;
	asi64(R1) -= asi64(R2);
	length = asi64(R1);
	asi64(R1) = length;
	R2 = 8;
	if (asi64(R1) <= asi64(R2)) goto L5143;
	R1 = tou64("Char const too long");
	mm_support_serror(asu64(R1));
L5143:
	R1 = 0;
	a = asu64(R1);
	asi64(R1) = length;
	if (!asi64(R1)) goto L5145;
	asi64(R1) = length;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = (u64)&a;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
L5145:
	R1 = 5;
	asu64(R2) = a;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	mm_lex_lex();
	goto L5133;
L5146:
	asu64(R1) = mm_parse_readlbrack();
	p = asu64(R1);
	goto L5133;
L5147:
	asu64(R1) = mm_parse_readcast();
	p = asu64(R1);
	goto L5133;
L5148:
	asu64(R1) = mm_parse_readopc();
	p = asu64(R1);
	goto L5133;
L5149:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5151;
	asu64(R1) = mm_parse_readopc();
	p = asu64(R1);
	goto L5150;
L5151:
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 17;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 63;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5150:
	goto L5133;
L5152:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5154;
	asu64(R1) = mm_parse_readopc();
	p = asu64(R1);
	goto L5153;
L5154:
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 18;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
L5153:
	goto L5133;
L5155:
	asu64(R1) = mm_parse_readset();
	p = asu64(R1);
	goto L5133;
L5156:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 40;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5133;
L5157:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	asi64(R2) = opc;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 32;
	if (asi64(R1) != asi64(R2)) goto L5159;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5161;
	R1 = tou64("Params not allowed");
	mm_support_serror(asu64(R1));
L5161:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5159:
	goto L5133;
L5162:
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 56;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L5133;
L5163:
	asu64(R1) = mm_parse_readcompilervar();
	p = asu64(R1);
	goto L5133;
L5164:
	asi64(R1) = mm_parse_intabledata;
	if (!asi64(R1)) goto L5166;
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5168;
	R1 = 0;
	R2 = (u64)&cstr;
	R3 = 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = mm_parse_tabledataname;
	R2 = (u64)&cstr;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 4;
	R2 = (u64)&cstr;
	R3 = 1;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	goto L5167;
L5168:
	asu64(R1) = mm_parse_tabledataname;
	s = asu64(R1);
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) != asi64(R2)) goto L5170;
	mm_lex_lex();
	mm_lex_lex();
	R1 = 62;
	mm_parse_checksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&s;
	*tou64p(R2) += asu64(R1);
L5170:
	R1 = -1;
	asu64(R2) = s;
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
L5167:
	goto L5165;
L5166:
	asi64(R1) = mm_parse_ndollar;
	R2 = 0;
	if (asi64(R1) > asi64(R2)) goto L5172;
	R1 = tou64("[$] No array");
	mm_support_serror(asu64(R1));
L5172:
	R1 = (u64)&mm_parse_dollarstack;
	asi64(R2) = mm_parse_ndollar;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = 36;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5165:
	mm_lex_lex();
	goto L5133;
L5173:
	asu64(R1) = mm_parse_readcastx();
	p = asu64(R1);
	goto L5133;
L5174:
	R1 = 9;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5176;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L5176;
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5175;
L5176:
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	r = asu64(R1);
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
L5175:
	mm_lex_lex();
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	q = asu64(R1);
	R1 = 56;
	asu64(R2) = q;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = r;
	asu64(R2) = q;
	R3 = 35;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 55;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5133;
L5177:
	R1 = 99;
	asu64(R1) = mm_parse_readgoto(asi64(R1));
	p = asu64(R1);
	goto L5133;
L5178:
	asu64(R1) = mm_parse_readif();
	p = asu64(R1);
	goto L5133;
L5179:
	asu64(R1) = mm_parse_readunless();
	p = asu64(R1);
	goto L5133;
L5180:
	asu64(R1) = mm_parse_readswitchcase();
	p = asu64(R1);
	goto L5133;
L5181:
	asu64(R1) = mm_parse_readrecase();
	p = asu64(R1);
	goto L5133;
L5182:
	asu64(R1) = mm_parse_readfor();
	p = asu64(R1);
	goto L5133;
L5183:
	asu64(R1) = mm_parse_readto();
	p = asu64(R1);
	goto L5133;
L5184:
	asu64(R1) = mm_parse_readdo();
	p = asu64(R1);
	goto L5133;
L5185:
	asu64(R1) = mm_parse_readwhile();
	p = asu64(R1);
	goto L5133;
L5186:
	asu64(R1) = mm_parse_readrepeat();
	p = asu64(R1);
	goto L5133;
L5187:
	asu64(R1) = mm_parse_readloopcontrol();
	p = asu64(R1);
	goto L5133;
L5188:
	asu64(R1) = mm_parse_readreturn();
	p = asu64(R1);
	goto L5133;
L5189:
	asu64(R1) = mm_parse_readstop();
	p = asu64(R1);
	goto L5133;
L5190:
	asu64(R1) = mm_parse_readprint();
	p = asu64(R1);
	goto L5133;
L5191:
	asu64(R1) = mm_parse_readread();
	p = asu64(R1);
	goto L5133;
L5192:
	R1 = 9;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 111;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L5133;
L5193:
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	R2 = 121;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L5133;
L5194:
	R1 = 1;
	asu64(R2) = mm_decls_currproc;
	R3 = 120;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	mm_decls_assemmode = asi64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5196;
	asu64(R1) = mm_assem_dummy_readassemline();
	p = asu64(R1);
	goto L5195;
L5196:
	asu64(R1) = mm_assem_dummy_readassemblock();
	p = asu64(R1);
L5195:
	R1 = 0;
	mm_decls_assemmode = asi64(R1);
	goto L5133;
L5197:
	R1 = 90;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = p;
	R3 = 40;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	mm_lex_lex();
	goto L5133;
L5198:
	R1 = (u64)&mm_decls_lx;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	strtype = asu8(R1);
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 13;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	asu8(R1) = strtype;
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5133;
L5199:
	mm_lex_lex();
	asu64(R1) = mm_parse_readterm2();
	R2 = 122;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	goto L5133;
L5200:
	R1 = tou64("{...} not ready");
	mm_support_serror(asu64(R1));
	goto L5133;
L5201:
	R1 = 9;
	mm_parse_lexchecksymbol(asi64(R1));
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = mm_parse_readunit();
	q = asu64(R1);
	R1 = 10;
	mm_parse_checksymbollex(asi64(R1));
	asu64(R1) = q;
	asu64(R2) = p;
	R3 = 24;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	p = asu64(R1);
	goto L5133;
L5135:
// mm_parse.readterm.doelse:
	msysc_m$print_startcon();
	R1 = (u64)&mm_tables_symbolnames;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("LX.SYMBOL=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = mm_parse_istypestarter();
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("readterm?");
	mm_support_serror(asu64(R1));
L5133:
	asi64(R1) = pos;
	asu64(R2) = p;
	R3 = 4;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	goto L5132;
L5132:
	return asu64(R1);
}

static void mm_parse_readmacrodef(u64 owner, i64 scope) {
    u64 R1, R2, R3; 
	u64 nameptr;
	u64 stmacro;
	u64 paramlist;
	u64 paramlistx;
	u64 stname;
	R1 = 67;
	mm_parse_lexchecksymbol(asi64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	nameptr = asu64(R1);
	R1 = 15;
	asu64(R2) = nameptr;
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stmacro = asu64(R1);
	asu64(R1) = stmacro;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stmacro;
	owner = asu64(R1);
	mm_lex_lex();
	R1 = 0;
	R2 = R1;
	paramlistx = asu64(R2);
	paramlist = asu64(R1);
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L5205;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5207;
L5208:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5211;
	goto L5212;
L5211:
	R1 = 16;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = owner;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = owner;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stname;
	R2 = (u64)&paramlistx;
	R3 = (u64)&paramlist;
	mm_parse_addlistparam(asu64(R3), asu64(R2), asu64(R1));
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5214;
	goto L5209;
L5214:
	R1 = 3;
	mm_parse_checksymbollex(asi64(R1));
	goto L5210;
L5212:
	R1 = tou64("macro def params");
	mm_support_serror(asu64(R1));
L5210:
	goto L5208;
L5209:
L5207:
	mm_lex_lex();
L5205:
	asu64(R1) = paramlist;
	asu64(R2) = stmacro;
	R3 = 112;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = scope;
	asu64(R2) = stmacro;
	R3 = 170;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	mm_parse_checkequals();
	mm_lex_lex();
	asu64(R1) = mm_parse_readunit();
	asu64(R2) = stmacro;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static u64 mm_parse_readrecase() {
    u64 R1, R2; 
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) != asi64(R2)) goto L5217;
	mm_lex_lex();
	R1 = 113;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	goto L5216;
L5217:
	asu64(R1) = mm_parse_readunit();
	R2 = 113;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
L5216:
	goto L5215;
L5215:
	return asu64(R1);
}

static u64 mm_parse_fixcond(u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	mm_parse_checknotempty(asu64(R1));
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5220;
	R1 = 18;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
L5220:
	asu64(R1) = p;
	goto L5218;
L5218:
	return asu64(R1);
}

static u64 mm_parse_readsunit(i64 inwhile) {
    u64 R1, R2, R3, R4, R5; 
	i64 pos;
	i64 m;
	i64 sym;
	i64 opc;
	u64 ulist;
	u64 ulistx;
	u64 p;
	u64 q;
	u64 r;
	u64 stname;
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	R1 = 0;
	R2 = R1;
	ulistx = asu64(R2);
	ulist = asu64(R1);
L5222:
	goto L5226;
L5225:
	mm_lex_lex();
L5226:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5225;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 4: goto L5261;
	case 5: case 6: case 7: case 8: case 9: case 12: case 13: case 14: case 15: case 16: case 17: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 81: case 88: case 89: case 90: case 91: case 93: case 94: case 95: case 97: case 98: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 110: case 112: case 113: case 114: case 115: case 118: case 124: case 125: case 126: case 128: case 129: case 130: case 131: goto L5230;
	case 10: case 82: case 83: case 84: case 85: case 86: case 87: case 92: case 99: goto L5252;
	case 11: case 79: case 80: case 117: case 121: goto L5236;
	case 18: goto L5262;
	case 59: goto L5251;
	case 67: goto L5253;
	case 96: goto L5258;
	case 108: case 109: goto L5235;
	case 111: goto L5248;
	case 116: goto L5246;
	case 119: case 120: goto L5242;
	case 122: goto L5249;
	case 123: goto L5247;
	case 127: goto L5231;
	case 132: goto L5250;
	default: goto L5230;
    };
// SWITCH
L5231:
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 120;
	if (asi64(R1) == asi64(R2)) goto L5234;
	R2 = 119;
	if (asi64(R1) != asi64(R2)) goto L5233;
L5234:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	opc = asi64(R1);
	mm_lex_lex();
	goto L5232;
L5233:
	R1 = 0;
	opc = asi64(R1);
L5232:
	asi64(R1) = opc;
	R2 = 10;
	R3 = 1;
	R4 = 0;
	asu64(R5) = mm_decls_currproc;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	goto L5228;
L5235:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readprocdef(asu64(R2), asi64(R1));
	goto L5228;
L5236:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5239;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5239;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5238;
L5239:
	goto L5240;
	goto L5237;
L5238:
	R1 = 0;
	sym = asi64(R1);
	goto L5241;
L5237:
	goto L5228;
L5242:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	sym = asi64(R1);
	mm_lex_lex();
// mm_parse.readsunit.dovar:
L5241:
	asi64(R1) = sym;
	R2 = 11;
	R3 = 0;
	R4 = 0;
	asu64(R5) = mm_decls_currproc;
	asu64(R1) = mm_parse_readvardef(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	q = asu64(R1);
	goto L5244;
L5243:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = r;
	q = asu64(R1);
L5244:
	asu64(R1) = q;
	if (asu64(R1)) goto L5243;
	goto L5228;
L5246:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readtypedef(asu64(R2), asi64(R1));
	goto L5228;
L5247:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readconstdef(asu64(R2), asi64(R1));
	goto L5228;
L5248:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readclassdef(asu64(R2), asi64(R1));
	goto L5228;
L5249:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readmacrodef(asu64(R2), asi64(R1));
	goto L5228;
L5250:
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	mm_parse_readtabledef(asu64(R2), asi64(R1));
	goto L5228;
L5251:
	msysc_m$print_startcon();
	asu64(R1) = mm_decls_currproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = tou64("Unexpected EOF in proc");
	mm_support_serror(asu64(R1));
	goto L5228;
L5252:
	goto L5224;
	goto L5228;
L5253:
	R1 = (u64)&mm_decls_nextlx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5255;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5256;
	goto L5257;
L5255:
	R1 = 100;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	p = asu64(R1);
	R1 = 14;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = mm_decls_currproc;
	asu64(R1) = mm_lib_getduplnameptr(asu64(R3), asu64(R2), asi64(R1));
	stname = asu64(R1);
	asu64(R1) = stname;
	asu64(R2) = mm_decls_currproc;
	mm_lib_adddef(asu64(R2), asu64(R1));
	asu64(R1) = stname;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	mm_lex_lex();
	R1 = 4;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	goto L5254;
L5256:
	R1 = 119;
	sym = asi64(R1);
	goto L5241;
	goto L5240;
	goto L5254;
L5257:
	goto L5240;
L5254:
	goto L5228;
L5258:
	asi64(R1) = inwhile;
	if (!asi64(R1)) goto L5260;
	goto L5224;
L5260:
	goto L5240;
	goto L5228;
L5261:
	goto L5228;
L5262:
	R1 = -1;
	R2 = (u64)&mm_decls_lx;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	R2 = 14;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	p = asu64(R1);
	R1 = 4;
	R2 = (u64)&mm_decls_lx;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5263;
	goto L5228;
L5230:
// mm_parse.readsunit.doexec:
L5240:
	asu64(R1) = mm_parse_readunit();
	p = asu64(R1);
// mm_parse.readsunit.doexec2:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L5266;
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 67;
	if (asi64(R1) != asi64(R2)) goto L5266;
	R1 = tou64("Possibly var/let needed");
	mm_support_serror(asu64(R1));
L5266:
// mm_parse.readsunit.doexec3:
L5263:
	asu64(R1) = p;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 96;
	if (asi64(R1) != asi64(R2)) goto L5268;
	goto L5224;
L5268:
L5228:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5222;
L5224:
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5270;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L5270;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L5270;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L5270;
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L5270;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L5270;
	R2 = 96;
	if (asi64(R1) == asi64(R2)) goto L5270;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L5270;
	R2 = 86;
	if (asi64(R1) == asi64(R2)) goto L5270;
	R2 = 87;
	if (asi64(R1) == asi64(R2)) goto L5270;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5270;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L5270;
	goto L5271;
L5270:
	goto L5269;
L5271:
	R1 = tou64("Readsunit: \";\" expected, or bad unit starter");
	mm_support_serror(asu64(R1));
L5269:
	asu64(R1) = ulist;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5274;
	asu64(R1) = ulist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5273;
L5274:
	asu64(R1) = ulist;
	R2 = 6;
	asu64(R1) = mm_lib_createunit1(asi64(R2), asu64(R1));
	goto L5272;
L5273:
	asu64(R1) = ulist;
L5272:
	goto L5221;
L5221:
	return asu64(R1);
}

static u64 mm_parse_readbxdata() {
    u64 R1, R2, R3; 
	u64 p;
	i64 curralloc;
	i64 n;
	u64 q;
	u64 r;
	u64 qnew;
	R1 = 4;
	curralloc = asi64(R1);
	R1 = 0;
	n = asi64(R1);
	R1 = 0;
	p = asu64(R1);
	asi64(R1) = curralloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	r = asu64(R2);
	q = asu64(R1);
L5276:
	mm_lex_lex();
	mm_parse_skipsemi();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L5279;
	goto L5277;
L5279:
	asi64(R1) = n;
	asi64(R2) = curralloc;
	if (asi64(R1) != asi64(R2)) goto L5281;
	R1 = 2;
	R2 = (u64)&curralloc;
	*toi64p(R2) *= asi64(R1);
	asi64(R1) = curralloc;
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	qnew = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R3) = qnew;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = qnew;
	asu64(R2) = r;
	asu64(R3) = q;
	asi64(R2) -= asi64(R3);
	R1 += (i64)R2;
	r = asu64(R1);
	asi64(R1) = n;
	asu64(R2) = q;
	mlib_pcm_free(asu64(R2), asi64(R1));
	asu64(R1) = qnew;
	q = asu64(R1);
L5281:
	R1 = (u64)&mm_decls_lx;
	R2 = 8;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&r;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	*tou8p(R2) = asu8(R1);
	R1 = (u64)&n;
	(*toi64p(R1)) += 1;
	mm_lex_lex();
	R1 = (u64)&mm_decls_lx;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5283;
	goto L5277;
L5283:
	goto L5276;
L5277:
	R1 = 10;
	mm_parse_checksymbol(asi64(R1));
	mm_lex_lex();
	asi64(R1) = n;
	asu64(R2) = q;
	asu64(R1) = mm_lib_createstringconstunit(asu64(R2), asi64(R1));
	p = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	goto L5275;
L5275:
	return asu64(R1);
}

static void mm_parse_checknotempty(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5287;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5286;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5286;
L5287:
	R1 = tou64("Empty sunit");
	mm_support_serror(asu64(R1));
L5286:
	return;
}

static u64 mm_support_newsourcefile() {
    u64 R1, R2, R3; 
	u64 pf;
	R1 = 68;
	asu64(R1) = mlib_pcm_allocz(asi64(R1));
	pf = asu64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 300;
	if (asi64(R1) < asi64(R2)) goto L5290;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("Too many sources");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5290:
	asu64(R1) = pf;
	R2 = (u64)&mm_decls_sources;
	R3 = (u64)&mm_decls_nsourcefiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	asu64(R2) = pf;
	R3 = 64;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asu64(R1) = pf;
	goto L5288;
L5288:
	return asu64(R1);
}

static void mm_support_mcerror(u64 mess) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("MC Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void mm_support_serror_gen(u64 mess) {
    u64 R1, R2, R3, R4, R5; 
	R1 = 42;
	mm_support_showdivider(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("Syntax Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = mm_decls_currproc;
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	mm_support_showerrorsource(asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asi64(R1) = mm_support_getlineno(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	R3 = (u64)&mm_decls_lx;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	R4 = 24;
	R5 = 31;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void mm_support_showdivider(u64 ch) {
    u64 R1, R2; 
	i64 av_1;
	R1 = 87;
	av_1 = asi64(R1);
L5294:
	msysc_m$print_startcon();
	R1 = 0;
	asu64(R2) = ch;
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
	if (--asi64(av_1)) goto L5294;
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	return;
}

static void mm_support_showerrorsource(i64 pos, u64 stproc) {
    u64 R1, R2, R3; 
	i64 fileno;
	i64 lineoffset;
	u64 errorline;
	u64 s;
	i64 av_1;
	i64 av_2;
	i64 av_3;
	asi64(R1) = pos;
	asi64(R1) = mm_support_getfileno(asu64(R1));
	fileno = asi64(R1);
	msysc_m$print_startcon();
	R1 = tou64("    Line:     #");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = pos;
	asi64(R1) = mm_support_getlineno(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = stproc;
	if (!asu64(R1)) goto L5299;
	asu64(R1) = stproc;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5299;
	msysc_m$print_startcon();
	R1 = tou64("    Function: #()");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = stproc;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5299:
	msysc_m$print_startcon();
	R1 = tou64("    Module:   # (#)");
	msysc_m$print_setfmt(asu64(R1));
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 45;
	mm_support_showdivider(asu64(R1));
	asi64(R1) = pos;
	asu64(R1) = mm_support_getsourceline(asu64(R1));
	R2 = R1;
	errorline = asu64(R2);
	s = asu64(R1);
	asi64(R1) = pos;
	asu64(R1) = mm_support_getsourcepos(asu64(R1));
	asu64(R2) = errorline;
	asi64(R1) -= asi64(R2);
	lineoffset = asi64(R1);
	R1 = 6;
	av_1 = asi64(R1);
L5300:
	msysc_m$print_startcon();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_1)) goto L5300;
	goto L5304;
L5303:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = (u64)&s;
	asu64(R3) = *tou64p(R2); *(tou64p(R2)) += 1; asu64(R2) = asu64(R3);
	asu8(R2) = *tou8p(R2);
	R2 = tou64(tou8(R2));
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
L5304:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5306;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5303;
L5306:
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = errorline;
	s = asu64(R1);
	R1 = 6;
	av_2 = asi64(R1);
L5307:
	msysc_m$print_startcon();
	R1 = tou64(" ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	if (--asi64(av_2)) goto L5307;
	asi64(R1) = lineoffset;
	av_3 = asi64(R1);
	asi64(R1) = av_3;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L5312;
L5310:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L5314;
	msysc_m$print_startcon();
	R1 = 0;
	R2 = 9;
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
	goto L5313;
L5314:
	msysc_m$print_startcon();
	R1 = 0;
	R2 = 32;
	msysc_m$print_c8(asu64(R2), asi64(R1));
	msysc_m$print_end();
L5313:
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
	if (--asi64(av_3)) goto L5310;
L5312:
	msysc_m$print_startcon();
	R1 = tou64("^");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 45;
	mm_support_showdivider(asu64(R1));
	return;
}

static void mm_support_stopcompiler(u64 filename, i64 lineno) {
    u64 R1, R2; 
	u64 f;
	R1 = tou64("w");
	R2 = tou64("$error.tmp");
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = lineno;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	msysc_m$print_startcon();
	R1 = tou64("PRESS key");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = mwindows_os_getch();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void mm_support_serror(u64 mess) {
    u64 R1; 
	asu64(R1) = mess;
	mm_support_serror_gen(asu64(R1));
	return;
}

static void mm_support_serror_s(u64 mess, u64 a) {
    u64 R1; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = (u64)&str;
	mm_support_serror_gen(asu64(R1));
	return;
}

static void mm_support_error_gen(i64 pass, u64 mess, u64 p) {
    u64 R1, R2, R3; 
	i64 pos;
	asu64(R1) = p;
	if (!asu64(R1)) goto L5320;
	msysc_m$print_startcon();
	R1 = tou64("P.POS");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pos = asi64(R1);
	goto L5319;
L5320:
	msysc_m$print_startcon();
	R1 = tou64("MMPOS");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = pc_decls_mmpos;
	pos = asi64(R1);
L5319:
	msysc_m$print_startcon();
	R1 = tou64("GETFILENO(POS)=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = pos;
	asi64(R1) = mm_support_getfileno(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 42;
	mm_support_showdivider(asu64(R1));
	asi64(R1) = pass;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L5322;
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L5323;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L5324;
	R2 = 65;
	if (asi64(R1) == asi64(R2)) goto L5325;
	goto L5326;
L5322:
	msysc_m$print_startcon();
	R1 = tou64("RX Name Error: ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L5321;
L5323:
	msysc_m$print_startcon();
	R1 = tou64("TX Type Error: ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L5321;
L5324:
	msysc_m$print_startcon();
	R1 = tou64("GX Code Gen Error: ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L5321;
L5325:
	msysc_m$print_startcon();
	R1 = tou64("AX Code Gen Error: ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L5321;
L5326:
L5321:
	asu64(R1) = mm_decls_currproc;
	asi64(R2) = pos;
	mm_support_showerrorsource(asi64(R2), asu64(R1));
	msysc_m$print_startcon();
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asi64(R1) = pos;
	asi64(R1) = mm_support_getlineno(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	asi64(R3) = pos;
	asi64(R3) = mm_support_getfileno(asu64(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void mm_support_rxerror(u64 mess, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = mess;
	R3 = 78;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_gerror(u64 mess, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = mess;
	R3 = 71;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_txerror(u64 mess, u64 p) {
    u64 R1, R2, R3; 
	asu64(R1) = p;
	asu64(R2) = mess;
	R3 = 84;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_txerror_s(u64 mess, u64 a, u64 p) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = (u64)&str;
	R3 = 84;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_txerror_ss(u64 mess, u64 a, u64 b) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = b;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	R1 = 0;
	R2 = (u64)&str;
	R3 = 84;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_rxerror_s(u64 mess, u64 a, u64 p) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = a;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = (u64)&str;
	R3 = 78;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_gerror_s(u64 mess, u64 s, u64 p) {
    u64 R1, R2, R3; 
	struct $B16 str;
	R1 = (u64)&str;
	msysc_m$print_startstr(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = s;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
	asu64(R1) = p;
	R2 = (u64)&str;
	R3 = 71;
	mm_support_error_gen(asi64(R3), asu64(R2), asu64(R1));
	return;
}

static void mm_support_lxerror_gen(u64 mess) {
    u64 R1, R2, R3, R4, R5; 
	msysc_m$print_startcon();
	R1 = tou64("On line");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asi64(R1) = mm_support_getlineno(asu64(R1));
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("in file");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_decls_sources;
	R2 = (u64)&mm_decls_lx;
	R3 = 4;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	R3 = 24;
	R4 = 31;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("**** Lex Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("****");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = (u64)&mm_decls_lx;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = tou64(tou32(R1));
	asi64(R1) = mm_support_getlineno(asu64(R1));
	R2 = (u64)&mm_decls_sources;
	R3 = (u64)&mm_decls_lx;
	R4 = 4;
	asu32(R3) = *tou32p(((i64)R3+(i64)R4));
	R3 = toi64(tou32(R3));
	R4 = 24;
	R5 = 31;
    asi64(R3) = Getdotslice((u64)R3, (i64)R4, (i64)R5);
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_support_stopcompiler(asu64(R2), asi64(R1));
	return;
}

static void mm_support_lxerror(u64 mess) {
    u64 R1; 
	asu64(R1) = mess;
	mm_support_lxerror_gen(asu64(R1));
	return;
}

static void mm_support_loaderror(u64 mess, u64 mess2, u64 mess3) {
    u64 R1; 
	msysc_m$print_startcon();
	R1 = tou64("Load Error:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess2;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = mess3;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Stopping");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	exit(R1);
	return;
}

static void mm_support_gs_additem(u64 dest, u64 s) {
    u64 R1, R2, R3; 
	u64 d;
	i64 lastchar;
	i64 nextchar;
	asu64(R1) = dest;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = dest;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5339;
	asu64(R1) = d;
	asu64(R2) = dest;
	R3 = 8;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R1 += (i64)R2;
	R2 = 1;
	R1 -= (i64)R2;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	lastchar = asi64(R1);
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	nextchar = asi64(R1);
	asi64(R1) = lastchar;
	asi64(R1) = mm_support_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L5341;
	asi64(R1) = nextchar;
	asi64(R1) = mm_support_isalphanum(asi64(R1));
	if (!asi64(R1)) goto L5341;
	R1 = -1;
	R2 = tou64(" ");
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
L5341:
L5339:
	R1 = -1;
	asu64(R2) = s;
	asu64(R3) = dest;
	mlib_strbuffer_add(asu64(R3), asu64(R2), asi64(R1));
	return;
}

static void mm_support_gs_copytostr(u64 source, u64 s) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = source;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5344;
	asu64(R1) = source;
	R2 = 8;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = tou64(toi32(R1));
	asu64(R2) = source;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = s;
	asu64(R3) = source;
	R4 = 8;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5343;
L5344:
	R1 = 0;
	asu64(R2) = s;
	*tou8p(R2) = asu8(R1);
L5343:
	return;
}

static i64 mm_support_isalphanum(i64 c) {
    u64 R1, R2; 
	asi64(R1) = c;
	R2 = 65;
	if (asi64(R1) < asi64(R2)) goto L5349;
	asi64(R1) = c;
	R2 = 90;
	if (asi64(R1) <= asi64(R2)) goto L5348;
L5349:
	asi64(R1) = c;
	R2 = 97;
	if (asi64(R1) < asi64(R2)) goto L5350;
	asi64(R1) = c;
	R2 = 122;
	if (asi64(R1) <= asi64(R2)) goto L5348;
L5350:
	asi64(R1) = c;
	R2 = 48;
	if (asi64(R1) < asi64(R2)) goto L5347;
	asi64(R1) = c;
	R2 = 57;
	if (asi64(R1) > asi64(R2)) goto L5347;
L5348:
	R1 = 1;
	goto L5345;
L5347:
	R1 = 0;
	goto L5345;
L5345:
	return asi64(R1);
}

static void mm_support_init_tt_tables() {
    u64 R1, R2, R3; 
	i64 i;
	i64 size;
	i64 bitsize;
	i64 s;
	i64 t;
	i64 u;
	i64 v;
	i64 av_1;
	R1 = 0;
	i = asi64(R1);
	R1 = 30;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L5354;
L5352:
	R1 = (u64)&mm_tables_stdnames;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mm_decls_ttname;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = i;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_tables_stdsize;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 8;
	asi64(R1) *= asi64(R2);
	bitsize = asi64(R1);
	asi64(R1) = bitsize;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5356;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5357;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5357;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5357;
	goto L5358;
L5356:
	R1 = 0;
	size = asi64(R1);
	goto L5355;
L5357:
	R1 = 1;
	size = asi64(R1);
	goto L5355;
L5358:
	asi64(R1) = bitsize;
	R2 = 8;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	size = asi64(R1);
L5355:
	asi64(R1) = size;
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = i;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	asi64(R1) = i;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5360;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5360;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L5360;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5360;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L5361;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L5361;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L5361;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5361;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5361;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5361;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5362;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5362;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5363;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L5363;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L5363;
	goto L5364;
L5360:
	R1 = 1;
	R2 = (u64)&mm_decls_ttsigned;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttisinteger;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5359;
L5361:
	R1 = 1;
	R2 = (u64)&mm_decls_ttisinteger;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5359;
L5362:
	R1 = 1;
	R2 = (u64)&mm_decls_ttisreal;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5359;
L5363:
	R1 = 1;
	R2 = (u64)&mm_decls_ttisref;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5359;
L5364:
L5359:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5366;
	asi64(R1) = size;
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L5366;
	R1 = 1;
	R2 = (u64)&mm_decls_ttisshort;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5366:
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = i;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = i;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5369;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5369;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5369;
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L5368;
L5369:
	R1 = 1;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5368:
	i += 1; if (i <= av_1) goto L5352;
L5354:
	R1 = 7;
	R2 = (u64)&mm_decls_ttbasetype;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 12;
	R2 = (u64)&mm_decls_tttarget;
	R3 = 20;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 30;
	mm_decls_ntypes = asi64(R1);
	R1 = 0;
	R2 = 24;
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	mm_tables_trefproc = asi64(R1);
	R1 = 0;
	R2 = 25;
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	mm_tables_treflabel = asi64(R1);
	return;
}

static u64 mm_support_getsupportfile(u64 filename, u64 ext, u64 path) {
    u64 R1, R2, R3; 
	struct $B15 filespec;
	struct $B15 filespec2;
	u64 file;
	i64 fileno;
	u64 pfile;
	i64 i;
	asu64(R1) = filename;
	file = asu64(R1);
	asi64(R1) = mm_decls_fverbose;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5372;
	msysc_m$print_startcon();
	R1 = tou64("Get file:# (ext:#) (path:#)");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = filename;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = ext;
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = path;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5372:
	asu64(R1) = ext;
	asu8(R1) = *tou8p(R1);
	if (!asu8(R1)) goto L5374;
	asu64(R1) = ext;
	asu64(R2) = filename;
	asu64(R1) = mlib_addext(asu64(R2), asu64(R1));
	R2 = (u64)&filespec;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = (u64)&filespec;
	file = asu64(R1);
L5374:
	asu8(R1) = mm_decls_loadedfromma;
	if (!asu8(R1)) goto L5376;
	asu64(R1) = file;
	asu64(R1) = mlib_extractfile(asu64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	file = asu64(R1);
L5376:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5379;
L5377:
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = file;
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5381;
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5381;
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	goto L5370;
L5381:
	i += 1; if (i <= mm_decls_nsourcefiles) goto L5377;
L5379:
	asu64(R1) = file;
	asi64(R1) = mm_support_isabspath(asu64(R1));
	if (asi64(R1)) goto L5383;
	asu64(R1) = path;
	R2 = (u64)&filespec2;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	asu64(R1) = file;
	R2 = (u64)&filespec2;
	asu64(R1) = strcat(asu64(R2), asu64(R1));
	R1 = (u64)&filespec2;
	file = asu64(R1);
L5383:
	asi64(R1) = mm_decls_fverbose;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5385;
	asi64(R1) = fileno;
	if (!asi64(R1)) goto L5385;
	msysc_m$print_startcon();
	R1 = tou64("Checkfile:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = file;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5385:
	asu64(R1) = file;
	R2 = 0;
	if (asu64(R1) == asu64(R2)) goto L5388;
	asu64(R1) = file;
	asi64(R1) = mlib_checkfile(asu64(R1));
	if (asi64(R1)) goto L5387;
L5388:
	R1 = tou64("");
	asu64(R2) = file;
	R3 = tou64("Can't find file: ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5387:
	R1 = 0;
	asu64(R2) = file;
	asu64(R1) = mm_modules_loadsourcefile(asu64(R2), asi64(R1));
	pfile = asu64(R1);
	asi64(R1) = mm_decls_fverbose;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5390;
	asu64(R1) = pfile;
	if (!asu64(R1)) goto L5390;
	msysc_m$print_startcon();
	R1 = tou64("Found:");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = file;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5390:
	R1 = 1;
	asu64(R2) = pfile;
	R3 = 57;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pfile;
	goto L5370;
L5370:
	return asu64(R1);
}

static i64 mm_support_isabspath(u64 filespec) {
    u64 R1, R2; 
	u64 path;
	asu64(R1) = filespec;
	asu64(R1) = mlib_extractpath(asu64(R1));
	path = asu64(R1);
	asu64(R1) = path;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L5394;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L5394;
	asu64(R1) = path;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5393;
	asu64(R1) = path;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 58;
	if (asu64(R1) != asu64(R2)) goto L5393;
L5394:
	R1 = 1;
	goto L5391;
L5393:
	R1 = 0;
	goto L5391;
L5391:
	return asi64(R1);
}

static void mm_support_initbblib() {
    u64 R1, R2, R3, R4; 
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 6;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5398;
L5396:
	R1 = 1;
	R2 = (u64)&mm_decls_typestarterset;
	R3 = (u64)&mm_tables_d_typestarterset;
	asi64(R4) = i;
	asi64(R3) = *toi64p(((i64)R3+(i64)R4*8-8));
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= av_1) goto L5396;
L5398:
	return;
}

static i64 mm_support_getfileno(u64 pos) {
    u64 R1, R2, R3; 
	i64 fileno;
	asu64(R1) = pos;
	R2 = 24;
	R3 = 31;
    asi64(R1) = Getdotslice((u64)R1, (i64)R2, (i64)R3);
	fileno = asi64(R1);
	asi64(R1) = fileno;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5402;
	asi64(R1) = fileno;
	asi64(R2) = mm_decls_nsourcefiles;
	if (asi64(R1) <= asi64(R2)) goto L5401;
L5402:
	R1 = tou64("No file no");
	mlib_abortprogram(asu64(R1));
L5401:
	asi64(R1) = fileno;
	goto L5399;
L5399:
	return asi64(R1);
}

static i64 mm_support_getlineno(u64 pos) {
    u64 R1, R2; 
	u64 source;
	u64 sline;
	u64 s;
	i64 lineno;
	asu64(R1) = pos;
	asu64(R1) = mm_support_getsourcestart(asu64(R1));
	source = asu64(R1);
	asu64(R1) = pos;
	asu64(R1) = mm_support_getsourceline(asu64(R1));
	sline = asu64(R1);
	asu64(R1) = sline;
	s = asu64(R1);
	R1 = 1;
	lineno = asi64(R1);
	goto L5405;
L5404:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5408;
	R1 = (u64)&lineno;
	(*toi64p(R1)) += 1;
L5408:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
L5405:
	asu64(R1) = s;
	asu64(R2) = source;
	if (asu64(R1) >= asu64(R2)) goto L5404;
	asi64(R1) = lineno;
	goto L5403;
L5403:
	return asi64(R1);
}

static u64 mm_support_getsourceline(u64 pos) {
    u64 R1, R2; 
	u64 source;
	u64 s;
	asu64(R1) = pos;
	asu64(R1) = mm_support_getsourcestart(asu64(R1));
	source = asu64(R1);
	asu64(R1) = pos;
	asu64(R1) = mm_support_getsourcepos(asu64(R1));
	s = asu64(R1);
	goto L5411;
L5410:
	R1 = (u64)&s;
	(*tou64p(R1)) -=1;
L5411:
	asu64(R1) = s;
	asu64(R2) = source;
	if (asu64(R1) <= asu64(R2)) goto L5413;
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5410;
L5413:
	asu64(R1) = s;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5415;
	R1 = (u64)&s;
	(*tou64p(R1)) += 1;
L5415:
	asu64(R1) = s;
	goto L5409;
L5409:
	return asu64(R1);
}

static u64 mm_support_getsourcestart(u64 pos) {
    u64 R1, R2; 
	R1 = (u64)&mm_decls_sources;
	asu64(R2) = pos;
	asi64(R2) = mm_support_getfileno(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L5416;
L5416:
	return asu64(R1);
}

static u64 mm_support_getsourcepos(u64 pos) {
    u64 R1, R2, R3, R4; 
	R1 = (u64)&mm_decls_sources;
	asu64(R2) = pos;
	asi64(R2) = mm_support_getfileno(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pos;
	R3 = 0;
	R4 = 23;
    asi64(R2) = Getdotslice((u64)R2, (i64)R3, (i64)R4);
	R1 += (i64)R2;
	goto L5417;
L5417:
	return asu64(R1);
}

static i64 mm_support_mgetsourceinfo(i64 pos, u64 filename, u64 sourceline) {
    u64 R1, R2; 
	i64 lineno;
	asi64(R1) = pos;
	asi64(R1) = mm_support_getlineno(asu64(R1));
	lineno = asi64(R1);
	asi64(R1) = pos;
	asu64(R1) = mm_support_getsourcestart(asu64(R1));
	asu64(R2) = sourceline;
	*tou64p(R2) = asu64(R1);
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = pos;
	asi64(R2) = mm_support_getfileno(asu64(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = filename;
	*tou64p(R2) = asu64(R1);
	asi64(R1) = lineno;
	goto L5418;
L5418:
	return asi64(R1);
}

static void mm_support_do_writema(u64 inpfile) {
    u64 R1, R2, R3, R4; 
	struct $B15 filename;
	struct $B77 sflist;
	u64 f;
	i64 offset;
	i64 nfiles;
	i64 fileno;
	u64 pf;
	i64 i;
	asi64(R1) = mm_decls_passlevel;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5421;
	goto L5419;
L5421:
	R1 = tou64("ma");
	asu64(R2) = inpfile;
	asu64(R1) = mlib_changeext(asu64(R2), asu64(R1));
	R2 = (u64)&filename;
	asu64(R1) = strcpy(asu64(R2), asu64(R1));
	R1 = 0;
	nfiles = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nsourcefiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5424;
L5422:
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5426;
	asi64(R1) = i;
	R2 = (u64)&sflist;
	R3 = (u64)&nfiles;
	asi64(R3) = *(toi64p(R3)) += 1;
	*toi64p(((i64)R2+(i64)R3*8-8)) = asi64(R1);
L5426:
	i += 1; if (i <= mm_decls_nsourcefiles) goto L5422;
L5424:
	asi64(R1) = nfiles;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5428;
	R1 = tou64("");
	R2 = tou64("");
	R3 = tou64("MA: no files");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5428:
	R1 = tou64("wb");
	R2 = (u64)&filename;
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (asu64(R1)) goto L5430;
	R1 = tou64("");
	R2 = (u64)&filename;
	R3 = tou64("Can't create MA file ");
	mm_support_loaderror(asu64(R3), asu64(R2), asu64(R1));
L5430:
	asi64(R1) = mm_decls_fverbose;
	if (!asi64(R1)) goto L5432;
	msysc_m$print_startcon();
	R1 = tou64("Writing ");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&filename;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5432:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== MA # ===");
	msysc_m$print_setfmt(asu64(R1));
	asi64(R1) = nfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5435;
L5433:
	R1 = (u64)&mm_decls_sources;
	R2 = (u64)&sflist;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pf = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== # # # #/# ===");
	msysc_m$print_setfmt(asu64(R1));
	asu64(R1) = pf;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pf;
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pf;
	R2 = 57;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asi64(R1) = nfiles;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = f;
	asi64(R1) = mlib_getfilepos(asu64(R1));
	offset = asi64(R1);
	asu64(R1) = pf;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asi64(R2) = offset;
	asu64(R3) = pf;
	R4 = 40;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = f;
	asi64(R1) = mlib_writerandom(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= nfiles) goto L5433;
L5435:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("=== END ===");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nfiles;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5438;
L5436:
	R1 = (u64)&mm_decls_sources;
	R2 = (u64)&sflist;
	asi64(R3) = i;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3*8-8));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pf = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pf;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = pf;
	R2 = 56;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	asu64(R1) = pf;
	R2 = 57;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= nfiles) goto L5436;
L5438:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
	R1 = 0;
	exit(R1);
L5419:
	return;
}

static void mm_support_do_getinfo(u64 filename) {
    u64 R1, R2, R3, R4; 
	u64 f;
	u64 fs;
	u64 pm;
	i64 i;
	asi64(R1) = mm_decls_passlevel;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5441;
	R1 = tou64("wb");
	R2 = tou64("list");
	asu64(R3) = filename;
	asu64(R2) = mlib_changeext(asu64(R3), asu64(R2));
	R3 = R2;
	fs = asu64(R3);
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (!asu64(R1)) goto L5443;
	msysc_m$print_startcon();
	R1 = tou64("Writing");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = fs;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	asu64(R1) = mm_decls_stprogram;
	asu64(R2) = f;
	mm_support_getst(asu64(R2), asu64(R1));
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L5443:
L5441:
	asi64(R1) = mm_decls_passlevel;
	R2 = 3;
	if (asi64(R1) != asi64(R2)) goto L5445;
	R1 = tou64("wb");
	R2 = tou64("proj");
	asu64(R3) = filename;
	asu64(R2) = mlib_changeext(asu64(R3), asu64(R2));
	R3 = R2;
	fs = asu64(R3);
	asu64(R1) = fopen(asu64(R2), asu64(R1));
	f = asu64(R1);
	asu64(R1) = f;
	if (!asu64(R1)) goto L5447;
	msysc_m$print_startcon();
	R1 = tou64("Writing");
	msysc_m$print_str_nf(asu64(R1));
	asu64(R1) = fs;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = mm_decls_nmodules;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5450;
L5448:
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pm = asu64(R1);
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("16jl");
	asu64(R2) = pm;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("16jl");
	R2 = (u64)&mm_decls_subprogs;
	asu64(R3) = pm;
	R4 = 18;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	R1 = tou64("q");
	asu64(R2) = pm;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	asu64(R1) = pm;
	R2 = 22;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	i += 1; if (i <= mm_decls_nmodules) goto L5448;
L5450:
	asu64(R1) = f;
	asi32(R1) = fclose(asu64(R1));
L5447:
L5445:
	return;
}

static void mm_support_getst(u64 f, u64 d) {
    u64 R1, R2; 
	u64 q;
	asu64(R1) = d;
	asu64(R2) = f;
	mm_support_getstrec(asu64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5455;
L5452:
	asu64(R1) = q;
	asu64(R2) = f;
	mm_support_getst(asu64(R2), asu64(R1));
	asu64(R1) = q;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5455:
	asu64(R1) = q;
	if (asu64(R1)) goto L5452;
	return;
}

static void mm_support_getstrec(u64 f, u64 d) {
    u64 R1, R2, R3, R4, R5; 
	u64 name;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5458;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5458;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5458;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5458;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5458;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L5458;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5458;
	goto L5459;
L5458:
	goto L5457;
L5459:
	goto L5456;
L5457:
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5461;
	asu64(R1) = d;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5461;
	goto L5456;
L5461:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("10jl");
	R2 = (u64)&mm_decls_subprogs;
	R3 = (u64)&mm_decls_moduletosub;
	asu64(R4) = d;
	R5 = 94;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("12jl");
	asu64(R2) = d;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("18jl");
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5463;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5464;
	goto L5465;
L5463:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5467;
	R1 = tou64("funcid");
	goto L5466;
L5467:
	R1 = tou64("procid");
L5466:
	name = asu64(R1);
	goto L5462;
L5464:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5469;
	R1 = tou64("dllfuncid");
	goto L5468;
L5469:
	R1 = tou64("dllprocid");
L5468:
	name = asu64(R1);
	goto L5462;
L5465:
	R1 = (u64)&mm_tables_namenames;
	asu64(R2) = d;
	R3 = 78;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	name = asu64(R1);
L5462:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("10jl");
	asu64(R2) = name;
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("5");
	asu64(R2) = d;
	R3 = 88;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = tou64(tou32(R2));
	asi64(R2) = mm_support_getlineno(asu64(R2));
	msysc_m$print_i64(asi64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 170;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5471;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5472;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5473;
	goto L5474;
L5471:
	R1 = tou64("Module");
	name = asu64(R1);
	goto L5470;
L5472:
	R1 = tou64("Subprog");
	name = asu64(R1);
	goto L5470;
L5473:
	R1 = tou64("Program");
	name = asu64(R1);
	goto L5470;
L5474:
	R1 = tou64("Export");
	name = asu64(R1);
L5470:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	asu64(R1) = name;
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 11;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5476;
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("Import ");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_end();
L5476:
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("10jlq");
	R2 = 1;
	asu64(R3) = d;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_space();
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	R1 = tou64("q");
	R2 = (u64)&mm_decls_sources;
	R3 = (u64)&mm_decls_modules;
	asu64(R4) = d;
	R5 = 94;
	asu8(R4) = *tou8p(((i64)R4+(i64)R5));
	R4 = toi64(tou8(R4));
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8));
	R4 = 20;
	asi16(R3) = *toi16p(((i64)R3+(i64)R4));
	R3 = toi64(toi16(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	msysc_m$print_str(asu64(R2), asu64(R1));
	msysc_m$print_end();
	asu64(R1) = f;
	msysc_m$print_startfile(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5456:
	return;
}

static void mm_tables_start() {
    u64 R1, R2, R3, R4; 
	i64 genop;
	i64 s;
	i64 t;
	i64 a;
	i64 specop;
	i64 av_1;
	i64 i;
	R1 = 1;
	i = asi64(R1);
	R1 = 12;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5480;
L5478:
	R1 = 1;
	R2 = (u64)&mm_tables_endsexpr;
	R3 = (u64)&mm_tables_exprendsymbols;
	asi64(R4) = i;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4-1));
	R3 = toi64(tou8(R3));
	*tou8p(((i64)R2+(i64)R3-1)) = asu8(R1);
	i += 1; if (i <= av_1) goto L5478;
L5480:
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 33;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 34;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 15;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 16;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 17;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 18;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 19;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 43;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	R2 = (u64)&mm_tables_isbooltag;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tpass(u64 p, i64 t, i64 lv) {
    u64 R1, R2, R3, R4, R5, R6; 
	u64 d;
	u64 a;
	u64 b;
	u64 c;
	u64 q;
	i64 oldmmpos;
	i64 m;
	i64 nparams;
	i64 paramtype;
	i64 restype;
	i64 amode;
	i64 av_1;
	i64 i;
	asu64(R1) = p;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5483;
	goto L5481;
L5483:
	asi64(R1) = mm_type_tpass_depth;
	R2 = 100;
	if (asi64(R1) != asi64(R2)) goto L5485;
	R1 = 0;
	R2 = tou64("TX looping detected");
	mm_support_txerror(asu64(R2), asu64(R1));
L5485:
	R1 = (u64)&mm_type_tpass_depth;
	(*toi64p(R1)) += 1;
	asi64(R1) = pc_decls_mmpos;
	oldmmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = p;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	c = asu64(R1);
	asi64(R1) = t;
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	switch (asi64(R1)) {
	case 1: case 7: goto L5490;
	case 2: case 3: case 5: case 9: case 23: case 25: case 26: case 27: case 29: case 30: case 31: case 42: case 43: case 44: case 45: case 47: case 50: case 54: case 57: case 63: case 64: case 69: case 70: case 71: case 72: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: goto L5488;
	case 4: goto L5489;
	case 6: goto L5521;
	case 8: goto L5551;
	case 10: case 11: goto L5554;
	case 12: goto L5555;
	case 13: goto L5593;
	case 14: goto L5596;
	case 15: case 16: goto L5509;
	case 17: case 18: case 19: goto L5510;
	case 20: goto L5537;
	case 21: goto L5514;
	case 22: goto L5595;
	case 24: goto L5594;
	case 28: goto L5499;
	case 32: goto L5507;
	case 33: case 35: goto L5493;
	case 34: goto L5587;
	case 36: goto L5495;
	case 37: goto L5496;
	case 38: goto L5497;
	case 39: goto L5498;
	case 40: goto L5513;
	case 41: goto L5494;
	case 46: goto L5505;
	case 48: goto L5520;
	case 49: goto L5508;
	case 51: case 52: goto L5519;
	case 53: goto L5506;
	case 55: goto L5500;
	case 56: goto L5503;
	case 58: goto L5511;
	case 59: goto L5592;
	case 60: goto L5534;
	case 61: goto L5512;
	case 62: goto L5491;
	case 65: case 66: goto L5492;
	case 67: goto L5556;
	case 68: goto L5573;
	case 73: case 74: goto L5572;
	case 86: goto L5559;
	case 87: case 88: goto L5550;
	case 89: goto L5524;
	case 90: goto L5574;
	case 91: goto L5533;
	case 92: goto L5504;
	case 93: case 94: goto L5531;
	case 95: case 96: goto L5532;
	case 97: goto L5542;
	case 98: goto L5546;
	case 99: goto L5540;
	case 100: goto L5541;
	case 101: case 102: case 103: goto L5539;
	case 104: goto L5523;
	case 105: case 106: goto L5518;
	case 107: case 108: case 109: case 110: goto L5517;
	case 111: goto L5515;
	case 112: goto L5516;
	case 113: goto L5567;
	case 114: case 115: case 116: case 117: goto L5525;
	case 118: goto L5561;
	case 119: goto L5560;
	case 120: goto L5538;
	case 121: goto L5522;
	case 122: goto L5588;
	default: goto L5488;
    };
// SWITCH
L5489:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = p;
	mm_type_tx_name(asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5490:
	goto L5486;
L5491:
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5486;
L5492:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5486;
L5493:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_bin(asu64(R3), asu64(R2), asu64(R1));
	goto L5486;
L5494:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_tx_in(asu64(R3), asu64(R2), asu64(R1));
	goto L5486;
L5495:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_unary(asu64(R2), asu64(R1));
	goto L5486;
L5496:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_prop(asu64(R2), asu64(R1));
	goto L5486;
L5497:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_binto(asu64(R3), asu64(R2), asu64(R1));
	goto L5486;
L5498:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_unaryto(asu64(R2), asu64(R1));
	goto L5486;
L5499:
	asi64(R1) = t;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_assign(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5486;
L5500:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 53;
	if (asi64(R1) != asi64(R2)) goto L5502;
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = p;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L5501;
L5502:
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5501:
	goto L5486;
L5503:
	asi64(R1) = t;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_addroffirst(asu64(R3), asu64(R2), asi64(R1));
	goto L5486;
L5504:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_type_tx_if(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5505:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = b;
	asu64(R4) = a;
	asu64(R5) = p;
	mm_type_tx_index(asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5506:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_ptr(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5507:
	asi64(R1) = t;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_callproc(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5486;
L5508:
	asi64(R1) = lv;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_dot(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5486;
L5509:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_andl(asu64(R3), asu64(R2), asu64(R1));
	goto L5486;
L5510:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_notl(asu64(R2), asu64(R1));
	goto L5486;
L5511:
	R1 = 1;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_convert(asu64(R3), asu64(R2), asi64(R1));
	goto L5486;
L5512:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_typepun(asu64(R2), asu64(R1));
	goto L5486;
L5513:
	asi64(R1) = t;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_incrto(asu64(R3), asu64(R2), asi64(R1));
	goto L5486;
L5514:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_makerange(asu64(R3), asu64(R2), asu64(R1));
	goto L5486;
L5515:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_swap(asu64(R3), asu64(R2), asu64(R1));
	goto L5486;
L5516:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_type_tx_select(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5517:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_type_tx_switch(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5518:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	asu64(R4) = b;
	asu64(R5) = a;
	asu64(R6) = p;
	mm_type_tx_case(asu64(R6), asu64(R5), asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5519:
	asi64(R1) = lv;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_dotindex(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5486;
L5520:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_slice(asu64(R3), asu64(R2), asu64(R1));
	goto L5486;
L5521:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_block(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5522:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5523:
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5524:
	asi64(R1) = t;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_return(asu64(R3), asu64(R2), asi64(R1));
	goto L5486;
L5525:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	mm_type_fixchararray(asu64(R1));
	goto L5527;
L5526:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 86;
	if (asi64(R1) != asi64(R2)) goto L5530;
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = R3;
	c = asu64(R4);
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 20;
	asu64(R3) = b;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L5529;
L5530:
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	R4 = R3;
	c = asu64(R4);
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L5529:
	asu64(R1) = c;
	mm_type_fixchararray(asu64(R1));
	asu64(R1) = b;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
L5527:
	asu64(R1) = b;
	if (asu64(R1)) goto L5526;
	R1 = 0;
	R2 = 23;
	asu64(R3) = p;
	R4 = 32;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5531:
	asu64(R1) = c;
	asu64(R2) = b;
	asu64(R3) = a;
	mm_type_tx_for(asu64(R3), asu64(R2), asu64(R1));
	goto L5486;
L5532:
	asu64(R1) = c;
	asu64(R2) = b;
	asu64(R3) = a;
	mm_type_tx_forall(asu64(R3), asu64(R2), asu64(R1));
	goto L5486;
L5533:
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5534:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L5536;
	R1 = 0;
	R2 = tou64("cast() needs type");
	mm_support_txerror(asu64(R2), asu64(R1));
L5536:
	R1 = 1;
	asi64(R2) = t;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L5486;
L5537:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_makelist(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5538:
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5539:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_exit(asu64(R2), asu64(R1));
	goto L5486;
L5540:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_goto(asu64(R2), asu64(R1));
	goto L5486;
L5541:
	goto L5486;
L5542:
	R1 = 0;
	R2 = 6;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = mm_type_iscondtrue(asu64(R1));
	if (!asi64(R1)) goto L5544;
	R1 = 104;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = b;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L5543;
L5544:
	asu64(R1) = a;
	asi64(R1) = mm_type_iscondfalse(asu64(R1));
	if (!asi64(R1)) goto L5545;
	R1 = 2;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5545:
L5543:
	R1 = 0;
	R2 = 0;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5546:
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = b;
	asi64(R1) = mm_type_iscondtrue(asu64(R1));
	if (asi64(R1)) goto L5549;
	asu64(R1) = b;
	asi64(R1) = mm_type_iscondfalse(asu64(R1));
	if (!asi64(R1)) goto L5548;
L5549:
	R1 = 0;
	R2 = tou64("repeat/const cond");
	mm_support_txerror(asu64(R2), asu64(R1));
L5548:
	goto L5486;
L5550:
	goto L5486;
L5551:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5553;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5553:
	R1 = 1;
	mm_type_inassem = asi64(R1);
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = c;
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	mm_type_inassem = asi64(R1);
	goto L5486;
L5554:
	goto L5486;
L5555:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5556:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L5558;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	m = asi64(R1);
	goto L5557;
L5558:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
L5557:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5486;
L5559:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5560:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L5486;
L5561:
	asu64(R1) = a;
	if (!asu64(R1)) goto L5563;
	R1 = 0;
	R2 = 5;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L5563:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5566;
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5565;
L5566:
	asi64(R1) = t;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	t = asi64(R1);
L5565:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5486;
L5567:
	asu64(R1) = a;
	if (!asu64(R1)) goto L5569;
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5571;
	R1 = 0;
	R2 = tou64("recase must be const");
	mm_support_txerror(asu64(R2), asu64(R1));
L5571:
L5569:
	goto L5486;
L5572:
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5486;
L5573:
	asi64(R1) = lv;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_bitfield(asu64(R3), asu64(R2), asi64(R1));
	goto L5486;
L5574:
	R1 = 0;
	restype = asi64(R1);
	R1 = 0;
	paramtype = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L5576;
	R2 = 30;
	if (asi64(R1) == asi64(R2)) goto L5577;
	R2 = 31;
	if (asi64(R1) == asi64(R2)) goto L5578;
	goto L5579;
L5576:
	R1 = 3;
	restype = asi64(R1);
	goto L5575;
L5577:
	R1 = 3;
	paramtype = asi64(R1);
	R1 = 20;
	restype = asi64(R1);
	goto L5575;
L5578:
	R1 = 3;
	paramtype = asi64(R1);
	R1 = 7;
	restype = asi64(R1);
	goto L5575;
L5579:
L5575:
	asi64(R1) = paramtype;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5581;
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5583;
	R1 = 0;
	R2 = tou64("sys: arg missing");
	mm_support_txerror(asu64(R2), asu64(R1));
L5583:
	R1 = 0;
	asi64(R2) = paramtype;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5585;
	R1 = 0;
	R2 = tou64("sys: too many args");
	mm_support_txerror(asu64(R2), asu64(R1));
L5585:
	goto L5580;
L5581:
	asu64(R1) = a;
	if (!asu64(R1)) goto L5586;
	R1 = 0;
	R2 = tou64("sys: too many args");
	mm_support_txerror(asu64(R2), asu64(R1));
L5586:
L5580:
	asi64(R1) = restype;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5486;
L5587:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_cmpchain(asu64(R2), asu64(R1));
	goto L5486;
L5588:
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5590;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5590;
	goto L5591;
L5590:
	goto L5589;
L5591:
	R1 = 0;
	R2 = tou64("Clear scalar?");
	mm_support_txerror(asu64(R2), asu64(R1));
L5589:
	goto L5486;
L5592:
	goto L5486;
L5593:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_tx_strinclude(asu64(R2), asu64(R1));
	goto L5486;
L5594:
	asi64(R1) = t;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_makeslice(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	goto L5486;
L5595:
	asi64(R1) = t;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_makeset(asu64(R3), asu64(R2), asi64(R1));
	goto L5486;
L5596:
	goto L5486;
L5488:
	msysc_m$print_startcon();
	R1 = tou64("TXUNIT: CAN'T DO:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
// mm_type.tpass.doelse:
	R1 = 1;
	i = asi64(R1);
	R1 = (u64)&mm_tables_jsubs;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5600;
L5598:
	R1 = 0;
	asi64(R2) = t;
	asu64(R3) = p;
	R4 = 16;
	R3 += (i64)R4;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	mm_type_tx_unitlist(asu64(R3), asi64(R2), asi64(R1));
	i += 1; if (i <= av_1) goto L5598;
L5600:
L5486:
	asu64(R1) = p;
	mm_type_tevaluate(asu64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L5602;
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L5602;
	goto L5603;
L5602:
	goto L5601;
L5603:
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L5605;
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5605;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = t;
	if (asi64(R1) == asi64(R2)) goto L5605;
	R1 = 0;
	asi64(R2) = t;
	asu64(R3) = p;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L5605:
L5601:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5607;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5609;
	R2 = 35;
	if (asi64(R1) == asi64(R2)) goto L5609;
	R2 = 36;
	if (asi64(R1) == asi64(R2)) goto L5609;
	R2 = 33;
	if (asi64(R1) == asi64(R2)) goto L5609;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5610;
	goto L5611;
L5609:
	goto L5608;
L5610:
	R1 = (u64)&mm_decls_ttisref;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5614;
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L5613;
L5614:
L5613:
	goto L5608;
L5611:
L5608:
L5607:
	asi64(R1) = oldmmpos;
	pc_decls_mmpos = asi64(R1);
	R1 = (u64)&mm_type_tpass_depth;
	(*toi64p(R1)) -=1;
L5481:
	return;
}

static void mm_type_tx_allprocs() {
    u64 R1, R2, R3; 
	u64 pp;
	u64 pcode;
	asu64(R1) = mm_decls_proclist;
	pp = asu64(R1);
	goto L5617;
L5616:
	asu64(R1) = pp;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_decls_currproc = asu64(R1);
	asu64(R1) = mm_decls_currproc;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcode = asu64(R1);
	R1 = 0;
	asu64(R2) = mm_decls_currproc;
	R3 = 122;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 1;
	if (asi64(R2) <= asi64(R3)) goto L5620;
	R2 = 28;
	goto L5619;
L5620:
	asu64(R2) = mm_decls_currproc;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
L5619:
	asu64(R3) = pcode;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = mm_decls_currproc;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5622;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5623;
	goto L5624;
L5622:
	goto L5621;
L5623:
	goto L5621;
L5624:
	asu64(R1) = pcode;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L5626;
	R1 = 89;
	asu64(R2) = pcode;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = mm_decls_currproc;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pcode;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = pcode;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5626:
L5621:
	asu64(R1) = pp;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pp = asu64(R1);
L5617:
	asu64(R1) = pp;
	if (asu64(R1)) goto L5616;
	return;
}

static void mm_type_tx_block(u64 p, u64 a, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	goto L5629;
L5628:
	R1 = 0;
	R2 = 0;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L5629:
	asu64(R1) = a;
	if (!asu64(R1)) goto L5631;
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (asu64(R1)) goto L5628;
L5631:
	asu64(R1) = a;
	if (!asu64(R1)) goto L5633;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5635;
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	goto L5634;
L5635:
	R1 = 0;
L5634:
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5633:
	return;
}

static void mm_type_tx_typetable() {
    u64 R1, R2; 
	u64 d;
	i64 i;
	R1 = 31;
	i = asi64(R1);
	asi64(R1) = mm_decls_ntypes;
	R2 = 31;
	if (asi64(R1) < asi64(R2)) goto L5639;
L5637:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = i;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L5641;
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = R1;
	d = asu64(R2);
	mm_type_tx_passdef(asu64(R1));
L5641:
	asi64(R1) = i;
	mm_type_setmodesize(asi64(R1));
	i += 1; if (i <= mm_decls_ntypes) goto L5637;
L5639:
	return;
}

static void mm_type_setmodesize(i64 m) {
    u64 R1, R2, R3; 
	i64 size;
	i64 target;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	if (!asu32(R1)) goto L5644;
	goto L5642;
L5644:
	R1 = (u64)&mm_decls_ttlineno;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	pc_decls_mmpos = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5646;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5647;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5648;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L5648;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5649;
	R2 = 22;
	if (asi64(R1) == asi64(R2)) goto L5650;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L5651;
	R2 = 29;
	if (asi64(R1) == asi64(R2)) goto L5652;
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L5653;
	goto L5654;
L5646:
	asi64(R1) = m;
	mm_type_setarraysize(asi64(R1));
	goto L5645;
L5647:
	asi64(R1) = m;
	mm_type_setrecordsize(asi64(R1));
	goto L5645;
L5648:
	goto L5645;
L5649:
	asi64(R1) = m;
	mm_type_setslicesize(asi64(R1));
	goto L5645;
L5650:
	R1 = 0;
	R2 = tou64("SETMODESIZE/AUTO?");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L5645;
L5651:
	goto L5645;
L5652:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	target = asi64(R1);
	asi64(R1) = target;
	mm_type_setmodesize(asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = target;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = target;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = target;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = target;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = target;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = (u64)&mm_decls_ttnamedef;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L5645;
L5653:
	goto L5645;
L5654:
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = R1;
	size = asi64(R2);
	if (!asi64(R1)) goto L5656;
	asi64(R1) = size;
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	goto L5642;
L5656:
	msysc_m$print_startcon();
	R1 = tou64("SIZE 0:");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	R1 = tou64("M=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = m;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("STDNAMES[TTBASETYPE[M]]=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_stdnames;
	R2 = (u64)&mm_decls_ttbasetype;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	msysc_m$print_startcon();
	R1 = tou64("Can't set mode size");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5645:
L5642:
	return;
}

static void mm_type_setarraysize(i64 m) {
    u64 R1, R2, R3; 
	i64 lower;
	i64 length;
	i64 elemsize;
	i64 target;
	i64 size;
	u64 pdim;
	u64 a;
	u64 b;
	R1 = (u64)&mm_decls_ttsizeset;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5659;
	goto L5657;
L5659:
	R1 = (u64)&mm_decls_ttdimexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pdim = asu64(R1);
	asu64(R1) = pdim;
	if (!asu64(R1)) goto L5661;
	asu64(R1) = pdim;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = pdim;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = pdim;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	mm_name_rx_unit(asu64(R2), asu64(R1));
	asu64(R1) = pdim;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L5663;
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L5664;
	goto L5665;
L5663:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	lower = asi64(R1);
	asu64(R1) = b;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	asi64(R2) = lower;
	asi64(R1) -= asi64(R2);
	R2 = 1;
	asi64(R1) += asi64(R2);
	length = asi64(R1);
	goto L5662;
L5664:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	lower = asi64(R1);
	asu64(R1) = b;
	if (!asu64(R1)) goto L5667;
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = b;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	length = asi64(R1);
	goto L5666;
L5667:
	R1 = 0;
	length = asi64(R1);
L5666:
	goto L5662;
L5665:
	R1 = 0;
	R2 = 23;
	asu64(R3) = pdim;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pdim;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	length = asi64(R1);
	R1 = 1;
	lower = asi64(R1);
L5662:
	goto L5660;
L5661:
	R1 = 1;
	lower = asi64(R1);
	R1 = 0;
	length = asi64(R1);
L5660:
	asi64(R1) = length;
	R2 = 0;
	if (asi64(R1) >= asi64(R2)) goto L5669;
	R1 = 0;
	R2 = tou64("Neg length");
	mm_support_txerror(asu64(R2), asu64(R1));
L5669:
	R1 = 0;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	asi64(R1) = lower;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = length;
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	target = asi64(R1);
	asi64(R1) = target;
	mm_type_setmodesize(asi64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	elemsize = asi64(R1);
	asi64(R1) = length;
	asi64(R2) = elemsize;
	asi64(R1) *= asi64(R2);
	R2 = R1;
	size = asi64(R2);
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttsizeset;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	mm_type_checkblocktype(asi64(R1));
L5657:
	return;
}

static void mm_type_setslicesize(i64 m) {
    u64 R1, R2, R3; 
	u64 pdim;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	if (!asu32(R1)) goto L5672;
	goto L5670;
L5672:
	R1 = (u64)&mm_decls_ttdimexpr;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pdim = asu64(R1);
	asu64(R1) = pdim;
	if (!asu64(R1)) goto L5674;
	asu64(R1) = pdim;
	R2 = (u64)&mm_decls_ttowner;
	asi64(R3) = m;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	mm_name_rx_unit(asu64(R2), asu64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = pdim;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pdim;
	asi64(R1) = mm_type_getconstint(asu64(R1));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 0;
	R2 = (u64)&mm_decls_ttdimexpr;
	asi64(R3) = m;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	goto L5673;
L5674:
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
L5673:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mm_type_setmodesize(asi64(R1));
	R1 = (u64)&mm_decls_ttsize;
	R2 = 11;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
L5670:
	return;
}

static i64 mm_type_tx_module(i64 n) {
    u64 R1, R2; 
	struct $B33 m;
	u64 d;
	i64 globalflag;
	i64 status;
	asi64(R1) = n;
	mm_decls_currmoduleno = asi64(R1);
	R1 = (u64)&mm_decls_modules;
	asi64(R2) = n;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_type_tx_passdef(asu64(R1));
	R1 = 1;
	goto L5675;
L5675:
	return asi64(R1);
}

static void mm_type_tx_passdef(u64 p) {
    u64 R1, R2, R3; 
	u64 d;
	i64 oldmmpos;
	u64 q;
	asu64(R1) = p;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5678;
	goto L5676;
L5678:
	asi64(R1) = pc_decls_mmpos;
	oldmmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	goto L5680;
L5679:
	asu64(R1) = d;
	mm_type_tx_passdef(asu64(R1));
	asu64(R1) = d;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
L5680:
	asu64(R1) = d;
	if (asu64(R1)) goto L5679;
	asu64(R1) = p;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5683;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5684;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5685;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5685;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5685;
	goto L5686;
L5683:
	R1 = 0;
	mm_decls_currproc = asu64(R1);
	R1 = 0;
	mm_decls_currproc = asu64(R1);
	goto L5682;
L5684:
	asu64(R1) = p;
	mm_type_tx_namedconst(asu64(R1));
	goto L5682;
L5685:
	asu64(R1) = p;
	mm_type_tx_namedef(asu64(R1));
	goto L5682;
L5686:
L5682:
	R1 = 1;
	asu64(R2) = p;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asi64(R1) = oldmmpos;
	pc_decls_mmpos = asi64(R1);
L5676:
	return;
}

static void mm_type_tx_unitlist(u64 p, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	goto L5689;
L5688:
	R1 = 0;
	asi64(R2) = t;
	asu64(R3) = p;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L5689:
	asu64(R1) = p;
	if (asu64(R1)) goto L5688;
	return;
}

static void mm_type_tx_namedef(u64 d) {
    u64 R1, R2, R3; 
	i64 m;
	i64 mold;
	i64 inidataold;
	u64 dcode;
	u64 pequiv;
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 3;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5693;
	R1 = 0;
	R2 = tou64("Circular reference detected");
	mm_support_txerror(asu64(R2), asu64(R1));
L5693:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5695;
	goto L5691;
L5695:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asi64(R1) = m;
	mm_type_setmodesize(asi64(R1));
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dcode = asu64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 8;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5697;
	asu64(R1) = d;
	R2 = 96;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pequiv = asu64(R1);
	asu64(R1) = pequiv;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L5699;
	asu64(R1) = pequiv;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = pequiv;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L5699:
	asu64(R1) = pequiv;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5701;
	R1 = 0;
	R2 = tou64("@name needed");
	mm_support_txerror(asu64(R2), asu64(R1));
L5701:
	R1 = 0;
	R2 = 23;
	asu64(R3) = pequiv;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L5697:
	asu64(R1) = dcode;
	if (!asu64(R1)) goto L5703;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5703;
	asi64(R1) = m;
	mold = asi64(R1);
	asi64(R1) = m;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L5705;
	asu64(R1) = dcode;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5705;
	asu64(R1) = dcode;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L5705;
	R1 = 0;
	R2 = 20;
	asu64(R3) = dcode;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L5704;
L5705:
	asi64(R1) = mm_type_inidata;
	inidataold = asi64(R1);
	R1 = 1;
	mm_type_inidata = asi64(R1);
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = dcode;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = inidataold;
	mm_type_inidata = asi64(R1);
L5704:
	R1 = 0;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5707;
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5707;
	asu64(R1) = dcode;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5707:
	asi64(R1) = mold;
	asi64(R2) = m;
	if (asi64(R1) == asi64(R2)) goto L5709;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5711;
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = mold;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5711;
	R1 = 59;
	asu64(R2) = d;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = mold;
	asu64(R2) = d;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5710;
L5711:
	asi64(R1) = mold;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5712;
	asi64(R1) = mold;
	asu64(R2) = d;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5712:
L5710:
L5709:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5714;
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_type_checkconstexpr(asu64(R1));
L5714:
	goto L5702;
L5703:
	asu64(R1) = dcode;
	if (!asu64(R1)) goto L5715;
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L5715;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L5715;
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5715;
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = dcode;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = dcode;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	goto L5702;
L5715:
	R1 = 0;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L5702:
L5691:
	return;
}

static void mm_type_tx_namedconst(u64 d) {
    u64 R1, R2, R3; 
	i64 m;
	u64 q;
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 3;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5718;
	R1 = 0;
	R2 = tou64("Circular const reference detected");
	mm_support_txerror(asu64(R2), asu64(R1));
L5718:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 2;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5720;
	goto L5716;
L5720:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	R1 = 0;
	asi64(R2) = m;
	R3 = 22;
	if (asi64(R2) != asi64(R3)) goto L5722;
	R2 = 23;
	goto L5721;
L5722:
	asi64(R2) = m;
L5721:
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 3;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
	asu64(R1) = q;
	mm_type_checkconstexpr(asu64(R1));
	asi64(R1) = m;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L5724;
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = d;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5724:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5726;
	goto L5727;
L5726:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L5729;
	R1 = 0;
	R2 = tou64("Bad const type");
	mm_support_txerror(asu64(R2), asu64(R1));
L5729:
	goto L5725;
L5727:
L5725:
	R1 = 1;
	asu64(R2) = d;
	R3 = 92;
	R2 += (i64)R3;
	R3 = 2;
    *toi64p(R2) = Setdotindex(*toi64p(R2), (i64)R3, (i64)R1);
L5716:
	return;
}

static void mm_type_checkconstexpr(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 pmode;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5732;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L5732;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L5733;
	R2 = 58;
	if (asi64(R1) == asi64(R2)) goto L5734;
	R2 = 59;
	if (asi64(R1) == asi64(R2)) goto L5735;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5736;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5736;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5737;
	goto L5738;
L5732:
	goto L5730;
	goto L5731;
L5733:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L5740;
L5739:
	asu64(R1) = q;
	mm_type_checkconstexpr(asu64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5740:
	asu64(R1) = q;
	if (asu64(R1)) goto L5739;
	goto L5731;
L5734:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5743;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L5742;
L5743:
	goto L5744;
L5742:
	goto L5731;
L5735:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	mm_type_checkconstexpr(asu64(R1));
	goto L5731;
L5736:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5746;
	goto L5747;
L5746:
	goto L5745;
L5747:
	goto L5744;
L5745:
	goto L5731;
L5737:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L5749;
	goto L5730;
L5749:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L5751;
	goto L5730;
L5751:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 14;
	if (asi64(R1) != asi64(R2)) goto L5753;
	goto L5730;
L5753:
	goto L5744;
	goto L5731;
L5738:
// mm_type.checkconstexpr.error:
L5744:
	msysc_m$print_startcon();
	R1 = tou64("JTAGNAMES[P.TAG]=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&mm_tables_jtagnames;
	asu64(R2) = p;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	mm_diags_dummy_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = tou64("Getconstexpr: not const");
	mm_support_txerror(asu64(R2), asu64(R1));
L5731:
L5730:
	return;
}

static i64 mm_type_getconstint(u64 q) {
    u64 R1, R2, R3; 
	asu64(R1) = q;
	mm_type_checkconstexpr(asu64(R1));
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5757;
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L5756;
L5757:
	asu64(R1) = q;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	goto L5754;
	goto L5755;
L5756:
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5758;
	asu64(R1) = q;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	R1 = toi64(asr64(R1));
	goto L5754;
	goto L5755;
L5758:
	msysc_m$print_startcon();
	R1 = 1;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Getconstint: not i32/64");
	mm_support_txerror(asu64(R2), asu64(R1));
L5755:
	R1 = 0;
	goto L5754;
L5754:
	return asi64(R1);
}

static void mm_type_makenewconst(u64 p, i64 x, i64 t) {
    u64 R1, R2, R3, R4; 
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5761;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5761:
	return;
}

static void mm_type_tx_name(u64 p, i64 t, i64 lv) {
    u64 R1, R2, R3, R4; 
	u64 d;
	i64 oldmmpos;
	u64 pcode;
	asi64(R1) = pc_decls_mmpos;
	oldmmpos = asi64(R1);
	asu64(R1) = p;
	R2 = 2;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5764;
	goto L5762;
L5764:
	asu64(R1) = p;
	R2 = 2;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 88;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5766;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5767;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L5767;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L5767;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5768;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5768;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L5769;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5770;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L5771;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5772;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5773;
	goto L5774;
L5766:
	asi64(R1) = lv;
	if (!asi64(R1)) goto L5776;
	R1 = 0;
	R2 = tou64("&const");
	mm_support_txerror(asu64(R2), asu64(R1));
L5776:
	asu64(R1) = d;
	mm_type_tx_namedconst(asu64(R1));
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pcode = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pcode;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) != asi64(R2)) goto L5778;
	asu64(R1) = pcode;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	goto L5777;
L5778:
	asu64(R1) = pcode;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
L5777:
	asu64(R1) = pcode;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = pcode;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5765;
L5767:
	asu64(R1) = d;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L5780;
	asi64(R1) = lv;
	if (!asi64(R1)) goto L5780;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't use 'let' as lvalue: ");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L5780:
	asu64(R1) = d;
	mm_type_tx_namedef(asu64(R1));
	asi64(R1) = mm_type_inassem;
	if (asi64(R1)) goto L5782;
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 160;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5784;
	asu64(R1) = p;
	R2 = 1;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5786;
	asu64(R1) = p;
	R2 = 1;
	R1 += (i64)R2;
	(*tou8p(R1)) += 1;
	R1 = 53;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5786:
L5784:
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	goto L5781;
L5782:
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5781:
	goto L5765;
L5768:
	asi64(R1) = mm_tables_trefproc;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5765;
L5769:
	asi64(R1) = mm_tables_treflabel;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5765;
L5770:
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Module name can't be used on it's own: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
	goto L5765;
L5771:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 32;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = d;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5765;
L5772:
	R1 = 62;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5765;
L5773:
	asu64(R1) = d;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5788;
	R1 = 0;
	R2 = tou64("Can't init dllvar");
	mm_support_txerror(asu64(R2), asu64(R1));
L5788:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5765;
L5774:
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	pc_decls_mmpos = asi64(R1);
	asu64(R1) = d;
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_tables_namenames;
	asu64(R3) = d;
	R4 = 78;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("TNAME? # #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L5765:
	asi64(R1) = oldmmpos;
	pc_decls_mmpos = asi64(R1);
L5762:
	return;
}

static void mm_type_tx_bin(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 q;
	i64 amode;
	i64 bmode;
	i64 abase;
	i64 bbase;
	i64 cmode;
	i64 resmode;
	i64 relop;
	i64 simpleset;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L5791;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L5792;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L5793;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L5794;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L5795;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L5795;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L5795;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L5795;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L5795;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L5795;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L5796;
	R2 = 56;
	if (asi64(R1) == asi64(R2)) goto L5796;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L5797;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L5798;
	R2 = 81;
	if (asi64(R1) == asi64(R2)) goto L5798;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L5799;
	R2 = 54;
	if (asi64(R1) == asi64(R2)) goto L5799;
	goto L5800;
L5791:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5802;
	goto L5789;
L5802:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5804;
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = bmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5806;
	asu64(R1) = a;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5806;
	asu64(R1) = b;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5806;
	asu64(R1) = p;
	mm_type_combinestrings(asu64(R1));
	goto L5789;
L5806:
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L5808;
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 57;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = amode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5789;
L5808:
L5804:
	goto L5790;
L5792:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5810;
	goto L5789;
L5810:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5812;
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = bmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5814;
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L5816;
	R1 = 59;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5789;
	goto L5815;
L5816:
	R1 = 0;
	R2 = tou64("ref-ref: not compat");
	mm_support_txerror(asu64(R2), asu64(R1));
L5815:
L5814:
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L5818;
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 58;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = amode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5789;
L5818:
L5812:
	goto L5790;
L5793:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5820;
	goto L5789;
L5820:
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5822;
	asu64(R1) = a;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5824;
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5824;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5824;
	asu64(R1) = p;
	mm_type_mulstrings(asu64(R1));
	goto L5789;
L5824:
L5822:
	goto L5790;
L5794:
	asi64(R1) = amode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5827;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5827;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5826;
L5827:
	asi64(R1) = bmode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5828;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5828;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5826;
L5828:
	R1 = 47;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5829;
L5826:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumf(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5831;
	goto L5789;
L5831:
	asi64(R1) = amode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L5833;
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L5833;
	R1 = 1;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	goto L5789;
L5833:
	goto L5790;
L5795:
// mm_type.tx_bin.doidiv:
L5829:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumi(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5835;
	goto L5789;
L5835:
	goto L5790;
L5796:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5837;
	goto L5789;
L5837:
	goto L5790;
L5797:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5839;
	goto L5789;
L5839:
	goto L5790;
L5798:
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5789;
	goto L5790;
L5799:
	asi64(R1) = amode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5842;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5842;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L5841;
L5842:
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = amode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5789;
L5841:
	goto L5790;
L5800:
	asu64(R1) = p;
	R2 = 64;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5844;
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	asi64(R1) = mm_type_dobinnumx(asu64(R3), asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5846;
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5789;
L5846:
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5848;
	R1 = (u64)&mm_decls_ttisref;
	asi64(R2) = bmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5848;
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L5850;
	R1 = 0;
	R2 = tou64("Cmp ref/ref not compat");
	mm_support_txerror(asu64(R2), asu64(R1));
L5850:
	goto L5789;
L5848:
	asu64(R1) = p;
	R2 = 64;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5853;
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5852;
L5853:
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L5855;
	goto L5789;
L5855:
L5852:
	goto L5843;
L5844:
	R1 = 0;
	R2 = tou64("txbin?");
	mm_support_txerror(asu64(R2), asu64(R1));
L5843:
L5790:
	msysc_m$print_startcon();
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	asi64(R2) = bmode;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = amode;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("BIN/CAN'T RESOLVE MODES");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L5789:
	return;
}

static void mm_type_tx_binto(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 abase;
	i64 bbase;
	i64 amode;
	i64 bmode;
	i64 opc;
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = amode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	abase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = bmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	bbase = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 93;
	if (asi64(R1) != asi64(R2)) goto L5858;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = abase;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5858;
	R1 = 94;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L5858:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 90;
	if (asi64(R1) == asi64(R2)) goto L5860;
	R2 = 91;
	if (asi64(R1) == asi64(R2)) goto L5861;
	R2 = 99;
	if (asi64(R1) == asi64(R2)) goto L5862;
	R2 = 100;
	if (asi64(R1) == asi64(R2)) goto L5862;
	R2 = 96;
	if (asi64(R1) == asi64(R2)) goto L5862;
	R2 = 97;
	if (asi64(R1) == asi64(R2)) goto L5862;
	R2 = 98;
	if (asi64(R1) == asi64(R2)) goto L5862;
	goto L5863;
L5860:
	asi64(R1) = abase;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5865;
	asi64(R1) = bbase;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5865;
	R1 = 0;
	R2 = tou64("to:ref+ref");
	mm_support_txerror(asu64(R2), asu64(R1));
L5865:
	asi64(R1) = abase;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5867;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L5867;
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 103;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5856;
L5867:
	goto L5859;
L5861:
	asi64(R1) = abase;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5869;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L5869;
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 104;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5856;
L5869:
	goto L5859;
L5862:
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	goto L5856;
	goto L5859;
L5863:
L5859:
	asi64(R1) = abase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L5871;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L5871;
	R1 = 0;
	asi64(R2) = abase;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	goto L5870;
L5871:
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = abase;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5872;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L5872;
	R1 = 0;
	asi64(R2) = abase;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	goto L5870;
L5872:
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L5874;
	R1 = 1;
	asi64(R2) = bmode;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = amode;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("BIN: modes not compatible: # #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L5874:
L5870:
L5856:
	return;
}

static i64 mm_type_getdominantmode(i64 amode, i64 bmode) {
    u64 R1, R2; 
	i64 abase;
	i64 bbase;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = amode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	abase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = bmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	bbase = asi64(R1);
	asi64(R1) = abase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L5877;
	asi64(R1) = bbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L5877;
	asi64(R1) = abase;
	asi64(R2) = bbase;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	goto L5875;
L5877:
	asi64(R1) = bmode;
	asi64(R2) = amode;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L5879;
	R1 = 0;
	R2 = tou64("Getdom: no dominant mode");
	mm_support_txerror(asu64(R2), asu64(R1));
L5879:
	asi64(R1) = amode;
	goto L5875;
L5875:
	return asi64(R1);
}

static void mm_type_tx_cmpchain(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 u;
	i64 genop;
	u64 q;
	u64 r;
	i64 av_1;
	i64 i;
	asu64(R1) = a;
	q = asu64(R1);
	goto L5882;
L5881:
	R1 = 0;
	R2 = 23;
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	asu64(R2) = a;
	if (asu64(R1) != asu64(R2)) goto L5885;
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L5884;
L5885:
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L5884:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5882:
	asu64(R1) = q;
	if (asu64(R1)) goto L5881;
	asu64(R1) = a;
	q = asu64(R1);
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	r = asu64(R1);
	goto L5887;
L5886:
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = q;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5887:
	asu64(R1) = q;
	if (asu64(R1)) goto L5886;
	R1 = 1;
	i = asi64(R1);
	R1 = 4;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5891;
L5889:
	asu64(R1) = p;
	R2 = 40;
	R1 += (i64)R2;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2-1));
	R1 = toi64(tou8(R1));
	genop = asi64(R1);
	asi64(R1) = genop;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L5893;
	goto L5891;
L5893:
	asi64(R1) = u;
	asi64(R1) = mm_lib_getpclmode(asi64(R1));
	asu64(R2) = p;
	R3 = 32;
	R2 += (i64)R3;
	asi64(R3) = i;
	*toi16p(((i64)R2+(i64)R3*2-2)) = asi16(R1);
	i += 1; if (i <= av_1) goto L5889;
L5891:
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_callproc(u64 p, u64 a, u64 pargs, i64 t) {
    u64 R1, R2, R3, R4; 
	u64 q;
	u64 d;
	u64 e;
	u64 pm;
	struct $B76 paramlist;
	struct $B76 arglist;
	struct $B76 newarglist;
	i64 nparams;
	i64 i;
	i64 j;
	i64 k;
	i64 nargs;
	i64 m;
	i64 kwdused;
	i64 qm;
	i64 ismproc;
	u64 name;
	u64 ulist;
	u64 ulistx;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = R1;
	nparams = asi64(R2);
	nargs = asi64(R1);
	R1 = 0;
	ismproc = asi64(R1);
// mm_type.tx_callproc.retry:
L5895:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5897;
	R2 = 92;
	if (asi64(R1) == asi64(R2)) goto L5898;
	R2 = 112;
	if (asi64(R1) == asi64(R2)) goto L5898;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5898;
	goto L5899;
L5897:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5902;
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L5901;
L5902:
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 6;
	asi64(R1) = asi64(R1)  ==  asi64(R2);
	ismproc = asi64(R1);
// mm_type.tx_callproc.getparams:
L5903:
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	goto L5905;
L5904:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L5908;
	asi64(R1) = nparams;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L5910;
	R1 = 0;
	R2 = tou64("Param overflow");
	mm_support_txerror(asu64(R2), asu64(R1));
L5910:
	asu64(R1) = e;
	R2 = (u64)&paramlist;
	R3 = (u64)&nparams;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5908:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L5905:
	asu64(R1) = e;
	if (asu64(R1)) goto L5904;
	goto L5900;
L5901:
	goto L5912;
L5911:
	R1 = 53;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5912:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5911;
	goto L5914;
L5900:
	goto L5896;
L5898:
	R1 = 0;
	R2 = tou64("Can't do ifx/function");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L5896;
L5899:
// mm_type.tx_callproc.dorefproc:
L5914:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 49;
	if (asi64(R1) != asi64(R2)) goto L5916;
	asu64(R1) = pargs;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tmethodcall(asu64(R3), asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pargs = asu64(R1);
	goto L5895;
L5916:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L5918;
	R1 = 0;
	R2 = tou64("Function pointer expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L5918:
	R1 = (u64)&mm_decls_ttnamedef;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5920;
	R1 = 0;
	R2 = tou64("Function expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L5920:
	goto L5903;
L5896:
	asu64(R1) = pargs;
	q = asu64(R1);
	goto L5922;
L5921:
	asi64(R1) = nargs;
	R2 = 100;
	if (asi64(R1) < asi64(R2)) goto L5925;
	R1 = 0;
	R2 = tou64("Param overflow");
	mm_support_txerror(asu64(R2), asu64(R1));
L5925:
	asu64(R1) = q;
	R2 = (u64)&arglist;
	R3 = (u64)&nargs;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L5922:
	asu64(R1) = q;
	if (asu64(R1)) goto L5921;
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	if (!asi32(R1)) goto L5927;
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L5927;
	R1 = 0;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
L5927:
	asu64(R1) = d;
	R2 = 123;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L5929;
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5932;
L5930:
	asi64(R1) = i;
	asi64(R2) = nparams;
	if (asi64(R1) > asi64(R2)) goto L5934;
	R1 = 0;
	R2 = (u64)&paramlist;
	asi64(R3) = i;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = (u64)&arglist;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L5933;
L5934:
	R1 = 0;
	R2 = 23;
	R3 = (u64)&arglist;
	asi64(R4) = i;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4*8-8));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L5933:
	i += 1; if (i <= nargs) goto L5930;
L5932:
	goto L5894;
L5929:
	R1 = 0;
	k = asi64(R1);
	R1 = 0;
	kwdused = asi64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5937;
L5935:
	R1 = 0;
	R2 = (u64)&newarglist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	i += 1; if (i <= nparams) goto L5935;
L5937:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nargs;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5940;
L5938:
	R1 = (u64)&arglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L5942;
	goto L5943;
L5942:
	asu64(R1) = q;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	name = asu64(R1);
	R1 = 1;
	j = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5947;
L5944:
	asu64(R1) = name;
	R2 = (u64)&paramlist;
	asi64(R3) = j;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8-8));
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asi64(R1) = mlib_eqstring(asu64(R2), asu64(R1));
	if (!asi64(R1)) goto L5949;
	goto L5946;
L5949:
	j += 1; if (j <= nparams) goto L5944;
L5947:
	R1 = 0;
	asu64(R2) = name;
	R3 = tou64("Can't find kwd param: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L5946:
	R1 = (u64)&newarglist;
	asi64(R2) = j;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	if (!asu64(R1)) goto L5951;
	R1 = 0;
	asu64(R2) = name;
	R3 = tou64("Kwd: # already used or was implicit");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L5951:
	asu64(R1) = q;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = (u64)&newarglist;
	asi64(R3) = j;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 1;
	kwdused = asi64(R1);
	goto L5941;
L5943:
	asi64(R1) = kwdused;
	if (!asi64(R1)) goto L5953;
	R1 = 0;
	R2 = tou64("Normal param follows kwd");
	mm_support_txerror(asu64(R2), asu64(R1));
L5953:
	asi64(R1) = k;
	asi64(R2) = nparams;
	if (asi64(R1) < asi64(R2)) goto L5955;
	msysc_m$print_startcon();
	R1 = tou64("K=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = k;
	msysc_m$print_i64_nf(asi64(R1));
	R1 = tou64("NPARAMS=");
	msysc_m$print_str_nf(asu64(R1));
	asi64(R1) = nparams;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Too many params supplied");
	mm_support_txerror(asu64(R2), asu64(R1));
L5955:
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L5957;
	R1 = 0;
	goto L5956;
L5957:
	asu64(R1) = q;
L5956:
	R2 = (u64)&newarglist;
	R3 = (u64)&k;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5941:
	i += 1; if (i <= nargs) goto L5938;
L5940:
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5960;
L5958:
	R1 = (u64)&newarglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pm = asu64(R1);
	asu64(R1) = q;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L5962;
	asu64(R1) = pm;
	R2 = 161;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L5964;
	R1 = 0;
	R2 = 0;
	asi64(R3) = i;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Param not optional: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L5964:
	asu64(R1) = pm;
	R2 = 64;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	if (!asu64(R1)) goto L5966;
	asu64(R1) = p;
	R2 = 4;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = pm;
	R3 = 64;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	R2 = (u64)&newarglist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L5965;
L5966:
	R1 = 3;
	R2 = 0;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	R2 = (u64)&newarglist;
	asi64(R3) = i;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L5965:
L5962:
	i += 1; if (i <= nparams) goto L5958;
L5960:
	R1 = 0;
	ulist = asu64(R1);
	R1 = 0;
	ulistx = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nparams;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L5969;
L5967:
	R1 = (u64)&paramlist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	pm = asu64(R1);
	R1 = (u64)&newarglist;
	asi64(R2) = i;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	q = asu64(R1);
	asu64(R1) = pm;
	R2 = 160;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L5971;
	R1 = 1;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = pm;
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	R3 = R2;
	m = asi64(R3);
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	qm = asi64(R1);
	asi64(R1) = m;
	asi64(R2) = qm;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L5973;
	R1 = 1;
	asi64(R2) = m;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = qm;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("&param: type mismatch");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L5973:
	R1 = 55;
	asu64(R2) = q;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = pm;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = q;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L5970;
L5971:
	R1 = 0;
	asu64(R2) = pm;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L5970:
	asu64(R1) = q;
	R2 = (u64)&ulistx;
	R3 = (u64)&ulist;
	mm_lib_addlistunit(asu64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	asu64(R2) = q;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	i += 1; if (i <= nparams) goto L5967;
L5969:
	asu64(R1) = ulist;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L5894:
	return;
}

static void mm_type_tx_unary(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 opc;
	i64 size;
	i64 amode;
	i64 mbase;
	i64 tmax;
	i64 x;
	i64 xhigh;
	i64 resmode;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asi64(R1) = amode;
	resmode = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L5976;
	R2 = 74;
	if (asi64(R1) == asi64(R2)) goto L5976;
	R2 = 75;
	if (asi64(R1) == asi64(R2)) goto L5976;
	R2 = 76;
	if (asi64(R1) == asi64(R2)) goto L5976;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L5976;
	R2 = 68;
	if (asi64(R1) == asi64(R2)) goto L5976;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L5976;
	R2 = 70;
	if (asi64(R1) == asi64(R2)) goto L5976;
	R2 = 71;
	if (asi64(R1) == asi64(R2)) goto L5976;
	R2 = 72;
	if (asi64(R1) == asi64(R2)) goto L5976;
	R2 = 78;
	if (asi64(R1) == asi64(R2)) goto L5976;
	R2 = 79;
	if (asi64(R1) == asi64(R2)) goto L5976;
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L5977;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L5977;
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L5977;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L5978;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L5978;
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L5978;
	R2 = 80;
	if (asi64(R1) == asi64(R2)) goto L5979;
	goto L5980;
L5976:
	R1 = 0;
	R2 = 1;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	resmode = asi64(R1);
	goto L5975;
L5977:
	asi64(R1) = amode;
	R2 = 5;
	if (asi64(R1) <= asi64(R2)) goto L5982;
	R1 = 0;
	R2 = tou64("not num");
	mm_support_txerror(asu64(R2), asu64(R1));
L5982:
	goto L5975;
L5978:
	asi64(R1) = amode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L5984;
	R1 = 0;
	R2 = tou64("toboolt");
	mm_support_txerror(asu64(R2), asu64(R1));
L5984:
	goto L5975;
L5979:
	R1 = 3;
	resmode = asi64(R1);
	goto L5975;
L5980:
	msysc_m$print_startcon();
	R1 = tou64("TTT");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5975:
	asi64(R1) = resmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_prop(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 opc;
	i64 size;
	i64 amode;
	i64 mbase;
	i64 tmax;
	i64 x;
	i64 xhigh;
	i64 resmode;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asi64(R1) = amode;
	resmode = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L5987;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L5987;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L5987;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L5987;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L5987;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L5988;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L5988;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L5989;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L5989;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L5990;
	goto L5991;
L5987:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_type_do_bounds(asu64(R2), asu64(R1));
	goto L5985;
	goto L5986;
L5988:
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = a;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 62;
	if (asi64(R2) != asi64(R3)) goto L5993;
	asu64(R2) = a;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	goto L5992;
L5993:
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
L5992:
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 7;
	if (asi64(R2) != asi64(R3)) goto L5995;
	R2 = 1;
	goto L5994;
L5995:
	R2 = 8;
L5994:
	asi64(R1) *= asi64(R2);
	size = asi64(R1);
	R1 = 0;
	asi64(R2) = size;
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	resmode = asi64(R1);
	goto L5986;
L5989:
	R1 = 3;
	resmode = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L5997;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mbase = asi64(R1);
	goto L5996;
L5997:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mbase = asi64(R1);
L5996:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 9;
	if (asi64(R1) != asi64(R2)) goto L5999;
	asi64(R1) = mbase;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6001;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6002;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6003;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6004;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6005;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6005;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6005;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6005;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6005;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6005;
	goto L6006;
L6001:
	R1 = -128;
	x = asi64(R1);
	goto L6000;
L6002:
	R1 = -32768;
	x = asi64(R1);
	goto L6000;
L6003:
	R1 = -2147483648;
	x = asi64(R1);
	goto L6000;
L6004:
	R1 = 0x8000000000000000;
	x = asi64(R1);
	goto L6000;
L6005:
	R1 = 0;
	x = asi64(R1);
	goto L6000;
L6006:
	R1 = 0;
	R2 = 1;
	asi64(R3) = mbase;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't do minvalue on #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L6000:
	goto L5998;
L5999:
	asi64(R1) = mbase;
	R2 = 14;
	if (asi64(R1) == asi64(R2)) goto L6008;
	R2 = 15;
	if (asi64(R1) == asi64(R2)) goto L6009;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6010;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6011;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6012;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6012;
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6013;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6014;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6015;
	goto L6016;
L6008:
	R1 = 127;
	x = asi64(R1);
	goto L6007;
L6009:
	R1 = 32767;
	x = asi64(R1);
	goto L6007;
L6010:
	R1 = 2147483647;
	x = asi64(R1);
	goto L6007;
L6011:
	R1 = 9223372036854775807;
	x = asi64(R1);
	goto L6007;
L6012:
	R1 = 255;
	x = asi64(R1);
	goto L6007;
L6013:
	R1 = 65535;
	x = asi64(R1);
	goto L6007;
L6014:
	R1 = 4294967295;
	x = asi64(R1);
	goto L6007;
L6015:
	R1 = 0;
	x = asi64(R1);
	R1 = (u64)&x;
	(*toi64p(R1)) -=1;
	R1 = 4;
	resmode = asi64(R1);
	goto L6007;
L6016:
	R1 = 0;
	R2 = 1;
	asi64(R3) = mbase;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't do maxvalue on #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L6007:
L5998:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L5986;
L5990:
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L6018;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	amode = asi64(R1);
	goto L6017;
L6018:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
L6017:
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asi64(R2) = amode;
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	asu64(R1) = mlib_pcm_copyheapstring(asu64(R1));
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 44;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asi64(R1) = strlen(asu64(R1));
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	goto L5985;
	goto L5986;
L5991:
	msysc_m$print_startcon();
	R1 = tou64("PROP");
	msysc_m$print_str_nf(asu64(R1));
	R1 = (u64)&pc_tables_pclnames;
	asu64(R2) = p;
	R3 = 62;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
L5986:
	asi64(R1) = resmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L5985:
	return;
}

static void mm_type_tx_unaryto(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 107;
	if (asi64(R1) == asi64(R2)) goto L6021;
	R2 = 108;
	if (asi64(R1) == asi64(R2)) goto L6021;
	R2 = 109;
	if (asi64(R1) == asi64(R2)) goto L6021;
	goto L6022;
L6021:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L6024;
	R1 = 0;
	R2 = tou64("Not int");
	mm_support_txerror(asu64(R2), asu64(R1));
L6024:
	goto L6020;
L6022:
L6020:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_if(u64 p, u64 pcond, u64 plist, u64 pelse, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	u64 pc;
	u64 pl;
	i64 u;
	asu64(R1) = pcond;
	pc = asu64(R1);
	asu64(R1) = plist;
	pl = asu64(R1);
	R1 = 0;
	u = asi64(R1);
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L6027;
	asi64(R1) = t;
	u = asi64(R1);
L6027:
	goto L6031;
L6028:
	R1 = 0;
	R2 = 23;
	asu64(R3) = pc;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = pl;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L6033;
	asi64(R1) = u;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6035;
	asu64(R1) = pl;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L6034;
L6035:
	asi64(R1) = lv;
	if (!asi64(R1)) goto L6036;
	asu64(R1) = pl;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L6038;
	R1 = 0;
	R2 = tou64("IF/LV?");
	mm_support_txerror(asu64(R2), asu64(R1));
L6038:
	goto L6034;
L6036:
	asu64(R1) = pl;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L6034:
L6033:
	asu64(R1) = pc;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pc = asu64(R1);
	asu64(R1) = pl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pl = asu64(R1);
L6031:
	asu64(R1) = pc;
	if (asu64(R1)) goto L6028;
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6040;
	asu64(R1) = pelse;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6040;
	R1 = 0;
	R2 = tou64("else needed");
	mm_support_txerror(asu64(R2), asu64(R1));
L6040:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = pelse;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L6042;
	asi64(R1) = lv;
	if (!asi64(R1)) goto L6044;
	asu64(R1) = pelse;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L6046;
	R1 = 0;
	R2 = tou64("IF/LV2?");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L6045;
L6046:
	asu64(R1) = pelse;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L6045:
L6044:
L6042:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6048;
	asu64(R1) = plist;
	pl = asu64(R1);
	goto L6052;
L6049:
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L6054;
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pl;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L6054:
	asu64(R1) = pl;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pl = asu64(R1);
L6052:
	asu64(R1) = pl;
	if (asu64(R1)) goto L6049;
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L6056;
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pelse;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L6056:
	asi64(R1) = u;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6048:
	asu64(R1) = pcond;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = plist;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asu64(R1) != asu64(R2)) goto L6058;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6058;
	asu64(R1) = pcond;
	asi64(R1) = mm_type_iscondtrue(asu64(R1));
	if (!asi64(R1)) goto L6060;
	asu64(R1) = plist;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L6059;
L6060:
	asu64(R1) = pcond;
	asi64(R1) = mm_type_iscondfalse(asu64(R1));
	if (!asi64(R1)) goto L6061;
	asu64(R1) = pelse;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6063;
	R1 = 6;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	pelse = asu64(R1);
L6063:
	asu64(R1) = pelse;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L6061:
L6059:
L6058:
	return;
}

static void mm_type_tx_incrto(u64 p, u64 a, i64 t) {
    u64 R1, R2, R3; 
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6066;
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 84;
	if (asi64(R1) == asi64(R2)) goto L6068;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L6069;
	goto L6070;
L6068:
	R1 = 86;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6067;
L6069:
	R1 = 87;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6067;
L6070:
L6067:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6065;
L6066:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 88;
	if (asi64(R1) == asi64(R2)) goto L6072;
	R2 = 89;
	if (asi64(R1) == asi64(R2)) goto L6073;
	goto L6074;
L6072:
	R1 = 84;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6071;
L6073:
	R1 = 85;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6071;
L6074:
L6071:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6065:
	R1 = 0;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	return;
}

static void mm_type_tx_for(u64 pindex, u64 pfrom, u64 pbody) {
    u64 R1, R2, R3, R4; 
	u64 pto;
	u64 pstep;
	u64 plocal;
	u64 plist;
	i64 u;
	asu64(R1) = pfrom;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	asu64(R1) = pto;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pstep = asu64(R1);
	R1 = 0;
	R2 = 23;
	asu64(R3) = pindex;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = pindex;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6077;
	R1 = 0;
	R2 = tou64("Loop index not a variable");
	mm_support_txerror(asu64(R2), asu64(R1));
L6077:
	asu64(R1) = pindex;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	R1 = 0;
	R2 = 23;
	asu64(R3) = pindex;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pfrom;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pto;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = pstep;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = pbody;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = pbody;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mm_type_tx_forall(u64 pindex, u64 plist, u64 pbody) {
    u64 R1, R2, R3, R4; 
	u64 plocal;
	u64 pfrom;
	u64 pto;
	u64 passign;
	i64 u;
	i64 mlist;
	i64 elemtype;
	asu64(R1) = pindex;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	plocal = asu64(R1);
	asu64(R1) = plocal;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfrom = asu64(R1);
	asu64(R1) = pfrom;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pto = asu64(R1);
	asu64(R1) = plist;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	passign = asu64(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = pindex;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = pfrom;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = pto;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = plist;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = plist;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mlist = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = mlist;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6080;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6081;
	goto L6082;
L6080:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = mlist;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	elemtype = asi64(R1);
	goto L6079;
L6081:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = mlist;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	elemtype = asi64(R1);
	goto L6079;
L6082:
	R1 = 0;
	R2 = tou64("forall/can't iterate");
	mm_support_txerror(asu64(R2), asu64(R1));
L6079:
	R1 = 0;
	R2 = 23;
	asu64(R3) = plocal;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = plocal;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L6084;
	asi64(R1) = elemtype;
	asu64(R2) = plocal;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = elemtype;
	asu64(R2) = plocal;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6084:
	R1 = 0;
	R2 = 23;
	asu64(R3) = passign;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = pbody;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 0;
	asu64(R3) = pbody;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	return;
}

static void mm_type_tx_index(u64 p, u64 a, u64 b, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 emode;
	i64 pmode;
	i64 tmode;
	i64 tbasemode;
	asi64(R1) = lv;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	asu64(R2) = a;
	mm_type_deref(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = amode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6087;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6087;
	R1 = 0;
	R2 = 1;
	asi64(R3) = amode;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't index: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L6087:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = amode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	return;
}

static void mm_type_tx_makerange(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 bmode;
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 9;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_ptr(u64 p, u64 a, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	u64 d;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6091;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6092;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6093;
	goto L6094;
L6091:
	R1 = 0;
	R2 = tou64("Deref Void");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L6090;
L6092:
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6090;
L6093:
	msysc_m$print_startcon();
	R1 = tou64("DEREF SLICE");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L6090;
L6094:
	R1 = 0;
	R2 = tou64("PTR: need ref T");
	mm_support_txerror(asu64(R2), asu64(R1));
L6090:
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	return;
}

static void mm_type_setrecordsize(i64 m) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	struct $B69 fieldlist;
	i64 i;
	i64 nfields;
	i64 indent;
	i64 nrfields;
	i64 size;
	i64 index;
	i64 maxalign;
	u64 d;
	u64 e;
	u64 flags;
	i64 flag;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	if (!asu32(R1)) goto L6097;
	goto L6095;
L6097:
	R1 = (u64)&mm_type_setrecordsize_depth;
	asi64(R1) = *(toi64p(R1)) += 1;
	R2 = 10;
	if (asi64(R1) <= asi64(R2)) goto L6099;
	R1 = tou64("Recursive record?");
	mm_support_serror(asu64(R1));
L6099:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	nfields = asi64(R1);
	R1 = 83;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6101;
L6100:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6104;
	asi64(R1) = nfields;
	R2 = 200;
	if (asi64(R1) < asi64(R2)) goto L6106;
	R1 = 0;
	R2 = tou64("srs:too many fields");
	mm_support_gerror(asu64(R2), asu64(R1));
L6106:
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mm_type_setmodesize(asi64(R1));
	asu64(R1) = e;
	R2 = 136;
	R1 += (i64)R2;
	flags = asu64(R1);
L6107:
	asu64(R1) = flags;
	asu8(R1) = *tou8p(R1);
	R1 = tou64(tou8(R1));
	R2 = 83;
	if (asu64(R1) == asu64(R2)) goto L6109;
	R2 = 85;
	if (asu64(R1) == asu64(R2)) goto L6109;
	goto L6110;
L6109:
	asu64(R1) = flags;
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	flag = asi64(R1);
	asi64(R1) = flag;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = (u64)&flags;
	(*tou64p(R1)) += 1;
	goto L6107;
L6110:
	goto L6108;
	goto L6107;
L6108:
	asu64(R1) = e;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
L6111:
	R1 = (u64)&flags;
	asu64(R2) = *tou64p(R1); *(tou64p(R1)) += 1; asu64(R1) = asu64(R2);
	asu8(R1) = *tou8p(R1);
	R1 = toi64(tou8(R1));
	flag = asi64(R1);
	asi64(R1) = flag;
	R2 = 42;
	if (asi64(R1) == asi64(R2)) goto L6114;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L6115;
	goto L6116;
L6114:
	goto L6113;
L6115:
	R1 = 69;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	goto L6113;
L6116:
	goto L6112;
L6113:
	goto L6111;
L6112:
L6104:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L6101:
	asu64(R1) = e;
	if (asu64(R1)) goto L6100;
	R1 = 69;
	R2 = (u64)&fieldlist;
	R3 = (u64)&nfields;
	asi64(R3) = *(toi64p(R3)) += 1;
	*tou64p(((i64)R2+(i64)R3*8-8)) = asu64(R1);
	R1 = 0;
	R2 = (u64)&fieldlist;
	asi64(R3) = nfields;
	*tou64p(((i64)R2+(i64)R3*8)) = asu64(R1);
	R1 = 0;
	mm_type_countedfields = asi64(R1);
	R1 = 2;
	index = asi64(R1);
	R1 = 1;
	maxalign = asi64(R1);
	R1 = (u64)&maxalign;
	asu64(R2) = d;
	R3 = 149;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	R3 = 0;
	R4 = (u64)&size;
	R5 = (u64)&index;
	R6 = (u64)&fieldlist;
	R7 = 83;
	mm_type_scanrecord(asi64(R7), asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	asu64(R1) = d;
	R2 = 149;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6118;
	asi64(R1) = maxalign;
	asi64(R2) = size;
	asi64(R1) = mm_type_roundoffset(asi64(R2), asi64(R1));
	size = asi64(R1);
	asi64(R1) = maxalign;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L6117;
L6118:
	R1 = 1;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	asi64(R1) = size;
	R2 = 7;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6120;
	R1 = 8;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L6119;
L6120:
	asi64(R1) = size;
	R2 = 3;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6121;
	R1 = 4;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
	goto L6119;
L6121:
	asi64(R1) = size;
	R2 = 1;
	asi64(R1) &= asi64(R2);
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6122;
	R1 = 2;
	asu64(R2) = d;
	R3 = 166;
	*toi16p(((i64)R2+(i64)R3)) = asi16(R1);
L6122:
L6119:
L6117:
	asi64(R1) = size;
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = m;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	asi64(R1) = mm_type_countedfields;
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	R1 = 1;
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = m;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asi64(R1) = m;
	mm_type_checkblocktype(asi64(R1));
	R1 = (u64)&mm_type_setrecordsize_depth;
	(*toi64p(R1)) -=1;
L6095:
	return;
}

static void mm_type_checkblocktype(i64 m) {
    u64 R1, R2, R3; 
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = m;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6125;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6125;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6125;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6125;
	goto L6126;
L6125:
	R1 = 0;
	R2 = (u64)&mm_decls_ttisblock;
	asi64(R3) = m;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6124;
L6126:
L6124:
	return;
}

static void mm_type_scanrecord(i64 state, u64 fields, u64 index, u64 isize, i64 offset, i64 calign, u64 maxalign) {
    u64 R1, R2, R3, R4, R5, R6, R7; 
	u64 e;
	u64 f;
	u64 ea;
	i64 size;
	i64 fieldsize;
	i64 bitoffset;
	i64 alignment;
	i64 newoffset;
	R1 = 0;
	size = asi64(R1);
	R1 = 0;
	bitoffset = asi64(R1);
	goto L6129;
L6128:
	asu64(R1) = f;
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L6132;
	R2 = 85;
	if (asi64(R1) == asi64(R2)) goto L6132;
	R2 = 69;
	if (asi64(R1) == asi64(R2)) goto L6133;
	goto L6134;
L6132:
	asu64(R1) = maxalign;
	asi64(R2) = calign;
	asi64(R3) = offset;
	R4 = (u64)&fieldsize;
	asu64(R5) = index;
	asu64(R6) = fields;
	asu64(R7) = f;
	mm_type_scanrecord(asi64(R7), asu64(R6), asu64(R5), asu64(R4), asi64(R3), asi64(R2), asu64(R1));
	goto L6131;
L6133:
	asi64(R1) = state;
	R2 = 85;
	if (asi64(R1) != asi64(R2)) goto L6136;
	R1 = (u64)&mm_type_countedfields;
	(*toi64p(R1)) += 1;
L6136:
	asi64(R1) = size;
	asu64(R2) = isize;
	*toi64p(R2) = asi64(R1);
	goto L6127;
	goto L6131;
L6134:
	asu64(R1) = f;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L6138;
	R1 = 0;
	fieldsize = asi64(R1);
	asu64(R1) = f;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	ea = asu64(R1);
	asu64(R1) = ea;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = f;
	R3 = 84;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = bitoffset;
	asu64(R2) = f;
	R3 = 150;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = f;
	R2 = 148;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = (u64)&bitoffset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = bitoffset;
	R2 = (u64)&mm_decls_ttsize;
	asu64(R3) = f;
	R4 = 128;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	R4 = 72;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	R3 = 8;
	asi64(R2) *= asi64(R3);
	if (asi64(R1) <= asi64(R2)) goto L6140;
	R1 = 0;
	R2 = tou64("Bit fields overflow type");
	mm_support_txerror(asu64(R2), asu64(R1));
L6140:
	goto L6137;
L6138:
	asu64(R1) = f;
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 7;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6141;
	R1 = 0;
	bitoffset = asi64(R1);
	asu64(R1) = f;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	R1 = 0;
	fieldsize = asi64(R1);
	asu64(R1) = e;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = f;
	R3 = 151;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	asu64(R2) = f;
	R3 = 84;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6137;
L6141:
	R1 = 0;
	bitoffset = asi64(R1);
	asi64(R1) = state;
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L6143;
	R1 = (u64)&mm_type_countedfields;
	(*toi64p(R1)) += 1;
L6143:
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = f;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	fieldsize = asi64(R1);
	asi64(R1) = calign;
	if (!asi64(R1)) goto L6145;
	asu64(R1) = f;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R1) = mm_lib_getalignment(asi64(R1));
	alignment = asi64(R1);
	asi64(R1) = alignment;
	asu64(R2) = maxalign;
	asi64(R2) = *toi64p(R2);
	if (asi64(R1) <= asi64(R2)) goto L6147;
	asi64(R1) = alignment;
	asu64(R2) = maxalign;
	*toi64p(R2) = asi64(R1);
L6147:
	asi64(R1) = alignment;
	asi64(R2) = offset;
	asi64(R1) = mm_type_roundoffset(asi64(R2), asi64(R1));
	newoffset = asi64(R1);
	asi64(R1) = newoffset;
	asi64(R2) = offset;
	asi64(R1) -= asi64(R2);
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	goto L6144;
L6145:
	asi64(R1) = offset;
	newoffset = asi64(R1);
L6144:
	asi64(R1) = newoffset;
	asu64(R2) = f;
	R3 = 84;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = newoffset;
	offset = asi64(R1);
L6137:
L6131:
	asi64(R1) = state;
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L6149;
	asi64(R1) = fieldsize;
	R2 = (u64)&offset;
	*toi64p(R2) += asi64(R1);
	asi64(R1) = fieldsize;
	R2 = (u64)&size;
	*toi64p(R2) += asi64(R1);
	goto L6148;
L6149:
	asi64(R1) = size;
	asi64(R2) = fieldsize;
	asi64(R1) = Max(asi64(R1), asi64(R2));
	size = asi64(R1);
L6148:
L6129:
	asu64(R1) = fields;
	asu64(R2) = index;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) += 1; asi64(R2) = asi64(R3);
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8-8));
	R2 = R1;
	f = asu64(R2);
	if (asu64(R1)) goto L6128;
L6127:
	return;
}

static i64 mm_type_roundoffset(i64 offset, i64 alignment) {
    u64 R1, R2; 
	i64 mask;
	asi64(R1) = alignment;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6152;
	asi64(R1) = offset;
	goto L6150;
L6152:
	asi64(R1) = alignment;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	mask = asi64(R1);
	goto L6154;
L6153:
	R1 = (u64)&offset;
	(*toi64p(R1)) += 1;
L6154:
	asi64(R1) = offset;
	asi64(R2) = mask;
	asi64(R1) &= asi64(R2);
	if (asi64(R1)) goto L6153;
	asi64(R1) = offset;
	goto L6150;
L6150:
	return asi64(R1);
}

static void mm_type_tx_convert(u64 p, u64 a, i64 hard) {
    u64 R1, R2, R3, R4; 
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6158;
	goto L6159;
L6158:
	R1 = 0;
	asu64(R2) = p;
	R3 = 53;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = a;
	mm_type_tx_makelist(asu64(R4), asu64(R3), asi64(R2), asi64(R1));
	goto L6157;
L6159:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = hard;
	asu64(R2) = p;
	R3 = 53;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L6157:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	return;
}

static void mm_type_tx_makelist(u64 p, u64 a, i64 t, i64 lv) {
    u64 R1, R2, R3, R4, R5; struct $B56 R1_B56; 
	i64 alength;
	i64 tlength;
	i64 elemtype;
	i64 newt;
	i64 i;
	i64 nfields;
	i64 isconst;
	i64 m;
	u64 q;
	u64 b;
	u64 e;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	alength = asi64(R1);
	R1 = 0;
	newt = asi64(R1);
	R1 = 1;
	isconst = asi64(R1);
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tlength = asi64(R1);
	asi64(R1) = tlength;
	if (!asi64(R1)) goto L6162;
	asi64(R1) = alength;
	asi64(R2) = tlength;
	if (asi64(R1) >= asi64(R2)) goto L6164;
	R1 = 0;
	asi64(R2) = tlength;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = 0;
	asi64(R3) = alength;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Too few elements");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
	goto L6163;
L6164:
	asi64(R1) = alength;
	asi64(R2) = tlength;
	if (asi64(R1) <= asi64(R2)) goto L6165;
	R1 = 0;
	asi64(R2) = tlength;
	asu64(R1) = msysc_strint(asi64(R2), asu64(R1));
	R2 = 0;
	asi64(R3) = alength;
	asu64(R2) = msysc_strint(asi64(R3), asu64(R2));
	R3 = tou64("Too many elements");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L6165:
L6163:
L6162:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6167;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6168;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6169;
	goto L6170;
L6167:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	elemtype = asi64(R1);
	asi64(R1) = tlength;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6172;
	R1 = 0;
	asi64(R2) = alength;
	R3 = (u64)&mm_decls_ttlower;
	asi64(R4) = t;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asi64(R4) = elemtype;
	R5 = 0;
	asi64(R1) = mm_lib_createarraymodek(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	newt = asi64(R1);
	goto L6171;
L6172:
	asi64(R1) = t;
	newt = asi64(R1);
L6171:
	asu64(R1) = a;
	q = asu64(R1);
	goto L6174;
L6173:
	asi64(R1) = lv;
	asi64(R2) = elemtype;
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6177;
	R1 = 0;
	isconst = asi64(R1);
L6177:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6174:
	asu64(R1) = q;
	if (asu64(R1)) goto L6173;
	asi64(R1) = newt;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6166;
L6168:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = a;
	q = asu64(R1);
	goto L6179;
L6178:
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6182;
	goto L6184;
L6183:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
	asu64(R1) = e;
	if (asu64(R1)) goto L6187;
	goto L6185;
L6187:
L6184:
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6183;
L6185:
	asi64(R1) = lv;
	asu64(R2) = e;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6189;
	R1 = 0;
	isconst = asi64(R1);
L6189:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6182:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L6179:
	asu64(R1) = q;
	if (!asu64(R1)) goto L6190;
	asu64(R1) = e;
	if (asu64(R1)) goto L6178;
L6190:
	goto L6192;
L6191:
	asu64(R1) = e;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	e = asu64(R1);
L6192:
	asu64(R1) = e;
	if (!asu64(R1)) goto L6194;
	asu64(R1) = e;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 13;
	if (asi64(R1) != asi64(R2)) goto L6191;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) == asi64(R2)) goto L6191;
L6194:
	asu64(R1) = q;
	if (asu64(R1)) goto L6197;
	asu64(R1) = e;
	if (!asu64(R1)) goto L6196;
L6197:
	R1 = 0;
	R2 = tou64("Can't initialise unions");
	mm_support_txerror(asu64(R2), asu64(R1));
L6196:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6166;
L6169:
	msysc_m$print_startcon();
	R1 = tou64("TSLICE");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	goto L6166;
L6170:
	R1 = 0;
	R2 = 1;
	asi64(R3) = t;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Unknown makelist type: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L6166:
	asi64(R1) = isconst;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = p;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6199;
	asi64(R1) = mm_type_inidata;
	if (asi64(R1)) goto L6201;
	asi64(R1) = isconst;
	if (!asi64(R1)) goto L6201;
	R1 = 10;
	asu64(R2) = mm_decls_currproc;
	asu64(R1) = mm_lib_getavname(asu64(R2), asi64(R1));
	e = asu64(R1);
	asi64(R1) = t;
	asu64(R2) = e;
	R3 = 72;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = e;
	mm_lib_addstatic(asu64(R1));
	R1 = 0;
	asu64(R1) = mm_lib_createunit0(asi64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	(R1_B56) = *(struct $B56*)(R1);
	asu64(R2) = q;
	*(struct $B56*)(R2) = (R1_B56);
	asu64(R1) = q;
	asu64(R2) = e;
	R3 = 64;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 4;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = e;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6201:
L6199:
	return;
}

static void mm_type_tx_makeslicefromlist(u64 p, u64 a, i64 t) {
    u64 R1, R2; 
	msysc_m$print_startcon();
	R1 = tou64("MAKESLICE/TX");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("MAKESLICE FROM LIST NOT READY");
	mm_support_txerror(asu64(R2), asu64(R1));
	return;
}

static void mm_type_tx_makeslice(u64 p, u64 a, u64 b, i64 t) {
    u64 R1, R2, R3; 
	msysc_m$print_startcon();
	R1 = tou64("MAKESLICE/TX");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6205;
	R1 = 0;
	R2 = tou64("slice init not ref");
	mm_support_txerror(asu64(R2), asu64(R1));
L6205:
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6207;
	R1 = 0;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = t;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L6209;
	R1 = 0;
	R2 = tou64("slice/ptr mismatch");
	mm_support_txerror(asu64(R2), asu64(R1));
L6209:
L6207:
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	msysc_m$print_startcon();
	R1 = tou64("MKSLICE2");
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tx_makeset(u64 p, u64 a, i64 t) {
    u64 R1, R2, R3; 
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6214;
L6211:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6216;
	R1 = 0;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6216:
	asu64(R1) = a;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
L6214:
	asu64(R1) = a;
	if (asu64(R1)) goto L6211;
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_dot(u64 p, u64 a, u64 b, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 recmode;
	i64 recbasemode;
	i64 i;
	i64 j;
	i64 newtag;
	i64 tmode;
	u64 q;
	u64 pindex;
	u64 d;
	u64 dequiv;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	recmode = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = recmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	recbasemode = asi64(R1);
	goto L6219;
L6218:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = recmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tmode = asi64(R1);
	R1 = 53;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = tmode;
	R2 = R1;
	asu64(R3) = a;
	R4 = 49;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	recmode = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = recmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	recbasemode = asi64(R1);
L6219:
	asi64(R1) = recbasemode;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6218;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = recmode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6222;
	R1 = 0;
	R2 = tou64("Bad record type");
	mm_support_txerror(asu64(R2), asu64(R1));
L6222:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 78;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6224;
	asi64(R1) = recmode;
	asu64(R2) = d;
	asu64(R1) = mm_type_resolvefield(asu64(R2), asi64(R1));
	R2 = R1;
	asu64(R3) = b;
	R4 = 16;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	d = asu64(R1);
L6224:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 27;
	if (asi64(R1) != asi64(R2)) goto L6226;
	asu64(R1) = d;
	R2 = 150;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	i = asi64(R1);
	asi64(R1) = i;
	asu64(R2) = d;
	R3 = 148;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	j = asi64(R1);
	asu64(R1) = d;
	R2 = 128;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	dequiv = asu64(R1);
	asu64(R1) = dequiv;
	asu64(R2) = b;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = dequiv;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) != asi64(R2)) goto L6228;
	R1 = 3;
	asi64(R2) = i;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	pindex = asu64(R1);
	R1 = 51;
	newtag = asi64(R1);
	goto L6227;
L6228:
	R1 = 3;
	asi64(R2) = j;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	R2 = 3;
	asi64(R3) = i;
	asu64(R2) = mm_lib_createconstunit(asu64(R3), asi64(R2));
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	pindex = asu64(R1);
	R1 = 9;
	asu64(R2) = pindex;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = pindex;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = pindex;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 52;
	newtag = asi64(R1);
L6227:
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
	asi64(R1) = newtag;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 4;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = pindex;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6217;
L6226:
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = d;
	R2 = 84;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asi64(R1) = lv;
	asu64(R2) = p;
	mm_type_twiden(asu64(R2), asi64(R1));
L6217:
	return;
}

static u64 mm_type_resolvefield(u64 d, i64 m) {
    u64 R1, R2, R3; 
	u64 e;
	u64 t;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6231;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6232;
	goto L6233;
L6231:
	goto L6230;
L6232:
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6235;
	R1 = 0;
	R2 = tou64("3:record expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L6235:
	goto L6230;
L6233:
	R1 = 0;
	R2 = tou64("4:record expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L6230:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = m;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	t = asu64(R1);
	asu64(R1) = d;
	asu64(R2) = t;
	asu64(R1) = mm_name_finddupl(asu64(R2), asu64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	if (asu64(R1)) goto L6237;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Not a field: #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L6237:
	asu64(R1) = e;
	goto L6229;
L6229:
	return asu64(R1);
}

static void mm_type_tx_andl(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 6;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 6;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_convintconst(u64 p, i64 x) {
    u64 R1, R2, R3, R4; 
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 32;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asi64(R1) = x;
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tx_sliceptr(u64 p, u64 a) {
    u64 R1, R2, R3, R4, R5; 
	i64 m;
	i64 tmode;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6242;
	goto L6243;
L6242:
	goto L6241;
L6243:
	R1 = 0;
	R2 = 1;
	asi64(R3) = m;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("SLICEPTR #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L6241:
	R1 = 0;
	R2 = 0;
	R3 = (u64)&mm_decls_ttlower;
	asi64(R4) = m;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	R4 = (u64)&mm_decls_tttarget;
	asi64(R5) = m;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5*4));
	R4 = toi64(toi32(R4));
	R5 = 0;
	asi64(R1) = mm_lib_createarraymodek(asu64(R5), asi64(R4), asi64(R3), asi64(R2), asi64(R1));
	tmode = asi64(R1);
	R1 = 0;
	asi64(R2) = tmode;
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_swap(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 av;
	i64 bv;
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 23;
	asu64(R2) = b;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L6246;
	R1 = 0;
	R2 = tou64("SWAP: type mismatch");
	mm_support_txerror(asu64(R2), asu64(R1));
L6246:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_select(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv) {
    u64 R1, R2, R3; 
	i64 i;
	i64 u;
	u64 q;
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = b;
	q = asu64(R1);
	goto L6249;
L6248:
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	asu64(R2) = b;
	if (asu64(R1) != asu64(R2)) goto L6252;
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
	goto L6251;
L6252:
	asu64(R1) = q;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L6251:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6249:
	asu64(R1) = q;
	if (asu64(R1)) goto L6248;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = c;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
	asu64(R1) = b;
	q = asu64(R1);
	goto L6254;
L6253:
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = q;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6254:
	asu64(R1) = q;
	if (asu64(R1)) goto L6253;
	asi64(R1) = u;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_case(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 amode;
	i64 u;
	u64 wt;
	u64 w;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 106;
	if (asi64(R1) != asi64(R2)) goto L6258;
	asi64(R1) = lv;
	if (!asi64(R1)) goto L6258;
	R1 = 0;
	R2 = tou64("&docase");
	mm_support_gerror(asu64(R2), asu64(R1));
L6258:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6260;
	R1 = 23;
	amode = asi64(R1);
	goto L6259;
L6260:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
L6259:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6262;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = amode;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) >= asi64(R2)) goto L6262;
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	amode = asi64(R1);
L6262:
	R1 = 0;
	u = asi64(R1);
	asu64(R1) = b;
	wt = asu64(R1);
	goto L6264;
L6263:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L6267;
L6266:
	R1 = 0;
	R2 = 23;
	asu64(R3) = w;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L6270;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = amode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6272;
	R1 = 0;
	R2 = tou64("case: need int index");
	mm_support_txerror(asu64(R2), asu64(R1));
L6272:
	goto L6269;
L6270:
	asi64(R1) = amode;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L6274;
	R1 = (u64)&mm_tables_isbooltag;
	asu64(R2) = w;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6276;
	R1 = 0;
	R2 = tou64("CASE/BOOL?");
	mm_support_txerror(asu64(R2), asu64(R1));
	R1 = 18;
	asu64(R2) = w;
	mm_lib_insertunit(asu64(R2), asi64(R1));
L6276:
	goto L6273;
L6274:
	R1 = 0;
	asi64(R2) = amode;
	asu64(R3) = w;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L6273:
L6269:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L6267:
	asu64(R1) = w;
	if (asu64(R1)) goto L6266;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = wt;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6278;
	asi64(R1) = u;
	if (!asi64(R1)) goto L6280;
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
	goto L6279;
L6280:
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
L6279:
L6278:
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L6264:
	asu64(R1) = wt;
	if (asu64(R1)) goto L6263;
	asu64(R1) = c;
	if (!asu64(R1)) goto L6282;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L6284;
	asu64(R1) = c;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L6284:
	goto L6281;
L6282:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6285;
	R1 = 0;
	R2 = tou64("case needs else");
	mm_support_txerror(asu64(R2), asu64(R1));
L6285:
L6281:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6287;
	asi64(R1) = u;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6286;
L6287:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6286:
	return;
}

static void mm_type_tx_notl(u64 p, u64 a) {
    u64 R1, R2, R3; 
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_typepun(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 smode;
	i64 tmode;
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6291;
	goto L6292;
L6291:
	R1 = 0;
	R2 = tou64("TYPEPUN/LIST");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L6290;
L6292:
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	smode = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 53;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tmode = asi64(R1);
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = smode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6295;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = tmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6294;
L6295:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = smode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6296;
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = tmode;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6294;
L6296:
	R1 = 0;
	R2 = tou64("Invalid type-punning; only real<->int");
	mm_support_txerror(asu64(R2), asu64(R1));
L6294:
	asi64(R1) = tmode;
	R2 = 16;
	if (asi64(R1) == asi64(R2)) goto L6299;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L6298;
L6299:
	R1 = 3;
	tmode = asi64(R1);
L6298:
	asi64(R1) = tmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6290:
	return;
}

static void mm_type_tx_exit(u64 p, u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6302;
	goto L6300;
L6302:
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6304;
	R1 = 0;
	R2 = tou64("exit/etc not const");
	mm_support_txerror(asu64(R2), asu64(R1));
L6304:
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 40;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6300:
	return;
}

static void mm_type_tx_goto(u64 p, u64 a) {
    u64 R1, R2, R3; 
	i64 m;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) != asi64(R2)) goto L6308;
	R1 = (u64)&mm_decls_ttbasetype;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 25;
	if (asi64(R1) == asi64(R2)) goto L6307;
L6308:
	R1 = 0;
	R2 = tou64("goto: not label");
	mm_support_txerror(asu64(R2), asu64(R1));
L6307:
	return;
}

static void mm_type_tx_switch(u64 p, u64 a, u64 b, u64 c, i64 t, i64 lv) {
    u64 R1, R2, R3, R4; 
	struct $B80 valueset;
	u64 wt;
	u64 w;
	i64 ax;
	i64 bx;
	i64 i;
	i64 u;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 108;
	if (asi64(R1) != asi64(R2)) goto L6311;
	asi64(R1) = lv;
	if (!asi64(R1)) goto L6311;
	R1 = 0;
	R2 = tou64("&doswitch");
	mm_support_gerror(asu64(R2), asu64(R1));
L6311:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 110;
	if (asi64(R1) != asi64(R2)) goto L6313;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	R4 = 8;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6315;
	R1 = 0;
	R2 = tou64("not ref");
	mm_support_txerror(asu64(R2), asu64(R1));
L6315:
	goto L6312;
L6313:
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L6312:
	R1 = 2048;
	R2 = 0;
	R3 = (u64)&valueset;
	memset(asu64(R3), asi32(R2), asu64(R1));
	R1 = 0;
	u = asi64(R1);
	asu64(R1) = b;
	wt = asu64(R1);
	goto L6317;
L6316:
	asu64(R1) = wt;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L6320;
L6319:
	R1 = 0;
	R2 = 23;
	asu64(R3) = w;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = w;
	asi64(R1) = mm_lib_isconstunit(asu64(R1));
	if (asi64(R1)) goto L6323;
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = w;
	mm_diags_dummy_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = tou64("Switch not constant");
	mm_support_txerror(asu64(R2), asu64(R1));
L6323:
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = w;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6325;
	goto L6326;
L6325:
	asu64(R1) = w;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	ax = asi64(R1);
	asu64(R1) = w;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	bx = asi64(R1);
// mm_type.tx_switch.dorange:
L6327:
	asi64(R1) = ax;
	i = asi64(R1);
	asi64(R1) = i;
	asi64(R2) = bx;
	if (asi64(R1) > asi64(R2)) goto L6330;
L6328:
	asi64(R1) = i;
	R2 = 0;
	if (asi64(R1) < asi64(R2)) goto L6333;
	asi64(R1) = i;
	R2 = 2047;
	if (asi64(R1) <= asi64(R2)) goto L6332;
L6333:
	R1 = 0;
	R2 = tou64("switch: value out of range");
	mm_support_txerror(asu64(R2), asu64(R1));
L6332:
	R1 = (u64)&valueset;
	asi64(R2) = i;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6335;
	msysc_m$print_startcon();
	asi64(R1) = i;
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("Duplicate switch value");
	mm_support_txerror(asu64(R2), asu64(R1));
L6335:
	R1 = 1;
	R2 = (u64)&valueset;
	asi64(R3) = i;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	i += 1; if (i <= bx) goto L6328;
L6330:
	goto L6324;
L6326:
	R1 = 0;
	R2 = 3;
	asu64(R3) = w;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = w;
	mm_type_tevaluate(asu64(R1));
	asu64(R1) = w;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6337;
	R1 = 0;
	R2 = tou64("Switch value: not const int");
	mm_support_txerror(asu64(R2), asu64(R1));
L6337:
	asu64(R1) = w;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = R1;
	bx = asi64(R2);
	ax = asi64(R1);
	goto L6327;
L6324:
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L6320:
	asu64(R1) = w;
	if (asu64(R1)) goto L6319;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = wt;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L6339;
	asi64(R1) = u;
	if (!asi64(R1)) goto L6341;
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
	goto L6340;
L6341:
	asu64(R1) = wt;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	u = asi64(R1);
L6340:
L6339:
	asu64(R1) = wt;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	wt = asu64(R1);
L6317:
	asu64(R1) = wt;
	if (asu64(R1)) goto L6316;
	asu64(R1) = c;
	if (!asu64(R1)) goto L6343;
	asi64(R1) = lv;
	asi64(R2) = t;
	asu64(R3) = c;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L6345;
	asu64(R1) = c;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asi64(R2) = u;
	asi64(R1) = mm_type_getdominantmode(asi64(R2), asi64(R1));
	u = asi64(R1);
L6345:
	goto L6342;
L6343:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6346;
	R1 = 0;
	R2 = tou64("switch needs else");
	mm_support_txerror(asu64(R2), asu64(R1));
L6346:
L6342:
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6348;
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
	goto L6350;
L6349:
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L6353;
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = b;
	R4 = 24;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L6353:
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = w;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = w;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	w = asu64(R1);
L6350:
	asu64(R1) = w;
	if (asu64(R1)) goto L6349;
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) != asi64(R2)) goto L6355;
	R1 = 0;
	asi64(R2) = u;
	asu64(R3) = c;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = u;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6354;
L6355:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6354:
	goto L6347;
L6348:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6347:
	return;
}

static void mm_type_tx_addroffirst(u64 p, u64 a, i64 t) {
    u64 R1, R2, R3; 
	i64 m;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6358;
	R1 = 0;
	R2 = tou64("&. ref[] expected");
	mm_support_txerror(asu64(R2), asu64(R1));
L6358:
	R1 = 0;
	R2 = (u64)&mm_decls_tttarget;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	m = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6360;
	R1 = 1;
	asu64(R2) = a;
	R3 = 40;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6360:
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_return(u64 p, u64 a, i64 t) {
    u64 R1, R2, R3; 
	i64 m;
	i64 nvalues;
	i64 nret;
	i64 i;
	u64 pmult;
	u64 q;
	asu64(R1) = mm_decls_currproc;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asu64(R1) = mm_decls_currproc;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nret = asi64(R1);
	R1 = (u64)&mm_decls_ttmult;
	asu64(R2) = mm_decls_currproc;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pmult = asu64(R1);
	asu64(R1) = a;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6363;
	asi64(R1) = nret;
	if (!asi64(R1)) goto L6365;
	R1 = 0;
	R2 = tou64("return value(s) missing");
	mm_support_txerror(asu64(R2), asu64(R1));
L6365:
	goto L6361;
	goto L6362;
L6363:
	asi64(R1) = nret;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6366;
	R1 = 0;
	R2 = tou64("Superfluous return value");
	mm_support_txerror(asu64(R2), asu64(R1));
L6366:
L6362:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6368;
	R1 = 25;
	asu64(R2) = a;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asi64(R2) = nret;
	if (asi64(R1) == asi64(R2)) goto L6370;
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6372;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6372;
	goto L6373;
L6372:
	R1 = 0;
	R2 = tou64("return constructor not supported");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L6371;
L6373:
	R1 = 0;
	R2 = tou64("Wrong number of return values");
	mm_support_txerror(asu64(R2), asu64(R1));
L6371:
L6370:
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	asi64(R1) = nret;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6376;
L6374:
	R1 = 0;
	asu64(R2) = pmult;
	asi64(R3) = i;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4-4));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	i += 1; if (i <= nret) goto L6374;
L6376:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6378;
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6377;
L6378:
	R1 = 28;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6377:
	goto L6367;
L6368:
	asi64(R1) = nret;
	R2 = 1;
	if (asi64(R1) <= asi64(R2)) goto L6380;
	R1 = 0;
	R2 = tou64("RETERROR?");
	mm_support_txerror(asu64(R2), asu64(R1));
L6380:
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6382;
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6381;
L6382:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L6381:
L6367:
	R1 = (u64)&mm_decls_ttisshort;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6384;
	R1 = 0;
	R2 = tou64("SHORT RET TYPE");
	mm_support_txerror(asu64(R2), asu64(R1));
L6384:
L6361:
	return;
}

static void mm_type_tx_dotindex(u64 p, u64 a, u64 b, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 pmode;
	u64 i;
	u64 j;
	asi64(R1) = lv;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 4;
	pmode = asi64(R1);
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6387;
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6389;
	R1 = 61;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 4;
	R2 = R1;
	asu64(R3) = a;
	R4 = 53;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6388;
L6389:
	R1 = 0;
	R2 = tou64("a.[i]: not int/str value");
	mm_support_txerror(asu64(R2), asu64(R1));
L6388:
L6387:
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6391;
	goto L6392;
L6391:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	i = asu64(R1);
	asu64(R1) = b;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	j = asu64(R1);
	asu64(R1) = i;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = j;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6394;
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6394;
	asu64(R1) = i;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	asu64(R2) = j;
	R3 = 16;
	asi64(R2) = *toi64p(((i64)R2+(i64)R3));
	if (asi64(R1) <= asi64(R2)) goto L6396;
	asu64(R1) = b;
	R2 = 16;
	R1 += (i64)R2;
	asu64(R2) = b;
	R3 = 24;
	R2 += (i64)R3;
	{u64 temp; temp = *tou64p(R1); *tou64p(R1) = *tou64p(R2); *tou64p(R2) = temp; }
L6396:
L6394:
	goto L6390;
L6392:
	R1 = 0;
	R2 = 3;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L6390:
	asi64(R1) = pmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_slice(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3, R4, R5; 
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6399;
	R1 = 0;
	R2 = 1;
	R3 = 12;
	asu64(R4) = mm_decls_currproc;
	asi64(R1) = mm_lib_createslicemodek(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6398;
L6399:
	R1 = 1;
	asu64(R2) = a;
	mm_type_deref(asu64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6401;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6402;
	goto L6403;
L6401:
	R1 = 0;
	R2 = 1;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = a;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu64(R4) = mm_decls_currproc;
	asi64(R1) = mm_lib_createslicemodek(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6400;
L6402:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6400;
L6403:
	msysc_m$print_startcon();
	R1 = tou64("STRMODE(A.MODE)=");
	msysc_m$print_str_nf(asu64(R1));
	R1 = 1;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = mm_lib_strmode(asi64(R2), asi64(R1));
	msysc_m$print_str_nf(asu64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("a[i..j]: not array");
	mm_support_txerror(asu64(R2), asu64(R1));
L6400:
L6398:
	return;
}

static void mm_type_twiden(u64 p, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 m;
	i64 u;
	i64 mbase;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	R3 = R2;
	m = asi64(R3);
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mbase = asi64(R1);
	asi64(R1) = mbase;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6406;
	goto L6404;
L6406:
	asi64(R1) = lv;
	if (!asi64(R1)) goto L6408;
	goto L6404;
L6408:
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = mbase;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6410;
	goto L6404;
L6410:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6412;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L6412;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L6412;
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L6412;
	R2 = 32;
	if (asi64(R1) == asi64(R2)) goto L6412;
	R2 = 40;
	if (asi64(R1) == asi64(R2)) goto L6412;
	goto L6413;
L6412:
	R1 = 58;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 4;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 53;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = m;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6411;
L6413:
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	mm_diags_dummy_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 0;
	R2 = (u64)&mm_tables_jtagnames;
	asu64(R3) = p;
	R4 = 0;
	asu8(R3) = *tou8p(((i64)R3+(i64)R4));
	R3 = toi64(tou8(R3));
	asu64(R2) = *tou64p(((i64)R2+(i64)R3*8));
	R3 = tou64("widen? #");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L6411:
L6404:
	return;
}

static void mm_type_tstringslice(u64 p, i64 slicemode) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	u64 prange;
	i64 length;
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = slicemode;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6416;
	R1 = 0;
	R2 = tou64("Not char slice");
	mm_support_txerror(asu64(R2), asu64(R1));
L6416:
	asu64(R1) = p;
	a = asu64(R1);
	R1 = 48;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6418;
	goto L6417;
L6418:
	R1 = 0;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_lib_duplunit(asu64(R2), asi64(R1));
	b = asu64(R1);
	R1 = 36;
	asu64(R2) = b;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 3;
	R3 = 1;
	asu64(R2) = mm_lib_createconstunit(asu64(R3), asi64(R2));
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	prange = asu64(R1);
	R1 = 9;
	asu64(R2) = prange;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = prange;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6417:
	asi64(R1) = slicemode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tx_bitfield(u64 p, u64 a, i64 lv) {
    u64 R1, R2, R3, R4; 
	i64 i;
	i64 j;
	i64 bitsize;
	i64 topbit;
	u64 r;
	asi64(R1) = lv;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6421;
	R1 = (u64)&mm_decls_ttisref;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6421;
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6423;
	R1 = 61;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 4;
	R2 = R1;
	asu64(R3) = a;
	R4 = 53;
	*toi32p(((i64)R3+(i64)R4)) = asi32(R2);
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = a;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6422;
L6423:
	R1 = 0;
	R2 = tou64("Int/ref needed");
	mm_support_txerror(asu64(R2), asu64(R1));
L6422:
L6421:
	R1 = (u64)&mm_decls_ttsize;
	R2 = (u64)&mm_decls_ttbasetype;
	asu64(R3) = a;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	asi64(R1) *= asi64(R2);
	bitsize = asi64(R1);
	asi64(R1) = bitsize;
	R2 = 1;
	asi64(R1) -= asi64(R2);
	topbit = asi64(R1);
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6425;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6426;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6427;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6428;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6428;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6429;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6430;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6431;
	goto L6432;
L6425:
	R1 = 0;
	i = asi64(R1);
	R1 = 7;
	j = asi64(R1);
	goto L6424;
L6426:
	asi64(R1) = topbit;
	j = asi64(R1);
	asi64(R1) = topbit;
	R2 = 7;
	asi64(R1) -= asi64(R2);
	i = asi64(R1);
	goto L6424;
L6427:
	R1 = 0;
	R2 = R1;
	j = asi64(R2);
	i = asi64(R1);
	goto L6424;
L6428:
	asi64(R1) = lv;
	if (!asi64(R1)) goto L6434;
	R1 = 0;
	R2 = tou64("Can't assign");
	mm_support_txerror(asu64(R2), asu64(R1));
L6434:
	R1 = 0;
	R2 = R1;
	j = asi64(R2);
	i = asi64(R1);
	goto L6424;
L6429:
	asi64(R1) = topbit;
	R2 = R1;
	j = asi64(R2);
	i = asi64(R1);
	goto L6424;
L6430:
	R1 = 0;
	i = asi64(R1);
	asi64(R1) = bitsize;
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	j = asi64(R1);
	goto L6424;
L6431:
	asi64(R1) = bitsize;
	R2 = 2;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	i = asi64(R1);
	asi64(R1) = topbit;
	j = asi64(R1);
	goto L6424;
L6432:
	msysc_m$print_startcon();
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	msysc_m$print_i64_nf(asi64(R1));
	msysc_m$print_newline();
	msysc_m$print_end();
	R1 = 0;
	R2 = tou64("BITFIELD");
	mm_support_txerror(asu64(R2), asu64(R1));
L6424:
	asi64(R1) = i;
	asi64(R2) = j;
	if (asi64(R1) != asi64(R2)) goto L6436;
	R1 = 51;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 3;
	asi64(R2) = i;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = p;
	R2 = 40;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	R2 = 8;
	if (asi64(R1) != asi64(R2)) goto L6438;
	R1 = 4;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	mm_type_addnotl(asu64(R1));
L6438:
	goto L6435;
L6436:
	R1 = 3;
	asi64(R2) = j;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	R2 = 3;
	asi64(R3) = i;
	asu64(R2) = mm_lib_createconstunit(asu64(R3), asi64(R2));
	R3 = 21;
	asu64(R1) = mm_lib_createunit2(asi64(R3), asu64(R2), asu64(R1));
	r = asu64(R1);
	R1 = 1;
	asu64(R2) = r;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 1;
	asu64(R2) = r;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 9;
	asu64(R2) = r;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 52;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = r;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
L6435:
	R1 = 4;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_deref(u64 a, i64 needres) {
    u64 R1, R2, R3; 
	i64 abasemode;
	i64 tmode;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	abasemode = asi64(R1);
	goto L6441;
L6440:
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tmode = asi64(R1);
	R1 = 53;
	asu64(R2) = a;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = tmode;
	asu64(R2) = a;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	abasemode = asi64(R1);
L6441:
	asi64(R1) = abasemode;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6440;
	return;
}

static void mm_type_tmethodcall(u64 p, u64 pdot, u64 pargs) {
    u64 R1, R2, R3; 
	i64 mrec;
	u64 prec;
	u64 pfield;
	u64 pfunc;
	u64 d;
	u64 e;
	asu64(R1) = pdot;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	prec = asu64(R1);
	asu64(R1) = pdot;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	pfield = asu64(R1);
	asu64(R1) = prec;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	mrec = asi64(R1);
	asu64(R1) = pfield;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	d = asu64(R1);
	asi64(R1) = mrec;
	asu64(R2) = d;
	asu64(R1) = mm_type_resolvefield(asu64(R2), asi64(R1));
	e = asu64(R1);
	asu64(R1) = e;
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6445;
	R1 = 0;
	asu64(R2) = d;
	R3 = 0;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = tou64("Can't resolve method:");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L6445:
	asu64(R1) = e;
	asu64(R1) = mm_lib_createname(asu64(R1));
	pfunc = asu64(R1);
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	asu64(R2) = pfunc;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = pargs;
	asu64(R2) = prec;
	R3 = 8;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pfunc;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = prec;
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	return;
}

static void mm_type_do_bounds(u64 p, u64 a) {
    u64 R1, R2, R3, R4; 
	i64 m;
	i64 mbase;
	i64 opc;
	i64 lower;
	i64 upper;
	R1 = 1;
	asu64(R2) = a;
	mm_type_deref(asu64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 62;
	if (asi64(R1) != asi64(R2)) goto L6448;
	asu64(R1) = a;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	m = asi64(R1);
L6448:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	mbase = asi64(R1);
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6450;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6451;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6452;
	R2 = 5;
	if (asi64(R1) == asi64(R2)) goto L6453;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6454;
	goto L6455;
L6450:
	asi64(R1) = mbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6457;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6457;
	goto L6458;
L6457:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	mm_type_convintconst(asu64(R2), asi64(R1));
	goto L6446;
	goto L6456;
L6458:
// mm_type.do_bounds.error:
L6459:
	R1 = 0;
	R2 = 1;
	asi64(R3) = m;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("lwb/upb/len?");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L6456:
	goto L6449;
L6451:
	asi64(R1) = mbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6461;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6462;
	goto L6463;
L6461:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	mm_type_convintconst(asu64(R2), asi64(R1));
	goto L6460;
L6462:
	R1 = 36;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6460;
L6463:
	goto L6459;
L6460:
	goto L6449;
L6452:
	asi64(R1) = mbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6465;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6466;
	goto L6467;
L6465:
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	mm_type_convintconst(asu64(R2), asi64(R1));
	goto L6464;
L6466:
	R1 = 36;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6464;
L6467:
	goto L6459;
L6464:
	goto L6449;
L6453:
	R1 = 9;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = mbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6469;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6470;
	goto L6471;
L6469:
	R1 = (u64)&mm_decls_ttlower;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	R3 = 16;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = m;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) += asi64(R2);
	R2 = 1;
	asi64(R1) -= asi64(R2);
	asu64(R2) = p;
	R3 = 24;
	*toi64p(((i64)R2+(i64)R3)) = asi64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = R1;
	asu64(R3) = p;
	R4 = 32;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	R2 = R1;
	asu64(R3) = p;
	R4 = 24;
	*tou64p(((i64)R3+(i64)R4)) = asu64(R2);
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6446;
	goto L6468;
L6470:
	goto L6468;
L6471:
	goto L6459;
L6468:
	goto L6449;
L6454:
	asi64(R1) = mbase;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6473;
	R1 = 0;
	R2 = tou64("Not slice");
	mm_support_txerror(asu64(R2), asu64(R1));
L6473:
	R1 = 36;
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6449;
L6455:
L6449:
L6446:
	return;
}

static void mm_type_addnotl(u64 p) {
    u64 R1, R2, R3; 
	R1 = 17;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 63;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tevaluate(u64 p) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	u64 pname;
	i64 offset;
	i64 tag;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	tag = asi64(R1);
	R1 = (u64)&mm_tables_jisexpr;
	asi64(R2) = tag;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 2;
	if (asi64(R1) != asi64(R2)) goto L6477;
	asu64(R1) = p;
	mm_type_tevalbinop(asu64(R1));
	goto L6476;
L6477:
	R1 = (u64)&mm_tables_jisexpr;
	asi64(R2) = tag;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6478;
	asu64(R1) = p;
	mm_type_tevalmonop(asu64(R1));
	goto L6476;
L6478:
	asi64(R1) = tag;
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L6480;
	R2 = 55;
	if (asi64(R1) == asi64(R2)) goto L6481;
	goto L6482;
L6480:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = 8;
	if (asi64(R1) > asi64(R2)) goto L6484;
	asu64(R1) = a;
	mm_type_tevaluate(asu64(R1));
	asu64(R1) = b;
	mm_type_tevaluate(asu64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6486;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6486;
	asu64(R1) = a;
	R2 = 60;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = b;
	R3 = 60;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asi64(R1) &= asi64(R2);
	asu64(R2) = p;
	R3 = 60;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6486:
L6484:
	goto L6479;
L6481:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	R1 = (u64)&offset;
	asu64(R2) = a;
	asu64(R1) = mm_type_addrdotindex(asu64(R2), asu64(R1));
	pname = asu64(R1);
	asu64(R1) = pname;
	if (!asu64(R1)) goto L6488;
	asu64(R1) = pname;
	asu64(R2) = a;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6490;
	R1 = 3;
	asi64(R2) = offset;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = p;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6489;
L6490:
	asi64(R1) = offset;
	asu64(R2) = p;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
L6489:
L6488:
	goto L6479;
L6482:
L6479:
L6476:
	return;
}

static u64 mm_type_addrdotindex(u64 p, u64 offset) {
    u64 R1, R2, R3, R4; 
	u64 q;
	i64 axmode;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 49;
	if (asi64(R1) == asi64(R2)) goto L6493;
	R2 = 46;
	if (asi64(R1) == asi64(R2)) goto L6494;
	goto L6495;
L6493:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6497;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = offset;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L6496;
L6497:
	asu64(R1) = offset;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_type_addrdotindex(asu64(R2), asu64(R1));
	q = asu64(R1);
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = offset;
	*toi64p(R2) += asi64(R1);
	asu64(R1) = q;
L6496:
	goto L6492;
L6494:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	axmode = asi64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6499;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6501;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = axmode;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = axmode;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = offset;
	*toi64p(R2) = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	goto L6500;
L6501:
	asu64(R1) = offset;
	asu64(R2) = p;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R1) = mm_type_addrdotindex(asu64(R2), asu64(R1));
	q = asu64(R1);
	asu64(R1) = q;
	if (!asu64(R1)) goto L6503;
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttlower;
	asi64(R3) = axmode;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	asi64(R1) -= asi64(R2);
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asi64(R4) = axmode;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asi64(R1) *= asi64(R2);
	asu64(R2) = offset;
	*toi64p(R2) += asi64(R1);
L6503:
	asu64(R1) = q;
L6500:
	goto L6498;
L6499:
	R1 = 0;
L6498:
	goto L6492;
L6495:
	R1 = 0;
L6492:
	goto L6491;
L6491:
	return asu64(R1);
}

static void mm_type_tevalbinop(u64 p) {
    u64 R1, R2, R3, R4, R5; 
	i64 a;
	i64 b;
	i64 c;
	i64 offset;
	r64 x;
	r64 y;
	r64 z;
	u64 lhs;
	u64 rhs;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	lhs = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rhs = asu64(R1);
	asu64(R1) = lhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	asu64(R2) = rhs;
	R3 = 0;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6507;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6506;
L6507:
	asu64(R1) = lhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 55;
	if (asi64(R1) != asi64(R2)) goto L6509;
	asu64(R1) = rhs;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6509;
	asu64(R1) = lhs;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6511;
	asu64(R1) = rhs;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = lhs;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	asi64(R1) *= asi64(R2);
	offset = asi64(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) != asi64(R2)) goto L6513;
	asi64(R1) = offset;
	asi64(R1) = -asi64(R1);
	offset = asi64(R1);
L6513:
	asu64(R1) = lhs;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6515;
	R1 = 3;
	asi64(R2) = offset;
	asu64(R1) = mm_lib_createconstunit(asu64(R2), asi64(R1));
	asu64(R2) = lhs;
	R3 = 24;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	goto L6514;
L6515:
	asi64(R1) = offset;
	asu64(R2) = lhs;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	R3 = 16;
	R2 += (i64)R3;
	*toi64p(R2) += asi64(R1);
L6514:
	asu64(R1) = lhs;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L6511:
L6509:
	goto L6504;
L6506:
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6517;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	y = asr64(R1);
	goto L6516;
L6517:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	b = asi64(R1);
L6516:
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6519;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6519;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6520;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6520;
	goto L6521;
L6519:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6523;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L6524;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L6525;
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L6526;
	R2 = 48;
	if (asi64(R1) == asi64(R2)) goto L6527;
	R2 = 53;
	if (asi64(R1) == asi64(R2)) goto L6528;
	R2 = 50;
	if (asi64(R1) == asi64(R2)) goto L6529;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L6530;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L6531;
	goto L6532;
L6523:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) += asi64(R2);
	c = asi64(R1);
	goto L6522;
L6524:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) -= asi64(R2);
	c = asi64(R1);
	goto L6522;
L6525:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) *= asi64(R2);
	c = asi64(R1);
	goto L6522;
L6526:
	asi64(R1) = b;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6534;
	R1 = 0;
	R2 = tou64("x/0");
	mm_support_txerror(asu64(R2), asu64(R1));
L6534:
	asi64(R1) = a;
	asi64(R2) = b;
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	c = asi64(R1);
	goto L6522;
L6527:
	asi64(R1) = b;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6536;
	R1 = 0;
	R2 = tou64("x rem 0");
	mm_support_txerror(asu64(R2), asu64(R1));
L6536:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) %= asi64(R2);
	c = asi64(R1);
	goto L6522;
L6528:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) <<= asi64(R2);
	c = asi64(R1);
	goto L6522;
L6529:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) &= asi64(R2);
	c = asi64(R1);
	goto L6522;
L6530:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) |= asi64(R2);
	c = asi64(R1);
	goto L6522;
L6531:
	asi64(R1) = a;
	asi64(R2) = b;
	asi64(R1) = Poweri64(asi64(R1), asi64(R2));
	c = asi64(R1);
	goto L6522;
L6532:
	goto L6504;
L6522:
	goto L6518;
L6520:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 43;
	if (asi64(R1) == asi64(R2)) goto L6538;
	R2 = 44;
	if (asi64(R1) == asi64(R2)) goto L6539;
	R2 = 45;
	if (asi64(R1) == asi64(R2)) goto L6540;
	R2 = 82;
	if (asi64(R1) == asi64(R2)) goto L6541;
	goto L6542;
L6538:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) += asr64(R2);
	z = asr64(R1);
	goto L6537;
L6539:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) -= asr64(R2);
	z = asr64(R1);
	goto L6537;
L6540:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) *= asr64(R2);
	z = asr64(R1);
	goto L6537;
L6541:
	asr64(R1) = x;
	asr64(R2) = y;
	asr64(R1) = pow(asr64(R1), asr64(R2));
	z = asr64(R1);
	goto L6537;
L6542:
	goto L6504;
L6537:
	goto L6518;
L6521:
	goto L6504;
L6518:
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6544;
	R1 = 0;
	asr64(R2) = z;
	asi64(R2) = asi64(R2);
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
	goto L6543;
L6544:
	R1 = 0;
	asi64(R2) = c;
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
L6543:
L6504:
	return;
}

static void mm_type_tevalmonop(u64 p) {
    u64 R1, R2, R3; 
	i64 a;
	i64 b;
	i64 c;
	r64 x;
	r64 z;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6547;
	goto L6545;
L6547:
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6549;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6549;
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6550;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6550;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6551;
	goto L6552;
L6549:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6555;
	R2 = 19;
	if (asi64(R1) != asi64(R2)) goto L6554;
L6555:
	goto L6556;
L6554:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L6558;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L6559;
	R2 = 62;
	if (asi64(R1) == asi64(R2)) goto L6560;
	R2 = 61;
	if (asi64(R1) == asi64(R2)) goto L6561;
	goto L6562;
L6558:
	asi64(R1) = a;
	asi64(R1) = -asi64(R1);
	c = asi64(R1);
	goto L6557;
L6559:
	asi64(R1) = a;
	asi64(R1) = !asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6557;
L6560:
	asi64(R1) = a;
	asi64(R1) = ~asi64(R1);
	c = asi64(R1);
	goto L6557;
L6561:
	asi64(R1) = a;
	if (asi64(R1) < 0) asi64(R1) = -asi64(R1);
	c = asi64(R1);
	goto L6557;
L6562:
	goto L6545;
L6557:
	goto L6548;
L6550:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L6564;
	R2 = 73;
	if (asi64(R1) == asi64(R2)) goto L6565;
	R2 = 67;
	if (asi64(R1) == asi64(R2)) goto L6566;
	goto L6567;
L6564:
	asr64(R1) = x;
	asr64(R1) = -asr64(R1);
	z = asr64(R1);
	goto L6563;
L6565:
	asr64(R1) = x;
	asr64(R1) = atan(asr64(R1));
	z = asr64(R1);
	goto L6563;
L6566:
	asr64(R1) = x;
	asr64(R1) = sqrt(asr64(R1));
	z = asr64(R1);
	goto L6563;
L6567:
	goto L6545;
L6563:
	goto L6548;
L6551:
// mm_type.tevalmonop.dobool:
L6556:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 18;
	if (asi64(R1) == asi64(R2)) goto L6569;
	R2 = 19;
	if (asi64(R1) == asi64(R2)) goto L6570;
	goto L6571;
L6569:
	asi64(R1) = a;
	asi64(R1) = !!asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6568;
L6570:
	asi64(R1) = a;
	asi64(R1) = !asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6568;
L6571:
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 64;
	if (asi64(R1) == asi64(R2)) goto L6573;
	R2 = 63;
	if (asi64(R1) == asi64(R2)) goto L6574;
	goto L6575;
L6573:
	asi64(R1) = a;
	asi64(R1) = !!asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6572;
L6574:
	asi64(R1) = a;
	asi64(R1) = !asi64(R1);
	c = asi64(R1);
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6572;
L6575:
L6572:
L6568:
	goto L6548;
L6552:
	goto L6545;
L6548:
	R1 = (u64)&mm_decls_ttisreal;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6577;
	R1 = 0;
	asr64(R2) = z;
	asi64(R2) = asi64(R2);
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
	goto L6576;
L6577:
	R1 = 0;
	asi64(R2) = c;
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
L6576:
L6545:
	return;
}

static i64 mm_type_iscondtrue(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6579;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6579;
	R1 = 1;
	goto L6580;
L6579:
	R1 = 0;
L6580:
	goto L6578;
L6578:
	return asi64(R1);
}

static i64 mm_type_iscondfalse(u64 p) {
    u64 R1, R2; 
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6582;
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6582;
	R1 = 1;
	goto L6583;
L6582:
	R1 = 0;
L6583:
	goto L6581;
L6581:
	return asi64(R1);
}

static void mm_type_fixchararray(u64 a) {
    u64 R1, R2, R3; 
	asu64(R1) = a;
	if (!asu64(R1)) goto L6586;
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 10;
	if (asi64(R1) != asi64(R2)) goto L6586;
	R1 = (u64)&mm_decls_tttarget;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L6586;
	R1 = 0;
	R2 = 20;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
L6586:
	return;
}

static void mm_type_combinestrings(u64 p) {
    u64 R1, R2, R3, R4; 
	u64 a;
	u64 b;
	i64 alen;
	i64 blen;
	i64 clen;
	i64 needterm;
	u8 atype;
	u8 btype;
	u8 ctype;
	u64 s;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	alen = asi64(R1);
	asu64(R1) = b;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	blen = asi64(R1);
	asu64(R1) = a;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	atype = asu8(R1);
	asu64(R1) = b;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	btype = asu8(R1);
	asu8(R1) = atype;
	R1 = toi64(tou8(R1));
	asu8(R2) = btype;
	R2 = toi64(tou8(R2));
    {u64 temp = R1; R1 = R2; R2 = temp;}
	if (asi64(R1) != asi64(R2)) goto L6589;
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L6589;
	R1 = 0;
	needterm = asi64(R1);
	R1 = 66;
	ctype = asu8(R1);
	goto L6588;
L6589:
	asu8(R1) = atype;
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) == asi64(R2)) goto L6591;
	asu8(R1) = btype;
	R1 = toi64(tou8(R1));
	R2 = 66;
	if (asi64(R1) != asi64(R2)) goto L6590;
L6591:
	R1 = 0;
	R2 = tou64("Mixed str+bin strings");
	mm_support_txerror(asu64(R2), asu64(R1));
	goto L6588;
L6590:
	R1 = (u64)&alen;
	(*toi64p(R1)) -=1;
	R1 = (u64)&blen;
	(*toi64p(R1)) -=1;
	R1 = 1;
	needterm = asi64(R1);
	asu8(R1) = atype;
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) == asi64(R2)) goto L6594;
	asu8(R1) = btype;
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L6593;
L6594:
	R1 = 83;
	ctype = asu8(R1);
	goto L6592;
L6593:
	R1 = 0;
	ctype = asu8(R1);
L6592:
L6588:
	asi64(R1) = alen;
	asi64(R2) = blen;
	asi64(R1) += asi64(R2);
	clen = asi64(R1);
	asi64(R1) = blen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6596;
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L6587;
	goto L6595;
L6596:
	asi64(R1) = alen;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6597;
	asu64(R1) = b;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	goto L6587;
L6597:
L6595:
	asi64(R1) = clen;
	asi64(R2) = needterm;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	s = asu64(R1);
	asi64(R1) = alen;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = blen;
	asu64(R2) = b;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = s;
	asi64(R4) = alen;
	R3 += (i64)R4;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = needterm;
	if (!asi64(R1)) goto L6599;
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = clen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6599:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asi64(R1) = clen;
	asi64(R2) = needterm;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu8(R1) = atype;
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6587:
	return;
}

static void mm_type_mulstrings(u64 p) {
    u64 R1, R2, R3; 
	u64 a;
	u64 b;
	i64 alen;
	i64 scale;
	i64 clen;
	i64 needterm;
	u8 atype;
	u8 ctype;
	u64 s;
	u64 t;
	i64 av_1;
	asu64(R1) = p;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	a = asu64(R1);
	asu64(R1) = p;
	R2 = 24;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	b = asu64(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	alen = asi64(R1);
	asu64(R1) = b;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	scale = asi64(R1);
	asu64(R1) = a;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	atype = asu8(R1);
	R1 = (u64)&alen;
	(*toi64p(R1)) -=1;
	R1 = 1;
	needterm = asi64(R1);
	asu8(R1) = atype;
	R1 = toi64(tou8(R1));
	R2 = 83;
	if (asi64(R1) != asi64(R2)) goto L6602;
	R1 = 1;
	needterm = asi64(R1);
L6602:
	asi64(R1) = alen;
	asi64(R2) = scale;
	asi64(R1) *= asi64(R2);
	clen = asi64(R1);
	asi64(R1) = scale;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6605;
	asi64(R1) = clen;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6605;
	asi64(R1) = clen;
	R2 = 100000;
	if (asi64(R1) > asi64(R2)) goto L6605;
	asi64(R1) = alen;
	R2 = 1;
	if (asi64(R1) >= asi64(R2)) goto L6604;
L6605:
	R1 = 0;
	R2 = tou64("mulstr");
	mm_support_txerror(asu64(R2), asu64(R1));
L6604:
	asi64(R1) = clen;
	asi64(R2) = needterm;
	asi64(R1) += asi64(R2);
	asu64(R1) = mlib_pcm_alloc(asi64(R1));
	R2 = R1;
	s = asu64(R2);
	t = asu64(R1);
	asi64(R1) = scale;
	av_1 = asi64(R1);
	asi64(R1) = av_1;
	R2 = 0;
	if (asi64(R1) <= asi64(R2)) goto L6608;
L6606:
	asi64(R1) = alen;
	asu64(R2) = a;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = t;
	memcpy(asu64(R3), asu64(R2), asu64(R1));
	asi64(R1) = alen;
	R2 = (u64)&t;
	*tou64p(R2) += asu64(R1);
	if (--asi64(av_1)) goto L6606;
L6608:
	asi64(R1) = needterm;
	if (!asi64(R1)) goto L6610;
	R1 = 0;
	asu64(R2) = s;
	asi64(R3) = clen;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
L6610:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	asi64(R1) = clen;
	asi64(R2) = needterm;
	asi64(R1) += asi64(R2);
	asu64(R2) = p;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = s;
	asu64(R2) = p;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu8(R1) = atype;
	asu64(R2) = p;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	return;
}

static void mm_type_tx_strinclude(u64 p, u64 a) {
    u64 R1, R2, R3, R4; 
	i64 fileno;
	u64 pf;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6614;
	asu64(R1) = a;
	R2 = 44;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6613;
L6614:
	R1 = 0;
	R2 = tou64("strincl/not string");
	mm_support_txerror(asu64(R2), asu64(R1));
L6613:
	R1 = (u64)&mm_decls_modules;
	asu64(R2) = p;
	R3 = 57;
	asu8(R2) = *tou8p(((i64)R2+(i64)R3));
	R2 = toi64(tou8(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 20;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2));
	R1 = toi64(toi16(R1));
	fileno = asi64(R1);
	R1 = (u64)&mm_decls_sources;
	asi64(R2) = fileno;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = tou64("");
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R1) = mm_support_getsupportfile(asu64(R3), asu64(R2), asu64(R1));
	pf = asu64(R1);
	asu64(R1) = pf;
	R2 = 32;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 16;
	*tou64p(((i64)R2+(i64)R3)) = asu64(R1);
	asu64(R1) = pf;
	R2 = 48;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	R2 = 1;
	asi64(R1) += asi64(R2);
	asu64(R2) = a;
	R3 = 40;
	*tou32p(((i64)R2+(i64)R3)) = asu32(R1);
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	asu64(R2) = a;
	R3 = 45;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = tou64(tou8(R1));
	R2 = 66;
	if (asu64(R1) != asu64(R2)) goto L6616;
	asu64(R1) = a;
	R2 = 40;
	R1 += (i64)R2;
	(*tou32p(R1)) -=1;
L6616:
	asu64(R1) = a;
	asu64(R2) = p;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
	return;
}

static void mm_type_coerceunit(u64 p, i64 t, i64 hard) {
    u64 R1, R2, R3, R4, R5; 
	i64 opc;
	i64 s;
	i64 n;
	i64 sbase;
	i64 tbase;
	i64 starg;
	i64 ttarg;
	asu64(R1) = p;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	s = asi64(R1);
	asi64(R1) = t;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6620;
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L6619;
L6620:
	goto L6617;
L6619:
	asi64(R1) = s;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6622;
	R1 = 0;
	R2 = tou64("Void expression/return value missing");
	mm_support_txerror(asu64(R2), asu64(R1));
L6622:
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L6624;
	goto L6617;
L6624:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	sbase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tbase = asi64(R1);
	R1 = 0;
	opc = asi64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	starg = asi64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	ttarg = asi64(R1);
	asi64(R1) = s;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6626;
	R1 = 20;
	sbase = asi64(R1);
L6626:
	asi64(R1) = t;
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6628;
	R1 = 20;
	tbase = asi64(R1);
L6628:
	asi64(R1) = sbase;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6630;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L6630;
	asi64(R1) = tbase;
	R2 = 1;
	if (asi64(R1) < asi64(R2)) goto L6632;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L6632;
	R1 = (u64)&mm_tables_softconvtable;
	asi64(R2) = sbase;
	R1 += (i64)R2*10-10;
	asi64(R2) = tbase;
	asi16(R1) = *toi16p(((i64)R1+(i64)R2*2-2));
	R1 = toi64(toi16(R1));
	opc = asi64(R1);
	goto L6631;
L6632:
	asi64(R1) = tbase;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6634;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6634;
	goto L6635;
L6634:
	R1 = 7;
	opc = asi64(R1);
// mm_type.coerceunit.checkhard:
L6636:
	asi64(R1) = hard;
	if (asi64(R1)) goto L6638;
	R1 = 9;
	opc = asi64(R1);
L6638:
	goto L6633;
L6635:
	asi64(R1) = tbase;
	R2 = 12;
	if (asi64(R1) < asi64(R2)) goto L6640;
	R2 = 19;
	if (asi64(R1) > asi64(R2)) goto L6640;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = sbase;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6642;
	asi64(R1) = hard;
	if (asi64(R1)) goto L6644;
	R1 = 10;
	opc = asi64(R1);
	goto L6643;
L6644:
	R1 = 3;
	opc = asi64(R1);
L6643:
L6642:
	goto L6639;
L6640:
	asi64(R1) = tbase;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6646;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L6647;
	goto L6648;
L6646:
	R1 = 8;
	opc = asi64(R1);
	goto L6645;
L6647:
	R1 = 7;
	opc = asi64(R1);
	goto L6645;
L6648:
L6645:
L6639:
L6633:
L6631:
	goto L6629;
L6630:
	asi64(R1) = sbase;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6650;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6651;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6652;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6653;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6654;
	R2 = 26;
	if (asi64(R1) == asi64(R2)) goto L6655;
	goto L6656;
L6650:
	asi64(R1) = tbase;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6659;
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6658;
L6659:
	R1 = 7;
	opc = asi64(R1);
L6658:
	goto L6649;
L6651:
	asi64(R1) = tbase;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6661;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6661;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6662;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6663;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6664;
	goto L6665;
L6661:
	R1 = 7;
	opc = asi64(R1);
	goto L6636;
	goto L6660;
L6662:
	asi64(R1) = starg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6668;
	asi64(R1) = ttarg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6667;
L6668:
	R1 = 7;
	opc = asi64(R1);
	goto L6666;
L6667:
// mm_type.coerceunit.checkref:
L6669:
	R1 = 7;
	opc = asi64(R1);
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L6671;
	goto L6636;
L6671:
L6666:
	goto L6660;
L6663:
	goto L6669;
	goto L6660;
L6664:
	R1 = 8;
	opc = asi64(R1);
	goto L6660;
L6665:
L6660:
	goto L6649;
L6652:
	asi64(R1) = tbase;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6673;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6673;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6674;
	R2 = 6;
	if (asi64(R1) == asi64(R2)) goto L6675;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6676;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6677;
	goto L6678;
L6673:
	R1 = 7;
	opc = asi64(R1);
	goto L6636;
	goto L6672;
L6674:
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L6681;
	asi64(R1) = hard;
	if (!asi64(R1)) goto L6680;
L6681:
	R1 = 7;
	opc = asi64(R1);
	goto L6679;
L6680:
	R1 = 9;
	opc = asi64(R1);
L6679:
	goto L6672;
L6675:
	R1 = 8;
	opc = asi64(R1);
	goto L6672;
L6676:
	asi64(R1) = ttarg;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6684;
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6683;
L6684:
	R1 = 11;
	opc = asi64(R1);
L6683:
	goto L6672;
L6677:
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) != asi64(R2)) goto L6686;
	asu64(R1) = p;
	R2 = 45;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6686;
	R1 = 7;
	opc = asi64(R1);
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	n = asi64(R1);
	asi64(R1) = n;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6688;
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = (u64)&mm_decls_ttsize;
	R3 = (u64)&mm_decls_tttarget;
	asu64(R4) = p;
	R5 = 49;
	asi32(R4) = *toi32p(((i64)R4+(i64)R5));
	R4 = toi64(toi32(R4));
	asi32(R3) = *toi32p(((i64)R3+(i64)R4*4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
   if (asi64(R2) == 0) {puts((u64)"Divide by zero"); exit(1);}
	asi64(R1) /= asi64(R2);
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = t;
	*toi32p(((i64)R2+(i64)R3*4)) = asi32(R1);
	asu64(R1) = p;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = t;
	*tou32p(((i64)R2+(i64)R3*4)) = asu32(R1);
	goto L6687;
L6688:
	R1 = 0;
	R2 = tou64("Array not empty");
	mm_support_txerror(asu64(R2), asu64(R1));
L6687:
L6686:
	goto L6672;
L6678:
L6672:
	goto L6649;
L6653:
	asi64(R1) = tbase;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6690;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6691;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6692;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6693;
	goto L6694;
L6690:
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L6696;
	R1 = 7;
	opc = asi64(R1);
L6696:
	goto L6689;
L6691:
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L6698;
	R1 = 12;
	opc = asi64(R1);
L6698:
	goto L6689;
L6692:
	asi64(R1) = starg;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6701;
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6700;
L6701:
	R1 = 13;
	opc = asi64(R1);
L6700:
	goto L6689;
L6693:
	asi64(R1) = ttarg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6703;
	R1 = 13;
	opc = asi64(R1);
L6703:
	goto L6689;
L6694:
L6689:
	goto L6649;
L6654:
	asi64(R1) = tbase;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6705;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6706;
	goto L6707;
L6705:
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L6709;
	R1 = 7;
	opc = asi64(R1);
L6709:
	goto L6704;
L6706:
	asi64(R1) = ttarg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6712;
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L6711;
L6712:
	R1 = 0;
	R2 = tou64("COERCE/SLICEPTR");
	mm_support_gerror(asu64(R2), asu64(R1));
L6711:
	goto L6704;
L6707:
L6704:
	goto L6649;
L6655:
	asi64(R1) = tbase;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L6714;
	R1 = 7;
	opc = asi64(R1);
L6714:
	goto L6649;
L6656:
L6649:
L6629:
	asi64(R1) = opc;
	asi64(R2) = t;
	asi64(R3) = s;
	asu64(R4) = p;
	mm_type_applyconversion(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
L6617:
	return;
}

static void mm_type_applyconversion(u64 p, i64 s, i64 t, i64 opc) {
    u64 R1, R2, R3, R4; 
	asi64(R1) = opc;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6717;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6718;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6719;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6720;
	R2 = 12;
	if (asi64(R1) == asi64(R2)) goto L6721;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6722;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6723;
	goto L6724;
L6717:
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = s;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't do conversion: # => #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
	goto L6716;
L6718:
	R1 = 0;
	R2 = tou64("*");
	R3 = 0;
	asu64(R4) = p;
	mm_diags_dummy_printunit(asu64(R4), asi64(R3), asu64(R2), asu64(R1));
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = s;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("2:Need explicit cast: # => #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
	goto L6716;
L6719:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6715;
	goto L6716;
L6720:
	asi64(R1) = opc;
	asi64(R2) = t;
	asi64(R3) = s;
	asu64(R4) = p;
	asi64(R1) = mm_type_tevalconvert(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L6726;
	goto L6715;
L6726:
	R1 = 59;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6715;
	goto L6716;
L6721:
	R1 = 48;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6715;
	goto L6716;
L6722:
	asi64(R1) = t;
	asu64(R2) = p;
	mm_type_tstringslice(asu64(R2), asi64(R1));
	goto L6715;
	goto L6716;
L6723:
	R1 = 56;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	R1 = 20;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6715;
	goto L6716;
L6724:
L6716:
	asi64(R1) = opc;
	asi64(R2) = t;
	asi64(R3) = s;
	asu64(R4) = p;
	asi64(R1) = mm_type_tevalconvert(asu64(R4), asi64(R3), asi64(R2), asi64(R1));
	if (!asi64(R1)) goto L6728;
	goto L6715;
L6728:
	R1 = 58;
	asu64(R2) = p;
	mm_lib_insertunit(asu64(R2), asi64(R1));
	asi64(R1) = opc;
	asu64(R2) = p;
	R3 = 62;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asi64(R1) = s;
	asu64(R2) = p;
	R3 = 53;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 1;
	asu64(R2) = p;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6730;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 53;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asi64(R1) = t;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	t = asi64(R1);
L6730:
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
L6715:
	return;
}

static void mm_type_checkmodes(i64 s, i64 t) {
    u64 R1, R2, R3; 
	asi64(R1) = t;
	asi64(R2) = s;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L6733;
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asi64(R3) = s;
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Type-compare error: # <-> #");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L6733:
	return;
}

static i64 mm_type_comparemodes(i64 s, i64 t) {
    u64 R1, R2, R3; 
	i64 sbase;
	i64 tbase;
	i64 starg;
	i64 ttarg;
	u64 d;
	u64 e;
	asi64(R1) = s;
	asi64(R2) = t;
	if (asi64(R1) != asi64(R2)) goto L6736;
	R1 = 1;
	goto L6734;
L6736:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	sbase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tbase = asi64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	starg = asi64(R1);
	R1 = (u64)&mm_decls_tttarget;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	ttarg = asi64(R1);
	asi64(R1) = sbase;
	asi64(R2) = tbase;
	if (asi64(R1) != asi64(R2)) goto L6738;
	asi64(R1) = sbase;
	R2 = 7;
	if (asi64(R1) == asi64(R2)) goto L6740;
	R2 = 10;
	if (asi64(R1) == asi64(R2)) goto L6741;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6742;
	R2 = 24;
	if (asi64(R1) == asi64(R2)) goto L6743;
	goto L6744;
L6740:
	asi64(R1) = starg;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6747;
	asi64(R1) = ttarg;
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6746;
L6747:
	R1 = 1;
	goto L6734;
L6746:
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	goto L6734;
	goto L6739;
L6741:
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L6749;
	R1 = 0;
	goto L6734;
L6749:
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = (u64)&mm_decls_ttlength;
	asi64(R3) = t;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	if (asi64(R1) == asi64(R2)) goto L6752;
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6752;
	R1 = (u64)&mm_decls_ttlength;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6751;
L6752:
	R1 = 1;
	goto L6734;
L6751:
	goto L6739;
L6742:
	asi64(R1) = ttarg;
	asi64(R2) = starg;
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	goto L6734;
	goto L6739;
L6743:
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = s;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	d = asu64(R1);
	R1 = (u64)&mm_decls_ttnamedef;
	asi64(R2) = t;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	e = asu64(R1);
	asu64(R1) = d;
	if (!asu64(R1)) goto L6754;
	asu64(R1) = e;
	if (!asu64(R1)) goto L6754;
	asu64(R1) = e;
	R2 = 72;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L6756;
	R1 = 0;
	goto L6734;
L6756:
	asu64(R1) = d;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6758;
	asu64(R1) = e;
	R2 = 112;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 0;
	if (asu64(R1) != asu64(R2)) goto L6758;
	R1 = 1;
	goto L6734;
L6758:
L6754:
	goto L6739;
L6744:
L6739:
	goto L6737;
L6738:
	asi64(R1) = sbase;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L6761;
	asi64(R1) = tbase;
	R2 = 17;
	if (asi64(R1) == asi64(R2)) goto L6760;
L6761:
	asi64(R1) = sbase;
	R2 = 17;
	if (asi64(R1) != asi64(R2)) goto L6759;
	asi64(R1) = tbase;
	R2 = 12;
	if (asi64(R1) != asi64(R2)) goto L6759;
L6760:
	R1 = 1;
	goto L6734;
	goto L6737;
L6759:
L6737:
	R1 = 0;
	goto L6734;
L6734:
	return asi64(R1);
}

static i64 mm_type_tevalconvert(u64 p, i64 s, i64 t, i64 opc) {
    u64 R1, R2, R3; 
	r64 x;
	r64 z;
	i64 a;
	i64 c;
	i64 sbase;
	i64 tbase;
	asu64(R1) = p;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 1;
	if (asi64(R1) == asi64(R2)) goto L6764;
	R1 = 0;
	goto L6762;
L6764:
	asu64(R1) = p;
	R2 = 16;
	asi64(R1) = *toi64p(((i64)R1+(i64)R2));
	a = asi64(R1);
	asu64(R1) = p;
	R2 = 16;
	asr64(R1) = *tor64p(((i64)R1+(i64)R2));
	x = asr64(R1);
	asi64(R1) = s;
	R2 = 16;
	asi64(R1) <<= asi64(R2);
	asi64(R2) = t;
	asi64(R1) |= asi64(R2);
	R2 = 196609;
	if (asi64(R1) == asi64(R2)) goto L6766;
	R2 = 196610;
	if (asi64(R1) == asi64(R2)) goto L6766;
	R2 = 65539;
	if (asi64(R1) == asi64(R2)) goto L6767;
	R2 = 65538;
	if (asi64(R1) == asi64(R2)) goto L6768;
	R2 = 196625;
	if (asi64(R1) == asi64(R2)) goto L6769;
	R2 = 196623;
	if (asi64(R1) == asi64(R2)) goto L6770;
	goto L6771;
L6766:
	asi64(R1) = a;
	asr64(R1) = tor64(asi64(R1));
	z = asr64(R1);
	goto L6765;
L6767:
	asr64(R1) = x;
	R1 = toi64(asr64(R1));
	c = asi64(R1);
	goto L6765;
L6768:
	asr64(R1) = x;
	z = asr64(R1);
	goto L6765;
L6769:
	asi64(R1) = a;
	asi64(R1) = toi64(tou8(R1));
	c = asi64(R1);
	goto L6765;
L6770:
	asi64(R1) = a;
	asi64(R1) = toi64(toi16(R1));
	c = asi64(R1);
	goto L6765;
L6771:
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = s;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6773;
	R1 = (u64)&mm_decls_ttisinteger;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6773;
	R1 = (u64)&mm_decls_ttsize;
	asi64(R2) = s;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = (u64)&mm_decls_ttsize;
	asi64(R3) = t;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	if (asi64(R1) != asi64(R2)) goto L6773;
	asi64(R1) = a;
	c = asi64(R1);
	goto L6772;
L6773:
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = s;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	sbase = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = t;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	tbase = asi64(R1);
	asi64(R1) = sbase;
	asi64(R2) = tbase;
	if (asi64(R1) != asi64(R2)) goto L6775;
	R1 = 1;
	goto L6762;
L6775:
	R1 = 0;
	goto L6762;
L6772:
L6765:
	R1 = (u64)&mm_decls_ttisreal;
	asi64(R2) = t;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6777;
	asi64(R1) = t;
	asr64(R2) = z;
	asi64(R2) = asi64(R2);
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
	goto L6776;
L6777:
	asi64(R1) = t;
	asi64(R2) = c;
	asu64(R3) = p;
	mm_type_makenewconst(asu64(R3), asi64(R2), asi64(R1));
L6776:
	R1 = 1;
	goto L6762;
L6762:
	return asi64(R1);
}

static void mm_type_tx_assign(u64 p, u64 a, u64 b, i64 t) {
    u64 R1, R2, R3, R4; 
	i64 m;
	i64 mm;
	i64 needres;
	u64 d;
	asi64(R1) = t;
	R2 = 0;
	asi64(R1) = asi64(R1)  !=  asi64(R2);
	needres = asi64(R1);
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6780;
	R2 = 51;
	if (asi64(R1) == asi64(R2)) goto L6781;
	R2 = 52;
	if (asi64(R1) == asi64(R2)) goto L6781;
	goto L6782;
L6780:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6784;
	asi64(R1) = needres;
	if (!asi64(R1)) goto L6786;
	R1 = 0;
	R2 = tou64("Mult assign has no result");
	mm_support_txerror(asu64(R2), asu64(R1));
L6786:
	asu64(R1) = b;
	asu64(R2) = a;
	asu64(R3) = p;
	mm_type_tx_assignmultmult(asu64(R3), asu64(R2), asu64(R1));
	goto L6783;
L6784:
	asi64(R1) = t;
	asu64(R2) = b;
	asu64(R3) = a;
	asu64(R4) = p;
	mm_type_tx_assignmultscalar(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
L6783:
	goto L6778;
	goto L6779;
L6781:
	R1 = 1;
	asu64(R2) = a;
	R3 = 24;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = a;
	R4 = 16;
	asu64(R3) = *tou64p(((i64)R3+(i64)R4));
	asu64(R4) = a;
	mm_type_tx_dotindex(asu64(R4), asu64(R3), asu64(R2), asi64(R1));
	R1 = 0;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 3;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6778;
	goto L6779;
L6782:
L6779:
	asu64(R1) = a;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6788;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	R2 = 92;
	asu16(R1) = *tou16p(((i64)R1+(i64)R2));
	R1 = toi64(tou16(R1));
	R2 = 4;
    asi64(R1) = Getdotindex(asu64(R1), asi64(R2));
	if (!asu64(R1)) goto L6788;
	asu64(R1) = p;
	R2 = 59;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6788;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L6787;
L6788:
	R1 = 23;
	asu64(R2) = a;
	mm_type_tpasslv(asu64(R2), asi64(R1));
L6787:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	m = asi64(R1);
	asi64(R1) = needres;
	asu64(R2) = a;
	R3 = 61;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asi64(R2) = m;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 11;
	if (asi64(R1) != asi64(R2)) goto L6790;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 20;
	if (asi64(R1) != asi64(R2)) goto L6790;
	asi64(R1) = m;
	asu64(R2) = b;
	R3 = 16;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	asu64(R3) = b;
	mm_type_tx_makeslicefromlist(asu64(R3), asu64(R2), asi64(R1));
	asi64(R1) = m;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	goto L6789;
L6790:
	asu64(R1) = b;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 47;
	if (asi64(R1) == asi64(R2)) goto L6793;
	R2 = 48;
	if (asi64(R1) != asi64(R2)) goto L6792;
L6793:
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L6791;
L6792:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 118;
	if (asi64(R1) != asi64(R2)) goto L6794;
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L6791;
L6794:
	asi64(R1) = m;
	mm = asi64(R1);
	R1 = (u64)&mm_decls_ttisshort;
	asi64(R2) = m;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6796;
	asi64(R1) = m;
	asi64(R1) = mm_lib_gettypebase(asi64(R1));
	mm = asi64(R1);
L6796:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 60;
	if (asi64(R1) == asi64(R2)) goto L6798;
	R2 = 20;
	if (asi64(R1) == asi64(R2)) goto L6799;
	goto L6800;
L6798:
	R1 = 0;
	asi64(R2) = mm;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L6797;
L6799:
	R1 = 0;
	asi64(R2) = m;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	goto L6797;
L6800:
	R1 = 0;
	asi64(R2) = mm;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
L6797:
	asi64(R1) = mm;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 58;
	if (asi64(R1) != asi64(R2)) goto L6802;
	asu64(R1) = b;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 4;
	if (asi64(R1) != asi64(R2)) goto L6802;
	R1 = (u64)&mm_decls_ttsize;
	asu64(R2) = a;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu32(R1) = *tou32p(((i64)R1+(i64)R2*4));
	R1 = toi64(tou32(R1));
	R2 = (u64)&mm_decls_ttsize;
	asu64(R3) = b;
	R4 = 53;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu32(R2) = *tou32p(((i64)R2+(i64)R3*4));
	R2 = toi64(tou32(R2));
	if (asi64(R1) > asi64(R2)) goto L6802;
	asi64(R1) = needres;
	if (asi64(R1)) goto L6802;
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	asu64(R2) = b;
	mm_lib_deleteunit(asu64(R2), asu64(R1));
L6802:
L6791:
L6789:
L6778:
	return;
}

static void mm_type_tx_assignmultmult(u64 pp, u64 a, u64 b) {
    u64 R1, R2, R3; 
	u64 p;
	u64 q;
	u64 lhs;
	u64 rhs;
	R1 = 29;
	asu64(R2) = pp;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	asu64(R2) = b;
	R3 = 40;
	asu32(R2) = *tou32p(((i64)R2+(i64)R3));
	R2 = toi64(tou32(R2));
	if (asi64(R1) == asi64(R2)) goto L6805;
	R1 = 0;
	R2 = tou64("Mult assign: count mismatch");
	mm_support_txerror(asu64(R2), asu64(R1));
L6805:
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	R2 = 0;
	if (asi64(R1) != asi64(R2)) goto L6807;
	R1 = 0;
	R2 = tou64("Invalid assignment");
	mm_support_txerror(asu64(R2), asu64(R1));
L6807:
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	rhs = asu64(R1);
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	lhs = asu64(R1);
	asu64(R1) = lhs;
	p = asu64(R1);
	goto L6811;
L6808:
	R1 = 23;
	asu64(R2) = p;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6811:
	asu64(R1) = p;
	if (asu64(R1)) goto L6808;
	asu64(R1) = lhs;
	p = asu64(R1);
	asu64(R1) = rhs;
	q = asu64(R1);
	goto L6815;
L6812:
	R1 = 0;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R3) = q;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6815:
	asu64(R1) = q;
	if (asu64(R1)) goto L6812;
	return;
}

static void mm_type_tx_assignmultscalar(u64 pp, u64 a, u64 b, i64 t) {
    u64 R1, R2, R3, R4; 
	u64 p;
	u64 q;
	u64 alist;
	i64 nretmodes;
	i64 i;
	i64 alength;
	u64 pmult;
	u64 d;
	asu64(R1) = a;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	alist = asu64(R1);
	asu64(R1) = a;
	R2 = 40;
	asu32(R1) = *tou32p(((i64)R1+(i64)R2));
	R1 = toi64(tou32(R1));
	alength = asi64(R1);
	R1 = 0;
	nretmodes = asi64(R1);
	R1 = 30;
	asu64(R2) = pp;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = b;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6818;
	R2 = 11;
	if (asi64(R1) == asi64(R2)) goto L6819;
	R2 = 9;
	if (asi64(R1) == asi64(R2)) goto L6820;
	R2 = 8;
	if (asi64(R1) == asi64(R2)) goto L6821;
	goto L6822;
L6818:
	asu64(R1) = b;
	asu64(R1) = mm_lib_getprocretmodes(asu64(R1));
	d = asu64(R1);
	asu64(R1) = d;
	R2 = 122;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	nretmodes = asi64(R1);
	R1 = (u64)&mm_decls_ttbasetype;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4));
	R1 = toi64(toi32(R1));
	R2 = 28;
	if (asi64(R1) == asi64(R2)) goto L6824;
	R1 = 0;
	R2 = tou64("Not a tuple");
	mm_support_txerror(asu64(R2), asu64(R1));
L6824:
	asi64(R1) = alength;
	asi64(R2) = nretmodes;
	if (asi64(R1) <= asi64(R2)) goto L6826;
	R1 = 0;
	R2 = tou64("mult ass/mult returns don't agree in number");
	mm_support_txerror(asu64(R2), asu64(R1));
L6826:
	asi64(R1) = nretmodes;
	R2 = 1;
	if (asi64(R1) > asi64(R2)) goto L6828;
	R1 = 0;
	R2 = tou64("mult ass rhs needs fn yielding 2+ values");
	mm_support_txerror(asu64(R2), asu64(R1));
L6828:
	asu64(R1) = alist;
	p = asu64(R1);
	R1 = (u64)&mm_decls_ttmult;
	asu64(R2) = d;
	R3 = 72;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu64(R1) = *tou64p(((i64)R1+(i64)R2*8));
	pmult = asu64(R1);
	R1 = 1;
	i = asi64(R1);
	goto L6832;
L6829:
	asu64(R1) = pmult;
	R2 = (u64)&i;
	asi64(R3) = *toi64p(R2); *(toi64p(R2)) += 1; asi64(R2) = asi64(R3);
	asi32(R1) = *toi32p(((i64)R1+(i64)R2*4-4));
	R1 = toi64(toi32(R1));
	asu64(R2) = p;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = p;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	p = asu64(R1);
L6832:
	asu64(R1) = p;
	if (asu64(R1)) goto L6829;
	goto L6817;
L6819:
	asi64(R1) = alength;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6834;
	R1 = 0;
	R2 = tou64("(a,b):=slice");
	mm_support_txerror(asu64(R2), asu64(R1));
L6834:
	R1 = 0;
	R2 = (u64)&mm_decls_tttarget;
	asu64(R3) = b;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asi32(R2) = *toi32p(((i64)R2+(i64)R3*4));
	R2 = toi64(toi32(R2));
	R3 = 0;
	asi64(R1) = mm_lib_createrefmode(asu64(R3), asi64(R2), asi64(R1));
	asu64(R2) = alist;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 3;
	asu64(R2) = alist;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_type_tpasslv(asu64(R2), asi64(R1));
	goto L6817;
L6820:
	goto L6817;
L6821:
	goto L6817;
L6822:
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 35;
	if (asi64(R1) != asi64(R2)) goto L6836;
	asu64(R1) = b;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 49;
	if (asi64(R1) != asi64(R2)) goto L6836;
	asi64(R1) = alength;
	R2 = 2;
	if (asi64(R1) == asi64(R2)) goto L6838;
	R1 = 0;
	R2 = tou64("(a,b):=divrem");
	mm_support_txerror(asu64(R2), asu64(R1));
L6838:
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = alist;
	mm_type_tpasslv(asu64(R2), asi64(R1));
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	asu64(R2) = alist;
	R3 = 8;
	asu64(R2) = *tou64p(((i64)R2+(i64)R3));
	mm_type_tpasslv(asu64(R2), asi64(R1));
	R1 = 31;
	asu64(R2) = pp;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6835;
L6836:
	R1 = 0;
	R2 = 1;
	asu64(R3) = b;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("Can't expand to mult values:");
	mm_support_txerror_s(asu64(R3), asu64(R2), asu64(R1));
L6835:
L6817:
	asi64(R1) = t;
	asu64(R2) = pp;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	return;
}

static void mm_type_tpasslv(u64 p, i64 t) {
    u64 R1, R2, R3, R4; 
	R1 = 1;
	R2 = 23;
	asu64(R3) = p;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asi64(R1) = t;
	R2 = 23;
	if (asi64(R1) == asi64(R2)) goto L6841;
	R2 = 0;
	if (asi64(R1) == asi64(R2)) goto L6841;
	asi64(R1) = t;
	asu64(R2) = p;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asi64(R1) = mm_type_comparemodes(asi64(R2), asi64(R1));
	if (asi64(R1)) goto L6843;
	R1 = 1;
	asi64(R2) = t;
	asu64(R1) = mm_lib_strmode2(asi64(R2), asi64(R1));
	R2 = 1;
	asu64(R3) = p;
	R4 = 49;
	asi32(R3) = *toi32p(((i64)R3+(i64)R4));
	R3 = toi64(toi32(R3));
	asu64(R2) = mm_lib_strmode(asi64(R3), asi64(R2));
	R3 = tou64("PassLV type mismatch: #:=#");
	mm_support_txerror_ss(asu64(R3), asu64(R2), asu64(R1));
L6843:
L6841:
	return;
}

static i64 mm_type_dobinnumx(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 bmode;
	i64 cmode;
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	asi64(R1) = amode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L6846;
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L6846;
	asi64(R1) = amode;
	asi64(R2) = bmode;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	R2 = R1;
	cmode = asi64(R2);
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L6844;
L6846:
	asi64(R1) = amode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L6848;
	asi64(R1) = bmode;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6849;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6848;
L6849:
	asi64(R1) = amode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = amode;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L6844;
	goto L6847;
L6848:
	asi64(R1) = amode;
	R2 = 13;
	if (asi64(R1) == asi64(R2)) goto L6851;
	R2 = 6;
	if (asi64(R1) != asi64(R2)) goto L6850;
L6851:
	asi64(R1) = bmode;
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L6850;
	asi64(R1) = bmode;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = bmode;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L6844;
L6850:
L6847:
	R1 = 0;
	goto L6844;
L6844:
	return asi64(R1);
}

static i64 mm_type_dobinnumf(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 bmode;
	i64 cmode;
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	asi64(R1) = amode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L6854;
	asi64(R1) = bmode;
	R2 = 2;
	if (asi64(R1) > asi64(R2)) goto L6854;
	asi64(R1) = amode;
	asi64(R2) = bmode;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	R2 = R1;
	cmode = asi64(R2);
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L6852;
L6854:
	R1 = 0;
	goto L6852;
L6852:
	return asi64(R1);
}

static i64 mm_type_dobinnumi(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 amode;
	i64 bmode;
	i64 cmode;
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	asi64(R1) = amode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6858;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6858;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L6857;
L6858:
	asi64(R1) = bmode;
	R2 = 3;
	if (asi64(R1) == asi64(R2)) goto L6859;
	R2 = 4;
	if (asi64(R1) == asi64(R2)) goto L6859;
	R2 = 5;
	if (asi64(R1) != asi64(R2)) goto L6857;
L6859:
	asi64(R1) = amode;
	asi64(R2) = bmode;
	asi64(R1) = Min(asi64(R1), asi64(R2));
	R2 = R1;
	cmode = asi64(R2);
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	asi64(R2) = cmode;
	asu64(R3) = b;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	goto L6855;
L6857:
	R1 = 0;
	goto L6855;
L6855:
	return asi64(R1);
}

static i64 mm_type_tx_in(u64 p, u64 a, u64 b) {
    u64 R1, R2, R3; 
	i64 simpleset;
	i64 amode;
	i64 bmode;
	u64 q;
	R1 = 0;
	R2 = 23;
	asu64(R3) = a;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	R1 = 0;
	R2 = 23;
	asu64(R3) = b;
	mm_type_tpass(asu64(R3), asi64(R2), asi64(R1));
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	amode = asi64(R1);
	asu64(R1) = b;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	bmode = asi64(R1);
	R1 = 0;
	R2 = 3;
	asu64(R3) = a;
	mm_type_coerceunit(asu64(R3), asi64(R2), asi64(R1));
	R1 = 1;
	simpleset = asi64(R1);
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L6862;
	asu64(R1) = b;
	R2 = 16;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
	goto L6866;
L6863:
	R1 = (u64)&mm_decls_ttisinteger;
	asu64(R2) = q;
	R3 = 49;
	asi32(R2) = *toi32p(((i64)R2+(i64)R3));
	R2 = toi64(toi32(R2));
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (asu8(R1)) goto L6868;
	R1 = 0;
	simpleset = asi64(R1);
	goto L6865;
L6868:
	asu64(R1) = q;
	R2 = 8;
	asu64(R1) = *tou64p(((i64)R1+(i64)R2));
	q = asu64(R1);
L6866:
	asu64(R1) = q;
	if (asu64(R1)) goto L6863;
L6865:
L6862:
	asu64(R1) = a;
	R2 = 49;
	asi32(R1) = *toi32p(((i64)R1+(i64)R2));
	R1 = toi64(toi32(R1));
	R2 = 5;
	if (asi64(R1) > asi64(R2)) goto L6870;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) == asi64(R2)) goto L6871;
	R2 = 22;
	if (asi64(R1) != asi64(R2)) goto L6870;
L6871:
	asi64(R1) = simpleset;
	if (!asi64(R1)) goto L6870;
	asu64(R1) = b;
	R2 = 0;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	R1 = toi64(tou8(R1));
	R2 = 21;
	if (asi64(R1) != asi64(R2)) goto L6873;
	R1 = 43;
	goto L6872;
L6873:
	R1 = 44;
L6872:
	asu64(R2) = p;
	R3 = 0;
	*tou8p(((i64)R2+(i64)R3)) = asu8(R1);
	goto L6869;
L6870:
	R1 = 0;
	R2 = tou64("doin");
	mm_support_txerror(asu64(R2), asu64(R1));
L6869:
	R1 = 6;
	asu64(R2) = p;
	R3 = 49;
	*toi32p(((i64)R2+(i64)R3)) = asi32(R1);
	asu64(R1) = p;
	R2 = 62;
	asu8(R1) = *tou8p(((i64)R1+(i64)R2));
	if (!asu8(R1)) goto L6875;
	asu64(R1) = p;
	mm_type_addnotl(asu64(R1));
L6875:
	R1 = 1;
	goto L6860;
L6860:
	return asi64(R1);
}

static void pclint_start() {
	mc_decls_start();
	return;
}

static void mmi_start() {
	mm_genpcl_start();
	mm_lex_start();
	mm_tables_start();
	return;
}

static struct $B68 $procaddr;

static struct $B68 $procname;

static i64 $nprocs = 0;

// ***** PCL Support Library *****

i64 Getdotindex(u64 a, int i) {
	return (a & (1LL<<i))>>i;
}

u64 Setdotindex(u64 a, i64 i, i64 x) {
	return (a & ~(1LL<<i)) | ((u64)(x)<<i);
}

i64 Getdotslice(u64 a, i64 i, i64 j) {
	if (i>=j)
		return (a>>j) & ~(0xFFFFFFFFFFFFFFFF<<(i-j+1));
	else
		return (a>>i) & ~(0xFFFFFFFFFFFFFFFF<<(j-i+1));
}

u64 Setdotslice(u64 a, i64 i, i64 j, u64 x) {
	u64 mask64;
	if (i>j) {i64 t=i; i=j; j=t;}

	mask64=~((0xFFFFFFFFFFFFFFFF<<(j-i+1)))<<i;
	return (a & ~mask64) ^ (x<<i);
}

i64 Poweri64(i64 a, i64 n) {
	if (n<0)
		return 0;
	else if (n==0)
		return 1;
	else if ((n&1)==0)
		return Poweri64(a*a, n/2);
	else
		return Poweri64(a*a, (n-1)/2)*a;
}

// End of C Code

