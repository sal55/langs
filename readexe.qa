=== QA 13 ===
=== readexe.q 0 1/13===
!Dump EXE or DLL file

!import sys
import clib
import winapi
import genlib
import disasm

type imagefileheader=struct
	wt_word  machine
	wt_word  nsections
	wt_dword timedatestamp
	wt_dword symtaboffset
	wt_dword nsymbols
	wt_word  optheadersize
	wt_word  characteristics
end

type imagedir=struct
	wt_dword virtualaddr
	wt_dword size
end

type optionalheader=struct			!exe/dll only
	wt_word  magic
	byte     majorlv
	byte     minorlv
	wt_dword codesize
	wt_dword idatasize
	wt_dword zdatasize
	wt_dword entrypoint
	wt_dword codebase
	word64	imagebase
	wt_dword sectionalignment
	wt_dword filealignment
	wt_word  majorosv
	wt_word  minorosv
	wt_word  majorimagev
	wt_word  minorimagev
	wt_word  majorssv
	wt_word  minorssv
	wt_dword win32version
	wt_dword imagesize
	wt_dword headerssize
	wt_dword checksum
	wt_word  subsystem
	wt_word  dllcharacteristics
	word64   stackreserve
	word64   stackcommit
	word64   heapreserve
	word64   heapcommit
	wt_dword loaderflags
	wt_dword rvadims
	imagedir exporttable
	imagedir importtable
	imagedir resourcetable
	imagedir exceptiontable
	imagedir certtable
	imagedir basereloctable
	imagedir debug
	imagedir architecture
	imagedir globalptr
	imagedir tlstable
	imagedir loadconfigtable
	imagedir boundimport
	imagedir iat
	imagedir delayimportdescr
	imagedir clrheader
	imagedir reserved
end

type imagesectionheader=struct
	stringz*8 name
	union
		wt_dword physical_address
		wt_dword virtual_size
	end
	wt_dword virtual_address
	wt_dword rawdata_size
	wt_dword rawdata_offset
	wt_dword relocations_ptr
	wt_dword linenos_offset
	wt_word  nrelocs
	wt_word  nlinenos
	wt_dword characteristics
end

type imagesymbol=struct
	union
		stringz*8 shortname
		struct
			wt_dword short
			wt_dword long
		end
		word64 longname
	end
	wt_dword value
	wt_word  sectionno
	wt_word  symtype
	byte     storageclass
	byte     nauxsymbols
end

type importdirrec = struct
	wt_dword implookuprva
	wt_dword timedatestamp
	wt_dword fwdchain
	wt_dword namerva
	wt_dword impaddressrva
end

type exportdirrec = struct
	wt_dword exportflags
	wt_dword timedatestamp
	wt_word majorversion
	wt_word minorversion
	wt_dword namerva
	wt_dword ordinalbase
	wt_dword naddrtable
	wt_dword nnamepointers
	wt_dword expaddressrva
	wt_dword namepointerrva
	wt_dword ordtablerva
end

type relocrec = struct
	int32 virtualaddr
	int32 stindex
	int16 reloctype
end

var coffptr
var sectionptr
var sectionoffset
var nsections

var optheaderoffset
var optheadersize
var opthdrptr

var symtaboffset
var symtabptr
var nsymbols
var stringtable
var stringindextable
var nstrings
var pedata

var reloctypenames = (0:"Abs","Addr64","Addr32","Add32NB","Rel32","Rel32_1")
const maxsymbol=1000
var symbolnames=(0:)

var storageclassnames=[0:"Null", 2:"Extern", 3:"Static",5:"Extern2"]

proc start=

	infile:=""
	showdata:=0

	if ncmdparams>=1 then
		(params,cmdswitches):=parsecmdparams(cmdparams[1..ncmdparams])
		if params then
			infile:=addext(params[1],"exe")
		fi

		showdata:="data" in cmdswitches
	fi

	if infile="" then
		println "No filename given"
		stop 1
	fi

	if not checkfile(infile) then
		infile:=changeext(infile,"dll")
	fi

	println "Dumping",infile

!CPL "SS1"
	pedata:=readblockfile(infile)      ! returns byte pointer to exe file contents
!CPL "SS2"

	if pedata=0 then
		println "Can't open",changeext(infile,"exe"),"nor",changeext(infile,"dll")
		stop 1
	fi
!CPL "SS3"

	initgenstr()
!CPL "SS4"

	if pedata^='M' and (pedata+1)^='Z' then		!exe file
!CPL "SS5"
		genstrln("Executable file "+infile)
		peoffset:=makeref(pedata+0x3c,int32)^
		coffoffset:=peoffset+4
		peptr:=makeref(pedata+peoffset,int32)
		genstrln("PE Sig:"+tostr(peptr^,"m"))
	else
		genstrln("Object file "+infile)
		coffoffset:=0
	fi
!CPL "SS6"

	coffptr:=makeref(pedata+coffoffset,imagefileheader)

!CPL "SS7"
	genstrln("Coff header:     "+tostr(coffptr^))

	genstrln("Machine:         "+tostr(coffptr^.machine,"h2"))
	genstrln("Nsections:       "+tostr(coffptr^.nsections,"h2"))
	genstrln("Timestamp:       "+tostr(coffptr^.timedatestamp,"h4"))
	genstrln("Symtab offset:   "+tostr(coffptr^.symtaboffset))
	genstrln("Nsymbols:        "+tostr(coffptr^.nsymbols))
	genstrln("Opt Hdr size:    "+tostr(coffptr^.optheadersize))
	genstrln("Characteristics: "+tostr(coffptr^.characteristics,"b"))
	genline()

!CPL "SS8"
	optheaderoffset:=coffoffset+imagefileheader.bytes
	optheadersize:=coffptr^.optheadersize
	opthdrptr:=makeref(pedata+optheaderoffset,optionalheader)

	sectionoffset:=optheaderoffset+optheadersize
	sectionptr:=makeref(pedata+sectionoffset,imagesectionheader)
	nsections:=coffptr^.nsections
!CPL "SS9"

	showoptheader()

!CPL "SS10"
	genstrln("Sectionoffset: "+tostr(sectionoffset))
	genstrln("Sectionptr   : "+tostr(sectionptr))
	genstrln("No Sections  : "+tostr(nsections))
	genline()

	symtaboffset:=coffptr^.symtaboffset
	symtabptr:=makeref(pedata+symtaboffset,imagesymbol)
	nsymbols:=coffptr^.nsymbols

!CPL "SS11"
	showsections()
!CPL "SS12"
	showsectionrelocs()
!CPL "SS13"

	showimportdir()
!CPL "SS14"

	showexportdir()
!CPL "SS15"

	if showdata then
!CPL "SS16"
		showbasereloctable()
!CPL "SS17"
		showsectiondata()
	fi
!CPL "SS18"

CPL TTDESTSTR

!	writestrfile("xxx1",ttdeststr)
!	execwait(f"\m\med.bat xxx1",1)
end

proc showsections=
	genstrln("proc Section Headers")

	p:=sectionptr
	for i:=1 to nsections do
		genstrln("Section "+tostr(i)+":")

		genstrln("	"+p^.name)
		genstrln("	Virtual size:  "+tostr(p^.virtual_size,"h"))
		genstrln("	Virtual addr:  "+tostr(p^.virtual_address,"h"))
		genstrln("	Rawdata size:  "+tostr(p^.rawdata_size,"H"))
		genstrln("	Nrelocs:       "+tostr(p^.nrelocs))
		genstrln("	Rawdat offset: "+tostr(p^.rawdata_offset,"H"))
		++p
		genline()
	od
end

proc showsectiondata=
	genstrln("proc Section Data")

	p:=sectionptr
	for i:=1 to nsections do
		genstrln("Section "+tostr(i)+": "+p^.name)

		q:=makeref(pedata+p^.rawdata_offset,byte)
		n:=p^.rawdata_size
		if p^.name=".text" then
			codelines:=decodeblock(q,n)
			forall line in codelines do
				genstrln(line)
			od
		else
			k:=0
			offset:=0
			genstr(tostr(offset,"6zh")+" ")
			to n do
				genstr(tostr(q^,"z2h")+" ")
				++offset
				if ++k=16 then
					genline()
					genstr(tostr(offset,"6zh")+" ")
					k:=0
				fi
				++q
			od
			genline()
		fi

		++p
		genline()
	od
end

proc showsectionrelocs=
	genstrln("proc Section Relocs")

	p:=sectionptr
	for i:=1 to nsections do
		genstrln("Section "+tostr(i)+": "+p^.name)

		q:=makeref(pedata+p^.relocations_ptr,relocrec)
		n:=p^.nrelocs
		genstrln("NRELOCS:"+TOSTR(N))
		for j to n do
			genstrln(sfprint("#: Type:# Virtualaddr:# Stindex:# (#)",
				j,reloctypenames[q^.reloctype]:"8",q^.virtualaddr:"6", q^.stindex:"4",
				symbolnames[q^.stindex]))
			++q
		od
		genline()
		++p
	od
end

proc showoptheader=
	genstrln("proc Optional Header")
	genstrln("Opt header size:  "+tostr(optheadersize))
	genstrln("Opt hdr rec size: "+tostr(optionalheader.bytes))

	p:=opthdrptr
	genline()
	genstrln("Magic:            "+tostr(p^.magic,"h"))
	genstrln("Link version:     "+tostr(p^.majorlv)+"."+tostr(p^.minorlv))
	genstrln("Code size:        "+tostr(p^.codesize))
	genstrln("Idata size:       "+tostr(p^.idatasize))
	genstrln("Zdata size:       "+tostr(p^.zdatasize))
	genstrln("Entry point:      "+tostr(p^.entrypoint)+" "+tostr(p^.entrypoint,"h")+ \
			" in data:"+tostr(p^.entrypoint-4096))

	genstrln("Code base:        "+tostr(p^.codebase))
	genstrln("Image base:       "+tostr(p^.imagebase)+" "+tostr(p^.imagebase,"h"))
	genstrln("Section align:    "+tostr(p^.sectionalignment))
	genstrln("File align:       "+tostr(p^.filealignment))


	genstrln("OS version:       "+tostr(p^.majorosv)+"."+tostr(p^.minorosv))
	genstrln("Image version:    "+tostr(p^.majorimagev)+"."+tostr(p^.minorimagev))
	genstrln("Subsys version:   "+tostr(p^.majorssv)+"."+tostr(p^.minorssv))
	genstrln("Win32 version:    "+tostr(p^.win32version))

	genstrln("Image size:       "+tostr(p^.imagesize))
	genstrln("Headers size:     "+tostr(p^.headerssize))
	genstrln("Checksum:         "+tostr(p^.checksum))
	genstrln("Subsystem:        "+tostr(p^.subsystem))
	genstrln("DLL chars:        "+tostr(p^.dllcharacteristics))
	genstrln("Stack reserve:    "+tostr(p^.stackreserve))
	genstrln("Stack commit:     "+tostr(p^.stackcommit))
	genstrln("Heap reserve:     "+tostr(p^.heapreserve))
	genstrln("Heap commit:      "+tostr(p^.heapcommit))
	genstrln("Loader flags:     "+tostr(p^.loaderflags))
	genstrln("RVA Dims:         "+tostr(p^.rvadims))
	genline()
	genstrln("Export table:     "+tostr(p^.exporttable.virtualaddr,"h")+" size:"+tostr(p^.exporttable.size))
	genstrln("Import table:     "+tostr(p^.importtable.virtualaddr,"h")+" size:"+tostr(p^.importtable.size))
	genstrln("Resource table:   "+tostr(p^.resourcetable.virtualaddr,"h")+" size:"+tostr(p^.resourcetable.size))
	genstrln("Exception table:  "+tostr(p^.exceptiontable.virtualaddr,"H")+" size:"+tostr(p^.exceptiontable.size))
	genstrln("Cert table:       "+tostr(p^.certtable))
	genstrln("Base reloc table: "+tostr(p^.basereloctable,"H"))
	genstrln("Debug:            "+tostr(p^.debug))
	genstrln("Architecture:     "+tostr(p^.architecture))
	genstrln("Global ptr:       "+tostr(p^.globalptr))
	genstrln("TLS table:        "+tostr(p^.tlstable))
	genstrln("Load config:      "+tostr(p^.loadconfigtable))
	genstrln("Bound import:     "+tostr(p^.boundimport))
	genstrln("IAT:              "+tostr(p^.iat,"h"))
	genstrln("Delayimp descr:   "+tostr(p^.delayimportdescr))
	genstrln("CLR Header:       "+tostr(p^.clrheader))
	genstrln("Reserved:         "+tostr(p^.reserved))

	genline()
end

function getstring(p)=
!p is a ref byte pointing to zero-terminated string
!return the string
	s::=""
	while p^ do
		s+:=p++^
	od
	return s
end

function getimportname(p)=
!p is a byte pointer to a 16-bit hint then zero-terminated name
	return (makeref(p,word16)^,getstring(p+2))
end

!proc showlookuptable(p,rawoffset,virtaddr)=
!!p points to a zero-terminated list of 64-bit values
!!assume top bit of each is 0 (uses name not ordinal)
!
!	while p^ do
!		phint:=makeref(pedata+rawoffset+((int(p^) iand 0xFFFF'FFFF)-virtaddr),byte)
!		(hint,name):=getimportname(phint)
!		genstrln("		Import:"+tostr(p^,"6h")+tostr(hint,"5h")+" "+name)
!		++p
!	od
!end

proc showlookuptable(p,rawoffset,virtaddr)=
!p points to a zero-terminated list of 64-bit values
!assume top bit of each is 0 (uses name not ordinal)


!println
!println "Show Lookup Table of Import directory:"

	while p^ do
!CPL =P
		phint:=makeref(pedata+rawoffset+((int(p^) iand 0xFFFF'FFFF)-virtaddr),byte)
!CPL "P=",p,"Phint=",phint
		(hint,name):=getimportname(phint)
!CPL =HINT,NAME,PHINT
		genstrln("		Import:"+tostr(p^,"6h")+tostr(hint,"5h")+" "+name)
!if name="ExitProcess" then CPL "SPECIAL EXIT"
!
!exit fi
!CPL "NEXT"
		++p
	od
end

proc showimportdir=

	genstrln("Import Directory")
	genline()

	rawoffset:=virtaddr:=0
	ptr:=getidataptr(rawoffset,virtaddr)
	if ptr=nil then
		CPL "Can't find Import Directory"
		return
	fi

	p:=makeref(pedata+rawoffset,importdirrec)

	while p^.implookuprva do
		genstrln("Entry:  "+tostr(makeref(p,byte)-pedata-rawoffset+virtaddr,"h"))
		genstrln("	Lookup RVA:       "+tostr(p^.implookuprva,"h"))
		genstrln("	Time Date Stamp:  "+tostr(p^.timedatestamp,"h"))
		genstrln("	Fwd Chain:        "+tostr(p^.fwdchain,"h"))
		genstrln("	Name RVA:         "+tostr(p^.namerva,"h"))
		pname:=pedata+rawoffset+(p^.namerva-virtaddr)
		genstrln("	Name:             "+getstring(pname))
		genstrln("	Import Addr RVA:  "+tostr(p^.impaddressrva,"h"))

		ptable:=pedata+rawoffset+(p^.implookuprva-virtaddr)
		showlookuptable(makeref(ptable,word64), rawoffset,virtaddr)
		genline()

		++p
	od

	genstrln("Entry (all zeros):  "+tostr(makeref(p,byte)-pedata-rawoffset+virtaddr,"h"))
	++p
	genstrln("Next:               "+tostr(makeref(p,byte)-pedata-rawoffset+virtaddr,"h"))
	genline()

end

proc showexportdir=

	genline()
	genstrln("Export Directory")
	genline()

	rawoffset:=virtaddr:=0
	ptr:=getedataptr(rawoffset,virtaddr)

	if ptr=nil then
		CPL "Can't find Export Directory"
		return
	fi

	p:=makeref(pedata+rawoffset,exportdirrec)

	offset:=virtaddr-rawoffset

	pnameptr:=makeref(pedata+rawoffset+(p^.namepointerrva-virtaddr),word32)
	paddrptr:=makeref(pedata+rawoffset+(p^.expaddressrva-virtaddr),word32)
	pordptr:=makeref(pedata+rawoffset+(p^.ordtablerva-virtaddr),word16)

	a:=b:=0
	pcode:=findtable(".text",0,a,b)
	if pcode=nil then println "Can't find .text section"; return fi
	codevirtaddr:=pcode^.virtual_address
	codevirtsize:=pcode^.virtual_size

	to p^.nnamepointers do
		genstr(tostr(pordptr^,"4"))
		genstr(" ")
		++pordptr
		(addr, ss):=fixexportaddr(paddrptr^)
		genstr(tostr(addr,"z8h"))
		genstr(" ")
		genstr(tostr(addr,"8"))
		genstr(" ")
		genstr(ss)
		++paddrptr

		genstrln(" "+getstring(makeref(pedata+pnameptr^-offset,byte)))
		++pnameptr
	od

	genline()
end

function fixexportaddr(addr)=
!search sections to see where
	p:=sectionptr

	for i:=1 to nsections do
		rawoffset:=p^.rawdata_offset
		virtaddr:=p^.virtual_address
		virtsize:=p^.virtual_size

		a:=addr-virtaddr			!rel to start of section
		if a in 0..virtsize then
			return (a, (p^.name=".text"|"Fun"|"Var"))
		fi
		++p
	od

	return (0,"?")

end

function findtable(sectionname,tableaddr, &rawoffset, &virtaddr)=
	p:=sectionptr

	for i:=1 to nsections do
		if p^.name=sectionname then
			rawoffset:=p^.rawdata_offset
			virtaddr:=p^.virtual_address
			return p
		fi
		++p
	od

!no dedicated table; look for section that might contain tableaddr
	p:=sectionptr
	idataptr:=nil

	for i:=1 to nsections do
		rawoffset:=p^.rawdata_offset
		virtaddr:=p^.virtual_address
		virtsize:=p^.virtual_size

		if tableaddr>=virtaddr and tableaddr<(virtaddr+virtsize) then
			xoffset:=tableaddr-virtaddr
			rawoffset+:=xoffset
			virtaddr+:=xoffset
			return p
		fi
		++p
	od

	return nil
end

function getedataptr(&rawoffset, &virtaddr)=
	return findtable(".edata",opthdrptr^.exporttable.virtualaddr,rawoffset,virtaddr)
end

function getidataptr(&rawoffset, &virtaddr)=
	return findtable(".idata",opthdrptr^.importtable.virtualaddr,rawoffset,virtaddr)
end

proc showbasereloctable=
	p:=opthdrptr
	offset:=p^.basereloctable.virtualaddr
	size:=p^.basereloctable.size
	if offset=0 then return fi

	genstrln("Base Reloc Table "+tostr(size))

	rawoffset:=virtaddr:=0
	ptr:=findtable(".reloc",offset,rawoffset,virtaddr)

	p:=makeref(pedata+rawoffset,word32)


	repeat
		blocksize:=(p+1)^
		n:=(blocksize-8)%2
		genstrln("    Block "+tostr(p^,"h")+" Size:"+tostr(blocksize)+" N:"+tostr(n))

		base:=p^

!		println p^:"h", =blocksize
		q:=makeref(p+2,word16)
		to n do
			offset:=q^.[0..11]
			genstrln(tostr(q^>>12,"2")+":"+tostr(offset,"z4h")+" "+tostr(base+offset,"z6h")+\
				" "+tostr(base+offset-4096,"6"))
			++q
		od
		genline()

		p:=makeref(makeref(p,byte)+blocksize,word32)
		size-:=blocksize
	until size<=0
end
=== genlib.q 0 12/13===
global var ttdeststr

global proc initgenstr=			!INITGENSTR
ttdeststr:=""
end

global proc genstr(s)=			!GENSTR
!iappend(ttdeststr,s)
ttdeststr +:=s
end

global proc genstrln(s)=		!GENSTRLN
!iappend(ttdeststr,s)
ttdeststr+:=s
genline()
end

global proc genline=			!GENLINE

!also append line-no info as a comment, in the form of:
!# L		Line number change only, same file
!# F L		Both have changed, or just file

lastfileno:=currfileno
lastlineno:=currlineno

ttdeststr+:="\w"
end

global proc genitem(s)=		!GENITEM
!like genstr, but ensure there is white space separation as needed from the last output
lastchar:=ttdeststr.[ttdeststr.len]
nextchar:=s.[1]
if lastchar in alphanumset and nextchar in alphanumset then
	ttdeststr+:=" "
fi
end

global proc additem(&dest,s)=		!GENITEM
!like genstr, but ensure there is white space separation as needed from the last output
if dest then
	lastchar:=dest.[dest.len]
	nextchar:=s.[1]
	if lastchar in alphanumset and nextchar in alphanumset then
!		iappend(dest," ")
		dest+:=" "
	fi
fi
dest+:=s
end

global proc gentab(level)=			!GENTAB
genstr(tabchar*level)
end

=== disasm.q 0 13/13===
!import sys
import clib

const tofile=1
!const tofile=0

const showmregs=1
!const showmregs=0

!const halt=0xF4

tabledata() opnames =
	(add_op=0,	"add"),
	(or_op,		"or"),
	(adc_op,	"adc"),
	(sbb_op,	"sbb"),
	(and_op,	"and"),
	(sub_op,	"sub"),
	(xor_op,	"xor"),
	(cmp_op,	"cmp")
end

var condnames = \
(0: "o", "no", "b","ae","z","nz","be","a","s","ns","p","np",
 "l","ge","le","g")

tabledata() addrmodenames=		! rm modes
	(amreg,			$),				! R
	(ammem,			$),				! [R+d]
	(amrel,			$)				! [RIP+d]
end

const wmask = 2x1000				!1 means 64-bit operand size
const rmask = 2x0100				!extends mod/rm reg field
const xmask = 2x0010				!extends sib index field
const bmask = 2x0001				!extends mod/rm r/m field, also sib base field

const rstack=5						!1-base register codes
const rframe=6

var rex

var addrmode						!amreg/ammem/amrel
var rmreg							!0, or 1..16; adjusted middle value of modrm byte
var rmopc							!0 to 7; middle value of modrm byte 
var basereg							!0, or 1..16
var indexreg						!0, or 1..16
var scale							!1,2,4
var opsize							!1,2,4,8
var offset
var offsetsize						!1 or 4
var sizeoverride					!32=>16 switch
var addroverride					!32=>16 switch
var f2override						!xmm regs
var f3override						!xmm regs
var modrmstr, sibstr, rexstr

var deststr
var destptr

!==============================================================

var codeptr,codestart

global function decodeblock(p,size=0)=

!cpl =p

codeptr:=codestart:=makeref(p,byte)

n:=0

code::=()

!CPL CODEPTR++^
!CPL CODEPTR++^
!CPL CODEPTR++^
!CPL CODEPTR++^
CODEPTR:=CODESTART

!CPL =SIZE


repeat
	instr:=decodeinstr()
	code append:=instr

!CPL =INSTR

until size and codeptr-codestart>=size

return code
end

proc start=
end

proc main=
p:=gettestfn()
CPL =P
!code:=decodeblock(gettestfn())
code:=decodeblock(P,2000)

if tofile then
	writetextfile("kkk1",code)
else
	forall i,c in code do
		cpl i,c
	od
fi

end

function decodeinstr=
!decode next instruction at codeptr
!return 1 if decoded, with codeptr stepped to start of next instruction
!return 0 when end-of-code seen (nop or 0x90)
!int n,w
!int opc,reg,op,xxx
!ref byte pstart
![32]char str
const maxinstrlen=14

!CPL "DECODE"

deststr::=""

pstart:=codeptr

rex:=0
opsize:=1
f2override:=f3override:=sizeoverride:=addroverride:=0
basereg:=indexreg:=offset:=0

modrmstr::=sibstr::=rexstr::=""

retry:						!back here after prefix byte seen

switch opc:=codeptr++^
when 0x00,0x1, 0x08,0x9, 0x10,0x11, 0x18,0x19,
					0x20,0x21, 0x28,0x29, 0x30,0x31, 0x38,0x39 then	!arith R/M, R
	op:=opc>>3
	decodeaddr(opc iand 1)
	getsilx(basereg)
	getsil(rmreg)
	genstr(opnames[op])
	printaddrmode()
	genstr(", ")
	genstr(strreg(rmreg,opsize))

when 0x02,0x3, 0x0A,0xB, 0x12,0x13, 0x1A,0x1B,
					0x22,0x23, 0x2A,0x2B, 0x32,0x33, 0x3A,0x3B then	!arith R,R/M
	op:=opc>>3
	decodeaddr(opc iand 1)
	getsilx(basereg)
	getsil(rmreg)
	genstr(opnames[op])
	genstr(" ")
	genstr(strreg(rmreg,opsize))
	genstr(", ")
	printaddrmode()

when 0x04,0x5, 0x0C,0xD, 0x14,0x15, 0x1C,0x1D,
					0x24,0x25, 0x2C,0x2D, 0x34,0x35, 0x3C,0x3D then	!arith rAX,imm
	genstr(opnames[opc>>3])
	genstr(" ")
	if opc iand 1 then
		opsize:=4
		if sizeoverride then opsize:=2 fi
		if rex iand wmask then opsize:=8 fi
	fi
	genstr(strreg(1,opsize))
	genstr(", ")
	genint(readimm())

when 0x0F then
	decodetwobyteinstr()

when 0x40 .. 0x4F then
	rex:=opc
!	if rex iand wmask then wopsize:=8 fi

	goto retry

when 0x50 .. 0x57 then
	reg:=getreg(opc iand 7,rex iand bmask)
	genstr("push ")
	genstr(strreg(reg,8))

when 0x58 .. 0x5F then
	reg:=getreg(opc iand 7,rex iand bmask)
	genstr("pop ")
	genstr(strreg(reg,8))

when 0x63 then
	decodeaddr(1)
	genstr("movsxd ")
	genstr(strreg(rmreg,opsize))
	genstr(", ")
	opsize:=4
	printaddrmode()

when 0x66 then
	if rex then
		println "REX before 66"
!		stop
	fi
	sizeoverride:=1
	goto retry

when 0x67 then
	if rex then
		println "REX before 67"
!		stop
	fi
	addroverride:=1
	goto retry

when 0x68 then
	genstr("push ")
	genint(readint())

when 0x6A then
	genstr("push ")
	genint(readsbyte())

when 0x69, 0x6B then
!	decodeaddr(1)
!	genstr("imul2")
!	printaddrmode()
!	genstr(", ")
!	opsize:=(opc iand 2|1|opsize)
!	genint(readimm())
	decodeaddr(1)
	if basereg<>rmreg then
		genstr("imul3")
		genstr(" ")
		genstr(strreg(rmreg,opsize))
		genstr(", ")
	else
		genstr("imul2")
	fi
	printaddrmode()
	genstr(", ")
	opsize:=(opc iand 2|1|opsize)
	genint(readimm())


when 0x70..0x7F then
	genstr("j")
	genstr(condnames[opc iand 15])
	genstr(" ")
	genint(readsbyte())

when 0x80..0x83 then			!arith r/m,imm
	decodeaddr(opc iand 1)
	genstr(opnames[rmopc])
	getsilx(basereg)
	printaddrmode()
	genstr(", ")
	if opc<>0x83 then
		genint(readimm())
	else
		genint(readsbyte())
	fi

when 0x84, 0x85 then			!test reg,reg/mem
	decodeaddr(opc iand 1)
	getsilx(basereg)
	getsil(rmreg)
	genstr("test ")
	printaddrmode()
	genstr(", ")
	genstr(strreg(rmreg,opsize))

when 0x86,0x87 then				!complex excg
	decodeaddr(opc iand 1)
	genstr("exch2 ")
	getsilx(basereg)
	getsil(rmreg)
	genstr(strreg(rmreg,opsize))
	genstr(", ")
	printaddrmode()

when 0x88, 0x89 then			!mov r/m,reg
	decodeaddr(opc iand 1)
	genstr("mov")
	getsilx(basereg)
	getsil(rmreg)
	printaddrmode()
	genstr(", ")
	genstr(strreg(rmreg,opsize))

when 0x8A, 0x8B then			!mov reg,r/m
	decodeaddr(opc iand 1)
	genstr("mov ")
	getsil(rmreg)
	genstr(strreg(rmreg,opsize))
	genstr(", ")
	printaddrmode()

when 0x8D then					!lea
	decodeaddr(opc iand 1)
	genstr("lea ")
	genstr(strreg(rmreg,opsize))
	genstr(", ")
	opsize:=0
	printaddrmode()

when 0x8F then
	decodeaddr(1)
	opsize:=1
	genstr("pop")
	printaddrmode()

when 0x90 then
	if rex then goto doexch fi
	genstr("nop")

when 0x91..0x97 then			!exch eax/reg
doexch:
	reg:=(opc iand 7)+1
	if rex iand bmask then reg+:=8 fi
	opsize:=(sizeoverride|2|4)
	if rex iand wmask then opsize:=8 fi
	genstr("xchg ")
	genstr(strreg(1,opsize))
	genstr(", ")
	genstr(strreg(reg,opsize))

when 0x98 then
	if sizeoverride then
		genstr("cbw")
	else
		genstr("cbw???")
	fi
when 0x99 then
	if sizeoverride then
		genstr("cwd")
	elsif rex iand wmask then
		genstr("cqo")
	else
		genstr("cdq")
	fi
when 0x9B then genstr("wait")

when 0x9C then genstr("pushf")
when 0x9D then genstr("popf")
when 0x9E then genstr("sahf")
when 0x9F then genstr("lahf")

when 0xA4..0xA7, 0xAA..0xAF then
	genstr((opc>>1 iand 7|"?","movs","cmps","?","stos","lods","scas"|"?"))
	if opc iand 1=0 then
		genstr("b")
	else
		if rex iand wmask then
			genstr("q")
		elsif sizeoverride then
			genstr("w")
		else
			genstr("d")
		fi
	fi

when 0xA8, 0xA9 then				!test r0,imm
	genstr("test ")
	if opc iand 1 then
		opsize:=(sizeoverride |2|4)
		if rex iand wmask then opsize:=8 fi
	fi
	genstr(strreg(1,opsize))
	genstr(", ")
	genint(readimm())

when 0xB0..0xBF then			!mov reg,imm
	reg:=(opc iand 7)+1
	if rex iand bmask then reg+:=8 fi
	if (opc iand 2x1000) then
		opsize:=(sizeoverride |2|4)
		if rex iand wmask then opsize:=8 fi
	fi
	genstr("mov ")
	getsil(reg)
	genstr(strreg(reg,opsize))
	genstr(", ")
	genint(readimm8())

when 0xC0, 0xC1, 0xD0..0xD3 then
	decodeaddr(opc iand 1)
	getsilx(basereg)
	genstr((rmopc+1|"rol","ror","rcl","rcr","shl","shr","?","sar"|"?"))
	printaddrmode()
	if opc<=0xC1 then
		genstr(", ")
		genint(readbyte())
	else
		genstr((opc iand 2|", cl"|", 1"))
	fi

when 0xC2 then
	genstr("retn ")
	genint(readword16())

when 0xC3 then
	genstr("ret")

when 0xC6,0xC7 then
	decodeaddr(opc iand 1)
	genstr("mov")
	printaddrmode()
	genstr(", ")
	genint(readimm())

when 0xD7 then genstr("xlat")

when 0xD8..0xDF then
	decode8087(opc iand 7)

when 0xE0 then genstr("loopnz "); genint(readsbyte())
when 0xE1 then genstr("loopz "); genint(readsbyte())
when 0xE2 then genstr("loopcx "); genint(readsbyte())
when 0xE3 then
	if addroverride then
		genstr("jecxz ")
	else
		genstr("jrcxz ")
	fi
	genint(readsbyte())

when 0xE8 then
	genstr("call ")
	genint(readint())

when 0xE9 then
	genstr("[4] jmp ")
	genint(readint())

when 0xEB then
	genstr("jmp ")
	genint(readsbyte())

when 0xF2 then
	if codeptr^<>0x0F and (codeptr^<0x40 and codeptr^>0x4F) then
		genstr("repne")
	else
		f2override:=1
		goto retry
	fi
when 0xF3 then
	if codeptr^<>0x0F and (codeptr^<0x40 and codeptr^>0x4F) then
		genstr("repe")
	else
		f3override:=1
		goto retry
	fi

when 0xF4 then
	genstr("halt")
!	return "halt"

when 0xF6,0xF7 then
	decodeaddr(opc iand 1)
	getsilx(basereg)
	genstr((rmopc+1|"test","?","not","neg","mul","imul","div","idiv"|"?"))
	printaddrmode()
	if rmopc=0 then
		if opsize=8 then opsize:=4 fi
		genstr(", ")
		genint(readimm())
	fi

when 0xFE then
	w:=0
	goto doff

when 0xFF then			!various
	w:=1
doff:
!CPL "FF//",codeptr^:"H",
!	(codeptr+1)^:"H",
!	(codeptr+2)^:"H",
!	(codeptr+3)^:"H",
!	(codeptr+4)^:"H",
!	(codeptr+5)^:"H"


	decodeaddr(w)
	case rmopc
	when 2x_000 then	!inc
		getsilx(basereg)
		genstr("inc")
	when 2x_001 then	!dec
		getsilx(basereg)
		genstr("dec")
	when 2x_010 then	!call
		opsize:=8
		genstr("icall")
	when 2x_100 then	!jmp
		opsize:=8
		genstr("ijmp")
	when 2x_110 then	!push
		opsize:=8
		genstr("push")
	else
!CPL =rmopc
!		println "FFxx?"
	esac
	printaddrmode()

else
	genstr("Unknown opcode: ")
    genhex(opc)
endswitch

offsetstr:=tostr(pstart-codestart,"5")
offsetstr+:=" "+tostr(pstart-codestart,"Z6H")

!s:=tostr(int(pstart),"zh8")+": "
s::=": "
to n:=codeptr-pstart do
	s+:=tostr(pstart++^,"zh2")+" "
od
to maxinstrlen-n do
	s+:="-- "
od

if rex iand wmask then rexstr+:="W" fi
if rex iand rmask then rexstr+:="R" fi
if rex iand xmask then rexstr+:="X" fi
if rex iand bmask then rexstr+:="B" fi

if modrmstr then
	return offsetstr+" "+s+deststr+"	|| "+modrmstr+" "+sibstr+ " "+rexstr
else
	return offsetstr+" "+s+deststr+" "+rexstr
!	return offsetstr+" "+offsetstr2+deststr+" "+rexstr
fi
end

proc decodetwobyteinstr=
!0F has been decoded
!int opc,rhssize
!ichar opcstr

!CPL "DECODE RWO PART"

switch opc:=codeptr++^
when 0x2A then					!cvtsi2ss/sd XMM, REG/MEM
	decodeaddr(1)
	if f3override then
!		opsize:=8
		genstr("cvtsi2ss ")
	else
!		opsize:=4
		genstr("cvtsi2sd ")
	fi
	genstr(strxmm(rmreg))
	genstr(", ")
	printaddrmode(0)
	
when 0x2D then					!cvt2ss/sd2si XMM, REG/MEM
	decodeaddr(1)
	if f3override then
		genstr("cvtss2si ")
		rhssize:=4
	else
		genstr("cvtsd2si ")
		rhssize:=8
	fi
	if rex iand wmask then
		genstr(strreg(rmreg,8))
	else
		genstr(strreg(rmreg,4))
	fi
	genstr(", ")
	opsize:=rhssize
	printaddrmode(1)

when 0x2F then					!comiss/comisd XMM, REG/MEM
	decodeaddr(1)
	if sizeoverride then
		opsize:=8
		genstr("comisd ")
	else
		opsize:=4
		genstr("comiss ")
	fi
	genstr(strxmm(rmreg))
	genstr(", ")
	printaddrmode(1)

when 0x40..0x4F then
	decodeaddr(1)
	genstr("cmov")
	genstr(condnames[opc iand 15])
	genstr(" ")
	genstr(strreg(rmreg,opsize))
	genstr(", ")
	printaddrmode()

when 0x51 then					!sqrtss/sd
	decodeaddr(1)
	opsize:=(f3override|4|8)
	genstr((opsize=4|"sqrtss "|"sqrtsd "))
	genstr(strxmm(rmreg))
	genstr(", ")
	printaddrmode(1)

when 0x54 then					!ANDPD
	decodeaddr(1)
	genstr((sizeoverride|"andpd "|"andps "))
	genstr(strxmm(rmreg))
	genstr(", ")
	opsize:=(sizeoverride|8|4)
	printaddrmode(1)

when 0x57 then					!XORPD
	decodeaddr(1)
	genstr((sizeoverride|"xorpd "|"xorps "))
	genstr(strxmm(rmreg))
	genstr(", ")
	opsize:=(sizeoverride|8|4)
	printaddrmode(1)

when 0x58 then					!addss/addsd
	opcstr:="adds"
doarith:
	genstr(opcstr)
	decodeaddr(1)
	if f2override then
		opsize:=8
		genstr("d ")
	else
		opsize:=4
		genstr("s ")
	fi
	genstr(strxmm(rmreg))
	genstr(", ")
	printaddrmode(1)

when 0x59 then					!mulss/mulsd
	opcstr:="muls"
	goto doarith

when 0x5A then					!cvtss2sd/cvtsd2ss
	decodeaddr(1)
	if f3override then
		genstr("cvtss2sd ")
		rhssize:=4
	else
		genstr("cvtsd2ss ")
		rhssize:=8
	fi
	genstr(strxmm(rmreg))
	genstr(", ")
	opsize:=rhssize
	printaddrmode(1)

when 0x5C then					!subss/subsd
	opcstr:="subs"
	goto doarith

when 0x5D then
	opcstr:="mins"
	goto doarith

when 0x5E then					!divss/divsd
	opcstr:="divs"
	goto doarith

when 0x5F then
	opcstr:="maxs"
	goto doarith

when 0x6E then					!mov X/MM, REG/MEM
	decodeaddr(1)
	opsize:=(rex iand wmask|8|4)
	genstr((opsize=4|"movd "|"movq "))
	if sizeoverride then		!xmm
		genstr(strxmm(rmreg))
	else
		genstr(strmmx(rmreg))
	fi
	genstr(", ")
	printaddrmode()

when 0x7E then					!mov REG/MEM, X/MM
	decodeaddr(1)
	if f3override then
		opsize:=8
		genstr("movq ")
		genstr(strxmm(rmreg))
		genstr(", ")
		printaddrmode(1)
	elsif rex iand wmask then
!GENSTR("7E/REX/WMASK")
		opsize:=8
		genstr("movq ")
		printaddrmode()
		genstr(", ")
		genstr(strxmm(rmreg))
	else
		opsize:=4
		genstr("movd ")
		printaddrmode()
		genstr(", ")
		if sizeoverride then		!xmm
			genstr(strxmm(rmreg))
		else
			genstr(strmmx(rmreg))
		fi
	fi

when 0x80..0x8F then			!long rel jumps
	genstr("[long] j")
	genstr(condnames[opc iand 15])
	genstr(" ")
	if sizeoverride then
		genint(readint16())
	else
		genint(readint())
	fi

when 0x90..0x9F then
	decodeaddr(0)
	genstr("set")
	genstr(condnames[opc iand 15])
	genstr(" ")
	getsilx(basereg)
	printaddrmode()

when 0xAF then
	decodeaddr(1)
	genstr("imul ")
	genstr(strreg(rmreg,opsize))
	genstr(", ")
	printaddrmode()

when 0xB6, 0xB7, 0xBE, 0xBF then
	decodeaddr(1)
!	opsize:=4
	genstr((opc<0xBE|"movzx "|"movsx "))
	genstr(strreg(rmreg,opsize))
	genstr(", ")
	opsize:=(opc iand 1|2|1)
	printaddrmode()

when 0xD6 then
	decodeaddr(1)
	opsize:=8
	genstr("movq ")
	printaddrmode(1)
	genstr(", ")
	genstr(strxmm(rmreg))	

else
	genstr("Unknown opcode 2-byte opcode: 0F ")
    genhex(opc)
endswitch
end

function readbyte=
return codeptr++^
end

function readsbyte=
a:=makeref(codeptr,int8)^
++codeptr
return a
end

function readword16=
!word a
a:=makeref(codeptr,word16)^
!a:=ref word16(codeptr)^
codeptr:=codeptr+2
return a
end

function readint16=
!int a
a:=makeref(codeptr,int16)^
!a:=ref int16(codeptr)^
codeptr:=codeptr+2
return a
end

function readword=
!word a
!a:=ref word(codeptr)^
a:=makeref(codeptr,word16)^
codeptr:=codeptr+4
return a
END

function readint=
!int a
!a:=ref int(codeptr)^
a:=makeref(codeptr,int32)^
codeptr:=codeptr+4
return a
END

function readint64=
!dint a
!a:=ref dint(codeptr)^
a:=makeref(codeptr,int64)^
codeptr:=codeptr+8
return a
END

function getreg(regcode,upper)=
if upper then
	return regcode+8+1
fi
return regcode+1
end

function strreg(reg,opsize)=
static var regnames8=("al","cl","dl","bl","ah","ch","dh","bh",
						"r8b","r9b","r10b","r11b","r12b","r13b","r14b","r15b",
				"spl","bpl","sil","dil")

static var regnames16=("ax","cx","dx","bx","sp","bp","si","di",
						"r8w","r9w","r10w","r11w","r12w","r13w","r14w","r15w")
static var regnames32=("eax","ecx","edx","ebx","esp","ebp","esi","edi",
						"r8d","r9d","r10d","r11d","r12d","r13d","r14d","r15d")
static var regnames64=("rax","rcx","rdx","rbx","rsp","rbp","rsi","rdi",
						"r8","r9","r10","r11","r12","r13","r14","r15")

static var mregnames8=("B0","B10","B11","B1","B16","B18","B19","B17",
						"B12","B13","B4","B5","B6","B7","B8","B9",
					"B14","B15","B2","B3")

static var mregnames16=("W0","W10","W11","W1","Wsp","Wbp","W2","W3",
						"W12","W13","W4","W5","W6","W7","W8","W9")
static var mregnames32=("A0","A10","A11","A1","Astack","Aframe","A2","A3",
						"A12","A13","A4","A5","A6","A7","A8","A9")
static var mregnames64=("D0","D10","D11","D1","Dstack","Dframe","D2","D3",
						"D12","D13","D4","D5","D6","D7","D8","D9")

if reg=0 then return "<>" fi

if showmregs then
	case opsize
	when 1 then return mregnames8[reg]
	when 2 then return mregnames16[reg]
	when 4 then return mregnames32[reg]
	when 8 then return mregnames64[reg]
	esac
else
	case opsize
	when 1 then return regnames8[reg]
	when 2 then return regnames16[reg]
	when 4 then return regnames32[reg]
	when 8 then return regnames64[reg]
	esac
fi
return ""
end

function strfreg(freg)=
!freg is 0-based
return ("st0","st1","st2","st3","st4","st5","st6","st7")[freg]
end

proc decodeaddr(w=0)=
!codeptr points to modrm byte, with possible sib and/or disp following
!decode modrm, sib and disp
!store result in amode:
! basereg		0 when not used
! indexreg
! scale			1,2,4,8 factor for indexreg
! offset		0, or any offset or abs address
! addrmode		rm-code
!the function returns the xxx value (middle part of modrm byte)
!int modrm,xxx,mode,sib,rm

basereg:=indexreg:=0
scale:=1
offset:=0
if w then
	opsize:=(sizeoverride|2|4)
	if rex iand wmask then opsize:=8 fi
else
	opsize:=1
fi

modrm:=codeptr++^
sib:=-1

mode:=modrm>>6
xxx:=(modrm>>3) iand 7
rm:=modrm iand 7
!CPL =mode
!CPL =xxx
!CPL =rm

if mode=3 then		!plain register access
	basereg:=rm+1
	addrmode:=amreg
elsif rm<>4 then				!not esp; no sib
!CPL "NO SIB"
	if mode=0 and rm=5 then		![ebp] is actually [rip+disp]
		offset:=readint()
		addrmode:=ammem

	else
		basereg:=rm+1
		addrmode:=ammem
		case mode
		when 1 then
			offset:=readsbyte()
		when 2 then
			offset:=readint()
		esac

	fi
else			!sib follows
!CPL "SIB follows"
	addrmode:=ammem
	sib:=readbyte()
	indexreg:=((sib>>3) iand 7)+1
	basereg:=(sib iand 7)+1
	scale:=(sib>>6+1|1,2,4,8|0)

	if mode=0 and basereg=rframe then	!no base register, only index; disp is 32bits
		basereg:=0
!CPL "******INDEXREG=",indexreg,sib>>3 iand 7
		offset:=readint()

	else
		case mode
		when 1 then
			offset:=readsbyte()
		when 2 then
			offset:=readint()
		esac
	fi

	if indexreg=rstack then				!stack means no index reg
		indexreg:=0
	fi

fi

if basereg and rex iand bmask then basereg+:=8 fi
if indexreg and rex iand xmask then indexreg+:=8 fi

!CPL "DECODE RMBYTE:"
!cpl =addrmode,addrmodenames[addrmode]
!cpl =basereg,strreg(basereg,4)
!cpl =indexreg,strreg(indexreg,4)
!cpl =scale
!cpl =offset
!cpl =rmreg,strreg(rmreg,4)
!cpl =rmopc

rmreg:=xxx+1
if rex iand rmask then rmreg+:=8 fi
rmopc:=xxx

modrmstr:=sfprint("modrm(#-#-#)",mode,xxx,rm)
if sib>=0 then
	sibstr:=sfprint("sib(#-#-#)",sib.[7..6],sib.[5..3],sib.[2..0])
else
	sibstr:=""
fi

end

proc printaddrmode(xmm=0)=
!static [100]char str
!ichar plus
!int addrsize

genstr(" ")

case addrmode
when amreg then
	if xmm then
		genstr(strxmm(basereg))
	else
		genstr(strreg(basereg,opsize))
	fi
	return
esac

case opsize
when 1 then genstr("byte ")
when 2 then genstr("word ")
when 4 then genstr("dword ")
when 8 then genstr("qword ")
when 10 then genstr("tword ")
when 16 then genstr("oword ")
when 0 then		!used to suppress size prefix (eg. lea)
else
CPL "///OPSIZE",opsize
esac

genstr("[")
plus:=""
addrsize:=(addroverride|4|8)
if basereg then
	genstr(strreg(basereg,addrsize))
	plus:="+"
fi
if indexreg then
	genstr(plus)
	genstr(strreg(indexreg,addrsize))
	if scale>1 then
		genstr("*")
		genint(scale)
	fi
	plus:="+"
fi

if offset or (basereg=0 and indexreg=0) then
!	print plus,,offset,"<",ref void(offset),,">"
	if basereg=0 and indexreg=0 then
!		genhex(offset)
		genint(offset)
	else
		if offset>0 then genstr(plus) fi
		genint(offset)
	fi
fi
genstr("]")
if addrmode=amrel then genstr("+RIP") fi
end

proc genstr(s)=
deststr+:=s
end

proc genint(a)=
deststr+:=tostr(a)
end

proc genhex(a)=
deststr+:=tostr(a,"hA")
end

function readimm=
!read signed offset according to opsize

case opsize
when 1 then return readsbyte()
when 2 then return readint16()
when 4,8 then return readint()			!64-bit uses 32-bit immediate
esac
return 0
end

function readimm8=
!like readimm but can 8 bytes too
if opsize<8 then return readimm() fi

return readint64()
end

function strxmm(reg)=
return "xmm"+tostr(reg-1)
end

function strmmx(reg)=
return "mmx"+tostr(reg-1)
end

proc decode8087(ttt)=
!byte bb
!int longopc,freg,shortopc,code

bb:=codeptr++^			!following byte

longopc:=ttt<<8+bb		!bottom 11 bits of 2-bytes opcode
freg:=(bb iand 7)+1		!where bb specifies a register in bottom 3 bits

!first look at all dedicated opcodes before treating bb as modrm byte

case longopc
when 2x'110'1101'1001 then genstr("fcompp")
when 2x'001'1110'0100 then genstr("ftst")
when 2x'001'1110'0101 then genstr("fxam")
when 2x'001'1110'1110 then genstr("fldz")
when 2x'001'1110'1000 then genstr("fld1")
when 2x'001'1110'1011 then genstr("fldpi")
when 2x'001'1110'1001 then genstr("fldl2t")
when 2x'001'1110'1010 then genstr("fldl2e")
when 2x'001'1110'1100 then genstr("fldlg2")
when 2x'001'1110'1101 then genstr("fldln2")

when 2x'001'1111'1010 then genstr("fsqrt")
when 2x'001'1111'1110 then genstr("fsin")
when 2x'001'1111'1111 then genstr("fcos")
when 2x'001'1111'1011 then genstr("fsincos")
when 2x'001'1111'1101 then genstr("fscale")
when 2x'001'1111'1000 then genstr("fprem")
when 2x'001'1111'1100 then genstr("frndint")
when 2x'001'1111'0100 then genstr("fxtract")
when 2x'001'1110'0001 then genstr("fabs")
when 2x'001'1110'0000 then genstr("fchs")

when 2x'001'1111'0010 then genstr("fptan")
when 2x'001'1111'0011 then genstr("fpatan")
when 2x'001'1111'0000 then genstr("f2xm1")
when 2x'001'1111'0001 then genstr("fyl2x")
when 2x'001'1111'1001 then genstr("fyl2xp1")

when 2x'011'1110'0011 then genstr("finit")
when 2x'011'1110'0000 then genstr("feni")
when 2x'011'1110'0001 then genstr("fdisi")

when 2x'011'1110'0010 then genstr("fclex")

when 2x'001'1111'0111 then genstr("fincstp")
when 2x'001'1111'0110 then genstr("fdecstp")
when 2x'001'1101'0000 then genstr("fnop")

elsecase longopc iand 2x'111'11111'000			!ignore bottom 3 bits

when 2x'001'11000'000 then genstr("fld "); genstr(strfreg(freg))
when 2x'101'11010'000 then genstr("fst "); genstr(strfreg(freg))
when 2x'101'11011'000 then genstr("fstp "); genstr(strfreg(freg))
when 2x'001'11001'000 then genstr("fxch "); genstr(strfreg(freg))
when 2x'000'11010'000 then genstr("fcom "); genstr(strfreg(freg))
when 2x'000'11011'000 then genstr("fcomp "); genstr(strfreg(freg))
when 2x'101'11000'000 then genstr("ffree "); genstr(strfreg(freg))

elsecase longopc iand 2x'001'11111'000			!ignore bottom 3 bits and top 2

when 2x'000'11000'000 then do87arith("fadd",ttt,freg)

when 2x'000'11100'000 then do87arith("fsub",ttt,freg)
when 2x'000'11101'000 then do87arith("fsubr",ttt,freg)

when 2x'000'11001'000 then do87arith("fmul",ttt,freg)

when 2x'000'11110'000 then do87arith("fdiv",ttt,freg)
when 2x'000'11111'000 then do87arith("fdivr",ttt,freg)

else	!finally, have to deal with modrm etc
	--codeptr					!put back modrm byte
	decodeaddr(0)			!code is middle bits
	shortopc:=ttt<<3 + rmopc

	case shortopc				!look at combination of ttt and code (middle bits of modrm)
	when 2x'111'101 then do87mem("fld",4)
	when 2x'011'101 then do87mem("fld",5)
	when 2x'111'100 then do87mem("fldbcd")

	when 2x'111'111 then do87mem("fstp",4)
	when 2x'011'111 then do87mem("fstp",5)
	when 2x'111'110 then do87mem("fstpbcd")

	when 2x'001'101 then do87mem("fldcw")
	when 2x'001'111 then do87mem("fstcw")
	when 2x'101'111 then do87mem("fstsw")

	when 2x'001'110 then do87mem("fstenv")
	when 2x'001'100 then do87mem("fldenv")
	when 2x'101'110 then do87mem("fsave")
	when 2x'101'100 then do87mem("frstor")

	elsecase shortopc iand 2x001'111		!ignore top two bits (mf code)

	when 2x'001'000 then do87mem("fld",ttt>>1)
	when 2x'001'010 then do87mem("fst",ttt>>1)
	when 2x'001'011 then do87mem("fstp",ttt>>1)
	when 2x'000'010 then do87mem("fcom",ttt>>1)
	when 2x'000'011 then do87mem("fcomp",ttt>>1)
	when 2x'000'000 then do87mem("fadd",ttt>>1)
	when 2x'000'100 then do87mem("fsub",ttt>>1)
	when 2x'000'101 then do87mem("fsubr",ttt>>1)
	when 2x'000'001 then do87mem("fmul",ttt>>1)
	when 2x'000'110 then do87mem("fdiv",ttt>>1)
	when 2x'000'111 then do87mem("fdivr",ttt>>1)

	else
		genstr("UNKNOWN x87 OPCODE")
	esac
esac

end

proc do87arith(opcstr, ttt,freg)=
!int d, p

d:=ttt iand 2x100		!d=0:  to st0; d<>0: to freg
p:=ttt iand 2x010		!p<>0: pop after operation

genstr(opcstr)
if p then
	genstr("p")
fi
genstr(" ")

if d=0 then
	genstr("st0, ")
    genstr(strfreg(freg))
else
    genstr(strfreg(freg))
	genstr(", st0")
fi
end

proc do87mem(opcstr, mf=-1)=
!mf has values 0,1,2,4 for type and width, when used; but also 4 for i64
genstr("f")

case mf
when 2x'00 then opsize:=4
when 2x'01 then genstr("i"); opsize:=4
when 2x'10 then opsize:=8
when 2x'11 then genstr("i"); opsize:=2
when 4 then genstr("i"); opsize:=8
when 5 then opsize:=10
esac
genstr(tail(opcstr))

genstr(" ")
printaddrmode()
end

function gettestfn=
return $test()
end

proc getsil(&reg)=
!for certain byte-reg combinations, convert regs ah,ch,dh,bh to spl,bpl,sil,dil
if opsize=1 and rex and reg>=5 and reg<=8 then
	reg+:=12				!5..8 => 17..20
fi
end

proc getsilx(&reg)=
!like getsil, but applied to basereg (and maybe indexreg), which needs to
!have addrmode=amreg
!for certain byte-reg combinations, convert regs ah,ch,dh,bh to spl,bpl,sil,dil
if addrmode=amreg and opsize=1 and rex and reg>=5 and reg<=8 then
	reg+:=12				!5..8 => 17..20
fi
end
=== END ===
1 readexe.q
12 genlib.q
13 disasm.q
