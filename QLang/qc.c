/*
Build on Windows as follows:

    gcc -O3 qc.c -oqq.exe

or using Tiny C:

    tcc qc.c -oqq.exe -fdollars-in-identifiers -luser32 c:\windows\system32\kernel32.dll
*/

#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"

//#include <stdio.h>
//#include <stdlib.h>
//#include <ctype.h>
//#include <string.h>
//#include <math.h>
//#include <time.h>
//#include <sys/types.h>
//#include <sys/stat.h>

//#pragma pack(1)

typedef signed char         i8;
typedef short              i16;
typedef int                i32;
typedef long long          i64;

typedef unsigned char       u8;
typedef unsigned short     u16;
typedef unsigned int       u32;
typedef unsigned long long u64;

typedef unsigned char     byte;

typedef float              r32;
typedef double             r64;

extern r64 sqrt(r64);
extern r64 fabs(r64);

typedef struct {void* ptr; u64 length;} Slice;

#define NULL ((void*)0)

#ifndef CALLBACK
#define CALLBACK
#endif

i64 m$llabs(i64 a){ return (a>=0?a:-a);}
#define m$infinity (1.0/0.0)


/* Forward Struct Declarations */
struct qq_decimal$constrec;
struct qq_decls$modulerec;
struct qq_decls$subprogrec;
struct qq_decls$packfieldrec;
struct qq_decls$procrec;
struct qq_decls$userxrec;
struct qq_decls$strec;
struct qq_decls$lexrec;
struct qq_decls$uflagsrec;
struct qq_decls$fieldrec;
struct qq_decls$unitrec;
struct qq_decls$genfieldrec;
struct qq_decls$varrec;
struct qq_decls$objrec;
struct qq_decls$stringrec;
struct qq_host$dimrec;
struct qq_parse$readterm$dummy;
struct qq_print$fmtrec;
struct msysc$procinforec;
struct msysc$fmtrec;
struct mlib$strbuffer;
struct mwindows$rsystemtime;
struct mwindows$input_record;
struct mwindows$rspoint;
struct mwindows$rsrect;
struct mwindows$rpoint;
struct mwindows$rconsole;
struct mwindows$rstartupinfo;
struct mwindows$rprocess_information;
struct mwindows$rwndclassex;
struct mwindows$rmsg;

/* Struct Definitions */
struct qq_decimal$constrec {
    i64 value;
    struct qq_decls$objrec *  bnvalue;
    struct qq_decimal$constrec* nextconst;
};

struct qq_decls$modulerec {
    u8 *  name;
    u8 *  path;
    struct qq_decls$unitrec *  ast;
    i64 parsed;
    i64 *  pcstart;
    i64 *  pcend;
    i64 pcsize;
    i32 *  pcsrcstart;
    union {
        struct qq_decls$strec *  def;
        struct qq_decls$strec *  stmodule;
    };
    struct qq_decls$strec *  stsubprog;
    struct qq_decls$strec *  stmacro;
    struct qq_decls$strec *  startfn;
    struct qq_decls$strec *  mainfn;
    i16 fileno;
    i16 issyslib;
    i16 moduleno;
    i16 subprogno;
};

struct qq_decls$subprogrec {
    u8 *  name;
    struct qq_decls$strec *  stsubprog;
    i64 issyslib;
    u8 *  path;
    i16 startmodule;
    i16 endmodule;
    i64 fileno;
};

struct qq_decls$packfieldrec {
    struct qq_decls$objrec *  structobj;
    u8 *  name;
    i32 packmode;
    i32 offset;
    i32 size;
    i32 length;
};

struct qq_decls$procrec {
    struct qq_decls$strec *  def;
    struct qq_decls$procrec* nextproc;
};

struct qq_decls$userxrec {
    struct qq_decls$strec *  owner;
    i16 *  pmode;
    struct qq_decls$userxrec* nextmode;
};

struct qq_decls$strec {
    union {
        struct {
            u8 *  name;
            struct qq_decls$strec* owner;
            struct qq_decls$strec* deflist;
            struct qq_decls$strec* deflistx;
            struct qq_decls$strec* nextdef;
            struct qq_decls$strec* nextdupl;
            struct qq_decls$strec* firstdupl;
            struct qq_decls$strec* alias;
            union {
                u64 a;
                i64 *  pcaddress;
                struct qq_decls$varrec *  varptr;
                u8 *  truename;
                struct qq_decls$strec* atfield;
                i64 labelno;
            };
            union {
                u64 b;
                struct qq_decls$unitrec *  code;
                struct qq_decls$strec** topfieldlist;
            };
            union {
                u64 c;
                i64 index;
            };
            union {
                u64 d;
                struct {
                    i16 nparams;
                    i16 nlocals;
                };
                struct {
                    i16 nfields;
                    i16 maxalign;
                    i16 fieldoffset;
                    i16 baseclassindex;
                };
                i64 genfieldindex;
            };
            u16 subcode;
            byte moduleno;
            byte subprogno;
            i16 mode;
            i16 hint;
            u16 flags;
            byte forindex;
            byte symbolcode;
            byte nameid;
            byte mutable;
            byte namelen;
            byte procfixed;
        };
    };
};

struct qq_decls$lexrec {
    union {
        i64 value;
        r64 xvalue;
        u64 uvalue;
        u8 *  svalue;
        struct qq_decls$strec *  symptr;
    };
    i32 pos;
    i16 symbol;
    i16 subcode;
};

struct qq_decls$uflagsrec {
    byte codes[7];
    byte ulength;
};

struct qq_decls$fieldrec {
    u8 *  name;
    i16 recordtype;
    i16 fieldtype;
    i32 fieldoffset;
};

struct qq_decls$unitrec {
    union {
        struct {
            i16 tag;
            union {
                byte elemtype;
            };
            union {
                byte nparams;
                byte enumindex;
            };
            i32 pos;
        };
        void *  word1;
    };
    struct qq_decls$unitrec* nextunit;
    union {
        struct {
            union {
                struct qq_decls$unitrec* a;
                struct qq_decls$strec *  def;
                struct qq_decls$strec *  labeldef;
                i64 value;
                u64 uvalue;
                r64 xvalue;
                u8 *  svalue;
                i64 range_lower;
                i64 qlower;
                i64 pclopcode;
            };
            union {
                struct qq_decls$unitrec* b;
                i64 range_upper;
                i64 qupper;
                i64 slength;
                i16 mode;
                byte cmpgenop[4];
                struct {
                    i32 length;
                    i32 lower;
                };
                i64 index;
            };
        };
    };
};

struct qq_decls$genfieldrec {
    struct qq_decls$strec *  def;
    struct qq_decls$genfieldrec* nextdef;
};

struct qq_decls$varrec {
    union {
        struct {
            union {
                struct {
                    byte tag;
                    byte hasref;
                    byte bitoffset;
                    union {
                        byte bitlength;
                        byte exceptiontype;
                        byte genmarker;
                    };
                };
                u32 tagx;
            };
            union {
                u32 elemtag;
                u32 frameptr_low;
                struct {
                    i16 frameoffset;
                    i16 nexceptions;
                };
            };
        };
        i64 dummy;
    };
    union {
        i64 value;
        r64 xvalue;
        u64 uvalue;
        u64 range_upper;
        struct qq_decls$objrec *  objptr;
        struct qq_decls$varrec* varptr;
        byte *  ptr;
        struct qq_decls$strec *  def;
        i64 *  retaddr;
    };
};

struct qq_decls$objrec {
    u32 refcount;
    struct {
        byte flags;
        byte objtype;
        union {
            u16 elemtag;
            u16 usertag;
            u16 itertag;
            struct {
                byte bitoffset;
                byte indexoffset;
            };
            i16 lower16;
        };
    };
    union {
        struct {
            union {
                i64 value;
                r64 xvalue;
                u64 uvalue;
                u8 *  strptr;
                struct qq_decls$varrec *  varptr;
                struct qq_decls$varrec *  genstack;
                byte *  ptr;
                i32 (*num)[];
                u64 b;
                i64 *  retaddr;
            };
            union {
                i64 length;
                i64 lower64;
                struct {
                    u32 rows;
                    u32 columns;
                };
                u64 c;
                byte *  frameptr;
                struct {
                    i32 iterpos;
                    i32 iterupper;
                };
            };
            union {
                i64 alloc64;
                struct qq_decls$objrec* objptr2;
                struct {
                    i16 neg;
                    i16 numtype;
                    i32 expon;
                };
                struct {
                    u32 alloc32;
                    u32 dictitems;
                };
                struct {
                    u16 genstacksize;
                    byte ngenparams;
                };
                u64 d;
            };
        };
        byte bignumdescr[24];
    };
};

struct qq_decls$stringrec {
    u8 *  svalue;
    i64 length;
};

struct qq_host$dimrec {
    i64 lbound;
    i64 upper;
    i64 length;
};

struct qq_parse$readterm$dummy {
    union {
        u8 str[20];
        i64 sa;
    };
};

struct qq_print$fmtrec {
    byte minwidth;
    i8 precision;
    byte base;
    u8 quotechar;
    u8 padchar;
    u8 realfmt;
    u8 plus;
    u8 sepchar;
    u8 lettercase;
    u8 justify;
    u8 suffix;
    u8 usigned;
    u8 charmode;
    u8 showtype;
    u8 newline;
    byte spare;
};

struct msysc$procinforec {
    u16 fnindex;
    byte rettype;
    byte nparams;
    byte paramlist[12];
};

struct msysc$fmtrec {
    byte minwidth;
    i8 precision;
    byte base;
    u8 quotechar;
    u8 padchar;
    u8 realfmt;
    u8 plus;
    u8 sepchar;
    u8 lettercase;
    u8 justify;
    u8 suffix;
    u8 usigned;
    u8 charmode;
    u8 heapmode;
    u8 param;
    byte spare;
};

struct mlib$strbuffer {
    u8 *  strptr;
    i32 length;
    i32 allocated;
};

struct mwindows$rsystemtime {
    u16 year;
    u16 month;
    u16 dayofweek;
    u16 day;
    u16 hour;
    u16 minute;
    u16 second;
    u16 milliseconds;
};

#pragma pack(8)
struct mwindows$input_record {
    u16 eventtype;
    u32 keydown;
    u16 repeatcount;
    u16 virtualkeycode;
    u16 virtualscancode;
    union {
        u16 unicodechar;
        byte asciichar;
    };
    u32 controlkeystate;
};
#pragma pack(1)

struct mwindows$rspoint {
    i16 x;
    i16 y;
};

struct mwindows$rsrect {
    i16 leftx;
    i16 top;
    i16 rightx;
    i16 bottom;
};

struct mwindows$rpoint {
    i32 x;
    i32 y;
};

struct mwindows$rconsole {
    struct mwindows$rspoint size;
    struct mwindows$rspoint pos;
    u16 attributes;
    struct mwindows$rsrect window;
    struct mwindows$rspoint maxwindowsize;
};

struct mwindows$rstartupinfo {
    u32 size;
    u32 dummy1;
    u8 *  reserved;
    u8 *  desktop;
    u8 *  title;
    u32 x;
    u32 y;
    u32 xsize;
    u32 ysize;
    u32 xcountchars;
    u32 ycountchars;
    u32 fillattribute;
    u32 flags;
    u16 showwindow;
    u16 reserved2;
    u32 dummy2;
    void *  reserved4;
    void *  stdinput;
    void *  stdoutput;
    void *  stderror;
};

struct mwindows$rprocess_information {
    void *  process;
    void *  thread;
    u32 processid;
    u32 threadid;
};

struct mwindows$rwndclassex {
    u32 size;
    u32 style;
    void (*wndproc)(void);
    i32 clsextra;
    i32 wndextra;
    void *  instance;
    void *  icon;
    void *  cursor;
    void *  background;
    u8 *  menuname;
    u8 *  classname;
    void *  iconsm;
};

struct mwindows$rmsg {
    void *  hwnd;
    u32 message;
    u32 dummy1;
    u64 wparam;
    u64 lparam;
    u32 time;
    u32 dummy2;
    struct mwindows$rpoint pt;
};


/* PROCDECLS */
int main(int, char**, char**);
static void qqcli$getinputoptions(void);
static void qqcli$do_option(i64 sw,u8 *value);
i64 qqcli$runqprogram(i64 run,u8 *filename,u8 *(*qparams)[],i64 nqparams);
static void qqcli$load_program(void);
static void qqcli$parse_program(void);
static void qqcli$rx_program(void);
static void qqcli$gxpcl_program(void);
static void qqcli$optimise_program(void);
static void qqcli$fixup_program(void);
static void qqcli$writeqa_program(void);
static void qqcli$initprogram(void);
static void qqcli$fixproc(struct qq_decls$strec *d);
static void qqcli$fixupmodule(i64 m);
static i64 qqcli$runprogram(u8 *(*cmds)[],i64 ncmds);
static void qqcli$disploop(void);
static void qqcli$disploop_fn(void);
static void qqcli$disploop_deb(i64 fdeb);
static void qqcli$setcmdmap(void);
i64 qqcli$runproc_m(void *amsg);
void qqcli$runproc(void *fnptr,struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *dest);
void qqcli$start(void);
void qq_arrays$var_empty_array(i64 tag,i64 elemtype,i64 lower,struct qq_decls$varrec *dest);
void qq_arrays$obj_free_array(struct qq_decls$objrec *p);
void qq_arrays$obj_free_vector(struct qq_decls$objrec *p);
void qq_arrays$var_make_array(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 lower,i64 n,i64 axtype,i64 elemtype);
struct qq_decls$objrec *qq_arrays$obj_newarray(i64 elemtype,i64 lower,i64 length);
struct qq_decls$objrec *qq_arrays$obj_newarray_u(i64 usertag);
void qq_arrays$var_getix_array(struct qq_decls$varrec *a,i64 index);
void qq_arrays$var_putix_array(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_arrays$var_getixref_array(struct qq_decls$varrec *a,i64 index);
static void qq_arrays$obj_append_array(struct qq_decls$objrec *a,struct qq_decls$varrec *x);
void qq_arrays$var_appendto_array(struct qq_decls$varrec *a,struct qq_decls$varrec *x);
void qq_arrays$obj_resize_array(struct qq_decls$objrec *p,i64 n);
void qq_arrays$var_dupl_array(struct qq_decls$varrec *a);
void qq_arrays$var_dupl_vector(struct qq_decls$varrec *a);
i64 qq_arrays$var_equal_array(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_arrays$var_concatto_array(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_arrays$var_getslice_array(struct qq_decls$varrec *a,i64 i,i64 j);
void qq_arrays$var_putslice_array(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x);
static i64 qq_arrays$u8inarray(byte a,struct qq_decls$objrec *p);
i64 qq_arrays$u16inarray(u16 a,struct qq_decls$objrec *p);
i64 qq_arrays$u32inarray(u32 a,struct qq_decls$objrec *p);
i64 qq_arrays$u64inarray(u64 a,struct qq_decls$objrec *p);
i64 qq_arrays$var_inx_array(struct qq_decls$varrec *a,struct qq_decls$varrec *b,i64 usertag);
void qq_arrays$var_expand_array(struct qq_decls$varrec *p,struct qq_decls$varrec *dest,i64 m);
void qq_arrays$var_nextiter_array(struct qq_decls$varrec *a,struct qq_decls$varrec *dest);
void qq_arrays$start(void);
void qq_bits$obj_free_bits(struct qq_decls$objrec *p,i64 tag);
void qq_bits$var_make_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 lower,i64 n,i64 bxtype,i64 elemtype);
struct qq_decls$objrec *qq_bits$obj_newbits(i64 elemtype,i64 lower,i64 length);
void qq_bits$var_getix_bits(struct qq_decls$varrec *a,i64 index);
void qq_bits$var_putix_bits(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_bits$var_getixref_bits(struct qq_decls$varrec *a,i64 index);
static byte *qq_bits$getindexoffset(byte *p,i64 offset,i64 index,i64 t,i64 *newoffset);
static void qq_bits$obj_append_bits(struct qq_decls$objrec *a,struct qq_decls$varrec *x);
void qq_bits$var_appendto_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *x);
void qq_bits$obj_resize_bits(struct qq_decls$objrec *p,i64 n);
void qq_bits$var_dupl_bits(struct qq_decls$varrec *a);
i64 qq_bits$var_equal_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_bits$var_concatto_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_bits$var_getslice_bits(struct qq_decls$varrec *a,i64 i,i64 j);
void qq_bits$var_putslice_bits(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x);
i64 qq_bits$bits_bytesize(struct qq_decls$objrec *p);
i64 qq_bits$getbitssize(i64 n,i64 t);
void qq_bits$start(void);
void qq_calldll$calldll(struct qq_decls$strec *d,struct qq_decls$varrec *args,struct qq_decls$varrec *result,i64 nargs);
static void (*qq_calldll$getlibprocaddr(struct qq_decls$strec *d))(void);
static u64 qq_calldll$vartopacked(struct qq_decls$varrec *p,struct qq_decls$strec *d);
static void qq_calldll$packedtovar(u64 retval,i64 t,struct qq_decls$varrec *dest);
static void (*qq_calldll$loaddllfunction(struct qq_decls$strec *d))(void);
void qq_calldll$start(void);
void qq_decimal$obj_free_dec(struct qq_decls$objrec *p);
void qq_decimal$var_dupl_dec(struct qq_decls$varrec *a);
void qq_decimal$var_empty_dec(struct qq_decls$varrec *dest);
void qq_decimal$var_make_dec_str(u8 *s,i64 length,struct qq_decls$varrec *dest);
void qq_decimal$var_make_dec_int(i64 a,struct qq_decls$varrec *dest);
static struct qq_decls$objrec *qq_decimal$badnumber(void);
static struct qq_decls$objrec *qq_decimal$bn_makestr(u8 *s,i64 length);
static i64 qq_decimal$readexpon(u8 *s);
static struct qq_decls$objrec *qq_decimal$bn_makeint(i64 x);
u8 *qq_decimal$var_tostr_dec(struct qq_decls$varrec *a,i64 fmt);
static u8 *qq_decimal$obj_tostr_dec(struct qq_decls$objrec *a,i64 fmt);
static u8 *qq_decimal$tostring_scient(struct qq_decls$objrec *a);
static u8 *qq_decimal$tostring_float(struct qq_decls$objrec *a,i64 fmt);
static i64 qq_decimal$strvaln(u8 *s,i64 n);
static i64 qq_decimal$bn_isint(struct qq_decls$objrec *a);
i64 qq_decimal$obj_len_dec(struct qq_decls$objrec *a);
i64 qq_decimal$bn_iszero(struct qq_decls$objrec *a);
i64 qq_decimal$var_equal_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_decimal$var_add_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_decimal$var_sub_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_decimal$var_mul_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_decimal$var_div_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_decimal$var_idiv_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_decimal$var_irem_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_decimal$var_neg_dec(struct qq_decls$varrec *a);
void qq_decimal$var_abs_dec(struct qq_decls$varrec *a);
i64 qq_decimal$var_compare_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
static i64 qq_decimal$bn_cmp(struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static i64 qq_decimal$bn_equal(struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static i64 qq_decimal$bn_add(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static i64 qq_decimal$bn_sub(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static void qq_decimal$bn_addu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static void qq_decimal$bn_subu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static struct qq_decls$objrec *qq_decimal$makebignum(i64 length);
static i32 *qq_decimal$makesmallnum(i64 length);
static struct qq_decls$objrec *qq_decimal$smalltobig(struct qq_decls$objrec *c,i32 *a,i64 length,i64 alloc,i64 offset);
static void qq_decimal$freesmall(i32 *p,i64 length);
struct qq_decls$objrec *qq_decimal$bn_init(void);
static void qq_decimal$bn_setzero(struct qq_decls$objrec *a);
static void qq_decimal$bn_move(struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static void qq_decimal$bn_dupl(struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static void qq_decimal$bn_setinf(struct qq_decls$objrec *dest);
static void qq_decimal$bn_setnan(struct qq_decls$objrec *dest);
void qq_decimal$var_setnan(struct qq_decls$varrec *dest);
void qq_decimal$var_setinf(struct qq_decls$varrec *dest);
static i64 qq_decimal$getbintype(struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static void qq_decimal$bn_negto(struct qq_decls$objrec *a);
static void qq_decimal$bn_absto(struct qq_decls$objrec *a);
static i64 qq_decimal$bn_mul(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static i64 qq_decimal$bn_mulp(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,i64 prec);
static void qq_decimal$bn_mulu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static i64 qq_decimal$smallmulto(i32 *p,i32 *q,i64 plen,i64 m);
static i64 qq_decimal$bn_div(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,i64 prec);
static i64 qq_decimal$bn_idiv(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static i64 qq_decimal$bn_idivrem(struct qq_decls$objrec *dest,struct qq_decls$objrec *rm,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static i64 qq_decimal$bn_irem(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b);
static void qq_decimal$bn_idivu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,struct qq_decls$objrec *rm);
static void qq_decimal$bn_fdivu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,i64 precision);
static i64 qq_decimal$smalldiv(i32 *x,i32 *b,i64 *xlen,i64 nb);
static i64 qq_decimal$smallsubto(i32 *p,i32 *q,i64 plen,i64 qlen);
static i64 qq_decimal$bn_getprec(struct qq_decls$objrec *a);
static void qq_decimal$bn_setprec(struct qq_decls$objrec *a,i64 prec);
static i64 qq_decimal$bn_getglobalprec(void);
static void qq_decimal$bn_setglobalprec(i64 prec);
static struct qq_decls$objrec *qq_decimal$bn_makefloat(r64 x);
struct qq_decls$varrec *qq_decimal$dectemp(struct qq_decls$varrec *a);
void qq_decimal$freedectemp(void);
static void qq_decimal$bn_ipower(struct qq_decls$objrec *d,struct qq_decls$objrec *a,i64 n);
void qq_decimal$var_power_dec(struct qq_decls$varrec *a,i64 n);
i64 qq_decimal$var_convert_dec_int(struct qq_decls$varrec *a);
static i64 qq_decimal$bn_toint(struct qq_decls$objrec *a);
void qq_decimal$start(void);
void qq_decls$start(void);
void qq_dicts$var_make_dict(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n);
struct qq_decls$objrec *qq_dicts$obj_new_dict(i64 n);
void qq_dicts$obj_free_dict(struct qq_decls$objrec *p,i64 internal);
void qq_dicts$var_dupl_dict(struct qq_decls$varrec *a);
i64 qq_dicts$var_equal_dict(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
struct qq_decls$varrec *qq_dicts$var_finddictitem(struct qq_decls$varrec *vd,struct qq_decls$varrec *p,i64 doins);
static void qq_dicts$expanddict(struct qq_decls$varrec *vd);
static void qq_dicts$adddictitem(struct qq_decls$varrec *d,struct qq_decls$varrec *p,struct qq_decls$varrec *q);
void qq_dicts$var_checkiter_dict(struct qq_decls$varrec *a,struct qq_decls$varrec *dest);
void qq_dicts$var_nextiter_dict(struct qq_decls$varrec *a,struct qq_decls$varrec *dest);
void qq_dicts$start(void);
void qq_iterators$var_make_iter(struct qq_decls$varrec *a,struct qq_decls$varrec *dest);
void qq_iterators$var_check_iter(struct qq_decls$varrec *a,struct qq_decls$varrec *dest);
void qq_iterators$var_next_iter(struct qq_decls$varrec *a,struct qq_decls$varrec *dest);
void qq_iterators$obj_free_iter(struct qq_decls$objrec *p);
void qq_iterators$var_dupl_iter(struct qq_decls$varrec *a);
void qq_iterators$start(void);
i64 qq_jhandlers_hll$asmavailable(void);
i64 *qq_jhandlers_hll$disploop_asm(void);
void qq_jhandlers_hll$initjhandlers(void);
void qq_jhandlers_hll$start(void);
void qq_khandlers$initkhandlers(void);
void qq_khandlers$kunimpl(void);
void qq_khandlers$k_pushci(void);
void qq_khandlers$k_pushtrue(void);
void qq_khandlers$k_pushfalse(void);
void qq_khandlers$k_pushcu(void);
void qq_khandlers$k_pushnil(void);
void qq_khandlers$k_pushcs(void);
void qq_khandlers$k_pushcr(void);
void qq_khandlers$k_pushenum(void);
void qq_khandlers$k_stop(void);
void qq_khandlers$k_stoprunproc(void);
void qq_khandlers$k_pushm(void);
void qq_khandlers$k_pushf(void);
void qq_khandlers$k_pushff(void);
void qq_khandlers$k_pushmref(void);
void qq_khandlers$k_pushfref(void);
void qq_khandlers$k_popm(void);
void qq_khandlers$k_storem(void);
void qq_khandlers$k_zpopm(void);
void qq_khandlers$k_popf(void);
void qq_khandlers$k_storef(void);
void qq_khandlers$k_zpopf(void);
void qq_khandlers$k_popretval(void);
void qq_khandlers$k_tom(void);
void qq_khandlers$k_tof(void);
void qq_khandlers$k_add(void);
void qq_khandlers$k_sub(void);
void qq_khandlers$k_mul(void);
void qq_khandlers$k_div(void);
void qq_khandlers$k_idiv(void);
void qq_khandlers$k_irem(void);
void qq_khandlers$k_iand(void);
void qq_khandlers$k_ior(void);
void qq_khandlers$k_ixor(void);
void qq_khandlers$k_shl(void);
void qq_khandlers$k_shr(void);
void qq_khandlers$k_sqr(void);
void qq_khandlers$k_sign(void);
void qq_khandlers$k_sqrt(void);
void qq_khandlers$k_sin(void);
void qq_khandlers$k_cos(void);
void qq_khandlers$k_tan(void);
void qq_khandlers$k_asin(void);
void qq_khandlers$k_acos(void);
void qq_khandlers$k_atan(void);
void qq_khandlers$k_ln(void);
void qq_khandlers$k_log(void);
void qq_khandlers$k_lg(void);
void qq_khandlers$k_exp(void);
void qq_khandlers$k_round(void);
void qq_khandlers$k_floor(void);
void qq_khandlers$k_ceil(void);
void qq_khandlers$k_fract(void);
void qq_khandlers$k_neg(void);
void qq_khandlers$k_negto(void);
void qq_khandlers$k_absto(void);
void qq_khandlers$k_inotto(void);
void qq_khandlers$k_atan2(void);
void qq_khandlers$k_fmod(void);
void qq_khandlers$k_abs(void);
void qq_khandlers$k_inot(void);
void qq_khandlers$k_istruel(void);
void qq_khandlers$k_notl(void);
void qq_khandlers$k_jumpeq(void);
void qq_khandlers$k_jumpne(void);
void qq_khandlers$k_jumplt(void);
void qq_khandlers$k_jumple(void);
void qq_khandlers$k_jumpge(void);
void qq_khandlers$k_jumpgt(void);
void qq_khandlers$k_jumpfalse(void);
void qq_khandlers$k_jumptrue(void);
void qq_khandlers$k_incrtom(void);
void qq_khandlers$k_incrtof(void);
void qq_khandlers$k_decrtom(void);
void qq_khandlers$k_decrtof(void);
void qq_khandlers$k_incrload(void);
void qq_khandlers$k_loadincr(void);
void qq_khandlers$k_decrload(void);
void qq_khandlers$k_loaddecr(void);
void qq_khandlers$k_incrptr(void);
void qq_khandlers$k_decrptr(void);
void qq_khandlers$k_pushvoid(void);
void qq_khandlers$k_callproc(void);
void qq_khandlers$k_callptr(void);
void qq_khandlers$k_procentry(void);
void qq_khandlers$k_return(void);
void qq_khandlers$k_return0(void);
void qq_khandlers$k_unshare(void);
void qq_khandlers$k_unshare1(void);
void qq_khandlers$k_formci(void);
void qq_khandlers$k_forfci(void);
void qq_khandlers$k_fordmci(void);
void qq_khandlers$k_fordfci(void);
void qq_khandlers$k_formm(void);
void qq_khandlers$k_fordmm(void);
void qq_khandlers$k_forff(void);
void qq_khandlers$k_fordff(void);
void qq_khandlers$k_comment(void);
void qq_khandlers$k_makelist(void);
void qq_khandlers$k_makedict(void);
void qq_khandlers$k_makeset(void);
void qq_khandlers$k_makerecord(void);
void qq_khandlers$k_makestruct(void);
void qq_khandlers$k_makearray(void);
void qq_khandlers$k_makebits(void);
void qq_khandlers$k_index(void);
void qq_khandlers$k_popindex(void);
void qq_khandlers$k_indexref(void);
void qq_khandlers$k_keyindex(void);
void qq_khandlers$k_popkeyindex(void);
void qq_khandlers$k_keyindexref(void);
void qq_khandlers$k_dot(void);
void qq_khandlers$k_dotref(void);
void qq_khandlers$k_popdot(void);
void qq_khandlers$k_dotindex(void);
void qq_khandlers$k_dotindexref(void);
void qq_khandlers$k_popdotindex(void);
void qq_khandlers$k_len(void);
void qq_khandlers$k_upb(void);
void qq_khandlers$k_lwb(void);
void qq_khandlers$k_bounds(void);
void qq_khandlers$k_boundsx(void);
static void qq_khandlers$do_bounds(i64 sx);
void qq_khandlers$k_dictitems(void);
void qq_khandlers$k_isfound(void);
void qq_khandlers$k_append(void);
void qq_khandlers$k_concat(void);
void qq_khandlers$k_appendto(void);
void qq_khandlers$k_concatto(void);
void qq_khandlers$k_addto(void);
void qq_khandlers$k_subto(void);
void qq_khandlers$k_multo(void);
void qq_khandlers$k_divto(void);
void qq_khandlers$k_idivto(void);
void qq_khandlers$k_iandto(void);
void qq_khandlers$k_iorto(void);
void qq_khandlers$k_ixorto(void);
void qq_khandlers$k_shlto(void);
void qq_khandlers$k_shrto(void);
void qq_khandlers$k_copy(void);
void qq_khandlers$k_dupl(void);
void qq_khandlers$k_makerange(void);
void qq_khandlers$k_makerangelen(void);
void qq_khandlers$k_makedecimal(void);
static struct qq_decls$strec *qq_khandlers$resolvefield(i64 index,i64 rectype);
void qq_khandlers$k_pushptr(void);
void qq_khandlers$k_popptr(void);
void qq_khandlers$k_islist(void);
void qq_khandlers$k_isarray(void);
void qq_khandlers$k_isstring(void);
void qq_khandlers$k_isrecord(void);
void qq_khandlers$k_swap(void);
void qq_khandlers$k_jumptesteq(void);
void qq_khandlers$k_jumptestne(void);
void qq_khandlers$k_jump(void);
void qq_khandlers$k_jumpptr(void);
void qq_khandlers$k_incr(void);
void qq_khandlers$k_decr(void);
void qq_khandlers$k_chr(void);
void qq_khandlers$k_asc(void);
void qq_khandlers$k_pusht(void);
void qq_khandlers$k_type(void);
void qq_khandlers$k_basetype(void);
void qq_khandlers$k_usertype(void);
void qq_khandlers$k_elemtype(void);
void qq_khandlers$k_nop(void);
void qq_khandlers$k_modulecall(void);
void qq_khandlers$k_modulereturn(void);
void qq_khandlers$k_maxvalue(void);
void qq_khandlers$k_minvalue(void);
void qq_khandlers$k_callhost(void);
void qq_khandlers$k_expand(void);
void qq_khandlers$k_pushsymbol(void);
void qq_khandlers$k_eq(void);
void qq_khandlers$k_ne(void);
void qq_khandlers$k_lt(void);
void qq_khandlers$k_le(void);
void qq_khandlers$k_ge(void);
void qq_khandlers$k_gt(void);
static void qq_khandlers$do_cmp(i64 opc);
void qq_khandlers$k_calldll(void);
void qq_khandlers$k_in(void);
void qq_khandlers$k_notin(void);
void qq_khandlers$k_inx(void);
void qq_khandlers$k_convrefpack(void);
void qq_khandlers$k_isdef(void);
void qq_khandlers$k_isvoid(void);
void qq_khandlers$k_isint(void);
void qq_khandlers$k_isnumber(void);
void qq_khandlers$k_ismutable(void);
void qq_khandlers$k_isreal(void);
void qq_khandlers$k_isrange(void);
void qq_khandlers$k_isset(void);
void qq_khandlers$k_ispointer(void);
static void qq_khandlers$istype(i64 t1,i64 t2);
void qq_khandlers$k_convert(void);
void qq_khandlers$k_switch(void);
void qq_khandlers$k_bytesize(void);
void qq_khandlers$k_bitwidth(void);
void qq_khandlers$k_min(void);
void qq_khandlers$k_max(void);
void qq_khandlers$k_addsp(void);
void qq_khandlers$k_pushtry(void);
void qq_khandlers$k_raise(void);
void qq_khandlers$k_isequal(void);
void qq_khandlers$k_minto(void);
void qq_khandlers$k_maxto(void);
void qq_khandlers$k_power(void);
static void qq_khandlers$domaths(i64 opcode);
static r64 qq_khandlers$getmaths(i64 opcode,r64 x);
void qq_khandlers$k_typepun(void);
void qq_khandlers$k_andlto(void);
void qq_khandlers$k_orlto(void);
void qq_khandlers$k_notlto(void);
void qq_khandlers$k_pushoperator(void);
void qq_khandlers$k_maps(void);
void qq_khandlers$k_mapss(void);
void qq_khandlers$k_idivrem(void);
void qq_khandlers$k_odd(void);
void qq_khandlers$k_even(void);
void qq_khandlers$start(void);
void qq_host$callhostfunction(i64 hostfn);
void qq_host$inithostlib(void);
static void qq_host$pch_leftstr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result);
static void qq_host$pch_rightstr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result);
static void qq_host$pch_convlc(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result);
static void qq_host$pch_convuc(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result);
static void qq_host$pch_waitkey(struct qq_decls$varrec *result);
static void qq_host$pch_execwait(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result);
static void qq_host$pch_execcmd(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result);
static void qq_host$pch_makestr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result);
static void qq_host$pch_makeref(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result);
static void qq_host$pch_getcmdparam(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static void qq_host$pch_clock(struct qq_decls$varrec *result);
static void qq_host$pch_allocexec(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static void qq_host$pch_runnative(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result);
static void qq_host$pch_setlwb(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
static void qq_host$pch_ticks(struct qq_decls$varrec *result);
static void qq_host$pch_sleep(struct qq_decls$varrec *a);
static void qq_host$pch_random(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static void qq_host$pch_system(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static void qq_host$pch_$getparam(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static i64 qq_host$checkparam(struct qq_decls$varrec *p,i64 tag,i64 defaultx);
static void qq_host$leftstring(struct qq_decls$varrec *a,i64 n,struct qq_decls$varrec *result);
static void qq_host$rightstring(struct qq_decls$varrec *a,i64 n,struct qq_decls$varrec *result);
static void qq_host$padstring_right(struct qq_decls$varrec *a,i64 n,i64 fillchar,struct qq_decls$varrec *result);
static void qq_host$padstring_left(struct qq_decls$varrec *a,i64 n,i64 fillchar,struct qq_decls$varrec *result);
static void qq_host$getbounds(struct qq_decls$varrec *p,struct qq_host$dimrec *dims,i64 lower);
static void qq_host$pch_new(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *d,struct qq_decls$varrec *result);
void qq_host$pch_gethostname(struct qq_decls$varrec *result);
void qq_host$pch_getprogname(struct qq_decls$varrec *result);
static void qq_host$pch_$test(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static void qq_host$pch_$test2(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static void qq_host$pch_$refcount(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static void qq_host$pch_testkey(struct qq_decls$varrec *result);
static void qq_host$pch_getos(struct qq_decls$varrec *result);
static void qq_host$pch_$procsymbols(struct qq_decls$varrec *result);
static void qq_host$pch_$symbolowner(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static void qq_host$pch_$symbolname(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static void qq_host$pch_$symboldefs(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
void qq_host$pch_setmesshandler(struct qq_decls$varrec *fn);
static void qq_host$pch_$testcallback(void);
static void qq_host$pch_$smallmemtotal(struct qq_decls$varrec *result);
static void qq_host$pch_$id(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
void qq_host$pch_iswindows(struct qq_decls$varrec *result);
static void qq_host$pch_$setdebug(struct qq_decls$varrec *a);
static void qq_host$pch_copy(struct qq_decls$varrec *a,struct qq_decls$varrec *dest);
static void qq_host$pch_gethash(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static void qq_host$pch_makeempty(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static void qq_host$pch_$infinity(struct qq_decls$varrec *dest);
static void qq_host$pch_$nan(struct qq_decls$varrec *dest);
void qq_host$setcmdparam(i64 index,u8 *s);
static void qq_host$pch_makeiter(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static void qq_host$pch_checkiter(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
static void qq_host$pch_nextiter(struct qq_decls$varrec *a,struct qq_decls$varrec *result);
void qq_host$start(void);
void qq_lex$lexreadtoken(void);
static void qq_lex$lxreadstring(i64 termchar);
void qq_lex$lexinit(void);
static void qq_lex$readrawstring(void);
i64 qq_lex$lookup(u8 *name,i64 length,i64 hashindex);
i64 qq_lex$gethashvaluez(u8 *s);
static void qq_lex$inithashtable(void);
static void qq_lex$addstname(u8 *name,i64 symbol,i64 subcode);
void qq_lex$startlex(i64 fileno,i64 moduleno);
struct qq_decls$strec *qq_lex$addnamestr(u8 *name);
void qq_lex$ps1(u8 *caption);
void qq_lex$ps2(u8 *caption);
void qq_lex$lex(void);
static i64 qq_lex$setinttype(u64 a);
void qq_lex$lxerror_s(u8 *mess,u8 *a);
void qq_lex$stacksource(i64 fileno);
void qq_lex$unstacksource(void);
static void qq_lex$makedecimal(u8 *s,i64 length,i64 base);
static void qq_lex$readdec(void);
static void qq_lex$readhex(void);
static void qq_lex$readbin(void);
static void qq_lex$readreal(void);
static void qq_lex$readrawxname(void);
void qq_lex$start(void);
void qq_lib$reportcterror(u8 *errortype,u8 *mess,i64 pos,struct qq_decls$strec *currproc);
void qq_lib$geterrorinfo(u64 pos,struct qq_decls$strec *currproc);
i64 qq_lib$getlineno(u8 *source,i64 offset);
static void qq_lib$showerrorsource(void);
void qq_lib$stopcompiler(struct qq_decls$modulerec *m,i64 lineno);
void qq_lib$gerror(u8 *mess,struct qq_decls$unitrec *p);
void qq_lib$gerror_s(u8 *mess,u8 *param,struct qq_decls$unitrec *p);
void qq_lib$serror(u8 *mess);
void qq_lib$serror_s(u8 *mess,u8 *param);
void qq_lib$rxerror(u8 *mess,struct qq_decls$unitrec *p);
void qq_lib$rxerror_s(u8 *mess,u8 *param,struct qq_decls$unitrec *p);
void qq_lib$lxerror(u8 *mess);
void qq_lib$pcerror(u8 *mess);
void qq_lib$pcerror_s(u8 *mess,u8 *param);
void qq_lib$reportpcerror(u8 *mess,i64 pos,struct qq_decls$strec *currproc);
static void qq_lib$getpcerrorpos(i64 *pc);
void qq_lib$loaderror(u8 *mess,u8 *mess2,u8 *mess3);
static i64 qq_lib$findmodulefrompc(i64 *pc);
void qq_lib$prterror(u8 *mess);
void qq_lib$pcustype(u8 *mess,struct qq_decls$varrec *x);
void qq_lib$pcustype_t(u8 *mess,i64 t);
void qq_lib$pcmxtypes(u8 *mess,struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_lib$pcmxtypestt(u8 *mess,i64 t,i64 u);
struct qq_decls$unitrec *qq_lib$allocunitrec(void);
struct qq_decls$unitrec *qq_lib$createintunit(i64 a);
struct qq_decls$unitrec *qq_lib$createboolunit(i64 a);
struct qq_decls$unitrec *qq_lib$createwordunit(i64 a);
struct qq_decls$unitrec *qq_lib$createrealunit(r64 x);
struct qq_decls$unitrec *qq_lib$createstringunit(u8 *s,i64 slength);
struct qq_decls$unitrec *qq_lib$createunit0(i64 tag);
struct qq_decls$unitrec *qq_lib$createunit1(i64 tag,struct qq_decls$unitrec *p);
struct qq_decls$unitrec *qq_lib$createunit2(i64 tag,struct qq_decls$unitrec *p,struct qq_decls$unitrec *q);
struct qq_decls$unitrec *qq_lib$createname(struct qq_decls$strec *p);
void qq_lib$addlistunit(struct qq_decls$unitrec **ulist,struct qq_decls$unitrec **ulistx,struct qq_decls$unitrec *p);
struct qq_decls$unitrec *qq_lib$getrangelwbunit(struct qq_decls$unitrec *p);
struct qq_decls$unitrec *qq_lib$getrangeupbunit(struct qq_decls$unitrec *p);
struct qq_decls$unitrec *qq_lib$createavname(void);
u8 *qq_lib$convtostringz(u8 *svalue,i64 length);
u8 *qq_lib$findprocname(void (*fnptr)(void));
struct mlib$strbuffer *qq_lib$strexpr(struct qq_decls$unitrec *p);
u8 *qq_lib$strexpr_s(struct qq_decls$unitrec *p);
static void qq_lib$jeval(struct qq_decls$unitrec *p);
void qq_lib$additem(u8 *s);
static i64 qq_lib$isalphanum(i64 c);
u8 *qq_lib$getopcname(i64 opc);
void qq_lib$convertstring(u8 *s,u8 *t);
u8 *qq_lib$extractstringz(struct qq_decls$varrec *p);
struct qq_decls$unitrec *qq_lib$createavnamex(struct qq_decls$strec *owner);
void qq_lib$storemode(struct qq_decls$strec *owner,i64 m,i16 *p);
i64 qq_lib$nextpoweroftwo(i64 x);
i64 *qq_lib$raiseexception(i64 exceptno);
void qq_lib$raise_error(i64 error_no);
static void qq_lib$default_exception(i64 exceptno);
i64 qq_lib$testelem(byte (*p)[],i64 n);
void qq_lib$setelem(byte (*p)[],i64 n);
void qq_lib$setelemblock(byte (*p)[],i64 a,i64 b);
i64 qq_lib$ispoweroftwo(i64 x);
void qq_lib$deleteunit(struct qq_decls$unitrec *p,struct qq_decls$unitrec *q);
u8 *qq_lib$getenumname(i64 m,i64 index);
void qq_lib$start(void);
void qq_lists$start(void);
void qq_lists$var_empty_list(i64 lower,struct qq_decls$varrec *dest);
void qq_lists$var_make_list(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n,i64 lower);
struct qq_decls$objrec *qq_lists$obj_newlist(i64 n,i64 lower,struct qq_decls$varrec *defval);
void qq_lists$obj_free_list(struct qq_decls$objrec *p);
void qq_lists$var_getix_list(struct qq_decls$varrec *a,i64 index);
void qq_lists$var_getslice_list(struct qq_decls$varrec *a,i64 i,i64 j);
void qq_lists$var_getixref_list(struct qq_decls$varrec *a,i64 index);
void qq_lists$var_putix_list(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_lists$var_putslice_list(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x);
static void qq_lists$obj_append_list(struct qq_decls$objrec *a,struct qq_decls$varrec *x);
void qq_lists$obj_resize_list(struct qq_decls$objrec *p,i64 n);
void qq_lists$var_appendto_list(struct qq_decls$varrec *a,struct qq_decls$varrec *x);
void qq_lists$var_dupl_list(struct qq_decls$varrec *a);
void qq_lists$var_mul_list(struct qq_decls$varrec *p,i64 m);
i64 qq_lists$var_equal_list(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_lists$var_concatto_list(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_lists$var_inx_list(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_lists$var_nextiter_list(struct qq_decls$varrec *a,struct qq_decls$varrec *dest);
void qq_modules$readprojectfile(u8 *filename);
static void qq_modules$initheadervars(void);
static void qq_modules$readmoduledir(void);
static void qq_modules$addmodule(u8 *modulename,struct qq_decls$strec *stalias);
static void qq_modules$addsubprogram(u8 *subprogname,i64 fileno);
static void qq_modules$addfirstsubprogram(u8 *progname,i64 fileno);
static void qq_modules$readsubprogram(void);
static void qq_modules$readimport(void);
static u8 *qq_modules$readvar(void);
static u8 *qq_modules$fixpath(u8 *path);
static void qq_modules$setmixedprogram(u8 *basefile);
static void qq_modules$setmixedimport(void);
void qq_modules$loadmodules(void);
static void qq_modules$loadmodule(struct qq_decls$modulerec *pm);
static void qq_modules$addsyslib(void);
i64 qq_modules$getsupportfile(u8 *filename,u8 *ext,u8 *path,i64 issyslib,i64 issupport);
static i64 qq_modules$isabspath(u8 *filespec);
i64 qq_modules$loadsourcefile(u8 *filespec);
static u8 *qq_modules$readfileline(u8 *s);
static u8 *qq_modules$findnextlineheader(u8 *s);
static i64 qq_modules$loadbundledfile(u8 *filespec,i64 issyslib,i64 support);
static u8 *qq_modules$loadqafile(u8 *filespec,u8 *builtinstr);
void qq_modules$start(void);
struct qq_decls$strec *qq_names$addglobalname(u8 *name);
static struct qq_decls$strec *qq_names$newstrec(void);
struct qq_decls$strec *qq_names$addsymbol(struct qq_decls$strec *owner,struct qq_decls$strec *d,i64 id,i64 isglobal);
void qq_names$addproc(struct qq_decls$strec *d);
struct qq_decls$strec *qq_names$createstroot(u8 *name);
i64 qq_names$newusertypex(struct qq_decls$strec *d,struct qq_decls$strec *e);
struct qq_decls$strec *qq_names$resolvedottedname(struct qq_decls$strec *owner,struct qq_decls$strec *d);
void qq_names$addgenfield(struct qq_decls$strec *d);
i64 qq_names$addusertype(struct qq_decls$strec *d);
i64 qq_names$makereftype(i64 target,struct qq_decls$strec *owner);
i64 qq_names$makeaxtype(i64 target,struct qq_decls$unitrec *plower,struct qq_decls$unitrec *plength);
i64 qq_names$makeslicetype(i64 target);
i64 qq_names$makestrtype(i64 m,struct qq_decls$unitrec *pwidth);
i64 qq_names$addanontype(void);
void qq_names$createusertype(struct qq_decls$strec *d,i64 m);
i64 qq_names$getalignment(i64 m);
void qq_names$duplfield(struct qq_decls$strec *p,struct qq_decls$strec *q);
static void qq_names$writesig(struct qq_decls$strec *d,void *dev);
void qq_names$writedocs(struct qq_decls$strec *d,u8 *(*docstrings)[],i64 ndocstrings);
struct qq_decls$strec *qq_names$createdupldef(struct qq_decls$strec *owner,struct qq_decls$strec *symptr,i64 id);
struct qq_decls$strec *qq_names$createnewmoduledef(struct qq_decls$strec *owner,struct qq_decls$strec *symptr,i64 id);
void qq_names$start(void);
void qq_optim$optimise_module(i64 n);
static void qq_optim$putnops(i64 offset,i64 n);
static void qq_optim$optimise_op(i64 cmd);
void qq_optim$start(void);
void qq_packed$var_loadpacked(void *p,i64 t,struct qq_decls$varrec *dest,struct qq_decls$objrec *ownerobj);
void qq_packed$var_storepacked(byte *p,struct qq_decls$varrec *q,i64 t);
static void qq_packed$setfslength(u8 *s,i64 m,i64 n);
i64 qq_packed$getfslength(u8 *s,i64 m);
void qq_packed$var_make_struct(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n,i64 rectype);
struct qq_decls$objrec *qq_packed$obj_new_struct(i64 m);
void qq_packed$var_dupl_struct(struct qq_decls$varrec *a);
void qq_packed$obj_free_struct(struct qq_decls$objrec *p);
i64 qq_packed$var_equal_struct(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_packed$var_getix_struct(struct qq_decls$varrec *a,i64 index);
void qq_packed$start(void);
void qq_parse$parsemodule(i64 n);
static struct qq_decls$unitrec *qq_parse$readexpression(void);
static struct qq_decls$unitrec *qq_parse$readassignment(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readorterms(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readandterms(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readcmpterms(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readinterms(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readrangeterm(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readaddterms(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readmulterms(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readpowerterms(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readterm2(void);
static struct qq_decls$unitrec *qq_parse$readtermsuffix(struct qq_decls$unitrec *p,i64 pos);
static struct qq_decls$unitrec *qq_parse$readterm(void);
static struct qq_decls$unitrec *qq_parse$readxunit(void);
static struct qq_decls$unitrec *qq_parse$readsunit(i64 inwhile);
void qq_parse$checksymbol(i64 symbol);
static void qq_parse$checkequals(void);
static i64 qq_parse$checkbegin(i64 fbrack);
static void qq_parse$checkbeginend(i64 closesym,i64 kwd,i64 startline);
void qq_parse$skipsemi(void);
static struct qq_decls$unitrec *qq_parse$readindex(struct qq_decls$unitrec *p,i64 dot);
static struct qq_decls$unitrec *qq_parse$readdotsuffix(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readslist(i64 *nparams,i64 ftrailing);
static struct qq_decls$unitrec *qq_parse$readcondsuffix(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readkeyindex(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readlbrack(void);
static struct qq_decls$unitrec *qq_parse$readif(void);
static void qq_parse$checkend(i64 endsym,i64 endkwd1,i64 endkwd2,i64 startline);
static struct qq_decls$unitrec *qq_parse$readunless(void);
static struct qq_decls$unitrec *qq_parse$readwhile(void);
static struct qq_decls$unitrec *qq_parse$readrepeat(void);
static struct qq_decls$unitrec *qq_parse$readfor(void);
static struct qq_decls$unitrec *qq_parse$readdo(void);
static struct qq_decls$unitrec *qq_parse$readto(void);
static struct qq_decls$unitrec *qq_parse$makeblock(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_parse$readvardef(i64 islet,i64 isglobal,i64 isstatic);
static void qq_parse$readconstdef(i64 isglobal);
static struct qq_decls$unitrec *qq_parse$readreturn(void);
static struct qq_decls$unitrec *qq_parse$readprint(void);
static struct qq_decls$unitrec *qq_parse$readread(void);
static struct qq_decls$unitrec *qq_parse$readloopcontrol(void);
static struct qq_decls$unitrec *qq_parse$readintunit(void);
static struct qq_decls$unitrec *qq_parse$readswitchcase(void);
static struct qq_decls$unitrec *qq_parse$readgoto(void);
static struct qq_decls$unitrec *qq_parse$readstop(void);
static struct qq_decls$unitrec *qq_parse$readcast(void);
static struct qq_decls$unitrec *qq_parse$readset(void);
void qq_parse$readtabledef(i64 isglobal);
static struct qq_decls$unitrec *qq_parse$readtry(void);
static struct qq_decls$unitrec *qq_parse$readsprint(void);
static struct qq_decls$unitrec *qq_parse$readsread(void);
static void qq_parse$readimportdll(void);
static void qq_parse$readffiparams(struct qq_decls$strec *stproc);
static void qq_parse$readtypeparams(struct qq_decls$strec *stproc,i64 ptype);
static void qq_parse$readtypenameparams(struct qq_decls$strec *stproc,i64 ptype);
void qq_parse$readrecorddef(i64 isglobal,struct qq_decls$strec *d);
static i64 qq_parse$readrecordbody(struct qq_decls$strec *owner);
static void qq_parse$readrecordfields(struct qq_decls$strec *owner);
static i64 qq_parse$readstructbody(struct qq_decls$strec *owner,i64 caligned);
static void qq_parse$addstructflag(struct qq_decls$strec *owner,i64 id);
static void qq_parse$readprocdef(i64 isglobal);
static struct qq_decls$strec *qq_parse$readatfield(void);
static i64 qq_parse$istypestarter(void);
static void qq_parse$readmacrodef(i64 isglobal);
static struct qq_decls$unitrec *qq_parse$readhostparams(struct qq_decls$unitrec *lhs,i64 isfn);
static void qq_parse$pushlisttype(i64 ltype);
static void qq_parse$poplisttype(void);
static struct qq_decls$unitrec *qq_parse$readcompilervar(void);
static struct qq_decls$unitrec *qq_parse$readmap(void);
void qq_parse$lexchecksymbol(i64 symbol);
static void qq_parse$readtypedef(i64 isglobal);
static i64 qq_parse$readtypespec(i64 allowvar,struct qq_decls$strec *owner);
static void qq_parse$readreturntype(struct qq_decls$strec *stproc);
static void qq_parse$readprocsig(struct qq_decls$strec *stproc,i64 isfunc);
static void qq_parse$readparams(struct qq_decls$strec *stproc,i64 pmode);
static void qq_parse$readparams_names(struct qq_decls$strec *stproc);
static struct qq_decls$unitrec *qq_parse$checkoperator(void);
static struct qq_decls$unitrec *qq_parse$readlist(void);
void qq_parse$start(void);
void qq_print$pch_print(struct qq_decls$varrec *p,struct qq_decls$varrec *fmt);
void qq_print$pch_print_nf(struct qq_decls$varrec *p);
void qq_print$pch_printnogap(void);
void qq_print$pch_println(void);
void qq_print$pch_reread(void);
void qq_print$pch_rereadln(void);
static void qq_print$pch_startprint(struct qq_decls$varrec *p);
void qq_print$pch_startprintcon(void);
void qq_print$pch_endprint(void);
void qq_print$pch_strstartprint(void);
void qq_print$pch_strendprint(struct qq_decls$varrec *dest);
void qq_print$pch_printspace(void);
void qq_print$pch_readln(struct qq_decls$varrec *dev);
static void qq_print$pc_readlinen(void *handlex,u8 *buffer,i64 size);
void qq_print$pch_sread(struct qq_decls$varrec *fmt,struct qq_decls$varrec *dest);
void qq_print$pch_sreadln(struct qq_decls$varrec *dev,struct qq_decls$varrec *dest);
static u8 *qq_print$readname(u8 *s,i64 length,struct qq_decls$varrec *dest);
static u8 *qq_print$readstring(u8 *s,i64 length,struct qq_decls$varrec *dest);
static u8 *qq_print$readint(u8 *sold,i64 length,struct qq_decls$varrec *dest,i64 dodec);
static u8 *qq_print$readhex(u8 *sold,i64 length,struct qq_decls$varrec *dest);
static u8 *qq_print$readbin(u8 *sold,i64 length,struct qq_decls$varrec *dest);
static u8 *qq_print$readreal(u8 *sold,i64 length,struct qq_decls$varrec *dest);
i64 qq_print$getreadfmtcode(struct qq_decls$varrec *p);
static void qq_print$stepkbpos(u8 *s);
static u8 *qq_print$readany(u8 *sold,i64 length,struct qq_decls$varrec *dest);
static u8 *qq_print$readitem(u8 *s,i64 length,u8 **itemstr,i64 *itemlength);
static void qq_print$strtoreal(u8 *s,i64 length,struct qq_decls$varrec *dest);
static void qq_print$strtoint(u8 *s,i64 length,struct qq_decls$varrec *dest,i64 dodec);
static void qq_print$printnextfmtchars(i64 lastx);
static void qq_print$pch_setformat(struct qq_decls$varrec *p);
struct qq_print$fmtrec *qq_print$pc_getfmt(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt);
void qq_print$pc_strtofmt(u8 *s,i64 slen,struct qq_print$fmtrec *fmt);
static void qq_print$initfmtcode(struct qq_print$fmtrec *f);
static i64 qq_print$i64mintostr(u8 *s,i64 base,i64 sep);
static i64 qq_print$u64tostr(u64 aa,u8 *s,u64 base,i64 sep);
static i64 qq_print$i64tostrfmt(i64 aa,u8 *s,struct qq_print$fmtrec *fmt,i64 usigned);
static i64 qq_print$u64tostrfmt(i64 aa,u8 *s,struct qq_print$fmtrec *fmt);
static i64 qq_print$strtostrfmt(u8 *s,u8 *t,i64 n,struct qq_print$fmtrec *fmt);
static i64 qq_print$expandstr(u8 *s,u8 *t,i64 n,struct qq_print$fmtrec *fmt);
void qq_print$addstring(struct qq_decls$objrec *p,u8 *t,i64 n);
static void qq_print$domultichar(u8 *p,i64 n,u8 *dest,struct qq_print$fmtrec *fmt);
static void qq_print$printstr_n(u8 *s,i64 n);
void qq_print$pch_strtoval(struct qq_decls$varrec *p,struct qq_decls$varrec *fmt,struct qq_decls$varrec *dest);
static void qq_print$tostr_int(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_word(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_real(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_str(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$pch_tostr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result);
static void qq_print$tostr_list(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_iterator(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_range(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_array(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_bits(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_struct(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_set(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_dict(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_decimal(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
static void qq_print$tostr_record(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest);
void qq_print$start(void);
void qq_pclgen$evalunit(struct qq_decls$unitrec *p,i64 res);
void qq_pclgen$gencodemodule(i64 n);
static void qq_pclgen$do_procdef(struct qq_decls$strec *p);
static void qq_pclgen$genprocentry(struct qq_decls$strec *p,i64 *nfreevars,i64 *nnofreevars);
static void qq_pclgen$genprocexit(i64 nfree,i64 nnofree,i64 isfunc);
static void qq_pclgen$evalref(struct qq_decls$unitrec *p);
static void qq_pclgen$genjumpcond(i64 opc,struct qq_decls$unitrec *p,i64 lab);
static void qq_pclgen$gcomparejump(i64 jumpopc,i64 cond,i64 lab);
static void qq_pclgen$genjumpl(i64 lab);
static i64 qq_pclgen$reversecond(i64 op);
void qq_pclgen$stacklooplabels(i64 *a,i64 *b,i64 *c);
void qq_pclgen$unstacklooplabels(void);
i64 qq_pclgen$findlooplabel(i64 k,i64 n);
static void qq_pclgen$do_assign(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 res,i64 deepcopy);
static void qq_pclgen$do_bin(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 opc);
static void qq_pclgen$do_binref(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 opc);
static void qq_pclgen$do_unary(struct qq_decls$unitrec *a,i64 opc);
static void qq_pclgen$do_unaryref(struct qq_decls$unitrec *a,i64 opc);
static void qq_pclgen$do_pushlist(struct qq_decls$unitrec *a,i64 n);
static void qq_pclgen$do_makedict(struct qq_decls$unitrec *a,i64 n);
static void qq_pclgen$do_call(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 res,i64 *procflag);
static i64 qq_pclgen$pushparams(struct qq_decls$strec *d,struct qq_decls$unitrec *(*arglist)[],i64 nargs,i64 kwdindex);
static void qq_pclgen$evalparam(struct qq_decls$unitrec *a,i64 byref);
static void qq_pclgen$pushkwdparams(struct qq_decls$strec *d,struct qq_decls$unitrec *(*arglist)[],i64 nargs,i64 kwdindex);
static void qq_pclgen$do_if(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,struct qq_decls$unitrec *pelse,i64 res);
static void qq_pclgen$do_do(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a);
static void qq_pclgen$do_exit(struct qq_decls$unitrec *p,i64 k);
static void qq_pclgen$do_to(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pcount,struct qq_decls$unitrec *pbody);
static void qq_pclgen$do_while(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pcond,struct qq_decls$unitrec *pbody);
static void qq_pclgen$do_repeat(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b);
static void qq_pclgen$do_for(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pvar,struct qq_decls$unitrec *pbody);
static void qq_pclgen$do_forx(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pvar,struct qq_decls$unitrec *pbody);
static void qq_pclgen$do_print(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b);
static void qq_pclgen$do_fprint(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,struct qq_decls$unitrec *c);
static void qq_pclgen$do_read(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b);
static void qq_pclgen$do_forall(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pbody);
static void qq_pclgen$do_case(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,i64 res);
static void qq_pclgen$do_case_nc(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,i64 res);
static void qq_pclgen$do_try(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b);
static i64 qq_pclgen$unitstoarray(struct qq_decls$unitrec *p,struct qq_decls$unitrec *(*plist)[],i64 maxunits);
static void qq_pclgen$do_select(struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pplist,i64 res);
static void qq_pclgen$do_andl(struct qq_decls$unitrec *x,struct qq_decls$unitrec *y);
static void qq_pclgen$do_orl(struct qq_decls$unitrec *x,struct qq_decls$unitrec *y);
static void qq_pclgen$do_incr(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,i64 res);
static void qq_pclgen$do_new(struct qq_decls$unitrec *p);
static i64 qq_pclgen$checkblockreturn(struct qq_decls$unitrec *p);
static void qq_pclgen$do_callhost(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,i64 res);
static void qq_pclgen$callhostfn(i64 fnindex,i64 calledasfn);
static void qq_pclgen$genfree(i64 n);
static void qq_pclgen$do_return(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a);
static void qq_pclgen$do_multassign(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 deepcopy,i64 res);
static void qq_pclgen$do_store(struct qq_decls$unitrec *a,i64 res);
static i64 qq_pclgen$getconstvalue(struct qq_decls$unitrec *p);
static void qq_pclgen$do_convert(struct qq_decls$unitrec *pconv);
static void qq_pclgen$checkelems(i64 n,i64 length,struct qq_decls$unitrec *p);
static void qq_pclgen$do_switch(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,i64 res);
static void qq_pclgen$do_simpleswitch(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,struct qq_decls$unitrec *pelse,i64 a,i64 b,i64 res);
static void qq_pclgen$do_makerecordkv(i64 m,i64 nkeyvals,struct qq_decls$unitrec *(*kvlist)[]);
static void qq_pclgen$do_idiv(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b);
static void qq_pclgen$do_irem(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b);
static void qq_pclgen$do_map(struct qq_decls$unitrec *p,struct qq_decls$unitrec *popcode,struct qq_decls$unitrec *x);
static void qq_pclgen$pushstring(u8 *s,i64 length);
void qq_pclgen$start(void);
void qq_pcllib$start(void);
void qq_pcllib$resetpcl(i64 sourcesize);
void qq_pcllib$genpc(i64 opc);
void qq_pcllib$genopnd_int(i64 x);
void qq_pcllib$genopnd_name(struct qq_decls$strec *d);
void qq_pcllib$genpc_int(i64 opc,i64 a);
void qq_pcllib$genpc_int2(i64 opc,i64 a,i64 b);
void qq_pcllib$genpc_int4(i64 opc,i64 a,i64 b,i64 c,i64 d);
void qq_pcllib$genpc_name(i64 opc,struct qq_decls$strec *d);
void qq_pcllib$genopnd_strz(u8 *s);
void qq_pcllib$genopnd_str(struct qq_decls$objrec *s);
void qq_pcllib$genopnd_obj(struct qq_decls$objrec *p);
void qq_pcllib$genpc_real(i64 opc,r64 x);
void qq_pcllib$genpc_lab(i64 opc,i64 a);
void qq_pcllib$genopnd_lab(i64 a);
void qq_pcllib$gencomment(u8 *s);
u8 *qq_pcllib$getdottedname(struct qq_decls$strec *p);
static void qq_pcllib$extendpcldata(void);
void qq_pcllib$extendlabeltable(void);
void qq_pcllib$pushint(i64 a);
void qq_pcllib$pushreal(r64 x);
i64 qq_pcllib$definelabel(void);
i64 qq_pcllib$createfwdlabel(void);
void qq_pcllib$definefwdlabel(i64 *lab);
i64 qq_pcllib$isstatic(struct qq_decls$strec *d);
void qq_records$var_make_record(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n,i64 rectype);
struct qq_decls$objrec *qq_records$obj_new_record(i64 m,struct qq_decls$varrec *defval);
void qq_records$obj_free_record(struct qq_decls$objrec *p);
void qq_records$var_dupl_record(struct qq_decls$varrec *a);
i64 qq_records$var_equal_record(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_records$var_getix_record(struct qq_decls$varrec *a,i64 index);
void qq_records$var_putix_record(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_records$var_getixref_record(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *dest);
void qq_records$start(void);
void qq_resolve$rx_module(i64 n);
void qq_resolve$rx_passdef(struct qq_decls$strec *owner,struct qq_decls$strec *p);
void qq_resolve$rx_deflist(struct qq_decls$strec *owner,struct qq_decls$strec *p);
void qq_resolve$rx_unit(struct qq_decls$strec *owner,struct qq_decls$unitrec *p);
static void qq_resolve$rx_unitlist(struct qq_decls$strec *owner,struct qq_decls$unitrec *p);
static void qq_resolve$evalmonop(struct qq_decls$unitrec *p);
static void qq_resolve$evalbinop(struct qq_decls$unitrec *p,struct qq_decls$unitrec *lhs,struct qq_decls$unitrec *rhs);
static void qq_resolve$makeintconst(struct qq_decls$unitrec *p,i64 value);
static void qq_resolve$makerealconst(struct qq_decls$unitrec *p,r64 xvalue);
void qq_resolve$resolvename(struct qq_decls$strec *owner,struct qq_decls$unitrec *p,i64 mode);
struct qq_decls$strec *qq_resolve$resolvetopname(struct qq_decls$strec *owner,struct qq_decls$strec *stnewname,i64 moduleno,i64 allowmod);
static void qq_resolve$resolvedot(struct qq_decls$strec *owner,struct qq_decls$unitrec *p);
static void qq_resolve$resolvedot_sym(struct qq_decls$strec *owner,struct qq_decls$unitrec *p);
struct qq_decls$strec *qq_resolve$finddupl(struct qq_decls$strec *d,struct qq_decls$strec *pdupl);
static void qq_resolve$expandmacro(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b);
static struct qq_decls$unitrec *qq_resolve$copylistunit(struct qq_decls$unitrec *p);
static struct qq_decls$unitrec *qq_resolve$copyunit(struct qq_decls$unitrec *p);
static void qq_resolve$replaceunit(struct qq_decls$unitrec *p,struct qq_decls$unitrec *q);
static void qq_resolve$fixmode(struct qq_decls$strec *owner,struct qq_decls$strec *p);
static i64 qq_resolve$fixmode2(struct qq_decls$strec *owner,i64 m);
void qq_resolve$fixusertypes(void);
void qq_resolve$tx_typetable(void);
static i64 qq_resolve$getconstint(struct qq_decls$strec *owner,struct qq_decls$unitrec *a,i64 ownerid);
void qq_resolve$converttype(i64 m);
static void qq_resolve$scanstruct(i64 smode,struct qq_decls$strec *(*fields)[],i64 *index,i64 *isize,i64 offset,i64 calign,i64 *maxalign,i64 countmode);
static void qq_resolve$dobaseclass(i64 baseclassindex);
void qq_resolve$start(void);
void qq_sets$obj_free_set(struct qq_decls$objrec *p);
void qq_sets$var_dupl_set(struct qq_decls$varrec *a);
i64 qq_sets$var_equal_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
static i64 qq_sets$getsetbytes(struct qq_decls$varrec *x);
void qq_sets$var_make_set(struct qq_decls$varrec *data,struct qq_decls$varrec *dest,i64 n);
struct qq_decls$objrec *qq_sets$obj_newset(i64 length);
void qq_sets$var_emptyset(struct qq_decls$varrec *dest);
void qq_sets$var_getix_set(struct qq_decls$varrec *a,i64 index);
void qq_sets$var_putix_set(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_sets$var_getixref_set(struct qq_decls$varrec *a,i64 index);
static byte *qq_sets$getoffset(byte *p,i64 index,i64 *newoffset);
i64 qq_sets$var_in_set(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_sets$iresizeset(struct qq_decls$varrec *p,i64 n);
void qq_sets$obj_resize_set(struct qq_decls$objrec *p,i64 n);
void qq_sets$iorsetbits(i64 *p,i64 *q,i64 n);
void qq_sets$ixorsetbits(i64 *p,i64 *q,i64 n);
void qq_sets$iandsetbits(u64 *p,u64 *q,i64 n);
void qq_sets$inotsetbits(u64 *p,i64 n);
void qq_sets$var_iorto_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_sets$var_iandto_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_sets$var_ixorto_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_sets$var_inotto_set(struct qq_decls$varrec *x);
void qq_sets$var_checkiter_set(struct qq_decls$varrec *a,struct qq_decls$varrec *dest);
void qq_sets$var_nextiter_set(struct qq_decls$varrec *a,struct qq_decls$varrec *dest);
void qq_sets$start(void);
void qq_strings$start(void);
void qq_strings$var_empty_string(struct qq_decls$varrec *dest,i64 mutable);
void qq_strings$var_make_string(u8 *s,struct qq_decls$varrec *dest,i64 mutable);
void qq_strings$var_make_stringn(u8 *s,i64 length,struct qq_decls$varrec *dest,i64 mutable);
struct qq_decls$objrec *qq_strings$obj_new_string(i64 n);
struct qq_decls$objrec *qq_strings$obj_make_string(u8 *s,i64 mutable);
struct qq_decls$objrec *qq_strings$obj_make_stringn(u8 *s,i64 length,i64 mutable);
void qq_strings$obj_free_string(struct qq_decls$objrec *p);
void qq_strings$var_dupl_string(struct qq_decls$varrec *a);
void qq_strings$var_getix_string(struct qq_decls$varrec *a,i64 index);
void qq_strings$var_getixref_string(struct qq_decls$varrec *a,i64 index);
void qq_strings$var_getdotix_string(struct qq_decls$varrec *a,i64 index);
void qq_strings$var_getdotixref_string(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *dest);
void qq_strings$var_getslice_string(struct qq_decls$varrec *a,i64 i,i64 j);
static void qq_strings$stringslice(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *dest);
void qq_strings$var_putix_string(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_strings$var_putslice_string(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x);
void qq_strings$var_putdotix_string(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_strings$obj_resize_string(struct qq_decls$objrec *p,i64 n);
void qq_strings$var_add_string(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_strings$var_addto_string(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_strings$var_addto_string_ch(struct qq_decls$varrec *a,i64 ch);
i64 qq_strings$var_equal_string(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
i64 qq_strings$var_compare_string(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
static i64 qq_strings$cmpstring_len(u8 *s,u8 *t,i64 slen,i64 tlen);
i64 qq_strings$var_inx_string(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_strings$var_iconvcase(struct qq_decls$varrec *a,struct qq_decls$varrec *b,i64 upper);
void qq_strings$var_makestrslicexobj(u8 *s,i64 length,struct qq_decls$varrec *dest);
struct qq_decls$objrec *qq_strings$obj_make_strslicexobj(u8 *s,i64 length);
static i64 qq_strings$var_asc(struct qq_decls$varrec *a);
void qq_strings$var_new_string(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *dest);
void qq_strings$var_new_stringn(i64 length,struct qq_decls$varrec *dest);
void qq_strings$var_mul_string(struct qq_decls$varrec *a,i64 m);
void qq_strings$var_convert_string_list(struct qq_decls$varrec *a,i64 t,struct qq_decls$varrec *dest);
void qq_strings$var_expand_string(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 m);
void qq_strings$var_makechar(i64 ch,struct qq_decls$varrec *dest);
void qq_strings$var_nextiter_string(struct qq_decls$varrec *a,struct qq_decls$varrec *dest);
i64 qq_syslibs$findsyslib(u8 *filename);
void qq_syslibs$start(void);
void qq_tables$start(void);
void qq_dummyshow$printunit(struct qq_decls$unitrec *p,i64 level,u8 *prefix,void *dev);
void qq_dummyshow$writeallpcl(i64 n,i64 pass);
void qq_dummyshow$printglobalsymbols(void *f);
void qq_dummyshow$printst(void *f,struct qq_decls$strec *p,i64 level);
void qq_dummyshow$printglobalsymbols_full(void *f);
void qq_dummyshow$printstfull(void *f,struct qq_decls$strec *p,i64 level);
void qq_dummyshow$printtypetables(void *f);
u8 *qq_dummyshow$getpclname(void);
void qq_dummyshow$showlogfile(void);
void qq_dummyshow$showast(u8 *file);
void qq_dummyshow$showpcl(i64 pass);
void qq_dummyshow$showmpl(i64 pass);
void qq_dummyshow$printsymbol(struct qq_decls$lexrec *lp);
u8 *qq_dummyshow$strmode(i64 t,i64 expand);
void qq_dummyshow$start(void);
void qq_vars$var_unshareu(struct qq_decls$varrec *p);
void qq_vars$obj_shareu(struct qq_decls$objrec *p);
struct qq_decls$varrec *qq_vars$void_new(void);
struct qq_decls$objrec *qq_vars$obj_new(void);
i64 qq_vars$var_getintvalue(struct qq_decls$varrec *p);
void qq_vars$var_fromobj(i64 tag,struct qq_decls$objrec *p,struct qq_decls$varrec *dest);
void qq_vars$var_free(struct qq_decls$varrec *a);
void qq_vars$var_duplu(struct qq_decls$varrec *a);
void qq_vars$var_neg(struct qq_decls$varrec *a);
void qq_vars$var_abs(struct qq_decls$varrec *a);
void qq_vars$var_inot(struct qq_decls$varrec *a);
i64 qq_vars$var_istruel(struct qq_decls$varrec *a);
i64 qq_vars$var_negto(struct qq_decls$varrec *p);
i64 qq_vars$var_absto(struct qq_decls$varrec *p);
i64 qq_vars$var_inotto(struct qq_decls$varrec *p);
void qq_vars$var_add(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_addmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_sub(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_submixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_mul(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_mulmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_div(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_divmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_idiv(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_idivmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_irem(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_iremmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_iand(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_iandmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_ior(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_iormixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_ixor(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_ixormixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_shl(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_shlmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_shr(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_shrmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_in(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_inx(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_equal(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_equalmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_compare(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_comparemixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_concat(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_append(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_min(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_minmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_max(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_maxmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_addto(struct qq_decls$varrec *p,struct qq_decls$varrec *b);
i64 qq_vars$var_multo(struct qq_decls$varrec *p,struct qq_decls$varrec *b);
i64 qq_vars$var_iandto(struct qq_decls$varrec *p,struct qq_decls$varrec *b);
i64 qq_vars$var_iorto(struct qq_decls$varrec *p,struct qq_decls$varrec *b);
i64 qq_vars$var_ixorto(struct qq_decls$varrec *p,struct qq_decls$varrec *b);
i64 qq_vars$var_shlto(struct qq_decls$varrec *p,struct qq_decls$varrec *b);
i64 qq_vars$var_shrto(struct qq_decls$varrec *p,struct qq_decls$varrec *b);
i64 qq_vars$var_concatto(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
i64 qq_vars$var_appendto(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_getix(struct qq_decls$varrec *a,i64 index);
void qq_vars$var_putix(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x);
void qq_vars$var_getixref(struct qq_decls$varrec *a,i64 index);
void qq_vars$var_getslice(struct qq_decls$varrec *a,i64 i,i64 j);
void qq_vars$var_putslice(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x);
void qq_vars$var_getdotix(struct qq_decls$varrec *a,i64 index);
void qq_vars$var_putdotix(struct qq_decls$varrec *p,i64 index,struct qq_decls$varrec *x);
void qq_vars$var_getdotixref(struct qq_decls$varrec *p,i64 index);
void qq_vars$var_getdotslice(struct qq_decls$varrec *a,i64 i,i64 j);
void qq_vars$var_putdotslice(struct qq_decls$varrec *p,i64 i,i64 j,struct qq_decls$varrec *x);
void qq_vars$var_getdotsliceref(struct qq_decls$varrec *p,i64 i,i64 j);
void qq_vars$var_expand(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 m);
i64 qq_vars$var_minto(struct qq_decls$varrec *p,struct qq_decls$varrec *b);
i64 qq_vars$var_maxto(struct qq_decls$varrec *p,struct qq_decls$varrec *b);
void qq_vars$var_inplace(struct qq_decls$varrec *px,struct qq_decls$varrec *y,void (*fnadd)(struct qq_decls$varrec *,struct qq_decls$varrec *),void (*fnaddmixed)(struct qq_decls$varrec *,struct qq_decls$varrec *));
void qq_vars$var_inplace_unary(struct qq_decls$varrec *px,void (*fnneg)(struct qq_decls$varrec *));
void qq_vars$var_loadptr(struct qq_decls$varrec *x,struct qq_decls$varrec *y);
void qq_vars$var_storeptr(struct qq_decls$varrec *p,struct qq_decls$varrec *q);
void qq_vars$var_loadbit(byte *p,i64 shift,i64 t,i64 bitlength,struct qq_decls$varrec *dest);
void qq_vars$var_storebit(byte *p,i64 shift,struct qq_decls$varrec *q,i64 t,i64 bitlength);
void qq_vars$var_convert(struct qq_decls$varrec *x,i64 t,struct qq_decls$varrec *dest);
i64 qq_vars$var_gethashvalue(struct qq_decls$varrec *p);
void qq_vars$var_objtovar(i64 tag,struct qq_decls$objrec *p,struct qq_decls$varrec *q);
void qq_vars$var_putdotix_intint(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *b);
void qq_vars$var_power(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$var_powermixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b);
void qq_vars$start(void);
void msysc$m_init(i64 nargs,u8 *(*args)[],u8 *(*envstrings)[]);
i64 msysc$m_getdotindex(u64 a,i64 i);
u64 msysc$m_setdotindex(u64 a,i64 i,i64 x);
i64 msysc$m_getdotslice(u64 a,i64 i,i64 j);
u64 msysc$m_setdotslice(u64 a,i64 i,i64 j,u64 x);
i64 msysc$m_get_nprocs(void);
i64 msysc$m_get_nexports(void);
u8 *msysc$m_get_procname(i64 n);
void *msysc$m_get_procaddr(i64 n);
void *msysc$m_get_procexport(i64 n);
static void msysc$pushio(void);
void msysc$m_print_startfile(void *dev);
void msysc$m_print_startstr(u8 *s);
void msysc$m_print_startptr(u8 **p);
void msysc$m_print_startcon(void);
void msysc$m_print_setfmt(u8 *format);
void msysc$m_print_end(void);
void msysc$m_print_ptr(void *a,u8 *fmtstyle);
void msysc$m_print_i64(i64 a,u8 *fmtstyle);
void msysc$m_print_u64(u64 a,u8 *fmtstyle);
void msysc$m_print_r64(r64 x,u8 *fmtstyle);
void msysc$m_print_r32(r32 x,u8 *fmtstyle);
void msysc$m_print_c8(i64 a,u8 *fmtstyle);
void msysc$m_print_str(u8 *s,u8 *fmtstyle);
void msysc$m_print_newline(void);
void msysc$m_print_nogap(void);
void msysc$m_print_space(void);
void msysc$printstr(u8 *s);
void msysc$printstr_n(u8 *s,i64 n);
void msysc$printstrn_app(u8 *s,i64 length,void *f);
static u8 *msysc$makezstring(u8 *s,i64 n,u8 *local);
static void msysc$freezstring(u8 *t,i64 n);
static void msysc$printchar(i64 ch);
void msysc$nextfmtchars(i64 lastx);
void msysc$strtofmt(u8 *s,i64 slen,struct msysc$fmtrec *fmt);
static i64 msysc$domultichar(u8 *p,i64 n,u8 *dest,struct msysc$fmtrec *fmt);
static i64 msysc$expandstr(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt);
static i64 msysc$u64tostr(u64 aa,u8 *s,u64 base,i64 sep);
static i64 msysc$i64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt);
static i64 msysc$u64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt);
static i64 msysc$i64mintostr(u8 *s,i64 base,i64 sep);
static i64 msysc$strtostrfmt(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt);
static void msysc$tostr_i64(i64 a,struct msysc$fmtrec *fmt);
static void msysc$tostr_u64(u64 a,struct msysc$fmtrec *fmt);
static void msysc$tostr_r64(r64 x,struct msysc$fmtrec *fmt);
static void msysc$tostr_str(u8 *s,struct msysc$fmtrec *fmt);
static struct msysc$fmtrec *msysc$getfmt(u8 *fmtstyle);
u8 *msysc$strint(i64 a,u8 *fmtstyle);
void msysc$getstrint(i64 a,u8 *dest);
u8 *msysc$strword(u64 a,u8 *fmtstyle);
u8 *msysc$strreal(r64 a,u8 *fmtstyle);
static u8 *msysc$getstr(u8 *s,struct msysc$fmtrec *fmt);
static void msysc$initreadbuffer(void);
void msysc$m_read_conline(void);
void msysc$m_read_fileline(void *f);
void msysc$m_read_strline(u8 *s);
static u8 *msysc$readitem(i64 *itemlength);
i64 msysc$strtoint(u8 *s,i64 length,i64 base);
i64 msysc$m_read_i64(i64 fmt);
r64 msysc$m_read_r64(i64 fmt);
void msysc$m_read_str(u8 *dest,i64 destlen,i64 fmt);
void msysc$readstr(u8 *dest,i64 fmt,i64 destlen);
void msysc$rereadln(void);
void msysc$reread(void);
i64 msysc$valint(u8 *s,i64 fmt);
r64 msysc$valreal(u8 *s);
static void msysc$iconvlcn(u8 *s,i64 n);
static void msysc$iconvucn(u8 *s,i64 n);
static void msysc$convlcstring(u8 *s);
static void msysc$convucstring(u8 *s);
i64 msysc$m_power_i64(i64 n,i64 a);
void msysc$m_intoverflow(void);
void msysc$m_dotindex(u64 i,u64 a);
void msysc$m_dotslice(u64 j,u64 i,u64 a);
void msysc$m_popdotindex(u64 i,u64 *p,u64 x);
void msysc$m_popdotslice(u64 j,u64 i,u64 *p,u64 x);
i64 msysc$m_imin(i64 a,i64 b);
i64 msysc$m_imax(i64 a,i64 b);
r64 msysc$m_sign(r64 x);
r64 msysc$m_tp_i64tor64(i64 a);
i64 msysc$m_tp_r64toi64(r64 x);
i64 msysc$m_tp_reftoi64(void *p);
void *msysc$m_tp_i64toref(i64 a);
void msysc$start(void);
void *mlib$pcm_alloc(i64 n);
void mlib$pcm_free(void *p,i64 n);
void mlib$pcm_freeac(void *p,i64 alloc);
void mlib$pcm_clearmem(void *p,i64 n);
void mlib$pcm_init(void);
i64 mlib$pcm_getac(i64 size);
void *mlib$pcm_newblock(i64 itemsize);
i64 mlib$pcm_round(i64 n);
void *mlib$pcm_allocz(i64 n);
u8 *mlib$pcm_copyheapstring(u8 *s);
u8 *mlib$pcm_copyheapstringn(u8 *s,i64 n);
u8 *mlib$pcm_copyheapblock(u8 *s,i64 length);
void *mlib$allocmem(i64 n);
void *mlib$reallocmem(void *p,i64 n);
void mlib$abortprogram(u8 *s);
i64 mlib$getfilesize(void *handlex);
void mlib$readrandom(void *handlex,byte *mem,i64 offset,i64 size);
i64 mlib$writerandom(void *handlex,byte *mem,i64 offset,i64 size);
i64 mlib$setfilepos(void *file,i64 offset);
i64 mlib$getfilepos(void *file);
byte *mlib$readfile(u8 *filename);
i64 mlib$writefile(u8 *filename,byte *data,i64 size);
i64 mlib$checkfile(u8 *file);
void mlib$readlinen(void *handlex,u8 *buffer,i64 size);
void mlib$iconvlcn(u8 *s,i64 n);
void mlib$iconvucn(u8 *s,i64 n);
u8 *mlib$convlcstring(u8 *s);
u8 *mlib$convucstring(u8 *s);
u8 *mlib$changeext(u8 *s,u8 *newext);
u8 *mlib$extractext(u8 *s,i64 period);
u8 *mlib$extractpath(u8 *s);
u8 *mlib$extractfile(u8 *s);
u8 *mlib$extractbasefile(u8 *s);
u8 *mlib$addext(u8 *s,u8 *newext);
void *mlib$pcm_alloc32(void);
void mlib$pcm_free32(void *p);
void mlib$outbyte(void *f,i64 x);
void mlib$outword16(void *f,u64 x);
void mlib$outword32(void *f,u64 x);
void mlib$outword64(void *f,u64 x);
void mlib$outstring(void *f,u8 *s);
void mlib$outblock(void *f,void *p,i64 n);
i64 mlib$myeof(void *f);
void mlib$strbuffer_add(struct mlib$strbuffer *dest,u8 *s,i64 n);
void mlib$gs_init(struct mlib$strbuffer *dest);
void mlib$gs_free(struct mlib$strbuffer *dest);
void mlib$gs_str(struct mlib$strbuffer *dest,u8 *s);
void mlib$gs_char(struct mlib$strbuffer *dest,i64 c);
void mlib$gs_strn(struct mlib$strbuffer *dest,u8 *s,i64 length);
void mlib$gs_strvar(struct mlib$strbuffer *dest,struct mlib$strbuffer *s);
void mlib$gs_strint(struct mlib$strbuffer *dest,i64 a);
void mlib$gs_strln(struct mlib$strbuffer *dest,u8 *s);
void mlib$gs_strsp(struct mlib$strbuffer *dest,u8 *s);
void mlib$gs_line(struct mlib$strbuffer *dest);
i64 mlib$gs_getcol(struct mlib$strbuffer *dest);
void mlib$gs_leftstr(struct mlib$strbuffer *dest,u8 *s,i64 w,i64 padch);
void mlib$gs_leftint(struct mlib$strbuffer *dest,i64 a,i64 w,i64 padch);
void mlib$gs_padto(struct mlib$strbuffer *dest,i64 col,i64 ch);
void mlib$gs_println(struct mlib$strbuffer *dest,void *f);
i64 mlib$nextcmdparamnew(i64 *paramno,u8 **name,u8 **value,u8 *defext);
static i64 mlib$readnextfileitem(u8 **fileptr,u8 **item);
void mlib$ipadstr(u8 *s,i64 width,u8 *padchar);
u8 *mlib$padstr(u8 *s,i64 width,u8 *padchar);
u8 *mlib$chr(i64 c);
i64 mlib$cmpstring(u8 *s,u8 *t);
i64 mlib$cmpstringn(u8 *s,u8 *t,i64 n);
i64 mlib$eqstring(u8 *s,u8 *t);
i64 mlib$cmpbytes(void *p,void *q,i64 n);
i64 mlib$eqbytes(void *p,void *q,i64 n);
void mlib$mseed(u64 a,u64 b);
u64 mlib$mrandom(void);
i64 mlib$mrandomp(void);
i64 mlib$mrandomint(i64 n);
i64 mlib$mrandomrange(i64 a,i64 b);
r64 mlib$mrandomreal(void);
r64 mlib$mrandomreal1(void);
u8 *mlib$readline(void);
void *mlib$findfunction(u8 *name);
i64 mlib$roundtoblock(i64 n,i64 align);
void mlib$start(void);
extern void *malloc(u64 $1);
extern void *realloc(void *$1,u64 $2);
extern void free(void *$1);
extern void memset(void *$1,i32 $2,u64 $3);
extern void memcpy(void *$1,void *$2,u64 $3);
extern void memmove(void *$1,void *$2,u64 $3);
extern i32 clock(void);
extern i32 ftell(void *$1);
extern i32 fseek(void *$1,i32 $2,i32 $3);
extern u64 fread(void *$1,u64 $2,u64 $3,void *$4);
extern u64 fwrite(void *$1,u64 $2,u64 $3,void *$4);
extern i32 getc(void *$1);
extern i32 ungetc(i32 $1,void *$2);
extern void *fopen(u8 *a,u8 *b);
extern i32 fclose(void *$1);
extern u8 *fgets(u8 *$1,i64 $2,void *$3);
extern i32 remove(u8 *$1);
extern i32 rename(u8 *$1,u8 *$2);
extern i32 getchar(void);
extern void putchar(i32 $1);
extern void setbuf(void *$1,byte *$2);
extern i64 strlen(u8 *$1);
extern u8 *strcpy(u8 *$1,u8 *$2);
extern i32 strcmp(u8 *$1,u8 *$2);
extern i32 strncmp(u8 *$1,u8 *$2,u64 $3);
extern u64 strncpy(u8 *$1,u8 *$2,u64 $3);
extern i32 memcmp(void *$1,void *$2,u64 $3);
extern u8 *strcat(u8 *$1,u8 *$2);
extern i32 tolower(i32 $1);
extern i32 toupper(i32 $1);
extern i32 isalpha(i32 $1);
extern i32 isupper(i32 $1);
extern i32 islower(i32 $1);
extern i32 isalnum(i32 $1);
extern i32 isspace(i32 $1);
extern u8 *strstr(u8 *$1,u8 *$2);
extern i64 atol(u8 *$1);
extern i32 atoi(u8 *$1);
extern r64 strtod(u8 *$1,u8 **$2);
extern u8 *_strdup(u8 *$1);
extern i32 puts(u8 *$1);
extern i32 printf(u8 *$1,...);
extern i32 sprintf(u8 *$1,u8 *$2,...);
extern i32 sscanf(u8 *$1,u8 *$2,...);
extern i32 scanf(u8 *$1,...);
extern i32 rand(void);
extern void srand(u32 $1);
extern i32 system(u8 *$1);
extern i32 fgetc(void *$1);
extern i32 fputc(i32 $1,void *$2);
extern i32 fprintf(void *$1,u8 *$2,...);
extern i32 fputs(u8 *$1,void *$2);
extern i32 feof(void *$1);
extern i32 getch(void);
extern i32 _getch(void);
extern i32 kbhit(void);
extern i32 _mkdir(u8 *$1);
extern i32 mkdir(u8 *$1);
extern u8 *strchr(u8 *$1,i32 $2);
extern i32 _setmode(i32 $1,i32 $2);
extern void _exit(i32 $1);
extern void exit(i32 $1);
extern r64 pow(r64 $1,r64 $2);
extern r64 sin(r64 $1);
extern r64 cos(r64 $1);
extern r64 tan(r64 $1);
extern r64 asin(r64 $1);
extern r64 acos(r64 $1);
extern r64 atan(r64 $1);
extern r64 log(r64 $1);
extern r64 log10(r64 $1);
extern r64 exp(r64 $1);
extern r64 floor(r64 $1);
extern r64 ceil(r64 $1);
extern i64 llabs(i64 $1);
extern void qsort(void *$1,u64 $2,u64 $3,void (*$4)(void));
extern i32 __getmainargs(i32 *$1,void *$2,void *$3,i64 $4,void *$5);
void mclib$start(void);
extern void *GetStdHandle(u32 $1);
extern i64 GetConsoleScreenBufferInfo(void *$1,void *$2);
extern i64 SetConsoleCtrlHandler(void (*$1)(void),i64 $2);
extern i64 SetConsoleMode(void *$1,u32 $2);
extern i64 CreateProcessA(u8 *$1,u8 *$2,void *$3,void *$4,i64 $5,u32 $6,void *$7,u8 *$8,void *$9,void *$10);
extern u32 GetLastError(void);
extern u32 WaitForSingleObject(void *$1,u32 $2);
extern i64 GetExitCodeProcess(void *$1,void *$2);
extern i64 CloseHandle(void *$1);
extern i64 GetNumberOfConsoleInputEvents(void *$1,void *$2);
extern i64 FlushConsoleInputBuffer(void *$1);
extern void *LoadLibraryA(u8 *$1);
extern void *GetProcAddress(void *$1,u8 *$2);
extern void *LoadCursorA(void *$1,u8 *$2);
extern u32 RegisterClassExA(void *$1);
extern i64 DefWindowProcA(void *$1,u32 $2,u64 $3,u64 $4);
extern i64 ReadConsoleInputA(void *$1,void *$2,u32 $3,void *$4);
extern void Sleep(u32 $1);
extern u32 GetModuleFileNameA(void *$1,u8 *$2,u32 $3);
extern void ExitProcess(u32 $1);
extern void PostQuitMessage(i32 $1);
extern void MessageBoxA(i32 x,u8 *message,u8 *caption,i32 y);
extern u32 QueryPerformanceCounter(i64 *$1);
extern u32 QueryPerformanceFrequency(i64 *$1);
extern void *CreateFileA(u8 *$1,u32 $2,u32 $3,void *$4,u32 $5,u32 $6,void *$7);
extern u32 GetFileTime(void *$1,void *$2,void *$3,void *$4);
extern void GetSystemTime(struct mwindows$rsystemtime *$1);
extern void GetLocalTime(struct mwindows$rsystemtime *$1);
extern u64 GetTickCount64(void);
extern u32 PeekMessageA(void *$1,void **$2,u32 $3,u32 $4,u32 $5);
extern u8 *GetCommandLineA(void);
extern void *VirtualAlloc(void *$1,u32 $2,u32 $3,u32 $4);
extern u32 VirtualProtect(void *$1,u32 $2,u32 $3,u32 *$4);
void mwindows$os_init(void);
i64 mwindows$os_execwait(u8 *cmdline,i64 newconsole,u8 *workdir);
i64 mwindows$os_execcmd(u8 *cmdline,i64 newconsole);
i64 mwindows$os_getch(void);
i64 mwindows$os_kbhit(void);
u64 mwindows$os_getdllinst(u8 *name);
void *mwindows$os_getdllprocaddr(i64 hinst,u8 *name);
void mwindows$os_initwindows(void);
void mwindows$os_gxregisterclass(u8 *classname);
i64 mwindows$mainwndproc(void *hwnd,u32 message,u64 wparam,u64 lparam);
void mwindows$os_setmesshandler(void *addr);
i64 mwindows$os_getchx(void);
u8 *mwindows$os_getos(void);
i64 mwindows$os_gethostsize(void);
i64 mwindows$os_shellexec(u8 *opc,u8 *file);
void mwindows$os_sleep(i64 a);
void *mwindows$os_getstdin(void);
void *mwindows$os_getstdout(void);
u8 *mwindows$os_gethostname(void);
u8 *mwindows$os_getmpath(void);
i64 mwindows$os_clock(void);
i64 mwindows$os_ticks(void);
i64 mwindows$os_hptimer(void);
i64 mwindows$os_iswindows(void);
void mwindows$os_getsystime(struct mwindows$rsystemtime *tm);
void mwindows$os_peek(void);
byte *mwindows$os_allocexecmem(i64 n);
void mwindows$start(void);
u64 mwindllc$os_calldllfunction(void (*fnaddr)(void),i64 retcode,i64 nargs,i64 (*args)[],byte (*argcodes)[]);
u64 mwindllc$os_pushargs(u64 (*args)[],i64 nargs,i64 nextra,void (*fnaddr)(void),i64 isfloat);
static i64 mwindllc$calldll_cint(void (*fnaddr)(void),i64 (*params)[],i64 nparams);
static i64 mwindllc$calldll_creal(void (*fnaddr)(void),i64 (*params)[],i64 nparams);
void mwindllc$os_dummycall(r64 a,r64 b,r64 c,r64 d);
void mwindllc$start(void);

/* VARS */
static u8 *  qqcli$runnames[7] = {(byte*)"header_cc",(byte*)"load_cc",(byte*)"parse_cc",(byte*)"names_cc",(byte*)"gencode_cc",(byte*)"fixup_cc",(byte*)"run_cc"};
static byte qqcli$fshowpcl1;
static byte qqcli$fshowpcl2;
static byte qqcli$fshowpcl3;
static byte qqcli$fshowast1;
static byte qqcli$fshowast2;
static byte qqcli$fshowst;
static byte qqcli$fshowstflat;
static byte qqcli$fshowtypes;
static byte qqcli$foptimise = (byte)(i64)1;
static byte qqcli$fwriteqa;
static byte qqcli$fshowmodules;
static byte qqcli$fshowtime;
static byte qqcli$runcode = (byte)(i64)7;
static u8 *  qqcli$sourcestr;
static u8 *  qqcli$inputfile;
static struct qq_decls$varrec *  qqcli$statictable[11000];
static struct qq_decls$strec *  qqcli$staticdefs[11000];
static i64 qqcli$nstatics;
static i64 *  qqcli$proctable[11000];
static struct qq_decls$strec *  qqcli$procdefs[11000];
static i64 qqcli$nprocs;
static i64 qqcli$cliruncode = (i64)7;
static u8 *  qqcli$optionnames[34] = {
    (byte*)"header",
    (byte*)"load",
    (byte*)"parse",
    (byte*)"names",
    (byte*)"gen",
    (byte*)"opt",
    (byte*)"asmopt",
    (byte*)"fixup",
    (byte*)"run",
    (byte*)"ast1",
    (byte*)"ast2",
    (byte*)"pcl1",
    (byte*)"pcl2",
    (byte*)"pcl3",
    (byte*)"st",
    (byte*)"stflat",
    (byte*)"types",
    (byte*)"modules",
    (byte*)"show",
    (byte*)"fn",
    (byte*)"sw",
    (byte*)"asm",
    (byte*)"debug",
    (byte*)"fdebug",
    (byte*)"lab",
    (byte*)"ext",
    (byte*)"qa",
    (byte*)"qas",
    (byte*)"v",
    (byte*)"docs",
    (byte*)"alldocs",
    (byte*)"p",
    (byte*)"time",
    (byte*)"nosys"
};
static i64 qqcli$cmdstartindex;
static struct mlib$strbuffer *  qqcli$pclstr;
static u8 *  qq_decimal$fpnames[4] = {(byte*)"zero_type",(byte*)"normal_type",(byte*)"inf_type",(byte*)"nan_type"};
static i64 qq_decimal$currprec = (i64)55;
static i64 qq_decimal$stblz;
static struct qq_decimal$constrec *  qq_decimal$constlist = 0;
static i64 qq_decimal$decstrsize;
static struct qq_decls$varrec qq_decimal$vtemp;
static i64 qq_decls$dispatchtype = (i64)5;
static i64 qq_decls$hasbytecodes = (i64)1;
static struct qq_decls$lexrec qq_decls$nextlx;
static struct qq_decls$lexrec qq_decls$lx;
static u8 *  qq_decls$searchdirs[10];
static i64 qq_decls$nsearchdirs = (i64)0;
static u8 *  qq_decls$hostdirs[5];
static i64 qq_decls$nhostdirs;
static i64 qq_decls$qpos;
static i64 qq_decls$pcerrorpos;
static struct qq_decls$modulerec *  qq_decls$pcerrormodule;
static struct qq_decls$varrec qq_decls$varstack[70000];
static struct qq_decls$varrec *  qq_decls$sptr;
static struct qq_decls$varrec *  qq_decls$stacklimit;
static byte *  qq_decls$frameptr;
static i64 *  qq_decls$pcptr;
static i64 qq_decls$stopped;
static struct qq_decls$strec *  qq_decls$stprogram;
static struct qq_decls$strec *  qq_decls$stmodule;
static struct qq_decls$strec *  qq_decls$stsubprog;
static struct qq_decls$strec *  qq_decls$stcurrmodule;
static struct qq_decls$strec *  qq_decls$stcurrproc;
static struct qq_decls$modulerec *  qq_decls$currmodule;
static i64 qq_decls$debug;
static i64 qq_decls$count;
static struct qq_decls$unitrec *  qq_decls$lastast;
static void *  qq_decls$astdev;
static i64 qq_decls$inproc;
static i64 qq_decls$nallunits;
static i64 qq_decls$nprocunits;
static i64 qq_decls$nallpcl;
static i64 qq_decls$nallprocs;
static i64 qq_decls$nmaxprocunits;
static u8 qq_decls$errorline[256];
static u8 qq_decls$errorpointer[256];
static i64 qq_decls$errorlineno;
static struct qq_decls$modulerec *  qq_decls$errormodule;
static struct qq_decls$strec *  qq_decls$sterrorproc;
static struct qq_decls$genfieldrec *  qq_decls$genfieldtable[1000];
static i64 qq_decls$ngenfields;
static i64 qq_decls$nlibfiles;
static struct qq_decls$strec *  qq_decls$libtable[50];
static byte qq_decls$libtypes[50];
static u64 qq_decls$dllinsttable[50];
static i64 qq_decls$ndllprocs;
static struct qq_decls$strec *  qq_decls$dllproctable[2000];
static byte qq_decls$dllproclibindex[2000];
static void *  qq_decls$dllprocaddr[2000];
static i64 qq_decls$usesyslibs = (i64)1;
static u8 *  qq_decls$dispatchnames[5] = {(byte*)"-lab",(byte*)"-fn",(byte*)"-debug",(byte*)"-fdebug",(byte*)"-asm"};
static i64 qq_decls$nqparams;
static u8 *  qq_decls$qparamtable[32];
static u8 *  qq_decls$err_message;
static struct qq_decls$varrec qq_decls$err_var1;
static struct qq_decls$varrec qq_decls$err_var2;
static i64 *  qq_decls$err_pcptr;
static i64 *  qq_decls$stopseq;
static i64 *  qq_decls$raiseseq;
static struct qq_decls$procrec *  qq_decls$proclist;
static struct qq_decls$procrec *  qq_decls$proclistx;
static i64 qq_decls$nproclist;
static void (*qq_decls$pcl_callbackfn)(void) = 0;
static struct qq_decls$objrec *  qq_decls$chrtable[256];
static i64 qq_decls$fnosys;
static i64 qq_decls$fverbose;
static i64 qq_decls$fwritedocs;
static void *  qq_decls$docsdev;
static i64 qq_decls$pcllevel = (i64)0;
static i16 qq_decls$baseclasstable[256];
static struct qq_decls$strec *  qq_decls$baseclassdef[256];
static i64 qq_decls$nbaseclasses;
static i64 qq_decls$lastretindex;
static struct qq_decls$modulerec qq_decls$moduletable[101];
static byte qq_decls$moduletosub[101];
static struct qq_decls$subprogrec qq_decls$subprogtable[31];
static u8 *  qq_decls$sourcefilespecs[200];
static u8 *  qq_decls$sourcefilepaths[200];
static u8 *  qq_decls$sourcefilenames[200];
static byte qq_decls$sourcefilesys[200];
static byte qq_decls$sourcefilesupport[200];
static u8 *  qq_decls$sourcefiletext[200];
static i64 qq_decls$sourcefilesizes[200];
static i64 qq_decls$nsourcefiles;
static i64 qq_decls$nmodules;
static i64 qq_decls$nsubprogs;
static i64 qq_decls$mainmoduleno;
static struct qq_decls$strec *  qq_decls$stmglobals;
static struct qq_decls$objrec *  qq_decls$ppp;
static i64 qq_decls$ncalls;
static i64 qq_decls$nargcounts[100];
static i64 qq_decls$nmult;
static i64 qq_decls$nconsts;
static i64 qq_decls$nsmall;
static i64 qq_decls$headermode = (i64)0;
static i64 qq_decls$pclcounts[273];
static i64 qq_decls$nstringsx;
static i64 qq_decls$nlengths;
static void (*qq_jhandlers_hll$jhandlertable[273])(void);
static void (*qq_khandlers$khandlertable[273])(void);
static void (*qq_host$hosttable[78])(void);
static u8 *  qq_lex$lxsource;
static u8 *  qq_lex$lxstart;
static u8 *  qq_lex$lxsptr;
static i64 qq_lex$lxifcond;
static i64 qq_lex$longsuffix;
static i64 qq_lex$lxfileno;
static i64 qq_lex$nextlxlength;
static i64 qq_lex$lxlength;
static struct qq_decls$strec qq_lex$hashtable[65536];
static struct qq_decls$strec *  qq_lex$hashtablelast;
static u8 *  qq_lex$lxstart_stack[20];
static u8 *  qq_lex$lxsptr_stack[20];
static i64 qq_lex$lxfileno_stack[20];
static struct qq_decls$lexrec qq_lex$lxnextlx_stack[20];
static i64 qq_lex$sourcelevel = (i64)0;
static u8 *  qq_lex$u64maxstr = (byte*)"18446744073709551615";
static i64 qq_lib$currlineno;
static i64 qq_lib$nextavindex = (i64)0;
static struct mlib$strbuffer qq_lib$exprstrvar;
static struct mlib$strbuffer *  qq_lib$exprstr = &qq_lib$exprstrvar;
static struct qq_decls$unitrec qq_lib$unitpool[500];
static i64 qq_lib$nlocalunits;
static u8 *  qq_lib$errormess;
static byte qq_lib$bytemasks[8] = {(u8)1u,(u8)2u,(u8)4u,(u8)8u,(u8)16u,(u8)32u,(u8)64u,(u8)128u};
static struct qq_decls$objrec *  qq_lists$emptylist;
static u8 *  qq_modules$headerpathx = (byte*)"";
static u8 *  qq_modules$altpathx = (byte*)"";
static u8 *  qq_modules$importpathx = (byte*)"";
static u8 *  qq_modules$subprogpath = (byte*)"";
static i64 qq_modules$dirpos;
static i64 qq_modules$issyslib;
static u8 *  qq_modules$headervars[11];
static byte qq_modules$freadqa;
static i64 qq_names$sdsize;
static i64 qq_names$sdoffset;
static i64 qq_names$sdaligned;
static i64 qq_names$sdlevel;
static i64 qq_names$sdmode;
static i64 qq_names$sdnfields;
static i64 qq_names$sdmaxalign;
static byte qq_names$sdunion[10];
static i64 qq_names$sdmaxsize[10];
static i64 *  qq_optim$pc;
static i64 *  qq_optim$pcstart;
static i64 (*qq_optim$labelmap)[];
static i64 qq_parse$intabledata;
static u8 *  qq_parse$tabledataname = 0;
static struct qq_decls$unitrec *  qq_parse$dollarstack[10];
static i64 qq_parse$ndollar = (i64)0;
static byte qq_parse$yieldseen;
static u8 *  qq_parse$docstrings[50];
static i64 qq_parse$ndocstrings;
static i64 qq_parse$currdllindex;
static i64 qq_parse$listtypestack[20];
static i64 qq_parse$nlisttype;
static i64 qq_parse$listtype;
static i64 qq_print$mindev;
static i64 qq_print$moutdev;
static i64 *  qq_print$minchan;
static void *  qq_print$moutchan;
static struct qq_decls$varrec qq_print$minvar;
static struct qq_decls$varrec qq_print$moutvar;
static i32 qq_print$moutdevstack[6];
static void *  qq_print$moutchanstack[6];
static struct qq_decls$varrec qq_print$moutvarstack[6];
static byte qq_print$mgapstack[6];
static u8 *  qq_print$mfmtstrstack[6];
static u8 *  qq_print$mfmtcurrstack[6];
static i64 qq_print$noclevels;
static u8 *  qq_print$mfmtstr;
static u8 *  qq_print$mfmtcurr;
static struct qq_print$fmtrec qq_print$defaultfmt = {
    (u8)0u,
    (i8)(i64)0,
    (u8)10u,
    (u8)(i64)0,
    (u8)' ',
    (u8)'f',
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)'R',
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)0u
};
static byte qq_print$mgapneeded;
static u8 *  qq_print$kb_start;
static u8 *  qq_print$kb_pos;
static u8 *  qq_print$kb_lastpos;
static i64 qq_print$kb_size;
static i64 qq_print$kb_linelength;
static i64 qq_print$kb_length;
static i64 qq_print$kb_lastlength;
static u8 qq_print$termchar;
static i64 qq_print$itemerror;
static void *  qq_print$testfilech;
static i64 qq_print$listdepth = (i64)0;
static u8 qq_print$digits[16] = {
    (u8)(i64)48,
    (u8)(i64)49,
    (u8)(i64)50,
    (u8)(i64)51,
    (u8)(i64)52,
    (u8)(i64)53,
    (u8)(i64)54,
    (u8)(i64)55,
    (u8)(i64)56,
    (u8)(i64)57,
    (u8)(i64)65,
    (u8)(i64)66,
    (u8)(i64)67,
    (u8)(i64)68,
    (u8)(i64)69,
    (u8)(i64)70
};
static i64 *  qq_pclgen$loopstack[20][4];
static i64 qq_pclgen$trylevelstack[20];
static i64 qq_pclgen$loopindex = (i64)0;
static i64 qq_pclgen$looptrylevel;
static i64 qq_pclgen$trylevel = (i64)0;
static i64 qq_pclgen$currfunction = (i64)0;
static i64 qq_pclgen$retindex;
static i64 qq_pclgen$retvaloffset;
static i64 qq_pclgen$nprocparams;
static i64 qq_pclgen$nproclocals;
static i64 *  qq_pclgen$pproclocals;
static i64 qq_pclgen$procskiplabel;
static i64 *  qq_pcllib$pclstart;
static i64 *  qq_pcllib$pclnext;
static i64 *  qq_pcllib$pclend;
static i64 *  qq_pcllib$pcllast;
static i64 qq_pcllib$pclalloc;
static i32 *  qq_pcllib$pclsrcstart;
static i32 *  qq_pcllib$pclsrcnext;
static i64 qq_pcllib$pclcurrlineno;
static i64 (*qq_pcllib$labeloffsettable)[];
static i64 qq_pcllib$labelalloc;
static i64 qq_pcllib$nextlabelno;
static i64 qq_pcllib$labelflag;
static byte qq_pcllib$pclnopnds[273];
static i64 qq_resolve$nprocs;
static i64 qq_resolve$noexpand;
static i64 qq_resolve$symbolmode;
static i64 qq_resolve$macrolevels;
static i64 qq_resolve$allowmodname;
static struct qq_decls$strec *  qq_resolve$macroparams[50];
static struct qq_decls$strec *  qq_resolve$macroparamsgen[50];
static struct qq_decls$unitrec *  qq_resolve$macroargs[50];
static i64 qq_resolve$nmacroparams;
static i64 qq_resolve$nmacroargs;
static struct qq_decls$strec *  qq_resolve$structfields[100];
static i64 qq_resolve$ntopfields;
static i64 qq_resolve$nallfields;
static struct qq_decls$objrec *  qq_strings$emptystring;
static u8 *  qq_syslibs$syslibnames[12] = {
    (byte*)"sysp.q",
    (byte*)"clibp.q",
    (byte*)"smlib.q",
    (byte*)"winapi.q",
    (byte*)"gxlib.q",
    (byte*)"bmlib.q",
    (byte*)"console.q",
    (byte*)"winconsts.q",
    (byte*)"wingxlib.q",
    (byte*)"winmessages.q",
    (byte*)"gxmisc.q",
    (byte*)"dates.q"
};
static u8 *  qq_syslibs$libtext[12] = {
    
(byte*)"!Q standard library\n\n!import clib\n!import winapi\n\nexport type rkey=struct\t!key info as it's used locally\n\tword16\tcharcode\n\tbyte\tkeycode\n\tbyte\tshift\nend\n\nexport var ncmdparams\nexport var cmdparams\nexport var stclock=0\n\nexport const tab=\"\\t\"\n\nexport var readfilesize\n\nexport var infinity=$infinity()\nexport var nan=$nan()\n\n\nproc start=\n\n!CPL \"SYS/START XXXYY\"\n\n\tncmdparams:=getcmdparam()\n!CPL \"SYS:\",=NCMDPARAMS\n\n\tcmdparams:=new(list,1..ncmdparams)\n\n\ts::=\"\"\n\tfor i:=1 to ncmdparams do\n\t\tcmdparams[i]:=getcmdparam(i)\n\t\ts+:=cmdparams[i]+\" \"\n    od\n\n\tsreadln(s)\nend\n\nproc main=\n\tstart()\n\n\ta:=(10,20,30,40)\n\tb:=(3,5,7,9)\n!\n\tcpl =a\n!\tcpl =b\n\n!\tc:=mapsv((+),100,b)\n\tcpl mapv((sqr),a)\n\nend\n\nexport proc reporterror(m)=\n#print \"Error:\" followed by message m. Is that it? Count as being deprecated\n\n\tprintln \"Error:\",m\nend\n\nexport func splitstring(s,sep)=\n#split up the string s into strings separated by the sep sequence\n#return a list of all the individual strings, excluding the sep seq\n\n\ta::=()\n\tns:=0\n\tif s=\"\" or sep=\"\" then return (s,) fi\n\tdo\n\t\tn:=sep inx s\n\t\tif not n.isfound then\n\t\t\ta[++ns]:=s\n\t\t\treturn a\n\t\tfi\n\t\tt:=leftstr(s,n-1)\n\t\ta[++ns]:=t\n\t\ts:=rightstr(s,-(n+sep.len-1))\n\tod\n\treturn \"\"\nend\n\nexport func joinstrings(a,sep)=\n#join the strings in list, using the given separator string\n#return new single string\n\tif a.upb=0 then return \"\" fi\n\ts:=a[1]\n\tfor i:=2 to a.upb do\n\t\ts:=s+sep+a[i]\n\tod\n\treturn s\nend\n\nexport proc abort(s)=\n#Print message, pause for keypress, then stop the interpreter with stopcode 1\n\n\tprintln \"Abort:\",s,\"Error\"\n\twaitkey()\n\tstop 1\nend\n\nexport func extractpath(fs)=\n#fs is a full filespec string\n#extract any path from it and return that; ie, strip the filename\n#otherwise return \"\"\n\tl:=fs.len\n\tfor i:=l downto 1 do\n\t\tif chr(fs.[i]) in \"\\\\/:\" then\n\t\t\treturn leftstr(fs,i)\n\t\tfi\n\tod\n\treturn \"\"\nend\n\nexport func extractfile(fs)=\n#return filename portion of path fs\n\tp:=extractpath(fs)\n\tif p=\"\" then return fs fi\n\treturn rightstr(fs,-p.len)\nend\n\nexport func extractbasefile(fs)=\n#return filename portion of path fs\n\tf:=extractfile(fs)\n\tif f=\"\" then return \"\" fi\n\te:=extractext(f)\n\tif e.len then\n\t\tf:=leftstr(f,-e.len)\n\tfi\n\tif rightstr(f)=\".\" then\n\t\tf:=leftstr(f,-1)\n\tfi\n\treturn f\nend\n\nexport func extractext(fs,period=0)=\n#extract extension part of filespec fs\n#endings of \"xxx\" (no extension) and \"xxx.\" both return \"\"\n#with period=1, then \"xxx\" returns \"\" and \"xxx.\" returns . (so can be used to\n#override default extensions)\n\n\tf:=extractfile(fs)\n\tif f=\"\" then return \"\" fi\n\te:=\"\"\n\tdo\n\t\tn:=\".\" inx f\n\t\tif n.isfound then\n\t\t\te:=rightstr(f,-n)\n\t\t\tif e=\"\" then\t\t!. ending\n\t\t\t\treturn (period.defined and period|\".\"|\"\")\n\t\t\tfi\n\n\t\t\tf:=e\n\t\telse\n\t\t\texit\n\t\tfi\n\tod\n\n\treturn e\nend\n\nexport func changeext(file,newext,soft=0)=\n#normally face a change of extension to the file spec\n#use soft=1 to only change extension if no extension is present (a \".\" ending is an extension)\n\text:=extractext(file)\n\n\tp:=extractpath(file)\n\tbf:=extractbasefile(file)\n\tep:=extractext(file,1)\n\n\tif soft and ep<>\"\" then return file fi\t\t!has extension, don't change!\n\n\tif newext=\"\" then\n\t\treturn p+bf\n\telsif leftstr(newext)=\".\" then\n\t\treturn p+bf+newext\n\telse\n\t\treturn p+bf+\".\"+newext\n\tfi\nend\n\nexport func addpath(path,file)=\n#If file doesn't already have an absolute path (here, starting with \\ / or ?:)\n#then prepend 'path', which must end with \\ or /\n\tif leftstr(file) in \"/\\\\.\" or file.len>=2 and file.[2]=\":\" then\n\t\treturn file\n\tfi\n\treturn path+file\nend\n\nexport func addext(file,ext)=\n#add extension to filename, if it doesn't already have it's own extenstion\n\n\tif extractext(file,1)=\"\" then\n\t\treturn changeext(file,ext)\n\tfi\n\treturn file\nend\n\nexport func replacestr (s,a,b)=\n#if string a exists in s, then replace with b\n#return original or modified s\n\tdo\n\t\tn:=a inx s\n\t\tif not n.isfound then return s fi\n\t\ts:=leftstr(s,n-1)+b+rightstr(s,1-n-a.len)\n\tod\n\treturn \"\"\nend\n\nexport func parsecmdparams(cmd)=\n#cmd consists of:\n#blocks of text separated by whitespace or commas\n#each block is one of these formats\n# ...\t\tparam only\n# /...\t\tconsists of switches only\n# .../...\tparam followed by switches\n#return of (params,switches), where each is a list of strings\n#note that any correspondence between params and switches is lost; all switches assumed\n#to be global, but can appear anywhere\n#NOTE: cmd can also already be a list of blocks\n\nconst dash=\"-\"\n\n\tif cmd.islist then\n\t\tblocks:=cmd\n\telse\n\t\tsreadln(cmd)\n\t\tblocks::=()\n\t\tdo\n\t\t\tread a:\"s\"\n\t\t\tif a=\"\" then exit fi\n\t\t\tblocks append:=a\n\t\tod\n\tfi\n\n\tparams::=()\n\tswitches::=()\n\n\tforall x in blocks do\n\t\tn:=dash inx x\n!\t\tif n=0 then\t\t!pure param\n!\t\t\tparams append:=x\n\t\tif n=1 then\t\t!pure switches\n\t\t\tswitches concat:=splitstring(convlc(rightstr(x,-1)),\"/\")\n\t\telse\t\t\t!param followed by switches\n\t\t\tparams append:=x\n!\t\t\tparams append:=leftstr(x,n-1)\n!\t\t\tswitches concat:=splitstring(convlc(rightstr(x,-n)),\"/\")\n\t\tfi\n\tod\n\n\treturn (params,switches)\nend\n\nexport proc waitsec(secs)=\n#wait for given number of seconds, which can be a float. Call sleep()\n\tsleep(int(secs*1000))\nend\n\nexport func cmd_getswitches=\n#params is a list of strings, which\n#read all switches, and return a list of switch names (minus the \"/\")\n#each string can have more than one switch\n#some switches can follow a name in a string\n\n\tswitches::=()\n\tfor i:=1 to cmdparams.upb do\t\t!use 1..len in case called on <cmdparams> which has lwb 0\n\t\ts:=cmdparams[i]\n\t\tif leftstr(s) in \"-/\" then\n\t\t\tswitches append:=convlc(rightstr(s,-1))\n\t\tfi\n\tod\n\treturn switches\nend\n\nexport func cmd_getparams=\n#params is a list of strings\n#return list of actual params, not including any switches\n#switches are read separately using cmd_getswitches, but are not associated with\n#specific params. That would need to be done here (when / is detected in the middle\n#of a param, then make use readswitches. But to return that info, may be best to\n#create a parallel function)\n\n\tcmds::=()\n\n\tfor i:=1 to cmdparams.upb do\n\t\tpm:=cmdparams[i]\n!forall pm in params do\n\t\tif leftstr(pm) in \"/-\" then\n\t\t\tnext\n\t\tfi\n!\tn:=\"/\" in pm\n!\tif n=0 then\n\t\t\tcmds append:=pm\n!\telse\n!\t\tcmds append:=leftstr(pm,n-1)\n!\tfi\n\tod\n\treturn cmds\nend\n\nexport func starttimer=\n#Start timer and remember ticks at this point\n\treturn stclock:=ticks()\nend\n\nexport func stoptimer=\n#Return number of ticks since starttimer was called, or last stoptimer\n#as the count is reset\n\n \td:=ticks()-stclock\n\tstclock:=ticks()\n\treturn d\nend\n\nexport func bnfact(n)=\n#n is limited to 9 million million million\n\n\tif n<=2 then\n\t\treturn longint(n)\n\tfi\n\n\tf:=1L\n\tg:=2L\n\tto n-1 do\n\t\tf:=f*g\n\t\tg:=g+1L\n\n\tod\n\treturn f\nend\n\nexport proc isort(a,?ll,?rr)=\n#inplace quicksort of a, which is anything that is indexable\n#ll rr are used for recursive calls\n\tif ll.isvoid then\n\t\tll:=a.lwb\n\t\trr:=a.upb\n\tfi\n\n\ti:=ll\n\tj:=rr\n\n\tpivot:=a[(ll+rr)%2]\n\n\trepeat\n\t\twhile pivot>a[i] and i<rr do ++i od\n\t\twhile pivot<a[j] and j>ll do --j od\n\t\tif i<=j then\n\t\t\tswap(a[i],a[j])\n\t\t\t++i\n\t\t\t--j\n\t\tfi\n\tuntil i>j\n\tif ll<j then isort(a,ll,j) fi\n\tif i<rr then isort(a,i,rr) fi\nend\n\nexport func sort(a)=\n#quicksort a and return newly sorted list. Duplicates a then uses isort\n\tb::=a\n\tisort(b)\n\treturn b\nend\n\nexport func pcerror(m)=\n#Force an interpreter error; advantage is that source location is reported.\n\n\tprintln \"Internal error:\",m\n\ta:=b+c\n\treturn 0\nend\n\n\n\n!=========================================\nexport proc insert(&a, b, c)=\n#insert value c just before index b\n#c is always a single value; to insert a sequence c, use insertn()\n\tn:=a.upb\n\ta[n+1]:=c\n\tfor i:=n downto b do\n\t\tswap(a[i+1],a[i])\n\tod\nend\n\nexport proc isort2(a,b,?ll,?rr)=\n#Like isort but also sorts b in parallel; sort order is determined by a however\n\tif ll.isvoid then\n\t\tll:=a.lwb\n\t\trr:=a.upb\n\tfi\n\n\ti:=ll\n\tj:=rr\n\n\tpivot:=a[(ll+rr)%2]\n\n\trepeat\n\t\twhile pivot>a[i] and i<rr do ++i od\n\t\twhile pivot<a[j] and j>ll do --j od\n\t\tif i<=j then\n\t\t\tswap(a[i],a[j])\n\t\t\tswap(b[i],b[j])\n\t\t\t++i\n\t\t\t--j\n\t\tfi\n\tuntil i>j\n\tif ll<j then isort2(a,b,ll,j) fi\n\tif i<rr then isort2(a,b,i,rr) fi\nend\n\nexport func left(a,n=1)=\n#return leftmost n elements of a (default left element)\n#when n is negative, all except rightmost -n\n\n\tif n>=0 then\n\t\treturn take(a,n)\n\telse\n\t\treturn take(a,a.len+n)\n\tfi\nend\n\nexport func right(a,n=1)=\n#return rightmost n elements of a (default right element)\n#when n is negative, all except leftmost -n\n\n\tif n>=0 then\n\t\treturn drop(a,a.len-n)\n\telse\n\t\treturn drop(a,-n)\n\tfi\nend\n\nexport func reverse(a)=\n#return reversed version of a\n#when 0, returns empty\n#when 1 element, returns a distinct, writeable copy\n\n\tif a.len=0 then\n\t\treturn makeempty(a)\n\tfi\n\tb::=a\n\n\tif a then\n\t\tfor i in a.bounds do\n\t\t\tb[a.upb-i+a.lwb]:=a[i]\n\t\tod\n\tfi\n\treturn b\nend\n\nexport func expandrange(a,step=1)=\n#Turn range a into a list of inclusive values\n\tx::=()\n\ti:=a.lwb\n\twhile i<=a.upb do\n\t\tx append:=i\n\t\ti+:=step\n\tod\n\treturn x\nend\n\nexport func head(a)=\n#return first element, or empty when empty\n\n\tif a.len then\n\t\treturn a[a.lwb]\n\telse\n\t\treturn makeempty(a)\n\tfi\nend\n\nexport func tail(a)=\n#return all except the first element\n#returns empty when only 0 or 1 elements\n\n\tcase a.len\n\twhen 0,1 then\n\t\treturn makeempty(a)\n\tesac\n\treturn a[2..$]\nend\n\nexport func init(a)=\n#return all except last element\n#returns empty when only 0 or 1 elements\n\tcase a.len\n\twhen 0,1 then\n\t\treturn makeempty(a)\n\tesac\n\treturn a[a.lwb..$-1]\nend\n\nexport func last(a)=\n#return last element, or empty\n\tif a.len then\n\t\treturn a[$]\n\telse\n\t\treturn makeempty(a)\n\tfi\nend\n\nexport func take(a,n)=\n#return first n elements from list/string a\n#returns () or \"\" when a is empty\n#n > 0 (n<=0 returns empty)\n\n\tif a.len=0 or n<=0 then\n\t\treturn makeempty(a)\n\tfi\n\tif n>=a.len then\n\t\treturn a\n\tfi\n\treturn a[a.lwb..a.lwb+n-1]\nend\n\nexport func drop(a,n)=\n#skips first n elements of a then returns the rest\n#returns () when empty, or skipping the whole list\n#n >= 0\n\n\tif a.len=0 or n>=a.len then\n\t\treturn makeempty(a)\n\tfi\n\tif n<=0 then\n\t\treturn a\n\tfi\n\treturn a[a.lwb+n..$]\nend\n\nexport func zip(a,b)=\n#return a list consisting of alternate elements from a and b\n#uses smaller of the two dimensions\n\n\tn:=min(a.len,b.len)\n\tc::=()\n\n!\tj:=a.lwb; k:=b.lwb\n\t(j, k) := (a.lwb, b.lwb)\n\n\tto n do\n\t\tc append:=a[j++]\n\t\tc append:=b[k++]\n\tod\n\treturn c\nend\n\nexport func repeatlist(a,n)=\n#duplicate a n times, and return the result\n#this ought to be built-in as a*n, but that's only implemented for a.len=1\n\n\tb:=makeempty(a)\n\tto n do\n\t\tb concat:=a\n\tod\n\treturn b\nend\n\n!export func minimum(a)=\n!#return minimum value of elements in a\n!\tif not a then\n!\t\treturn void\n!\tfi\n!\tx:=head(a)\n!\tforall y in tail(a) do\n!\t\tx min:=y\n!\tod\n!\treturn x\n!end\n!\n!export func maximum(a)=\n!#return maximum value of elements in a\n!\tif not a then\n!\t\treturn void\n!\tfi\n!\tx:=head(a)\n!\tforall y in tail(a) do\n!\t\tx max:=y\n!\tod\n!\treturn x\n!end\n!\n!export func sumlist(a)=\n!# apply \"+\" between all elements of a, and return result\n!# all elements must be compatble (all strings or all numbers for example)\n!# returns void then a is empty, or head(a) when just one element\n!\n!\tif not a then\n!\t\treturn void\n!\tfi\n!\tx:=head(a)\n!\tforall y in tail(a) do\n!\t\tx +:=y\n!\tod\n!\treturn x\n!end\n\nexport proc delete(&a,?b)=\n#delete element b\n\tn:=a.upb\n\tif b.isvoid then b:=n fi\n\n\tif n=b=1 then\n\t\ta::=()\n\t\treturn\n\tfi\n\n\tif b>n then return fi\n\tif b<a.lwb then return fi\n\tfor i:=b to n-1 do\n\t\tswap(a[i],a[i+1])\t\t\t!swap is faster for complex elements\n\tod\n!a[n]:=0\t\t!don't leave any heap data beyond new end of list\n\n\tresize(a,n-1)\nend\n\nexport proc resize(&a,n)=\n#hange the upper bound of a to n\n\n\tif n<a.lwb then\n\t\ta:=makeempty(a)\n\t\treturn\n\tfi\n\n\ta::=a[a.lwb..n]\t\t\t!duplication forces original to be freed\nend\n \nexport func makebits(data,t=bit)=\n#turn data (list, array, or bit array of different type) into a bit array\n\n\ta:=new(bits,t,data.bounds)\n\tfor i:=data.lwb to data.upb do\n\t\ta[i]:=data[i]\n\tod\n\treturn a\nend\n\nexport func makearray(data,t=int64)=\n#turn data (list, array of different type, or bit array) into an array of \n#given element type\n\n\ta:=new(array,t,data.bounds)\n\tfor i:=data.lwb to data.upb do\n\t\ta[i]:=data[i]\n\tod\n\treturn a\nend\n\nexport func tolist(a)=\n#convert a, a string, array or bits, to a list, and return that list\n\n\tcase a.basetype\n\twhen array,string,bits then\n\t\tb:=new(list,a.bounds)\n\t\tforall i,x in a do\n\t\t\tb[i]:=x\n\t\tod\n\t\treturn b\n!\twhen string then\n!\t\tb:=new(list,a.len)\n!\t\ti:=1\n!\t\tforall i,x in a do\n!\t\t\tb[i++]:=x\n!\t\tod\n!\t\treturn b\n\n\twhen list then\n\t\treturn a\n\telse\n\t\tpcerror(\"tolist:\"+tostr(a.type))\n\tesac\n\treturn 0\nend\n\nexport func toarray(a,?t)=\n#convert a, a list, string, array or bits, to an array, and return that array\n#can be used to turn one array type into another\n\tcase a.basetype\n\twhen list then\n\t\tif t.isvoid then\n\t\t\tif a then\n\t\t\t\tt:=a[a.lwb].type\n\t\t\telse\n\t\t\t\tt:=int32\n\t\t\tfi\n\t\tfi\n\n\twhen bits then\n\t\tif t.isvoid then\n\t\t\tt:=byte\n\t\tfi\n\n\twhen string then\n\t\tif t.isvoid then t:=byte fi\n\t\tb:=new(array,t,a.len)\n\t\tforeach i,x in a do\n\t\t\tb[i]:=x\n\t\tod\n\t\treturn b\n\twhen array then\n\t\tif t.isvoid then\n\t\t\treturn a\n\t\tfi\n\t\tu:=e.elemtype\n\t\tif t=u then return a fi\n\telse\n\t\tpcerror(\"toarray:\"+tostr(a.type))\n\tesac\n\tb:=new(array,t,a.bounds)\n\n\tforall i,x in a do\n\t\tb[i]:=x\n\tod\n\treturn b\nend\n\nexport func tobits(a,t=bit)=\n#convert a, a list, array or other bit array, into a bit array\n\n\tcase a.basetype\n\twhen list,array then\n\n\twhen bits then\n\t\tif a.elemtype=t then\n\t\t\treturn a\n\t\tfi\n\n\telse\n\t\tpcerror(\"tobits:\"+tostr(a.type))\n\tesac\n\tb:=new(bits,t,a.bounds)\n\tforall i,x in a do\n\t\tb[i]:=x\n\tod\n\treturn b\nend\n\nexport func listtostring(a)=\n#a should be a list or array\n#interpreter elements as characters and form a single string\n\ts:=\"\"\n\tforall x in a do\n\t\ts+:=chr(x)\n\tod\n\treturn s\nend\n\nexport func qversion=\n\treturn \"4.0\"\nend\n\nexport proc issort(a,?ll,?rr)=\n#Version of isort that works with dot-indexing\n\n\tif ll.isvoid then\n\t\tll:=a.lwb\n\t\trr:=a.upb\n\tfi\n\n\ti:=ll\n\tj:=rr\n\n\tpivot:=a.[(ll+rr)%2]\n\n\trepeat\n\t\twhile pivot>a.[i] and i<rr do ++i od\n\t\twhile pivot<a.[j] and j>ll do --j od\n\t\tif i<=j then\n\t\t\tswap(a.[i],a.[j])\n\t\t\t++i\n\t\t\t--j\n\t\tfi\n\tuntil i>j\n\tif ll<j then issort(a,ll,j) fi\n\tif i<rr then issort(a,i,rr) fi\nend\n\nexport func ssort(a)=\n#Version of sort() with dot-indexing, eg. strings, or int bits\n\n\tb::=a\n\tissort(b)\n\treturn b\nend\n\nexport func maketable(rows, cols, initval=0)=\n#Create a table: a rectangular list, set to either 0 or to initval\n#Each rows/cols is a range, or length\n\n\trow:=new(list,cols,initval)\n\n\ttable::=new(list,rows)\n\tif rows.isint then rows:=1..rows fi\n\n\tfor i in rows do\n\t\ttable[i]::=row\n\tod\n\n\treturn table\nend\n\nexport func mapv(op,a)=\n#Apply operator or suitable unary func to all elements of vector a,\n#and return new list \n\tb::=makeempty(a)\n\tfor i,x in a do\n\t\t\tb[i]:=mapss(op,x)\n\tod\n\treturn b\nend\n\nexport func mapvv(op,a,b)=\n#Apply op or func between corresponding elements of vectors a and b\n\tc::=makeempty(a)\n\tforall i,x in a do\n\t\tc[i]:=mapss(op,x,b[i])\n\tod\n\treturn c\nend\n\nexport func mapvs(op,a,bs)=\n#Apply op or func between elements of vector a and single value bs\n\tc::=makeempty(a)\n\tforall i,x in a do\n\t\tc[i]:=mapss(op,x,bs)\n\tod\n\treturn c\nend\n\nexport func mapsv(op,as,b)=\n#Apply op or func between elements of single value as and vector b\n!\tc::=makeempty(b)\n\tc::=()\n\tforall i,x in b do\n\t\tc[i]:=mapss(op,as,x)\n\tod\n\treturn c\nend\n\nexport func openfile(name,option=\"rb\")=\n#Open a file for reading. Uses C's fopen and default option is for binary mode\n#Return a valid file handle, which is an int64 value, or 0 when not found\n\tif not name.isstring or name=\"\" then\n\t\treturn 0\n\tfi\n\treturn fopen(name,option)\nend\n\nexport func createfile(name,options=\"wb\")=\n#Create a new file and return its handle, or 0 if there was an error\n\tif not name.isstring or name=\"\" then return 0 fi\n\treturn fopen(name,options)\nend\n\nexport func closefile(f)=\n#close the file associated with handle f\n\treturn fclose(f)=0\nend\n\nexport func checkfile(name)=\n#return 1 if file name exists, otherwise 0\n\tfile:=fopen(name,\"rb\")\n\tif file=0 then return 0 fi\n\tfclose(file)\n\treturn 1\nend\n\nexport func eof(f)=\n#return 1 if at eof on currently open file handle f\n\tc:=fgetc(f)\n\tif c=-1 then return 1 fi\n\n\tungetc(c,f)\n\treturn 0\nend\n\nexport func getfilesize(f)=\n#return size of bytes of currently open file f\n\tp:=ftell(f)\t\t\t!p=current position\n\tfseek(f,0,2)\t\t!get eof position\n\tsize:=ftell(f)\t\t!size in bytes\n\tfseek(f,p,0)\t\t!restore file position\n\treturn size\nend\n\nexport func setfilepos(f,offset)=\n#set position in file f to given byte offset\n\treturn fseek(f,offset,0)\nend\n\nexport func getfilepos(f)=\n#return current file position\n\treturn ftell(f)\nend\n\nexport func readrandom(f,mem,offset,size)=\n#read size bytes from file f, to memory at mem, from given offset\n#returns number of bytes read\n#mem needs to be a pointer\n#new file offset will be offset+size (or offset+byte read if smaller)\n\tfseek(f,offset,0)\n\treturn fread(mem,1,size,f)\nend\n\nexport func writerandom(f,mem,offset,size)=\n#write size bytes from memory at mem, to current file f from given offset\n#returns bytes written\n\tfseek(f,offset,0)\n\treturn fwrite(mem,1,size,f)\nend\n\nexport func readbytes(f,mem,size)=\n#read size bytes from current position in file f to mem\n\treturn fread(mem,1,size,f)\nend\n\nexport func writebytes(f,mem,size)=\n#write size bytes from mem to current position in f\n\treturn fwrite(mem,1,size,f)\nend\n\nexport func inbyte(file)=\t\t!INBYTE\n\treturn fgetc(file)\nend\n\nexport func inword(file)=\t\t!INWORD\n\tbb:=fgetc(file)\n\treturn fgetc(file)<<8+bb\nend\n\nexport func inlong(file)=\t\t!INLONG\n\tww:=inword(file)\n\treturn inword(file)<<16+ww\nend\n\nexport proc outbyte(file,x)=\t\t!OUTBYTE\n!writerandom(file,&x,getfilepos(file),1)\n\tfputc(x,file)\nend\n\nexport proc outword(file,x)=\t\t!OUTWORD\n\toutbyte(file,x iand 255)\n\toutbyte(file,x.[15..8])\nend\n\nexport proc outlong(file,x)=\t\t!OUTLONG\n\toutword(file,x iand 65535)\n\toutword(file,x>>16)\nend\n\nexport func instring(file)=\t\t!INSTRING\n\ts::=\"\"\n\tdo\n\t\tc:=inbyte(file)\n\t\tif c=0 then return s fi\n\t\ts+:=c\n\tod\n\treturn s\nend\n\nexport func appendfile(a,b)=\n#append line-based text file a to file b\n\nf:=openfile(a)\nif f=0 then return 0 fi\n\nh:=openfile(b,\"ab\")\nif h=0 then return 0 fi\n\nwhile not eof(f) do\n\treadln @f,x:\"l\"\n\tprintln @h,x\nod\n\nclosefile(f)\nclosefile(h)\nreturn 1\nend\n\nexport func readblockfile(filename,doetx=0)=\n#read text file into a memory block\n#block is allocated here\n#return byte pointer to start of block, or nil\n#doetx=1 to add etx byte to end\n\nf:=openfile(filename)\nif f=0 then return nil fi\n\nn:=getfilesize(f)\nreadfilesize:=n\n\ns:=malloc(n+doetx)\nif s=0 then abort(\"Readfile/Malloc fails\") fi\nsptr:=makeref(s,byte)\n\n!readrandom(f,&s,0,n)\nreadrandom(f,s,0,n)\n\nif doetx then\n\t(sptr+n)^:=26\nfi\n\nclosefile(f)\nreturn sptr\nend\n\nexport func readstrfile(filename,doetx=0)=\n#read text file into a single string\n#return string, or 0 if there was an error\n\nf:=openfile(filename)\nif f=0 then return 0 fi\n\nn:=getfilesize(f)\nreadfilesize:=n\n\nptr:=malloc(n+1+doetx)\nif ptr=0 then abort(\"Readfile/Malloc fails\") fi\n\nreadrandom(f,ptr,0,n)\nif doetx then\n\t(makeref(ptr,byte)+n)^:=26\nfi\n\nclosefile(f)\n\ns::=makestr(ptr,n+doetx)\n\nfree(ptr)\nreturn s\nend\n\nexport func writestrfile(filename,s)=\n#read text file from a single string\n#return status\n\nf:=createfile(filename)\nif f=0 then return 0 fi\n\nwriterandom(f,makeref(s,byte),0,s.len)\n\nreturn closefile(f)\nend\n\nexport func readbinfile(filename)=\n#read binary file into byte array\n#return () (empty list not array) on error\n\nf:=openfile(filename)\nif f=0 then return 0 fi\n\nn:=getfilesize(f)\nreadfilesize:=n\n\na:=new(array,byte,n)\nreadrandom(f,&a,0,n)\n\nclosefile(f)\nreturn a\nend\n\nexport func writebinfile(filename,a)=\n#write binary file from byte array a\n#return status 1/0\n\nf:=createfile(filename)\nif f=0 then return 0 fi\n\nwriterandom(f,(&a),0,a.len)\n\nclosefile(f)\nreturn 1\nend\n\nexport func writeblockfile(filename,p,length)=\n#return status 1/0\n\nf:=createfile(filename)\nif f=0 then return 0 fi\n\nif not writerandom(f,p,0,length) then return 0 fi\n\nclosefile(f)\nreturn 1\nend\n\nexport func erasefile(filename)=\n#delete given file, return status (check msdn)\nreturn remove(filename)\nend\n\nexport func renamefile(oldfilename,newfilename)=\n#rename file, return status (check msnd)\nreturn rename(oldfilename,newfilename)\nend\n\nexport func readtextfile(file)=\n#read text file into a list of strings; one per line\n#return list, or 0 on error\nf:=openfile(file)\nif not f then\n\treturn 0 \nfi\n\nreadfilesize:=getfilesize(f)\na::=()\n\nwhile not eof(f) do\n\ta append:= sreadln(f)\nod\nclosefile(f)\nreturn a\nend\n\nexport func writetextfile(file,a)=\n#write list of strings <a> as a text file <file>\nf:=createfile(file)\nif not f then return 0 fi\n\nfor i:=a.lwb to a.upb do\n\tprintln @f,a[i]\nod\nclosefile(f)\nreturn 1\nend\n\nexport func readbinaryfile(filename,t)=\n#read binary file consisting of an array of type t values, into array of t\n#return () (empty list not array) on error\n\n\tf:=openfile(filename)\n\tif f=0 then return () fi\n\n\tn:=getfilesize(f)\n\treadfilesize:=n\n\telems:=n%t.bytes\n\n\ta:=new(array,t,elems)\n\treadrandom(f,&a,0,n)\n\n\tclosefile(f)\n\treturn a\nend\n\nexport func writebinaryfile(filename,data)=\n#write binary file from array of a fixed type to a file\n#return 1/0 status\n\treturn writeblockfile(filename,&data,data.bytes)\nend\n\nexport func confirm(m,caption=\"Confirm\",default=1)=\n#Pop-up box to ask for confirmationdefault=1/2/3 for yes/no/cancel button\n#Return 1 or 0\n\n\tflags:=0x20000+0x20\t!foreground window/question mark icon\n\tflags ior:=3\t\t!yes/no/cancel\n\n\tflags ior:=(default|0,0x100,0x200|0)\n\n\tstatus:=messagebox(nil,m,caption,flags)\n\treturn status=6\nend\n\nexport func messagebox(a=nil,mess,caption=\"Caption\",d=0)=\n#Standard Windows' Messagebox\n\treturn messageboxa(nil,mess,caption,d)\nend\n\nexport func dirlist(s,t=1)=\n#s is a export filename (eg. \"*.dwg\") with possible drive/path; scan\n#directory for all matching files and return as a list of names\n#also returns total no. of files so far\n#t= +1\tInclude normal files, no sub-directory names\n#t= +2  Include directories\n#t= +3  Include all files including directories\n#t= +4  Convert to lower case\n#t=  0  Defaults to +1\n\n!CPL \"DIRLIST/WINLIB\"\n\n\tif t.isvoid then t:=1 fi\t\t\t!files only\n\n\tnfiles:=0\n\tdata::=()\n\tfile:=new(ws_finddata)\n\n\tif (hfind:=findfirstfile(s,&file))<>-1 then\t!at least one file\n\t\trepeat\n\t\t\tif (file.fileattributes iand 16) then\t\t!this is a directory\n\t\t\t\tif (t iand 2)=0 then goto skip fi\t\t!no directories\n\t\t\telse\t\t\t\t\t\t!this is a file\n\t\t\t\tif (t iand 1)=0 then goto skip fi\n\t\t\tfi\n\t\t\t++nfiles\n\t\t\tif (t iand 4) then\t\t\t\t!to lower case\n\t\t\t\tdata[nfiles]:=convlc(file.filename)\n\t\t\telse\n\t\t\t\tdata[nfiles]::=file.filename\n\t\t\tfi\n\tskip:\n\t\tuntil not findnextfile(hfind,&file)\n\t\tfindclose(hfind)\n\tfi\n\treturn data\nend\n\nexport func setcurrdir(newdir)=\n#Set current directory; return Windows' status code\n\treturn setcurrentdirectory(newdir)\nend\n\nexport func getcurrdir=\n#Return current directory name, always ends with \\ or /\n\ta:=new(array,byte,256)\n\tn:=getcurrentdirectory(a.len,&a[1])\n\n\tif n then\n\t\tdir::=makestr(&a[1],n)\n\telse\n\t\tdir:=\"\"\n\tfi\n\n\tif not (rightstr(dir) in \"\\\\/\") then dir +:= \"\\\\\" fi\n\treturn dir\nend\n\nexport func createdir(name)=\n#Create a new directory\n\treturn createdirectory(name,0)\nend\n\nexport func direxists(path)=\n#Return 1 if directory path exists\n\tconst file_attribute_directory=16\n\tconst invalid_file_attributes=-1\n\n\tattrib := getfileattributesa(path)\n\n\treturn attrib<>invalid_file_attributes and (attrib iand file_attribute_directory)\nend\n\nexport proc beep1=\n#Standard beep\n\tmessagebeep(0)\nend\n\nexport proc mem(mess)=\n\tstatic var startmem\n\tif startmem.isvoid then\n\t\tstartmem:=$smallmemtotal()\n\tfi\n\tprintln mess,,\":\",$smallmemtotal()-startmem\nend\n\nexport func reduce(op, a)=\n\tx:=head(a)\n\tfor y in tail(a) do\n\t\tx:=mapss(op,x,y)\n\tod\n\tx\nend\n",
    (byte*)"importdll msvcrt=\n\tclang func    \t\"malloc\"\t\t(int64)ref byte\n\tclang func    \trealloc\t\t(int64, int32)int64\n\tclang procedure\tfree\t\t(int64)\n\tclang procedure\tmemset\t\t(ref byte, int32, int32)\n\tclang procedure\tmemcpy\t\t(ref byte, ref byte, int32)\n!\tclang func    \tclock\t\t:int32\n\tclang func    \tftell\t\t(int64)int32\n\tclang func    \tfseek\t\t(int64, int32, int32)int32\n\tclang func    \tfread\t\t(ref byte, int32, int32, int64)int32\n\tclang func    \tfwrite\t\t(ref byte, int32, int32, int64)int32\n\tclang func    \tgetc\t\t(int64)int32\n\tclang func    \tungetc\t\t(int32, int64)int32\n\tclang func    \tfopen\t\t(stringz, stringz)int64\n\tclang func    \tfclose\t\t(int64)int32\n\tclang func    \tfgets\t\t(ref byte, int32, int64)ref byte\n\tclang func    \tremove\t\t(stringz)int32\n\tclang func    \trename\t\t(stringz, stringz)int32\n\tclang func    \tgetchar\t\t:int32\n\tclang procedure\tputchar\t\t(int32)\n\tclang procedure\tsetbuf\t\t(int64, int64)\n\n\tclang func    \trand\t\t:int32\n\tclang procedure\tsrand\t\t(int32)\n\n\tclang func    \tputs\t\t(stringz)int32\n\tclang func    \tprintf\t\t(stringz, ...)int32\n\n\tclang func    \tsprintf\t\t(stringz, stringz, ...)int32\n\n\tclang func    \tsscanf\t\t(stringz, stringz, ...)int32\n\tclang func    \tisalpha\t\t(int32)int32\n\tclang func    \ttolower\t\t(int32)int32\n\tclang func    \tstrlen\t\t(ref byte)int32\n\tclang func    \tatoi\t\t(stringz)int32\n\n!\tclang func    \tsystem\t\t(stringz)int32\n\n\tclang func    \tfgetc\t\t(int64)int32\n\tclang func    \tfputc\t\t(int32,  int64)int32\n\tclang func    \tfprintf\t\t(int64, stringz, ...)int32\n\tclang func    \tfputs\t\t(stringz,  int64)int32\n\tclang func    \tfeof\t\t(int64)int32\n!\tclang func    \tgetch\t\t:int32\n\tclang func    \t_getch\t\t:int32\n\nend\n\nglobal const c_eof     = -1\nglobal const seek_set  = 0\nglobal const seek_curr = 1\nglobal const seek_end  = 2\n\n",
    
(byte*)"!import sys\n!\n!import gxmisc\n!import gxlib\n\nexport var popuplist::=()\nexport var focuslist::=()\nexport var npopups=0\nexport var message\nexport var messw\nexport var wpopup=nil\n\nrecord blockrec=\n\tvar posx, posy\t\t\t\t!pixel position of top left of block: relative to other\n\t\t\t\t\t\t\t\t!blocks, later within client area of containing window\n\tvar dimx,dimy\t\t\t\t!'client' area of block, including margins, cells and gaps\n\tvar celldimx, celldimy\t\t!size of each cell, in pixels\n\tvar cellsx, cellsy\t\t\t!number of identically-svert hoz and vertical controls\n\tvar gapx, gapy\t\t\t\t!gap between cells, in pixels\n\tvar marginx, marginy\t\t!margins around all cells\n\tvar labelwidth\t\t\t\t!for edit boxes, how many pixels on left are for label\n\tvar cellposx,cellposy\t\t!position of top left cell within block\n\tvar pitchx,pitchy\t\t\t!1st cell is at for edit boxes, how many pixels on left are for label\n\tvar blockstyle\t\t\t\t!style record for blocks\n\tvar name\t\t\t\t\t!name for debugging\n\tvar dir\t\t\t\t\t\t!'H' or 'V' for stepping direction\n\nend\n\nvar blocklist::=()\nvar nblocks=0\nvar\tcurrblock =nil\t\t\t\t!current blockrec\nvar\tcurrgroup =nil\t\t\t\t!rwindow corresponding to currblock\nvar\tcurrpopup =nil\t\t\t\t!rwindow for menu to contain current set of blocks\nvar cellx, celly\t\t\t\t!current cell within current block\nvar slposx,slposy,sldir\t\t\t!set by smcreate in case sl-functions are used\n\nproc start=\n!CPL \"-----------SMLIB\"\n!TOGGLETEST()\nend\n\nproc toggletest=\n\n!CPL \"SMLIB TOGGLETEST\"\ngxloadfont(1,\"Arial\",\"I\",20)\ngxloadfont(2,\"COURIER\",\"B\",20)\n\na:=smdefblock(\"X\"*26,6,\"CNR\")\n\na:=smdefblock(\"X\"*26,5,\"\",labeldim:\"*\"*12)\nb:=smdefblock(\"X\"*26,5,\"\",labeldim:\"*\"*12)\nc:=smdefblock(\"X\"*26,5,\"\",labeldim:\"*\"*12)\nd:=smdefblock(\"X\"*10,2)\n\nsmorder((a,b,c,d))\n!smorder((b,c),\"r\")\nsmcreate(\"TOGGLES\",smmenusize())\n\nwa:=smblock(a)\nd1:=\"One\"\nd2:=\"Two\"\nd3:=\"Three\"\nd4:=\"Four\"\nd5:=\"five\"\nwd::=()\n\nwd[1]:=smeditbox(\"Edit d1:\",^d1,211,enable:1)\nwd[2]:=smeditbox(\"Edit d2:\",^d2,212,enable:1)\n!wd[3]:=smeditbox(\"Edit d3:\",^d3,213,enable:1)\n!wd[4]:=smeditbox(\"Edit d4:\",^d4,214,enable:1)\n!wd[5]:=smeditbox(\"Edit d5:\",^d5,215,enable:1)\n!\n\n!wb:=smblock(b)\n!s1:=\"Six\"\n!s2:=\"Seven\"\n!s3:=\"Eight\"\n!s4:=\"Nine\"\n!s5:=\"Ten\"\n!ws:=()\n!\n!ws[1]:=smeditbox(\"Edit s1:\",^s1,221,enable:1)\n!ws[2]:=smeditbox(\"Edit s2:\",^s2,222,enable:1)\n!ws[3]:=smeditbox(\"Edit s3:\",^s3,223,enable:1)\n!ws[4]:=smeditbox(\"Edit s4:\",^s4,224,enable:1)\n!ws[5]:=smeditbox(\"Edit s5:\",^s5,225,enable:1)\n!\n!wc:=smblock(c)\n!t1:=\"XSix\"\n!t2:=\"XSeven\"\n!t3:=\"XEight\"\n!t4:=\"XNine\"\n!t5:=\"XTen\"\n!wt:=()\n!\n!wt[1]:=smeditbox(\"Edit t1:\",^t1,231,enable:1)\n!wt[2]:=smeditbox(\"Edit t2:\",^t2,232,enable:1)\n!wt[3]:=smeditbox(\"Edit t3:\",^t3,233,enable:1)\n!wt[4]:=smeditbox(\"Edit t4:\",^t4,234,enable:1)\n!wt[5]:=smeditbox(\"Edit t5:\",^t5,235,enable:1)\n\n!wbutton:=smcmd(\"Button\",210,0)\n\nsmblock(d)\nwok:=smok(enable:0)\nwcancel:=smcancel()\n\nsetfocus(wd[1])\n\n!gxenable(wtoggle,0)\n!gxenable(wselect1,0)\n!gxenable(wok,0)\n!gxenable(wbutton,0)\n\ndo\n!    gxfocus(wlb)\n\n\tm:=gxaskmess(1)\nCPL \"MESSAGELOOP:\",MESSAGENAMES[CURRMESS.MESSAGE],M,currmess.a,=TOGGLE,=SELECT,=abc\n\n\tcase m\n\twhen mm_pick then\nCPL \"PICK\"\n\t\texit\n\twhen mm_ok then\n\t\texit\n\twhen mm_cancel then\n\t\texit\n!\twhen mm_lbchange then\t\t\t\t!dummy message, allows windex to be updated\n!CPL \"LBCHANGE\"\n\twhen mm_tabkey then\nCPL \"TABKEY\"\n!\t\tgxenable(wtoggle,1)\n\tesac\nod\n\n!$SETDEBUG(1)\n\nsmoff()\n\n\n\nend\n\nproc main=\nCPL \"SMLIB MAIN\"\n!proc start=\n\ntoggletest()\nstop\n\nsminit()\n\nA:=smdefblock(\n\tdim:\"X\"*28,\n\tcells:(1,10),\n\tgap:0,\n\tmargin:10)\nB:=smdefblock(\n\tdim:\"X\"*10,\n\tcells:(1,3)\n)\n\nsmorder((a,b))\nwpopup:=smcreate(\"TEST MENU\",smmenusize())\n!smcreate(\"TEST MENU\",(500,100))\n\nwa:=smblock(a)\n!xx:=0\n!for i to 10 do\n!\tsmtoggle(\"BART\"+tostr(i),^xx)\n!od\nxx:=()\n!for i to 1000 do\nfor i to 130 do\n\txx append:=tostr(i)\nod\n\n!xx:=(\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\")\nwlb:=smlistbox(^xx)\nwlb.style.lbchange:=1\nWLB.NAME:=\"FREDDY\"\n\nSMBLOCK(B)\nSMOK()\nSMCMD(\"HELLO\",201)\n\nNN:=0\ndo\n! \tgxcaption(windex,tostr(wlb.attrs.currpos)+\"/\"+tostr(info.getbounds().len))\n\n    gxfocus(wlb)\n\n\tm:=gxaskmess(1)\n!!CPL =M\nCPL \"MESSAGELOOP:\",MESSAGENAMES[CURRMESS.MESSAGE],M,currmess.a\n\n\tcase m\n\twhen mm_pick then\nCPL \"PICK\"\n\t\tretval:=currmess.a\n\t\texit\n\twhen mm_ok then\n\t\tretval:=gxcurrpos(wlb)\n\t\texit\n\twhen mm_cancel then\n!\t\tsmoff(wpopup)\n\t\tretval:=0\n\t\texit\n\twhen mm_lbchange then\t\t\t\t!dummy message, allows windex to be updated\nCPL \"LBCHANGE\"\n\twhen mm_tabkey then\nCPL \"TABKEY\"\n\tesac\nod\n\n!$SETDEBUG(1)\n\nsmoff()\n\n!EVENTLOOP()\nend\n\n!proc showblockinfo(block)=\n!println \"Block:      \",(block.name.isdef|block.name|\"\")\n!println \"Pos:        \",block.posx,block.posy\n!println \"Dim:        \",block.dimx,block.dimy\n!println \"CellDim:    \",block.celldimx,block.celldimy\n!println \"Gap:        \",block.gapx,block.gapy\n!println \"Cells:      \",block.cellsx,block.cellsy\n!println \"Gaps:       \",block.gapx,block.gapy\n!println \"Margins:    \",block.marginx,block.marginy\n!println \"Labelwidth: \",block.labelwidth\n!println \"Cellpos:    \",block.cellposx,block.cellposy\n!println \"Pitch:      \",block.pitchx,block.pitchy\n!println \"Dir:        \",block.dir\n!println\n!end\n\nexport proc sminit=\nblocklist::=()\nnblocks:=0\n\nend\n\nexport func smdefblock(?dim,cells=1,style=\"\",gap=0,labeldim=\"\",margin=0,dir='V')=\n!define a matrix of cells, all the same size, to be used as controls\n!dim\tis a the size of each cell, as pixel dims, or as a sample string\n!cells\tis a the hoz and vert cell count. Or it can be an int for vert column only\n!gap\tis the inter-cell gap, specified in pixels. Default is to use chx or chy.\n!\t\tgap can be (x,y), or just n for the same gap in hoz and vert\n!style\tCurrently, a string containing various styles and options. Will be\n!\tcompatible with old uses of these functions. Or can be replaced with a dict\n!label\tWhen specified, is a sample string givibg the length of the label on the left\n!\t\tof edit boxes; can also be a pixel width\n!return handle to block\n!also add block to export blocklist\n\nblock:=new(blockrec,0)\nblock.dir:=dir\n!block.dir:='H'\n\nif dim.isstring then\n\tblock.celldimx:=gxtextwidth(labelfont,dim)+smx*2\n\tblock.celldimy:=chy+smy*2\nelse\n\t(block.celldimx,block.celldimy):=dim\nfi\n\nif cells.isint then\n\tblock.cellsx:=1\n\tblock.cellsy:=cells\nelse\n\t(block.cellsx,block.cellsy):=cells\nfi\n\nif gap.isint then\n\tblock.gapx:=gap\n\tblock.gapy:=gap\nelse\n\t(block.gapx,block.gapy):=gap\nfi\n\nif margin.isint then\n\tblock.marginx:=margin\n\tblock.marginy:=margin\nelse\n\t(block.marginx,block.marginy):=margin\nfi\n\nif labeldim then\n\tif labeldim.isstring then\n\t\tblock.labelwidth:=gxtextwidth(labelfont,labeldim)+smx*2\n\telse\n\t\tblock.labelwidth:=labeldim\n\tfi\n\tblock.celldimx+:=block.labelwidth\nfi\n\nblock.blockstyle:=readstylestr(style)\n\n!CPL \"BLOCKSTYLE\",STYLE,BLOCK.BLOCKSTYLE\n\n!now work out overall size of the block, and the pitch between cells\n!this needs to take account of the frame size of each cell, which depends on\n!its border style\n!block position is done at a higher level using smorder\n\nbdx:=bdy:=1\t\t\t\t!use border widths of 0 for now (and assume same all round)\n\nblock.pitchx:=block.celldimx+bdx*2+block.gapx\t\t!hoz pitch\nblock.pitchy:=block.celldimy+bdy*2+block.gapy\t\t!vert\n\n!CPL \"PITCHY\",BLOCK.PITCHY,=BDY,=BLOCK.GAPY\n!CPL \"MARGINY\",BLOCK.MARGINY\n\nblock.cellposx:=block.marginx+bdx\t\t\t\t\t!position of client area of 1st cell\nblock.cellposy:=block.marginy+bdy\n\nblock.dimx:=block.pitchx*block.cellsx-block.gapx+block.marginx*2\nblock.dimy:=block.pitchy*block.cellsy-block.gapy+block.marginy*2\n\nblocklist[++nblocks]:=block\n\nreturn block\nend\n\nexport func smmenusize(margin=chy)=\n!work out overall bounding box for all blocks, and relocate blocks (or set their\n!pos values) so that each is positioned within to the bounding box rectangle\n!return (dimx,dimy)\n\n!get bounding box in (x1,y1), (x2,y2)\nforall i,block in blocklist do\n\tif i=1 then\t\t\t\t!first block\n\t\tx1:=block.posx\n\t\ty1:=block.posy\n\t\tx2:=x1+block.dimx-1\n\t\ty2:=y1+block.dimy-1\n\telse\n\t\tx1 min:=block.posx\n\t\ty1 min:=block.posy\n\t\tx2 max:=block.posx+block.dimx-1\n\t\ty2 max:=block.posy+block.dimy-1\n\tfi\nod\n\n!now, need to relocate each block so they stay at the same position relative to\n!each other, but are positioned within the client area of an owner window\n!this effectively relocates (x1,y1) to (0,0), so the offset to be applied to\n!each block is -(x1,y1), plus (margin,margin)\n\nforall block in blocklist do\n\tblock.posx+:=margin-x1\n\tblock.posy+:=margin-y1\nod\n\n!return (x1-margin,y1-margin,x2-y1+margin*2+1,y2-y1+margin*2+1)\nreturn (x2-x1+margin*2+1,y2-y1+margin*2+1)\nend\n\nexport proc smorder(blocks,dir='D')=\n!take a blocks, and arrange all in a line, relative to the first\n!dir is one of \"U\", \"D\", \"L\", \"R\" (or can be char codes or in lower case)\n!some block elements can be an integer specifing a gap between the blocks.\n!the gap is specified in pixels. The default gap is chx for hoz and chy for vertical\n!(***I THINK that the gap override is only between two blocks, so needs the reset to\n!default after. That mean also that the first list item must be a block***)\n\nif dir.isstring then\n\tdir:=asc(convuc(dir))\t\t\t!\"r\",\"R\" or 'R' possible, but not 'r'\nfi\n\nbdx:=bdy:=1\t\t\t\t\t\t!border widths for the blocks\n\ndx:=chx+bdx\ndy:=chy+bdy\nfirstblock:=1\n\nforall block in blocks do\n\tif block.isint then\t\t\t!is a gap\n\t\tdx:=block+bdx*2\n\t\tdy:=block+bdy*2\n\t\tnext\n\tfi\n\tif firstblock then\n\t\tlastblock:=block\n\t\tfirstblock:=0\n\t\tnext\n\tfi\n\tcase dir\n\twhen 'D' then\t\t\t!add below\n\t\tblock.posx:=lastblock.posx\n\t\tblock.posy:=lastblock.posy+lastblock.dimy+dy\n\twhen 'R' then\n\t\tblock.posx:=lastblock.posx+lastblock.dimx+dx\n\t\tblock.posy:=lastblock.posy\n\twhen 'U' then\t\t\t!add above\n\t\tblock.posx:=lastblock.posx\n\t\tblock.posy:=lastblock.posy-block.dimy-dy\n\twhen 'L' then\n\t\tblock.posx:=lastblock.posx-block.dimx-dx\n\t\tblock.posy:=lastblock.posy\n\tesac\n\tlastblock:=block\nod\nend\n\nproc showtestmenu(dim)=\n\nwapplic:=gxcreatewindow(dim:dim,caption:\"test\")\n\nforall block in blocklist do\n\tgxbutton(pos:(block.posx,block.posy),dim:(block.dimx,block.dimy),caption:block.name,\n\towner:wapplic,style:[ss_border:bs_simplew])\nod\n\neventloop()\n\nend\n\nexport func smcreate(caption=\"\",?dim,?pos)=\n!create a pop-up menu window\n!dim ix (x,y) client area size in pixels\n!?pos is optional position, but can also existing button, then menu is placed nearby\n!Normally used after after series of smdefblock etc calls to setup a menu layout\n!Dim usually is a call to smmenusize which exactly contains the blocks\n!return handle to window\n\n!CPL \"SMCREATE\"\n\nw:=gxcreatewindow(caption:caption, dim:dim, options:[wf_minmax:0],pos:pos)\n!w:=gxcreatewindow(caption:caption, dim:dim)\nw.windclass:=popup_class\ncurrpopup:=w\n\nslposx:=chx\nslposy:=chy\nsldir:=(dim[1]>dim[2]|'H'|'V')\n\nwpopup:=w\n\noldfocus:=wfocus\nif wfocus then\n\tgxkillfocus()\nfi\n\npopuplist[++npopups]:=w\nfocuslist[npopups]:=oldfocus\t\t!of underlying window\n\nreturn w\nend\n\nexport func smblock(block,border=0)=\n!set block as the current block for subsequent \n!unlike old versions of the library, an actual window is created for the block,\n!and a handle to that is returned. That is a child group control.\n\ncase border\nwhen 0 then\tbord:=bs_none\nwhen 1 then\tbord:=bs_simple\nwhen 2 then\tbord:=bs_panel\nelse\n\tbord:=bs_none\nesac\n\nwblock:=gxgroup(pos:(block.posx,block.posy),dim:(block.dimx,block.dimy),\n!\t\towner:currpopup, style:[ss_border:bs_none])\n\t\towner:currpopup, style:[ss_border:bord])\ncurrblock:=block\ncurrgroup:=wblock\ncellx:=celly:=1\n\nreturn wblock\nend\n\nexport proc smclose=\n!NOTE: for nested menus, ie. invoking another popup menu while one is still\n!on the screen, requires:\n! * blocklist needs to be moved elsewhere, eg. to data field of current popup rwindow\n! * Then smclose can close blocks in that list, not the export one\n! * Global blocklist can be reused\n! * It might require that the owner window is disabled from being clicked on, but\n!   that will be awkward to do without disabling each control within it. Or perhaps\n!   this is a check that can be done within process_wmmessage, to see if click-window\n!   has an owner that has been disabled.\n!    Disabling is one with smcreate, and re-enableing here in smclose\n\ngxclose(wpopup)\n!forall block in blocklist do\n!\tblock:=0\n!!\tfreehandle(block)\n!od\n\noldfocus:=focuslist[npopups]\n--npopups\nif npopups then\n\twpopup:=popuplist[npopups]\n\tif oldfocus then\n\t\tgxfocus(oldfocus)\n\tfi\nelse\n\twpopup:=nil\nfi\nend\n\nexport proc smoff=\nsmclose()\nend\n\nproc nextcell=\n!step cellx,y to next cell within current block\nif currblock.dir='V' then\n\t++celly\n\tif celly>currblock.cellsy then\n\t\tcelly:=1\n\t\t++cellx\n\tfi\nelse\t\t\t\t\t!hoz\n\t++cellx\n\tif cellx>currblock.cellsx then\n\t\tcellx:=1\n\t\t++celly\n\tfi\nfi\nend\n\nfunc getsmpos=\nreturn ((cellx-1)*currblock.pitchx+currblock.cellposx,\n        (celly-1)*currblock.pitchy+currblock.cellposy)\nend\n\nfunc getsmdim=\nreturn (currblock.celldimx,currblock.celldimy)\nend\n\nfunc getslpos=\nreturn (slposx,slposy)\nend\n\nfunc getsldim(s)=\nif s.isint then\n\treturn (s*chx+chx*2,chy+smy*2)\nelse\n\treturn (gxtextwidth(labelfont,s)+smx*2,chy+smy*2)\nfi\nend\n\nproc nextslcell(dim)=\nif sldir='H' then\n\tslposx+:=dim[1]+chx\nelse\n\tslposy+:=dim[2]+chy\nfi\nend\n\nexport func smcmd(caption,id=0,enable=1)=\n!create button within current block\n!caption can also be an integer code:\n! 0\t\tskip this cell (just leave a blank space)\n! -1\tinsert divider line\n!when id is omitted or is zero, then creates a static label instead\n\n!CPL \"SMCMD\",CAPTION,ID\n\nif caption.isint then\n\tcase caption\n\twhen 0 then\n\twhen -1 then\n\tesac\n\tnextcell()\n\treturn nil\nfi\n\nif id=0 then\n\treturn smlabel(caption)\nfi\n\npos:=getsmpos()\ndim:=(currblock.celldimx,currblock.celldimy)\nss:=[ss_border:bs_simplew]\n\nw:=gxbutton(pos:pos,dim:dim,caption:caption,id:id,owner:currgroup, \n\tstyle:ss, enable:enable)\nnextcell()\nreturn w\nend\n\nexport func smlabel(caption)=\npos:=getsmpos()\ndim:=(currblock.celldimx,currblock.celldimy)\n\nw:=gxlabel(pos:pos,dim:dim,caption:caption,owner:currgroup)\nnextcell()\nreturn w\nend\n\nexport func smarrow(dir,id)=\npos:=getsmpos()\ndim:=(currblock.celldimx,currblock.celldimy)\n\nw:=gxarrow(pos:pos,dim:dim,dir:dir,owner:currgroup)\nnextcell()\nreturn w\nend\n\nexport func smtoggle(caption,linkvar,id=0,enable=1)=\n!create toggle control within current block\n\nw:=gxtoggle(pos:getsmpos(), dim:getsmdim(), caption:caption,\n\t\t\tlinkvar:linkvar,id:id,owner:currgroup, enable:enable,\n\t\t\tstyle:currblock.blockstyle)\n!style:[ss_marktype:radio_mark])\n!style:[ss_marktype:check_mark])\n!style:[ss_marktype:bold_mark])\n\n!\t(radio_mark,\t\t$),\n!\t(tick_mark,\t\t\t$),\n!\t(check_mark,\t\t$),\n!\t(invert_mark,\t\t$),\n!\t(outline_mark,\t\t$),\n!\t(bold_mark,\t\t\t$),\n\nnextcell()\nreturn w\nend\n\nexport func smselect(caption,linkvar,onvalue=1,id=0,enable=1)=\n!create toggle control within current block\n\nw:=gxselect(pos:getsmpos(), dim:getsmdim(), caption:caption,\n\t\t\tlinkvar:linkvar,onvalue:onvalue,\n\t\t\tid:id,owner:currgroup, enable:enable, style:currblock.blockstyle)\n\nnextcell()\nreturn w\nend\n\nexport func smeditbox(?caption,linkvar,id=0,enable=1,?style)=\n!create toggle control within current block\n\npos:=getsmpos()\ndim:=getsmdim()\n\nif caption.isdef then\n\tgxlabel(pos:pos, dim:(currblock.labelwidth-chx,dim[2]), caption:caption,\n\t owner:currgroup)\n\tpos[1]+:=currblock.labelwidth\n\tdim[1]-:=currblock.labelwidth\nfi\n\nw:=gxeditbox(pos:pos, dim:dim,\n\t\t\tlinkvar:linkvar,\n\t\t\tid:id,owner:currgroup, enable:enable, style:getstyle(style))\n!gxdrawmode(w,dm_screenmemory)\n\nnextcell()\nreturn w\nend\n\nexport func smlistbox(linkvar,id=0,enable=1)=\n\n!CPL =CURRBLOCK.CELLSY,\"(ROWS)\"\n!CPL =CURRBLOCK.PITCHY,\"(PITCH)\"\n!CPL =CURRBLOCK.CELLDIMY,\"(CELLDIMY)\"\n!CPL =CURRBLOCK.CELLPOSY,\"(OFFSET)\"\n!CPL =CURRBLOCK.GAPY,\"(GAPY)\"\n!CPL =CURRBLOCK.DIMY,\"(DIMY)\"\n!CPL \"LBDIMY=\",CURRBLOCK.DIMY-CURRBLOCK.MARGINY*2\n!CPL =CURRBLOCK.MARGINY\n\nCPL \"SMLB1\"\n!$SETDEBUG(1)\nw:=gxlistbox(pos:getsmpos(),\n\tdim:(currblock.dimx-currblock.marginx*2,currblock.dimy-currblock.marginy*2),\n\tlinkvar:linkvar,\n\tstyle:[ss_vscroll:1,\n\tss_border:bs_simplew],\n\trows:currblock.cellsy,\n\tpitch:currblock.pitchy,\n!\toffset:currblock.cellposy,\n\tid:id,owner:currgroup)\nCPL \"SMLB2\"\nreturn w\nend\n\nexport func sllabel(caption)=\npos:=getslpos()\ndim:=getsldim(caption)\n\nw:=gxlabel(pos:pos,dim:dim,caption:caption,owner:currpopup)\nnextslcell(dim)\nreturn w\nend\n\nexport func slcmd(caption,id=201,enable=1)=\n!create button within current block\n!caption can also be an integer code:\n! 0\t\tskip this cell (just leave a blank space)\n! -1\tinsert divider line\n!when id is omitted or is zero, then creates a static label instead\n\npos:=getslpos()\ndim:=getsldim(caption)\nss:=[ss_border:bs_simplew]\n\nw:=gxbutton(pos:pos,dim:dim,caption:caption,id:id,owner:currpopup, \n\tstyle:ss)\nnextslcell(dim)\nreturn w\nend\n\nexport func sleditbox(linkvar,width=30,id=0,enable=1)=\npos:=getslpos()\ndim:=getsldim(width)\n\nw:=gxeditbox(pos:pos, dim:dim,\n\t\t\tlinkvar:linkvar,\n\t\t\tid:id,owner:currpopup)\n\nnextslcell(dim)\nreturn w\nend\n\nexport func smok(caption=\"OK\",enable=1)=\nreturn smcmd(caption,mm_ok,enable)\nend\n\nexport func smcancel(caption=\"Cancel\",enable=1)=\nreturn smcmd(caption,mm_cancel,enable)\nend\n\nexport func slok(caption=\"OK\")=\nreturn slcmd(caption,mm_ok)\nend\n\nexport func slcancel(caption=\"Cancel\")=\nreturn slcmd(caption,mm_cancel)\nend\n\nexport proc smokcancel=\nsmok()\nsmcancel()\nend\n\nexport proc slinit(w)=\ncurrpopup:=w\nslposx:=chx\nslposy:=0\nsldir:=(w.dimx>w.dimy|'H'|'V')\nend\n\nexport func smerror(mess) =\n!a:=b+c\n!println \"Unimplemented SM/CCI function:\", mess\npcerror(\"Unimplemented SM/CCI function: \"+mess+\"\\n\\n\\n\")\nprintln\nprintln\nprintln\nstop\nreturn 0\nend\n\nexport proc settab(?a,?b,?c,?d,?e,?f,?g,?h,?i)=\nstatic var oldtabs\n\nif not a.defined then\n\tgxtabstops(oldtabs)\n\treturn\nfi\n\noldtabs:=gxtabstops()\nparams::=allparams()\n\n!gxtabstops(allparams())\ngxtabstops(param)\nend\n\nexport proc smupdatevalue(w)=\ngxupdate(w)\nend\n\nexport proc setfocus(w,?b)= gxfocus(w) end\n\nexport proc askmenu(a)=\nmessage:=gxaskmess(1)\nmessw:=currmess.wind\nend\n\nfunc readstylestr(s)=\n!read cell style string s, and return option dict\nd:=new(dict)\nif s=\"\" then return d fi\n\ns:=convuc(s)\n\nforeach c in s do\n\tcase c\n\twhen 'X' then d{ss_marktype}:=check_mark\n\twhen 'M' then d{ss_marktype}:=radio_mark\n\twhen 'I' then d{ss_marktype}:=invert_mark\n\twhen 'R' then d{ss_returnmess}:=1\n\twhen 'N' then d{ss_noupdate}:=1\n\tesac\nod\nreturn d\nend\n\nfunc getstyle(style)=\nif style.defined then\n\treturn readstylestr(style)\nelse\n\treturn currblock.blockstyle\nfi\n\nend\n\nexport func smmark(a,b,c)= return smerror($function) end\nexport func smcheck(?a,?b,?c,?d,?e)= return smerror($function) end\nexport func smmenu(?a)= return smerror($function) end\nexport func smshowmenu(a,?b,?c,?d)= return smerror($function) end\nexport func smdown= return smerror($function) end\nexport func smup= return smerror($function) end\nexport func smleft= return smerror($function) end\nexport func smright= return smerror($function) end\nexport func smedit(a,b,c,?d)= return smerror($function) end\n!export func smoff= return smerror($function) end\nexport func smbutton(a,b)= return smerror($function) end\nexport func smstartmenu(a)= return smerror($function) end\nexport func smsize(a)= return smerror($function) end\n\n\n",
    
(byte*)"\nexport type wt_word\t\t= word16\nexport type wt_bool\t\t= word32\nexport type wt_dword\t= word32\nexport type wt_wchar\t= word16\nexport type wt_char\t\t= byte\nexport type wt_ichar\t= stringz\nexport type wt_string\t= stringz\nexport type wt_ptr\t\t= ref byte\nexport type wt_wndproc\t= word64\n\nexport type wt_handle\t= ref void\nexport type wt_int\t\t= int32\nexport type wt_uint\t\t= word32\nexport type wt_long\t\t= int32\nexport type wt_wparam\t= word64\nexport type wt_lparam\t= word64\nexport type wt_size\t\t= word64\n\nexport type wt_wparam32\t= word32\nexport type wt_lparam32\t= word32\nexport type wt_handle32\t= word32\nexport type wt_ptr32\t= word32\nexport type wt_string32\t= word32\nexport type wt_wndproc32\t= word32\n\nexport type wt_wparam64\t= word64\nexport type wt_lparam64\t= word64\nexport type wt_handle64\t= word64\nexport type wt_ptr64\t= word64\nexport type wt_string64\t= word64\nexport type wt_wndproc64= word64\n\nexport type wt_result\t= word64\nexport type wt_intptr\t= word64\nexport type wt_coord\t= word32\n\nexport type ws_spoint= struct\n\tint16 x,y\nend\n\nexport type ws_srect=struct\n\tint16 leftx,top, rightx,bottom\nend\n\nexport type ws_charinfo=struct\n\tunion\n\t\twt_word\tunicodechar\n\t\twt_char\tasciichar\n\tend union\n\twt_word\t\tattributes\nend\n\nexport type ws_palette16=[0..15]int32\n\nexport type ws_console=struct\n\tws_spoint size,pos\n\twt_word attributes\n\tws_srect window\n\tws_spoint maxwindowsize\nend\n\nexport type ws_consoleex=struct\n\tint32 recsize\n\tws_spoint size,pos\n\twt_word attributes\n\tws_srect window\n\tws_spoint maxwindowsize\n\twt_word wpopup\n\tint32 fullscreen\n\tws_palette16 palette\nend\n\nexport type ws_keyevent = struct $caligned\n\twt_word\teventtype\n\t\twt_bool\tkeydown\n\t\twt_word\trepeatcount\n\t\twt_word\tvirtualkeycode\n\t\twt_word\tvirtualscancode\n\t\tunion\n\t\t\twt_word unicodechar\n\t\t\twt_char asciichar\n\t\tend\n\t\twt_dword controlkeystate\nend\n\nexport type ws_cursor=struct(int32 size,visible)\n\nexport var hconsole, hconsolein\n\nexport const stdoutputhandle=0xffff_fff5\nexport const stdinputhandle=0xfffffff6\nexport const stderrorputhandle=0xfffffff4\nexport const invalidhandlevalue=0xffffffff\n\nexport const maxpathlen=260\n\ntype spath=stringz*maxpathlen\ntype sshort=stringz*14\n!\nexport type ws_filetime=struct\n\tint32 ftlow\n\tint32 fthigh\nend\n\nexport type ws_finddata=struct\n\tint32\t\tfileattributes\n\tws_filetime\tcreationtime\n\tws_filetime\tlastaccesstime\n\tws_filetime\tlastwritetime\n\tint32\t\tfilesizehigh\n\tint32\t\tfilesizelow\n\tint32\t\treserved0\n\tint32\t\treserved1\n\tspath\t\tfilename\n\tsshort\t\tshortfilename\nend\n\nexport type ws_systemtime = struct\n\tword16\tyear\n\tword16\tmonth\n\tword16\tdayofweek\n\tword16\tday\n\tword16\thour\n\tword16\tminute\n\tword16\tsecond\n\tword16\tmilliseconds\nend\n\nexport type ws_msg64 = struct $caligned\n\tref void\thwnd\n\tint32\t\tmessage\n\tint64\t\twparam\n\tint64\t\tlparam\n\tint32\t\ttime\n\tint32\t\tptx\n\tint32\t\tpty\nend\n\nexport type ws_point = struct\n\tint32 x, y\nend\n\nexport type ws_rect=struct\t\t!rect record occupying 16 bytes\n\tunion\n\t\tstruct\n\t\t\tint32 leftx,top, rightx,bottom\n\t\tend\n\t\tstruct\n\t\t\tunion int32 x,x1 end\n\t\t\tunion int32 y,y1 end\n\t\t\tint32 x2,y2\n\t\tend\n\tend\nend\n\nexport type ws_logbrush = struct\n\tint32 lbstyle\n\tint32 lbcolour\n\tint32 lbhatch\nend\n\nexport type ws_textmetrics = struct\n\tint32\theight\n\tint32\tascent\n\tint32\tdescent\n\tint32\tint32ernalleading\n\tint32\texternalleading\n\tint32\tavecharwidth\n\tint32\tmaxcharwidth\n\tint32\tweight\n\tint32\toverhang\n\tint32\tdigitizedaspectx\n\tint32\tdigitizedaspecty\n\tbyte\tfirstchar\n\tbyte\tlastchar\n\tbyte\tdefaultchar\n\tbyte\tbreakchar\n\tbyte\titalic\n\tbyte\tunderlined\n\tbyte\tstruckout\n\tbyte\tpitchandfamily\n\tbyte\tcharset\nend\n!=========================================\n\nexport type ws_bitmapv5header = struct\n\tint32\tsize\n\tint32\twidth\n\tint32\theight\n\tword16\tplanes\n\tword16\tbitcount\n\tint32\tcompression\n\tint32\tsizeimage\n\tint32\txpelspermeter\n\tint32\typelspermeter\n\tint32\tclrused\n\tint32\tclrimportant\n\tint32\tredmask\n\tint32\tgreenmask\n\tint32\tbluemask\n\tint32\talphamask\n\tint32\tcstype\n\t[1..9]int32 endpoints\n\tint32\tredgamma\n\tint32\tgreengamma\n\tint32\tbluegamma\n\tint32\tintent\n\tint32\tprofiledata\n\tint32\tprofilesize\n\tint32\treserved\nend\n\nexport type ws_bitmapfileheader = struct\n\twt_word\t\ttypex\n\twt_dword\tsize\n\twt_word\t\tres1, res2\n\twt_dword\toffbits\nend\n\nexport type ws_bitmapinfoheader = struct\n\twt_dword \tsize\n\twt_long\t\twidth\n\twt_long\t\theight\n\twt_word\t\tplanes\n\twt_word\t\tbitcount\n\twt_dword\tcompression\n\twt_dword\tsizeimage\n\twt_long\t\txpelspermetre\n\twt_long\t\typelspermetre\n\twt_dword\tclrused\n\twt_dword\tclrimportant\nend\n\nexport type ws_paintstruct = struct\n!\tint64\t\thdc\n\tint64\t\thdc\n\tint32\t\terase\n\tws_rect\t\tpaintrect\n\tint32\t\trestore\n\tint32\t\tincupdate\n\t[32]byte\trgbreserved\nend\n\n!32-BIT VERSION\nexport type ws_openfilename32 = struct\n\twt_dword\t\tstructsize\n\twt_handle32\t\towner\n\twt_handle32\t\tinstance\n\twt_string32\t\tfilter\n\twt_string32\t\tcustomfilter\n\twt_dword\t\tmaxcustfilter\n\twt_dword\t\tfilterindex\n\twt_string32\t\tfile\n\twt_dword\t\tmaxfile\n\twt_string32\t\tfiletitle\n\twt_dword\t\tmaxfiletitle\n\twt_string32\t\tinitialdir\n\twt_string32\t\ttitle\n\twt_dword\t\tflags\n\twt_word\t\t\tfileoffset\n\twt_word\t\t\tfileextension\n\twt_string32\t\tdefext\n\twt_lparam32\t\tcustdata\n\twt_wndproc32\thook\n\twt_string32\t\ttemplatename\n\twt_ptr32\t\treserved1\n\twt_dword\t\treserved2\n\twt_dword\t\tflagsex\nend\n\n!64-BIT VERSION\nexport type ws_openfilename64 = struct $caligned\n\twt_dword\t\tstructsize\n\twt_handle64\t\towner\n\twt_handle64\t\tinstance\n\twt_string64\t\tfilter\n\twt_string64\t\tcustomfilter\n\twt_dword\t\tmaxcustfilter\n\twt_dword\t\tfilterindex\n\twt_string64\t\tfile\n\twt_dword\t\tmaxfile\n\twt_string64\t\tfiletitle\n\twt_dword\t\tmaxfiletitle\n\twt_string64\t\tinitialdir\n\twt_string64\t\ttitle\n\twt_dword\t\tflags\n\twt_word\t\t\tfileoffset\n\twt_word\t\t\tfileextension\n\twt_string64\t\tdefext\n\twt_lparam64\t\tcustdata\n\twt_wndproc64\thook\n\twt_string64\t\ttemplatename\n\twt_ptr64\t\treserved1\n\twt_dword\t\treserved2\n\twt_dword\t\tflagsex\nend\n\nimportdll kernel32=\n\twindows func\t\"GetLastError\"\t\t\t\t\t:wt_dword\n\twindows func\t\"GetStdHandle\"\t\t\t\t\t(wt_dword)wt_handle\n\twindows func\t\"WriteConsoleA\" as writeconsole\t\t\t\t(wt_handle,wt_string,wt_dword,wt_ptr,wt_ptr)wt_bool\n\twindows func\t\"SetConsoleCursorPosition\"\t\t(wt_handle,wt_coord)wt_bool\n\twindows func\t\"GetConsoleScreenBufferInfo\"\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"SetConsoleMode\"\t\t\t\t(wt_handle,wt_dword)wt_bool\n\twindows func\t\"WriteConsoleOutputA\" as writeconsoleoutput\t\t\t(wt_handle,wt_ptr,wt_coord,wt_coord,wt_ptr)wt_bool\n\n\twindows func\t\"GetConsoleScreenBufferInfoEx\"\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"SetConsoleScreenBufferInfoEx\"\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"GetConsoleWindow\"\t\t\t\t:wt_handle\n\n\twindows func\t\"SetConsoleTextAttribute\"\t\t(wt_handle,wt_word)wt_bool\n\twindows func\t\"SetConsoleTitleA\" as setconsoletitle\t\t\t\t(wt_string)wt_bool\n\twindows func\t\"ReadConsoleInputA\" as readconsoleinput\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr)wt_bool\n\twindows func\t\"PeekConsoleInputA\"\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr)wt_bool\n\twindows func\t\"FlushConsoleInputBuffer\"\t\t(wt_handle)wt_bool\n\twindows func\t\"SetConsoleWindowInfo\"\t\t\t(wt_handle,wt_bool,wt_ptr)wt_bool\n\twindows func\t\"SetConsoleScreenBufferSize\"\t(wt_handle,wt_coord)wt_bool\n\twindows func\t\"GetConsoleCursorInfo\"\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"SetConsoleCursorInfo\"\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"GetNumberOfConsoleInputEvents\"(wt_handle,wt_ptr)wt_bool\n\n\twindows func\t\"FindFirstFileA\" as findfirstfile\t\t(stringz,ref int32)int32\n\twindows func\t\"FindNextFileA\"  as findnextfile\t\t\t(int32,ref int32)int32\n\twindows func\t\"FindClose\"\t\t\t\t\t(int32)int32\n\twindows func\t\"SetCurrentDirectoryA\" as setcurrentdirectory\t(stringz)int32\n\twindows func\t\"GetCurrentDirectoryA\" as getcurrentdirectory\t(int32,int32)int32\n\twindows func\t\"CreateDirectoryA\" as createdirectory\t\t(stringz,int32)int32\n\twindows func\t\"GetFileAttributesA\"\t\t\t(stringz)int32\n\twindows func\t\"GetModuleHandleA\" as getmodulehandle\t\t(wt_string)wt_handle\n\twindows func\t\"GetTickCount\"\t\t\t\t\t\t\t\t:wt_dword\n\twindows func\t\"GlobalAlloc\"\t\t\t\t\t\t\t\t\t(wt_uint,wt_size)wt_handle\n\twindows func\t\"GlobalLock\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_ptr\n\twindows func\t\"GlobalUnlock\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\twindows func\t\"GlobalSize\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_size\n\n\twindows func\t\"GetSystemTime\"(ref byte)int32\n\twindows func\t\"Beep\"\t\t\t\t\t\t\t(wt_dword, wt_dword)wt_bool\n\twindows func\t\"SetConsoleCP\"\t\t\t\t\t\t\t\t(wt_uint)wt_bool\nend\n\nimportdll user32=\n\twindows func\t\"CreateWindowExA\" as createwindowex\t\t(wt_dword, wt_string, wt_string, wt_dword, wt_int,wt_int,wt_int,wt_int,\n\t\t\t\t\t\t\t\t\t\t\t\t\t wt_handle, wt_handle, wt_handle, wt_ptr)wt_handle\n\n\twindows func\t\"GetMessageA\" as getmessage\t\t\t\t(wt_ptr, wt_handle, wt_uint, wt_uint)wt_bool\n\twindows func\t\"TranslateMessage\"\t\t\t\t\t\t(wt_ptr)wt_bool\n\twindows func\t\"DispatchMessageA\" as dispatchmessage\t\t(wt_ptr)wt_result\n\twindows func\t\"SetTimer\"\t\t\t\t\t\t\t\t(wt_handle,wt_intptr,wt_uint,wt_ptr)wt_intptr\n\twindows func\t\"KillTimer\"\t\t\t\t\t\t\t\t(wt_handle,wt_intptr)wt_bool\n\twindows func\t\"SystemParametersInfoA\"\t\t\t\t\t(wt_uint,wt_uint,wt_ptr,wt_uint)wt_bool\n\twindows func\t\"GetSystemMetrics\"\t\t\t\t\t\t(wt_int)wt_int\n!\twindows func\t\"CreateMenu\"\t\t\t\t\t\t\t\t:int\n\twindows func\t\"AppendMenuA\" as appendmenu\t\t\t\t(wt_handle,wt_uint,wt_intptr,wt_string)wt_bool\n\twindows func\t\"GetDC\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_handle\n\twindows func\t\"ReleaseDC\"\t\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_int\n\n\twindows func\t\"SendMessageA\" as sendmessage\t\t\t\t(wt_handle,wt_uint,wt_wparam,wt_lparam)wt_result\n\twindows func\t\"PostMessageA\" as postmessage\t\t\t\t(wt_handle,wt_uint,wt_wparam,wt_lparam)wt_bool\n\twindows func\t\"PeekMessageA\" as peekmessage\t\t\t\t(wt_ptr,wt_handle,wt_uint,wt_uint,wt_uint)wt_bool\n\twindows func\t\"BeginPaint\"\t\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_handle\n\twindows func\t\"EndPaint\"\t\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows procedure\t\"PostQuitMessage\"\t\t\t\t\t(wt_int)\n\twindows func\t\"LoadIconA\" as loadicon\t\t\t\t\t(wt_handle,wt_string)wt_handle\n\twindows func\t\"LoadCursorA\" as loadcursor\t\t\t\t(wt_handle,wt_string)wt_handle\n\twindows func\t\"SetCursor\"\t\t\t\t\t\t\t\t(wt_handle)wt_handle\n\twindows func\t\"DrawMenuBar\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\twindows func\t\"GetSystemMenu\"\t\t\t\t\t\t\t(wt_handle,wt_bool)wt_handle\n\twindows func\t\"CreateMenu\"\t\t\t\t\t\t\t\t:wt_handle\n\twindows func\t\"CreatePopupMenu\"\t\t\t\t\t\t\t:wt_handle\n\twindows func\t\"DestroyMenu\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\twindows func\t\"CheckMenuItem\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_dword\n\twindows func\t\"EnableMenuItem\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\n\twindows func\t\"GetSubMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_handle\n\twindows func\t\"GetMenuItemID\"\t\t\t\t\t\t\t(wt_handle,wt_int)wt_uint\n\twindows func\t\"GetMenuItemCount\"\t\t\t\t\t\t(wt_handle)wt_int\n\twindows func\t\"InsertMenuA\" as insertmenu\t\t\t\t(wt_handle,wt_uint,wt_uint,wt_intptr,wt_string)wt_bool\n\twindows func\t\"ModifyMenuA\" as modifymenu\t\t\t\t(wt_handle,wt_uint,wt_uint,wt_intptr,wt_string)wt_bool\n\twindows func\t\"RemoveMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\n\twindows func\t\"DeleteMenu\"\t\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_bool\n\n\twindows func\t\"DestroyWindow\"\t\t\t\t\t\t\t(wt_handle)wt_bool\n\twindows func\t\"InvalidateRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_bool)wt_bool\n\twindows func\t\"ValidateRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"ShowWindow\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_bool\n\twindows func\t\"GetClassLongA\" as getclassint\t\t\t(wt_handle,wt_int)wt_word\n\twindows func\t\"SetClassLongA\" as setclasslong\t\t\t(wt_handle,wt_int,wt_dword)wt_word\n\twindows func\t\"SetWindowTextA\" as setwindowtext\t\t\t(wt_handle,wt_string)wt_bool\n\twindows func\t\"GetWindowTextA\" as getwindowtext\t\t\t(wt_handle,wt_string,wt_int)wt_int\n\twindows func\t\"GetWindowTextLengthA\" as getwindowtextlength\t(wt_handle)wt_int\n\twindows func\t\"GetKeyState\"\t\t\t\t\t\t\t\t(wt_int)wt_word\n\n!\twindows func\t\"GetWindowLongPtrA\" as getwindowlongptr\t(wt_handle,wt_int)int64\n!\twindows func\t\"SetWindowLongPtrA\" as setwindowlongptr\t(wt_handle,wt_int,wt_int)int64\n\twindows func\t\"GetWindowLongA\" as getwindowlongptr\t\t(wt_handle,wt_int)int64\n\twindows func\t\"SetWindowLongA\" as setwindowlongptr\t\t(wt_handle,wt_int,int64)int64\n\n\twindows func\t\"GetClientRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"ClientToScreen\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"ScreenToClient\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"GetWindowRect\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"GetSysColor\" as getsyscolour\t\t\t\t(wt_int)wt_dword\n\twindows func\t\"GetScrollInfo\"\t\t\t\t\t\t\t(wt_handle,wt_int,wt_ptr)wt_bool\n\twindows func\t\"GetMenu\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_handle\n\twindows func\t\"SetMenu\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_ptr\n\twindows func\t\"TrackPopupMenu\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_int,wt_int,wt_int,wt_handle,wt_ptr)wt_bool\n\twindows func\t\"GetMenuState\"\t\t\t\t\t\t\t(wt_handle,wt_uint,wt_uint)wt_uint\n\twindows func\t\"MessageBoxA\" \\\n\t\t\t\t\t\t\t\t(wt_handle a=nil,wt_string message, wt_string caption=\"Caption\", wt_uint b=0)wt_int\n\twindows func\t\"OpenClipboard\"\t\t\t\t\t\t\t(wt_handle)wt_bool\n\twindows func\t\"CloseClipboard\"\t\t\t\t\t\t\t:wt_bool\n\twindows func\t\"EmptyClipboard\"\t\t\t\t\t\t\t:wt_bool\n\twindows func\t\"GetClipboardData\"\t\t\t\t\t\t(wt_uint)wt_handle\n\twindows func\t\"SetClipboardData\"\t\t\t\t\t\t(wt_uint,wt_handle)wt_handle\n\twindows func\t\"MessageBeep\"\t\t\t\t\t\t\t(wt_uint x=0)wt_bool\nend\n\nimportdll gdi32=\n\twindows func\t\"Rectangle\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int)wt_bool\n\twindows func\t\"RoundRect\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\twindows func\t\"Ellipse\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int)wt_bool\n\twindows func\t\"Arc\"\t\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\twindows func\t\"Chord\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\twindows func\t\"Pie\"\t\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int)wt_bool\n\twindows func\t\"Polygon\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_int)wt_bool\n\twindows func\t\"TextOutA\" as textout\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_string,wt_int)wt_bool\n\twindows func\t\"TextOutW\" \t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_ptr,wt_int)wt_bool\n\twindows func\t\"GetStockObject\"\t\t\t\t\t\t\t(wt_int)wt_handle\n\twindows func\t\"SelectObject\"\t\t\t\t\t\t\t(wt_handle,wt_handle)wt_handle\n\twindows func\t\"CreateDCA\" as createdc\t\t\t\t\t(wt_string,wt_string,wt_string,wt_ptr)wt_handle\n\twindows func\t\"MoveToEx\"\t\t\t\t\t\t(wt_handle a,wt_int b,wt_int c,wt_ptr d=nil)wt_bool\n\twindows func\t\"CreatePen\"\t\t\t\t\t\t\t\t(wt_int,wt_int,wt_dword)wt_handle\n\twindows func\t\"CreateSolidBrush\"\t\t\t\t\t\t(wt_dword)wt_handle\n\twindows func\t\"CreateBrushIndirect\"\t\t\t\t\t\t(wt_ptr)wt_handle\n\twindows func\t\"LineTo\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_bool\n\twindows func\t\"GetPixel\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_dword\n\twindows func\t\"SetPixel\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_dword)wt_dword\n\twindows func\t\"SetGraphicsMode\"\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\twindows func\t\"CreateFontIndirectA\" as createfontindirect\t(wt_ptr)wt_handle\n\twindows func\t\"CreateFontA\" as createfont \\\n\t\t\t(wt_int height, wt_int width=0, wt_int escapement=0, wt_int orientation=0, wt_int bold=0,\n\t\t\t wt_dword italic=0, wt_dword underline=0, wt_dword strikeout=0, wt_dword charset=0,\n\t\t\t wt_dword outprec=0, wt_dword clipprec=0, wt_dword quality=0, wt_dword pitch=0, wt_string facename)wt_handle\n\twindows func\t\"SaveDC\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\twindows func\t\"GetTextMetricsA\" as gettextmetrics\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"DeleteObject\"\t\t\t\t\t\t\t(wt_handle)wt_bool\n\twindows func\t\"RestoreDC\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_bool\n\twindows func\t\"GetTextExtentPoint32A\" as gettextextentpoint32\t(wt_handle,wt_string,wt_int,wt_ptr)wt_bool\n\twindows func\t\"GetObjectA\" as getobject\t\t\t\t\t(wt_handle,wt_int,wt_ptr)wt_int\n\twindows func\t\"CreatePalette\"\t\t\t\t\t\t\t(wt_ptr)wt_handle\n\twindows func\t\"GetWindowExtEx\"\t\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"CreateCompatibleBitmap\"\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_handle\n\twindows func\t\"SetBitmapBits\"\t\t\t\t\t\t\t(wt_handle,wt_dword,wt_ptr)wt_long\n\twindows func\t\"SelectPalette\"\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_bool)wt_handle\n\twindows func\t\"RealizePalette\"\t\t\t\t\t\t\t(wt_handle)wt_uint\n\twindows func\t\"SetDIBitsToDevice\"\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_dword,wt_dword,wt_int,wt_int,wt_uint,wt_uint,wt_ptr,wt_ptr,wt_uint)wt_int\n\twindows func\t\"StretchDIBits\"\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_int,wt_ptr,wt_ptr,wt_uint,wt_dword)wt_int\n\twindows func\t\"SetStretchBltMode\"\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\twindows func\t\"PatBlt\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_dword)wt_bool\n\twindows func\t\"BitBlt\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int,wt_int,wt_int,wt_handle,wt_int,wt_int,wt_dword)wt_bool\n\twindows func\t\"SetROP2\"\t\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\twindows func\t\"CreateCompatibleDC\"\t\t\t\t\t\t(wt_handle)wt_handle\n\twindows func\t\"DeleteDC\"\t\t\t\t\t\t\t\t(wt_handle)wt_bool\n\twindows func\t\"CreateBitmap\"\t\t\t\t\t\t\t(wt_int,wt_int,wt_uint,wt_uint,wt_ptr)wt_handle\n\twindows func\t\"CreateBitmapIndirect\"\t\t\t\t\t(wt_ptr)wt_handle\n\twindows func\t\"CreateDIBitmap\"\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_dword,wt_ptr,wt_ptr,wt_uint)wt_handle\n\twindows func\t\"CreateDIBSection\"\t\t\t\t\t\t(wt_handle,wt_ptr,wt_uint,wt_ptr,wt_handle,wt_dword)wt_handle\n\twindows func\t\"StretchBlt\"\t\t\t\t\t\t\t\t(wt_handle,wt_int,wt_int, wt_int,wt_int,wt_handle, wt_int,wt_int,wt_int, wt_int,wt_dword)wt_bool\n\twindows func\t\"PlgBlt\"\t\t\t\t\t\t\t\t(wt_handle,wt_ptr,wt_handle, wt_int,wt_int,wt_int,wt_int, wt_handle, wt_int,wt_int)wt_bool\n\twindows func\t\"SetTextColor\"  as settextcolour\t\t\t(wt_handle,wt_dword)wt_dword\n\twindows func\t\"SetTextAlign\"\t\t\t\t\t\t\t(wt_handle,wt_uint)wt_uint\n\twindows func\t\"SetTextJustification\"\t\t\t\t\t(wt_handle,wt_int,wt_int)wt_bool\n\twindows func\t\"SetBkColor\"  as setbkcolour\t\t\t\t(wt_handle,wt_dword)wt_dword\n\twindows func\t\"SetBkMode\"\t\t\t\t\t\t\t\t(wt_handle,wt_int)wt_int\n\twindows func\t\"GetBkColor\"  as getbkcolour\t\t\t\t(wt_handle)wt_dword\n\twindows func\t\"GetBkMode\"\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\twindows func\t\"StartDocA\" as startdoc\t\t\t\t\t(wt_handle,wt_ptr)wt_int\n\twindows func\t\"StartPage\"\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\twindows func\t\"EndPage\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\twindows func\t\"EndDoc\"\t\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\twindows func\t\"AbortDoc\"\t\t\t\t\t\t\t\t(wt_handle)wt_int\n\twindows func\t\"GetViewportOrgEx\"\t\t\t\t\t\t(wt_handle,wt_ptr)wt_bool\n\twindows func\t\"GetDIBits\"\t\t\t\t\t\t\t\t(wt_handle,wt_handle,wt_uint,wt_uint,wt_ptr,wt_ptr,wt_uint)wt_int\n\twindows func\t\"GetDIBColorTable\" as getdibcolourtable\t(wt_handle,wt_uint,wt_uint,wt_ptr)wt_uint\n\twindows func\t\"SetDIBColorTable\" as setdibcolourtable\t(wt_handle,wt_uint,wt_uint,wt_ptr)wt_uint\n\twindows func\t\"GetTextAlign\"\t\t\t\t\t\t\t(wt_handle)wt_uint\nend\n\nimportdll comdlg32=\n\twindows func\t\"GetOpenFileNameA\"\t\t\t\t\t\t(wt_ptr)wt_bool\n\twindows func\t\"GetSaveFileNameA\"\t\t\t\t\t\t(wt_ptr)wt_bool\nend\n",
    
(byte*)"module sysp\n!module clib\n!module console\n!\nmodule winconsts\nmodule winapi\nmodule wingxlib\n!module winmessages\n!\nmodule gxmisc\n\nexport var debug=0\n\nexport var messhandlertable=9000\t!message by windowclass table of message handlers\nexport var actionhandlertable\n\nexport var chx,chy\t\t!default text sizes for menus\nexport var cha,chd\t\t!ascender/descender heights\nexport const smx=3\t\t!margins around button text in pixels (both sides)\nexport const smy=4\nexport var arrowdim\nexport var markdim\nexport var buttonheight\nexport var listrowheight\nexport const labelfont=1\n\nexport var tabstops=(8,)*20\n\nexport var wmouse=0\nexport var wfocus=0\nexport var wprinter=0\nexport var lastmousepos=0\nexport var lastmousewindow=0\nexport var currmousewindow=0\n\nexport var mousepos\nexport var mousesw\nexport var quitmess=0\nexport var dragmode=0\nexport var lastbuttontime=0\n\nexport var buttonstate=0\nexport var wmessagetable\t\t!see initdata\nexport var buttontable\t\t!see initdata\n\nconst maxqueuesize=100\nexport var messagequeue=()\nexport var nmessages=()\n\nconst dragtol=1\n\nexport var copymode=4\n\nvar vktomesstable\n\n!Describe gx window (also bitmap, control or child window)\nexport record rwindow =\n\n\tvar windclass\t\t\t\t\t! type of window (popup, control, etc)\n\tvar flags\t\t\t\t\t\t! general purpose flags\n\tvar style\t\t\t\t\t\t! stylerec entry\n\tvar name\t\t\t\t\t\t! Optional debugging name\n\n\tvar owner\t\t\t\t\t\t! owner when this is a child window\n\tvar index\t\t\t\t\t\t! index 1..n when part of a list (eg. .childlist of owner)\n\tvar childlist\t\t\t\t\t! list of child windows\n\n!framepos/dim describe the overall window size including Windows or gx-drawn borders,\n\tvar frameposx, frameposy\t\t! top left of frame, in screen or owner window client coords\n\tvar framedimx, framedimy\t\t! pixels dims including frame and caption\n\n\tvar\tposx, posy\t\t\t\t\t! Pixel pos client area as seen by application\n\tvar\tdimx, dimy\t\t\t\t\t! Pixel dims of client area as seen by application\n\n\tvar gdi\t\t\t\t\t\t\t! (rgdistate)\tgdi state record\n\n\tvar enable\t\t\t\t\t\t! 1 to enable toggle/button/arrow etc, 0 to disable and show greyed out\n\tvar id\t\t\t\t\t\t\t! button/et al: command code associated with control\n\tvar text\t\t\t\t\t\t! caption or label or primary data\n!\t\tvar data \t@text\n\tvar linkvar\t\t\t\t\t\t! pointer to linked var for toggle/select/scroll\n\tvar gindex\t\t\t\t\t\t! window export index\n\n\tvar attrs\t\t\t\t\t\t! general purpose attributes, depends on window class\n\n!bitmap data\n\tvar pixelbits\t\t\t\t\t! 1, 4, 16, 24, 32 bits per pixel\n\tvar pixelptr\t\t\t\t\t! pointer to image data\n\tvar pixelbytes\t\t\t\t\t!bytes/pixel (round up to next whole byte)\n\tvar linebytes\t\t\t\t\t!bytes/per row, also pitch\n\tvar framebytes\n\tvar paltype\t\t\t\t\t\t!0, or palette type\nend\n\n!export record bitmaprec=\t\t\t!bitmap-specfic data\n!\tvar pixelbits\t\t\t\t\t! 1, 4, 16, 24, 32 bits per pixel\n!\tvar pixelptr\t\t\t\t\t! pointer to image data\n!\tvar pixelbytes\t\t\t\t\t!bytes/pixel (round up to next whole byte)\n!\tvar linebytes\t\t\t\t\t!bytes/per row, also pitch\n!\tvar ncolours\t\t\t\t\t!0, or colours in palette\n!end\n\nexport enumdata paltypenames =\n\t(no_pal=0,\t\t$),\n\t(greyscale_pal,\t$),\n\t(tinted_pal,\t$),\n\t(colour_pal,\t$),\n\t(uv_pal,\t\t$),\nend\n\nexport type rgdistate = struct\n!\tint64 hwnd\t\t\t\t! win32 handle (hwnd)\n\tref void hwnd\t\t\t\t! win32 handle (hwnd)\n!\tint64 hdc\t\t\t\t! 0 or device context handle for hwnd\n\tref void hdc\t\t\t\t! 0 or device context handle for hwnd\n!\tint64 hwnd2\t\t\t\t! secondary window/memory backup\n\tref void hwnd2\t\t\t\t! secondary window/memory backup\n!\tint64 hdc2\t\t\t\t! 0 or hwnd3 DC screen or memory hdc\n\tref void hdc2\t\t\t\t! 0 or hwnd3 DC screen or memory hdc\n\tint64 originalwndproc\t! win32 control handling proc\n\tunion\n\t\tint64 menuhandle\t\t! win32 handle to any menubar\n\t\tint64 oldbmobj\t\t\t!used for bitmaps\n\tend\n\tint32 drawmode\t\t\t! see dm- drawcodes\n\tint32 updated\t\t\t\t! 1 when pixels have changed\n\n\tint32 posx,posy\t\t\t!current drawing position\n!\tint32 windcolour\t\t\t! current background colour (rgb)\n\tint32 pencolour\t\t\t! current line colour (rgb)\n\tint32 penwidth\t\t\t! current line width\n\n\tint32 penstyle\t\t\t! current line dotted style\n!\tint32 textcolour\t\t\t! current text colour\n!\tint32 bgndcolour\t\t\t! current background colour\n!\tint32 bgndmode\t\t\t! current opaque/transparent mode\n\n\tint32 xormode\t\t\t\t! 0=normal, 1=xor\n\tint32 brushcolour\t\t\t! current brush colour\n\tint32 brushstyle\t\t\t! current brush style (bs_solid/etc)\n\tint32 brushpattern\t\t! current brush hatch/bitmap pattern\n\n\tint32 font\t\t\t\t! current font number\nend\n\nexport enumdata marktypenames =\n\t(no_mark=0,\t\t\t$),\n\t(radio_mark,\t\t$),\n\t(tick_mark,\t\t\t$),\n\t(check_mark,\t\t$),\n\t(invert_mark,\t\t$),\n\t(outline_mark,\t\t$),\n\t(bold_mark,\t\t\t$),\nend\n\nexport enumdata hilitetypenames =\n\t(no_hilite=0,\t\t$),\n\t(invert_hilite,\t\t$),\n\t(outline_hilite,\t$),\nend\n\nexport record togglerec=\t\t!for toggle and select\n\tvar textoffset\n\tvar onvalue\nend\n\nexport record scrollbarrec=\t\t!scroll bars\n\tvar limits\t\t\t\t\t\t!range\n\tvar span\t\t\t\t\t\t!portion of limits represented by visible data (0 means not relevant)\n\tvar thumbsize\t\t\t\t\t!pixel length of thumb (vert or hoz extent along scrollbar)\n\tvar thumbspan\t\t\t\t\t!pixels that the thumb can move\n\tvar thumbpos\t\t\t\t\t!current thumb position in pixels from start of scrollbar\n\tvar currpos\t\t\t\t\t\t!current position, will be in limits range\n\tvar dragmode\t\t\t\t\t!1 if thum currently being dragged\nend\n\nexport record editboxrec=\t\t!edit boxes\n!current char position within edit text\n!if text has N characters, then position will be 1..N+1\n!The position is just /before/ the stated character\n!This matches column position within the MED text editor\n\tvar currpos\t\t\t\t\t\t!cursor position, 1 to N+1 (N=chars in edit text)\n\tvar caretpos\t\t\t\t\t!current pixel position of any caret\n\tvar textpos\t\t\t\t\t\t!start x,y pixel position of text, set by gxjust_text\nend\n\nexport record listboxrec=\n\tvar rows\t\t\t\t\t\t!number of displayed rows\n\tvar pagepos\t\t\t\t\t\t!data position corresponding to row 1 of display\n\tvar length\t\t\t\t\t\t!all data items, same as linkvar^.len\n\tvar currpos\t\t\t\t\t\t!cursor position within the data, 1 to N (can be 0 when N=0)\n\tvar pitch, offset\t\t\t\t!pixel dims of each row\nend\n\nexport record rmessage=\n\tvar\t\twind\t\t!main window/button associated with message\n\tvar\t\tmenuwind\t!top-level window owning button\n\tvar\t\tmessage\t\t!message number\n\tvar\t\tstate\t\t!button/shift key state at time of message\n\tvar\t\ta,b\t\t\t!general purpose data, depends on message\n\tvar\t\tx,y\t\t\t!current mouse position\nend\n\n!contains many different flags and style codes for assorted controls\n!But at one mostly byte each, is very low overhead (32 values is same as two vars)\n\nexport type stylerec = struct\n\tbyte\tborder\t\t\t\t!bs_ code\n\tbyte\tjustify\t\t\t\t!'L', 'R', 'C'\n\tbyte\tvjustify\t\t\t!'T', 'B', 'M'\n\tbyte\twindbgnd\t\t\t!colour index for window background\n\tbyte\ttextfgnd\t\t\t!colour index\n\tbyte\ttextbgnd\t\t\t!\n\tbyte\tbgndmode\t\t\t!\n\tbyte\ttextfont\t\t\t!font index\n\tbyte\ttextsize\t\t\t!pixel size\n\tbyte\ttextbold\t\t\t!1 if bold\n\tbyte\ttextitalic\t\t\t!1 if italic\n\tbyte\tispassword\t\t\t!1 when edit field is a password\n\tbyte\tfieldwidth\t\t\t!edit field maximum char width\n\tbyte\tdir\t\t\t\t\t!'L','R','U','D'\n\tbyte\tmarktype\t\t\t!xxx_mark style, or:\n\tbyte\thilitetype\t\t\t!xxx_hilite style\n\tbyte\tiframe\t\t\t\t!1: pos/dim include frame\n\tbyte\timark\t\t\t\t!1: pos/dim include mark for toggle/select\n\tbyte\thscroll\t\t\t\t!1: include windows-drawn hoz scroll bar\n\tbyte\tvscroll\t\t\t\t!1: include windows-drawn vert scroll bar\n\tbyte\tlbchange\t\t\t!1: return mm_change on list boxes when row has changed\n\tbyte\treturnmess\t\t\t!1: return id code when clicking toggle/select/editbox\n\tbyte\tnoupdate\t\t\t!1: don't change or allow editing on toggle/select/editbox\nend\n\nexport record rpoint = var x,y end\nexport record rrect  = (var pos,dim)\nexport record rframe = (var x1,y1,x2,y2)\n\nexport record getrec=\n\tmethod getbounds(&self)=\n\t\treturn 0\n\tend method\n\tmethod getitem(&self,n)=\n\t\treturn 0\n\tend method\n\tmethod getstritem(&self,n)= return \"\" end method\nend\n\nexport enumdata stylenames =\t! (default)\n\t(ss_border,\t\t\t$),\t\t! Border style (wbs_simple)\n\t(ss_justify,\t\t$),\t\t! 'L' 'C' 'R'\tHorizontal text justify ('L')\n\t(ss_vjustify,\t\t$),\t\t! 'T' 'M' 'B'\tVertical text justify ('M' for buttons)\n\t(ss_textfgnd,\t\t$),\t\t! Text colour index (black)\n\t(ss_textbgnd,\t\t$),\t\t! Text background colour index (if opaque mode) (0)\n\t(ss_bgndmode,\t\t$),\t\t! 0\n\t(ss_textfont,\t\t$),\t\t! Text font number (1)\n\t(ss_textsize,\t\t$),\t\t! (0)\n\t(ss_textbold,\t\t$),\t\t! (0)\n\t(ss_textitalic,\t\t$),\t\t! (0)\n\t(ss_ispassword,\t\t$),\t\t! (0)\n\t(ss_marktype,\t\t$),\t\t! Toggle/select mark style (radio_mark)\n\t(ss_hilitetype,\t\t$),\t\t! Toggle/select hilite style (no_hilite)\n\t(ss_iframe,\t\t\t$),\t\t! Whether pos and dim include frame width (also caption bar/menu for windows)\n\t(ss_windbgnd,\t\t$),\t\t! Background colour of window or button (ltgrey)\n\t(ss_imark,\t\t\t$),\t\t! Background colour of window or button (ltgrey)\n\t(ss_hscroll,\t\t$),\t\t! (0)\n\t(ss_vscroll,\t\t$),\t\t! (0)\n\t(ss_lbchange,\t\t$),\t\t! (0)\n\t(ss_returnmess,\t\t$),\t\t! (0) Toggle/select/editbox, return id when clicked\n\t(ss_noupdate,\t\t$),\t\t! (0) Toggle/select/editbox, don't change or allow edit\nend\n\nexport enumdata drawmodenames =\n\t\t\t\t\t\t\t\t!HDC\tHDC2\tRestore\n\t(dm_screen=0,\t\t$),\t\t!screen\t--\t\tCustom routine\tDraw directly to screen; no mem backup\n\t(dm_memory,\t\t\t$),\t\t!memory\t--\t\tNA\t\t\t\tDraw to memory only; no screen hdc (eg. bitmap)\n\t(dm_screenmemory,\t$),\t\t!screen\tmemory\tBlit mem->scr\tDraw to both screen and memory at same time\n\t(dm_memoryscreen,\t$),\t\t!memory\tscreen\tBlit mem->scr\tDraw to memory; update screen periodically\nend\n\n!var windowlist=nil\n\nexport enumdata wfnames =\n\t(wa_rightclick=0,\t$),\t\t!allow right click\n\t(wa_middleclick,\t$),\t\t!allow middle click\n\t(wa_leftdbl,\t\t$),\t\t!allow left double click\n\t(wa_rightdbl,\t\t$),\t\t!allow right double click\n\t(wa_middledbl,\t\t$),\t\t!allow middle double click\n\t(wa_leftdrag,\t\t$),\t\t!allow left drag\n\t(wa_rightdrag,\t\t$),\t\t!etc\n\t(wa_middledrag,\t\t$),\n\t(wa_autoupdate,\t\t$),\t\t!auto update screen for toggles/etc\n\t(wa_tab,\t\t\t$), \t!allow tab to switch to next button which has watab\n\t(wa_strvar,\t\t\t$), \t!1 for listbox linkvar to use string not index\n\t(wa_retmess,\t\t$), \t!1 for button to return .value as mess not qmcommand\n\t(wa_retsel,\t\t\t$), \t!1 for button to return .value as mess not qmcommand\n\t(wa_memory,\t\t\t$), \t!1 when hdc/hdcmem have been switched, hdc points to memory dev\n\t(wa_maximised,\t\t$),\t\t!1 when maximised, 0 when normal/minimised\n\t(wa_param1,\t\t\t$), \t!general purpose control-specific flags\n\t(wa_param2,\t\t\t$), \n\t(wa_useenter,\t\t$),\n\t(wa_closed,\t\t\t$),\t\t!whether window has been closed\n\n\t(wa_$last,\t\t\t$)\nend\n\nconst wa_needdbl\t= wa_param1\t!1 requires double-click on listbox to return wmcommand\nconst wa_editdd\t\t= wa_param2\t!1 means editable dropdown box\n\n!GX border styles, used for child windows.\n!some child windows\nexport enumdata bsnames, bscat, bswidths=\n\t(bs_none=0,\t\t$,\t0,\tws_rect(0,0,0,0)),\t\t\t!no border\n!\t(bs_windows,\t$,\t'W',\tws_rect(0,0,0,0)),\t\t\t!windows-drawn, but no own-drawn border\n\t(bs_simplew,\t$,\t'W',\tws_rect(1,1,1,1)),\t\t\t!single 1-pixel black line, windows drawn\n\t(bs_simple,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!single 1-pixel black line\n\t(bs_thick,\t\t$,\t'X',\tws_rect(2,2,2,2)),\t\t\t!2-pixel border\n\t(bs_panel,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!raised panel, 1-pixel\n\t(bs_inset,\t\t$,\t'X',\tws_rect(1,1,1,1)),\t\t\t!inset panel, 1-pixel\n\t(bs_ownsimple,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel (drawn as part of client area)\n\t(bs_ownpanel,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel (drawn as part of client area)\n\t(bs_owninset,\t$,\t'I',\tws_rect(0,0,0,0)),\t\t\t!included inset panel, 1-pixel\n\t(bs_testext,\t$,\t'X',\tws_rect(10,10,10,10)),\n\t(bs_testint,\t$,\t'I',\tws_rect(8,8,8,8)),\n\t(bs_dummy,\t\t$,\t0,\tws_rect(0,0,0,0))\nend\n\nexport enumdata windowclassnames, defaultborderstyles =\n\t(no_class=0,\t\t$,\tbs_none),\t\t\t!Unassigned\n\t(window_class,\t\t$,\twbs_resize),\t\t!Main window\n\t(memwindow_class,\t$,\twbs_none),\t\t\t!memory backup to any window\n\t(popup_class,\t\t$,\twbs_thick),\t\t\t!Pop-up window (forms a stack)\n\t(float_class,\t\t$,\tbs_thick),\t\t\t!Independent window\n\t(bitmap_class,\t\t$,\tbs_none),\t\t\t!(image handling)\n\t(screen_class,\t\t$,\tbs_none),\t\t\t!Describes the desktop screen (not owned by my app)\n\t(printer_class,\t\t$,\tbs_none),\t\t\t!Used for printing\n\n\t(group_class,\t\t$,\tbs_inset),\t\t\t!Used mainly for grouping other buttons (eg. for Smdefblock)\n\t(panel_class,\t\t$,\tbs_inset),\t\t\t!General purpose panel for drawing in etc\n!\t(button_class,\t\t$,\tbs_panel),\t\t\t!Click button\n\t(button_class,\t\t$,\tbs_simplew),\t\t!Click button\n\t(toggle_class,\t\t$,\tbs_none),\t\t\t!Toggle button (can be composite, eg mark and label)\n\t(select_class,\t\t$,\tbs_none),\t\t\t!Select from several choices\n\t(editbox_class,\t\t$,\tbs_simplew),\t\t!Single-line edit control\n\t(scrollbar_class,\t$,\tbs_simplew),\t\t!Hoz or vert scroll bar (Some windows can also have Windows-drawn scroll bars)\n\t(listbox_class,\t\t$,\tbs_simplew),\t\t!List of options (scrollable usually)\n\t(dropdown_class,\t$,\tbs_none),\t\t\t!Button revealing attached listbox when clicked\n\t(framebar_class,\t$,\tbs_panel),\t\t\t!Left or right full-height panel used for toolboxes etc\n\t(statusbar_class,\t$,\tbs_panel),\t\t\t!Top or bottom full-width panel used for scrollbars\n\t(tooltip_class,\t\t$,\tbs_simplew),\t\t!Tooltops displayed when hovering over enabled buttons\n\t(arrow_class,\t\t$,\tbs_ownpanel),\t\t!Click button normally displaying an error in one of 4 orientations\n\t(mark_class,\t\t$,\tbs_none),\t\t\t!Toggle or select mark\n\t(label_class,\t\t$,\tbs_none),\t\t\t!Contains unclickable text usually\n\t(dummy_class,\t\t$,\tbs_none)\nend\n\n!export enumdata actionnames, actionhandlertable=\n!\t(draw_w,\t\t$,\t\t()),\n!\t(update_w,\t\t$,\t\t()),\n!\t(last_w,\t\t$,\t\t()),\n!end\n\nexport enumdata actionnames=\n\t(draw_w,\t\t$),\n\t(update_w,\t\t$),\n\t(last_w,\t\t$),\nend\n\n!MM Message Numbers\n\nexport enumdata messagenames=\n\n!all messages have x,y coord relative to top most window or child window\n!\n\t(mm_null=0,\t\t\t$),\t\t! empty message\n\n!window messages\n\t(mm_activate,\t\t$),\t\t! (w,a) a=1/0 activate/deactivate window\n\t(mm_close,\t\t\t$),\t\t! (w) close window (X button clicked)\n\t(mm_sizewindow,\t\t$),\t\t! (w...) resize window\n\t(mm_movewindow,\t\t$),\t\t! (w...) move window\n\t(mm_restore,\t\t$),\t\t! (w...) repaint window\n\n!cursor/focus messages\n\t(mm_setcursor,\t\t$),\t\t! (w...) update cursor type\n\t(mm_setfocus,\t\t$),\t\t! (w...) set focus to w\n\t(mm_killfocus,\t\t$),\t\t! (w...) lose focus from w\n\n!basic mouse messages (click messages can be promoted to other messages eg mm_command)\n\t(mm_move,\t\t\t$),\t\t! (w,x,y,b) mouse move, btns up/down (also drag messages when down)\n\t(mm_click,\t\t\t$),\t\t! (w,x,y) left btn click, can be promoted to mm_command etc depending on context\n\t(mm_dblclick,\t\t$),\t\t! (w,x,y) left btn dbl click, usu promoted\n\t(mm_clickup,\t\t$),\t\t! (w,x,y) left btn released\n\t(mm_rclick,\t\t\t$),\t\t! (w,x,y) right click in window, these usu. promoted\n\t(mm_rdblclick,\t\t$),\t\t! (w,x,y) right double click\n\t(mm_rclickup,\t\t$),\t\t! (w,x,y) right button released\n\t(mm_mclick,\t\t\t$),\t\t! (w,x,y) middle button versions of above\n\t(mm_mdblclick,\t\t$),\t\t! (w,x,y)\n\t(mm_mclickup,\t\t$),\t\t! (w,x,y)\n\t(mm_hover,\t\t\t$),\t\t! (w,x,y) paused over button\n\n\t(mm_onwindow,\t\t$),\t\t! (w,x,y) newly over a window\n\t(mm_offwindow,\t\t$),\t\t! (w,x,y) just came off window\n\t(mm_draw,\t\t\t$),\t\t! (w,x,y) redraw window\n\t(mm_update,\t\t\t$),\t\t! (w,x,y) update window (change of pos etc)\n\n!drag messages\n\t(mm_startdrag,\t\t$),\t\t! (w) start mouse movement with some btns down\n\t(mm_rstartdrag,\t\t$),\t\t! (w)\n\t(mm_mstartdrag,\t\t$),\t\t! (w)\n\t(mm_drag,\t\t\t$),\t\t! (w,x,y) moving mouse with buttons down (also qmmove sent)\n\t(mm_enddrag,\t\t$),\t\t! (w,x,y) all buttons up after drag\n\n!left command\n\t(mm_command,\t\t$),\t\t! (w,id) button clicked, id and sub-event given\n\t(mm_dblcommand,\t\t$),\t\t! (w,id) button double clicked\n\n!right command\n\t(mm_rcommand,\t\t$),\t\t! (w,id) right click button\n\t(mm_rdblcommand,\t$),\t\t! (w,id) right double click button\n\n!middle command\n\t(mm_mcommand,\t\t$),\t\t! (w,id)\n\t(mm_mdblcommand,\t$),\t\t! (w,id)\n\n!general key messages\n\t(mm_char,\t\t\t$),\t\t! (w,ch)\n\t(mm_key,\t\t\t$),\t\t! (w,k,shift)\n\t(mm_keyup,\t\t\t$),\t\t! (w,k,shift)\n\n!scroll/select/wheel messages\n\t(mm_sethozpos,\t\t$),\t\t! (w,pos)\t\tNew logical position set by hoz scrollbar\n\t(mm_setvertpos,\t\t$),\t\t! (w,pos)\t\tfrom vertical scrollbar\n\t(mm_select,\t\t\t$),\t\t! (w,n)\t\t\tSet nth item as current/highlighted/selected item\n\t(mm_pick,\t\t\t$),\t\t! (w,n)\t\t\tPick and return item n\n\t(mm_wheel,\t\t\t$),\t\t! (w,delta)\t\tMove log pos etc but depends on context\n\t(mm_lbchange,\t\t$),\t\t! (w,n)\t\t\tA listbox position has changed\n\n!misc messages\n\t(mm_timer,\t\t\t$),\t\t! (w)\n\n!high level window messages\n\t(mm_cancel,\t\t\t$),\t\t! (w)\n\t(mm_ok,\t\t\t\t$),\t\t! (w)\n\t(mm_help,\t\t\t$),\t\t! (w,id)\n\t(mm_cmdline,\t\t$),\t\t! (w,s)\n\n!specific key messages\n\t(mm_leftkey ,\t\t$),\t\t! (w,shift)\n\t(mm_rightkey,\t\t$),\t\t! (w,shift)\n\t(mm_upkey,\t\t\t$),\t\t! (w,shift)\n\t(mm_downkey,\t\t$),\t\t! (w,shift)\n\t(mm_pageupkey,\t\t$),\t\t! (w,shift)\n\t(mm_pagedownkey,\t$),\t\t! (w,shift)\n\t(mm_homekey,\t\t$),\t\t! (w,shift)\n\t(mm_endkey,\t\t\t$),\t\t! (w,shift)\n\t(mm_tabkey,\t\t\t$),\t\t! (w,shift)\n\t(mm_bskey,\t\t\t$),\t\t! (w,shift)\n\t(mm_deletekey,\t\t$),\t\t! (w,shift)\n\t(mm_enterkey,\t\t$),\t\t! (w,shift)\n\t(mm_insertkey,\t\t$),\t\t! (w,shift)\n\t(mm_functionkey,\t$),\t\t! (w,shift)\n\n!Other messages for controls, mainly for attached arrow buttons\n\t(mm_up,\t\t\t\t$),\t\t! (w,id) Arrow up/etc\n\t(mm_down,\t\t\t$),\t\t! (w,id)\n\t(mm_right,\t\t\t$),\t\t! (w,id)\n\t(mm_left,\t\t\t$),\t\t! (w,id)\n\t(mm_edit,\t\t\t$),\t\t! (w,id)\tUpdate of edit box\n\t(mm_edited,\t\t\t$),\t\t! (w,id)\tFinished edit box entry (tab etc)\n\t(mm_last,\t\t\t$)\nend\n\n!export const mm_scroll\t= mm_hscroll\t!general scroll independent of orientation\n\n!!other messages wmuser+ are user assigned, usually applied as\n!ids to controls. Depending on the options to Waitmess(), a wm_commmand message\n!is coverted to a direct message number. So (wm_command, 230) is covered to\n!message 230. So message ids have to start from 200 so that they occupy a different\n!number space from normal message codes.\nexport const mm_user\t= 200\n\nexport const kb_lbutton\t= 0x1\t!used in buttonstate\nexport const kb_rbutton\t= 0x2\nexport const kb_mbutton\t= 0x4\n\nexport const kb_shift\t= 0x8\t!used in shiftstate\nexport const kb_ctrl\t= 0x10\nexport const kb_alt\t\t= 0x20\nexport const kb_capslock\t= 0x40\nexport const kb_dblclick\t= 0x80\t!used for some messages that don't have dblclick versions,\n\nexport const kb_rshift\t= 0x100\nexport const kb_rctrl\t= 0x200\nexport const kb_ralt\t= 0x400\n\nexport enumdata colournames, colourvalues =\n!\t\t\t\t\t   BB'GG'RR\n\t(black,\t\t$,\t0x_00'00'00),\n\t(red,\t\t$,\t0x_00'00'C0),\n\t(dkred,\t\t$,\t0x_00'00'90),\n\t(red3,\t\t$,\t0x_00'00'70),\n\t(green,\t\t$,\t0x_00'C0'00),\n\t(dkgreen,\t$,\t0x_00'90'00),\n\t(green3,\t$,\t0x_00'70'00),\n\t\n\t(blue,\t\t$,\t0x_C0'00'00),\n\t(dkblue,\t$,\t0x_90'00'00),\n\t(blue3,\t\t$,\t0x_70'00'00),\n\n\t(cyan,\t\t$,\t0x_c0'c0'00),\n\t(dkcyan,\t$,\t0x_90'90'00),\n\t(cyan3,\t\t$,\t0x_70'70'00),\n\n\t(magenta,\t$,\t0x_c0'00'c0),\n\t(dkmagenta,\t$,\t0x_90'00'90),\n\t(magenta3,\t$,\t0x_70'00'70),\n\n\t(yellow,\t$,\t0x_00'C0'C0),\n\t(dkyellow,\t$,\t0x_00'90'90),\n\t(yellow3,\t$,\t0x_00'70'70),\n\t(yellow4,\t$,\t0x_00'50'50),\n\n\t(white,\t\t$,\t0x_FF'FF'FF),\n\t(ltgrey,\t$,\t0x_C0'C0'C0),\n\t(grey,\t\t$,\t0x_90'90'90),\n\t(dkgrey,\t$,\t0x_70'70'70),\n\n\t(ltorange,\t$,\t0x_00'A0'FF),\n\t(orange,\t$,\t0x_00'60'FF),\n\t(flesh,\t\t$,\t0x_70'85'EE),\n\t(pink,\t\t$,\t0x_9A'32'DB),\n\t(dkpink,\t$,\t0x_72'24'A9),\n\t(brown,\t\t$,\t0x_46'43'7D),\n\t(blue4,\t\t$,\t0x_B7'1C'5E),\n\t(blue5,\t\t$,\t0x_6F'3D'0D),\n\t(olive,\t\t$,\t0x_05'A0'88),\n\t(ltbrown,\t$,\t0x_00'70'B0),\n\n\t(blue6,\t\t$,\t0x_9C'63'1C),\n\t(green4,\t$,\t0x_12'51'11),\n\t(purple,\t$,\t0x_5E'0D'73),\n\t(blue7,\t\t$,\t0x_E6'27'1C),\n\t(crimson,\t$,\t0x_15'2A'D3),\n\t(violet,\t$,\t0x_54'16'A0),\n\t(blue8,\t\t$,\t0x_86'68'1E),\n\t(dkorange,\t$,\t0x_25'6A'D4),\n\t(green5,\t$,\t0x_09'46'41),\n\t(blue9,\t\t$,\t0x_65'0A'1D),\n\n\t(ltred,\t\t$,\t0x_00'00'FF),\n\t(ltgreen,\t$,\t0x_00'FF'00),\n\t(ltblue,\t$,\t0x_FF'00'00),\n\t(ltcyan,\t$,\t0x_FF'FF'00),\n\t(ltmagenta,\t$,\t0x_FF'00'FF),\n\t(ltyellow,\t$,\t0x_00'FF'FF),\n\n!The following are the Windows system colours, set up as indices\n!Init needs need to retrieve the values and set up the rgb values in this table\n\t(button_col,\t$,\t0),\t\t!button colour\n\t(window_col,\t$,\t0),\t\t!window colour\n\t(text_col,\t\t$,\t0),\t\t!text in windows\nend\n\nexport const skipmess = 1\t\t!message has been processed; caller must wait for another message\nexport const thismess = 0\t\t!caller should deal with this message (it has not been processed, or has been but caller can process it too)\n\nexport var bmbgnd\nexport var defstyle\t\t\t!set initdata\nexport var currmess\n\nexport var wapplic=nil\nexport var wscreen=nil\n\nvar data,ndata\nvar tabstack,ntab\nvar breakflag\n\nconst k_menu=30000\nconst kdivide=30001\nconst kcolumn=30002\nconst kfilehistory=30003\n\nvar caretdrawn=0\nvar dkcolour=0x000000\nvar ltcolour=0xFFFFFF\nvar thumbdragmode=0\nvar thumbstartpos=0\n\nvar dirtomess=['L':mm_left,'R':mm_right,'U':mm_up,'D':mm_down]\n\nproc start=\n!CPL \"---------GXLIB\"\n!CPL \"GXLIB START\"\n!K:=WAITKEY()\n!CPL =K\n!IF K=27 THEN\n!\tCPL \"STOPPING...\"\n!\t$TEST(\"HELLO\")\n!\tSTOP\n!FI\n\ninitdata()\nmxinit()\ninitmenuhandlers()\n!CPL \"GXLIB START DONE\"\n\n!w:=GXCREATEWINDOW()\n!gxcaption(w,\"hello there\")\n!\n!EVENTLOOP()\n!\n!waitkey()\n\nend\n\nexport proc setupgdi(w,hwnd)=\t\t\t!SETUPGDI\n!NOTE: rare care of a func within a data header. This is to allow bitmap module\n!to be higher up the hierarchy than gx, but still let it use some gx functions.\n\n!set up the default gdi descriptor for window w\n\nif w.gdi then\n\treturn\t\t\t!assume already done\nfi\n\ngdi:=new(rgdistate)\ngdi.hwnd:=hwnd\n\n!start with default drawmodes of dm_screen, or dm_memory for bitmaps\n!These can be converted later using gxdrawmode\n\nif w.usertype=rwindow then\n\tgdi.hdc:=getdc(hwnd)\n\tgdi.drawmode:=dm_screen\nelse\t\t\t\t\t\t!assume bitmap\n\tgdi.hdc:=createcompatibledc(nil)\n\tgdi.drawmode:=dm_memory\nfi\n\ngdi.posx:=gdi.posy:=0\ngdi.updated:=0\ngdi.font:=0\ngdi.pencolour:=getsyscolour(colour_windowtext)\ngdi.penwidth:=0\ngdi.penstyle:=ps_solid\ngdi.xormode:=0\ngdi.brushcolour:=0xff'ff'ff\ngdi.brushstyle:=bs_solid\ngdi.brushpattern:=0\nw.gdi:=gdi\nend\n\nexport const arleft = \"<\"\nexport const arright = \">\"\nexport const arup = \"^\"\nexport const ardown = \"V\"\n\nexport var allwindows::=()\t\t\t!list of all windows and controls\n\nexport func ctrlpressed = return (currmess.state iand kb_ctrl) end\nexport func shiftpressed = return (currmess.state iand kb_shift) end\n\nproc initdata=\nmessagequeue:=new(list,100)\nnmessages:=0\n\ncolourvalues::=colourvalues\n\ncolourvalues[button_col]:=getsyscolour(colour_btnface)\n\ncolourvalues[window_col]:=getsyscolour(colour_window)\ncolourvalues[text_col]:=getsyscolour(colour_windowtext)\n\ndefstyle:=new(stylerec)\ndefstyle.border\t\t:= bs_simplew\ndefstyle.justify\t:= 'L'\ndefstyle.vjustify\t:= 'M'\ndefstyle.textfgnd\t:= black\ndefstyle.marktype\t:= check_mark\ndefstyle.hilitetype\t:= no_hilite\ndefstyle.windbgnd\t:= button_col\ndefstyle.imark\t\t:= 1\n!defstyle.windbgnd\t:= window_col\n\ninit_handlertables()\nd:=gxchardim(labelfont)\nchx:=d.x\nchy:=d.y\n\nd:=gxchardim(0,1)\ncha:=d.x\nchd:=d.y\narrowdim:=chy+2\nmarkdim:=arrowdim-2\n\nbuttonheight:=chy+smy*2\nlistrowheight:=chy+smy*2\nend\n\nexport func gxcreatewindow(?caption,?pos,?dim,?options,owner=nil)=\t\t!CREATEWINDOW\n#create a popup window which is not a child window.\n#(nevertheless, it can have an owner window, such as the main window of the\n#application)\n#returns an rwindow handle\n#caption\toptional caption txt\n#pos\t\t(x,y) is pixel pos of top left corner in screen coordinates (of frame?)\n#\t\t\"cent\" to place centrally\n#\t\tomitted: use default placement\n#dim\t\t(width,height) overall pixel size\n#\t\t\"max\" maximised\n#\t\t\"desktop\" fill desktop screen\n#\t\tomitted: use (640,480)\n#owner\toptional owner window (default nil)\n#options\toption dict, default is [wf_caption:1, wf_border:wbs_resize]\n\nhwnd:=wx_createpopup(caption,pos,dim,options,(owner|owner.gdi.hwnd|nil))\n!CPL \"CW2\"\n\nw:=newwindow(hwnd,0,no_class,bs_windows)\n\nif wapplic=nil then\n\twapplic:=w\nfi\n\nW.STYLE:=NEW(STYLEREC)\nW.STYLE.BORDER:=0\nW.WINDCLASS:=WINDOW_CLASS\nW.STYLE.WINDBGND:=WINDOW_COL\nW.ENABLE:=1\nW.FLAGS.[WA_LEFTDRAG]:=1\nW.FLAGS.[WA_LEFTDBL]:=1\n\nsetwindowdims_w(w,hwnd)\n\nsetupgdi(w,hwnd)\ngxfont(w,1)\n\nGXDRAWMODE(W,DM_SCREENMEMORY)\nGXCLEAR(W)\n\nreturn w\nend\n\nproc setwindowdims_w(w,hwnd)=\t\t\t!SETWINDOWDIMS\n!use windows functions to set up client and frame pos and dims of top-level window\n\nbox:=new(ws_rect)\ngetwindowrect(hwnd,&box)\nw.frameposx:=box.x\nw.frameposy:=box.y\nw.framedimx:=box.x2-box.x\nw.framedimy:=box.y2-box.y\n\ngetclientrect(hwnd,&box)\n\nw.dimx:=box.x2-box.x\nw.dimy:=box.y2-box.y\n\npt:=ws_point(0,0)\nclienttoscreen(hwnd,&pt)\t\t!pos starts at 0,0\nw.posx:=pt.x\nw.posy:=pt.y\nend\n\nproc setwindowdims_c(w,hwnd)=\t\t\t!SETWINDOWDIMS\n!use windows functions to set up client and frame pos and dims of child window\n\n\nbox:=new(ws_rect)\ngetwindowrect(hwnd,&box)\t\t\t!client dims also Windows frame dims as has no Windows border\nw.posx:=box.x-w.owner.posx\nw.posy:=box.y-w.owner.posy\nw.dimx:=box.x2-box.x\nw.dimy:=box.y2-box.y\n\nwidths:=bswidths[w.style.border]\nif bscat[w.style.border]='I' then widths:=ws_rect(0,0,0,0) fi\n\nw.frameposx:=w.posx-widths.x1\nw.frameposy:=w.posy-widths.y1\nw.framedimx:=w.dimx+widths.x1+widths.x2\nw.framedimy:=w.dimy+widths.y1+widths.y2\nend\n\nexport proc gxclear(w,?colour)=\t\t\t!GXCLEAR\n#fill window w with <colour>, or with current background if omitted\n\n!RETURN\ngdi:=w.gdi\ngdi.updated:=1\n\ngxcolour(w,getrgb(black))\ngxstyle(w,0)\n\nif colour.isvoid then\n\tcolour:=getrgb(w.style.windbgnd)\nfi\n\noldpenstyle:=gdi.penstyle\noldbrushstyle:=gdi.brushstyle\n\ngxbrushstyle(w,bs_solid)\ngxstyle(w,ps_null)\n\ngxfillrect(w,0,0,w.dimx,w.dimy,colour)\ngxbrushstyle(w,oldbrushstyle)\ngxstyle(w,oldpenstyle)\nend\n\nexport func gxstyle(w,?style)=\t\t\t!GXSTYLE\n#style omitted: get pen current pen style\n#style supplied: set pen style for subsequent line drawing\n#Style is a char code or int refering to a small variety of Windows dotted styles:\n#\t0 S |\t\tSolid\n#\tSpace\t\tNull (pen up?)\n#\t-\t\t\tDotted\n#\t:\t\t\tDashdotdot\n#\t!\t\t\tDashdotd\n#\tF\t\t\tInside frame\n\ngdi:=w.gdi\n\nif style.isdef and gdi.penstyle<>style then\n\tcase style\n\twhen '!' then style:=ps_dashdot\n\twhen ':' then style:=ps_dashdotdot\n\twhen '-' then style:=ps_dot\n\twhen ' ' then style:=ps_null\n\twhen 'D' then style:=ps_alternate\n\twhen '|','S',0 then style:=ps_solid\n\twhen 'F' then style:=ps_insideframe\n\tesac\n\n\tgdi.penstyle:=style\n\tif style>=10 then style:=ps_dot fi\n\tdeleteobject(selectobject(gdi.hdc,createpen(style,gdi.penwidth,gdi.pencolour)))\n\tif gdi.drawmode=dm_screenmemory then\n\t\tdeleteobject(selectobject(gdi.hdc2,createpen(style,gdi.penwidth,gdi.pencolour)))\n\tfi\nfi\nreturn gdi.penstyle\nend\n\nexport proc gxbrushstyle(w,?style,?pattern)=\t\t!GXBRUSHSTYLE\n#Set Windows brush style and pattern\n#Style supplied:\tset style\n#pattern supplied:\tset style\n#style is:\t\tS, H, Space, B for Solid, Hatched, Null, DIB\n#pattern is:\t- | \\ / + x/X for Hoz, Vert, Diag, Fwd Diag, Cross, Diag Cross\n\ngdi:=w.gdi\nbrush:=new(ws_logbrush)\n\nif style.isdef then\n\tif style<>gdi.brushstyle then\n\t\tcase style\n\t\twhen 'S' then style:=bs_solid\n\t\twhen 'H' then style:=bs_hatched\n\t\twhen ' ' then style:=bs_null\n\t\twhen 'B' then style:=bs_dibpattern\n\t\tesac\n\n\t\tgdi.brushstyle:=style\n\tfi\n\tgdi.brushpattern:=0\t\t!default to no pattern, will be changed by pattern if supplied\nfi\n\nif pattern.isdef and pattern<>gdi.brushpattern then\n\tcase pattern\n\twhen '-' then pattern:=hs_horizontal\n\twhen '|' then pattern:=hs_vertical\n\twhen '\\\\' then pattern:=hs_fdiagonal\n\twhen '/' then pattern:=hs_bdiagonal\n\twhen '+' then pattern:=hs_cross\n\twhen 'x','X' then pattern:=hs_diagcross\n\tesac\n\tgdi.brushpattern:=pattern\nfi\n\nbrush.lbstyle:=gdi.brushstyle\nbrush.lbcolour:=gdi.brushcolour\nbrush.lbhatch:=gdi.brushpattern\n\ndeleteobject(selectobject(gdi.hdc,createbrushindirect(&brush)))\nif gdi.drawmode=dm_screenmemory then\n\tdeleteobject(x:=selectobject(gdi.hdc2,createbrushindirect(&brush)))\nfi\nend\n\nexport func gxbrushcolour(w,?colour)=\t\t\t!GXBRUSHCOLOUR\n#colour supplied:\tset current fill colour\n#colour omitted:\treturn current fill colour\n\ngdi:=w.gdi\n\nif colour.isdef and colour<>gdi.brushcolour then\n\tgdi.brushcolour:=colour\n\tbrush:=new(ws_logbrush)\n\tbrush.lbstyle:=gdi.brushstyle\n\tbrush.lbcolour:=colour\n\tbrush.lbhatch:=gdi.brushpattern\n\n\tdeleteobject(selectobject(gdi.hdc,createbrushindirect(&brush)))\n\tif gdi.drawmode=dm_screenmemory then\n\t\tdeleteobject(selectobject(gdi.hdc2,createbrushindirect(&brush)))\n\tfi\nfi\nreturn gdi.brushcolour\nend\n\nexport proc gxfillrect(w,x,y,width,height,?colour,mode=0)=\t\t!GXFILLRECT\n#Draw filled rectangle with optional outline\n#x,y are top-left coordinates\n#width, height are overall pixel dimensions, inclusive; they include any outline\n#(When the outline is drawn, the filled region is 1 pixel smaller all round)\n#colour is the colour of the filled region (current brush colour when omitted)\n#mode=1 to draw the outline, or mode=0 (default) to omit it\n#The outline is drawn in the current pen colour\n\ngdi:=w.gdi\ngdi.updated:=1\n\noldbrushcolour:=gdi.brushcolour\nif colour.isdef then\n\tgxbrushcolour(w,colour)\nfi\n\noldpenstyle:=gdi.penstyle\nif mode=0 then\t\t!inside only\n\tgxstyle(w,ps_null)\nfi\n\nif height<0 then y:=y+height+1; height:=-height fi\nif width<0 then x:=x+width+1; width:=-width fi\n\nif mode=0 then\t\t!inside only, needs extra pixel width\n\trectangle(gdi.hdc,x, y,x+width+1,y+height+1)\n\tif gdi.drawmode=dm_screenmemory then\n\t\trectangle(gdi.hdc2,x,y,x+width+1,y+height+1)\n\tfi\nelse\t\t\t!inside and outside\n\trectangle(gdi.hdc,x, y, x+width, y+height)\n\tif gdi.drawmode=dm_screenmemory then\n\t\trectangle(gdi.hdc2,x,y,x+width,y+height)\n\tfi\nfi\ngxstyle(w,oldpenstyle)\ngxbrushcolour(w,oldbrushcolour)\nend\n\nexport func gxcolour(w,?colour)=\t\t!GXCOLOUR\n# colour supplied:\tset current outline colour for subsequent line drawing\n# colour omitted:\treturn current outline colour\n\ngdi:=w.gdi\n\nif colour.isdef and gdi.pencolour<>colour then\n\tgdi.pencolour:=colour\n\tgdi.xormode:=0\n\tdeleteobject(selectobject(gdi.hdc,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\tsetrop2(gdi.hdc,r2_copypen)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tdeleteobject(selectobject(gdi.hdc2,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\t\tsetrop2(gdi.hdc2,r2_copypen)\n\tfi\n\nfi\n\nreturn gdi.pencolour\nend\n\nexport proc gxsetpen(w,pen)=\ngxcolour(w,getrgb(pen))\nend\n\nexport proc gxline(w,x,y,?x2,?y2)=\t\t!GXLINE\n#gxline(w,x,y)\t\t\tDraw line from current position to x,y\n#gxline(w,x,y,x2,y2)\tDraw line from x,y to x2,y2\n\ngdi:=w.gdi\n\nif x2.isvoid then\t\t!assume 2 params\n\tx2:=x\n\ty2:=y\n\n\tmovetoex(gdi.hdc,gdi.posx, gdi.posy)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tmovetoex(gdi.hdc2,gdi.posx, gdi.posy)\n\tfi\nelse\n\tmovetoex(gdi.hdc,x, y)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tmovetoex(gdi.hdc2,x, y)\n\tfi\n\tgdi.posx:=x\n\tgdi.posy:=y\nfi\n\nlineto(gdi.hdc,x2,y2)\n\nif gdi.drawmode=dm_screenmemory then\n\tlineto(gdi.hdc2,x2,y2)\nfi\ngdi.posx:=x2\ngdi.posy:=y2\nend\n\nexport func gxwidth(w,width)=\n!get/set pen width for subsequent line drawing\ngdi:=w.gdi\nif width.isvoid then\n\treturn gdi.penwidth\nfi\n\nif gdi.penwidth<>width then\n\tgdi.penwidth:=width\n\tdeleteobject(selectobject(gdi.hdc,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\tif gdi.drawmode=dm_screenmemory then\n\t\tdeleteobject(selectobject(gdi.hdc2,createpen(gdi.penstyle,gdi.penwidth,gdi.pencolour)))\n\tfi\n\nfi\nreturn width\nEND\n\nexport proc gxlinerel(w,dx,dy)=\t\t!GXLINEREL\n#Draw line from current position, to current position + (dx,dy)\n\ngdi:=w.gdi\nmovetoex(gdi.hdc, gdi.posx, gdi.posy)\nif gdi.drawmode=dm_screenmemory then\n\tmovetoex(gdi.hdc2, gdi.posx, gdi.posy)\nfi\n!w.x+:=dx\n!w.y+:=dy\nx:=gdi.posx+dx\ny:=gdi.posy+dy\ngxline(w,x,y)\ngdi.posx:=x\ngdi.posy:=y\nend\n\nexport proc gxmove(w,x2,y2)=\t\t!GXMOVE\n#Set current position to x2,y2\n\ngdi:=w.gdi\n\nmovetoex(gdi.hdc, x2, y2)\nif gdi.drawmode=dm_screenmemory then\n\tmovetoex(gdi.hdc2,x2, y2)\nfi\ngdi.posx:=x2\ngdi.posy:=y2\nend\n\nexport proc gxmoverel(w,dx,dy)=\t\t!GXMOVEREL\n#\tSet current position to current position+(dx,dy)\ngdi:=w.gdi\n\ngdi.posx+:=dx\ngdi.posy+:=dy\n\nmovetoex(gdi.hdc,gdi.posx, gdi.posy)\nif gdi.drawmode=dm_screenmemory then\n\tmovetoex(gdi.hdc2,gdi.posx, gdi.posy)\nfi\nend\n\nexport proc gxrect(w,x,y,width,height)=\t\t!GXRECT\n#draw outline rectangle starting from x,y at top left, in current pen colour\n#overall size is width by height pixels inclusive (x,y to x+width+1,y+height-1)\n#outline is 1 pixel wide\n\ngdi:=w.gdi\ngdi.updated:=1\nif height<0 then y:=y+height+1; height:=-height fi\nif width<0 then x:=x+width+1; width:=-width fi\n\noldbrushstyle:=gdi.brushstyle\ngxbrushstyle(w,bs_hollow)\n\nrectangle(gdi.hdc,x, y, x+width, y+height)\nif gdi.drawmode=dm_screenmemory then\n\trectangle(gdi.hdc2,x, y, x+width,y+height)\nfi\ngxbrushstyle(w,oldbrushstyle)\nend\n\nexport proc gxcircle(w,x,y,r)=\t\t!GXCIRCLE\n#draw circle at centre x,y in window w, of radius r, using current pen colour\n#outline is 1 pixel wide\n\ngdi:=w.gdi\ngdi.updated:=1\noldbrushstyle:=gdi.brushstyle\ngxbrushstyle(w,bs_hollow)\n\nellipse(gdi.hdc,x-r, y-r, x+r-1, y+r-1)\nif gdi.drawmode=dm_screenmemory then\n\tellipse(gdi.hdc2,x-r, y-r, x+r-1, y+r-1)\nfi\ngxbrushstyle(w,oldbrushstyle)\nend\n\nexport proc gxfillcircle(w,x,y,r,?colour,mode=0)=\t\t!GXFILLCIRCLE\n#Draw filled circle with optional outline\n#x,y is the centre, r is the radius\n#(When the outline is drawn, the filled region is 1 pixel smaller all round)\n#colour is the colour of the filled region (current brush colour when omitted)\n#mode=1 to draw the outline, or mode=0 (default) to omit it\n#The outline is drawn in the current pen colour\ngdi:=w.gdi\n\ngdi.updated:=1\noldbrushcolour:=gdi.brushcolour\nif colour.isdef then\n\tgxbrushcolour(w,colour)\nfi\n\noldpenstyle:=gdi.penstyle\nif mode=0 then\t\t!inside only\n\tgxstyle(w,ps_null)\nfi\n\nellipse(gdi.hdc,x-r, y-r, x+r-1, y+r-1)\nif gdi.drawmode=dm_screenmemory then\n\tellipse(gdi.hdc2,x-r, y-r, x+r-1, y+r-1)\nfi\n\ngxstyle(w,oldpenstyle)\ngxbrushcolour(w,oldbrushcolour)\nend\n\nexport func gxpixel(w,x,y,?colour)=\t\t!GXPIXEL\n#colour provided: set pixel at point x,y of window w to colour\n#colour omitted: return pixel colour from point x,y\n!set pixel at x,y with given rgb colour, or return pixel value if omitted (-1)\nw.gdi.updated:=1\n\nif colour.isvoid then\t\t!get pixel\n\tres:=getpixel(w.gdi.hdc, x, y)\n\tif w.gdi.drawmode=dm_screenmemory then\n\t\tgetpixel(w.gdi.hdc2, x, y)\n\tfi\n\treturn res\nelse\n\tsetpixel(w.gdi.hdc,x, y, colour)\n\tif w.gdi.drawmode=dm_screenmemory then\n\t\tsetpixel(w.gdi.hdc2,x,y,colour)\n\tfi\n\treturn colour\nfi\nend\n\nexport func gxcaption(w,?caption)=\t\t!GXCAPTION\n#caption omitted:  return current window caption text\n#caption provided: set new window caption text\n\ncase w.windclass\nwhen window_class,popup_class then\n\n\tif caption.isdef then\t\t!set text\n\t\tsetwindowtext(w.gdi.hwnd,caption)\n\t\treturn caption\n\telse\n\t\tbuffer:=new(array,byte,512)\n\t\tn:=getwindowtext(w.gdi.hwnd,int(&buffer),buffer.len)\n\t\tif n then\n\t\t\ts:=makestr(&buffer,n)\t\t!needs assigment to ensure a copy is made befor buffer\n\t\t\t\t\t\t\t\t\t\t!is freed (assignment of return value might do the same)\n\t\telse\n\t\t\ts:=\"\"\n\t\tfi\n\t\treturn s\n\tfi\nesac\n\nif caption.isdef then\t\t!set text\n\tw.text:=caption\n\tgxdraw(w)\nfi\n\nreturn w.text\nend\n\nexport proc gxtext(w,s,?x,?y)=\t\t!GXTEXT\n#Display text s\n#Text is drawn starting at (x,y) when provided, otherwise at current position\n#insertion point refers either to base line, or to top left of cell (not sure)\n#Text is drawn in current font, size, style and mode\n#Text typically contains no control codes, but can also contain cr and lf (also\n#tabs, but currently position isn't changed). However, text with control codes is\n#drawn a character at a time\n#Finishes with current position set to the end of the text\n\n!uses chr(16) for reverse tab. Reverse tabs are usually encoded as:\n!  chr(9)+chr(16), ie. normal tab then reverse tab\n!Reverse tab, after tabbing to next stop, then moves position back by width\n!of next substring\n\nreturn when s=\"\"\n\ngdi:=w.gdi\n\nif x.isvoid then x:=gdi.posx fi\nif y.isvoid then y:=gdi.posy fi\ngdi.updated:=1\n\n!scan the string and create a table of substrings and control codes\nstartpos::=lengths::=()\nngroups:=0\n\nforeach i,c in s do\n\tif c<32 then\n\t\t++ngroups\n\t\tstartpos[ngroups]:=i\n\t\tlengths[ngroups]:=0\n\telse\n\t\tif ngroups and lengths[ngroups] then\t\t!extend this group\n!CPL =LENGTHS.BOUNDS, NGROUPS,=LENGTHS\n\t\t\t++lengths[ngroups]\n\t\telse\t\t\t\t\t\t\t\t\t\t!start new substring group\n\t\t\t++ngroups\n\t\t\tstartpos[ngroups]:=i\n\t\t\tlengths[ngroups]:=1\n\t\tfi\n\tfi\nod\n\nfor i,l in lengths do\n\tpos:=startpos[i]\n\tif l then\n\t\tslicex:=pos..pos+l-1\n\t\ttextout(gdi.hdc,x, y,s.[slicex],l)\n\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\ttextout(gdi.hdc2,x,y,s.[slicex],l)\n\t\tfi\n\t\tx +:= gxtextwidth(w,s.[slicex])\n\n\telse\t\t\t\t!Deal with control codes\n\t\tcase s.[pos]\n\t\twhen 13 then\n\t\t\tx:=0\n\t\twhen 10 then\n\t\t\ty+:=20\t\t\t\t!NEEDS TO PICK CURRENT FONT DIMS\n\n\t\twhen 9,16 then\t\t\t!16 will be used as reverse tab\n\t\t\tcurrx:=x\n\t\t\tx:=0\n\t\t\tfor t in tabstops do\n\t\t\t\tx+:=t*chx\t\t\t\t!MUST BE CURRENT FONT NOT CHX\n\t\t\t\tif x>currx then exit fi\n\t\t\tod\n\t\t\twhile x<=currx do x+:=chx*8 od\n\n\t\t\tif s.[pos]=16 and i<ngroups and lengths[i+1] then\t!reverse offset for next substring\n\t\t\t\tpos:=startpos[i+1]\n\t\t\t\tx -:= gxtextwidth(w,s.[pos..pos+lengths[i+1]-1])+1\n\t\t\tfi\n\n\t\tesac\t\n\tfi\nod\n\ngdi.posx:=x\ngdi.posy:=y\nend\n\nexport func gxtextcolour(w,?colour,?bgndcolour)=\t\t!GXTEXTCOLOUR\n#Set either text foreground colour or background colour, or both, or neither,\n#depending on which are supplied\n#Text colours will be colour indices, not rgb\n#Always returned current or new foreground\n\ngdi:=w.gdi\n\nif colour.isdef and colour<>w.style.textfgnd then\n\tw.style.textfgnd:=colour\n\tsettextcolour(gdi.hdc,getrgb(colour))\n\tif gdi.drawmode=dm_screenmemory then\n\t\tsettextcolour(gdi.hdc2,getrgb(colour))\n\tfi\nfi\nif bgndcolour.isdef and bgndcolour<>w.style.textbgnd then\n\tgxbgndcolour(w,bgndcolour)\nfi\n\nreturn w.style.textfgnd\nend\n\nexport func gxtextwidth(font,?s)=\t\t!GXTEXTWIDTH\n# font is a window, or a font number within fonttable\n# font can be zero (then uses font 1)\n# return total pixel width of string s, using given font\n\nif s=\"\" then return 0 fi\n\n!if not font.isint then\t\t\t!aasume font is window\n!CPL =FONT\n!CPL =FONT.TYPE\n\n\n!if not font.ispointer then\t\t\t!aasume font is window\nif not font.isint then\t\t\t!aasume font is window\n\tfont:=font.gdi.font\nfi\nif font=0 then font:=1 fi\n\nselectobject(screendc,fonttable[font])\nwidthheight:=new(ws_point)\n\n!CPL =S\n\ngettextextentpoint32(screendc,s,s.len,&widthheight)\n\nreturn widthheight.x\nend\n\nexport func gxloadfont(n,facename,?style,height=0,width=0)=\t\t!GXLOADFONT\n#define new font\n#N is index into fonttable\n#facename is the name of the font\n#Style is optional font style, a string containing any of:\n#\tB,b\t\tBold\n#\tI,i\t\tItalic\n#\tU,u\t\tUnderline\n#\tS,s\t\tStrikeout\n#Height is height of text (default 0, gives default height?)\n#Weight is width; defautl 0 normally used for normal aspect of text\n\n!CPL \"GXLOADFONT\"\n\nif n<=0 then return 0 fi\n!n:=min(n,nglobalfonts)\n\nif style.isvoid then style:=\"\" fi\n\nif n<=nglobalfonts and fonttable[n] then\t\t\t!remove existing font\n\tigxremovefont(n)\nfi\n\np:=style\nbold:=400\nitalic:=0\nunderline:=0\nstrikeout:=0\nfor c in style do\n\tcase asc(convuc(c))\n\twhen 'B' then bold:=700\n\twhen 'I' then italic:=1\n\twhen 'U' then underline:=1\n\twhen 'S' then strikeout:=1\n\tesac\nod\n\nhfont:=createfont(\n\tfacename:\tfacename,\n\theight:\t\theight,\n\twidth:\t\twidth,\n\tbold:\t\tbold,\n\titalic:\t\titalic,\n\tunderline:\tunderline,\n\tcharset:\t0,\n\tquality:\t2,\n\tescapement:\t0,\n\torientation:0)\n\nif hfont=0 then\n\thfont:=getstockobject(system_font)\nfi\n\n!CPL =FONTTABLE.BOUNDS,=N\nfonttable[n]:=hfont\nnglobalfonts:=max(n,nglobalfonts)\n\n!CPL =SCREENDC\n!CPL =FONTTABLE[N]\nselectobject(screendc,fonttable[n])\n\ntm:=new(ws_textmetrics)\n\ngettextmetrics(screendc,&tm)\n\nCPL \"SETFONTDIM\"\nfontdimtable[n]::=ws_point(tm.avecharwidth, tm.height+tm.externalleading)\nfontvdimtable[n]::=ws_point(tm.ascent, tm.descent)\n\nselectobject(screendc,getstockobject(system_font))\n\nreturn n\nend\n\nproc igxremovefont(n)=\n!unload font n, free table entry\n\nunless n in 1..nglobalfonts then return end\nif fonttable[n]=0 then return fi\t!already freed\n\n!w:=windowlist\n!while w<>nil do\n!\tif w.gdi.hdc and w.gdi.font>0 then\t\t!font was in use, set as undefined\n!\t\tw.gdi.font:=1\n!\t\tselectobject(w.gdi.hdc,fonttable[w.gdi.font])\n!\t\tif w.gdi.hdc2 then\n!\t\t\tselectobject(w.gdi.hdc2,fonttable[w.gdi.font])\n!\t\tfi\n!\tfi\n!\tw:=w.nextwind\n!od\n\ndeleteobject(fonttable[n])\t\t!get rid of this font\nfonttable[n]:=0\nend\n\nexport func gxfont(w,font=1)=\t\t!GXFONT\n# select font from font table for subsequent text display; default is font 1\n\nif not w then w:=wapplic fi\nif not w then w:=wscreen fi\ngdi:=w.gdi\n\nif font.isdef and font<>gdi.font then\n\tif font not in 1..nglobalfonts then\n\t\tabort(\"Bad font number \"+tostr(font))\n\tfi\n\tgdi.font:=font\n\tif fonttable[font]=0 then\n\t\tabort(\"Font not in use \"+tostr(font))\n\tfi\n\n\toldhfont:=selectobject(gdi.hdc,fonttable[font])\n\tsendmessage(gdi.hwnd,wm_setfont,fonttable[font],0)\n\n\tif gdi.drawmode=dm_screenmemory then\n\t\toldhfont:=selectobject(gdi.hdc2,fonttable[font])\n\t\tsendmessage(gdi.hwnd2,wm_setfont,fonttable[font],0)\n\tfi\n\tif fontdimtable[font].x=0 then\t\t!set up dims\n\t\tgxchardim(font,0)\n\tfi\nfi\nreturn gdi.font\nend\n\nfunc hascontrolchars(s)=\t\t!TESTCTRLCHAR\n!scan string s looking for control chars\n!return 1 if control chars (<20H) are present\n\nforeach c in s do\n!for c in s do\n\tif c<32 then return 1 fi\nod\nreturn 0\nend\n\nexport func gxchardim(font,vert=0)=\t\t\t!GXCHARDIM\n#return font char average width/height info as a point rec\n#wfont is a font number, or hwindow when the current font in that window is used\n#vert=1 means get ascent/descent pair instead of (vert=0) average width/height\n\n!if not font.isint then\n!CPL FONT\n!CPL FONT.TYPE\n\nif not font.isint then\n\tfont:=font.gdi.font\nfi\nif font=0 then font:=1 fi\n!\n!CPL =FONTDIMTABLE, =FONT\n\nif fontdimtable[font].x=0 then\t\t!probably stock fonts not setup with gxloadfont\n\tselectobject(screendc,fonttable[font])\n\ttm:=new(ws_textmetrics)\n\tgettextmetrics(screendc,&tm)\n\n\tfontdimtable[font]::=ws_point(tm.avecharwidth, tm.height+tm.externalleading)\n\n\tfontvdimtable[font]::=ws_point(tm.ascent, fontvdimtable[font].y:=tm.descent)\n\n\tselectobject(screendc,getstockobject(ansi_var_font))\nfi\n\nif vert then\n\treturn fontvdimtable[font]\nfi\n\nreturn fontdimtable[font]\nEND\n\nexport func gxbgndcolour(w,?colour)=\t\t!GXBGNDCOLOUR\n#Set background colour (for text mainly)\n#colour will be a colour index\n#return current colour when omitted\ngdi:=w.gdi\n\nif colour.isdef then\n\n\tif colour<>w.style.textbgnd then\n\t\tw.style.textbgnd:=colour\n\t\tsetbkcolour(gdi.hdc,getrgb(colour))\n\t\tif gdi.drawmode=dm_screenmemory then\n\t\t\tsetbkcolour(gdi.hdc2,getrgb(colour))\n\t\tfi\n\tfi\n\tgxbgndmode(w,(colour<>w.style.windbgnd|1|0))\nfi\nreturn w.style.textbgnd\nend\n\nexport func gxbgndmode(w,?mode)=\t\t!GXBGNDMODE\n#\tmode supplied: set new background mode:\n#\t\t1 y Y T\t\tSet opaque (T for True? Looks like Transparent)\n#\t\t0 n N F\t\tSet Transparent\n\ngdi:=w.gdi\n\nif mode.isdef  then\n\tcase mode\n\twhen 1,'y','Y','T' then\n\t\tw.style.bgndmode:=opaque\n\telse\n\t\tw.style.bgndmode:=transparent\n\tesac\n\n\tsetbkmode(gdi.hdc,mode+1)\n\tif gdi.drawmode=dm_screenmemory then\n\t\tsetbkmode(gdi.hdc2,mode+1)\n\tfi\nfi\nreturn w.style.bgndmode\nend\n\nexport proc gxhighlight(w,x,y,width,height)=\t\t!GXHIGHLIGHT\n#Invert rectangular region\nconst dstinvert=0x00550009\t!patblt\ngdi:=w.gdi\n\ngdi.updated:=1\npatblt(gdi.hdc, x, y, width,height,dstinvert)\nif gdi.drawmode=dm_screenmemory then\n\tpatblt(gdi.hdc2, x,y, width,height,dstinvert)\nfi\nend\n\nexport proc gxbitblt(w,x2,y2,width,height,x,y)=\t\t\t!GXBITBLT\n#Copy rectangular region of window to another location\ngdi:=w.gdi\ngdi.updated:=1\nbitblt(gdi.hdc, x2, y2, width,height,\n\t\t\tgdi.hdc,x,y,srccopy)\n\nif gdi.drawmode=dm_screenmemory then\n\tbitblt(gdi.hdc2,x2,y2,width,height,gdi.hdc2,x,y,srccopy)\nfi\nend\n\nexport func gxaskmess(mode=0)=\n#wait for next message and return message number\n!#return 0 if close or quit message seen\n#return MM_CANCEL if close or quit message seen\n#some messages will be ignored here (processsed via procmess) and will wait for next\n#mode=0\t\tReturn currmess.message\n#mode=1\t\tReturn currmess.message, but if a mm_command message, then return\n#\t\t\tthe command id. This means message numbers and command ids share the\n#\t\t\tsame space. This should work because messages are below 200, and ids above 200\n\nrepeat\n\tif mxwait_mm_message()=0 then\n!CPL \"GAM2\"\n!CPL\n!STOP\n!\t\treturn 0\n\t\treturn mm_cancel\n\tfi\n\tif quitmess then\n return mm_cancel fi\n\tx:=process_message(currmess)\n\n\tif currmess.message=mm_key and currmess.a=27 then\n!\t\treturn 0\n\t\treturn mm_cancel\n\tfi\n\nuntil x=thismess\t\t\t\t\t!message ready to return\n\nif mode=1 and currmess.message=mm_command then\n\treturn currmess.a\nfi\n\nreturn currmess.message\nend\n\nfunc process_message(mess)=\n#user or default event processing for mm message\n#will call event handler if there is one\n#returns 1 (skipmess) if message has been processed here; caller must wait for another message\n#returns 0 (thismess) caller should deal with this message (it has not been processed, or has beenbut caller can process it too)\n\nif mess.wind=nil then\n\treturn thismess\nfi\n\ncase mess.message\nwhen mm_close then\n\treturn thismess\nesac\n\nstatus:=domessage(mess)\n\nreturn status\nend\n\nexport proc docs=\n!export proc where dostringzs for entire lib can go\n#Option dicts: used as args to gccreatewindow/gxcreatechildwindow:\n#\twf_border\t\tBorder style; see wbs_ enums\n#\twf_resize\t\t1 for resizable border (for top-level windows)\n# wf_hscroll\t\t1 for horizontal scrollbar\n# wf_vscroll\t\t1 for vertical scrollbar\n# wf_menu\t\t\t1 for a menubar\n# wf_caption\t\t1 for a caption bar (needs to be the right kind of border too)\n# wf_max\t\t\t1 for a max button\n# wf_minmax\t\t1 for a min/max buttons\n# wf_sysmenu\t\t1 for a system menu (right-click on top left I think)\n# wf_desktop\t\t1 to fill desktop\n# wf_clip\t\t\t1 to clip windows to desktop\n# wf_show\t\t\t1 to show window after creating\n# wf_iframe\t\t1 for pos/dim to refer to frame rather than client area\n# wf_cent\t\t\t1 to centre window\n# wf_toolwind\t\t1 for tool window (not sure what this means)\n\nend\n\nfunc newwindow(hwnd,index,windclass,borderstyle)=\n\nw:=new(rwindow,0)\nw.windclass:=windclass\n!w.style.borderstyle:=borderstyle\nw.index:=index\nw.childlist::=()\nw.owner:=nil\n\naddwindow(w)\nwx_setw(hwnd,w.gindex)\nreturn w\nend\n\nexport func getrgb(index)=\nif index=0 then return 0 fi\nreturn colourvalues[index]\nend\n\nfunc readstyle(owner,windclass,options)=\n!process gx options stored in the given dict type\n!return a stylerec all filled in\n\nif options.usertype=stylerec then\t\t\t!already a stylerec\n\treturn options\nfi\n\nss:=new(stylerec)\nif options.isvoid then\t\t\t\t!use bunch of defaults\n\td::=defstyle\n\td.border:=defaultborderstyles[windclass]\n\treturn d\nfi\n\nss.border\t:=options{ss_border,defaultborderstyles[windclass]}\nss.justify\t:=options{ss_justify,defstyle.justify}\nss.vjustify\t:=options{ss_vjustify,defstyle.vjustify}\nss.textfgnd\t:=options{ss_textfgnd,defstyle.textfgnd}\nss.textbgnd\t:=options{ss_textbgnd,defstyle.textbgnd}\nss.bgndmode\t:=options{ss_bgndmode,defstyle.bgndmode}\n\nss.iframe\t:=options{ss_iframe,0}\n\nss.hilitetype\t:=options{ss_hilitetype,defstyle.hilitetype}\nss.marktype\t:=options{ss_marktype,(ss.hilitetype|0|defstyle.marktype)}\nss.imark\t:=options{ss_imark,defstyle.imark}\n\nif windclass in [toggle_class, select_class,mark_class] and ss.marktype then\n\tdef:=owner.style.windbgnd\nelse\n\tdef:=defstyle.windbgnd\nfi\n\nss.windbgnd\t:=options{ss_windbgnd,def}\nss.hscroll\t:=options{ss_hscroll,0}\nss.vscroll\t:=options{ss_vscroll,0}\nss.lbchange\t:=options{ss_lbchange,0}\nss.returnmess\t:=options{ss_returnmess,0}\nss.noupdate\t:=options{ss_noupdate,0}\n\nreturn ss\nend\n\nexport func gxpanel(owner,pos,dim,?style)=\nss:=readstyle(owner,panel_class,style)\n\nw:=gxcontrol(owner,panel_class,pos,dim,ss)\n\ngxdraw(w)\n\nreturn w\nend\n\nexport func gxstatusbar(owner,pos,dim,?style)=\n\nss:=readstyle(owner,statusbar_class,style)\n\nif ss.iframe=0 then\t\t\t\t\t!frame not included, but can't have it leaking outside owner\n\tbs:=ss.border\n\tif bscat[bs]<>'I' then\t\t\t!do adjustments\n\t\tdim+:=bswidths[bs].y1+bswidths[bs].y2\n\tfi\n\tss.iframe:=1\t\t\t\t\t!stop gxcontrol expanding dims\nfi\n\n(ecapos,ecadim):=gxclientarea(owner)\n\nif pos.isint then pos:=chr(pos) fi\n!if pos.ispointer then pos:=chr(pos) fi\nif convuc(pos) in \"T TOP\" then\t\t\t!along the top\n\tpos:=ecapos\n\tdir:='T'\nelse\t\t\t\t\t\t\t\t\t!along the bottom\n\tpos:=(ecapos[1],ecadim[2]-dim+ecapos[2])\n\tdir:='B'\nfi\ndim:=(ecadim[1],dim)\n\nss.dir:=dir\n\nw:=gxcontrol(owner,statusbar_class,pos,dim,ss)\n\ngxdraw(w)\n\nreturn w\nend\n\nexport func gxframebar(owner,pos,dim,?style)=\n\nss:=readstyle(owner,framebar_class,style)\nif ss.iframe=0 then\t\t\t\t\t!frame not included, but can't have it leaking outside owner\n\tbs:=ss.border\n\tif bscat[bs]<>'I' then\t\t\t!do adjustments\n\t\tdim+:=bswidths[bs].y1+bswidths[bs].y2\n\tfi\n\tss.iframe:=1\t\t\t\t\t!stop gxcontrol expanding dims\nfi\n\n(ecapos,ecadim):=gxclientarea(owner)\n\n!if pos.isint then pos:=chr(pos) fi\nif pos.ispointer then pos:=chr(pos) fi\nif convuc(pos) in \"L LEFT\" then\t\t\t!along the left\n\tpos:=ecapos\n\tdir:='L'\nelse\t\t\t\t\t\t\t\t\t!along the right\n\tpos:=(ecadim[1]-dim+ecapos[1],ecapos[2])\n\tdir:='R'\nfi\ndim:=(dim,ecadim[2])\n\nss.dir:=dir\n\nw:=gxcontrol(owner,\tframebar_class,pos,dim,ss)\n\ngxdraw(w)\n\nreturn w\nend\n\nexport func gxbutton(owner,pos,dim,caption,?style,id=201,enable=1)=\n#create clickable button\n#returns rwindow\n\nss:=readstyle(owner,button_class,style)\n\nw:=gxcontrol(owner,button_class,pos,dim,ss)\nw.id:=id\n\nw.text:=caption\nw.enable:=enable\ngxdraw(w)\n\nreturn w\nend\n\nexport func gxlabel(owner,pos,dim,caption,?style)=\n#create static label button\n#returns rwindow\n\nss:=readstyle(owner,label_class,style)\n\nw:=gxcontrol(owner,label_class,pos,dim,ss)\n\n!CPL \"///////GXLABEL\",CAPTION\nw.text:=caption\ngxdraw(w)\n\nreturn w\nend\n\nexport func gxgroup(owner,pos,dim,?style)=\n#create group window that encapsulates a set of controls\n#returns rwindow\n\nss:=readstyle(owner,group_class,style)\n\nw:=gxcontrol(owner,group_class,pos,dim,ss)\n\ngxdraw(w)\n\nreturn w\nend\n\nfunc gxcontrol(owner,windclass=button_class,pos,dim,?ss)=\n\nif ss.type=dict or ss.isvoid then\n\tss:=readstyle(owner,windclass,ss)\nfi\nwb:=wbs_none\ncase ss.border\t\t\t!find wbs- version of windows-drawn borders\nwhen bs_simplew then\n\twb:=wbs_simple\nesac\n\nif ss.iframe and bscat[ss.border]<>'I' then\n\twidths:=bswidths[ss.border]\n\tpos[1]+:=widths.x1\n\tpos[2]+:=widths.y1\n\tdim[1]-:=widths.x1+widths.x2\n\tdim[2]-:=widths.y1+widths.y2\nFI\n\nhwnd:=wx_createcontrol(pos:pos,dim:dim,border:wb,owner:owner.gdi.hwnd)\n\nif hwnd=0 then\n\tabort(\"Can't create control window\")\nfi\n\nw:=newwindow(hwnd,0,no_class,ss.border)\nw.windclass:=windclass\nw.style:=ss\nw.owner:=owner\nw.enable:=1\n\nsetwindowdims_c(w,hwnd)\nsetupgdi(w,hwnd)\n\ngxdrawmode(w,dm_screenmemory)\n\ngxfont(w,labelfont)\n\ngxtextcolour(w,w.style.textfgnd,w.style.textbgnd)\n\ngxbgndmode(w,w.style.bgndmode)\n\n!link into owner\nw.owner.childlist append:=w\nw.index:=w.owner.childlist.upb\n\nreturn w\nend\n\nexport func gxtoggle(owner,pos,dim,caption=\"\",linkvar,?style,id=201,enable=1)=\n\n(posx,posy):=pos\n(dimx,dimy):=dim\ntextoffset:=0\n\n\nss:=readstyle(owner,toggle_class,style)\n\n!work out whether an auxiliary window is needed\n\nif ss.marktype then\n\tif ss.imark=0 then\t\t\t!dims don't include the mark\n\t\tposx-:=markdim\n\t\tdimx+:=markdim\n\t\ttextoffset:=markdim\n\tfi\nfi\n\nw:=gxcontrol(owner,toggle_class,(posx,posy),(dimx,dimy),ss)\n!RETURN 0\nw.linkvar:=linkvar\nw.id:=id\nw.text:=caption\nw.attrs:=togglerec(textoffset,1)\nw.enable:=enable\n\nif w.style.marktype then\n!\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id,style:style)\n\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id, style:ss)\nfi\n\ngxdraw(w)\nreturn w\nend\n\nexport func gxselect(owner,pos,dim,caption=\"\",linkvar,onvalue,?style,id=201,enable=1)=\n\n(posx,posy):=pos\n(dimx,dimy):=dim\ntextoffset:=0\n\nss:=readstyle(owner,select_class,style)\n\n!work out whether an auxiliary window is needed\nif ss.marktype and ss.imark=0 then\t\t\t!dims don't include the mark\n\tposx-:=markdim\n\tdimx+:=markdim\n\ttextoffset:=markdim\nfi\n\nw:=gxcontrol(owner,select_class,(posx,posy),(dimx,dimy),ss)\n\nw.linkvar:=linkvar\nw.id:=id\nw.text:=caption\nw.attrs:=togglerec(textoffset,onvalue)\nw.enable:=enable\nif w.style.marktype then\n\tgxmark(owner:w,pos:(0,(w.dimy-markdim)%2),id:id, style:style)\nfi\n\ngxdraw(w)\nreturn w\nend\n\nexport proc showmessage(mess)=\nRETURN\nCPL MESS.MESSAGE\ncp \"Message:\",leftstr(messagenames[mess.message],20)\ncp \"A:\",,mess.a,\"B:\",,mess.b\ncp \" (X:\",,mess.x,\"Y:\",,mess.y,,\") Buttons:\",mess.state:\"b\"\n\ncpl \"\tWindow:\",mess.wind.name\nend\n\nfunc domessage(mess)=\n\nm:=mess.message\nw:=mess.wind\n\nIF W.GDI=0 THEN PCERROR(\"DOM/GDI=0\") FI\n\ncase m\nwhen mm_move,mm_setcursor then\n\treturn skipmess\nesac\n\n!CPL \"DOMESSAGE\",W.TYPE,=W.DIMX\n\n!CPL =M\n!CPL =MESSAGENAMES[M]\n!CPL =W.WINDCLASS\n!CPL messhandlertable[m,w.windclass].TYPE\n!!CPL INT(messhandlertable[m,w.windclass].TYPE)\n!CPL messhandlertable[m,w.windclass]\n\nx:=messhandlertable[m,w.windclass](mess,w)\nreturn x\nend\n\nproc init_handlertables=\n\n!messhandlertable::=new(list,mm_null..mm_last,new(list,no_class..dummy_class,0))\n!CPL =MM_NULL, =MM_LAST, =NO_CLASS\n\n\tmesshandlertable:=maketable(mm_null..mm_last, no_class..dummy_class, nil)\n\tactionhandlertable:=maketable(actionnames.bounds, no_class..dummy_class, nil)\n\n!$pcldata('PROCINIT')\n\tmessalltable:=new(list,mm_null..mm_last,0)\t\t!for all mess_mess_all handlers\n\tfnallall:=nil\t\t\t\t\t\t\t\t\t!for single mess_all_all handler\n\tfnfixups:=nil\n\n\tactionalltable:=new(list,actionnames.bounds,0)\n\tallprocs:=$procsymbols()\n\n\tforall d in allprocs do\n\t\tfnptr:=d\n\t\tfnname:=$symbolname(d)\n\t\t(name,messname,windname):=splitstring(fnname,\"_\")\t\t\t!split func name\n\n\t\tif fnname=\"gxhandler_fixups\" then\n\t\t\tfnfixups:=fnptr\n\t\telsif leftstr(fnname,5)=\"mess_\" then\n\t\t\tif messname=\"all\" and windname=\"all\" then\n\t\t\t\tfnallall:=fnptr\n\t\t\telse\n!CPL \"///\",D,NAME,MESSNAME,WINDNAME\n!IF WAITKEY()=27 THEN STOP FI\n\t\t\t\tmessage:=(\"mm_\"+messname) inx messagenames\n!\t\t\t\tmessage:=(\"mm_\"+messname) in messagenames\n!CPL \"mm_\"+MESSNAME,MESSAGENAMES.BOUNDS,MESSAGE,\"//\",messname\n!CPL MESSAGENAMES\n\t\t\t\tif not message.isfound then\n\t\t\t\t\tABORT(\"CAN'T FIND MESSAGE <\"+messname+\">\")\n\t\t\t\tfi\n\n\t\t\t\tif windname=\"all\" then\t\t\t\t!assume <mess> all\n\t\t\t\t\tmessalltable[message]:=fnptr\n\t\t\t\telse\n!CPL \"DOING MESS\",MESSAGENAMES[MESSAGE],WINDNAME\n\t\t\t\t\tmesshandlertable[message,WX:=findwindclass(windname)]:=fnptr\n!MX:=MESSAGE\n!IF MX=24 AND WX=14 THEN\n!\tCPL \"SET MHT TO\",MESSHANDLERTABLE[MX,WX].TYPE\n!\tCPL \"SET MHT TO\",MESSHANDLERTABLE[MX,WX],=FNPTR\n!WAITKEY()\n!ELSE\n!\tCPL \"SETMESS\",MX,WX; WAITKEY()\n!FI\n!CPL \"DOING MESS\",messname,WINDNAME,findwindclass(windname)\n\t\t\t\tfi\n\t\t\tfi\n\n\t\telsif leftstr(fnname,8)=\"do_draw_\" or leftstr(fnname,10)=\"do_update_\" then\n!CPL \"WX:\",NAME,MESSNAME,WINDNAME,\"//\",FNNAME\n\t\t\taction:=messname+\"_w\" inx actionnames\n!\t\t\taction:=messname+\"_w\" in actionnames\n!\t\t\tif action<actionnames.lwb then\n\t\t\tif not action.isfound then\n\t\t\t\tABORT(\"CAN'T FIND ACTION \"+MESSNAME)\n\t\t\tfi\n\t\t\tif windname=\"all\" then\n\t\t\t\tactionalltable[action]:=fnptr\n\t\t\telse\n\t\t\t\twindclass:=findwindclass(windname)\n\t\t\t\tactionhandlertable[action,windclass]:=fnptr\n!CPL \"DOING ACTION\",messname,WINDNAME,findwindclass(windname),=ACTION,=WINDCLASS\n\t\t\tfi\n\t\tfi\n\tod\n\n!!do some manual fixups\n!CPL \"A\",=MESSHANDLERTABLE[24,14].TYPE\n\tif fnfixups then\n\t\tfnfixups()\n\tfi\n!CPL \"B\",=MESSHANDLERTABLE[24,14].TYPE\n\n\tfor mx:=0 to mm_last do\n\t\tfor wx:=0 to dummy_class do\n\t\t\tif not messhandlertable[mx,wx] then\n\t\t\t\tmesshandlertable[mx,wx]:=(messalltable[mx]|messalltable[mx]|fnallall)\n!IF MX=24 AND WX=14 THEN\n!\tCPL \"SET MHT TO\",MESSHANDLERTABLE[MX,WX].TYPE\n!\tCPL \"SET MHT TO\",MESSHANDLERTABLE[MX,WX]\n!WAITKEY()\n!FI\n!\n\t\t\tfi\n\t\tod\n\tod\n\n!CPL =MESSHANDLERTABLE[24,14].TYPE\n!! WAITKEY()\n!STOP\n\n\tif not fnallall then\n\t\tpcerror(\"Can't find all/all mess handler\")\n\tfi\n\n!\tfor ax:=1 to last_w do\n\tfor ax:=1 to DRAW_w do\n\t\tfor wx:=0 to dummy_class do\n\t\t\tif not actionhandlertable[ax,wx] then\n\t\t\t\tif not actionalltable then\n\t\t\t\t\tpcerror(\"No DO/ALL handler for:\"+actionnames[ax])\n\t\t\t\tfi\n!CPL \"MISSING ACTION HANDLER\",ACTIONNAMES[AX],WINDOWCLASSNAMES[WX],=AX,=WX,=ACTIONHANDLERTABLE[AX,WX]\n\t\t\t\tactionhandlertable[ax,wx]:=actionalltable[ax]\n!\t\t\tactionhandlertable[ax,wx]::=actionalltable[ax]\n\t\t\tfi\n\t\tod\n\tod\n\n!\tCPL \"INITTABLES DONE\"\n\nend\n\nfunc findwindclass(name)=\n\twindclass:=name+\"_class\" inx windowclassnames\n\tunless windclass.isfound then\n\t\tABORT(\"CAN'T FIND WINDOW \"+windname)\n\tend\n\treturn windclass\nend\n\nexport proc gxdraw(w)=\nfnptr:=actionhandlertable[draw_w,w.windclass]\n!CPL \"GXDRAW\",=FNPTR,=DRAW_W, W.WINDCLASS,ACTIONHANDLERTABLE[DRAW_W,W.WINDCLASS]\n\nif fnptr then\n\tfnptr(w)\nelse\n\tcpl \"NO DRAW HANDLER\",windowclassnames[w.windclass],w.name\n\twaitkey()\n!\twaitsec(1)\n\tstop\nfi\nend\n\nexport proc gxupdate(w)=\nfnptr:=actionhandlertable[update_w,w.windclass]\nif fnptr then\n\tfnptr(w)\nelse\n\tgxdraw(w)\nfi\nend\n\nexport proc eventloop=\ndo\n\tm:=gxaskmess()\n\n\tSHOWMESSAGE(CURRMESS)\n\n\tcase m\n\twhen 0,mm_cancel then\n\t\treturn\n\tesac\n\nod\nend\n\nexport func gxeditbox(owner,pos,dim,linkvar,?style,id=201,enable=1)=\n\nss:=readstyle(owner,editbox_class,style)\n\nw:=gxcontrol(owner,editbox_class,pos,dim,ss)\n\nw.linkvar:=linkvar\nw.id:=id\nw.attrs:=new(editboxrec)\n!CPL \"EDITBOX\",W.ATTRS.TEXTPOS\nw.attrs.currpos:=linkvar^.len+1\nw.enable:=enable\n\ngxdraw(w)\n!paintselect(w)\nreturn w\nend\n\nexport proc gxebchange(w,?linkvar,charpos=-1)=\n\nif linkvar.isdef then\n!$SETDEBUG(1)\n!CPL \"EBCHANGE\"\n\n\tw.linkvar:=linkvar\nfi\n\nif charpos=-1 then\n\tw.attrs.currpos:=w.linkvar^.len+1\nelse\n\tw.attrs.currpos:=charpos\nfi\ngxupdate(w)\nend\n\nexport proc gxsetlbdata(w,linkvar,?pos)=\nw.linkvar:=linkvar\nif pos.isvoid then\n\tpos:=(linkvar^|1|0)\nfi\nw.attrs.currpos:=pos\n\nif w.childlist[1] then\n!\tgxsetscrolllimits(ws,linkvar^.bounds,w.attrs.rows)\n\tgxsetscrolllimits(ws,getlvbounds(linkvar),w.attrs.rows)\n\tgxscrollpos(ws,pos)\nfi\nend\n\nexport proc gxsetlbpos(w,pos)=\n!change in pos\nw.attrs.currpos:=pos\n\n!work out screen row\nif pos then\n\toldpagepos:=w.attrs.pagepos\n\tif pos<oldpagepos then\n\t\tw.attrs.pagepos:=pos\n\telsif pos>oldpagepos+w.attrs.rows-1 then\n\t\tw.attrs.pagepos:=pos-w.attrs.rows+1\n\tfi\n\tif w.attrs.pagepos<>oldpagepos then\n\t\tif w.childlist then\n\t\t\tgxscrollpos(w.childlist[1],w.attrs.pagepos)\n\t\tfi\n\t\tm:=mm_draw\n\telse\n\t\tm:=mm_update\n\tfi\nelse\n\tm:=mm_draw\nfi\n\npostmess(w,m)\nif w.style.lbchange then\n\tpostmess(w,mm_lbchange,w.attrs.currpos)\nfi\nend\n\nexport proc gxsetlbpage(w,pagepos)=\n!change in pagepos (originates from scrollbar message)\nw.attrs.pagepos:=pagepos\n\noldpos:=w.attrs.currpos\nif oldpos<pagepos then\n\tw.attrs.currpos:=pagepos\nelsif oldpos>=pagepos+w.attrs.rows then\n\tw.attrs.currpos:=pagepos+w.attrs.rows-1\nfi\n\nif w.childlist then\n\tgxscrollpos(w.childlist[1],pagepos)\nfi\n\npostmess(w,mm_draw)\nif w.style.lbchange and oldpos<>w.attrs.currpos then\n\tpostmess(w,mm_lbchange,w.attrs.currpos)\nfi\nend\n\nexport func gxlistbox(owner,pos,dim,linkvar,?style,id=201,rows=0,pitch=0,offset=0)=\n\nss:=readstyle(owner,listbox_class,style)\n\n(dimx,dimy):=dim\nif ss_vscroll and ss_imark=0 then\t\t\t!dims don't include the scrollbar\n\tdimx+:=arrowdim\nfi\n\nw:=gxcontrol(owner,listbox_class,pos,(dimx,dimy),ss)\nw.linkvar:=linkvar\nw.id:=id\nw.attrs:=new(listboxrec)\n\nif pitch=0 then\t\t\t\t\t\t\t\t!calculate all these here\n\tpitch:=listrowheight\n\toffset:=0\n\trows:=w.dimy%pitch\nfi\nw.attrs.rows:=rows\nw.attrs.pitch:=pitch\nw.attrs.offset:=offset\n\nw.attrs.pagepos:=1\nw.attrs.currpos:=(getlvbounds(linkvar).len|1|0)\n\nif w.style.vscroll then\n\tws:=gxvertscrollbar(owner:w,pos:(w.dimx-arrowdim,0),dim:w.dimy,id:id,style:style)\n!\tgxsetscrolllimits(ws,linkvar^.bounds,w.attrs.rows)\n\tgxsetscrolllimits(ws,getlvbounds(linkvar),w.attrs.rows)\n!\tgxscrollpos(ws,linkvar^.lwb)\n\n\tgxscrollpos(ws,getlvbounds(linkvar).lwb)\n!\tgxscrollpos(ws,1)\nfi\n\ngxdraw(w)\nreturn w\nend\n\nexport func gxarrow(owner,pos,?dim,dir,?style,id=201)=\n\nss:=readstyle(owner,arrow_class,style)\nif dim.isvoid then\n\tdim:=(arrowdim,arrowdim)\nfi\n\nw:=gxcontrol(owner,arrow_class,pos,dim,ss)\nw.id:=id\nif dir.isstring then dir:=asc(dir) fi\ncase dir\t\t\t\t\t!allow compass bearings too, but convert to UDLR\nwhen 'N' then dir:='U'\nwhen 'E' then dir:='R'\nwhen 'S' then dir:='D'\nwhen 'W' then dir:='L'\nesac\n\nw.style.dir:=dir\t\t\t!don't dir allow via style options\ngxdraw(w)\n\nreturn w\nend\n\nexport proc gxsetscrolllimits(w,limits,span=0)=\n!set up or change scrollbar limits\n!span=0:\n!\tPure ranging control. Limits are actual range of the thumb.\n!\tThumb is drawn at a fixed, nominal size. Might be suppressed when limits are <=1\n!\tInitial position set to limits.lwb\n!span=M:\n!\tPaging control, such as used on a listbox or text editor.\n!\tSpan can be the number of rows display at one time.\n!\tLimit can be single number N, or range 1..N.\n!\tActual scroll bar range will be 1..N-M+1. When upper limit<1 then\n!\tlimit will be 1..1, and thumb might not be drawn\n!\tData position will: actually there /is/ not data position, except for the\n!\tdata position represented by the top row, which will be the same as the scroll\n!\tposition.\n!Arrows should be disabled (and perhaps thumb suppressed) when scroll range if 1..1,\n!or data range is nor larger than a span\n\nw.attrs.span:=span\nif w.style.dir='H' then\n\twidth:=w.dimx\nelse\n\twidth:=w.dimy\nfi\nm:=width-arrowdim*2\t\t\t\t!number of pixels movement between arrows\n\nif span=0 then\t\t\t\t\t\t!pure scrolling control\n\tw.attrs.limits:=limits\n\tw.attrs.currpos:=limits.lwb\n\tw.attrs.thumbsize:=arrowdim\n\tenable:=limits.len>1\n\tw.attrs.thumbsize:=arrowdim*enable\nelse\n\tif limits.isrange then\n\t\tlength:=limits.len\n\telse\n\t\tlength:=limits\n\tfi\n\tif length<=span then\n\t\tenable:=0\n\t\tw.attrs.limits:=1..1\n\t\tw.attrs.thumbsize:=0\n\telse\n\t\tw.attrs.limits:=1..length-span+1\n\t\tenable:=1\n\t\tw.attrs.thumbsize:=max(10,int(m*(span/length)))\n\tfi\nfi\n\nw.attrs.currpos:=w.attrs.limits.lwb\nw.enable:=enable\n\nw.attrs.thumbspan:=m-w.attrs.thumbsize\t\t!movement available to thumb\nw.attrs.thumbpos:=arrowdim\npostmess(w,mm_draw)\nend\n\nexport func gxscrollpos(w,pos,u=0)=\n!\nif pos.isvoid then\n\treturn w.attrs.currpos\nfi\n\nw.attrs.currpos:=pos\nif pos not in w.attrs.limits then\n\tpcerror(\"Bad scroll pos\")\nfi\n\ntpos:=int(w.attrs.thumbspan*((pos-w.attrs.limits.lwb)/(w.attrs.limits.len-1)))\nw.attrs.thumbpos:=arrowdim+tpos\n\nw.childlist[1].enable:=pos>w.attrs.limits.lwb\nw.childlist[2].enable:=pos<w.attrs.limits.upb\n\nif u then\n\tpostmess(w,mm_update)\nfi\nreturn 0\nend\n\nexport func gxhozscrollbar(owner,pos,dim,?style,id=201)=\n\nss:=readstyle(owner,scrollbar_class,style)\nwidth:=arrowdim\nif dim.isint then\n!if dim.ispointer then\n\tdim:=(dim,width)\nelse\n\twidth:=dim[1]\nfi\n\nw:=gxcontrol(owner,scrollbar_class,pos,dim,ss)\nw.id:=id\nw.style.dir:='H'\n\nw.attrs:=new(scrollbarrec)\nw.flags.[wa_leftdrag]:=1\n\n!Now, create the arrows at each end. The thumbbar is not an explicit control,\n!it's just a drawn box\nwa:=gxarrow(owner:w, pos:(0,0), dim:(width,width),dir:'L')\nwb:=gxarrow(owner:w, pos:(dim[1]-width,0), dim:(width,width),dir:'R')\n\ngxsetscrolllimits(w,1..200,20)\ngxscrollpos(w,1)\n\ngxdraw(w)\n\nreturn w\nend\n\nexport func gxvertscrollbar(owner,pos,dim,?style,id=201)=\nss:=readstyle(owner,scrollbar_class,style)\nwidth:=arrowdim\nif dim.isint then\n!if dim.ispointer then\n\tdim:=(width,dim)\nelse\n\twidth:=dim[2]\nfi\n\nw:=gxcontrol(owner,scrollbar_class,pos,dim,ss)\nw.id:=id\nw.style.dir:='V'\n\nw.attrs:=new(scrollbarrec)\nw.flags.[wa_leftdrag]:=1\n\n!Now, create the arrows at each end. The thumbbar is not an explicit control,\n!it's just a drawn box\nwa:=gxarrow(owner:w, pos:(0,0), dim:(width,width),dir:'U')\nwb:=gxarrow(owner:w, pos:(0,dim[2]-width), dim:(width,width),dir:'D')\ngxsetscrolllimits(w,100..200,2)\n\ngxscrollpos(w,100)\n\ngxdraw(w)\n\nreturn w\nend\n\nexport func gxmark(owner,pos,?dim,?style,id=201)=\n\nss:=readstyle(owner,mark_class,style)\nif dim.isvoid then\n\tdim:=(markdim,markdim)\nfi\n\nw:=gxcontrol(owner,mark_class,pos,dim,style)\nw.id:=id\ngxdraw(w)\n\nreturn w\nend\n\nexport proc gxfocus(w)=\n!switch focus to window w\nif wfocus==w then\n\treturn\nfi\n\nif wfocus then\n\tdomessage(makemess(wfocus,mm_killfocus))\nfi\ncaretdrawn:=0\ndomessage(makemess(w,mm_setfocus))\nend\n\nexport proc gxkillfocus=\nif wfocus then\n\tdrawcaret(0)\nfi\nwfocus:=nil\nend\n\nexport func gxcopy(w,?bm,x=0,y=0,scalex=1.0,scaley=0,sx=0,sy=0,dimx=0,dimy=0)=\t\t!GXCOPY\n!copy bitmap bm to window w, at position x,y in w. Scalex/y can be 0 for 1:1,\n!or Scalex/y can be any real value for unequal x/y scaling\n!For equal x/y scaling, Scaley can be 0\n!Entire bitmap is copied (sx,sy,w,h all 0); for portion, set sx,sy to top left of rect\n!and w,h to size to be copied\n![1..100]char str\n\nif bm.isvoid then\n\tbm:=w\n\tw:=nil\nfi\nif bm.isvoid then\n\treturn nil\nfi\n\nif dimx=0 then dimx:=bm.dimx-sx fi\nif dimy=0 then dimy:=bm.dimy-sy fi\n\nif scalex=0 then scalex:=1.0 fi\nif scaley=0 then scaley:=scalex fi\n\nif w=nil then\t\t!create appropriate window\n\tw:=gxcreatewindow(caption:\"Bitmap \"+tostr(bm.pixelbits)+\" bit\",pos:(500,500),\n\t\t\tdim:(bm.dimx*scalex,bm.dimy*scaley))\nCPL \"*******SETDM2\",DM_SCREENMEMORY\n\tw.gdi.drawmode:=dm_screenmemory\t\t\t!default when using auto-window\nfi\n\ngdi:=w.gdi\ngdi.updated:=1\n\nmode:=copymode\n\nsetstretchbltmode(gdi.hdc,mode)\nstretchblt(gdi.hdc, x, y,int(dimx*scalex),int(dimy*scaley),\n\t\t\t\t\t\t\t\t\t\t\tbm.gdi.hdc,sx,sy,dimx,dimy, srccopy)\nif gdi.drawmode=dm_screenmemory then\n\tsetstretchbltmode(gdi.hdc2,mode)\n\tstretchblt(gdi.hdc2,x,y,int(dimx*scalex),int(dimy*scaley),\n\t\t\t\t\t\t\t\t\t\t\tbm.gdi.hdc,sx,sy,dimx,dimy, srccopy)\nfi\nreturn w\nend\n\nexport proc gxrestore(w,?r)=\n!repaint window w\n!only called when repaint can be done from a backup\n!r is the region to restore within w; or restore all if omitted\n\nif r.isvoid then\n\tx1:=y1:=0\n\n!CPL =W,=W.TYPE\n\n\twidth:=w.dimx\n\theight:=w.dimy\nelse\n\tx1:=r.x1\n\ty1:=r.x2\n\twidth:=r.x2-x1+1\n\theight:=r.y2-y1+1\nfi\n\ncase w.gdi.drawmode\nwhen dm_screen then\t\t\t!can't restore; need to call gx_draw\n\tgxdraw(w)\nwhen dm_screenmemory then\n\tdestdc:=w.gdi.hdc\n\tsourcedc:=w.gdi.hdc2\nwhen dm_memoryscreen then\n\tdestdc:=w.gdi.hdc2\n\tsourcedc:=w.gdi.hdc\nelse\n\tabort(\"gxrest/?\")\nesac\n\nbitblt(destdc,x1,y1, width,height, sourcedc, x1,y1, srccopy)\n\nend\n\nexport func gxdrawmode(w,?drawmode)=\n!set or get drawmode\n!really requires window to be cleared afterwards.\n\n\nolddrawmode:=w.gdi.drawmode\nif drawmode.isvoid then\n\treturn olddrawmode\nfi\n\nif olddrawmode=drawmode then\t\t!already set\n\treturn drawmode\nelsif olddrawmode<>dm_screen then\t!can only change screen => screenmemory/memoryscreen\n\tabort(\"gxdrawmode2\")\t\t\t!not memory to anything else\nfi\n\n!assuming currently on screen, will need extra compatible bitmap\nmemhwnd:=createcompatiblebitmap(screendc,w.dimx,w.dimy)\nmemhdc:=createcompatibledc(nil)\nselectobject(memhdc,memhwnd)\n\n!need to change draw mode\ncase drawmode\nwhen dm_screenmemory then\n\tw.gdi.hwnd2:=memhwnd\n\tw.gdi.hdc2:=memhdc\nwhen dm_memoryscreen then\n\tw.gdi.hwnd2:=w.gdi.hwnd\t\t\t!screen becomes secondary\n\tw.gdi.hdc2:=w.gdi.hdc\n\tw.gdi.hwnd:=memhwnd\n\tw.gdi.hdc:=memhdc\nelse\n\tabort(\"gxdrawmode?\")\nesac\n\nw.gdi.drawmode:=drawmode\nreturn drawmode\nend\n\nexport proc switchdest(w)=\n!for a window with screenmemory drawmode, switch things around so that\n!it's drawing into the memory area only\ngdi:=w.gdi\n\ncase gdi.drawmode\nwhen dm_screenmemory then\n\tt:=gdi.hwnd; gdi.hwnd:=gdi.hwnd2; gdi.hwnd2:=t\n\tt:=gdi.hdc; gdi.hdc:=gdi.hdc2; gdi.hdc2:=t\n\tgdi.drawmode:=dm_memory\nwhen dm_memory then\n\tt:=gdi.hwnd; gdi.hwnd:=gdi.hwnd2; gdi.hwnd2:=t\n\tt:=gdi.hdc; gdi.hdc:=gdi.hdc2; gdi.hdc2:=t\n\tgdi.drawmode:=dm_screenmemory\nesac\nend\n\nexport proc gxclose(w)=\n\ncase w.windclass\nwhen bitmap_class then\nelse\n\tif issubwindow(w,wfocus) then\n\t\twfocus:=nil\n\tfi\n\n\tif issubwindow(w,wmouse) then\t\n\t\tlastmousewindow:=nil\n\t\twmouse:=nil\n\tfi\n\n\tdestroywindow(w.gdi.hwnd)\n\tgxfreewindow(w)\nesac\nend\n\nproc gxfreewindow(w)=\n!recover memory used by this window and all childwindows\nfor wc in w.childlist do\n\tgxfreewindow(wc)\nod\n\nremovewindow(w)\n\nw.gdi:=0\nw:=0\nend\n\nexport func gxmsgbox(message,caption=\"\",options=\"\")=\n\nconst mb_abortretryignore\t= 0x02\nconst mb_applmodal\t\t\t= 0x00\nconst mb_defbutton1\t\t\t= 0x00\nconst mb_defbutton2\t\t\t= 100\nconst mb_defbutton3\t\t\t= 200\nconst mb_defbutton4\t\t\t= 300\nconst mb_help\t\t\t\t= 4000\nconst mb_iconasterisk\t\t= 40\nconst mb_iconerror\t\t\t= 10\nconst mb_iconexclamation\t= 30\nconst mb_iconhand\t\t\t= mb_iconerror\nconst mb_iconinformation\t= mb_iconasterisk\nconst mb_iconquestion\t\t= 20\nconst mb_iconstop\t\t\t= mb_iconhand\nconst mb_iconwarning\t\t= mb_iconexclamation\nconst mb_ok\t\t\t\t\t= 0x00\nconst mb_okcancel\t\t\t= 0x01\nconst mb_retrycancel\t\t= 0x05\nconst mb_right\t\t\t\t= 80000\nconst mb_setforeground\t\t= 10000\nconst mb_systemmodal \t\t= 1000\nconst mb_taskmodal\t\t\t= 2000\nconst mb_yesno\t\t\t\t= 0x04\nconst mb_yesnocancel\t\t= 0x03\nconst mb_topmost\t\t\t= 0x040000\n\n!return values\nconst idfail\t= 0\nconst idok\t\t= 1\nconst idcancel\t= 2\nconst idabort\t= 3\nconst idretry\t= 4\nconst idignore\t= 5\nconst idyes\t\t= 6\nconst idno\t\t= 7\n\nstatic var rettable=(0:\"fail\",\"ok\",\"cancel\",\"abort\",\"retry\",\"ignore\",\"yes\",\"no\",\n\t\t\"\",\"\",\"tryagain\",\"continue\")\n\nstatic var styletable=(\n(\"bari\",mb_abortretryignore),\n(\"bo\",mb_ok),\n(\"boc\",mb_okcancel),\n(\"brc\",mb_retrycancel),\n(\"byn\",mb_yesno),\n(\"bync\",mb_yesnocancel),\n(\"ix\",mb_iconexclamation),\n(\"iw\",mb_iconwarning),\n(\"ii\",mb_iconinformation),\n(\"iq\",mb_iconquestion),\n(\"is\",mb_iconstop),\n(\"ie\",mb_iconerror),\n(\"ih\",mb_iconhand),\n(\"d1\",mb_defbutton1),\n(\"d2\",mb_defbutton2),\n(\"d3\",mb_defbutton3),\n(\"d4\",mb_defbutton4),\n(\"h\",mb_help),\n(\"rj\",mb_right),\n(\"sm\",mb_systemmodal))\n\nhwnd:=nil\n\nstyle:=0\noptioncodes:=splitstring(options,\" \")\n\nfor opt in optioncodes do\n\tfor i to styletable.len do\n\t\tif styletable[i,1]=opt then style ior:=styletable[i,2] fi\n\tod\nod\n\nstyle ior:=0x10000\n\n!CPL =HWND.TYPE\n!CPL =MESSAGE.TYPE\n!CPL =CAPTION.TYPE\n!CPL =STYLE.TYPE\n\nx:=messageboxa(hwnd,message,caption,style)\n!CPL =X\nreturn rettable[x]\nEND\n\n\nexport proc gxhandler(windclass,mess,fnptr)=\n!windclass is a window, or a window class\n!override the current message handler for w's window class, and fo message mess\n\n!if not windclass.isint then\nif not windclass.ispointer then\n\twindclass:=windclass.windclass\nfi\n\n!CPL \"SETTING GXHANDLER\",MESS,WINDCLASS,FNPTR\nmesshandlertable[mess,windclass]:=fnptr\nend\n\nexport func gxaskfile(caption=\"File\",filespec=\"*.*\",deffile=\"\",startdir=\"\")=\n\nsave:=0\nif caption='*' then\n\tsave:=1\n\tcaption:=rightstr(caption,-1)\nfi\n\nfilters:=array(filespec+\"@@@\")\t\t!turn into a byte-array\n\nfor i,bb in filters do\t\t\t!convert all @ into embedded zeros\n\tif bb='@' then filters[i]:=0 fi\nod\n\nofn:=new((iswin32|ws_openfilename32|ws_openfilename64))\n\nofn.structsize:=ofn.bytes\nofn.owner:=wapplic.gdi.hwnd\nofn.instance:=getmodulehandle(0)\nofn.filter:=int(&filters)\nofn.flags:=ofn_explorer ior ofn_nochangedir ior ofn_hidereadonly !IOR OFN_NOVALIDATE\n\nofn.initialdir:=getstringz(startdir)\n\nofn.defext:=getstringz(\"\")\n\nresult:=new(array,byte,300)\n\nresult[1]:=0\nif deffile<>\"\" then\n\tmemcpy(&result,&deffile,deffile.len)\nfi\n\nofn.file:=int(&result)\n\nofn.maxfile:=256\nofn.title:=getstringz(caption)\n\nif not (not save | getopenfilenamea(&ofn) | getsavefilenamea(&ofn)) then\n\tresult[1]:=0\t\t!return \"\" on error\nfi\n\nreturn string(result)\nEND\n\nexport func gxcurrpos(w)=\nreturn w.attrs.currpos\nend\n\nexport func gxtabstops(?tabs,signed=0)=\nif tabs.isdef then\n\ttabstops::=tabs\n\tif signed then\n\t\tfor i,x in tabstops do\n\t\t\ttabstops[i]:=abs(x)\n\t\tod\n\tfi\nfi\nreturn tabstops\n\nend\n\nexport func getlvbounds(linkvar)=\nif linkvar.ispointer and linkvar^.islist then\n\treturn linkvar^.bounds\nelse\n\treturn linkvar.getbounds()\nfi\nreturn 0\nend\n\nexport func getlvitem(linkvar,n)=\nif linkvar.ispointer and linkvar^.islist then\n\treturn linkvar^[n]\nelse\n\tPCERROR(\"GETLVITEM\")\nfi\nreturn 0\nend\n\nexport func getlvstritem(linkvar,n)=\nif linkvar.ispointer and linkvar^.islist then\n\treturn tostr(linkvar^[n])\nelse\n\treturn linkvar.getstritem(n)\nfi\nreturn 0\nend\n\nexport proc gxtext16(w,s,n,x=0,y=0)=\t\t!GXTEXT\n\tgdi:=w.gdi\n\n\ttextoutw(gdi.hdc,x, y,&s,n)\n\tif gdi.drawmode=dm_screenmemory then\n\t\ttextoutw(gdi.hdc2,x,y,&s,n)\n\tfi\nend\n\nexport func gxenable(w,flag)=\nif flag.isdef then\n\tw.enable:=flag\n\tgxupdate(w)\nfi\nreturn w.enable\nend\n\nexport func gxclientarea(w)=\n!scan child windows of w, work out remaining client area after taking account of\n!framebars etc\n!return (pos, dim), each being a 2-element list\n\naposx:=aposy:=0\n\nadimx:=w.dimx\nadimy:=w.dimy\n\ncentx:=(aposx+adimx)%2\ncenty:=(aposy+adimy)%2\n\n!for cw in w.childlist when cw.windclass in [statusbar_class,framebar_class] do\nfor cw in w.childlist do\n\n\t(posx,posy):=(cw.frameposx,cw.frameposy)\n\t(dimx,dimy):=(cw.framedimx,cw.framedimy)\n\n!need to find out which of the four sides the bar is against, and set up side= L R T B\n\tcase cw.style.dir\n\twhen 'B' then\t\t\t\t!bottom\n\t\tif posy<(aposy+adimy) then\n\t\t\tadimy-:=dimy\n\t\tfi\n\n\twhen 'T' then\t\t\t\t!top\n\t\tif (posy+dimy)>aposy then\t\t!\n\t\t\taposy+:=(posy+dimy)\n\t\t\tadimy-:=(posy+dimy)\n\t\tfi\n\n\twhen 'R' then\t\t\t\t!right\n\t\tif posx<(aposx+adimx) then\n\t\t\tadimx-:=dimx\n\t\tfi\n\n\twhen 'L' then\t\t\t\t!LEFT\n\t\tif (posx+dimx)>aposx then\t\t!\n\t\t\taposx+:=(posx+dimx)\n\t\t\tadimx-:=(posx+dimx)\n\t\tfi\n\telse\n\n\t\tif dimx>dimy then\t\t\t!assume hoz\n\t\t\tif posy>centy then\t\t\t!assume bottom\n\t\t\t\tif posy<(aposy+adimy) then\n\t\t\t\t\tadimy-:=dimy\n\t\t\t\tfi\n\n\t\t\telse\t\t\t\t\t!top\n\t\t\t\tif (posy+dimy)>aposy then\t\t!\n\t\t\t\t\taposy+:=(posy+dimy)\n\t\t\t\t\tadimy-:=(posy+dimy)\n\t\t\t\tfi\n\t\t\tfi\n\t\telse\t\t\t\t\t!assume vert\n\t\t\tif posx>centx then\t\t\t!assume right\n\n\t\t\t\tif posx<(aposx+adimx) then\n\t\t\t\t\tadimx-:=dimx\n\t\t\t\tfi\n\n\t\t\telse\t\t\t\t\t!left\n\n\t\t\t\tif (posx+dimx)>aposx then\t\t!\n\t\t\t\t\taposx+:=(posx+dimx)\n\t\t\t\t\tadimx-:=(posx+dimx)\n\t\t\t\tfi\n\n\t\t\tfi\n\t\tfi\n\tesac\nod\n\nreturn ((aposx,aposy), (adimx,adimy))\nEND\n\nexport func addwindow(w)=\n!w is a newly created window\n!add it to all windows\nn:=nil inx allwindows\n!if not n then\nif not n.isfound then\n\tn:=allwindows.len+1\nfi\n\nallwindows[n]:=w\nw.gindex:=n\nreturn n\nend\n\nexport proc removewindow(w)=\n!remove w from all windows\nn:=w inx allwindows\nif n.isfound then\n\tallwindows[n]:=nil\nfi\nend\n\nfunc get_function_name(fnptr)=\nn:=$pcldata('PROC',0)\nfor i:=1 to n do\n\tdata:=$pcldata('PROC',i)\n\tif fnptr=data[4] then\n\t\treturn data[1]\n\tfi\nod\nreturn \"NOT FOUND \"+tostr(fnptr)\nend\n\n!===================================\n!MESSLIB\nfunc process_wmmessage(msg)=\n\tx:=process_wmmessage2(msg)\n!stop\n\treturn x\n\nend\n\nfunc process_wmmessage2(msg)=\n!msg is a windows rmsg record\n!Called from MainWndProc callback func (via mechanisms for B code to call into MPL code)\n!this func processes some wm_ Windows messages and converts them\n!into mm_ messages as necessary\n!It returns:\n!\t0 The wm_ message has been processed\n!\t1 The wm_ message has not been processed, and the caller should call DefWindowProc.\n!\t  Or, the DefWindowProc should also be called anyway.\n\n!CPL =MSG\n!CPL =MSG.TYPE\n\n\nhwnd:=msg.hwnd\n!IF MSG.MESSAGE<>WM_GETICON THEN\n!CPL \"PROC WMMESS\",WINMESSAGENAMES{MSG.MESSAGE},=hwnd\n!FI\nw:=getwindow(hwnd)\n\nmessage:=msg.message\nwparam:=msg.wparam\nlparam:=msg.lparam\n\n!CPL \"PROC WMMMESS2\",WINMESSAGENAMES[MESSAGE]\ncase msg.message\n!switch msg.message\nwhen wm_command then\n\tw:=getwindow(lparam)\t\t\t!w was owner, use control window\n\ti:=wparam iand 0xffff\t\t\t!id\n\tj:=wparam>>16\t\t\t\t!notify code\n\tm:=mm_command\n\n\tif not w then\n\t\tw:=wapplic\n\tfi\n\n\tpostmess(w,m,i,j,0)\n\n\treturn 0\n\nwhen wm_activate then\n\tif wparam then\t\t\t\t!being activated\n\tfi\n\nwhen wm_syskeydown,wm_syskeyup,wm_keydown,wm_keyup then\n\tif dokeymessage(hwnd,message,wparam,lparam) then\n\t\treturn 0\n\tfi\n\nwhen wm_char then\n\tpostmess((wfocus|wfocus|w),mm_char,wparam,lparam,0)\n\nwhen wm_close then\nCPL \"WMCLOSE SEEN\"\n\tif w==wapplic then\nCPL \"CLOSEMESS\"\n\t\tpostmess(w,mm_close,0,0,0)\n\t\treturn 0\n\telse\nCPL \"CANCELMESS\"\n\t\tpostmess(w,mm_cancel,0,0,0)\n\t\treturn 0\n\tfi\n\nwhen wm_timer then\n\tif not background and not stationary then\t\t!test for pausing of mouse\n\t\tif gettickcount()-lastxytime>pausetime then\n\t\t\tstationary:=1\n\t\tfi\n\tfi\n\nwhen wm_destroy then\n\tif w and wapplic and w==wapplic then\n\t\tkilltimer(hwnd,1)\n!*\t\tif tick then killtimer(hwnd,1) fi\n\t\tpostquitmessage(0)\t\t\t!mm_quit message\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi\n\n!when wm_setcursor then\n!\tpostmess(w,mm_setcursor,wparam,lparam,0)\n\nwhen wm_mousemove then\n\n\tbuttonstate:=wparam iand (kb_lbutton ior kb_rbutton ior kb_mbutton)\n\tmousepos.x:=lparam iand 65535\n\tmousepos.y:=lparam>>16\n\ndomousemove:\n\txyvalid:=1\t\t\t\t!known again\n\tsetnewmousewindow(w)\n\n\twmouse:=w\n\tpostmess(wmouse,mm_move)\n\n\tlastxy::=getscreencoords(wmouse,mousepos)\n\tlastxytime:=gettickcount()\n\tstationary:=0\n\n!do drag processing; states are:\n!pen up/recent pen down/first drag/subsequent drag\n!any drag messages are sent as well as mm_move messages\n!dragmode=1/2/3 indicates drag has started (reset by buttonswitching)\n\n\tif buttonstate<>0 and lastmousewindow<>nil then\t\t!switch pressed\n\t\tpt:=getscreencoords(lastmousewindow,lastmousepos)\n\t\tdx:=lastxy.x-pt.x\n\t\tdy:=lastxy.y-pt.y\n\n!CPL =DRAGMODE\n\t\tif dragmode then\t\t!1st drag message already generated\n\t\t\tpostmess(lastmousewindow,mm_drag,dx,dy,-1)\t\t\t!send latest drag coords\n\n\t\telse\t\t\t\t!test for drag enabling\n!CPL \"TESTDRAG\",=MOUSESW\n\t\t\tif ((mousesw=1 and lastmousewindow.flags.[wa_leftdrag]<>0) or \\\n\t\t\t\t\t\t\t(mousesw=2 and lastmousewindow.flags.[wa_rightdrag]<>0) or \\\n\t\t\t\t\t\t\t(mousesw=3 and lastmousewindow.flags.[wa_middledrag]<>0)) and \\\n\t\t\t\t\t\t(abs(dx)>dragtol or abs(dy)>dragtol) then\n\t\t\t\tdragmode:=mousesw\n\t\t\t\tpostmess(lastmousewindow,mm_startdrag,dx,dy,-1)\t\t!send latest drag coords\n\t\t\tfi\n\n\t\tfi\n\telse\n\t\tif dragmode then\n\t\t\tpostmess(lastmousewindow,mm_enddrag,dx,dy,-1)\t!send latest drag coords\n\t\t\tdragmode:=0\n\t\tfi\n\tfi\n\n\treturn 0\n\nwhen wm_enteridle then\t\t!enter idle\n\tidlemode:=1\n\treturn 0\n\nwhen wm_paint then\n\n\tif w<>nil then\n\t\tps:=new(ws_paintstruct)\n\t\trect:=new(ws_rect)\n\t\tbeginpaint(hwnd,&ps)\n!\t\tframe2rect(^ps.paintrect,^rect)\n!\t\tRECT.DIMX-:=1\n!\t\tRECT.DIMX-:=1\n!\t\tRECT.DIMY-:=1\n!*!\t\tgxmplpaint(w,^rect,0)\n!gxclear(wapplic,red)\n\t\tpostmess(w,mm_restore,0,0,0)\n\t\tendpaint(hwnd,&ps)\n\t\treturn 0\n\tfi\n\nwhen wm_erasebkgnd then\n\nwhen wm_move then\n\tif w<>nil then\n!*!\t\tgxmovewindow(w,lparam iand 65535,lparam>>16)\n\tfi\n!RETURN 0\n\nwhen wm_size then\n\tx:=lparam iand 0xffff\n\ty:=lparam>>16\n\tif w<>nil  and (w.dimx<>x or w.dimy<>y) then\n!*!\t\tgxmplresize(w,x,y,wparam)\n\t\treturn 0\n\tfi\n\n!when wm_killfocus,wm_setfocus then\n\nwhen wm_contextmenu then\n\tsendmess(w,mm_rclick,wparam>>16,wparam iand 0xffff,0)\n\treturn 0\n\nwhen wm_mousewheel then\n\tif not wmouse then wmouse:=w fi\n!CPL \"WM/WHEEL\",WPARAM:\"H\",WPARAM>>16\n\tpostmess(wmouse,mm_wheel,int(wparam>>16),wparam iand 0xffff,0)\n\treturn 0\n\nwhen wm_nclbuttondown,wm_nclbuttondblclick then\n\nwhen wm_activateapp then\n\tif wparam then\n\t\tpostmess(w,mm_activate,1,0,0)\n\tfi\n\nelse\nbtnmessages:\n!check for sequential messages\n\tif message>=wm_lbuttondown and message<=wm_mbuttondblclk then\n\t\tbuttonmessages(hwnd,message,wparam,lparam)\n\t\treturn 0\n\tfi\nesac\n!end\n!fall-through here to do default message processing instead of/in addition to local processing\nreturn 1\t!defwindowproc(hwnd,imsg,wparam,lparam)\nend\n\nexport proc mxinit=\nwmessagetable := [\\\n\twm_lbuttondown:\t\tmm_click,\n\twm_lbuttonup:\t\tmm_clickup,\n\twm_lbuttondblclk:\tmm_dblclick,\n\n\twm_rbuttondown:\t\tmm_rclick,\n\twm_rbuttonup:\t\tmm_rclickup,\n\twm_rbuttondblclk:\tmm_rdblclick,\n\n\twm_mbuttondown:\t\tmm_mclick,\n\twm_mbuttonup:\t\tmm_mclickup,\n\twm_mbuttondblclk:\tmm_mdblclick]\n\n!table gives button number 1,2,3 for Windows button message (always 0 for button up)\nbuttontable\t:= [\\\n\twm_lbuttondown:\t\t1,\n\twm_lbuttonup:\t\t0,\n\twm_lbuttondblclk:\t1,\n\n\twm_rbuttondown:\t\t2,\n\twm_rbuttonup:\t\t0,\n\twm_rbuttondblclk:\t2,\n\n\twm_mbuttondown:\t\t3,\n\twm_mbuttonup:\t\t0,\n\twm_mbuttondblclk:\t3]\n\nmousepos:=new(ws_point)\n\nsetmesshandler(process_wmmessage)\n!setmesshandler(bill)\n\nvktomesstable:=[\\\n\tvkleft:\t\tmm_leftkey,\n\tvkright:\tmm_rightkey,\n\tvkup:\t\tmm_upkey,\n\tvkdown:\t\tmm_downkey,\n\tvkpageup:\tmm_pageupkey,\n\tvkpagedown:\tmm_pagedownkey,\n\tvkhome:\t\tmm_homekey,\n\tvkend:\t\tmm_endkey,\n\tvktab:\t\tmm_tabkey,\n\tvkbackspace:\tmm_bskey,\n\tvkdelete:\tmm_deletekey,\n\tvkenter:\tmm_enterkey,\n\tvkinsert:\tmm_insertkey,\n\tvkescape:\tmm_cancel\n]\nend\n\nexport func postmess(w,mess,a=0,b=0,c=0)=\n!add message m to end of message queue\n!use mess+1000 to add message to start of queue rather than the end\n\nif w=nil then w:=wapplic fi\nif w=nil then\n return 0 fi\n\nif w.flags.[wa_closed] then\n\n return 0 fi\n\nif mess>=1000 then\n\theadx:=1; mess-:=1000\nelse\n\theadx:=0\nfi\n\n!check if new message can be combined with an old message\ncase mess\nwhen mm_sethozpos,mm_setvertpos,mm_draw,mm_restore,mm_update then\n\tfor i:=1 to nmessages do\n\t\tm:=messagequeue[i].message\n!\t\tif m=mess then\t\t\t\t!use the old message but update any params\n\t\tif m=mess and w==messagequeue[i].wind then\t\t\t\t!use the old message but update any params\n\t\t\tmessagequeue[i].a:=a\n\t\t\tmessagequeue[i].b:=b\n\t\t\treturn 0\n\t\telsif mess=mm_draw and m=mm_update then\t\t!convert update to draw\n\t\t\tmessagequeue[i].message:=mm_draw\n\t\t\treturn 0\n\t\tfi\n\tod\nesac\n\nif quitmess or nmessages>=maxqueuesize then\n\treturn 0\nfi\n\npostmsg(makemess(w,mess,a,b,c))\nreturn 0\t\t\t\t\t!return zero for use in mainwndproc\nend\n\nexport func postmsg(msg,headx=0)=\n!add complete message msg to end of message queue\n!use head=1 to add to start of queue rather than the end\n\nif quitmess or nmessages>=maxqueuesize then\n\treturn 0\nfi\n\nif msg.wind.flags.[wa_closed] then return 0 fi\n\nif headx then\n\n!avoid dupl paint messages\n!\tif nmessages>1 and msg.message=mm_paint and messagequeue[1].message=mm_paint then\n!\t\treturn 0\n!\tfi\n\n\t++nmessages\n\tfor i:=nmessages downto 2 do\n\t\tmessagequeue[i]:=messagequeue[i-1]\n\tod\n\tmessagequeue[1]:=msg\n\nelse\n\t++nmessages\n\tmessagequeue[nmessages]:=msg\nfi\n!CPL =MESSAGEQUEUE\n\nreturn 0\t\t\t\t\t!return zero for use in mainwndproc\nend\n\nexport proc sendmess(w,mess,a=0,b=0,c=0)=\n!add message m to head of message queue\n!(may be 100% handled in q smlib)\n\nif w=nil then return fi\nif w.flags.[wa_closed] then return fi\n\nsendmsg(makemess(w,mess,a,b,c))\nend\n\nproc sendmsg(msg)=\n!call event handler for msg or add to head of queue\nif msg.wind.flags.[wa_closed] then return fi\npostmsg(msg,1)\nend\n\nexport func makemess(w,mess,a=0,b=0,state=-1)=\n!turn params into a new messrec @nemm_ess\n!the q version makemess also accepts makemess(w,msg)\n\nif w=nil then w:=wapplic fi\n\nm:=new(rmessage,0)\n\nm.wind:=w\n\nm.message:=mess\nm.a:=a\nm.b:=b\nm.state:=state\n\nm.x:=mousepos.x\nm.y:=mousepos.y\n\nif m.state=-1 then m.state:=getshiftstate() fi\n\nreturn m\nend\n\nfunc dokeymessage(hwnd,msg,wparam,lparam)=\n!return 1 if message has been dealt with\ncase msg\nwhen wm_syskeydown then\n!CPL \"SYSKEYDOWN\"\n\n\tif wparam=vkf10 then msg:=wm_keydown; goto dokey fi\n\nwhen wm_syskeyup then\n\tif wparam=vkf10 then msg:=wm_keyup; goto dokey fi\n\nwhen wm_keydown,wm_keyup then\ndokey:\n\tcase wparam\n\twhen vkshift,vkctrl,vkalt,vkcapslock then\n\telse\n\t\tw:=wfocus\n!\t\tif not w then w:=wx_getw(hwnd) fi\n\t\tif not w then w:=getwindow(hwnd) fi\n!CPL =GETSHIFTSTATE()\n!\t\tpostmess(w,(msg=wm_keydown|mm_key|mm_keyup),wparam,getshiftstate(),lparam)\n\t\tpostmess(w,(msg=wm_keydown|mm_key|mm_keyup),wparam,lparam,-1)\n\t\treturn 1\n\tesac\nesac\nreturn 0\nend\n\nfunc getshiftstate=\nstate:=0\n\nif getkeystate(vklshift) iand 0x8000 then state ior:=kb_shift fi\nif getkeystate(vklcontrol) iand 0x8000 then state ior:=kb_ctrl fi\nif getkeystate(vklalt) iand 0x8000 then state ior:=kb_alt fi\n\nif getkeystate(vkrshift) iand 0x8000 then state ior:=kb_rshift fi\nif getkeystate(vkrcontrol) iand 0x8000 then state ior:=kb_rctrl fi\nif getkeystate(vkralt) iand 0x8000 then\n\tstate ior:=kb_ralt\n\tstate iand:=(inot kb_ctrl)\t\t\t!AltGr gives Lctrl+Ralt; return Ralt only\nfi\nif getkeystate(vkcapslock) iand 1 then state ior:=kb_capslock fi\n\nreturn state ior buttonstate\nEND\n\nproc buttonmessages(hwnd,msg,wp,lp)=\n!process Windows mouse message <msg>\n\n!update button from wparam, excluding ctrl/shift (which are updated from key msgs)\nbuttonstate:=wp iand (kb_lbutton ior kb_rbutton ior kb_mbutton)\n\n!update mouse position\nmousepos.x:=lp iand 0xffff\nmousepos.y:=int(lp)>>16\nwmouse:=getwindow(hwnd)\n\n!set mousesw to last pressed button (1,2,3) or 0 if one just released\n!(note other buttons may still be down, used for drag processing)\nmousesw:=buttontable{msg}\n\nif mousesw then\t\t\t!down up on click or dblclick\n\tlastbuttontime:=gettickcount()\n\tlastmousepos::=mousepos\n\tlastmousewindow:=wmouse\nelse\n\tmousesw:=0\n\n\tif dragmode then\n\t\tpostmess(lastmousewindow,mm_enddrag,0,0,-1)\n\t\tdragmode:=0\n\tfi\n\n\tlastbuttontime:=0\n\tlastmousewindow:=nil\nfi\n\nnewmess:=wmessagetable{msg}\n\n!filter double-click messages and convert to repeated click if not enabled\ncase newmess\nwhen mm_dblclick then unless wmouse.flags.[wa_leftdbl] then newmess:=mm_click end\nwhen mm_rdblclick then unless wmouse.flags.[wa_rightdbl] then newmess:=mm_click end\nesac\n\n!postmess(wmouse,newmess,wmouse.id,0,getshiftstate())\npostmess(wmouse,newmess,wmouse.id,0,-1)\nEND\n\nproc setnewmousewindow(w)=\nreturn when not currmousewindow\nunless w==currmousewindow then\t\t!changed\n\tif currmousewindow<>nil then\n\t\tpostmess(currmousewindow,mm_offwindow,0,0,0)\n\tfi\n\n\tcurrmousewindow:=w\n\tpostmess(w,mm_onwindow,0,0,0)\nend unless\nend\n\nproc frame2rect(f,r)=\nr^.x:=f^.x\nr^.y:=f^.y\n\nr^.dimx:=f^.x2-f^.x1+1\nr^.dimy:=f^.y2-f^.y1+1\nend\n\nexport func mxwait_mm_message=\n#do windows dispatch loop\n#calling dispatchmessage() results in mainwndproc being called in interpreter,\n#which passes the Windows message params on to process_wmmessage() in this module\n#process_wmmessage() converts wm-messages to mpl mm-messages\n#return when at least one mm message is ready; (will return immediately if there\n#is already one in the queue)\n#return value is normall 1, or 0 when quitmess has been encountered\n\nif quitmess then\t\t\t\t!quit message already seen\n\treturn 0\nfi\n\nwindmsg:=new((iswin32|ws_msg32|ws_msg64))\n\nwhile nmessages<=0 do\n\tif x:=getmessage(&windmsg,nil,0,0)<>0 then\n!\tif x:=getmessage(0,0,0,0)<>0 then\n\t\tw:=windmsg.hwnd\n!\t\tif windmsg.message=wm_keydown and windmsg.wparam=27 then exit fi\n!\t\tif windmsg.message=wm_timer then CPL \"TIMER!!\" fi\n\n\t\ttranslatemessage(&windmsg)\n\t\tdispatchmessage(&windmsg)\n\telse\n\t\tquitmess:=1\n\t\texit\n\tfi\nod\n\nif not nmessages then\t\t\t!assume quit message seen\n\treturn 0\nfi\t\n\ncurrmess:=messagequeue[1]\n\n--nmessages\n\nxlatkeyboard()\n\nfor i:=1 to nmessages do\n\tmessagequeue[i]:=messagequeue[i+1]\nod\nreturn 1\nend\n\nproc xlatkeyboard=\n!expand any mm_key messages to special key messages\n!uses and modified currmess\nm:=currmess.message\n\nif m=mm_key then\n\n\tk:=currmess.a\n\tif k>=vkf1 and k<=vkf12 then\n\t\tnewmsg:=currmess\n\t\tcurrmess.message:=mm_functionkey\n\t\tcurrmess.a:=k-vkf1+1\n\telse\n\t\tkeymess:=vktomesstable{k,0}\n\t\tif keymess then\n\t\t\tcurrmess.message:=keymess\n\t\tfi\n\tfi\nfi\nend\n\nfunc getscreencoords(w,pos)=\npt::=pos\nif not w then\n\tPCERROR(\"GSC/W=0\")\nfi\n\nclienttoscreen(w.gdi.hwnd,&pt)\t\t!pos starts at 0,0\nreturn pt\nend\n\nexport func getwindow(hwnd)=\n!convert hwnd to window\n!return nil if any problem\nif hwnd=0 then\n\treturn nil\nfi\n\nindex:=wx_getw(hwnd)\nif index then\n\treturn allwindows[index]\nfi\nreturn nil\nend\n\nproc initmenuhandlers=\n!CPL \"IMH1\"\nltcolour:=getrgb(ltgrey)\n!CPL \"IMH2\"\ndkcolour:=getrgb(dkgrey)\n!CPL \"IMH3\"\nend\n\nproc gxhandler_fixups=\n!do some manual fixups for various shared handlers\n!(the automatic fixup routine allows multiple window classes per message, but not\n! multiple message per window class)\nmesshandlertable[mm_startdrag,scrollbar_class]:=mess_drag_scrollbar\nmesshandlertable[mm_enddrag,scrollbar_class]:=mess_drag_scrollbar\nmesshandlertable[mm_leftkey,scrollbar_class]:=mess_upkey_scrollbar\nend\n\nfunc mess_all_all(mess,w)=\n!CPL \"ALLALL\",MESSAGENAMES[MESS.MESSAGE]\ncase mess.message\nwhen mm_startdrag,mm_drag,mm_enddrag then\nwhen mm_command then\nwhen mm_ok,mm_cancel then\nwhen mm_click then\n\tcase w.windclass\n\twhen label_class, group_class then\n\t\treturn skipmess\n\tesac\nwhen mm_key then\n!CPL \"ALL/ALL/KEY\"\nwhen mm_sethozpos,mm_setvertpos then\nwhen mm_pick,mm_lbchange then\nwhen mm_leftkey,mm_rightkey,mm_upkey,mm_downkey,mm_enterkey,mm_tabkey then\nwhen mm_pageupkey,mm_pagedownkey then\nwhen mm_homekey, mm_endkey then\nwhen mm_functionkey then\nwhen mm_wheel then\nelse\n\treturn skipmess\nesac\n\nreturn thismess\nend\n\nfunc mess_restore_all(mess,w)=\n!CPL \"RESTORE ALL\", MESS.TYPE,W.TYPE\ngxrestore(W)\n\nreturn skipmess\nend\n\nfunc mess_killfocus_all\t\t\t\t<\"mx\">\t\t(mess,w)=\n!note: can be called from mess_setfocus_all, with a different mess, but correct w\n!assume w is same as wfocus\n\ndrawcaret(0)\nwfocus:=nil\n\nreturn skipmess\nend\n\nfunc mess_setfocus_all\t\t\t\t<\"mx\">\t\t(mess,w)=\nif wfocus then\n\tmess_killfocus_all(mess,wfocus)\nfi\n\nwfocus:=w\ndrawcaret(1)\nreturn skipmess\nend\n\nfunc mess_update_all\t<\"mx\">\t\t\t(mess,w)=\ngxupdate(w)\nreturn skipmess\nend\n\nfunc mess_draw_all\t\t<\"mx\">\t\t\t(mess,w)=\ngxdraw(w)\nreturn skipmess\nend\n\nfunc mess_click_select\t\t<\"mx\">\t(mess,w)=\nif w.enable then\n\tif not w.style.noupdate then\n\t\tp:=w.linkvar\n\t\tp^:=w.attrs.onvalue\n\t\tfor wc in w.owner.childlist do\n\t\t\tif wc.windclass=select_class and wc.linkvar=p then\n\t\t\t\tgxdraw(wc)\n\t\t\tfi\n\t\tod\n\tfi\n\tif w.style.returnmess then\n\t\tpostmess(w,mm_command,w.id)\n\tfi\nfi\nreturn skipmess\nend\n\nfunc mess_click_toggle\t\t<\"mx\">\t(mess,w)=\nif w.enable then\n\tif not w.style.noupdate then\n\t\tw.linkvar^:=not w.linkvar^\n\t\tgxdraw(w)\n\tfi\n\tif w.style.returnmess then\n\t\tpostmess(w,mm_command,w.id)\n\tfi\nfi\nreturn skipmess\nend\n\nfunc mess_click_button\t\t<\"mx\">\t(mess,w)=\n\nif w.enable=0 then\n\tbeep1()\n\treturn skipmess\nfi\n\nif w.id in 0..199 then\t\t\t\t!speficies an actual message number (but no params)\n\tpostmess(w,w.id)\nelse\n\tpostmess(w,mm_command,w.id)\nfi\nreturn skipmess\nend\n\nfunc mess_click_editbox\t\t<\"mx\">\t(mess,w)=\n!CPL \"CLICK EDITBOX\"\nif w.enable then\n\tif not w.style.noupdate then\n\t\tunless w==wfocus then\n\t\t\tgxfocus(w)\n\t\tend\n\tfi\n\tif w.style.returnmess then\n\t\tpostmess(w,mm_command,w.id)\n\tfi\nfi\n\nreturn skipmess\nend\n\nfunc mess_click_arrow\t\t<\"mx\">\t(mess,w)=\n\ncase w.owner.windclass\nwhen scrollbar_class then\n\tpostmess(w.owner,dirtomess{w.style.dir},w.id,0,-1)\nelse\n\tmess.message:=dirtomess{w.style.dir}\n\tmess.a:=w.id\n\treturn thismess\nesac\nreturn skipmess\nend\n\nfunc mess_click_mark\t\t<\"mx\">\t(mess,w)=\n\ncase w.owner.windclass\nwhen toggle_class,select_class then\n\tpostmess(w.owner,mess.message,w.id,0,-1)\nesac\nreturn skipmess\nend\n\nfunc mess_click_listbox\t\t<\"mx\">\t(mess,w)=\ngxfocus(w)\n\ny:=max(w.attrs.offset,mess.y)\n\npos:=(y-w.attrs.offset)%w.attrs.pitch+w.attrs.pagepos\n!if pos<=w.linkvar^.len then\nif pos<=getlvbounds(w.linkvar).len then\n\tgxsetlbpos(w,pos)\n\tpostmess(w,mm_pick,pos)\nfi\n\nreturn skipmess\nend\n\nfunc mess_click_scrollbar\t\t<\"mx\">\t(mess,w)=\nonthumb:=isonthumb(w,(w.style.dir='H'|mess.x|mess.y))\nstep:=w.attrs.span\na:=w.attrs.currpos\n\ncase w.owner.windclass\nwhen listbox_class then\n\tcase onthumb\n\twhen -1 then\n\t\tif a>w.attrs.limits.lwb then\n\t\t\ta:=max(a-step,w.attrs.limits.lwb)\n\t\t\tgxsetlbpage(w.owner,a)\n\t\tfi\n\twhen 1 then\n\t\tif a<w.attrs.limits.upb then\n\t\t\ta:=min(a+step,w.attrs.limits.upb)\n\t\t\tgxsetlbpage(w.owner,a)\n\t\tfi\n\tesac\nelse\n\tif not step then step:=10 fi\n\n\tcase onthumb\n\twhen -1 then\n\t\tif a>w.attrs.limits.lwb then\n\t\t\ta:=max(a-step,w.attrs.limits.lwb)\n\t\t\tgxscrollpos(w,a,1)\n\t\t\tpostmess(w,mm_sethozpos,a)\n\t\tfi\n\twhen 1 then\n\t\tif a<w.attrs.limits.upb then\n\t\t\ta:=min(a+step,w.attrs.limits.upb)\n\t\t\tgxscrollpos(w,a,1)\n\t\t\tpostmess(w,mm_sethozpos,a)\n\t\tfi\n\tesac\nesac\nreturn skipmess\nend\n\nfunc mess_wheel_scrollbar\t\t<\"mx listbox\">\t(mess,w)=\ndelta:=currmess.a\nn:=abs(currmess.a%120)\nto n do\n\tcase w.windclass\n\twhen scrollbar_class then\ndoscroll:\n\t\tpostmess(w,(delta>0|mm_up|mm_down))\n\twhen listbox_class then\n\t\tif w.childlist then\n\t\t\tw:=w.childlist[1]\n\t\t\tgoto doscroll\n\t\tfi\n\t\tpostmess(w,(delta>0|mm_upkey|mm_downkey))\n\tesac\nod\nreturn skipmess\nend\n\nfunc mess_up_scrollbar\t\t<\"mx\">\t(mess,w)=\na:=w.attrs.currpos\nif a<=w.attrs.limits.lwb then\n\treturn skipmess\nfi\ncase w.owner.windclass\nwhen listbox_class then\n\tgxsetlbpage(w.owner,a-1)\n\treturn skipmess\nelse\n\t--a\n\tgxscrollpos(w,a,1)\n\tpostmess(w,mm_setvertpos,a)\nesac\nreturn skipmess\nend\n\nfunc mess_left_scrollbar\t\t<\"mx\">\t(mess,w)=\n\ncase w.owner.windclass\nwhen listbox_class then\n\treturn skipmess\nelse\n\ta:=w.attrs.currpos\n\tif a>w.attrs.limits.lwb then\n\t\t--a\n\t\tgxscrollpos(w,a,1)\n\t\tpostmess(w,mm_sethozpos,a)\n\tfi\nesac\nreturn skipmess\nend\n\nfunc mess_right_scrollbar\t\t<\"mx\">\t(mess,w)=\n\ncase w.owner.windclass\nwhen listbox_class then\n\treturn skipmess\nelse\n\ta:=w.attrs.currpos\n\tif a<w.attrs.limits.upb then\n\t\t++a\n\t\tgxscrollpos(w,a,1)\n\t\tpostmess(w,mm_sethozpos,a)\n\tfi\n\nesac\nreturn skipmess\nend\n\nfunc mess_down_scrollbar\t\t<\"mx\">\t(mess,w)=\n\na:=w.attrs.currpos\nif a>=w.attrs.limits.upb then\n\treturn thismess\nfi\ncase w.owner.windclass\nwhen listbox_class then\n\tgxsetlbpage(w.owner,a+1)\n\treturn skipmess\nelse\n\t++a\n\tgxscrollpos(w,a,1)\n\tpostmess(w,mm_setvertpos,a)\n\nesac\nreturn skipmess\nend\n\nfunc mess_drag_scrollbar\t\t<\"mx\">\t(mess,w)=\ncase mess.message\nwhen mm_startdrag then\n\tif isonthumb(w,(w.style.dir='H'|mess.x|mess.y))=0 then\n\t\tthumbdragmode:=1\t\t\t!then treat as mm_drag\n\t\tthumbstartpos:=w.attrs.thumbpos-arrowdim\t\t!use thumb pos at start of drag\n\telse\t\t\t\t\t\t\t!dragging other part of scrollbar\n\t\treturn skipmess\n\tfi\nwhen mm_enddrag then\n\tthumbdragmode:=0\n\treturn skipmess\nelsif not thumbdragmode then\n\treturn skipmess\nesac\n\noffset:=(w.style.dir='H'|mess.a|mess.b)\t\t!pixel offset from initial drag start pos\nnewpos:=thumbstartpos+offset\t\t\t\t\t\t!could outside thumb span range\n\npos:=int(round((newpos/w.attrs.thumbspan)*(w.attrs.limits.len-1)+w.attrs.limits.lwb))\npos:=clamp(pos,w.attrs.limits.lwb,w.attrs.limits.upb)\n\ncase w.owner.windclass\nwhen listbox_class then\n\tgxsetlbpage(w.owner,pos)\nelse\n\tgxscrollpos(w,pos,1)\n\tpostmess(w,(w.style.dir='H'|mm_sethozpos|mm_setvertpos),pos)\nesac\nreturn skipmess\nend\n\nfunc mess_move_button\t\t<\"mx\">\t\t\t(mess,w)=\nreturn skipmess\nend\n\nfunc mess_move_all\t\t\t<\"mx\">\t\t\t(mess,w)=\nreturn skipmess\nend\n\nfunc mess_char_editbox\t\t<\"mx\">\t\t\t(mess,w)=\n\tif mess.a not in 32..255 then\n\t\tif wapplic then\n\t\t\tpostmess(wapplic,mm_key,mess.a,mess.b,mess.state)\n\t\tfi\n\t\treturn skipmess\n\tfi\n\tif not w.enable or w.style.noupdate then return skipmess fi\n\ts:=w.linkvar^\n\tn:=w.attrs.currpos\n\tc:=chr(mess.a)\n\n\tif n>s.len then\t\t\t\t!at end\n\t\ts+:=c\n\telsif n=1 then\t\t\t\t!at start\n\t\ts:=c+s\n\telse\t\t\t\t\t\t!in middle\n\t\ts:=leftstr(s,n-1)+c+rightstr(s,-(n-1))\n\tfi\n\n\tw.linkvar^:=s\n\t++w.attrs.currpos\n\tgxdraw(w)\n\n\treturn skipmess\nend\n\nfunc mess_key_editbox\t\t<\"mx\">\t\t\t(mess,w)=\n!CPL \"KEY/EDITBOX\"\n\npostmess(wapplic,mm_key,mess.a,mess.b,mess.state)\n\nreturn skipmess\nend\n\nfunc mess_leftkey_editbox\t\t<\"mx\">\t\t(mess,w)=\nif ctrlpressed() then\n\tpostmess(wapplic,mm_leftkey,mess.a,mess.b,mess.state)\n\treturn skipmess\nfi\n\nif w.attrs.currpos>1 then\n\tdrawcaret(0)\n\t--w.attrs.currpos\n\tdrawcaret(1)\nfi\nreturn skipmess\nend\n\nfunc mess_rightkey_editbox\t\t<\"mx\">\t\t(mess,w)=\nif ctrlpressed() then\n\tpostmess(wapplic,mm_rightkey,mess.a,mess.b,mess.state)\n\treturn skipmess\nfi\n\nif w.attrs.currpos<=w.linkvar^.len then\n\tdrawcaret(0)\n\t++w.attrs.currpos\n\tdrawcaret(1)\nfi\nreturn skipmess\nend\n\nfunc mess_bskey_editbox\t\t<\"mx\">\t\t(mess,w)=\ns:=w.linkvar^\nif not s then return skipmess fi\nn:=w.attrs.currpos\nif n=1 then return skipmess fi\n\nif n>s.len then\t\t\t\t!at end\n\ts:=leftstr(s,-1)\nelse\t\t\t\t\t\t!in middle\n\ts:=leftstr(s,n-2)+rightstr(s,-(n-1))\nfi\n\nw.linkvar^:=s\n--w.attrs.currpos\ngxdraw(w)\n\nreturn skipmess\nend\n\nfunc mess_deletekey_editbox\t\t<\"mx\">\t\t(mess,w)=\ns:=w.linkvar^\nif not s then return skipmess fi\nn:=w.attrs.currpos\nif n>s.len then return skipmess fi\n\nif n=1 then\t\t\t\t!at start\n\ts:=rightstr(s,-1)\nelse\t\t\t\t\t\t!in middle\n\ts:=leftstr(s,n-1)+rightstr(s,-n)\nfi\nw.linkvar^:=s\ngxdraw(w)\n\nreturn skipmess\nend\n\nfunc mess_homekey_editbox\t\t<\"mx\">\t\t(mess,w)=\nif ctrlpressed() then\n\tpostmess(wapplic,mm_homekey,mess.a,mess.b,mess.state)\n\treturn skipmess\nfi\n\ndrawcaret(0)\nw.attrs.currpos:=1\ndrawcaret(1)\n\nreturn skipmess\nend\n\nfunc mess_homekey_listbox\t\t<\"mx\">\t\t(mess,w)=\nif w.attrs.currpos>1 then\n\tgxsetlbpos(w,1)\nfi\n\nreturn skipmess\nend\n\nfunc mess_endkey_editbox\t\t<\"mx\">\t\t(mess,w)=\nif ctrlpressed() then\n\tpostmess(wapplic,mm_endkey,mess.a,mess.b,mess.state)\n\treturn skipmess\nfi\n\ndrawcaret(0)\nw.attrs.currpos:=w.linkvar^.len+1\ndrawcaret(1)\n\nreturn skipmess\nend\n\nfunc mess_endkey_listbox\t\t<\"mx\">\t\t(mess,w)=\n!if w.attrs.currpos<w.linkvar^.len then\nif w.attrs.currpos<getlvbounds(w.linkvar).len then\n!\tgxsetlbpos(w,w.linkvar^.len)\n\tgxsetlbpos(w,getlvbounds(w.linkvar).len)\nfi\n\nreturn skipmess\nend\n\nfunc mess_upkey_listbox\t\t<\"mx\">\t\t(mess,w)=\nif w.attrs.currpos>1 then\n\tgxsetlbpos(w,w.attrs.currpos-1)\nfi\n\nreturn skipmess\nend\n\nfunc mess_upkey_scrollbar\t\t<\"mx\">\t\t(mess,w)=\n!assume that this is independent scrollbar\n!(linked scrollbar wouldn't get the focus)\n\na:=w.attrs.currpos\nif a>w.attrs.limits.lwb then\n\t--a\n\tgxscrollpos(w,a,1)\n\tpostmess(w,mm_setvertpos,a)\nfi\nreturn skipmess\nend\n\nfunc mess_downkey_listbox\t\t<\"mx\">\t\t(mess,w)=\n!if w.attrs.currpos<w.linkvar^.len then\nif w.attrs.currpos<getlvbounds(w.linkvar).len then\n\tgxsetlbpos(w,w.attrs.currpos+1)\nfi\n\nreturn skipmess\nend\n\nfunc mess_pageupkey_listbox\t\t<\"mx\">\t\t(mess,w)=\nif (a:=w.attrs.currpos)>1 then\n\ta:=max(a-w.attrs.rows,1)\n\tgxsetlbpos(w,a)\nfi\n\nreturn skipmess\nend\n\nfunc mess_pagedownkey_listbox\t\t<\"mx\">\t\t(mess,w)=\n!if (a:=w.attrs.currpos)<w.linkvar^.len then\nif (a:=w.attrs.currpos)<getlvbounds(w.linkvar).len then\n!\ta:=min(a+w.attrs.rows,w.linkvar^.len)\n\ta:=min(a+w.attrs.rows,getlvbounds(w.linkvar).len)\n\tgxsetlbpos(w,a)\nfi\n\nreturn skipmess\nend\n\nfunc mess_enterkey_listbox\t\t<\"mx\">\t\t(mess,w)=\nif w.attrs.currpos then\n\tpostmess(w,mm_pick,w.attrs.currpos)\nfi\n\nreturn skipmess\nend\n\nproc do_draw_all\t\t\t<\"wx\">\t\t\t(w)=\n!RETURN\ngxclear(w)\ndrawborder(w)\ndrawchildborders(w)\nend\n\nproc do_draw_button\t\t\t<\"wx label\">\t\t\t(w)=\ngxclear(w)\n\ngxtext_just(w,w.text,0,w.enable)\n\ndrawborder(w)\n\nend\n\nproc do_draw_label(w)=\ndo_draw_button(w)\nend\n\nproc do_draw_toggle\t\t\t<\"wx\">\t(w)=\n!CPL \"DRAW TOGGLE/////////\"\n\ngxclear(w)\n\nVALSTR:=\"\"\n\nturnedon:=istrue w.linkvar^\n\nif w.style.marktype then\n\tdrawmark(w.childlist[1],turnedon,w.enable)\n\n\tgxtext_just(w,w.text+valstr,markdim,w.enable)\nelse\n!\tcase w.style.hilitetype\n!\twhen invert_hilite then\n\t\tif turnedon then\n\t\t\tgxclear(w,getrgb(green))\n\t\tfi\n!\tesac\n\n\tgxtext_just(w,w.text+valstr)\nfi\nend\n\nproc do_draw_select\t\t\t<\"wx\">\t(w)=\ngxclear(w)\n\nturnedon:=w.linkvar^=w.attrs.onvalue\n\nif w.style.marktype then\n\tdrawmark(w.childlist[1],turnedon,w.enable)\n\tgxtext_just(w,w.text,markdim,w.enable)\nelse\n\tcase w.style.hilitetype\n\twhen invert_hilite then\n\t\tif turnedon then\n\t\t\tgxclear(w,getrgb(white))\n\t\tfi\n\tesac\n\t\tgxtext_just(w,w.text)\nfi\nend\n\nproc do_draw_editbox\t\t\t<\"wx\">\t(w)=\ngxclear(w)\n\ngxtext_just(w,w.linkvar^,enable:w.enable)\n\n!Now, have to draw the cursor\nunless wfocus==w then\t\t\t!only draw it when this window has the focus\n\treturn\nend\n\ncaretdrawn:=0\n\ndrawcaret(1)\nend\n\nproc do_draw_arrow\t\t\t<\"wx\">\t(w)=\ngxclear(w)\n\ndrawborder(w)\ndrawarrow(w,w.enable)\nend\n\nproc do_draw_mark\t\t\t<\"wx\">\t(w)=\n\ncase w.owner.windclass\nwhen toggle_class, select_class then\n\treturn\t\t\t\t\t!mark drawn by owner\nesac\n\ngxclear(w,getrgb(w.owner.style.windbgnd))\n\ndrawborder(w)\nend\n\nproc do_draw_scrollbar\t\t\t<\"wx\">\t(w)=\ngxclear(w)\ndrawborder(w)\ngxdraw(w.childlist[1])\t\t\t!arrows\ngxdraw(w.childlist[2])\n\n!now draw the thumb\nif w.attrs.thumbsize then\n\tif w.style.dir='H' then\n\t\tx:=w.attrs.thumbpos\n\t\tdx:=w.attrs.thumbsize\n\t\tdrawthumb(w,x,0,dx,w.dimy)\n\telse\n\t\ty:=w.attrs.thumbpos\n\t\tdy:=w.attrs.thumbsize\n\t\tdrawthumb(w,0,y,w.dimx,dy)\n\tfi\nfi\nend\n\nproc do_draw_listbox\t\t\t<\"wx\">\t(w)=\ngxclear(w)\ndrawborder(w)\nif w.childlist then\t\t\t!scrollbar\n\tgxdraw(w.childlist[1])\nfi\n\nfor i:=1 to w.attrs.rows do\n\tk:=i+w.attrs.pagepos-1\n\tif k<=getlvbounds(w.linkvar).len then\n\t\tdrawlbtext(w,i,getlvstritem(w.linkvar,k),0,k=w.attrs.currpos)\n\tfi\nod\nend\n\nproc do_update_all\t\t\t\t<\"wx\">\t(w)=\ngxdraw(w)\nend\n\nproc do_update_listbox\t\t\t<\"wx\">\t(w)=\ngxdraw(w)\nend\n\nproc drawcaret(x)=\n!x=1: draw caret in wfocus window at current position\n!x=0: delete caret in wsfocus window\n!returns x-pixel position of caret\n\nif wfocus=nil then\t\t!no window has focus\n\tcaretdrawn:=0\n\treturn\nfi\n\ncase wfocus.windclass\nwhen editbox_class then\n\tif x then\t\t\t!new caret\n\t\tif caretdrawn then return fi\t!already drawn\n\t\txpos:=getcaretpos(wfocus.linkvar^,wfocus.attrs.currpos,0)\n\t\twfocus.attrs.caretpos:=xpos\t\t\t!record position\n\telse\t\t\t!delete caret\n\t\tif not caretdrawn then return fi\t!already deleted\n\t\txpos:=wfocus.attrs.caretpos\t\t!use stored value\n\tfi\n\n\tcaretwidth:=2\n\n\tgxhighlight(wfocus,xpos+wfocus.attrs.textpos[1],wfocus.attrs.textpos[2]-chd,caretwidth,20)\n\n\tcaretdrawn:=x\nesac\nend\n\nfunc getcaretpos(s,pos,offset)=\n!return pixel position of in front of pos'th character in string s\n!offset is no. of chars not shown, to left of string\nif pos=1 then return 0 fi\n\nreturn wx_gettextwidth(wfocus.gdi.hdc, leftstr(s,pos-1))\nend\n\nproc drawborder(w)=\n!do own-drawn borders\n!other kinds of borders are windows-drawn, no-border, and the main bs- style\n!borders which exist in the owner's client area\n!for own-drawn borders, the window should have been cleared first\n\ncase bscat[w.style.border]\nwhen 0 then\t\t\t\t\t!no border\n\treturn\nwhen 'W' then\t\t\t\t!windows-drawn\n\treturn\nwhen 'X' then\t\t\t\t!external (drawn in owner's client space\n\tposx:=w.frameposx\n\tposy:=w.frameposy\n\tdimx:=w.framedimx\n\tdimy:=w.framedimy\n\tbs:=w.style.border\n\n\tbs:=w.style.border\n\two:=w.owner\n\tcase bs\n\twhen bs_simple then\t\t\t!USUALLY BS_SIMPLE converts to BS_WINDOWS; must be override\n\t\tgxcolour(wo,0)\n\t\tgxrect(wo,posx,posy,dimx,dimy)\n!\t\tgxline(wo,posx,posy,posx+dimx+50,posy+dimy+50)\n\twhen bs_thick then\n\twhen bs_panel then\n\t\tgxcolour(wo,ltcolour)\n\t\tgxline(wo,posx+dimx-1,posy, posx,posy)\n\t\tgxline(wo,posx,posy+dimy-1)\n\t\tgxcolour(wo,dkcolour)\n\t\tgxline(wo,posx+dimx-1,posy+dimy-1)\n\t\tgxline(wo,posx+dimx-1,posy)\n\twhen bs_inset then\n\t\tgxcolour(wo,dkcolour)\n\t\tgxline(wo,posx+dimx-1,posy, posx,posy)\n\t\tgxline(wo,posx,posy+dimy-1)\n\t\tgxcolour(wo,ltcolour)\n\t\tgxline(wo,posx+dimx-1,posy+dimy-1)\n\t\tgxline(wo,posx+dimx-1,posy)\n\twhen bs_testext then\n\t\tgxcolour(wo,0)\n\t\tgxrect(wo,posx,posy,dimx,dimy)\n\t\tgxrect(wo,posx+9,posy+9,dimx-18,dimy-18)\n!\t\tgxcolour(w,0)\n!\t\tgxline(w,0,0,w.dimx-1,w.dimy-1)\n!\t\tgxline(w,0,w.dimy-1,w.dimx-1,0)\n\n\tesac\nwhen 'I' then\t\t\t\t!internal (drawn within window's client space\n\tposx:=w.frameposx\n\tposy:=w.frameposy\n\tdimx:=w.dimx\n\tdimy:=w.dimy\n\n\tcase w.style.border\n\twhen bs_ownpanel then\n\t\tgxcolour(w,ltcolour)\n\t\tgxline(w,w.framedimx-1,0,0,0)\n\t\tgxline(w,0,w.framedimy-1)\n\t\tgxcolour(w,dkcolour)\n\t\tgxline(w,w.framedimx-1,w.framedimy-1)\n\t\tgxline(w,w.framedimx-1,0)\n\n\twhen bs_owninset then\n\t\tgxcolour(w,dkcolour)\n\t\tgxline(w,w.framedimx-1,0,0,0)\n\t\tgxline(w,0,w.framedimy-1)\n\t\tgxcolour(w,ltcolour)\n\t\tgxline(w,w.framedimx-1,w.framedimy-1)\n\t\tgxline(w,w.framedimx-1,0)\n\twhen bs_ownsimple then\n\t\tgxcolour(w,0)\n\t\tgxrect(w,0,0,w.framedimx,w.framedimy)\n\twhen bs_testint then\n\t\tgxcolour(w,0)\n\t\tgxrect(w,0,0,dimx,dimy)\n\t\tgxrect(w,7,7,dimx-14,dimy-14)\n!\t\tgxcolour(w,0)\n!\t\tgxline(w,0,0,w.dimx-1,w.dimy-1)\n!\t\tgxline(w,0,w.dimy-1,w.dimx-1,0)\n\tesac\nesac\nend\n\nproc drawchildborders(w)=\nif not w.childlist then\n\treturn\nfi\nfor wc in w.childlist do\n\tif wc.style.border in [bs_simple,bs_thick,bs_panel,bs_inset] then\n\t\tdrawborder(wc)\n\tfi\nod\nend\n\nproc drawarrow(w,enable)=\n!w has already been cleared\n!e=1/omitted to enable, 0 to disable (shown grey)\nconst factor=0.3\n\ngxsetpen(w,(enable|black|dkgrey))\n\nwidth:=w.dimx\nheight:=w.dimy\n\ncase w.style.dir\nwhen 'D' then\n\tx:=int(round(width/2)-1)\n\n\twd:=0\n\n\th:=int(round(min(height,width)*factor))\n\tif h<3 then h:=3 fi\n\ty:=int((height+h)*0.5)-1\n\n\tto h do\n\t\tgxline(w,x,y,x+wd,y)\n\t\tx-:=1\n\t\ty-:=1\n\t\twd+:=2\n\tod\n\nwhen 'U' then\n\tx:=int(round(width/2)-1)\n\twd:=0\n\n\th:=int(round(min(height,width)*factor))\n\tif h<3 then h:=3 fi\n\ty:=int(round((height-h)*0.5))\n\tto h do\n\t\tgxline(w,x,y,x+wd,y)\n\t\tx-:=1\n\t\ty+:=1\n\t\twd+:=2\n\tod\n\nwhen 'L' then\n\ty:=height%2\n\n\tht:=0\n\twd:=y\n\n\twd:=int(round(min(height,width)*factor))\n\tif wd<3 then wd:=3 fi\n\tx:=int(round((width-wd)*0.5)-1)\n\n\tto wd do\n\t\tgxline(w,x,y,x,y+ht)\n\t\ty-:=1\n\t\tx+:=1\n\t\tht+:=2\n\tod\n\nwhen 'R' then\n\ty:=height%2\n\tht:=0\n\n\twd:=int(round(min(height,width)*factor))\n\tif wd<3 then wd:=3 fi\n\tx:=int(round((width+wd)*0.5)-1)\n\n\tto wd do\n\t\tgxline(w,x,y,x,y+ht)\n\t\ty-:=1\n\t\tx-:=1\n\t\tht+:=2\n\tod\nesac\nend\n\nexport proc gxtext_just(w,s,offset=0,enable=1)=\n\n!CPL \"GXTEXT JUST\"\n\n\tdimx:=w.dimx\n\tdimy:=w.dimy\n\twidth:=wx_gettextwidth(w.gdi.hdc, s)\n\theight:=chy\t\t\t\t!assume basic font\n\n\tcase w.style.justify\n\twhen 'L' then\tx:=smx\n\twhen 'R' then\tx:=dimx-width-smx\n\telse\n\t\t\t\tx:=(dimx-width)%2\n\tesac\n\n\tcase w.style.vjustify\n\twhen 'T' then\ty:=smy\n\twhen 'B' then\ty:=dimy-height-smy\n\telse\n\t\t\t\ty:=(dimy-height)%2!\t\t-smy%2\n\tesac\n\n\tif not enable then\n\t\toldtextfgnd:=w.style.textfgnd\n\t\tgxtextcolour(w,grey)\n\tfi\n\n\tgxtext(w,s,x+offset,y)\n\n\tif not enable then\n\t\tgxtextcolour(w,oldtextfgnd)\n\tfi\n\tif w.windclass=editbox_class then\n\t\tw.attrs.textpos:=(x+offset,y)\n\tfi\nend\n\nproc drawthumb(w,x,y,dx,dy)=\n!w is a scrollbar, vert or hoz\n!draw thumb within w, as a simple rectangle starting at x,y at top left of size dx,dy\n\ngxcolour(w,0)\ngxrect(w,x,y,dx,dy)\ngxfillrect(w,x+1,y+1,dx-2,dy-2,getrgb(grey))\nend\n\nfunc isonthumb(w,d)=\n!w is a scrollbar, d is a pixel position along it (0 being at left or top)\n!return:\n! -1\tis before the thumb\n!  0\tis on the thumb\n! +1\tif after the thumb\n!d can specify a spot off the thumbar if being dragged\n\na:=w.attrs.thumbpos\nb:=w.attrs.thumbsize\n\nif d<a then\n\treturn -1\nelsif d>(a+b) then\n\treturn 1\nelse\n\treturn 0\nfi\nend\n\nproc drawmark(w,turnedon,enable)=\n!!w has already been cleared\n!draw checked check mark, tick, or radio button, according to whether\n!turnedon is 1 or 0\n!e=1 to enable, 0 to disable (shown grey)\n\ngxclear(w,getrgb(w.owner.style.windbgnd))\ngxsetpen(w,(enable|black|red))\n\nwidth:=w.dimx\nheight:=w.dimy\nx:=y:=1\nwd:=width-2\nht:=height-2\ngxrect(w,x,y,wd,ht)\nif not turnedon then return fi\n\ncase w.style.marktype\nwhen radio_mark then\n\n\tgxfillrect(w,x+3,y+3,wd-6,ht-6,getrgb(red))\n\nwhen check_mark then\n\n\tgxline(w,x,y,x+wd-1,y+ht-1)\n\tgxline(w,x+wd-1,y,x,y+ht-1)\n\nwhen tick_mark then\n\n\tgxline(w,x+3,y+ht%2,x+wd%2,y+ht-4)\n\tgxline(w,x+wd-3,y+2)\n\nesac\nend\n\nproc drawlbtext(w,row,text,clr=0,hilite=0)=\n!draw text inside given row of listbox w\n!clr=1 to clear the background first (not needed when entired lb has been cleared)\n!hilite=1 to highlight this row\n\nx:=0\ny:=(row-1)*w.attrs.pitch+w.attrs.offset\n\nif clr or hilite then\n\tgxfillrect(w,x,y,w.dimx,w.attrs.pitch,(hilite|getrgb(grey)|getrgb(w.style.windbgnd)))\nfi\n\nif hilite then\n\toldtextcolour:=gxtextcolour(w)\n\tgxtextcolour(w,white)\nfi\n!RETURN\n\ngxtext(w,text,x+smx,y+smy)\nif hilite then\n\tgxtextcolour(w,oldtextcolour)\nfi\nend\n\nfunc readnextitem(a)=\n!return (level,value,labelx,options)\n!special values used for divider, new column, new menu\n!next line of file should already have been read\n\nif a=\"\" then return list(0,0,0,0) fi\n\nlevel:=1\ntabs:=0\noptions:=\"\"\n\nwhile asc(a) in [9,' '] do tabs+:=1; a:=rightstr(a,-1) od\n\nif a=\"\" then return list(0,0,0,0) fi\n\ncase asc(a)\nwhen '!' then\n\treturn list(0,0,0,0)\nesac\n\nif tabs then\n\tj:=0\n\tfor i:=1 to ntab do\n\t\tif tabs=tabstack[i] then j:=i; exit fi\n\tod\n\n\tif j=0 then\n\t\tif tabs>tabstack[ntab] then\n\t\t\tntab+:=1\n\t\t\ttabstack[ntab]:=tabs\n!\t\t\tmenustack[ntab]:=0\n\t\tfi\n\t\tlevel:=ntab\n\telse\n\t\tlevel:=j\n\t\tif j<ntab then ntab:=j fi\n\tfi\nfi\n\nif asc(a) in ['0'..'9'] then\n\tvalue:=strtoval(a)\n\tn:=\" \" inx a\n\tif not n.isfound then\n\t\tn:=chr(9) in a\n\tfi\n\tif n.isfound then\n\t\tlabelx:=rightstr(a,-n)\n\telse\n\t\tlabelx:=\"?\"\n\tfi\n\nelse\t\t\t!no preceding number, maybe top-level menu\n\n\tif \"=\" in a then\t!command def for mpl\n\t\treturn (0,0,0,0)\n\tfi\n\n\tvalue:=k_menu\n\tlabelx:=a\n\tcase convlc(labelx)\n\twhen \"hozbreak\",\"divider\" then\n\t\tvalue:=kdivide\n\twhen \"vertbreak\" then\n\t\tvalue:=kcolumn\n\twhen \"filehistory\" then\n\t\tvalue:=kfilehistory\n\telse\n\t\tif leftstr(labelx)=\"-\" then value:=kdivide fi\n\tesac\nfi\n\nif labelx=\"\" then\t\t\t!maybe [cmd] only\n\treturn list(0,0,0,0)\nfi\n\nreturn (level,value,(labelx),options)\nend\n\nfunc readmenu(m,n,level)=\n!starting at index n in data, read all following items that are\n!at lower level (ie. higher level number) than given level\n!insert items into menu handle m\n!return index of next item in data, which is at <level> or higher\n!will stop at end of data, and return ndata+1\n\nrestartx:\nfor i:=n to ndata do\n\t(l,value,labelx,options):=data[i]\n\n\tif l<=level then\t\t!end of this submenu\n\t\treturn i\n\tfi\n\n\tflags:=breakflag\n\tenable:=1\n\tif rightstr(labelx)=\"?\" then\n\t\tenable:=0\n\t\tlabelx:=leftstr(labelx,-1)\n\tfi\n\n\tif options<>\"\" then\n\t\tif \"H\" in options then flags+:=\"h\" fi\n\t\tif \"C\" in options then flags+:=\"c\" fi\n\tfi\n\n\tcase value\n\twhen kdivide then\n\t\tgxaddmb(m,style:\"d\")\n\twhen kcolumn then\n\t\tbreakflag:=\"v\"\n\twhen k_menu then\t\t!submenu\n\t\tnewm:=gxcreatemb()\n\t\tn:=readmenu(newm,i+1,l)\n\t\tgxaddmb(m,labelx,newm,\"p\"+flags,enable)\n\t\tbreakflag:=\"\"\n\t\tgoto restartx\n\twhen kfilehistory then\n\t\tnfiles:=8\n\t\tgxaddmb(m,\"filehistory\",1060,breakflag)\n\telse\t\t\t\t!ordinary command\nnormalcmd:\n\t\tgxaddmb(m,labelx,value,flags,enable)\n\t\tbreakflag:=\"\"\n\tesac\n\nskip:\nod\n\nreturn ndata+1\t\t\t!eod reached\nend\n\nfunc mbreaddata(a)=\n!a is a list of tab-indented strings for a menu bar\n!a can also be a text file containing the strings\n\ntabstack::=(0,)\nntab:=1\ndata::=()\nndata:=0\nbreakflag:=\"\"\n\nif a.isstring then\t\t!read from file\n\ta:=readtextfile(a)\n\tif a=0 then\n\t\ta:=(\"CANTOPENFILE\",)\n\tfi\nfi\n\nfor i:=1 to a.upb do\n\tx:=readnextitem(a[i])\n\n\tif x[1] then\n\t\t++ndata\n\t\tdata[ndata]:=x\n\tfi\nod\n\nm:=gxcreatemb()\nreadmenu(m,1,0)\nreturn m\nend\n\nexport func gxmenubar(w,?a)=\n!called as:\n!\tgxmenubar(a):\tcreate standalone menu; return handle\n!\tgxmenubar(w,a):\tadd menu to windows w (returns 0)\n!a:\n!\tstring:\t\t\tassume this is a filename containing menubar tabbed layout\n!\tlist:\t\t\ta list of strings containing the data\n\nif a.defined then\t\t!w,m: read menu into window w\n\tm:=mbreaddata(a)\n! mbset(w,0)\n\n!\tif not w.isint then\n\tif not w.ispointer then\n\t\twhile w.owner<>nil do\n\t\t\tw:=w.owner\n\t\tod\n\tfi\n\n\tgxsetmb(w,m)\n\treturn 0\nelse\t\t\t\t!create standalone menu, return handle\n\treturn mbreaddata(w)\nfi\nend\n\nfunc gxcreatemb(?s)=\n\n!CPL \"MBCREATE:\",S\nif s.defined and s in \"Pp\" then\n\treturn createpopupmenu()\nelse\n\treturn createmenu()\nfi\nend\n\nproc gxsetmb(w,m)=\n\nhwnd:=w.gdi.hwnd\na:=getmenu(hwnd)\ns:=setmenu(hwnd,m)\nif a then destroymenu(a) fi\nend\n\nfunc gxaddmb(wm,caption=\"X\",id=0,style=\"\",enable=0)=\n\nif wm.ispointer then\t\t\t\t!assume handle\n\thmenu:=wm\n\twm:=nil\nelse\n\thmenu:=getmenu(wm.gdi.hwnd)\nfi\n\n!CPL \"WM,HMENU=\",WM,HMENU,ENABLE\n\nflags:=mf_string ior mf_unchecked\n\nif not enable then flags ior:=mf_greyed fi\n\nforeach c in convuc(style) do\n!for c in convuc(style) do\n\tcase c\n\twhen 0 then exit\n\twhen 'P' then flags ior:=mf_popup\n\twhen 'D' then flags ior:=mf_separator\n\twhen 'B' then flags ior:=mf_menubreak\n\twhen 'V' then flags ior:=mf_menubarbreak\n\twhen 'H' then flags ior:=mf_help\n\twhen 'C' then flags ior:=mf_checked\n\tesac\nod\n\nif appendmenu(hmenu,flags,id,caption) then\n\tif wm<>nil then drawmenubar(wm.gdi.hwnd) fi\n\treturn hmenu\nfi\nreturn 0\nend\n\nproc gxshowmb(wm,w,x,y)=\n!update menu associated with window; call this func if it has been updated\n!when wm is a menu handle, draw the popup on the screen at x,y\n!if wm.isint then\nif wm.ispointer then\n\n\tif not y.defined then\n\t\tx:=w\n\t\ty:=x\n\t\tw:=nil\n\t\thwnd:=wapplic.gdi.hwnd\n\telse\n\t\thwnd:=w.gdi.hwnd\n\tfi\n\n\tpos:=ws_point(x,y)\n\n\tif w<>nil then\n\t\tclienttoscreen(w.gdi.hwnd,&pos)\n\tfi\n\n\ttrackpopupmenu(wm,0,pos.x,pos.y,0,hwnd,0)\nelse\n\tdrawmenubar(wm.gdi.hwnd)\nfi\nend\n\nfunc gxenablemb(wm,id,enable)=\n\n!if wm.isint then\t\t\t\t!assume handle\nif wm.ispointer then\t\t\t\t!assume handle\n\thmenu:=wm\nelse\n\thmenu:=getmenu(wm.gdi.hwnd)\nfi\n\nif enable.defined then\n\treturn enablemenuitem(hmenu,id,(enable|0|mf_greyed)+mf_bycommand)\nelse\n\treturn (getmenustate(hmenu,id,mf_bycommand) iand mf_greyed|0|1)\nfi\nend\n\nfunc gxcheckmb(wm,id,check)=\n!if wm.isint then\t\t\t\t!assume handle\nif wm.ispointer then\t\t\t\t!assume handle\n\thmenu:=wm\nelse\n\thmenu:=getmenu(wm.gdi.hwnd)\nfi\n\nif check.defined then\n\treturn checkmenuitem(hmenu,id,(check|mf_checked|mf_unchecked)+mf_bycommand)\nelse\n\treturn (getmenustate(hmenu,id,mf_bycommand) iand mf_checked|1|0)\nfi\nend\n\nproc gxclosemb(m)=\ndestroymenu(m)\nend\n\nexport func gxconfirm(m)=\nx:=gxmsgbox(m,\"Confirm\",\"byn\")\nreturn x=\"yes\"\nend\n\nfunc issubwindow(w,w2)=\nwhile w2 do\n\tif w2==w then return 1 fi\n\tw2:=w2.owner\nod\nreturn 0\nend\n\nexport proc flushmessages=\n\nend\n",
    
(byte*)"!BMLIB\n\n!!import sys\n!import clib\n!!import files\n!import winapi\n!import winconsts\n!import gxlib\n!\nVAR DEBUG=0\n\n\n!importdll jpeg=\n!\tmlang func \"jpeg.loadjpeg\" as loadjpeg\t(string, ref byte, ref byte)ref byte\n!\tmlang proc     \"jpeg.freejpeg\" as freejpeg (ref byte)\n!end\n!\n!!importdll loadimg =\nimportdll imglib =\n!importdll stb_image=\n!!    clang func stbi_load\t\t(string, ref byte, ref byte, ref byte, int32)ref byte\n    clang func imgload_rgb\t\t(stringz, ref byte, ref byte, ref byte, int32)ref byte\n\n    clang func imgload_bgr\t\t(stringz, ref int32, ref int32, ref int32, int32)ref byte\n!    clang func imgload_bgr\t\t(stringz, ref int32, ref int32, ref int32)ref byte\n\n    clang procedure     imgload_free\t\t(ref byte)\n    clang func imgsave_jpeg_rgb\t(stringz, ref byte, int32, int32, int32)int32\n    clang func imgsave_jpeg_bgr\t(stringz, ref byte, int32, int32, int32)int32\n!    clang procedure     stbi_image_free\t(ref byte)\nend\n\ntype bmpheader = struct\n\tws_bitmapfileheader fh\n\tws_bitmapinfoheader bh\nend\n\nvar\tshifts=[2:1, 4:2, 8:3, 16:4, 32:5, 64:6]\n\nproc start=\nend\n\nproc main=\n\n!C\n\n!PASTETEST()\n\nCPL \"TESTING BMMAIN\"\n!FILE:=\"C:/JPEG/GIRL.JPG\"\nFILE:=\"C:/JPEG/SMALLGIRL.JPG\"\n!FILE:=\"C:/JPEG/freya.JPG\"\n\n!FILE:=\"C:/JPEG/CARD2.JPG\"\n!FILE:=\"C:fred.ppm\"\n\n!!FILE:=\"C:/PNG/basi2C16.png\"\n!BM:=BMLOAD(FILE)\nBM:=BMLOADJPG(FILE)\n!CPL =BM.TYPE\nIF NOT BM THEN STOP FI\n\n!CPL \"LOADED\"\n!STOP\n!BMSAVE(\"FRED.PPM\",BM)\n!BMSAVE(\"FRED.PPM\",BM,0)\n!\n!!CPL \"SAVED\"\n!!!bmfree(bm)\n!!\n!!BMPUTCLIPBOARD(bm)\nw:=GXCREATEWINDOW(DIM:(960,540),caption:\"HI THERE\")\n!gxcopy(w,bm,scalex:0.25)\n!gxcopy(w,bm,scalex:0.5)\ngxcopy(w,bm,scalex:5.0, x:100)\neventloop()\n\nend\n\n!export func bmcreate(pixelbits,width,height,maskptr=nil)=\nexport func bmcreate(pixelbits,width,height)=\n!create new bitmap with given specs, return handle to bitmap (=rwindow ref)\n!when maskptr<>nil, set up mask values\n\n\tbminfo:=new(ws_bitmapv5header)\n\tbminfo.size:=ws_bitmapv5header.bytes\n\tbminfo.width:=width\n\tbminfo.height:=-height\n\tbminfo.planes:=1\n\tbminfo.bitcount:=pixelbits\n\n\tpixelptr:=nil\n\n\tif pixelbits not in [8,24,32] then\n\t\tabort(\"bmcreate pixel size not supported:\"+tostr(pixelbits))\n\tfi\n\n!\thwnd:=createdibsection(screendc,&bminfo,0,&pixelptr,0,0)\n\n!CPL =BMINFO.BYTES\n!CPL =WS_BITMAPV5HEADER.BYTES\n!CPL =BMINFO.SIZE\n!CPL =BMINFO.WIDTH\n!CPL =BMINFO.HEIGHT\n!CPL =BMINFO.PLANES\n!CPL =BMINFO.BITCOUNT\n!\n!\n!CPL =(&BMINFO).TYPE\n!CPL =(&PIXELPTR).TYPE\n!!CPL =(&BMINFO)^\n!CPL =(&PIXELPTR)^\n\n\thwnd:=createdibsection(nil,&bminfo,0,&pixelptr,nil,0)\n!X:=GETLASTERROR()\n!\thwnd:=createdibsection(nil,&bminfo,0,pixelptr,0,0)\n\n!(wt_handle, wt_ptr, wt_uint, wt_ptr, wt_handle,wt_dword)wt_handle\n\n!CPL =HWND\n!\n!IF NOT HWND THEN\n!CPL =X\n!CPL =GETLASTERROR()\n!\tABORT(\"CREATEDIB FAILURE\")\n!FI\n!\n\tpixelptr:=makeref(pixelptr,byte)\n\n\tif hwnd=0 then\n\t\terror:=getlasterror()\n\t\tabort(\"bmcreate:CreateDIB failed:\"+tostr(error))\n\tfi\n\n!now create a bm record based around this handle\n\n\tbm:=new(rwindow,0)\n\tbm.windclass:=bitmap_class\n\n\tbm.dimx:=width\n\tbm.dimy:=abs(height)\t\t!neg height used for top-down bitmaps\n\n\tbm.style:=defstyle\n\n\tbm.pixelbits:=pixelbits\n\tbm.pixelptr:=pixelptr\n!\tbm.pixelptr:=pixelptr\n\n!\tbm.attrs:=bitmaprec(pixelbits,pixelptr,0,0,0)\t\t!pixelbytes/linebytes/ncolours are zero\n\n!set bytes per pixel\n\tbm.pixelbytes:=pixelbits%8\n\n!set bytes per scanline\n\tn:=bm.pixelbytes*width\n\n!n must be a multiple of 4 bytes\n\tif (n iand 3)<>0 then\t!make bytes a multiple of 4\n\t\tn:=(n+4) iand 0xfffc\n\tfi\n\tbm.linebytes:=n\n\tbm.framebytes:=bm.linebytes*bm.dimy\n\n!set palette colours, using winrgb order\n\tif pixelbits=8 then\n\t\tpalette:=new(array,int32,0..255)\n\t\tbm.paltype:=greyscale_pal\n\t\tcolour:=0\n\t\tfor i:=0 to 255 do\n\t\t\tpalette[i]:=colour\n\t\t\tcolour+:=0x10101\n\t\tod\n\tfi\n\n\tsetupgdi(bm,hwnd)\n\n\tbm.gdi.hdc:=createcompatibledc(nil)\n\tbm.gdi.drawmode:=dm_memory\n\tbm.gdi.oldbmobj:=selectobject(bm.gdi.hdc,hwnd)\t!should store original bitmap\n\tsetstretchbltmode(bm.gdi.hdc,4)\t\t\t!average pixels for best result\n\n\tbmputpalette(bm,palette)\n\n\treturn bm\nend\n\nexport func bmgetpalette(bm)=\n!extract entire palette to p, in bmrgb order\n\tif bm.paltype then\n\t\tpalette:=new(array,int32,0..256)\n\t\tgetdibcolortable(bm.gdi.hdc,0,256,&palette)\n\t\tpalette[256]:=bm.paltype\n\t\treversepalette(palette)\n\telse\n\t\tpalette:=()\n\tfi\n\treturn palette\nend\n\nexport proc bmputpalette(bm,p,reverse=1)=\n!update entire palette from p, in bmrgb order\n\tif bm.paltype then\n\t\tif reverse then reversepalette(p) fi\t\t!fix colours\n\t\tsetdibcolortable(bm.gdi.hdc,0,256,&p)\t!store\n\t\tif reverse then reversepalette(p) fi\t\t\t!restore orignal palette\n\t\tif p.upb=256 then\n\t\t\tbm.paltype:=p[256]\n\t\tfi\n\tfi\nend\n\nexport func bmcolour(bm,n,?colour)=\n!get/set palette info:\n!n=given:\n! colour given: update colour entry\n! colour omitted(-1): return colour value\n\n\tif colour.isdef then\t\t!set colour\n\t\tcolour:=revpixel(colour)\n\t\tsetdibcolortable(bm.gdi.hdc,n,1,&colour)\n\t\treturn colour\n\telse\t\t\t\t!get colour\n\t\tcolour:=0\n\t\tgetdibcolortable(bm.gdi.hdc,n,1,&colour)\n\t\treturn revpixel(colour)\n\tfi\nend\n\nexport proc reversepalette(&p)=\n!reverse values of 32-bit colour data at p\n!CPL \"REV PALETTE\"\n\tfor i:=0 to 255 do\n\t\tp[i]:=revpixel(p[i])\n\tod\nend\n\nexport func revpixel(a)=\n!change rgb to bgr\n!windows colours use red in lsb, bitmaps use blue in lsb, in 24-bit pixels and palette colours\nreturn (a iand 0x00ff00) ior (a>>16 iand 255) ior ((a iand 255)<<16)\nend\n\nexport proc bmshow(bm)=\n\tgxcopy(bm)\nend\n\nexport proc bmfree(bm)=\n\treturn when bm=nil\n\tif not deletedc(bm.gdi.hdc) then\n\t\tpcerror(\"ERROR DELETING BM/HDC\")\n\tfi\n\n\tif not deleteobject(bm.gdi.hwnd) then\n\t\tpcerror(\"ERROR DELETING DIB\")\n\tfi\nend\n\nexport func bmdupl(bm)=\n\tnewbm:=bmcreate(bm.pixelbits, bm.dimx, bm.dimy)\n\tmemcpy(newbm.pixelptr, bm.pixelptr, bm.linebytes*bm.dimy)\n\n\tbmduplpalette(newbm,bm)\n\n\treturn newbm\nend\n\nexport proc bmduplpalette(newbm,bm)=\n\tif bm.paltype then\n\t\tpal:=bmgetpalette(bm)\n\t\tbmputpalette(newbm,pal)\n\t\tnewbm.paltype:=bm.paltype\n\tfi\nend\n\nexport func bmduplz(bm)=\n\tnewbm:=bmcreate(bm.pixelbits, bm.dimx, bm.dimy)\n\treturn newbm\nend\n\nexport func bmgetptr(bm,x,y)=\n!return byte pointer to given pixel\n\treturn bm.pixelptr+(bm.linebytes*y+x*bm.pixelbytes)\nend\n\nexport func bmgetrowptr(bm,y)=\n!\treturn makeref(bm.pixelptr+y*bm.linebytes,byte)\n\treturn bm.pixelptr+y*bm.linebytes\nend\n\nfunc getcbbitmap(hwnd)=\n\n\tp:=globallock(hwnd)\n\thsize:=ws_bitmapinfoheader.bytes\n\tbm:=nil\n\n\tif p then\n\t\tp:=makeref(p,ws_bitmapinfoheader)\n\t\tpb:=makeref(p,byte)\n\n\t\tbm:=bmcreate(p^.bitcount,p^.width,p^.height)\n\t\toffset:=(bm.paltype|1024|0)\t\t!offset due to palette table\n\n\t\tif offset then\n\t\t\tsetdibcolortable(bm.gdi.hdc,0,256,pb+hsize)\n\t\tfi\n\n\t\tpb:=pb+hsize+offset\n\t\tfor y:=0 to bm.dimy-1 do\n\t\t\tq:=bmgetrowptr(bm,bm.dimy-y-1)\n\t\t\tmemcpy(q,pb,bm.linebytes)\n\t\t\tpb:=pb+bm.linebytes\n\t\tod\n\n\tfi\n\n\tglobalunlock(hwnd)\n\n\treturn bm\nend\n\nexport func bmgetclipboard=\n!get image from clipboard if one is there, otherwise return nil\n\tif openclipboard(0)=0 then\n\t\treturn nil\n\tfi\n\n\thwnd:=getclipboarddata(cf_dib)\n\n\tbm:=nil\n\tif hwnd then\n\t\tbm:=getcbbitmap(hwnd)\n\tfi\n\n\tcloseclipboard()\n\n\treturn bm\nend\n\nexport func bmputclipboard(bm)=\n\tif openclipboard(0)=0 then\n\t\treturn nil\n\tfi\n\n\temptyclipboard()\n\n\thwnd:=putcbbitmap(bm)\n\tif hwnd then\n\t\tsetclipboarddata(cf_dib,hwnd)\n\tfi\n\n\tcloseclipboard()\n\treturn 1\nend\n\nfunc putcbbitmap(bm)=\n\thsize:=ws_bitmapinfoheader.bytes\n\tpsize:=(bm.paltype|1024|0)\n\tfsize:=bm.linebytes*bm.dimy\n\n\thmem:=globalalloc(0,hsize+psize+fsize)\n\tmem:=makeref(globallock(hmem),byte)\n\n\thdr:=new(ws_bitmapinfoheader)\n\thdr.size:=hsize\n\thdr.width:=bm.dimx\n\thdr.height:=bm.dimy\n\thdr.bitcount:=bm.pixelbits\n\thdr.planes:=1\n\thdr.xpelspermetre:=11811\n\thdr.ypelspermetre:=11811\n\thdr.clrused:=0\n\n\tmemcpy(mem,&hdr,hsize)\n\n\tif psize then\n\t\tpal:=bmgetpalette(bm)\n\t\tmemcpy(mem+hsize,&pal,psize)\n\tfi\n\n\tmem:=mem+hsize+psize\n\tfor y:=0 to bm.dimy-1 do\n\t\tp:=bmgetrowptr(bm,bm.dimy-1-y)\n\t\tmemcpy(mem, p, bm.linebytes)\n\t\tmem:=mem+bm.linebytes\n\tod\n!\tmemcpy(mem+hsize+psize,bm.pixelptr,fsize)\n\tglobalunlock(hmem)\n\n\treturn hmem\nend\n\nproc copy24to8(newbm,oldbm)=\n!both images are same size. Copy 1st plane of 24-bit oldbm to 8-bit newbm\n\tfor y:=0 to oldbm.dimy-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(oldbm,y)\n\t\tto oldbm.dimx do\n\t\t\tp++^:=q^\n\t\t\tq:=q+3\n\t\tod\n\tod\nend\n\n!proc copy8to24(newbm,oldbm)=\n!!both images are same size. Copy only plane of 8-bit oldbm to all planes of 24-bit newbm\n!\tfor y:=0 to oldbm.dimy-1 do\n!\t\tp:=bmgetrowptr(newbm,y)\n!\t\tq:=bmgetrowptr(oldbm,y)\n!\t\tto oldbm.dimx do\n!\t\t\tp++^:=q^\n!\t\t\tq:=q+3\n!\t\tod\n!\tod\n!end\n\nexport proc bmresetpalette(bm)=\n# set palette back to greyscale\n\tpal:=new(array,int32,0..256)\n\tcolour:=0\n\tfor i:=0 to 255 do\n\t\tpal[i]:=colour\n\t\tcolour+:=0x010101\n\tod\n\tbmputpalette(bm,pal)\n\tbm.paltype:=greyscale_pal\nend\n\nfunc makescalemap(x)=\n!x=0..1; create 256-element lookup table to multiply 0..255 by x\n\tmap:=new(list,0..255)\n\tfor i:=0 to 255 do\n\t\tmap[i]:=clamp(int(round(i*x)),0,255)\n\tod\n\treturn map\nend\n\nfunc bmunimpl(mess)=\n!ABORT(\"UNIMPLEMENTED: \"+MESS)\nPRINTLN \"UNIMPLEMENTED:\",MESS\nPRINTLN \"ABORTING\"\nSTOP\nreturn 0\nend\n\n!===========================================================================\n!========= HANDLERS\n!===========================================================================\n\nexport func bmload(filename)=\n!CPL \"BMLOAD:\",FILENAME\n\tcase e:=convlc(extractext(filename))\n\twhen \"jpg\",\"jpeg\" then\n\t\treturn bmloadjpg(filename)\n\twhen \"bmp\" then\n\t\treturn bmloadbmp(filename)\n\twhen \"pgm\" then\n\t\treturn bmloadpgm_p2p5(filename)\n\twhen \"ppm\" then\n\t\treturn bmloadppm_p3p6(filename)\n\twhen \"pbm\" then\n\t\treturn bmloadpbm_p1p4(filename)\n\twhen \"png\" then\n\t\treturn bmloadpng(filename)\n\twhen \"\" then\t\t\t\t!try all\n\t\texts:=(\"jpg\",\"bmp\",\"pgm\",\"ppm\",\"png\")\n\t\tfor ext in exts do\n\t\t\tbm:=bmload(addext(filename,ext))\n\t\t\tif bm then\n\t\t\t\treturn bm\n\t\t\tfi\n\t\tod\n\t\treturn nil\n\telse\n\t\tprintln \"CAN'T LOAD\",E,\"IMAGE\"\n\t\treturn nil\n\tesac\n\treturn nil\nend\n\nfunc bmloadbmp(filename)=\n\tf:=openfile(filename)\n\tif not f then return nil fi\n\n\tfileheader:=new(bmpheader)\n\n\treadrandom(f,&fileheader,0,bmpheader.bytes)\n\tfiledimx:=fileheader.bh.width\n\tfiledimy:=fileheader.bh.height\n\tinvert:=1\n\tif filedimy<0 then\n\t\tfiledimy:=abs(filedimy)\n\t\tinvert:=0\n\tfi\n\n\tif fileheader.fh.typex<>'BM' then\n\t\tclosefile(f)\n\t\treturn nil\n\tfi\n\n\tif fileheader.bh.compression<>0 then\n\t\tclosefile(f)\n\t\treturn nil\n\tfi\n\n\tbm:=bmcreate(fileheader.bh.bitcount,filedimx,filedimy)\n\tframebytes:=bm.linebytes*filedimy\n\n\tif bm.paltype then\n\t\tpalette:=new(array,int32,0..255)\n\t\treadrandom(f,&palette,bmpheader.bytes,1024)\n\t\tbmputpalette(bm,palette,0)\n\t\tcolour:=0\n\t\tfor i:=0 to 255 do\n\t\t\tif palette[i]<>colour then\n\t\t\t\tbm.paltype:=colour_pal\n\t\t\t\texit\n\t\t\tfi\n\t\t\tcolour+:=0x010101\n\t\tod\n\n\tfi\n\n\treadrandom(f,bm.pixelptr,fileheader.fh.offbits,framebytes)\n\tclosefile(f)\n\n\n\tif invert then\n\t\tn:=bm.linebytes\n\t\tbuffer:=makeref(malloc(n),byte)\n\n\t\tfor y:=0 to filedimy%2 do\n\t\t\tp:=bmgetrowptr(bm,y)\n\t\t\tq:=bmgetrowptr(bm,filedimy-1-y)\n!\n\t\t\tmemcpy(buffer,p,n)\n\t\t\tmemcpy(p,q,n)\n\t\t\tmemcpy(q,buffer,n)\n\t\tod\n\t\tfree(buffer)\n\tfi\n\n\treturn bm\nend\n\nexport func bmloadjpg(filename)=\n\tw:=h:=n:=0\n\n!\tp:=imgload_bgr(filename,&w,&h,&n,3)\n!CPL \"LOADJ1\"\n\tp:=imgload_bgr(filename,&w,&h,&n,0)\n!\tp:=imgload_bgr(filename,&w,&h,&n)\n!CPL \"LOADJ2\"\n\n\tpixelbits:=n*8\n\n\tif p=nil then\n\t\treturn nil\n\tfi\n\n\tq:=makeref(p,byte)\n\n\tbm:=bmcreate(pixelbits,w,h)\n\n\tnbytes:=w*h*n\n\tdest:=makeref(bm.pixelptr,byte)\n\n\tto h do\n\t\tmemcpy(dest,q,w*n)\n\t\tdest:=dest+bm.linebytes\n\t\tq:=q+w*n\n\tod\n\n\timgload_free(p)\n\n\treturn bm\nend\n\nfunc bmloadpbm_p1p4(filename)=\nCPL \"CAN'T LOAD PBM\"\nRETURN NIL\n!return bmunimpl(\"bmloadpbm\")\nend\n\nfunc bmloadpgm_p2p5(filename)=\n\nCPL \"LOAD PGM P25\",FILENAME\n\tf:=openfile(filename,\"rb\")\n\tif f=0 then return nil fi\n\n\treadln @f, sig:\"s\"\n\n!CPL =SIG\n\tcase sig\n\twhen \"P5\" then\n\t\tbinary:=1\n\twhen \"P2\" then\n\t\tbinary:=0\n\telse\n\t\tabort(\"Can't read pgm\")\n\t\treturn nil\n\tesac\t\n\n\twidth:=readnextint(f)\n\theight:=readnextint(f)\n\tmaxpix:=readnextint(f)\n\n\tbm:=bmcreate(8,width,height)\n\n\tlinebytes:=width\n\tdest:=makeref(bm.pixelptr,byte)\n\nCPL =WIDTH,=HEIGHT, LINEBYTES,=BM\n\tto height do\n\t\tif binary then\n\t\t\treadbytes(f,dest,width)\t\t\t!will be bgr\n\t\telse\n\t\t\tp:=dest\n\t\t\tto linebytes do\n\t\t\t\tp++^:=readffint(f)\n\t\t\tod\n\t\tfi\n\n\t\tdest:=dest+bm.linebytes\n\tod\n\n\tclosefile(f)\n\n\treturn bm\nend\n\nfunc bmloadppm_p3p6(filename)=\n!read p6 ppm which is binary 24-bit, but will also recognise other formats\n\n!CPL \"P3P6\"\n\tf:=openfile(filename,\"rb\")\n\tif f=0 then return nil fi\n\n\treadln @f, sig:\"s\"\n\n!CPL =SIG\n\tcase sig\n\twhen \"P6\" then\n\t\tbinary:=1\n\twhen \"P3\" then\n\t\tbinary:=0\n\twhen \"P5\",\"P2\" then\n\t\tclosefile(f)\n\t\treturn bmloadpgm_p2p5(filename)\n\twhen \"P4\",\"P1\" then\n\t\tclosefile(f)\n\t\treturn bmloadpbm_p1p4(filename)\n\telse\n\t\tabort(\"Can't read ppm/P3\")\n\t\treturn nil\n\tesac\t\n\n!CPL \"READING P6/P3 PPM\"\n\n\twidth:=readnextint(f)\n\theight:=readnextint(f)\n\tmaxpix:=readnextint(f)\n\n\tbm:=bmcreate(24,width,height)\n\n\tlinebytes:=width*3\n\tdest:=makeref(bm.pixelptr,byte)\n\n\tto height do\n\t\tif binary then\n\t\t\treadbytes(f,dest,linebytes)\t\t\t!will be bgr\n\t\telse\n\t\t\tp:=dest\n\t\t\tto linebytes do\n\t\t\t\tp++^:=readffint(f)\n\t\t\tod\n\t\tfi\n\n\t\tp:=dest\t\t\t\t\t\t\t\t!convert to rgb\n\t\tto width do\n\t\t\tswap(p^,(p+2)^)\n\t\t\tp:=p+3\n\t\tod\n\n\t\tdest:=dest+bm.linebytes\n\tod\n\n\tclosefile(f)\n\n\treturn bm\nend\n\nfunc readnextint(f)=\n\tread x\n\twhile not x.isint and not eof(f) do\n\t\treadln @f,x\n\tod\n\tif not x.isint then return 0 fi\n\treturn x\nend\n\nfunc readffint(f)=\n!read next free-format int from f\n\trepeat\n\t\tc:=inbyte(f)\n\tuntil c in '0'..'9'\n\n\ta:=c-'0'\n\tdo\n\t\tc:=inbyte(f)\n\t\tif c in '0'..'9' then\n\t\t\ta:=a*10+c-'0'\n\t\telse\n\t\t\texit\n\t\tfi\n\tod\n\n\treturn a\nend\n\nfunc bmloadpng(filename)=\nRETURN BMLOADJPG(FILENAME)\n!return bmunimpl(\"bmloadpng\")\nend\n\nexport func bmsave(filename,bm,binary=1)=\n\tcase e:=convlc(extractext(filename))\n\twhen \"jpg\",\"jpeg\" then\n\t\treturn bmsavejpg(filename,bm)\n\twhen \"bmp\" then\n\t\treturn bmsavebmp(filename,bm)\n\twhen \"ppm\" then\n\t\treturn bmsaveppm_p3p6(filename,bm,binary)\n\twhen \"pgm\" then\n\t\treturn bmsavepgm_p2p5(filename,bm,binary)\n\twhen \"pbm\" then\n\t\treturn bmsavepbm_p1p4(filename,bm,binary)\n\telse\n\t\tprintln \"CAN'T SAVE\",E,\"IMAGE\"\n\t\treturn nil\n\tesac\n\treturn nil\nend\n\nfunc bmsavebmp(filename,bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tpixelbytes:=bm.pixelbytes\n\tframebytes:=bm.linebytes*h\n\tpalettebytes:=(pixelbytes=1|1024|0)\n\n\tbmfile:=createfile(filename)\n\tif bmfile=nil then\n\t\treturn 0\n\tfi\n\n\tfileheader:=new(bmpheader)\n\n\tfileheader.fh.typex:='BM'\n\tfileheader.fh.offbits:=bmpheader.bytes+palettebytes\n\tfileheader.fh.size:=fileheader.fh.offbits+framebytes\n\tfileheader.bh.size:=ws_bitmapinfoheader.bytes\n\tfileheader.bh.width:=bm.dimx\n\tfileheader.bh.height:=-bm.dimy\n\tfileheader.bh.bitcount:=bm.pixelbits\n\tfileheader.bh.planes:=1\n\tfileheader.bh.xpelspermetre:=11811\t\t!300 dpi\n\tfileheader.bh.ypelspermetre:=11811\n\tfileheader.bh.clrused:=0\n\n\twriterandom(bmfile,&fileheader,0,bmpheader.bytes)\n\n\tif palettebytes then\n\t\tpalette:=bmgetpalette(bm)\n\t\treversepalette(palette)\n\t\twriterandom(bmfile,&palette,bmpheader.bytes,palettebytes)\n\tfi\n\n\twriterandom(bmfile,bm.pixelptr,fileheader.fh.offbits,framebytes)\n\n\treturn closefile(bmfile)\nend\n\nfunc bmsavejpg(filename,bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tpixelbytes:=bm.pixelbytes\n\tlinebytes:=bm.linebytes\n\n\tp:=q:=malloc(pixelbytes*w*h)\n\n\ts:=makeref(bm.pixelptr,byte)\n\n\tto h do\n\t\tmemcpy(q,s,w*pixelbytes)\n\t\tq:=q+bm.linebytes\n\t\ts:=s+w*pixelbytes\n\tod\n\n\tstatus:=imgsave_jpeg_bgr(filename,p,w,h,pixelbytes)\n\n\tfree(p)\n\n\treturn status\nend\n\nfunc bmsavepbm_p1p4(filename,bm,binary)=\nreturn bmunimpl(\"bmsaveppm\")\nend\n\nfunc bmsavepgm_p2p5(filename,bm,binary)=\nreturn bmunimpl(\"bmsavepgm\")\nend\n\nfunc bmsaveppm_p3p6(filename,bm,binary)=\n!\treturn bmunimpl(\"bmsaveppm\")\n\n\twidth:=bm.dimx\n\theight:=bm.dimy\n\n\tcase bm.pixelbits\n\twhen 24 then\n\twhen 8 then\n\t\treturn bmsavepgm_p2p5(filename,bm,binary)\n\telse\n\t\treturn 0\n\tesac\n\n\tf:=createfile(changeext(filename,\"ppm\"))\n\n\tCPL \"WRITEPPM\",CHANGEEXT(FILENAME,\"PPM\")\n\n\tif not f then return 0 fi\n\n\tprintln @f,(binary|\"P6\"|\"P3\")\n\tprintln @f,width\n\tprintln @f,height\n\tprintln @f,\"255\"\n!\n\tbuffer:=data\n\n\tbuffer:=malloc(bm.linebytes)\n\tif buffer=nil then return 0 fi\n\tbuffer:=makeref(buffer,byte)\n\n\tlinebytes:=width*3\t\t\t!also number of values per line when in text mode\n\n\tfor y:=0 to height-1 do\n\t\tmemcpy(buffer,bmgetrowptr(bm,y),linebytes)\n\t\tp:=buffer\t\t\t\t\t!convert to bgr\n\t\tto width do\n\t\t\tswap(p^,(p+2)^)\n\t\t\tp:=p+3\n\t\tod\n\t\tif binary then\n\t\t\twritebytes(f,buffer,linebytes)\n\t\telse\n\t\t\tp:=buffer\n\t\t\tto linebytes do\n\t\t\t\tprint @f,p++^,,\" \"\n\t\t\tod\n\t\t\tprintln @f\n\t\tfi\n\tod\n\tclosefile(f)\n\treturn 1\nend\n\nexport func bmrotate(bm, angle)=\n\tcase angle\n\twhen 0 then return bmdupl(bm)\n\twhen -90 then return bmrotleft90(bm)\n\twhen +90 then return bmrotright90(bm)\n\twhen 180 then return rot180(bm)\n\tesac\n\treturn bmunimpl(\"bmrotate by \"+tostr(angle))\nend\n\nexport func bmrotleft90(bm)=\n\tcase bm.pixelbits\n\twhen 8 then return rotleft90_8(bm)\n\twhen 24 then return rotleft90_24(bm)\n\twhen 32 then return bmunimpl(\"ROTLEFT90/32\")\n\tesac\n\treturn nil\nend\n\nexport func bmrotright90(bm)=\n\tcase bm.pixelbits\n\twhen 8 then return rotright90_8(bm)\n\twhen 24 then return rotright90_24(bm)\n\twhen 32 then return bmunimpl(\"ROTRIGHT90/32\")\n\tesac\n\treturn nil\nend\n\nexport func rot180(bm)=\n\tnewbm1:=bmfliphoz(bm)\n\tnewbm2:=bmflipvert(newbm1)\n\tbmfree(newbm1)\n\treturn newbm2\nend\n\nfunc rotleft90_8(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tlinebytes:=bm.linebytes\n\n\tnewbm:=bmcreate(8,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,w-y-1,0)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n!\t\t\tq:=q+w\n\t\t\tq:=q+linebytes\n\t\tod\n\tod\n\n\tbmduplpalette(newbm,bm)\n\treturn newbm\nend\n\nfunc rotright90_8(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tlinebytes:=bm.linebytes\n\n\tnewbm:=bmcreate(8,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,y,h-1)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n\t\t\tq:=q-linebytes\n\t\tod\n\tod\n\n\tbmduplpalette(newbm,bm)\n\treturn newbm\nend\n\n!function rotleft90_24(bm)=\n!\tnewbm:=bmcreate(24,bm.dimy,bm.dimx)\n!\n!\txform:=new(array,ws_point,3)\n!\txform[1].y:=bm.dimx\n!\txform[3].x:=bm.dimy\n!\txform[3].y:=bm.dimx\n!\n!\tplgblt(newbm.gdi.hdc,&xform, bm.gdi.hdc,0,0,bm.dimx,bm.dimy, nil,0,0)\n!\n!\treturn newbm\n!end\n\nfunc rotleft90_24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,w-y-1,0)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n\t\t\tp++^:=(q+1)^\n\t\t\tp++^:=(q+2)^\n\t\t\tq:=q+bm.linebytes\n\t\tod\n\tod\n\n\treturn newbm\nend\n\n!function rotright90_24(bm)=\n!\tnewbm:=bmcreate(24,bm.dimy,bm.dimx)\n!\n!\txform:=new(array,ws_point,3)\n!\txform[1].X:=bm.dimy\n!\txform[2].x:=bm.dimy\n!\txform[2].y:=bm.dimx\n!\n!\tplgblt(newbm.gdi.hdc,&xform, bm.gdi.hdc,0,0,bm.dimx,bm.dimy, nil,0,0)\n!\n!\treturn newbm\n!end\n\nfunc rotright90_24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,h,w)\n\n\tfor y:=0 to w-1 do\n\t\tq:=bmgetptr(bm,y,h-1)\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tto h do\n\t\t\tp++^:=q^\n\t\t\tp++^:=(q+1)^\n\t\t\tp++^:=(q+2)^\n\t\t\tq:=q-bm.linebytes\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc rotate8(bm,angle)=\nreturn bmunimpl(\"rotate8\")\nend\n\nexport func bmfliphoz(bm)=\n\tcase bm.pixelbytes\n    when 1 then return fliphoz8(bm)\n    when 3 then return fliphoz24(bm)\n    when 4 then return fliphoz32(bm)\n\tesac\n\treturn nil\nend\n\nfunc fliphoz8(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tw:=newbm.dimx\n\th:=newbm.dimy\n\tbuffer:=makeref(malloc(bm.linebytes),byte)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=p+w-1\n\t\tfor x:=0 to w%2 do\n\t\t\tt:=p^\n\t\t\tp^:=q^\n\t\t\tq^:=t\n\t\t\t++p; --q\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc fliphoz24(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tw:=newbm.dimx\n\th:=newbm.dimy\n\tbuffer:=makeref(malloc(bm.linebytes),byte)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tmemcpy(buffer,p,bm.linebytes)\n\t\tq:=buffer+(w-1)*3\n\n\t\tto w do\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q^\n\n\t\t\tq:=q-5\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc fliphoz32(bm)=\nreturn bmunimpl(\"fliphoz_32\")\nend\n\nexport func bmflipvert(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tw:=newbm.dimx\n\th:=newbm.dimy\n\tn:=bm.linebytes\n\tbuffer:=makeref(malloc(n),byte)\n\n\tfor y:=0 to h%2 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(newbm,h-1-y)\n!\n\t\tmemcpy(buffer,p,n)\n\t\tmemcpy(p,q,n)\n\t\tmemcpy(q,buffer,n)\n\tod\n\tfree(buffer)\n\n\treturn newbm\nend\n\nexport func bmrepeat(bm,cols,rows)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(bm.pixelbits, w*cols, h*rows)\n\tlinebytes:=bm.linebytes\n\n\tfor y:=0 to h-1 do\n\t\ts:=bmgetrowptr(bm,y)\n\t\tfor r:=0 to rows-1 do\n\t\t\tfor c:=0 to cols-1 do\n\t\t\t\tmemcpy(bmgetptr(newbm,c*w,r*h+y),s,linebytes)\n\t\t\tod\n\t\tod\n\tod\n\n\tif bm.pixelbits=8 then\n\t\tbmduplpalette(newbm,bm)\n\tfi\n\n\treturn newbm\nend\n\nexport func bmscale(bm, sx,?sy)=\n\tif sy.isvoid then sy:=sx fi\n\tcase bm.pixelbits\n\twhen 8 then return scalex8(bm,sx,sy)\n\twhen 24,32 then return scalex24(bm,sx,sy)\n\tesac\n\treturn nil\nend\n\nfunc scalex8(bm,sx,sy)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tneww:=int(round(w*sx))\n\tnewh:=int(round(h*sy))\n\n\tnewbm:=bmcreate(24, neww,newh)\n\treturn nil when not newbm\n\n\tbm24:=bmtorgb(bm,24)\n\n\tstretchblt(newbm.gdi.hdc,0,0,neww,newh,bm24.gdi.hdc,0,0,w,h, srccopy)\n\n\tif bm.paltype=greyscale_pal then\n\t\tnewbm8:=bmgetplane(newbm,\"R\")\n\telse\n\t\tnewbm8:=bmtopal(newbm)\n\tfi\n\tbmfree(newbm)\n\t\n\treturn newbm8\nend\n\nfunc scalex24(bm,sx,sy)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tneww:=int(round(w*sx))\n\tnewh:=int(round(h*sy))\n\n\tif neww<8 or newh<8 then return nil fi\n\n\tnewbm:=bmcreate(bm.pixelbits, neww,newh)\n\tif newbm then\n\t\tstretchblt(newbm.gdi.hdc,0,0,neww,newh,bm.gdi.hdc,0,0,w,h, srccopy)\n\tfi\n\n\treturn newbm\nend\n\nfunc bmscaleupi8(bm,sx,sy)=\nreturn bmunimpl(\"bmscaleupi8\")\nend\n\nfunc bmscaleupi24(bm,sx,sy)=\nreturn bmunimpl(\"bmscaleupi24\")\nend\n\nfunc bmscaleupi32(bm,sx,sy)=\nreturn bmunimpl(\"bmscaleupi32\")\nend\n\nfunc bmscaledowni8(bm,sx,sy)=\nreturn bmunimpl(\"bmscaledowni8\")\nend\n\nfunc bmscaledowni24(bm,sx,sy)=\nreturn bmunimpl(\"bmscaledowni24\")\nend\n\nfunc bmscaledowni32(bm,sx,sy)=\nreturn bmunimpl(\"bmscaledowni32\")\nend\n\nexport func bmneg(bm)=\n\tnewbm:=bmdupl(bm)\n\n\tdx:=newbm.dimx-1\n\tdy:=newbm.dimy-1\n\tn:=newbm.linebytes\n\tdo32:=0\n\tif n rem 4=0 then\n\t\tdo32:=1\n\t\tn:=n%4\n\tfi\n\n\tfor y:=0 to dy do\n\t\tif do32 then\n\t\t\tp:=makeref(bmgetrowptr(newbm,y),int32)\n\t\t\tto n do\n\t\t\t\tp++^ := p^ ixor 0xFFFFFFFF\n\t\t\tod\n\t\telse\n\t\t\tp:= bmgetrowptr(newbm,y)\n\t\t\tto n do\n\t\t\t\tp++^ := p^ ixor 255\n\t\t\tod\n\t\tfi\n\tod\n\treturn newbm\nend\n\nexport func bmmap(bm,map, channels=\"RGB\")=\n\tif channels=\"\" then channels:=\"RGB\" fi\n\n\tcase bm.pixelbits\n\twhen 8 then\n\t\treturn mapall(bm,map)\n\twhen 24 then\n\t\tif channels=\"RGB\" then\n\t\t\treturn mapall(bm,map)\n\t\tfi\n\t\treturn mapchan_24(bm,map,channels,0)\n\twhen 32 then\n\t\tif channels=\"RGBA\" then\n\t\t\treturn mapall(bm,map)\n\t\tfi\n\t\treturn mapchan_24(bm,map,channels,1)\n\tesac\n\n\treturn nil\nend\n\nfunc mapall(bm,map)=\n\tnewbm:=bmdupl(bm)\n\tp:=newbm.pixelptr\n\tto newbm.framebytes do\n\t\tp^:=map[p^]\n\t\t++p\n\tod\n\treturn newbm\nend\n\nfunc mapchan_24(bm,map,channels,alpha=0)=\n\tdored:=\"R\" in channels\n\tdogreen:=\"G\" in channels\n\tdoblue:=\"B\" in channels\n\tdoalpha:=\"A\" in channels\n\n\tnewbm:=bmdupl(bm)\n\n\tfor y:=0 to newbm.dimy-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto newbm.dimx do\n\t\t\tif doblue then p^:=map[p^] fi\n\t\t\t++p\n\t\t\tif dogreen then p^:=map[p^] fi\n\t\t\t++p\n\t\t\tif dored then p^:=map[p^] fi\n\t\t\t++p\n\t\t\tif alpha then\n\t\t\t\tif doalpha then p^:=map[p^] fi\n\t\t\t\t++p\n\t\t\tfi\n\t\tod\n\tod\n\n\treturn newbm\nend\n\n!function mapchan_32(bm,map,channels)=\n!return bmunimpl(\"mapchan_32\")\n!end\n\nexport func bmbright(bm,dx,channels=\"RGB\")=\n\treturn bmunimpl(\"bmbright\")\nend\n\nexport func bmcont(bm,x,channels=\"RGB\")=\n\treturn bmunimpl(\"bmcont\")\nend\n\nexport func bmgamma(bm,x,channels=\"RGB\")=\nreturn bmunimpl(\"bmgamma\")\nend\n\nexport func bmtogrey(bm,destbits=24)=\n\tif destbits=0 then destbits:=bm.pixelbits fi\n\tcase bm.pixelbits\n\twhen 8 then\n\t\tcase destbits\n\t\twhen 8 then\n\t\t\treturn pal8togrey8(bm)\n\t\twhen 24 then\n\t\t\tcm:=pal8togrey8(bm)\n\t\t\tnewbm:=grey8torgb24(cm)\n\t\t\tbmfree(cm)\n\t\t\treturn newbm\n\t\tesac\n\twhen 24,32 then\n\t\tcase destbits\n\t\twhen 8 then\n\t\t\treturn rgb24togrey8(bm)\n\t\twhen 24 then\n\t\t\tcm:=rgb24togrey8(bm)\n\t\t\tnewbm:=grey8torgb24(cm)\n\t\t\tbmfree(cm)\n\t\t\treturn newbm\n\t\tesac\n\tesac\nCPL =BM.PIXELBITS, =DESTBITS\n\treturn bmunimpl(\"bmtogrey bad combos\")\n\nend\n\nfunc pal8togrey8(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\t(rmap, gmap, bmap):=getlumtables()\n\n\tnewbm:=bmcreate(8,w,h)\n\tpal:=bmgetpalette(bm)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tcolour:=pal[q++^]\n\t\t\tr:=colour.[0..7]\n\t\t\tg:=colour.[8..15]\n\t\t\tb:=colour.[16..23]\n\t\t\tp++^:=rmap[r]+gmap[g]+bmap[b]\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc pal8togrey24(bm)=\nreturn bmunimpl(\"pal8togrey24\")\nend\n\nfunc rgb24togrey8(bm)=\n!does 24/32 bits\n\tqincr:=(bm.pixelbits=32)\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\t(rmap, gmap, bmap):=getlumtables()\n\n\tnewbm:=bmcreate(8,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tb:=q++^; g:=q++^; r:=q++^\n\t\t\tp++^:=rmap[r]+gmap[g]+bmap[b]\n\t\t\tq:=q+qincr\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc rgb24togrey24(bm)=\nreturn bmunimpl(\"rgb24togrey24\")\nend\n\nexport func bmtorgb(bm,destbits=24)=\n\tif destbits=0 then destbits:=24 fi\n\tcase bm.pixelbits\n\twhen destbits then\n\t\treturn bmdupl(bm)\n\n\twhen 8 then\n\t\tcase destbits\n\t\twhen 8 then\n\t\t\tbmunimpl(\"8 to 8 bits rgb\")\n\t\twhen 24 then\n\t\t\tif bm.paltype=greyscale_pal then\n\t\t\t\treturn grey8torgb24(bm)\n\t\t\telse\n\t\t\t\treturn paltorgb24(bm)\n\t\t\tfi\n\t\tesac\n\twhen 24 then\n\t\tif destbits=32 then\n\t\t\treturn bmrgb24torgb32(bm)\n\t\tfi\n\twhen 32 then\n\t\tif destbits=24 then\n\t\t\treturn bmrgb32torgb24(bm)\n\t\tfi\n\tesac\nCPL =BM.PIXELBITS, =DESTBITS\n\treturn bmunimpl(\"bmtorgb bad combos\")\nend\n\nfunc paltorgb24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,w,h)\n\tpal:=bmgetpalette(bm)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tcolour:=pal[q++^]\n\t\t\tr:=colour.[0..7]\n\t\t\tg:=colour.[8..15]\n\t\t\tb:=colour.[16..23]\n\n\t\t\tp++^:=b\n\t\t\tp++^:=g\n\t\t\tp++^:=r\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nfunc grey8torgb24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(24,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n\t\tto w do\n\t\t\tlum:=q++^\n\t\t\tp++^:=lum\n\t\t\tp++^:=lum\n\t\t\tp++^:=lum\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nexport func bmrgb24torgb32(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(32,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tq:=bmgetrowptr(bm,y)\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto w do\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=128\n\t\tod\n\tod\n\treturn newbm\nend\n\nexport func bmrgb32torgb24(bm)=\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(24,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tq:=bmgetrowptr(bm,y)\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto w do\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tp++^:=q++^\n\t\t\tq++\n\t\tod\n\tod\n\treturn newbm\nend\n\nexport func bmtopal(bm)=\n\tif bm.pixelbits=8 then return bmdupl(bm) fi\n\tqincr:=(bm.pixelbits=32)\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmcreate(8,w,h)\n\n\tpal:=new(array,int32,0..255)\n\n!create special palette mapping for rrrgggbb\n\tfor r:=0 to 7 do\n\t\tfor g:=0 to 7 do\n\t\t\tfor b:=0 to 3 do\n\t\t\t\tindex:=r<<5+g<<2+b\n!\t\t\t\tpal[index]:=r<<5+g<<13+b<<18\n\t\t\t\tpal[index]:=r<<5+g<<13+b<<22\n\t\t\tod\n\t\tod\n\tod\n\tbmputpalette(newbm,pal)\n\tbm.paltype:=colour_pal\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tq:=bmgetrowptr(bm,y)\n\n!noise:=-16..16\n!noise:=-8..8\n\n\t\tto w do\n\t\t\tb:=q++^; g:=q++^; r:=q++^\n\n!\t\t\tr+:=clamp(random(noise),0,255)\n!\t\t\tg+:=clamp(random(noise),0,255)\n!\t\t\tb+:=clamp(random(noise),0,255)\n!\n\t\t\tp++^:=r>>5<<5 + g>>5<<2 + b>>6\n\t\t\tq:=q+qincr\n\t\tod\n\tod\n\n\treturn newbm\n\nend\n\nexport func bmsplittorgb(bm,greydest=1)=\n# split 24-bit bitmap into three separate 8-bit planes\n# return 3 new bitmaps in the order red, green, blue\n# return () on error\n# dogreyscale=1 for each image to have a greyscale palette. Otherwise\n# the red image will be shades of red, etc\n\n\tif bm.pixelbits<24 then\n\t\treturn ()\n\tfi\n\tchannels:=bm.pixelbytes\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tpal:=new(array,int32,0..255)\n\timages::=()\n\n\tfor offset:=channels-1 downto 0 do\n\n\t\tnewbm:=bmcreate(8,w,h)\n\n\t\tfor y:=0 to h-1 do\n\t\t\tq:=bmgetrowptr(bm,y)+offset\n\t\t\tp:=bmgetrowptr(newbm,y)\n\t\t\tto w do\n\t\t\t\tp++^:=q^\n\t\t\t\tq:=q+channels\n\t\t\tod\n\t\tod\n\n\t\tif not greydest then\n\t\t\tcolour:=0\n\t\t\tincr:=(3-offset|0x00'00'01,0x00'01'00,0x01'00'00|0x01'01'01)\n\t\t\tfor i:=0 to 255 do\n\t\t\t\tpal[i]:=colour\n\t\t\t\tcolour+:=incr\n\t\t\tod\n\t\t\tbmputpalette(newbm,pal)\n\t\t\tnewbm.paltype:=tinted_pal\n\t\tfi\n\n\t\timages append:=newbm\n\tod\n\n!image order is r,g,b, or a,r,g,b\n\tif images.len=4 then\n\t\treturn (images[2],images[3],images[4],images[1])\n\telse\n\t\treturn images\n\tfi\nend\n\nexport func bmsplittoyuv(bm)=\n# split 24-bit bitmap into three separate 8-bit planes\n# return 3 new bitmaps in the order y, u, v\n# return () on error\n\n\tneedfree:=0\n\tcase bm.pixelbits\n\twhen 24 then\n\twhen 32 then\n\t\tbm:=bmtorgb(bm,24)\n\t\tneedfree:=1\n\telse\n\t\treturn nil\n\tesac\n\n!get y plane first with existing routine\n\tgreybm:=bmtogrey(bm,8)\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n!equations used are:\n! u:=int(round(0.492*(b-y)+128)\n! v:=int(round(0.702*(r-y)+128)\n!b-y and r-y will be in range +/- 255\n\n\tumap:=new(list,-255..255)\n\tvmap:=new(list,-255..255)\n\tfor i:=-255 to 255 do\n\t\tumap[i]:=int(round(0.492*(i)+128))\n\t\tvmap[i]:=int(round(0.702*(i)+128))\n\tod\n\n\tubm:=bmcreate(8,w,h)\n\tvbm:=bmcreate(8,w,h)\n\tfor c:=1 to 2 do\n\t\tif c=1 then\n\t\t\toffset:=0\n\t\t\tmap:=umap\n\t\telse\n\t\t\toffset:=2\n\t\t\tmap:=vmap\n\t\tfi\n\n\t\tfor yy:=0 to h-1 do\n\t\t\tpy:=bmgetrowptr(greybm,yy)\n\t\t\tp:=bmgetrowptr(bm,yy)\t\t\t!point to bgr pixels in original\n\n\t\t\tpu:=bmgetrowptr(ubm,yy)\n\t\t\tpv:=bmgetrowptr(vbm,yy)\n\t\t\tto w do\n\t\t\t\ty:=py++^\n\t\t\t\tr:=(p+2)^\n\t\t\t\tb:=p^\n\t\t\t\tpu++^:=umap[b-y]\n!CPL =B,=Y,=PV,=VMAP.TYPE\n\t\t\t\tpv++^:=vmap[r-y]\n\n\t\t\t\tp:=p+3\n\t\t\tod\n\t\tod\n\tod\n\n!create special greyscale for u/v images, since point of zero colour\n!info has been offset to +128\n\tpal:=new(array,int32,0..256)\n\tcolour:=0\n\tpal[128]:=0\n\tfor i:=1 to 127 do\n\t\tcolour+:=0x020202\n\t\tpal [i+128]:=colour\n\t\tpal [128-i]:=colour\n\tod\n\tpal[256]:=uv_pal\n\tbmputpalette(ubm,pal)\n\tbmputpalette(vbm,pal)\n\n\tif needfree then\n\t\tbmfree(bm)\n\tfi\n\n\treturn (greybm,ubm,vbm)\nend\n\nexport func bmgetplane(bm,plane)=\n# plane is one of \"R\",\"G\",\"B\"\n# extract given plane of a 24-bit bitmaps into a single 8-bit greyscale image\n# Return new image\n\n\tincr:=bm.pixelbytes\n\tif plane.len<>1 or bm.pixelbytes<3 then\n\t\treturn nil\n\tfi\n\n\tcase asc(plane)\n\twhen 'R' then offset:=2\n\twhen 'G' then offset:=1\n\twhen 'B' then offset:=0\n\twhen 'A' then offset:=3\n\telse return nil\n\tesac\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\tnewbm:=bmcreate(8,w,h)\n\n\tfor y:=0 to h-1 do\n\t\tq:=bmgetrowptr(bm,y)+offset\n\t\tp:=bmgetrowptr(newbm,y)\n\t\tto w do\n\t\t\tp++^:=q^\n\t\t\tq:=q+incr\n\t\tod\n\tod\n\n\treturn newbm\nend\n\nexport func bmjoinrgb(redbm,greenbm,bluebm,alphabm=nil)=\n\n\tw:=redbm.dimx\n\th:=redbm.dimy\n\n\tnewbm:=bmcreate((alphabm|32|24),w,h)\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,y)\n\n\t\tr:=bmgetrowptr(redbm,y)\n\t\tg:=bmgetrowptr(greenbm,y)\n\t\tb:=bmgetrowptr(bluebm,y)\n\n\t\tif alphabm then\n\t\t\ta:=bmgetrowptr(alphabm,y)\n\t\t\tto w do\n\t\t\t\tp++^:=b++^\n\t\t\t\tp++^:=g++^\n\t\t\t\tp++^:=r++^\n\t\t\t\tp++^:=a++^\n\t\t\tod\n\t\telse\n\t\t\tto w do\n\t\t\t\tp++^:=b++^\n\t\t\t\tp++^:=g++^\n\t\t\t\tp++^:=r++^\n\t\t\tod\n\t\tfi\n\tod\n\n\treturn newbm\nend\n\nexport func bmjoinyuv(ybm,ubm,vbm)=\n# combine y, u, v separations into a single rgb image\n# return new bitmap, or nil\n\n\tif ybm.pixelbits<>8 then\n\t\treturn nil\n\tfi\n\n\tw:=ybm.dimx\n\th:=ybm.dimy\n\n\tv1425map:=new(list,0..255)\n\tv726map:=new(list,0..255)\n\tu395map:=new(list,0..255)\n\tu2032map:=new(list,0..255)\n\n\tfor i:=0 to 255 do\n\t\tv1425map[i]:=int(round(1.425*(i-128)))\n\t\tv726map[i]:=int(round(0.726*(i-128)))\n\t\tu395map[i]:=int(round(0.395*(i-128)))\n\t\tu2032map[i]:=int(round(2.032*(i-128)))\n\tod\n\n\tnewbm:=bmcreate(24,w,h)\n\n\tfor yy:=0 to h-1 do\n\t\tp:=bmgetrowptr(newbm,yy)\n\t\tqy:=bmgetrowptr(ybm,yy)\n\t\tqu:=bmgetrowptr(ubm,yy)\n\t\tqv:=bmgetrowptr(vbm,yy)\n\n!\t\tto w do\n\t\tFOR X:=0 TO W-1 DO\n\t\t\ty:=qy++^\n\t\t\tr:=y+v1425map[qv^]\n\t\t\tg:=y-u395map[qu^]-v726map[qv^]\n\t\t\tb:=y+u2032map[qu^]\n\t\t\t++qu\n\t\t\t++qv\n\t\t\tp++^:=clamp(b,0,255)\n\t\t\tp++^:=clamp(g,0,255)\n\t\t\tp++^:=clamp(r,0,255)\n\t\tod\n\tod\n\treturn newbm\nend\n\nexport func bmblur(bm,n)=\n\tcase bm.pixelbits\n\twhen 8 then\n\t\treturn blur8(bm,n)\n\twhen 24 then\n\t\treturn blur24(bm,n)\n\twhen 32 then\n\t\treturn blur32(bm,n)\n\tesac\n\treturn nil\nend\n\nfunc blur8(bm,n)=\n\tshift:=shifts{n,1}\n\n\tnewbm:=bmdupl(bm)\n\tiblurhoz8(newbm,n)\n\n\tnewbm2:=rotleft90_8(newbm)\n\tiblurhoz8(newbm2,n)\n\n\tnewbm3:=rotright90_8(newbm2)\n\tbmfree(newbm)\n\tbmfree(newbm2)\n\n\tbmduplpalette(newbm3,bm)\n\treturn newbm3\nend\n\nfunc blur24(bm,n)=\n\t(r,g,b):=bmsplittorgb(bm)\n\n\tr2:=bmblur(r,n)\n\tg2:=bmblur(g,n)\n\tb2:=bmblur(b,n)\n\n\tnewbm:=bmjoinrgb(r2,g2,b2)\n\tbmfree(r2)\n\tbmfree(g2)\n\tbmfree(b2)\n\n\treturn newbm\nend\n\nfunc blur32(bm,n)=\nreturn bmunimpl(\"blur32\")\nend\n\nproc iblurhoz8(bm,n)=\n\tshift:=shifts{n,1}\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tfor y:=0 to h-1 do\n\t\tp:=bmgetrowptr(bm,y)\n\t\tto w-n-1 do\n\t\t\tsum:=0\n\t\t\tq:=p\n\t\t\tto n do\n\t\t\t\tsum+:=q++^\n\t\t\tod\n\t\t\tp++^:=sum>>shift\n\t\tod\n\tod\nend\n\nfunc blurhoz24(bm,n)=\nreturn bmunimpl(\"blurhoz24\")\nend\n\nfunc blurhoz32(bm,n)=\nreturn bmunimpl(\"blurhoz32\")\nend\n\nexport func bmsharpen(bm,n=0)=\n\tcase bm.pixelbits\n\twhen 8 then\n\t\treturn sharpen8(bm,n)\n\twhen 24 then\n\t\treturn sharpen24(bm,n)\n\twhen 32 then\n\t\treturn sharpen32(bm,n)\n\tesac\n\treturn nil\nend\n\nexport func sharpen8(bm,n)=\n!blur in-place horizontally by averaging each set of n pixels\n!n must be multiple of 2 from 2 to 64\n!return new modified image\n\n\tw:=bm.dimx\n\th:=bm.dimy\n\n\tnewbm:=bmdupl(bm)\n\n\tfor y:=1 to h-2 do\n\t\tp:=bmgetptr(newbm,1,y)\n\n\t\tq:=bmgetptr(bm,1,y-1)\n\t\tr:=bmgetptr(bm,1,y)\n\t\ts:=bmgetptr(bm,1,y+1)\n\n\t\tto w-2 do\n!\t\t\tabcdefghij\n\t\t\ta:=(q-1)^\n\t\t\tb:=q^\n\t\t\tc:=(q+1)^\n\t\t\td:=(r-1)^\n\t\t\te:=r^\n\t\t\tf:=(r+1)^\n\t\t\tg:=(s-1)^\n\t\t\th:=s^\n\t\t\ti:=(s+1)^\n\n! a b c\n! d e f\n! g h i\n!\t\t\tsum:=e*4-b-d-f-h\n!\t\t\tp^:=clamp(p^+sum%4,0,255)\n\n\t\t\tsum:=e*8-a-b-c-d-f-g-h-i\n\t\t\tp^:=clamp(p^+sum%8,0,255)\n\n!\t\t\tsum:=e*4+c+g+i-2*(b+d+f+h)\n!\t\t\tp^:=clamp(p^+sum%4,0,255)\n\n\t\t\t++p\n\t\t\t++q\n\t\t\t++r\n\t\t\t++s\n\t\tod\n\tod\n\n\treturn newbm\n\nend\n\nexport func sharpen24(bm,n)=\n\t(r,g,b):=bmsplittorgb(bm)\n\n\tr2:=bmsharpen(r,n)\n\tg2:=bmsharpen(g,n)\n\tb2:=bmsharpen(b,n)\n\n\tnewbm:=bmjoinrgb(r2,g2,b2)\n\tbmfree(r2)\n\tbmfree(g2)\n\tbmfree(b2)\n\n\treturn newbm\nend\n\nexport func sharpen32(bm,n)=\nreturn bmunimpl(\"bmsharpen32\")\nend\n\nfunc getlumtables=\n\trmap:=makescalemap(0.299)\n\tgmap:=makescalemap(0.587)\n\tbmap:=makescalemap(0.111)\n\treturn (rmap, gmap, bmap)\nend\n",
    
(byte*)"import sys\nimport clib\n\nimport winconsts\nimport winapi\n\n!!Virtual keycodes\nexport const vklbutton=1\t\t!note these are physical not logical buttons\nexport const vkrbutton=2\nexport const vkmbutton=4\t\t!middle button is correct\nexport const vkbackspace=8\nexport const vktab=9\nexport const vkclear=12\nexport const vkenter=13\nexport const vkshift=16\nexport const vkctrl=17\nexport const vkalt=18\nexport const vkbreak=19\nexport const vkcapslock=20\n!export const vkrshift=21\nexport const vkrctrl=22\n!export const vkralt=23\nexport const vkinslock=24\nexport const vkescape=27\nexport const vkspace=32\nexport const vkpageup=33\nexport const vkpagedown=34\nexport const vkend=35\nexport const vkhome=36\nexport const vkleft=37\nexport const vkup=38\nexport const vkright=39\nexport const vkdown=40\nexport const vkinsert=45\nexport const vkdelete=46\nexport const vkhelp=47\nexport const vk0='0'\nexport const vka='A'\nexport const vkwindows=91\nexport const vkrightbutton=93\nexport const vknumpad0=96\t\t!96..105 = '0'..'9'\nexport const vkmul=106\nexport const vkadd=107\nexport const vksub=109\nexport const vkdecimal=110\nexport const vkdiv=111\nexport const vkf1=112\nexport const vkf2=113\nexport const vkf3=114\nexport const vkf4=115\nexport const vkf5=116\nexport const vkf6=117\nexport const vkf7=118\nexport const vkf8=119\nexport const vkf9=120\nexport const vkf10=121\nexport const vkf11=122\nexport const vkf12=123\n!export const vklsq=128\n!export const vkrsq=129\n!export const vksemi=130\n!export const vkquote=131\n!export const vkstroke=132\n!export const vkdot=133\n!export const vkcomma=134\n!export const vkbackslash=135\n!export const vkquote2=136\n!export const vkequals=137\n!export const vkminus=138\n!export const vkhash=139\nexport const vklshift=160\nexport const vkrshift=161\nexport const vklcontrol=162\nexport const vkrcontrol=163\nexport const vklalt=164\nexport const vkralt=165\n\n!oem codes\nexport const vkminus=189\nexport const vkequals=187\nexport const vklsq=219\nexport const vkrsq=221\nexport const vksemi=186\nexport const vkquote=192\nexport const vkhash=222\nexport const vkcomma=188\nexport const vkperiod=190\nexport const vkslash=191\nexport const vkbackslash=220\nexport const vkbackquote=223\n\nexport const con_black=0\nexport const con_dkblue=1\nexport const con_dkred=2\nexport const con_dkmagenta=3\nexport const con_dkgreen=4\nexport const con_dkcyan=5\nexport const con_dkyellow=6\nexport const con_dkgrey=7\nexport const con_grey=8\nexport const con_blue=9\nexport const con_red=10\nexport const con_magenta=11\nexport const con_green=12\nexport const con_cyan=13\nexport const con_yellow=14\nexport const con_white=15\n\n\nexport record winrec =\n\tvar posx,posy\n\tvar cols,rows\n\tvar fgnd,bgnd\t\t\t!default text/background colour\n\n\tvar columns\t\t\t!used when divided into columns\n\tvar itemcols\t\t\t!width of each column\n\tvar pagesize\t\t\t!columns*rows\n\n\tvar name\n\n\tvar hdata\t\t\t!pointer to data record, or is nil\nend\n\nexport var wconscreen\nexport var screencols,screenrows\n\nexport var chardata\t\t\t!string these two represent row of the console\nexport var attrdata\t\t\t!string\n\nexport var defscreenfgnd=con_black\nexport var defscreenbgnd=con_grey\nexport var rlkey=0\t\t!set by readline, when special key has been input\nexport var rlbuffer\t\t\t!contents of readline buffer when special key pressed\n\nvar cmdindex,ncmds\nvar cmdhistory\n\nexport const capsmask  = 0x8\t\t!shift states as they are in .keyshift\nexport const altmask   = 0x4\nexport const ctrlmask  = 0x2\nexport const shiftmask = 0x1\n\nexport const capsbit=3\nexport const altbit=2\nexport const ctrlbit=1\nexport const shiftbit=0\n\nvar keypending=0\nvar lastkey\nvar pendkey\nexport var hconsole, hconsolein\nvar colourpalette\n\n!export var wscreencols,wscreenrows\nexport var currbgnd=-1,currfgnd=-1\n\n!export var screencolour=con_dkred..con_grey\n\n!export var colourmap\nexport VAR SUPPRESS=0\n\nVAR ALLCHARS\n\nproc START=\n!if iswindows() then\n!\tCPL \"WINCON INIT\"\n\t\tinit()\n!fi\n\tend\n\nproc main=\n\tinit()\n\tsettitle(\"New Title\")\n\n!keyscreentest()\n\n!W:=MAKEWIN((1,20),(20,20))\n!CLEARWIN(W)\n\n!SHOWTEXT(\"^^^^^^^^^^^^^^^^^\")\n\na:=rkey(10,20,30)\n!\tsetpos(12, 10)\n!\tprint \"***********hello\"\n!\twaitkey()\nend\n\nproc keyscreentest=\n\t(cols,rows):=(screencols, screenrows)\n\tCPL =COLS,=ROWS\n\n\trow:=rows%2\n\tcol:=cols%2\n\tch:=\"X\"\n\n\tsetcolour(6,1)\n\n\tdo\n\t\tsetpos(col,row)\n\t\tcp ch\n\t\tsetpos(col,row)\n\t\tk:=getkey().keycode\n\t\tcase k\n\t\twhen 27 then\n\t\t\texit\n\t\twhen vkleft then col:=max(1,col-1)\n\t\twhen vkright then col:=min(cols,col+1)\n\t\twhen vkup then row:=max(1,row-1)\n\t\twhen vkdown then row:=min(rows,row+1)\n\t\tesac\n\tod\n\n!waitkey()\n\nend\n\nexport func makerspoint(x,y)=\n!combine x,y into 32-bit value (rspoint)\n\treturn y<<16 ior x\nend\n\nexport proc setpos(col,row)=\n\tsetconsolecursorposition(hconsole,makerspoint(col-1,row-1))\nend\n\nexport func getpos=\n\tinfo:=new(ws_console)\n\tgetconsolescreenbufferinfo(hconsole,&info)\n\treturn (info.pos.x+1,info.pos.y+1)\nend\n\nexport proc init(cols=100)=\n!static var setdimdone=0\n\n!\tconsolesw.init(cols)\n\tcmdhistory::=()\t!\"one\",\"two\",\"three\",\"four\")\n\tncmds:=cmdhistory.upb\n\tcmdindex:=0\n\n!screencols:=consolesw.wscreencols\n!screenrows:=consolesw.wscreenrows\n!\n\n\thconsole:=getstdhandle(-11)\n\thconsolein:=getstdhandle(-10)\n\tlastkey:=new(ws_keyevent)\n\tlastkey.repeatcount:=0\n\tpendkey:=new(ws_keyevent)\n\n\tsetdims(cols,60)\n\n\tgetdims()\n\n!CPL =SCREENCOLS\n\n\twconscreen:=makewin((1,1),(screencols,screenrows),defscreencolour)\n\n\tcolourpalette:=new(ws_palette16)\n\n\tsetstdpalette()\nend\n\nexport func setcursor(?visible)=\n\tcursor:=new(ws_cursor)\n\tgetconsolecursorinfo(hconsole,&cursor)\n\n\tif visible.defined then\n\t\tcursor.visible:=visible\n\t\tsetconsolecursorinfo(hconsole,&cursor)\n\tfi\n\treturn cursor.visible\nend\n\nexport proc setcolour(fgnd,bgnd)=\n!call with as (fgnd,bgnd) or as (fgnd..bgnd)\n\n\tif fgnd=currfgnd and bgnd=currbgnd then\n\t\treturn\n\tfi\n\n\tcurrfgnd:=fgnd\n\tcurrbgnd:=bgnd\n\n!setconsoletextattribute(hconsole,(colourmap[bgnd]*16 + colourmap[fgnd]))\n\tsetconsoletextattribute(hconsole,(bgnd*16+fgnd))\nend\n\nexport proc settitle(caption)=\n\tsetconsoletitle(caption)\nend\n\nexport func getkeychar=\n!wait for any key, return single char code; as returned by C's getch()\n\treturn waitkey()\nend\n\nexport func getkey2=\n!wait for any key, return keyrec\n!includes shift key presses as discrete keys\n!use getkey() to ignore these\n\n\treturn getchx()\n\n\tk:=getchx()\t\t\t!get keyrec, encoded as int\n\n\tkey:=new(rkey)\t\t\t!convert to proper keyrec\n\tkey.charcode:=k iand 65535\n\tkey.shift:=k>>24\n\tkey.keycode:=k.[23..16]\n!CPL \"GK2:\",KEY\n\n\treturn key\nend\n\nexport func getkey=\n!calls igetkey but doesn't return shift keys as discrete key presses\n\tdo\n\t\tk:=getkey2()\n\t\tcase k.keycode\n\t\twhen vkshift,vkctrl,vkalt,vkcapslock then\n\t\telse\n\t\t\texit\n\t\tesac\n\tod\n\treturn k\nend\n\nexport func keyready=\n\treturn testkey()\nend\n\nexport proc wshowtext(w,s,?col,?row)=\n\tif col.defined then\n\t\tshowtext(s,w.posx+col-1,w.posy+row-1)\n\telse\n\t\tshowtext(s)\n\tfi\nend\n\nexport proc showtext(s,?x,?y)=\n\n\tif x.defined then\n\t\tsetpos(x,y)\n\tfi\n\n\tcount:=0\n\tif s then\n\t\tif not suppress then\n\t\t\twriteconsole(hconsole,s,s.len,&count,nil)\n\t\tfi\n\tfi\nend\n\nproc setwindowsize(cols,rows)=\n\tr:=new(ws_srect)\n\tr.leftx:=0\n\tr.rightx:=cols-1\n\tr.top:=0\n\tr.bottom:=rows-1\n\tif not setconsolewindowinfo(hconsole,1,&r) then\n!\tCPL \"WINDOW ERROR 1\"\n!\tabort(\"Window error 1\")\n\tfi\nend\n\nexport proc setdims(cols,rows)=\n!set new size for console, by reinitialising\n\n\tmaxcol:=cols\n\tmaxrow:=rows\n\n\tinfo:=new(ws_console)\n\toldscreenattributes:=info.attributes\n\toldscreensize:=info.size\n\n\toldcols:=info.window.rightx-info.window.leftx+1\n\toldrows:=info.window.bottom-info.window.top+1\n\n\tIF OLDSCREENSIZE.X>COLS OR OLDSCREENSIZE.Y>ROWS THEN\t!need to reduce window size first\n\t\tsetwindowsize(oldscreensize.x min cols, oldscreensize.y min rows)\n\tfi\n\n!Set the new size of the entire (virtual) console window\n\tif setconsolescreenbuffersize(hconsole,rows<<16+cols)=0 then\n!\tabort(\"Buffer size error\")\n\tfi\n\n!now set the size of the displayed portion of it; in this case exactly the same\n!size as the buffer, with no scrollbars\n\tsetwindowsize(cols,rows)\n\n\twscreencols:=cols\n\twscreenrows:=rows\n\n!hide blinking cursor\n\tcursor:=new(ws_cursor)\n\tcursor.size:=10\n\tcursor.visible:=1\nend\n\nexport proc setpalette(index,colour)=\n!index is 0..15; colour is an rgb value bbggrr\n!updates local palette array\n!to update actual console, use writepalette\n\tcolourpalette[index]:=colour\nend\n\nexport proc writepalette=\n\tr:=new(ws_consoleex)\n\tr.recsize:=ws_consoleex.bytes\n\tX:=getconsolescreenbufferinfoex(hconsole,&r)\n\n\tr.palette:=colourpalette\n\n\tR.WINDOW.RIGHTX:=R.WINDOW.RIGHTX+1\t\t!workaround off-by-one bug\n\tR.WINDOW.BOTTOM:=R.WINDOW.BOTTOM+1\n\n\tX:=setconsolescreenbufferinfoex(hconsole,&r)\n\n!export proc READPALETTE=\n!r:=new(rconsoleex)\n!r.recsize:=rconsoleex.bytes\n!x:=getconsolescreenbufferinfoex(hconsole,&r)\n!\n!CPL \"GCSBI X=\",X\n!FOR I:=0 TO 15 DO\n! CPL I,\":\",R.PALETTE[I]:\"H\"\n!OD\n!\nend\n\nproc setstdpalette=\n!export const con_black=0\n!export const con_dkblue=1\n!export const con_dkred=2\n!export const con_dkmagenta=3\n!export const con_dkgreen=4\n!export const con_dkcyan=5\n!export const con_dkyellow=6\n!export const con_grey=7\n!export const con_dkgrey=8\n!export const con_blue=9\n!export const con_red=10\n!export const con_magenta=11\n!export const con_green=12\n!export const con_cyan=13\n!export const con_yellow=14\n!export const con_white=15\n\n!R G B\n\tcols:=(\n\t(0,\t\t0,\t\t0),\t\t\t!black\n\t(0,\t\t0,\t\t128),\t\t!dk blue\n\t(128,\t0,\t\t0),\t\t\t!dk red\n\t(128,\t0,\t\t128),\t\t!dk magenta\n\t(0,\t\t128,\t0),\t\t\t!dk green\n\t(0,\t\t128,\t128),\t\t!dk cyan\n\t(128,\t128,\t0),\t\t\t!dk yellow\n\t(128,\t128,\t128),\t\t!dk grey\n\t(192,\t192,\t192),\t\t!grey\n\t(0,\t\t0,\t\t192),\t\t!blue\n\t(192,\t0,\t\t0),\t\t\t!red\n\t(192,\t0,\t\t192),\t\t!magenta\n\t(0,\t\t192,\t0),\t\t\t!green\n\t(0,\t\t192,\t192),\t\t!cyan\n\t(192,\t192,\t0),\t\t\t!yellow\n\t(255,\t255,\t255))\t\t!white\n\n\tforall i,c in cols do\n\t\tsetpalette(i-1,c[3]<<16+c[2]<<8+c[1])\n\tod\n!CPL \"WRITEPAL\"; WAITKEY()\n\twritepalette()\nend\n\nproc getdims=\n\tinfo:=new(ws_console)\n\tgetconsolescreenbufferinfo(hconsole,&info)\n\n\tscreencols:=info.window.rightx-info.window.leftx+1\n\tscreenrows:=info.window.bottom-info.window.top+1\nend\n\nexport func getchx=\n\tconst rightaltmask\t= 1\t\t\t\t!masks used by .controlkeystate\n\tconst leftaltmask\t= 2\n\tconst leftctrlmask\t= 8\n\tconst rightctrlmask\t= 4\n\tconst shiftmask\t\t= 16\n\tconst capsmask\t\t= 128\n\tconst scrollmask\t= 64\n\n\tconst leftctrlbit\t= 3\t\t!for c.l.p\n\tconst rightctrlbit\t= 2\n\n\tif keypending then\n\t\tlastkey:=pendkey\n\t\tkeypending:=0\n\telse\n\t\tif lastkey.repeatcount=0 then\n\t\t\trepeat\n\t\t\t\tcount:=0\n\t\t\t\treadconsoleinput(hconsolein,&lastkey,1,&count)\n\t\t\tuntil lastkey.eventtype=1 and lastkey.keydown=1\n\t\tfi\n\tfi\n\n\taltdown\t\t:= (lastkey.controlkeystate iand (leftaltmask ior rightaltmask)|1|0)\n\tctrldown\t:= (lastkey.controlkeystate iand (leftctrlmask ior rightctrlmask)|1|0)\n\tshiftdown\t:= (lastkey.controlkeystate iand shiftmask|1|0)\n\tcapslock\t:= (lastkey.controlkeystate iand capsmask|1|0)\n\n\tlastkey.repeatcount:=lastkey.repeatcount-1\n\n\tcharcode:=lastkey.asciichar\n\tkeycode:=lastkey.virtualkeycode iand 255\n\n!for keycodes in range 186 to 223, which are all stand-alone punctuation keys, I might\n!wish to set charcode to the appropriate printed char code (currently charcode will be\n!zero, and keyboard handlers need to detect keycodes such as vkequals)\n!\n\tif altdown and ctrldown and charcode=166 then\n\t\taltdown:=ctrldown:=0;\n\telse\n\t\tif altdown or ctrldown then\n\t\t\tcharcode:=0;\n\t\t\tif keycode>='A' and keycode<= 'Z' then\n\t\t\t\tcharcode:=keycode-'@'\n\t\t\tfi\n\t\tfi\n\tfi\n\n\tkeyshift:=capslock<<3 ior altdown<<2 ior ctrldown<<1 ior shiftdown\n\n\tkeyshift.[4]:=lastkey.controlkeystate.[leftctrlbit]\t\t!for c.l.p\n\tkeyshift.[5]:=lastkey.controlkeystate.[rightctrlbit]\n\n!need to be more ruthless with how keycoded and charcodes are combined.\n!More combinations need to have only charcode or keycode set, and the other zero\n\n\tswitch charcode\n\twhen 'A'..'Z','a'..'z','0'..'9' then\n\twhen 8,9,13,27,' ','`' then\n\twhen 0 then\t\t\t\t!already key-only event\n\telse\n\t\tkeycode:=0\n\tend switch\n\n\treturn rkey(charcode,keycode,keyshift)\n\nend\n\nexport proc flushkeyboard=\n\tflushconsoleinputbuffer(hconsolein)\nend\n\nexport proc w_writeconsolerow(text, attributes, length, row)=\n\tbuffersize:=1<<16+length\n\tcoord:=0\n\n\tbox:=ws_srect(0,row-1,length-1,row-1)\n\n\tbuffer:=new(array,ws_charinfo,length)\n\n\tfor i:=1 to length do\n\t\tx:=new(ws_charinfo)\n\t\tx.asciichar  := text.[i]\n\t\tx.attributes := attributes.[i]\n!\tx.attributes := attributes.[1]\n\t\tbuffer[i]:=x\n\tod\n!CPL \"HELLO\",text; WAITKEY()\n\n\twriteconsoleoutputa(hconsole, &buffer,buffersize,coord,&box)\nend\n\nexport func setclipboard(s)=\n!copy text to the Windows clipboard\n!return status 0 if no clipboard o/p was possible\n\tconst ghnd=2 + 0x40\n\n\tif openclipboard(nil)=0 then\n\t\treturn 0\n\tfi\n\n\temptyclipboard()\n\n\tif s<>\"\" then\n\t\th:=globalalloc(ghnd,s.len+1)\n\t\tp:=globallock(h)\n\n\t\tmemcpy(p,&s,s.len+1)\n\tglobalunlock(h)\n\t\tsetclipboarddata(cf_text,h)\n\tfi\n\n\tcloseclipboard()\n\n\treturn 1\nend\n\nexport func getclipboard=\n!copy text from Windows clipboard\n!return clipboard text, or \"\" when error or not text data available\n\n\tif openclipboard(nil)=0 then\n\t\treturn \"\"\n\tfi\n\n\thtext:=getclipboarddata(cf_text)\n\n\tif not htext then\n\t\treturn \"\"\n\tfi\n\n\tsize:=globalsize(htext)\t\t!should include zero terminator\n\n\tp:=globallock(htext)\n\ts:=makestr(p,size-1)\t\t!assignment should copy the string data\n\n\tglobalunlock(htext)\n\n\tcloseclipboard()\n\treturn s\nend\n\nexport func makewin(pos, dims, ?fgnd,?bgnd,name=\"Anon\")=\n!export func makewin(pos, dims, ?colour)=\n\n\tw:=new(winrec)\n\tw.posx:=pos[1]\n\tw.posy:=pos[2]\n\tw.cols:=dims[1]\n\tw.rows:=dims[2]\n\tw.columns:=1\n\tif dims.len>=3 then\n\t\tw.columns:=dims[3]\n\tfi\n\n!CPL =POS,=DIMS,=W.COLUMNS\n\n\tw.itemcols:=w.cols%w.columns\n\tw.pagesize:=w.rows*w.columns\n\tw.hdata:=nil\n\n\tw.fgnd:=fgnd\n\tw.bgnd:=bgnd\n\tw.name:=name\n\n\treturn w\nend\n\nexport proc clearwin(w)=\n!clear region used by listbox\n!can clear multi-columns at once\n\tspaces:=\" \"*w.cols\n\n\tsetcolour(w.fgnd,w.bgnd)\n\tfor i:=1 to w.rows do\n\t\tshowtext(spaces,w.posx,w.posy+i-1)\n\tod\n\tsetpos(w.posx,w.posy)\nend\n\nexport proc wsetpos(w,col,row)=\n\tsetpos(w.posx+col-1,w.posy+row-1)\nend\n\nexport proc wshowtext_b(w,s,col,fgnd,bgnd)=\n!version of wshowtext that dumps into char/attr buffer.\n!w is used for absolute column number\n\n\tlength:=s.len\n\toffset:=w.posx-1\t!hoz offset\n\n\tchardata.[(col+offset)..(col-1+length+offset)]:=s\n\n!\tattr:=consolesw.colourmap[bgnd]<<4+consolesw.colourmap[fgnd]\n\tattr:=bgnd<<4+fgnd\n\n\tattrdata.[(col+offset)..(col-1+length+offset)]:=chr(attr)*length\nend\n\nexport proc updateconsolerow(row)=\n!write out latest contents to chardata/attrdata to console\n!this represents an entire composite wlineno+wvgap+wedit row, for given row within wedit\n!etc\n\tw_writeconsolerow(chardata,attrdata,screencols,row)\nend\n\nexport func getkeyname(key)=\n\tcase key.keycode\n\twhen vkleft then name:=\"left\"\n\twhen vkright then name:=\"right\"\n\twhen vkup then name:=\"up\"\n\twhen vkdown then name:=\"down\"\n\twhen vkpageup then name:=\"pageup\"\n\twhen vkpagedown then name:=\"pagedown\"\n\twhen vkhome then name:=\"home\"\n\twhen vkend then name:=\"end\"\n\twhen vkinsert then name:=\"insert\"\n\twhen vkdelete then name:=\"delete\"\n\twhen vktab then name:=\"tab\"\n\twhen vkescape then name:=\"escape\"\n\twhen vkbackspace then name:=\"backspace\"\n\twhen vkenter then name:=\"enter\"\n\twhen vkf1..vkf12 then name:=\"f\"+tostr(key.keycode-vkf1+1)\n\twhen vkspace then name:=\"space\"\n\telse\n\t\tif key.charcode in [1..26] then\t!ctrl code\n\t\t\tname:=chr(key.charcode+'a'-1)\n\t\telsif key.charcode in ['!','\"','','$','%','^','&','*','(',')','-','_','+','=','[',']',\n\t\t'{','}',':',';','\\'','@','~','#','<','>',',','.','/','','','|','\\\\','?'] then\n\t\t\tname:=chr(key.charcode)\n\t\t\tkey.shift iand:=inot shiftmask\t\t!ignore any shift press needed to get char\n\n\t\telsif key.keycode in ['A'..'Z','0'..'9'] then\n\t\t\tif (key.shift iand (ctrlmask ior altmask))=0 then\n\t\t\t\tname:=chr(key.charcode)\n\t\t\t\tkey.shift iand:=inot shiftmask\n\t\t\telse\n\t\t\t\tname:=convlc(chr(key.keycode))\n\t\t\tfi\n\t\telsif key.keycode in (186..223) then\n\t\t\tcase key.keycode\n\t\t\twhen vkminus then name:=\"-\"\n\t\t\twhen vkequals then name:=\"=\"\n\t\t\twhen vklsq then name:=\"[\"\n\t\t\twhen vkrsq then name:=\"]\"\n\t\t\twhen vksemi then name:=\";\"\n\t\t\twhen vkquote then name:=\"'\"\n\t\t\twhen vkhash then name:=\"#\"\n\t\t\twhen vkcomma then name:=\",\"\n\t\t\twhen vkperiod then name:=\".\"\n\t\t\twhen vkslash then name:=\"/\"\n\t\t\twhen vkbackslash then name:=\"\\\\\"\n\t\t\twhen vkbackquote then name:=\"`\"\n\t\t\telse\n\t\t\t\treturn \"?\"\n\t\t\tesac\n\t\telse\n\t\t\treturn \"?\"\n\t\tfi\n\tesac\n\n\tprefix::=\"*\"\n\tif key.shift iand shiftmask then prefix+:=\"s\" fi\n\tif key.shift iand ctrlmask then prefix+:=\"c\" fi\n\tif key.shift iand altmask then prefix+:=\"a\" fi\n\treturn prefix+name\n\nend\n\nexport func keynametokey(name)=\n!given a key name in the format \"*...\", reconstruct an rkey record, and return that\n\tcharcode:=shift:=keycode:=0\n\n\tname:=rightstr(name,-1)\t\t!get rid of \"*\"\n\n\tif name.len=1 then\t\t!simple printable key, no shifts\n\t\tcharcode:=asc(name)\n\t\tgoto simplekey\n\n\telse\t\t\t\t!any letters s,c,a on left indicate a modifier\n\t\twhile name.len>1 do\n\t\t\tcase leftstr(name)\n\t\t\twhen \"s\" then\n\t\t\t\tshift ior:=shiftmask\n\t\t\t\tname:=rightstr(name,-1)\n\t\t\twhen \"c\" then\n\t\t\t\tshift ior:=ctrlmask\n\t\t\t\tname:=rightstr(name,-1)\n\t\t\twhen \"a\" then\n\t\t\t\tshift ior:=altmask\n\t\t\t\tname:=rightstr(name,-1)\n\t\t\telse\n\t\t\t\texit\n\t\t\tesac\n\t\tod\n\n\t\tcase name\n\t\twhen \"left\" then keycode:=vkleft\n\t\twhen \"right\" then keycode:=vkright\n\t\twhen \"up\" then keycode:=vkup\n\t\twhen \"down\" then keycode:=vkdown\n\t\twhen \"pageup\" then keycode:=vkpageup\n\t\twhen \"pagedown\" then keycode:=vkpagedown\n\t\twhen \"home\" then keycode:=vkhome\n\t\twhen \"end\" then keycode:=vkend\n\t\twhen \"insert\" then keycode:=vkinsert\n\t\twhen \"delete\" then keycode:=vkdelete\n\t\twhen \"tab\" then keycode:=charcode:=vktab\n\t\twhen \"escape\" then keycode:=vkescape\n\t\twhen \"backspace\" then keycode:=charcode:=vkbackspace\n\t\twhen \"enter\" then keycode:=charcode:=vkenter\n\t\twhen \"space\" then keycode:=charcode:=vkspace\n\t\telse\n\t\t\tif name.len>=2 and leftstr(name)=\"f\" then\t!function key\n\t\t\t\tkeycode:=vkf1+strtoval(rightstr(name,-1))-1\n\t\t\telsif name.len=1 then\t\t\t\t!ordinary key, but with shifts\n\tsimplekey:\n\t\t\t\tc:=asc(name)\n\t\t\t\tcase c\n\t\t\t\twhen ['A'..'Z'] then\n\t\t\t\t\tkeycode:=c\n\t\t\t\twhen ['a'..'z'] then\n\t\t\t\t\tkeycode:=c-' '\n\t\t\t\twhen ['0'..'9'] then\n\t\t\t\t\tkeycode:=c\n\t\t\t\twhen '-','_' then keycode:=vkminus\n\t\t\t\twhen '=','+' then keycode:=vkequals\n\t\t\t\twhen '[','{' then keycode:=vklsq\n\t\t\t\twhen ']','}' then keycode:=vkrsq\n\t\t\t\twhen ';',':' then keycode:=vksemi\n\t\t\t\twhen '\\'','@' then keycode:=vkquote\n\t\t\t\twhen ',','<' then keycode:=vkcomma\n\t\t\t\twhen '.','>' then keycode:=vkperiod\n\t\t\t\twhen '/','?' then keycode:=vkslash\n\t\t\t\twhen '\\\\','|' then keycode:=vkbackslash\n\t\t\t\twhen '`','' then keycode:=vkbackquote\n\t\t\t\twhen '#','~' then keycode:=vkhash\n\t\t\t\twhen '!' then keycode:='1'\n\t\t\t\twhen '\"' then keycode:='2'\n\t\t\t\twhen '' then keycode:='3'\n\t\t\t\twhen '$' then keycode:='4'\n\t\t\t\twhen '%' then keycode:='5'\n\t\t\t\twhen '^' then keycode:='6'\n\t\t\t\twhen '&' then keycode:='7'\n\t\t\t\twhen '*' then keycode:='8'\n\t\t\t\twhen '(' then keycode:='9'\n\t\t\t\twhen ')' then keycode:='0'\n\t\t\t\telse\n\t\t\t\t\tpcerror(\"keynametokey\")\n\t\t\t\tend\n\t\t\tfi\n\t\tesac\n\tfi\n\n\tif shift iand (altmask ior ctrlmask) then\n\t\tcharcode:=0\n\t\tif keycode in 'A'..'Z' then\n\t\t\tcharcode:=keycode-'@'\n\t\tfi\n\tfi\n\n\tkey:=new(rkey)\t\t\t!convert to proper keyrec\n\tkey.charcode:=charcode\n\tkey.shift:=shift\n\tkey.keycode:=keycode\n\treturn key\nend\n\nexport proc clearscreen(?bgnd,?fgnd)=\n\nif bgnd.isvoid then bgnd:=defscreenbgnd fi\nif fgnd.isvoid then fgnd:=defscreenfgnd fi\nsetcolour(fgnd,bgnd)\n\nfor i:=1 to screenrows do\n\tsetpos(1,i)\n\tshowtext(\" \"*screencols)\n!\tshowtext(\"*\"*screencols)\nod\nsetpos(1,1)\nend\n\nexport func readline(?cmdline,donewline=1)=\n!this func doesn't handle tabs properly\n!would need to maintain 2 buffers, one with tabs translated to spaces\n!or convert tabs to another char which is translated back to tabs on exit\n!return with input buffer set to the line, but also returns the complete line\n!newline=1 to end with a newline, 0 to leave it\n\n!readln\n!return\n\n\tbuffer:=\"\"\n\tnchars:=0\n!congetpos()\n\n!NOTE: getpos is dodgy using TERMCON; MAY NEED CALLER TO SPECIFY START POINT\n\t(startx,starty):=(getpos())\n\n\tpos:=0\t\t!with nchars shown, pos can be 0 to nchars\n\n\treenter:\n\tif cmdline.defined and cmdline<>\"\" then\n\t\tbuffer:=cmdline\n\treenter2:\n\t\tpos:=nchars:=buffer.len\n\tfi\n\n\tdo\n! print \"_\"\n\t\trlkey:=0\t\t\t!normal input starts with \"*\" will expect rlkey to be a keyrec\n\t\tsetpos(startx,starty)\n\t\tprint buffer\n\t\tsetpos(startx+pos,starty)\n\n\t\tkey:=getkey()\n\t\tkeycode:=key.keycode\n\t\tkeyshift:=key.shift\n\n\t\tcase keycode\n\t\twhen vkpageup,vkpagedown,vkup,vkdown,vkinsert,vkf1..vkf12 then\n\n\tdospecial:\n\t\trlbuffer:=buffer\n\t\t\toldbufferlen:=buffer.len\t\t!to help erase old buffer\n\t\t\tbuffer:=getkeyname(key)\n\t\t\trlkey:=key\t\t\t\t!allow caller to use key code rather than name\n\t\t\texit\n\n\t\twhen vkleft then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\n\t\t\tif pos>0 then\n\t\t\t\t--pos\n\t\t\tfi\n\n\t\twhen vkhome then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tpos:=0\n\n\t\twhen vkend then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tpos:=nchars\n\n\t\twhen vkright then\n\t\t\tif buffer=\"\" then goto dospecial fi\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif pos<nchars then\n\t\t\t\t++pos\n\t\t\tfi\n\n\t\twhen vkenter then\n\n!  println\n\t\t\texit\n\n\t\twhen vkbackspace then\n\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif nchars then\n\t\t\t\tsetpos(startx,starty)\n\t\t\t\tprint \" \"*buffer.len\n\n\t\t\t\tcase pos\n\t\t\t\twhen 0 then\t\t\t!not allowed\n\t\t\t\twhen nchars then\t\t!at end\n\t\t\t\t\tbuffer:=leftstr(buffer,-1)\n\t\t\t\t\t--nchars\n\t\t\t\t\t--pos\n\t\t\t\telse\t\t\t\t!in middle\n\t\t\t\t\tbuffer:=leftstr(buffer,pos-1)+rightstr(buffer,-(pos))\n\t\t\t\t\t--nchars\n\t\t\t\t\t--pos\n\t\t\t\tesac\n\n\t\t\tfi\n\n\t\twhen vkdelete then\n\t\t\tif (keyshift iand 7) then goto dospecial fi\n\t\t\tif nchars and nchars=pos then\n\t\t\t\tgoto delline\n\t\t\tfi\n\t\t\tif nchars=0 then\n\t\t\t\tgoto dospecial\n\t\t\tfi\n\t\t\tif nchars then\n!CPL \"\\NNCHARS\",=NCHARS,++CCC,=POS,\"\\N\"\n\t\t\t\tsetpos(startx,starty)\n\t\t\t\tprint \" \"*buffer.len\n\n\t\t\t\tcase pos\n\t\t\t\twhen nchars then\t\t!not allowed\n!\t\t\twhen 0 then\t\t\t!at start\n!\t\t\t\tbuffer:=leftstr(buffer,-1)\n!\t\t\t\t--nchars\n\t\t\t\telse\t\t\t\t!in middle\n\t\t\t\t\tbuffer:=leftstr(buffer,pos)+rightstr(buffer,-(pos+1))\n\t\t\t\t\t--nchars\n!    --pos\n\t\t\t\tesac\n\n\t\t\tfi\n\n\t\twhen vkescape then\n\t\t\tif nchars=0 then\n\t\t\t\tgoto dospecial\n!   oldbufferlen:=buffer.len\n!   buffer:=\"*esc\"\n!   exit\n\t\t\tfi\n\tdelline:\n\t\t\tsetpos(startx,starty)\n\t\t\tprint \" \"*buffer.len\n\n\t\t\tbuffer:=\"\"\n\t\t\tnchars:=pos:=0\n\n\t\twhen vktab then\n\t\t\tgoto normalkey\n\n\t\telse\n\tnormalkey:\n\t\t\tif (key.charcode>=' ' or key.charcode=9) then\n\t\t\t\tif pos=0 then\n\t\t\t\t\tbuffer:=chr(key.charcode)+buffer\n\t\t\t\telsif pos=nchars then\n\t\t\t\t\tbuffer:=buffer+chr(key.charcode)\n\t\t\t\telse\n\t\t\t\t\tbuffer:=leftstr(buffer,pos)+chr(key.charcode)+rightstr(buffer,-(pos))\n\t\t\t\tfi\n\t\t\t\t++nchars\n\t\t\t\t++pos\n\t\t\telse\n\t\t\t\tGOTO DOSPECIAL\n\t\t\t\tprint \"<\",keycode,key.charcode,\">\"\n\t\t\tfi\n\n\t\tesac\n\tod\n\n\tcase buffer\n\twhen \"*cup\",\"*cdown\" then\n\t\tif ncmds then\n\t\t\tsetpos(startx,starty)\n\t\t\tprint \" \"*oldbufferlen\n\n\t\t\tif cmdindex=0 then\t\t!get started on last\n\t\t\t\tcmdline:=cmdhistory[ncmds]\n\t\t\t\tcmdindex:=ncmds\n\t\t\t\tgoto reenter\n\t\t\tfi\n\n\t\t\tif buffer=\"*cup\" and cmdindex>1 then\n\t\t\t\t--cmdindex\n\t\t\telsif buffer=\"*cdown\" and cmdindex<ncmds then\n\t\t\t\t++cmdindex\n\t\t\tfi\n\t\t\tcmdline:=cmdhistory[cmdindex]\n\t\t\tgoto reenter\n\t\tfi\n\t\tbuffer:=\"\"\n\t\tgoto reenter2\n\tesac\n\n\tif buffer.len>1 and leftstr(buffer)<>\"*\" then\n\t\tif ncmds=0 or cmdhistory[ncmds]<>buffer then\n\t\t\tcmdhistory[++ncmds]:=buffer\n\t\tfi\n\t\tcmdindex:=0\n\tfi\n\n\tif donewline then println fi\n\n\treturn sreadln(buffer)\nend\n\nexport proc wsetcolumns(w,columns)=\n\tw.columns:=columns\n\tw.itemcols:=w.cols%w.columns\n\tw.pagesize:=w.rows*w.columns\nend\n\n",
    
(byte*)"!Windows win32 constants\n\nglobal const driverversion =  0\nglobal const technology =  2\nglobal const horzsize =  4\nglobal const vertsize =  6\nglobal const horzres =  8\nglobal const vertres =  10\nglobal const bitspixel =  12\nglobal const bitplanes =  14\nglobal const numbrushes =  16\nglobal const numpens =  18\nglobal const nummarkers =  20\nglobal const numfonts =  22\nglobal const numcolours =  24\nglobal const pdevicesize =  26\nglobal const curvecaps =  28\nglobal const linecaps =  30\nglobal const polygonalcaps =  32\nglobal const textcaps =  34\nglobal const clipcaps =  36\nglobal const rastercaps =  38\nglobal const aspectx =  40\nglobal const aspecty =  42\nglobal const aspectxy =  44\nglobal const logpixelsx =  88\nglobal const logpixelsy =  90\nglobal const sizepalette =  104\nglobal const numreserved =  106\nglobal const colourres =  108\nglobal const physicalwidth =  110\nglobal const physicalheight =  111\nglobal const physicaloffsetx =  112\nglobal const physicaloffsety =  113\nglobal const scalingfactorx =  114\nglobal const scalingfactory =  115\nglobal const fw_dontcare =  0\nglobal const fw_thin =  100\nglobal const fw_extralight =  200\nglobal const fw_ultralight =  200\nglobal const fw_light =  300\nglobal const fw_normal =  400\nglobal const fw_regular =  400\nglobal const fw_medium =  500\nglobal const fw_semibold =  600\nglobal const fw_demibold =  600\nglobal const fw_bold =  700\nglobal const fw_extrabold =  800\nglobal const fw_ultrabold =  800\nglobal const fw_heavy =  900\nglobal const fw_black =  900\nglobal const cs_vredraw =  1\nglobal const cs_hredraw =  2\nglobal const cs_keycvtwindow =  4\nglobal const cs_dblclks =  8\nglobal const cs_owndc =  32\nglobal const cs_classdc =  64\nglobal const cs_parentdc =  128\nglobal const cs_nokeycvt =  256\nglobal const cs_noclose =  512\nglobal const cs_savebits =  2048\nglobal const cs_bytealignclient =  4096\nglobal const cs_bytealignwindow =  8192\nglobal const cs_publicclass =  16384\nglobal const sw_hide =  0\nglobal const sw_shownormal =  1\nglobal const sw_normal =  1\nglobal const sw_showminimized =  2\nglobal const sw_showmaximized =  3\nglobal const sw_maximize =  3\nglobal const sw_shownoactivate =  4\nglobal const sw_show =  5\nglobal const sw_minimize =  6\nglobal const sw_showminnoactive =  7\nglobal const sw_showna =  8\nglobal const sw_restore =  9\nglobal const sw_showdefault =  10\nglobal const sw_max =  10\nglobal const pm_noremove =  0\nglobal const pm_remove =  1\nglobal const pm_noyield =  2\nglobal const wm_null =  0\nglobal const wm_create =  1\nglobal const wm_destroy =  2\nglobal const wm_move =  3\nglobal const wm_size =  5\nglobal const wm_activate =  6\nglobal const wa_inactive =  0\nglobal const wa_active =  1\nglobal const wa_clickactive =  2\nglobal const wm_setfocus =  7\nglobal const wm_killfocus =  8\nglobal const wm_enable =  10\nglobal const wm_setredraw =  11\nglobal const wm_settext =  12\nglobal const wm_gettext =  13\nglobal const wm_gettextlength =  14\nglobal const wm_paint =  15\nglobal const wm_close =  16\nglobal const wm_queryendsession =  17\nglobal const wm_quit =  18\nglobal const wm_queryopen =  19\nglobal const wm_erasebkgnd =  20\nglobal const wm_syscolourchange =  21\nglobal const wm_endsession =  22\nglobal const wm_showwindow =  24\nglobal const wm_wininichange =  26\nglobal const wm_devmodechange =  27\nglobal const wm_activateapp =  28\nglobal const wm_fontchange =  29\nglobal const wm_timechange =  30\nglobal const wm_cancelmode =  31\nglobal const wm_setcursor =  32\nglobal const wm_mouseactivate =  33\nglobal const wm_childactivate =  34\nglobal const wm_queuesync =  35\nglobal const wm_getminmaxinfo =  36\nglobal const wm_drawitem =  43\nglobal const wm_notify =  78\nglobal const wm_contextmenu =  123\nglobal const wm_geticon =  127\nglobal const wm_seticon =  128\nglobal const wm_nchittest =  132\n\nglobal const wm_nclbuttondown\t= 161\nglobal const wm_nclbuttonup\t= 162\nglobal const wm_nclbuttondblclick\t= 163\n\nglobal const wm_menurbuttonup\t= 290\n\nglobal const wm_parentnotify =  528\nglobal const wm_dropfiles =  563\nglobal const wm_enteridle =  289\nglobal const wm_user =  1024\nglobal const wm_mdicreate =  544\nglobal const wm_mdidestroy =  545\nglobal const wm_mdiactivate =  546\nglobal const wm_mdirestore =  547\nglobal const wm_mdinext =  548\nglobal const wm_mdimaximize =  549\nglobal const wm_mditile =  550\nglobal const wm_mdicascade =  551\nglobal const wm_mdiiconarange =  552\nglobal const wm_mdigetactive =  553\nglobal const wm_mdisetmenu =  560\nglobal const wm_entersizemove =  561\nglobal const wm_exitsizemove =  562\nglobal const wm_mdirefrshmenu =  564\nglobal const wm_lbuttondblclk =  515\nglobal const wm_rbuttondblclk =  518\nglobal const wm_lbuttondown =  513\nglobal const wm_rbuttondown =  516\nglobal const wm_mbuttondown =  519\nglobal const wm_mousemove =  512\nglobal const wm_lbuttonup =  514\nglobal const wm_rbuttonup =  517\nglobal const wm_mbuttonup =  520\nglobal const wm_mbuttondblclk =  521\nglobal const wm_mousewheel =  522\nglobal const snd_filename =  131072\nglobal const snd_async =  1\nglobal const dt_singleline =  32\nglobal const dt_centre =  1\nglobal const dt_vcentre =  4\nglobal const ws_overlapped =  0\nglobal const ws_popup =  2147483648\nglobal const ws_child =  1073741824\nglobal const ws_minimize =  536870912\nglobal const ws_visible =  268435456\nglobal const ws_disabled =  134217728\nglobal const ws_clipsiblings =  67108864\nglobal const ws_clipchildren =  33554432\nglobal const ws_maximize =  16777216\nglobal const ws_caption =  12582912\nglobal const ws_border =  8388608\nglobal const ws_dlgframe =  4194304\nglobal const ws_hscroll =  1048576\nglobal const ws_vscroll =  2097152\nglobal const ws_sysmenu =  524288\nglobal const ws_thickframe =  262144\nglobal const ws_group =  131072\nglobal const ws_tabstop =  0\nglobal const ws_scrollbars =  3145728\nglobal const ws_minimizebox =  131072\nglobal const ws_maximizebox =  65536\nglobal const ws_tiled =  0\nglobal const ws_iconic =  536870912\nglobal const ws_sizebox =  262144\nglobal const ws_overlappedwindow =  13565952\nglobal const ws_tiledwindow =  13565952\nglobal const ws_popupwindow =  -2138570752\nglobal const ws_childwindow =  1073741824\nglobal const ws_ex_acceptfiles =  16\nglobal const ws_ex_appwindow =  262144\nglobal const ws_ex_clientedge =  512\nglobal const ws_ex_contexthelp =  1024\nglobal const ws_ex_controlparent =  65536\nglobal const ws_ex_dlgmodalframe =  1\nglobal const ws_ex_left =  0\nglobal const ws_ex_leftscrollbar =  16384\nglobal const ws_ex_ltrreading =  0\nglobal const ws_ex_mdichild =  64\nglobal const ws_ex_noparentnotify =  4\nglobal const ws_ex_overlappedwindow =  768\nglobal const ws_ex_palettewindow =  392\nglobal const ws_ex_right =  4096\nglobal const ws_ex_rightscrollbar =  0\nglobal const ws_ex_rtlreading =  8192\nglobal const ws_ex_staticedge =  131072\nglobal const ws_ex_toolwindow =  128\nglobal const ws_ex_topmost =  8\nglobal const ws_ex_transparent =  32\nglobal const ws_ex_windowedge =  256\n\nglobal const gw_hwndfirst =  0\nglobal const gw_hwndlast =  1\nglobal const gw_hwndnext =  2\nglobal const gw_hwndprev =  3\nglobal const gw_owner =  4\nglobal const gw_child =  5\nglobal const gw_enabledpopup =  6\nglobal const cb_geteditsel =  320\nglobal const cb_limittext =  321\nglobal const cb_seteditsel =  322\nglobal const cb_addstring =  323\nglobal const cb_deletestring =  324\nglobal const cb_dir =  325\nglobal const cb_getcount =  326\nglobal const cb_getcursel =  327\nglobal const cb_getlbtext =  328\nglobal const cb_getlbtextlen =  329\nglobal const cb_insertstring =  330\nglobal const cb_resetcontent =  331\nglobal const cb_findstring =  332\nglobal const cb_findstringexact =  344\nglobal const cb_selectstring =  333\nglobal const cb_setcursel =  334\nglobal const cb_showdropdown =  335\nglobal const cb_getitemdata =  336\nglobal const cb_setitemdata =  337\nglobal const cb_getdroppedcontrolrect =  338\nglobal const cb_setitemheight =  339\nglobal const cb_getitemheight =  340\nglobal const cb_setextendedui =  341\nglobal const cb_getextendedui =  342\nglobal const cb_getdroppedstate =  343\nglobal const cb_setlocale =  345\nglobal const cb_getlocale =  346\nglobal const cb_gettopindex =  347\nglobal const cb_settopindex =  348\nglobal const cb_gethorizontalextent =  349\nglobal const cb_sethorizontalextent =  350\nglobal const cb_getdroppedwidth =  351\nglobal const cb_setdroppedwidth =  352\nglobal const cb_initstorage =  353\nglobal const cb_multipleaddstring =  355\nglobal const bm_click =  245\nglobal const bm_getcheck =  240\nglobal const bm_getimage =  246\nglobal const bm_getstate =  242\nglobal const bm_setcheck =  241\nglobal const bm_setimage =  247\nglobal const bm_setstate =  243\nglobal const bm_setstyle =  244\nglobal const cf_bitmap =  2\nglobal const cf_dib =  8\nglobal const cf_palette =  9\nglobal const cf_enhmetafile =  14\nglobal const cf_metafilepict =  3\nglobal const cf_oemtext =  7\nglobal const cf_text =  1\t\t\t!used in sys\nglobal const cf_unicodetext =  13\nglobal const cf_dif =  5\nglobal const cf_dspbitmap =  130\nglobal const cf_dspenhmetafile =  142\nglobal const cf_dspmetafilepict =  131\nglobal const cf_dsptext =  129\nglobal const cf_gdiobjfirst =  768\nglobal const cf_gdiobjlast =  1023\nglobal const cf_hdrop =  15\nglobal const cf_locale =  16\nglobal const cf_ownerdisplay =  128\nglobal const cf_pendata =  10\nglobal const cf_privatefirst =  512\nglobal const cf_privatelast =  767\nglobal const cf_riff =  11\nglobal const cf_sylk =  4\nglobal const cf_wave =  12\nglobal const cf_tiff =  6\n\nglobal const tcif_text =  1\nglobal const tcif_image =  2\nglobal const tcif_param =  8\nglobal const tcif_rtlreading =  4\n\nglobal const wm_keydown =  256\nglobal const wm_keyup =  257\nglobal const wm_char =  258\nglobal const wm_syschar =  262\nglobal const wm_sysdeadchar =  263\nglobal const wm_syskeydown =  260\nglobal const wm_syskeyup =  261\nglobal const mf_insert =  0\nglobal const mf_change =  128\nglobal const mf_append =  256\nglobal const mf_delete =  512\nglobal const mf_remove =  4096\nglobal const mf_bycommand =  0\nglobal const mf_byposition =  1024\nglobal const mf_separator =  2048\nglobal const mf_enabled =  0\nglobal const mf_grayed =  1\nglobal const mf_greyed =  1\nglobal const mf_disabled =  2\nglobal const mf_unchecked =  0\nglobal const mf_checked =  8\nglobal const mf_usecheckbitmaps =  512\nglobal const mf_string =  0\nglobal const mf_bitmap =  4\nglobal const mf_ownerdraw =  256\nglobal const mf_popup =  16\nglobal const mf_menubarbreak =  32\nglobal const mf_menubreak =  64\nglobal const mf_unhilite =  0\nglobal const mf_hilite =  128\nglobal const mf_sysmenu =  8192\nglobal const mf_help =  16384\nglobal const mf_mouseselect =  32768\n\n!global const bn_clicked =  0\n!global const bn_dblclk =  5\n!global const bn_disable =  4\n!global const bn_doubleclicked =  5\n!global const bn_hilite =  2\n!global const bn_killfocus =  7\n!global const bn_paint =  1\n!global const bn_pushed =  2\n!global const bn_setfocus =  6\n!global const bn_unhilite =  3\n!global const bn_unpushed =  3\n!global const en_setfocus =  256\n!global const en_killfocus =  512\n!global const en_change =  768\n!global const en_update =  1024\n!global const en_errspace =  1280\n!global const en_maxtext =  1281\n!global const en_hscroll =  1537\n!global const en_vscroll =  1538\n!global const lbn_errspace =  -2\n!global const lbn_selchange =  1\n!global const lbn_dblclk =  2\n!global const lbn_selcancel =  3\n!global const lbn_setfocus =  4\n!global const lbn_killfocus =  5\n!global const cbn_errspace =  -1\n!global const cbn_selchange =  1\n!global const cbn_dblclk =  2\n!global const cbn_setfocus =  3\n!global const cbn_killfocus =  4\n!global const cbn_editchange =  5\n!global const cbn_editupdate =  6\n!global const cbn_dropdown =  7\n!global const cbn_closeup =  8\n!global const cbn_selendok =  9\n!global const cbn_selendcancel =  10\n!\n!global const cbs_autohscroll =  64\n!global const cbs_disablenoscroll =  2048\n!global const cbs_dropdown =  2\n!global const cbs_dropdownlist =  3\n!global const cbs_hasstrings =  512\n!global const cbs_lowercase =  16384\n!global const cbs_nointegralheight =  1024\n!global const cbs_oemconvert =  128\n!global const cbs_ownerdrawfixed =  16\n!global const cbs_ownerdrawvariable =  32\n!global const cbs_simple =  1\n!global const cbs_sort =  256\n!global const cbs_uppercase =  8192\n\nglobal const wm_command =  273\nglobal const wm_menuselect =  287\nglobal const wm_cut =  768\nglobal const wm_copy =  769\nglobal const wm_paste =  770\nglobal const wm_clear =  771\nglobal const wm_undo =  772\nglobal const em_getsel =  176\nglobal const em_setsel =  177\nglobal const em_scroll =  181\nglobal const em_linescroll =  182\nglobal const em_scrollcaret =  183\nglobal const em_getmodify =  184\nglobal const em_setmodify =  185\nglobal const em_getlinecount =  186\nglobal const em_lineindex =  187\nglobal const em_sethandle =  188\nglobal const em_gethandle =  189\nglobal const em_getthumb =  190\nglobal const em_linelength =  193\nglobal const em_replacesel =  194\nglobal const em_getline =  196\nglobal const em_limittext =  197\nglobal const em_canundo =  198\nglobal const em_undo =  199\nglobal const em_fmtlines =  200\nglobal const em_linefromchar =  201\nglobal const em_settabstops =  203\nglobal const em_setpasswordchar =  204\nglobal const em_emptyundobuffer =  205\nglobal const em_getfirstvisibleline =  206\nglobal const em_setreadonly =  207\nglobal const em_setwordbreakproc =  208\nglobal const em_getwordbreakproc =  209\nglobal const em_getpasswordchar =  210\nglobal const em_setlimittext =  197\nglobal const em_getseltext =  1086\nglobal const em_setcharformat =  1092\nglobal const em_getcharformat =  1082\nglobal const em_settextmode =  1113\nglobal const em_gettextmode =  1114\nglobal const em_gettextex =  1118\nglobal const em_gettextlengthex =  1119\nglobal const tm_plaintext =  1\nglobal const tm_richtext =  2\nglobal const tm_singlelevelundo =  4\nglobal const tm_multilevelundo =  8\nglobal const tm_singlecodepage =  16\nglobal const tm_multicodepage =  32\nglobal const scf_word =  2\nglobal const scf_selection =  1\nglobal const sb_getborders =  1031\nglobal const sb_getparts =  1030\nglobal const sb_getrect =  1034\nglobal const sb_gettextw =  1037\nglobal const sb_gettextlengthw =  1036\nglobal const sb_settextw =  1035\nglobal const sb_gettexta =  1026\nglobal const sb_gettextlengtha =  1027\nglobal const sb_settexta =  1025\nglobal const sb_gettext =  1026\nglobal const sb_gettextlength =  1027\nglobal const sb_settext =  1025\nglobal const sb_setminheight =  1032\nglobal const sb_setparts =  1028\nglobal const sb_simple =  1033\nglobal const wm_setfont =  48\nglobal const wm_getfont =  49\nglobal const gm_advanced =  2\nglobal const transparent =  1\nglobal const opaque =  2\nglobal const mwt_identity =  1\nglobal const cw_usedefault =  0x8000'0000\nglobal const idc_arrow =  32512\nglobal const idc_ibeam =  32513\nglobal const idc_wait =  32514\nglobal const idc_cross =  32515\nglobal const idc_uparrow =  32516\nglobal const idc_sizenwse =  32642\nglobal const idc_sizenesw =  32643\nglobal const idc_sizewe =  32644\nglobal const idc_sizens =  32645\nglobal const idc_sizeall =  32646\nglobal const idc_no =  32648\nglobal const idc_appstarting =  32650\nglobal const idc_help =  32651\nglobal const idi_application =  32512\nglobal const idi_hand =  32513\nglobal const idi_question =  32514\nglobal const idi_exclamation =  32515\nglobal const idi_asterisk =  32516\nglobal const idi_winlogo =  32517\nglobal const idc_size =  32640\nglobal const idc_icon =  32641\nglobal const arrowpointer =  32512\nglobal const ibeampointer =  32513\nglobal const waitpointer =  32514\nglobal const crosspointer =  32515\nglobal const uparrowpointer =  32516\nglobal const sizenwsepointer =  32642\nglobal const sizeneswpointer =  32643\nglobal const sizewepointer =  32644\nglobal const sizenspointer =  32645\nglobal const sizeallpointer =  32646\nglobal const nopointer =  32648\nglobal const appstartingpointer =  32650\nglobal const helpicon =  32651\nglobal const applicationicon =  32512\nglobal const handicon =  32513\nglobal const questionicon =  32514\nglobal const exclamationicon =  32515\nglobal const asteriskicon =  32516\nglobal const winlogoicon =  32517\nglobal const sizepointer =  32640\nglobal const iconicon =  32641\nglobal const sm_cymin =  29\nglobal const sm_cxmin =  28\nglobal const sm_arrange =  56\nglobal const sm_cleanboot =  67\nglobal const sm_cmetrics =  76\nglobal const sm_cmousebuttons =  43\nglobal const sm_cxborder =  5\nglobal const sm_cyborder =  6\nglobal const sm_cxcursor =  13\nglobal const sm_cycursor =  14\nglobal const sm_cxdlgframe =  7\nglobal const sm_cydlgframe =  8\nglobal const sm_cxdoubleclk =  36\nglobal const sm_cydoubleclk =  37\nglobal const sm_cxdrag =  68\nglobal const sm_cydrag =  69\nglobal const sm_cxedge =  45\nglobal const sm_cyedge =  46\nglobal const sm_cxfixedframe =  7\nglobal const sm_cyfixedframe =  8\nglobal const sm_cxframe =  32\nglobal const sm_cyframe =  33\nglobal const sm_cxfullscreen =  16\nglobal const sm_cyfullscreen =  17\nglobal const sm_cxhscroll =  21\nglobal const sm_cyhscroll =  3\nglobal const sm_cxhthumb =  10\nglobal const sm_cxicon =  11\nglobal const sm_cyicon =  12\nglobal const sm_cxiconspacing =  38\nglobal const sm_cyiconspacing =  39\nglobal const sm_cxmaximized =  61\nglobal const sm_cymaximized =  62\nglobal const sm_cxmaxtrack =  59\nglobal const sm_cymaxtrack =  60\nglobal const sm_cxmenucheck =  71\nglobal const sm_cymenucheck =  72\nglobal const sm_cxmenusize =  54\nglobal const sm_cymenusize =  55\nglobal const sm_cxminimized =  57\nglobal const sm_cyminimized =  58\nglobal const sm_cxminspacing =  47\nglobal const sm_cyminspacing =  48\nglobal const sm_cxmintrack =  34\nglobal const sm_cymintrack =  35\nglobal const sm_cxscreen =  0\nglobal const sm_cyscreen =  1\nglobal const sm_cxsize =  30\nglobal const sm_cysize =  31\nglobal const sm_cxsizeframe =  32\nglobal const sm_cysizeframe =  33\nglobal const sm_cxsmicon =  49\nglobal const sm_cysmicon =  50\nglobal const sm_cxsmsize =  52\nglobal const sm_cysmsize =  53\nglobal const sm_cxvscroll =  2\nglobal const sm_cyvscroll =  20\nglobal const sm_cyvthumb =  9\nglobal const sm_cycaption =  4\nglobal const sm_cykanjiwindow =  18\nglobal const sm_cymenu =  15\nglobal const sm_cysmcaption =  51\nglobal const sm_dbcsenabled =  42\nglobal const sm_debug =  22\nglobal const sm_menudropalignment =  40\nglobal const sm_mideastenabled =  74\nglobal const sm_mousepresent =  19\nglobal const sm_mousewheelpresent =  75\nglobal const sm_network =  63\nglobal const sm_penwindows =  41\nglobal const sm_reserved1 =  24\nglobal const sm_reserved2 =  25\nglobal const sm_reserved3 =  26\nglobal const sm_reserved4 =  27\nglobal const sm_secure =  44\nglobal const sm_showsounds =  70\nglobal const sm_slowmachine =  73\nglobal const sm_swapbutton =  23\nglobal const arw_bottomleft =  0\nglobal const arw_bottomright =  1\nglobal const arw_hide =  8\nglobal const arw_topleft =  2\nglobal const arw_topright =  3\nglobal const arw_down =  4\nglobal const arw_left =  0\nglobal const arw_right =  0\nglobal const arw_up =  4\nglobal const white_brush =  0\nglobal const ltgray_brush =  1\nglobal const gray_brush =  2\nglobal const dkgray_brush =  3\nglobal const black_brush =  4\nglobal const null_brush =  5\nglobal const hollow_brush =  5\nglobal const white_pen =  6\nglobal const black_pen =  7\nglobal const null_pen =  8\nglobal const oem_fixed_font =  10\nglobal const ansi_fixed_font =  11\nglobal const ansi_var_font =  12\nglobal const system_font =  13\nglobal const device_default_font =  14\nglobal const default_palette =  15\nglobal const system_fixed_font =  16\nglobal const stock_last =  16\n\n!global const sbm_setpos =  224\n!global const sbm_getpos =  225\n!global const sbm_setrange =  226\n!global const sbm_setrangeredraw =  230\n!global const sbm_getrange =  227\n!global const sbm_enable_arrows =  228\n!global const sbs_horz =  0\n!global const sbs_vert =  1\n!global const sbs_topalign =  2\n!global const sbs_leftalign =  2\n!global const sbs_bottomalign =  4\n!global const sbs_rightalign =  4\n!global const sbs_sizeboxtopleftalign =  2\n!global const sbs_sizeboxbottomrightalign =  4\n!global const sbs_sizebox =  8\n\nglobal const wm_hscroll =  276\nglobal const wm_vscroll =  277\n\n!global const sb_horz =  0\n!global const sb_hoz =  0\n!global const sb_vert =  1\n!global const sb_ctl =  2\n!global const sb_both =  3\n!global const sb_lineup =  0\n!global const sb_lineleft =  0\n!global const sb_linedown =  1\n!global const sb_lineright =  1\n!global const sb_pageup =  2\n!global const sb_pageleft =  2\n!global const sb_pagedown =  3\n!global const sb_pageright =  3\n!global const sb_thumbposition =  4\n!global const sb_thumbtrack =  5\n!global const sb_top =  6\n!global const sb_left =  6\n!global const sb_bottom =  7\n!global const sb_right =  7\n!global const sb_endscroll =  8\n!global const sif_disablenoscroll =  8\n!global const sif_page =  2\n!global const sif_pos =  4\n!global const sif_range =  1\n!global const sif_trackpos =  16\n!global const sif_all =  23\n\nglobal const wm_ctlcolourmsgbox =  306\nglobal const wm_ctlcolouredit =  307\nglobal const wm_ctlcolourlistbox =  308\nglobal const wm_ctlcolourbtn =  309\nglobal const wm_ctlcolourdlg =  310\nglobal const wm_ctlcolourscrollbar =  311\nglobal const wm_ctlcolourstatic =  312\nglobal const wm_timer =  275\n\nglobal const srccopy =  13369376\nglobal const srcpaint =  15597702\nglobal const srcand =  8913094\nglobal const srcinvert =  6684742\nglobal const srcerase =  4457256\n\nglobal const notsrccopy =  3342344\nglobal const notsrcerase =  1114278\nglobal const mergecopy =  12583114\nglobal const mergepaint =  12255782\nglobal const patcopy =  15728673\nglobal const patpaint =  16452105\nglobal const patinvert =  5898313\nglobal const dstinvert =  5570569\nglobal const blackness =  66\nglobal const whiteness =  16711778\n\nglobal const r2_black =  1\nglobal const r2_notmergepen =  2\nglobal const r2_masknotpen =  3\nglobal const r2_notcopypen =  4\nglobal const r2_maskpennot =  5\nglobal const r2_not =  6\nglobal const r2_xorpen =  7\nglobal const r2_notmaskpen =  8\nglobal const r2_maskpen =  9\nglobal const r2_notxorpen =  10\nglobal const r2_nop =  11\nglobal const r2_mergenotpen =  12\nglobal const r2_copypen =  13\nglobal const r2_mergepennot =  14\nglobal const r2_mergepen =  15\nglobal const r2_white =  16\nglobal const r2_last =  16\n\nglobal const gdi_error =  4294967295\nglobal const hgdi_error =  4294967295\nglobal const clr_invalid =  4278190080\nglobal const clr_default =  4278190080\nglobal const clr_none =  4294967295\nglobal const ofn_readonly =  1\nglobal const ofn_overwriteprompt =  2\nglobal const ofn_hidereadonly =  4\nglobal const ofn_nochangedir =  8\nglobal const ofn_showhelp =  16\nglobal const ofn_enablehook =  32\nglobal const ofn_enabletemplate =  64\nglobal const ofn_enabletemplatehandle =  128\nglobal const ofn_novalidate =  256\nglobal const ofn_allowmultiselect =  512\nglobal const ofn_extensiondifferent =  1024\nglobal const ofn_pathmustexist =  2048\nglobal const ofn_filemustexist =  4096\nglobal const ofn_createprompt =  8192\nglobal const ofn_shareaware =  16384\nglobal const ofn_noreadonlyreturn =  32768\nglobal const ofn_notestfilecreate =  65536\nglobal const ofn_nonetworkbutton =  131072\nglobal const ofn_nolongnames =  262144\nglobal const ofn_explorer =  524288\nglobal const ofn_nodereferencelinks =  1048576\nglobal const ofn_longnames =  2097152\nglobal const ofn_sharefallthrough =  2\nglobal const ofn_sharenowarn =  1\nglobal const ofn_sharewarn =  0\n!global const gmem_fixed =  0\n!global const gmem_moveable =  2\n!global const gmem_nocompact =  16\n!global const gmem_nodiscard =  32\n!global const gmem_zeroinit =  64\n!global const gmem_modify =  128\n!global const gmem_discardable =  256\n!global const gmem_not_banked =  4096\n!global const gmem_share =  8192\n!global const gmem_ddeshare =  8192\n!global const gmem_notify =  16384\n!global const gmem_lower =  4096\n!global const gmem_valid_flags =  32626\n!global const gmem_invalid_handle =  32768\n!global const gmem_clipboard =  8194\n!global const ghnd =  66\n!global const gptr =  64\n!global const pd_allpages =  0\n!global const pd_collate =  16\n!global const pd_disableprinttofile =  524288\n!global const pd_enableprinthook =  4096\n!global const pd_enableprinttemplate =  16384\n!global const pd_enableprinttemplatehandle =  65536\n!global const pd_enablesetuphook =  8192\n!global const pd_enablesetuptemplate =  32768\n!global const pd_enablesetuptemplatehandle =  131072\n!global const pd_hideprinttofile =  1048576\n!global const pd_nopagenums =  8\n!global const pd_noselection =  4\n!global const pd_nowarning =  128\n!global const pd_pagenums =  2\n!global const pd_printsetup =  64\n!global const pd_printtofile =  32\n!global const pd_returndc =  256\n!global const pd_returndefault =  1024\n!global const pd_returnic =  512\n!global const pd_selection =  1\n!global const pd_showhelp =  2048\n!global const pd_usedevmodecopies =  262144\n!global const pd_usedevmodecopiesandcollate =  262144\nglobal const dib_rgb_colours =  0\nglobal const dib_pal_colours =  1\nglobal const dib_pal_indices =  2\nglobal const dib_pal_physindices =  2\nglobal const dib_pal_logindices =  4\nglobal const stm_seticon =  368\nglobal const stm_setimage =  370\nglobal const lr_loadfromfile =  16\nglobal const image_bitmap =  0\nglobal const image_icon =  1\nglobal const lr_copydeleteorg =  8\nglobal const lr_copyreturnorg =  4\nglobal const lr_monochrome =  1\nglobal const lr_createdibsection =  8192\nglobal const lr_defaultsize =  64\nglobal const ss_icon =  3\nglobal const ss_bitmap =  14\nglobal const gcl_menuname =  -8\nglobal const gcl_hbrbackground =  -10\nglobal const gcl_hcursor =  -12\nglobal const gcl_hicon =  -14\nglobal const gcl_hmodule =  -16\nglobal const gcl_cbwndextra =  -18\nglobal const gcl_cbclsextra =  -20\nglobal const gcl_wndproc =  -24\nglobal const gcl_style =  -26\nglobal const gcw_atom =  -32\nglobal const colour_scrollbar =  0\nglobal const colour_background =  1\nglobal const colour_desktop =  1\nglobal const colour_activecaption =  2\nglobal const colour_inactivecaption =  3\nglobal const colour_menu =  4\nglobal const colour_window =  5\nglobal const colour_windowframe =  6\nglobal const colour_menutext =  7\nglobal const colour_windowtext =  8\nglobal const colour_captiontext =  9\nglobal const colour_activeborder =  10\nglobal const colour_inactiveborder =  11\nglobal const colour_appworkspace =  12\nglobal const colour_highlight =  13\nglobal const colour_highlighttext =  14\nglobal const colour_btnface =  15\nglobal const colour_3dface =  15\nglobal const colour_btnshadow =  16\nglobal const colour_3dshadow =  16\nglobal const colour_graytext =  17\nglobal const colour_btntext =  18\nglobal const colour_inactivecaptiontext =  19\nglobal const colour_btnhighlight =  20\nglobal const colour_3dhilight =  20\nglobal const colour_3ddkshadow =  21\nglobal const colour_3dlight =  22\nglobal const colour_infotext =  23\nglobal const colour_infobk =  24\nglobal const colour_tooltipbk =  24\nglobal const mk_lbutton =  1\nglobal const mk_rbutton =  2\nglobal const mk_shift =  4\nglobal const mk_control =  8\nglobal const mk_mbutton =  16\nglobal const cbm_createdib =  2\nglobal const cbm_init =  4\nglobal const cc_enablehook =  16\nglobal const cc_enabletemplate =  32\nglobal const cc_enabletemplatehandle =  64\nglobal const cc_fullopen =  2\nglobal const cc_preventfullopen =  4\nglobal const cc_rgbinit =  1\nglobal const cc_showhelp =  8\nglobal const cc_solidcolour =  128\nglobal const cf_screenfonts =  1\nglobal const cf_printerfonts =  2\nglobal const cf_effects =  256\nglobal const size_restored =  0\nglobal const size_minimized =  1\nglobal const size_maximized =  2\nglobal const size_maxshow =  3\nglobal const size_maxhide =  4\n!global const gwl_wndproc =  -4\n!global const gwl_hinstance =  -6\n!global const gwl_hwndparent =  -8\n!global const gwl_style =  -16\n!global const gwl_exstyle =  -20\nglobal const gwl_userdata =  -21\nglobal const gwl_id =  -12\nglobal const ta_top =  0\nglobal const ta_left =  0\nglobal const ta_noupdatecp =  0\nglobal const ta_updatecp =  1\nglobal const ta_right =  2\nglobal const ta_centre =  6\nglobal const vta_centre =  6\nglobal const ta_bottom =  8\nglobal const ta_baseline =  24\nglobal const vta_baseline =  24\nglobal const ta_rtlreading =  256\nglobal const aligntop =  0\nglobal const alignbottom =  8\nglobal const alignbaseline =  24\nglobal const aligncentre =  6\nglobal const alignleft =  0\nglobal const alignright =  2\n\nglobal const em_exgetsel =  1076\nglobal const em_exlimittext =  1077\nglobal const em_exlinefromchar =  1078\nglobal const em_exsetsel =  1079\nglobal const em_getparaformat =  1085\nglobal const em_setparaformat =  1095\nglobal const em_streamin =  1097\nglobal const em_streamout =  1098\nglobal const em_gettextrange =  1099\nglobal const em_findtext =  1080\nglobal const em_findtextex =  1103\n\n!global const ttf_idishwnd =  1\n!global const ttf_centretip =  2\n!global const ttf_rtlreading =  4\n!global const ttf_subclass =  16\n!global const ttf_track =  32\n!global const ttf_absolute =  128\n!global const ttf_transparent =  256\n!global const ttf_di_setitem =  32768\n\nglobal const hwnd_top =  0\nglobal const hwnd_bottom =  1\nglobal const hwnd_topmost =  -1\nglobal const hwnd_notopmost =  -2\n\nglobal const normalwind =  0\nglobal const modalwind =  -1\nglobal const dialogwind =  -2\nglobal const minimize =  2\nglobal const maximize =  3\nglobal const shiftmask =  1\nglobal const controlmask =  2\nglobal const altmask =  4\nglobal const windowcolour =  15\nglobal const ps_geometric =  65536\nglobal const ps_cosmetic =  0\nglobal const ps_alternate =  8\nglobal const ps_solid =  0\nglobal const ps_dash =  1\nglobal const ps_dot =  2\nglobal const ps_dashdot =  3\nglobal const ps_dashdotdot =  4\nglobal const ps_null =  5\nglobal const ps_insideframe =  6\nglobal const ps_userstyle =  7\nglobal const ps_endcap_round =  0\nglobal const ps_endcap_square =  256\nglobal const ps_endcap_flat =  512\nglobal const ps_join_bevel =  4096\nglobal const ps_join_miter =  8192\nglobal const ps_join_round =  0\nglobal const ps_style_mask =  15\nglobal const ps_endcap_mask =  3840\nglobal const ps_type_mask =  983040\nglobal const bs_solid =  0\nglobal const bs_hollow =  1\nglobal const bs_null =  1\nglobal const bs_hatched =  2\nglobal const bs_pattern =  3\nglobal const bs_dibpattern =  5\nglobal const bs_dibpatternpt =  6\nglobal const bs_pattern8x8 =  7\nglobal const bs_dibpattern8x8 =  8\nglobal const hs_horizontal =  0\nglobal const hs_vertical =  1\nglobal const hs_fdiagonal =  2\nglobal const hs_bdiagonal =  3\nglobal const hs_cross =  4\nglobal const hs_diagcross =  5\n\n!global const gl_points =  0\n!global const gl_lines =  1\n!global const gl_line_loop =  2\n!global const gl_line_strip =  3\n!global const gl_triangles =  4\n!global const gl_triangle_strip =  5\n!global const gl_triangle_fan =  6\n!global const gl_quads =  7\n!global const gl_quad_strip =  8\n!global const gl_polygon =  9\n\nglobal const spi_getworkarea =  48\n\nproc start=\nend\n\n",
    
(byte*)"!import winmessages\n!import winconsts\n!import gxmisc\n!import winapi\n\n!module winapi\n\nexport var hwapplic=nil\nexport var hwchild=nil\nexport var iswin32\nexport var screendc\n\nexport var nglobalfonts=0\nexport var fonttable::=()\t\t\t![]font handles\nexport var fontdimtable::=()\t\t![]rpoint (width,total line height)\nexport var fontvdimtable::=()\t\t![]rpoint (ascenders, descenders) \n\nproc start\t=\n\tinitdata()\nend\n\nproc initdata=\n!CPL \"---------WINGXLIB\"\n\tiswin32:=(getos()=\"W32\")\n\tscreendc:=getdc(nil)\n\n\tfonttable:=(0,)*20\n\tfontdimtable:=(0,)*20\n\tfontvdimtable:=(0,)*20\n\n\tfonttable[1]:=getstockobject(17)\t!default gui\n\tfonttable[2]:=getstockobject(13)\t!system font\n\tfonttable[3]:=getstockobject(16)\t!system fixed\n\tfonttable[4]:=getstockobject(10)\t!oem fixed\n\tfor i:=1 to 4 do\n\t\tfontdimtable[i]::=ws_point(0,0)\n\t\tfontvdimtable[i]::=ws_point(0,0)\n\tod\n\tnglobalfonts:=4\nend\n\nfunc checkoption(optionnames,optionvalues,name,default=-1)=\n!search for option with given name\n!return value of option, or -1 if not present\n!options (which can be void) will be a list of (name,value) list pairs\n\n\tn:=name in optionnames\n\tif not n then return default fi\n\treturn optionvalues[n]\nend\n\nglobal proc wx_waitmess=\n\twindmsg:=new((iswin32|ws_msg32|ws_msg64))\n\n\tdo\n\t\tif getmessage(&windmsg,nil,0,0)<>0 then\n\t\t\tw:=windmsg.hwnd\n\t\t\tif windmsg.message=wm_keydown and windmsg.wparam=27 then exit fi\n\t\t\tif windmsg.message=wm_timer then CPL \"TIMER!!\" fi\n\t\t\ttranslatemessage(&windmsg)\n\t\t\tdispatchmessage(&windmsg)\n\t\t\tif windmsg.message=wm_close then exit fi\n\t\telse\n\t\t\texit\n\t\tfi\n\tod\nend\n\nglobal func wx_getw(hwnd)=\n!return allwindow-index of window that has been stored into it\n\tn:=getwindowlongptr(hwnd, gwl_userdata)\n\treturn n\nend\n\nglobal proc wx_setw(hwnd,index)=\n!store mm window handle into win32 window\n!index is .gindex (index into allwindows)\n\tsetwindowlongptr(hwnd, gwl_userdata, index)\nend\n\nglobal func wx_gettextwidth(hdc,s)=\n\tsize:=new(ws_point)\n\tgettextextentpoint32(hdc,s,s.len,&size)\n\treturn size.x\nend\n\nglobal func wx_createpopup(?caption,?pos,?dim,?options,owner=nil)=\n!wrapper around win32 createwindow\n!return win32 handle to newly created window\n\tconst gap=40\n\tconst smallestwidth=150\n\n\tif options.isvoid then\n options:=[wf_caption:1,wf_border:wbs_resize]\n\tfi\n\n\tposx:=posy:=-1\n\tdimx:=640\n\tdimy:=480\n\tfcentre:=0\n\tfautopos:=0\n\tfmax:=fdesktop:=0\n\n\tif caption.isvoid then caption:=\"<No Caption>\" fi\n\n\tif dim.defined then\n\t\tif dim.isstring and dim=\"max\" then\n\t\t\tfmax:=1\n\t\telsif dim.isstring and dim=\"desktop\" then\n\t\t\tfdesktop:=1\n\t\telse\n\t\t\tdimx:=dim[1]\n\t\t\tdimy:=dim[2]\n\t\tfi\n\tfi\n\n\tif pos.isvoid or pos=\"cent\" then\n\t\tfcentre:=1\n\telsif pos=\"auto\" then\n\t\tfautopos:=1\n\telsif pos.defined and not pos.isstring then\n\t\tposx:=pos[1]\n\t\tposy:=pos[2]\n\telse\t\t\t\t!check options?\n\t\tabort(\"gxcw bad pos\")\n\tfi\n\n\tbstyle:=bxstyle:=0\n\tnocap:=0\t\t\t!whether to suppress caption\n\n\tframex:=framey:=0\n\n\tcase options{wf_border,wbs_resize}\n\twhen wbs_none then\t\t!no border\n\t\tnocap:=1\n\t\tframex:=0\n\t\tframey:=0\n\twhen wbs_simple then\t\t!single line\n\t\tnocap:=1\n\t\tbstyle:=ws_border\n\t\tframex:=1\n\t\tframey:=1\n\twhen wbs_thick then\t\t!thick line\n\t\tbstyle:=ws_dlgframe\n\t\tfixedframe:=0\n\t\tframex:=getsystemmetrics(sm_cxfixedframe)\n\t\tframey:=getsystemmetrics(sm_cyfixedframe)\n\twhen wbs_resize then\n\t\tbstyle:=ws_sizebox\n\t\tframex:=getsystemmetrics(sm_cxsizeframe)\n\t\tframey:=getsystemmetrics(sm_cysizeframe)\n\twhen wbs_sunken,wbs_sunken2 then\t\t!sunken\n\t\tbstyle:=ws_dlgframe\n\t\tbxstyle:=ws_ex_clientedge\n\t\tframex:=5\n\t\tframey:=5\n\twhen wbs_sunkenrs then\n\t\tbstyle:=ws_sizebox\n\t\tbxstyle:=ws_ex_clientedge\n\t\tframex:=6\n\t\tframey:=6\n\tesac\n\n\tcapheight:=getsystemmetrics(sm_cycaption)\n\tmbheight:=getsystemmetrics(sm_cymenu)\n\n\tstyle:=0\n\texstyle:=0\n\n\tif options{wf_show,1} then\n\t\tstyle ior:=ws_visible\n\tfi\n\n\tmxleft:=framex\n\tmxright:=framey\n\tmytop:=framey+capheight\n\tmybottom:=framey\n\tshowstyle:=sw_shownormal\n\n\thcwmenu:=nil\n\tif options{wf_menu,0}=1 then\n\t\tmytop+:=mbheight\n\t\thcwmenu:=createmenu()\n\t\tappendmenu(hcwmenu,0,998,\"fred\")\n\tfi\n\n\tstyle ior:=ws_clipchildren\n\n\tif nocap or options{wf_caption,1}=0 then\n\t\tmytop-:=capheight\n\t\tstyle ior:=ws_popup\n\tfi\n\n\tif options{wf_iframe,0}=0 then\n\t\tif not fautopos then\n\t\t\tposx-:=mxleft\n\t\t\tposy-:=mytop\n\t\tfi\n\t\tdimx+:=mxleft+mxright\n\t\tdimy+:=mytop+mybottom\n\tfi\n\n\tif fcentre or options{wf_cent,0}=1 then\n\t\tfautopos:=0\n\t\tbox:=new(ws_rect)\n\t\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\n\t\tposx:=box.rightx%2-dimx%2\n\t\tposy:=(box.bottom-box.top)%2-dimy%2+box.top\n\tfi\n\n\tif fmax or options{wf_max,0} then\n\t\tshowstyle:=sw_maximize\n\t\tstyle ior:=ws_maximize\n\tfi\n\n\n\tif options{wf_minmax,1}=1 then\n\t\tstyle ior:=(ws_maximizebox ior ws_minimizebox)\n\n\tfi\n\n\tif options{wf_sysmenu,1}=1 then\n\t\tstyle ior:=ws_sysmenu\n\tfi\n\n\tif fautopos=0 and options{wf_clip,0}=1 then\n\t\tbox:=new(ws_rect)\n\t\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\n\n\t\tif posx<box.leftx+gap then posx:=box.leftx+gap fi\n\n\t\tif posy<box.top+gap then posy:=box.top+gap fi\n\t\tdimxmin:=dimx max smallestwidth\n\t\tif posx+dimxmin>=box.rightx+gap then posx:=box.rightx-gap-dimxmin fi\n\t\tif posy+dimy>=box.bottom+gap then posy:=box.bottom-gap-dimy fi\n\telsif fautopos then\n\t\tposx:=posy:=cw_usedefault\n\tfi\n\n\tif fdesktop or options{wf_desktop,0}=1 then\n\t\tbox:=new(ws_rect)\n\t\tsystemparametersinfoa(spi_getworkarea,0,&box,0)\n\t\tposx:=box.leftx\n\t\tposy:=box.top\n\t\tdimx:=box.rightx-box.leftx\n\t\tdimy:=box.bottom-box.top\n\tfi\n\n\tif options{wf_toolwind,0}=1 then\n\t\texstyle ior:=ws_ex_toolwindow\n\tfi\n\n\tclassname:=\"pcc001\"\n\n\tSTYLE IOR:=WS_VISIBLE\n\n\tstyle ior:=bstyle\n\texstyle ior:=bxstyle\n\n\thwnd:=createwindowex(\n\t\texstyle,\n\t\tclassname,\n\t\tcaption,\n\t\tstyle,\n\t\tposx,posy,\t\t\t!initial position and size\n\t\tdimx,dimy,\n\t\towner,\t\t\t!will be 0 for 1st window, other popups use hwapplic as owner\n\t\thcwmenu,\t\t\t!menu handle\n\t\tnil,\t!proginstance,\t\t!instance handle\n\t\tnil)\t\t\t!creation params\n\n\tif hwnd=nil then\n\t\te:=getlasterror()\n\t\tabort(\"wx:Can't create popup window \"+tostr(e))\n\tfi\n\treturn hwnd\nend\n\nglobal func wx_createcontrol(?pos,?dim,border=wbs_simple,owner)=\n!wrapper around win32 createwindow\n!return win32 handle to newly created window\n\tconst gap=40\n\tconst smallestwidth=150\n\n\tposx:=posy:=0\n\tdimx:=160\n\tdimy:=120\n\n\tif dim.defined then\n\t\tdimx:=dim[1]\n\t\tdimy:=dim[2]\n\tfi\n\n\tif pos.defined then\n\t\tposx:=pos[1]\n\t\tposy:=pos[2]\n\tfi\n\n\tbstyle:=bxstyle:=0\n\n\tcase border\n\twhen wbs_none then\t\t\t!no border\n\twhen wbs_simple then\t\t!single line\n\t\tbstyle:=ws_border\n\telse\n\t\tpcerror(\"createcontrol/bad border \"+wbsnames[border])\n\tesac\n\n\tstyle:=0\n\texstyle:=0\n\n\tstyle ior:=ws_clipchildren\n\n\tclassname:=\"pcc001\"\n\n\tstyle ior:=ws_child\n\tstyle ior:=ws_visible\n\n\tstyle ior:=bstyle\n\texstyle ior:=bxstyle\n\n\thwnd:=createwindowex(\n\t\texstyle,\n\t\tclassname,\n\t\tnil,\n\t\tstyle,\n\t\tposx,posy,\t\t\t!initial position and size\n\t\tdimx,dimy,\n\t\towner,\t\t\t\t!will be 0 for 1st window, other popups use hwapplic as owner\n\t\tnil,\t\t\t\t!menu handle\n\t\tnil,\n\t\tnil)\t\t\t\t!creation params\n\n\tif hwnd=0 then\n\t\te:=getlasterror()\n\t\tabort(\"wx:Can't create child window \"+tostr(e))\n\tfi\n\n\treturn hwnd\nend\n\n",
    
(byte*)"global var winmessagenames=[\n\t(0:\"wm_null\"),\n\t(1:\"wm_create\"),\n\t(2:\"wm_destroy\"),\n\t(3:\"wm_move\"),\n\t(4:\"pgk_menu\"),\n\t(5:\"wm_size\"),\n\t(6:\"wm_activate\"),\n\t(7:\"wm_setfocus\"),\n\t(8:\"wm_killfocus\"),\n\t(9:\"cbn_selendok\"),\n\t(10:\"wm_enable\"),\n\t(11:\"wm_setredraw\"),\n\t(12:\"wm_settext\"),\n\t(13:\"wm_gettext\"),\n\t(14:\"wm_gettextlength\"),\n\t(15:\"wm_paint\"),\n\t(16:\"wm_close\"),\n\t(17:\"wm_queryendsession\"),\n\t(18:\"wm_quit\"),\n\t(19:\"wm_queryopen\"),\n\t(20:\"wm_erasebkgnd\"),\n\t(21:\"wm_syscolorchange\"),\n\t(22:\"wm_endsession\"),\n\t(24:\"wm_showwindow\"),\n\t(26:\"wm_wininichange\"),\n\t(27:\"wm_devmodechange\"),\n\t(28:\"wm_activateapp\"),\n\t(29:\"wm_fontchange\"),\n\t(30:\"wm_timechange\"),\n\t(31:\"wm_cancelmode\"),\n\t(32:\"wm_setcursor\"),\n\t(33:\"wm_mouseactivate\"),\n\t(34:\"wm_childactivate\"),\n\t(35:\"wm_queuesync\"),\n\t(36:\"wm_getminmaxinfo\"),\n\t(38:\"wm_painticon\"),\n\t(39:\"wm_iconerasebkgnd\"),\n\t(40:\"wm_nextdlgctl\"),\n\t(42:\"wm_spoolerstatus\"),\n\t(43:\"wm_drawitem\"),\n\t(44:\"wm_measureitem\"),\n\t(45:\"wm_deleteitem\"),\n\t(46:\"wm_vkeytoitem\"),\n\t(47:\"wm_chartoitem\"),\n\t(48:\"wm_setfont\"),\n\t(49:\"wm_getfont\"),\n\t(50:\"wm_sethotkey\"),\n\t(51:\"wm_gethotkey\"),\n\t(55:\"wm_querydragicon\"),\n\t(57:\"wm_compareitem\"),\n\t(64:\"tbif_size\"),\n\t(65:\"wm_compacting\"),\n\t(70:\"wm_windowposchanging\"),\n\t(71:\"wm_windowposchanged\"),\n\t(72:\"wm_power\"),\n\t(74:\"wm_copydata\"),\n\t(75:\"wm_canceljournal\"),\n\t(78:\"wm_notify\"),\n\t(80:\"wm_inputlangchangerequest\"),\n\t(81:\"wm_inputlangchange\"),\n\t(82:\"wm_tcard\"),\n\t(83:\"wm_help\"),\n\t(84:\"wm_userchanged\"),\n\t(85:\"wm_notifyformat\"),\n\t(123:\"wm_contextmenu\"),\n\t(124:\"wm_stylechanging\"),\n\t(125:\"wm_stylechanged\"),\n\t(126:\"wm_displaychange\"),\n\t(127:\"wm_geticon\"),\n\t(128:\"wm_seticon\"),\n\t(129:\"wm_nccreate\"),\n\t(130:\"wm_ncdestroy\"),\n\t(131:\"wm_nccalcsize\"),\n\t(132:\"wm_nchittest\"),\n\t(133:\"wm_ncpaint\"),\n\t(134:\"wm_ncactivate\"),\n\t(135:\"wm_getdlgcode\"),\n\t(160:\"wm_ncmousemove\"),\n\t(161:\"wm_nclbuttondown\"),\n\t(162:\"wm_nclbuttonup\"),\n\t(163:\"wm_nclbuttondblclk\"),\n\t(164:\"wm_ncrbuttondown\"),\n\t(165:\"wm_ncrbuttonup\"),\n\t(166:\"wm_ncrbuttondblclk\"),\n\t(167:\"wm_ncmbuttondown\"),\n\t(168:\"wm_ncmbuttonup\"),\n\t(169:\"wm_ncmbuttondblclk\"),\n\t(176:\"em_getsel\"),\n\t(177:\"em_setsel\"),\n\t(178:\"em_getrect\"),\n\t(179:\"em_setrect\"),\n\t(180:\"em_setrectnp\"),\n\t(181:\"em_scroll\"),\n\t(182:\"em_linescroll\"),\n\t(183:\"em_scrollcaret\"),\n\t(184:\"em_getmodify\"),\n\t(185:\"em_setmodify\"),\n\t(186:\"em_getlinecount\"),\n\t(187:\"em_lineindex\"),\n\t(188:\"em_sethandle\"),\n\t(189:\"em_gethandle\"),\n\t(190:\"em_getthumb\"),\n\t(193:\"em_linelength\"),\n\t(194:\"em_replacesel\"),\n\t(196:\"em_getline\"),\n\t(197:\"em_setlimittext\"),\n\t(198:\"em_canundo\"),\n\t(199:\"em_undo\"),\n\t(200:\"em_fmtlines\"),\n\t(201:\"em_linefromchar\"),\n\t(203:\"em_settabstops\"),\n\t(204:\"em_setpasswordchar\"),\n\t(205:\"em_emptyundobuffer\"),\n\t(206:\"em_getfirstvisibleline\"),\n\t(207:\"em_setreadonly\"),\n\t(208:\"em_setwordbreakproc\"),\n\t(209:\"em_getwordbreakproc\"),\n\t(210:\"em_getpasswordchar\"),\n\t(211:\"em_setmargins\"),\n\t(212:\"em_getmargins\"),\n\t(213:\"em_getlimittext\"),\n\t(214:\"em_posfromchar\"),\n\t(215:\"em_charfrompos\"),\n\t(224:\"sbm_setpos\"),\n\t(225:\"sbm_getpos\"),\n\t(226:\"sbm_setrange\"),\n\t(227:\"sbm_getrange\"),\n\t(228:\"sbm_enable_arrows\"),\n\t(230:\"sbm_setrangeredraw\"),\n\t(233:\"sbm_setscrollinfo\"),\n\t(234:\"sbm_getscrollinfo\"),\n\t(240:\"bm_getcheck\"),\n\t(241:\"bm_setcheck\"),\n\t(242:\"bm_getstate\"),\n\t(243:\"bm_setstate\"),\n\t(244:\"bm_setstyle\"),\n\t(245:\"bm_click\"),\n\t(246:\"bm_getimage\"),\n\t(247:\"bm_setimage\"),\n\t(255:\"wm_input\"),\n\t(256:\"wm_keydown\"),\n\t(257:\"wm_keyup\"),\n\t(258:\"wm_char\"),\n\t(259:\"wm_deadchar\"),\n\t(260:\"wm_syskeydown\"),\n\t(261:\"wm_syskeyup\"),\n\t(262:\"wm_syschar\"),\n\t(263:\"wm_sysdeadchar\"),\n\t(269:\"wm_ime_startcomposition\"),\n\t(270:\"wm_ime_endcomposition\"),\n\t(271:\"wm_ime_composition\"),\n\t(272:\"wm_initdialog\"),\n\t(273:\"wm_command\"),\n\t(274:\"wm_syscommand\"),\n\t(275:\"wm_timer\"),\n\t(276:\"wm_hscroll\"),\n\t(277:\"wm_vscroll\"),\n\t(278:\"wm_initmenu\"),\n\t(279:\"wm_initmenupopup\"),\n\t(287:\"wm_menuselect\"),\n\t(288:\"wm_menuchar\"),\n\t(289:\"wm_enteridle\"),\n\t(290:\"wm_menurbuttonup\"),\n\t(295:\"wm_changeuistate\"),\n\t(296:\"wm_updateuistate\"),\n\t(297:\"wm_queryuistate\"),\n\t(306:\"wm_ctlcolormsgbox\"),\n\t(307:\"wm_ctlcoloredit\"),\n\t(308:\"wm_ctlcolorlistbox\"),\n\t(309:\"wm_ctlcolorbtn\"),\n\t(310:\"wm_ctlcolordlg\"),\n\t(311:\"wm_ctlcolorscrollbar\"),\n\t(312:\"wm_ctlcolorstatic\"),\n\t(320:\"cb_geteditsel\"),\n\t(321:\"cb_limittext\"),\n\t(322:\"cb_seteditsel\"),\n\t(323:\"cb_addstring\"),\n\t(324:\"cbem_deleteitem\"),\n\t(325:\"cb_dir\"),\n\t(326:\"cb_getcount\"),\n\t(327:\"cb_getcursel\"),\n\t(328:\"cb_getlbtext\"),\n\t(329:\"cb_getlbtextlen\"),\n\t(330:\"cb_insertstring\"),\n\t(331:\"cb_resetcontent\"),\n\t(332:\"cb_findstring\"),\n\t(333:\"cb_selectstring\"),\n\t(334:\"cb_setcursel\"),\n\t(335:\"cb_showdropdown\"),\n\t(336:\"cb_getitemdata\"),\n\t(337:\"cb_setitemdata\"),\n\t(338:\"cb_getdroppedcontrolrect\"),\n\t(339:\"cb_setitemheight\"),\n\t(340:\"cb_getitemheight\"),\n\t(341:\"cb_setextendedui\"),\n\t(342:\"cb_getextendedui\"),\n\t(343:\"cb_getdroppedstate\"),\n\t(344:\"cb_findstringexact\"),\n\t(345:\"cb_setlocale\"),\n\t(346:\"cb_getlocale\"),\n\t(347:\"cb_gettopindex\"),\n\t(348:\"cb_settopindex\"),\n\t(349:\"cb_gethorizontalextent\"),\n\t(350:\"cb_sethorizontalextent\"),\n\t(351:\"cb_getdroppedwidth\"),\n\t(352:\"cb_setdroppedwidth\"),\n\t(353:\"cb_initstorage\"),\n\t(368:\"stm_seticon\"),\n\t(369:\"stm_geticon\"),\n\t(370:\"stm_setimage\"),\n\t(371:\"stm_getimage\"),\n\t(384:\"lb_addstring\"),\n\t(385:\"lb_insertstring\"),\n\t(386:\"lb_deletestring\"),\n\t(387:\"lb_selitemrangeex\"),\n\t(388:\"lb_resetcontent\"),\n\t(389:\"lb_setsel\"),\n\t(390:\"lb_setcursel\"),\n\t(391:\"lb_getsel\"),\n\t(392:\"lb_getcursel\"),\n\t(393:\"lb_gettext\"),\n\t(394:\"lb_gettextlen\"),\n\t(395:\"lb_getcount\"),\n\t(396:\"lb_selectstring\"),\n\t(397:\"lb_dir\"),\n\t(398:\"lb_gettopindex\"),\n\t(399:\"lb_findstring\"),\n\t(400:\"lb_getselcount\"),\n\t(401:\"lb_getselitems\"),\n\t(402:\"lb_settabstops\"),\n\t(403:\"lb_gethorizontalextent\"),\n\t(404:\"lb_sethorizontalextent\"),\n\t(405:\"lb_setcolumnwidth\"),\n\t(406:\"lb_addfile\"),\n\t(407:\"lb_settopindex\"),\n\t(408:\"lb_getitemrect\"),\n\t(409:\"lb_getitemdata\"),\n\t(410:\"lb_setitemdata\"),\n\t(411:\"lb_selitemrange\"),\n\t(412:\"lb_setanchorindex\"),\n\t(413:\"lb_getanchorindex\"),\n\t(414:\"lb_setcaretindex\"),\n\t(415:\"lb_getcaretindex\"),\n\t(416:\"lb_setitemheight\"),\n\t(417:\"lb_getitemheight\"),\n\t(418:\"lb_findstringexact\"),\n\t(421:\"lb_setlocale\"),\n\t(422:\"lb_getlocale\"),\n\t(423:\"lb_setcount\"),\n\t(424:\"lb_initstorage\"),\n\t(425:\"lb_itemfrompoint\"),\n\t(512:\"wm_mousemove\"),\n\t(513:\"wm_lbuttondown\"),\n\t(514:\"wm_lbuttonup\"),\n\t(515:\"wm_lbuttondblclk\"),\n\t(516:\"wm_rbuttondown\"),\n\t(517:\"wm_rbuttonup\"),\n\t(518:\"wm_rbuttondblclk\"),\n\t(519:\"wm_mbuttondown\"),\n\t(520:\"wm_mbuttonup\"),\n\t(521:\"wm_mbuttondblclk\"),\n\t(522:\"wm_mousewheel\"),\n\t(523:\"wm_xbuttondown\"),\n\t(524:\"wm_xbuttonup\"),\n\t(525:\"wm_xbuttondblclk\"),\n\t(528:\"wm_parentnotify\"),\n\t(529:\"wm_entermenuloop\"),\n\t(530:\"wm_exitmenuloop\"),\n\t(531:\"wm_nextmenu\"),\n\t(532:\"wm_sizing\"),\n\t(533:\"wm_capturechanged\"),\n\t(534:\"wm_moving\"),\n\t(536:\"wm_powerbroadcast\"),\n\t(537:\"wm_devicechange\"),\n\t(544:\"wm_mdicreate\"),\n\t(545:\"wm_mdidestroy\"),\n\t(546:\"wm_mdiactivate\"),\n\t(547:\"wm_mdirestore\"),\n\t(548:\"wm_mdinext\"),\n\t(549:\"wm_mdimaximize\"),\n\t(550:\"wm_mditile\"),\n\t(551:\"wm_mdicascade\"),\n\t(552:\"wm_mdiiconarrange\"),\n\t(553:\"wm_mdigetactive\"),\n\t(560:\"wm_mdisetmenu\"),\n\t(561:\"wm_entersizemove\"),\n\t(562:\"wm_exitsizemove\"),\n\t(563:\"wm_dropfiles\"),\n\t(564:\"wm_mdirefreshmenu\"),\n\t(641:\"wm_ime_setcontext\"),\n\t(642:\"wm_ime_notify\"),\n\t(643:\"wm_ime_control\"),\n\t(644:\"wm_ime_compositionfull\"),\n\t(645:\"wm_ime_select\"),\n\t(646:\"wm_ime_char\"),\n\t(656:\"wm_ime_keydown\"),\n\t(657:\"wm_ime_keyup\"),\n\t(673:\"wm_mousehover\"),\n\t(675:\"wm_mouseleave\"),\n\t(689:\"wm_wtssession_change\"),\n\t(768:\"wm_cut\"),\n\t(769:\"wm_copy\"),\n\t(770:\"wm_paste\"),\n\t(771:\"wm_clear\"),\n\t(772:\"wm_undo\"),\n\t(773:\"wm_renderformat\"),\n\t(774:\"wm_renderallformats\"),\n\t(775:\"wm_destroyclipboard\"),\n\t(776:\"wm_drawclipboard\"),\n\t(777:\"wm_paintclipboard\"),\n\t(778:\"wm_vscrollclipboard\"),\n\t(779:\"wm_sizeclipboard\"),\n\t(780:\"wm_askcbformatname\"),\n\t(781:\"wm_changecbchain\"),\n\t(782:\"wm_hscrollclipboard\"),\n\t(783:\"wm_querynewpalette\"),\n\t(784:\"wm_paletteischanging\"),\n\t(785:\"wm_palettechanged\"),\n\t(786:\"wm_hotkey\"),\n\t(791:\"wm_print\"),\n\t(792:\"wm_printclient\"),\n\t(896:\"wm_penwinirst\"),\n\t(911:\"wm_penwinlast\"),\n\t(1024:\"infotipsize\"),\n\t(1025:\"cbem_insertitema\"),\n\t(1026:\"cbem_setimagelist\"),\n\t(1027:\"cbem_getimagelist\"),\n\t(1028:\"cbem_getitema\"),\n\t(1029:\"cbem_setitema\"),\n\t(1030:\"cbem_getcombocontrol\"),\n\t(1031:\"cbem_geteditcontrol\"),\n\t(1032:\"cbem_setexstyle\"),\n\t(1033:\"cbem_getextendedstyle\"),\n\t(1034:\"cbem_haseditchanged\"),\n\t(1035:\"cbem_insertitemw\"),\n\t(1036:\"cbem_setitemw\"),\n\t(1037:\"cbem_getitemw\"),\n\t(1038:\"cbem_setextendedstyle\"),\n\t(1039:\"ttm_getcurrenttoola\"),\n\t(1040:\"ttm_windowfrompoint\"),\n\t(1041:\"ttm_trackactivate\"),\n\t(1042:\"ttm_trackposition\"),\n\t(1043:\"ttm_settipbkcolor\"),\n\t(1044:\"ttm_settiptextcolor\"),\n\t(1045:\"ttm_getdelaytime\"),\n\t(1046:\"ttm_gettipbkcolor\"),\n\t(1047:\"ttm_gettiptextcolor\"),\n\t(1048:\"ttm_setmaxtipwidth\"),\n\t(1049:\"ttm_getmaxtipwidth\"),\n\t(1050:\"ttm_setmargin\"),\n\t(1051:\"ttm_getmargin\"),\n\t(1052:\"ttm_pop\"),\n\t(1053:\"tb_getitemrect\"),\n\t(1054:\"tb_buttonstructsize\"),\n\t(1055:\"tb_setbuttonsize\"),\n\t(1056:\"tb_setbitmapsize\"),\n\t(1057:\"tb_autosize\"),\n\t(1059:\"tb_gettooltips\"),\n\t(1060:\"tb_settooltips\"),\n\t(1061:\"tb_setparent\"),\n\t(1063:\"tb_setrows\"),\n\t(1064:\"tb_getrows\"),\n\t(1065:\"tb_getbitmapflags\"),\n\t(1066:\"tb_setcmdid\"),\n\t(1067:\"tb_changebitmap\"),\n\t(1068:\"tb_getbitmap\"),\n\t(1069:\"tb_getbuttontexta\"),\n\t(1070:\"tb_replacebitmap\"),\n\t(1071:\"tb_setindent\"),\n\t(1072:\"tb_setimagelist\"),\n\t(1073:\"tb_getimagelist\"),\n\t(1074:\"ttm_addtoolw\"),\n\t(1075:\"ttm_deltoolw\"),\n\t(1076:\"ttm_newtoolrectw\"),\n\t(1077:\"ttm_gettoolinfow\"),\n\t(1078:\"ttm_settoolinfow\"),\n\t(1079:\"ttm_hittestw\"),\n\t(1080:\"ttm_gettextw\"),\n\t(1081:\"ttm_updatetiptextw\"),\n\t(1082:\"ttm_enumtoolsw\"),\n\t(1083:\"ttm_getcurrenttoolw\"),\n\t(1084:\"tb_setmaxtextrows\"),\n\t(1085:\"tb_gettextrows\"),\n\t(1086:\"em_getseltext\"),\n\t(1087:\"em_hideselection\"),\n\t(1088:\"em_pastespecial\"),\n\t(1089:\"em_requestresize\"),\n\t(1090:\"em_selectiontype\"),\n\t(1091:\"tb_insertbuttonw\"),\n\t(1092:\"tb_addbuttonsw\"),\n\t(1093:\"tb_hittest\"),\n\t(1094:\"em_setolecallback\"),\n\t(1095:\"em_setparaformat\"),\n\t(1096:\"em_settargetdevice\"),\n\t(1097:\"em_streamin\"),\n\t(1098:\"em_streamout\"),\n\t(1099:\"tb_getbuttontextw\"),\n\t(1100:\"tb_saverestorew\"),\n\t(1101:\"tb_addstringw\"),\n\t(1102:\"em_getoptions\"),\n\t(1103:\"tb_getinsertmark\"),\n\t(1104:\"tb_setinsertmark\"),\n\t(1105:\"tb_insertmarkhittest\"),\n\t(1106:\"tb_movebutton\"),\n\t(1107:\"tb_getmaxsize\"),\n\t(1108:\"tb_setextendedstyle\"),\n\t(1109:\"tb_getextendedstyle\"),\n\t(1110:\"tb_getpadding\"),\n\t(1111:\"tb_setpadding\"),\n\t(1112:\"tb_setinsertmarkcolor\"),\n\t(1113:\"tb_getinsertmarkcolor\"),\n\t(1114:\"tb_mapacceleratorw\"),\n\t(1124:\"em_setpunctuation\"),\n\t(1125:\"wm_choosefont_setlogfont\"),\n\t(1126:\"wm_choosefont_setflags\"),\n\t(1127:\"udm_setpos\"),\n\t(1128:\"udm_getpos\"),\n\t(1129:\"udm_setbuddy\"),\n\t(1130:\"udm_getbuddy\"),\n\t(1131:\"udm_setaccel\"),\n\t(1132:\"udm_getaccel\"),\n\t(1133:\"udm_setbase\"),\n\t(1134:\"udm_getbase\"),\n\t(1135:\"psm_settitlea\"),\n\t(1136:\"psm_setwizbuttons\"),\n\t(1137:\"psm_pressbutton\"),\n\t(1138:\"psm_setcurselid\"),\n\t(1139:\"psm_setfinishtexta\"),\n\t(1140:\"psm_gettabcontrol\"),\n\t(1141:\"psm_isdialogmessage\"),\n\t(1142:\"psm_getcurrentpagehwnd\"),\n\t(1144:\"psm_settitlew\"),\n\t(1145:\"psm_setfinishtextw\"),\n\t(1157:\"dl_begindrag\"),\n\t(1158:\"dl_dragging\"),\n\t(1159:\"dl_dropped\"),\n\t(1160:\"dl_canceldrag\"),\n\t(1280:\"en_errspace\"),\n\t(1281:\"en_maxtext\"),\n\t(1537:\"en_hscroll\"),\n\t(1538:\"en_vscroll\"),\n\t(1792:\"en_msgfilter\"),\n\t(1793:\"en_requestresize\"),\n\t(1794:\"en_selchange\"),\n\t(1795:\"en_dropfiles\"),\n\t(1796:\"en_protected\"),\n\t(1797:\"en_correcttext\"),\n\t(1798:\"en_stopnoundo\"),\n\t(1799:\"en_imechange\"),\n\t(1800:\"en_saveclipboard\"),\n\t(1801:\"en_oleopfailed\"),\n\t(4096:\"lvm_getbkcolor\"),\n\t(4097:\"lvm_setbkcolor\"),\n\t(4098:\"lvm_getimagelist\"),\n\t(4099:\"lvm_setimagelist\"),\n\t(4100:\"lvm_getitemcount\"),\n\t(4101:\"lvm_getitema\"),\n\t(4102:\"lvm_setitema\"),\n\t(4103:\"lvm_insertitema\"),\n\t(4104:\"lvm_deleteitem\"),\n\t(4105:\"lvm_deleteallitems\"),\n\t(4106:\"lvm_getcallbackmask\"),\n\t(4107:\"lvm_setcallbackmask\"),\n\t(4108:\"lvm_getnextitem\"),\n\t(4109:\"lvm_finditema\"),\n\t(4110:\"lvm_getitemrect\"),\n\t(4111:\"lvm_setitemposition\"),\n\t(4112:\"lvm_getitemposition\"),\n\t(4113:\"lvm_getstringwidtha\"),\n\t(4114:\"lvm_hittest\"),\n\t(4115:\"lvm_ensurevisible\"),\n\t(4116:\"lvm_scroll\"),\n\t(4117:\"lvm_redrawitems\"),\n\t(4118:\"lvm_arrange\"),\n\t(4119:\"lvm_editlabela\"),\n\t(4120:\"lvm_geteditcontrol\"),\n\t(4121:\"lvm_getcolumna\"),\n\t(4122:\"lvm_setcolumna\"),\n\t(4123:\"lvm_insertcolumna\"),\n\t(4124:\"lvm_deletecolumn\"),\n\t(4125:\"lvm_getcolumnwidth\"),\n\t(4126:\"lvm_setcolumnwidth\"),\n\t(4129:\"lvm_createdragimage\"),\n\t(4130:\"lvm_getviewrect\"),\n\t(4131:\"lvm_gettextcolor\"),\n\t(4132:\"lvm_settextcolor\"),\n\t(4133:\"lvm_gettextbkcolor\"),\n\t(4134:\"lvm_settextbkcolor\"),\n\t(4135:\"lvm_gettopindex\"),\n\t(4136:\"lvm_getcountperpage\"),\n\t(4137:\"lvm_getorigin\"),\n\t(4138:\"lvm_update\"),\n\t(4139:\"lvm_setitemstate\"),\n\t(4140:\"lvm_getitemstate\"),\n\t(4141:\"lvm_getitemtexta\"),\n\t(4142:\"lvm_setitemtexta\"),\n\t(4143:\"lvm_setitemcount\"),\n\t(4144:\"lvm_sortitems\"),\n\t(4145:\"lvm_setitemposition32\"),\n\t(4146:\"lvm_getselectedcount\"),\n\t(4147:\"lvm_getitemspacing\"),\n\t(4148:\"lvm_getisearchstringa\"),\n\t(4171:\"lvm_getitemw\"),\n\t(4172:\"lvm_setitemw\"),\n\t(4173:\"lvm_insertitemw\"),\n\t(4179:\"lvm_finditemw\"),\n\t(4183:\"lvm_getstringwidthw\"),\n\t(4191:\"lvm_getcolumnw\"),\n\t(4192:\"lvm_setcolumnw\"),\n\t(4193:\"lvm_insertcolumnw\"),\n\t(4211:\"lvm_getitemtextw\"),\n\t(4212:\"lvm_setitemtextw\"),\n\t(4213:\"lvm_getisearchstringw\"),\n\t(4214:\"lvm_editlabelw\"),\n\t(4352:\"tvm_insertitema\"),\n\t(4353:\"tvm_deleteitem\"),\n\t(4354:\"tvm_expand\"),\n\t(4356:\"tvm_getitemrect\"),\n\t(4357:\"tvm_getcount\"),\n\t(4358:\"tvm_getindent\"),\n\t(4359:\"tvm_setindent\"),\n\t(4360:\"tvm_getimagelist\"),\n\t(4361:\"tvm_setimagelist\"),\n\t(4362:\"tvm_getnextitem\"),\n\t(4363:\"tvm_selectitem\"),\n\t(4364:\"tvm_getitema\"),\n\t(4365:\"tvm_setitema\"),\n\t(4366:\"tvm_editlabela\"),\n\t(4367:\"tvm_geteditcontrol\"),\n\t(4368:\"tvm_getvisiblecount\"),\n\t(4369:\"tvm_hittest\"),\n\t(4370:\"tvm_createdragimage\"),\n\t(4371:\"tvm_sortchildren\"),\n\t(4372:\"tvm_ensurevisible\"),\n\t(4373:\"tvm_sortchildrencb\"),\n\t(4374:\"tvm_endeditlabelnow\"),\n\t(4375:\"tvm_getisearchstringa\"),\n\t(4402:\"tvm_insertitemw\"),\n\t(4414:\"tvm_getitemw\"),\n\t(4415:\"tvm_setitemw\"),\n\t(4416:\"tvm_getisearchstringw\"),\n\t(4417:\"tvm_editlabelw\"),\n\t(4608:\"hdm_getitemcount\"),\n\t(4609:\"hdm_insertitema\"),\n\t(4610:\"hdm_deleteitem\"),\n\t(4611:\"hdm_getitema\"),\n\t(4612:\"hdm_setitema\"),\n\t(4613:\"hdm_layout\"),\n\t(4614:\"hdm_hittest\"),\n\t(4618:\"hdm_insertitemw\"),\n\t(4619:\"hdm_getitemw\"),\n\t(4620:\"hdm_setitemw\"),\n\t(4864:\"tcm_first\"),\n\t(4866:\"tcm_getimagelist\"),\n\t(4867:\"tcm_setimagelist\"),\n\t(4868:\"tcm_getitemcount\"),\n\t(4869:\"tcm_getitema\"),\n\t(4870:\"tcm_setitema\"),\n\t(4871:\"tcm_insertitema\"),\n\t(4872:\"tcm_deleteitem\"),\n\t(4873:\"tcm_deleteallitems\"),\n\t(4874:\"tcm_getitemrect\"),\n\t(4875:\"tcm_getcursel\"),\n\t(4876:\"tcm_setcursel\"),\n\t(4877:\"tcm_hittest\"),\n\t(4878:\"tcm_setitemextra\"),\n\t(4904:\"tcm_adjustrect\"),\n\t(4905:\"tcm_setitemsize\"),\n\t(4906:\"tcm_removeimage\"),\n\t(4907:\"tcm_setpadding\"),\n\t(4908:\"tcm_getrowcount\"),\n\t(4909:\"tcm_gettooltips\"),\n\t(4910:\"tcm_settooltips\"),\n\t(4911:\"tcm_getcurfocus\"),\n\t(4912:\"tcm_setcurfocus\"),\n\t(4924:\"tcm_getitemw\"),\n\t(4925:\"tcm_setitemw\"),\n\t(4926:\"tcm_insertitemw\"),\n\t(5120:\"pgm_first\"),\n\t(8192:\"ccm_first\")]\n\nproc start=\nend\n",
    (byte*)"export enumdata optionnames =\n\t(wf_border,\t\t$),\t\t! wbs_simple\n\t(wf_resize,\t\t$),\t\t! 0\n\t(wf_hscroll,\t$),\t\t! 0\n\t(wf_vscroll,\t$),\t\t! 0\n\t(wf_menu,\t\t$),\t\t! 0\n\t(wf_caption,\t$),\t\t! 1\n\t(wf_max,\t\t$),\t\t! 0\n\t(wf_minmax,\t\t$),\t\t! 1\n\t(wf_sysmenu,\t$),\t\t! 1\n\t(wf_desktop,\t$),\t\t! 0\n\t(wf_clip,\t\t$),\t\t! 0\n\t(wf_show,\t\t$),\t\t!\n\t(wf_iframe,\t\t$),\t\t! 1\n\t(wf_cent,\t\t$),\t\t!\n\t(wf_toolwind,\t$)\t\t!\nend\n\n!Windows border styles, used for pop-up windows. Could also be used for\n!some child windows\nexport enumdata wbsnames=\n\t(wbs_none=0,$),\n\t(wbs_simple,$),\n\t(wbs_thick,$),\n\t(wbs_resize,$),\n\t(wbs_sunken,$),\n\t(wbs_sunken2,$),\n\t(wbs_sunkenrs,$),\n\t(wbs_dummy,$)\nend\n",
    
(byte*)"\nexport var daynames=(\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\")\n\nexport var Monthnames=(\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\n\t\t\"August\",\"September\",\"October\",\"November\",\"December\")\n\nexport var days=(31,28,31, 30,31,30, 31,31,30, 31,30,31)\n\nexport record rdate=\n\tvar day,month,year\nend\n\nexport record rdatetime = \n\tvar\tday\n\tvar\tmonth\n\tvar\tyear\n\tvar\thour\n\tvar\tminute\n\tvar\tsecond\n\tvar\tmilliseconds\n\tvar\tdayofweek\nend\n\n!proc start=\n!end\n!\n!proc main=\n!end\n\nexport func makedatetime(d,m,y, h=0, minute=0, s=0)=\n\n\td:=rdatetime(d,m,y, h,minute,s,0,0)\n\td.dayofweek:=getdow(d)\n\treturn d\nend\n\nexport proc setdow(&d)=\n\td.dayofweek:=getdow(d)\nend\n\nexport func strdate(d,sep=\"-\")=\n!return leftstr(daynames[d.dayofweek],3)+\" \"+tostr(d.day)+sep+leftstr(monthnames[d.month],3)+sep+tostr(d.year)\n\treturn tostr(d.day)+sep+leftstr(monthnames[d.month],3)+sep+tostr(d.year)\nend\n\nexport func strtime(d,sep=\":\")=\n\treturn tostr(d.hour)+sep+tostr(d.minute,\"z2\")+sep+tostr(d.second,\"z2\")\nend\n\nexport func strdow(d,n=0)=\n\tif n then\n\t\treturn leftstr(daynames[d.dayofweek],n)\n\telse\n\t\treturn daynames[d.dayofweek]\n\tfi\nend\n\nexport func strdatetime(d,dsep=\"-\",tsep=\":\")=\n\treturn strdate(d,dsep)+\" \"+strtime(d,tsep)\nend\n\nexport func parsedate(s,defdate)=\n!parse string s into a new date record\n!def = default date to work from, eg. for missing year\n!return date record obtained, or 0 if error\n\n\tday:=defdate.day\n\tmonth:=defdate.month\n\tyear:=defdate.year\n\tif s.[1]=\" \" then s:=rightstr(s,-1) fi\n\n\tsepset:=[' ', '-', '/', '.']\n\n\tseppos:=0\n\tfor i:=1 to s.len do if s.[i] in sepset then seppos:=i; exit fi od\n\n\tif not seppos then\t\t!day only\n\t\tday:=strtoval(s)\n\t\tgoto gotday\n\tfi\n\tday:=strtoval(leftstr(s,seppos-1))\n\n\ts:=rightstr(s,-seppos)\t\t!month and possible year\n\tseppos:=0\n\tfor i:=1 to s.len do if s.[i] in sepset then seppos:=i; exit fi od\n\n\tif seppos then\n\t\tmonthstr:=leftstr(s,seppos-1)\n\t\tyearstr:=rightstr(s,s.len-seppos)\n\telse\n\t\tmonthstr:=s\n\t\tyearstr:=\"\"\n\tfi\n\n\tif asc(leftstr(monthstr)) in ['0'..'9'] then\t!numeric month\n\t\tmonth:=strtoval(monthstr)\n\t\tif month<1 or month>12 then\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\tmonth:=0\n\t\tfor i:=1 to 12 do\n\t\t\tif convlc(leftstr(monthnames[i],3))=convlc(leftstr(monthstr,3)) then\n\t\t\t\tmonth:=i\n\t\t\t\texit\n\t\t\tfi\n\t\tod\n\t\tif not month then\n\t\t\treturn 0\n\t\tfi\n\tfi\n\n\tif yearstr<>\"\" then\n\t\tyear:=strtoval(yearstr)\n\t\tif year<200 then\n\t\t\tif year in [00..89] then\n\t\t\t\tyear+:=2000\n\t\t\telse\n\t\t\t\tyear+:=1900\n\t\t\tfi\n\t\tfi\n\tfi\n\ngotday:\n!check the date, rather than correct using addday(d,0)\n\tdd:=days[month] \n\tif leapyear(year) and month=2 then dd+:=1 fi\n\tif day<1 or day>dd then return 0 fi\n\tif year<1990 or year>2089 then return 0 fi\n\treturn makedatetime(day,month,year)\nend\n\nexport func leapyear(y)=\n!return true if y (eg. 1994) is a leap year\n\treturn (y-1900) rem 4=0\nend\n\nexport func getdow(d)=\n!return day of week for given date, returning 1..7 (monday..sunday)\n\treturn ((getday(d)-1) rem 7)+1\nend\n\nexport func getday(d)=\n!return day number for date d, measured from 1.1.90\n\tday:=0\n\tfor i:=1990 to d.year-1 do\n\t\tday+:=(leapyear(i)|366|365)\n\tod\n\n\tfor i:=1 to d.month-1 do\n\t\tday+:=(i=2|(leapyear(d.year)|29|28)|days[i])\n\tod\n\tday+:=d.day\n\treturn day\nend\n\nexport func getdays(m,y)=\n!return no. of days in month m, for year y\n\tif leapyear(y) and m=2 then return 29 fi\n\treturn days[m]\nend\n\nexport func getmonthname(m,?n)=\n\tif not m.isint then\n\t\tm:=m.month\n\tfi\n\tm:=monthnames[m]\n\tif n.defined then m:=leftstr(m,n) fi\n\treturn m\nend\n\nexport func getdayname(d,?n)=\n\tif not d.isint then\n\t\td:=getdow(d)\n\tfi\n\td:=daynames[d]\n\tif n.defined then d:=leftstr(d,n) fi\n\treturn d\nend\n\nexport func addday(d0,i)=\n\td:=d0\n\tif i>0 then\n\t\tto i do\n\t\t\t++d.day\n\t\t\tif d.day>getdays(d.month,d.year) then\n\t\t\t\td.day:=1\n\t\t\t\t++d.month\n\t\t\t\tif d.month>12 then\n\t\t\t\t\td.month:=1\n\t\t\t\t\t++d.year\n\t\t\t\tfi\n\t\t\tfi\n\t\tod\n\telse\n\t\tto -i do\n\t\t\t--d.day\n\t\t\tif d.day<1 then\n\t\t\t\t--d.month\n\t\t\t\tif d.month<1 then\n\t\t\t\t\td.month:=12\n\t\t\t\t\t--d.year\n\t\t\t\tfi\n\t\t\t\td.day:=getdays(d.month,d.year)\n\t\t\tfi\n\t\tod\n\tfi\n\n!do checking\n\tif d.year<1990 then d:=makedatetime(1,1,1990) fi\n\tif d.year>2089 then d:=makedatetime(31,12,2089) fi\n\n\tdd:=getdays(d.month,d.year)\n\tif leapyear(d.year) and d.month=2 then dd+:=1 fi\n\tif d.day<1 then d.day:=1 fi\n\tif d.day>dd then d.day:=dd fi\n\tsetdow(d)\n\treturn d\nend\n\nexport func getdatetime=\n\ttm:=getsystime()\n\n\treturn rdatetime(tm.day,tm.month,tm.year,\n\t\t\ttm.hour, tm.minute, tm.second, tm.milliseconds,tm.dayofweek)\nend\n\nexport func getsystime=\n\ttm:=new(ws_systemtime)\n\tgetsystemtime(&tm)\n\n\tif tm.dayofweek=0 then\n\t\ttm.dayofweek:=7\n\tfi\n\n\treturn tm\nend\n"
};
static byte qq_syslibs$syslibfileno[12];
static u8 *  qq_tables$stdtypenames[43] = {
    (byte*)"void",
    (byte*)"int",
    (byte*)"word",
    (byte*)"real",
    (byte*)"decimal",
    (byte*)"bool",
    (byte*)"range",
    (byte*)"enum",
    (byte*)"set",
    (byte*)"dict",
    (byte*)"vector",
    (byte*)"bits",
    (byte*)"string",
    (byte*)"list",
    (byte*)"array",
    (byte*)"record",
    (byte*)"struct",
    (byte*)"refvar",
    (byte*)"refbit",
    (byte*)"type",
    (byte*)"operator",
    (byte*)"retaddr",
    (byte*)"except",
    (byte*)"symbol",
    (byte*)"refpack",
    (byte*)"iter",
    (byte*)"x2",
    (byte*)"tvar",
    (byte*)"i8",
    (byte*)"i16",
    (byte*)"i32",
    (byte*)"u8",
    (byte*)"u16",
    (byte*)"u32",
    (byte*)"r32",
    (byte*)"u1",
    (byte*)"u2",
    (byte*)"u4",
    (byte*)"packstrc",
    (byte*)"packstrz",
    (byte*)"stringz",
    (byte*)"refproc",
    (byte*)"slice"
};
static byte qq_tables$stdtypewidths[43] = {
    (u8)0u,
    (u8)64u,
    (u8)64u,
    (u8)64u,
    (u8)0u,
    (u8)64u,
    (u8)64u,
    (u8)64u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)64u,
    (u8)128u,
    (u8)64u,
    (u8)64u,
    (u8)0u,
    (u8)0u,
    (u8)64u,
    (u8)64u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)8u,
    (u8)16u,
    (u8)32u,
    (u8)8u,
    (u8)16u,
    (u8)32u,
    (u8)32u,
    (u8)1u,
    (u8)2u,
    (u8)4u,
    (u8)0u,
    (u8)0u,
    (u8)64u,
    (u8)64u,
    (u8)0u
};
static byte qq_tables$stdvar[43] = {
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static byte qq_tables$stdpack[43] = {
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u
};
static byte qq_tables$stdmvar[43] = {
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u
};
static byte qq_tables$stdffi[43] = {
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u
};
static u8 *  qq_tables$jtagnames[209] = {
    (byte*)"jnone",
    (byte*)"jlabeldef",
    (byte*)"jassign",
    (byte*)"jdeepcopy",
    (byte*)"jkeyword",
    (byte*)"jkeyvalue",
    (byte*)"jdocstring",
    (byte*)"joperator",
    (byte*)"jblock",
    (byte*)"jif",
    (byte*)"jselect",
    (byte*)"jwhenthen",
    (byte*)"jcase",
    (byte*)"jdocase",
    (byte*)"jswitch",
    (byte*)"jdoswitch",
    (byte*)"jrecase",
    (byte*)"jforup",
    (byte*)"jforupx",
    (byte*)"jfordown",
    (byte*)"jfordownx",
    (byte*)"jforall",
    (byte*)"jforallrev",
    (byte*)"jforeach",
    (byte*)"jdo",
    (byte*)"jdoonce",
    (byte*)"jto",
    (byte*)"jwhile",
    (byte*)"jrepeat",
    (byte*)"jtry",
    (byte*)"jexcept",
    (byte*)"jraise",
    (byte*)"jcall",
    (byte*)"jcallhost",
    (byte*)"jnil",
    (byte*)"jpnil",
    (byte*)"jswap",
    (byte*)"jgoto",
    (byte*)"jstop",
    (byte*)"jreturn",
    (byte*)"jyield",
    (byte*)"jtypeconst",
    (byte*)"jeval",
    (byte*)"jconvert",
    (byte*)"jtypepun",
    (byte*)"jmap",
    (byte*)"jcmpchain",
    (byte*)"jname",
    (byte*)"jsymbol",
    (byte*)"jhostname",
    (byte*)"jintconst",
    (byte*)"jwordconst",
    (byte*)"jint128const",
    (byte*)"jword128const",
    (byte*)"jrealconst",
    (byte*)"jboolconst",
    (byte*)"jenumconst",
    (byte*)"jstringconst",
    (byte*)"jstrinclude",
    (byte*)"jdot",
    (byte*)"jindex",
    (byte*)"jdotindex",
    (byte*)"jkeyindex",
    (byte*)"jredo",
    (byte*)"jnext",
    (byte*)"jexit",
    (byte*)"jptr",
    (byte*)"jaddrof",
    (byte*)"jptrto",
    (byte*)"jnull",
    (byte*)"jprint",
    (byte*)"jprintln",
    (byte*)"jfprint",
    (byte*)"jfprintln",
    (byte*)"jsprint",
    (byte*)"jsfprint",
    (byte*)"jnogap",
    (byte*)"jspace",
    (byte*)"jfmtitem",
    (byte*)"jread",
    (byte*)"jreadln",
    (byte*)"jnew",
    (byte*)"jdecimal",
    (byte*)"jincr",
    (byte*)"jdecr",
    (byte*)"jincrload",
    (byte*)"jdecrload",
    (byte*)"jloadincr",
    (byte*)"jloaddecr",
    (byte*)"jneg",
    (byte*)"jabs",
    (byte*)"jnotl",
    (byte*)"jinot",
    (byte*)"jistruel",
    (byte*)"jasc",
    (byte*)"jchr",
    (byte*)"jsqrt",
    (byte*)"jsqr",
    (byte*)"jsin",
    (byte*)"jcos",
    (byte*)"jtan",
    (byte*)"jasin",
    (byte*)"jacos",
    (byte*)"jatan",
    (byte*)"jln",
    (byte*)"jlog",
    (byte*)"jlg",
    (byte*)"jexp",
    (byte*)"jround",
    (byte*)"jfloor",
    (byte*)"jceil",
    (byte*)"jfract",
    (byte*)"jfmod",
    (byte*)"jsign",
    (byte*)"jnegto",
    (byte*)"jabsto",
    (byte*)"jnotlto",
    (byte*)"jinotto",
    (byte*)"jlen",
    (byte*)"jlwb",
    (byte*)"jupb",
    (byte*)"jbounds",
    (byte*)"jboundsx",
    (byte*)"jbitwidth",
    (byte*)"jbytesize",
    (byte*)"jtype",
    (byte*)"jelemtype",
    (byte*)"jbasetype",
    (byte*)"jusertype",
    (byte*)"jdictitems",
    (byte*)"jisfound",
    (byte*)"jminvalue",
    (byte*)"jmaxvalue",
    (byte*)"jisint",
    (byte*)"jisreal",
    (byte*)"jisstring",
    (byte*)"jisrange",
    (byte*)"jisnumber",
    (byte*)"jislist",
    (byte*)"jisrecord",
    (byte*)"jispointer",
    (byte*)"jisarray",
    (byte*)"jismutable",
    (byte*)"jisset",
    (byte*)"jisvoid",
    (byte*)"jisdef",
    (byte*)"jisequal",
    (byte*)"jodd",
    (byte*)"jeven",
    (byte*)"jadd",
    (byte*)"jsub",
    (byte*)"jmul",
    (byte*)"jdiv",
    (byte*)"jidiv",
    (byte*)"jirem",
    (byte*)"jidivrem",
    (byte*)"jiand",
    (byte*)"jior",
    (byte*)"jixor",
    (byte*)"jshl",
    (byte*)"jshr",
    (byte*)"jin",
    (byte*)"jnotin",
    (byte*)"jinx",
    (byte*)"jinrev",
    (byte*)"jandl",
    (byte*)"jorl",
    (byte*)"jeq",
    (byte*)"jne",
    (byte*)"jlt",
    (byte*)"jle",
    (byte*)"jge",
    (byte*)"jgt",
    (byte*)"jmin",
    (byte*)"jmax",
    (byte*)"jconcat",
    (byte*)"jappend",
    (byte*)"jpower",
    (byte*)"jatan2",
    (byte*)"jaddto",
    (byte*)"jsubto",
    (byte*)"jmulto",
    (byte*)"jdivto",
    (byte*)"jidivto",
    (byte*)"jandlto",
    (byte*)"jorlto",
    (byte*)"jiandto",
    (byte*)"jiorto",
    (byte*)"jixorto",
    (byte*)"jshlto",
    (byte*)"jshrto",
    (byte*)"jminto",
    (byte*)"jmaxto",
    (byte*)"jconcatto",
    (byte*)"jappendto",
    (byte*)"jmakerange",
    (byte*)"jmakerangelen",
    (byte*)"jmakelist",
    (byte*)"jmakeset",
    (byte*)"jmakedict",
    (byte*)"jcvlineno",
    (byte*)"jcvstrlineno",
    (byte*)"jcvmodulename",
    (byte*)"jcvfilename",
    (byte*)"jcvfunction",
    (byte*)"jcvdate",
    (byte*)"jcvtime",
    (byte*)"jcvversion",
    (byte*)"jcvpclversion"
};
static u8 *  qq_tables$jshortnames[209] = {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    (byte*)"++",
    (byte*)"--",
    0,
    0,
    0,
    0,
    (byte*)"-",
    (byte*)"abs",
    (byte*)"not",
    (byte*)"inot",
    (byte*)"istrue",
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    (byte*)"+",
    (byte*)"-",
    (byte*)"*",
    (byte*)"/",
    (byte*)"%",
    (byte*)"rem",
    0,
    (byte*)"iand",
    (byte*)"ior",
    (byte*)"ixor",
    (byte*)"<<",
    (byte*)">>",
    (byte*)"in",
    (byte*)"notin",
    (byte*)"inx",
    0,
    (byte*)"and",
    (byte*)"or",
    (byte*)"=",
    (byte*)"<>",
    (byte*)"<",
    (byte*)"<=",
    (byte*)">=",
    (byte*)">",
    (byte*)"min",
    (byte*)"max",
    0,
    0,
    (byte*)"**",
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
static byte qq_tables$jflags[209] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)2u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
static i16 qq_tables$jpclcodes[209] = {
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)224,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)93,
    (i16)98,
    (i16)92,
    (i16)97,
    (i16)101,
    (i16)102,
    (i16)103,
    (i16)104,
    (i16)105,
    (i16)106,
    (i16)107,
    (i16)108,
    (i16)109,
    (i16)111,
    (i16)112,
    (i16)113,
    (i16)114,
    (i16)115,
    (i16)116,
    (i16)118,
    (i16)119,
    (i16)120,
    (i16)121,
    (i16)122,
    (i16)123,
    (i16)124,
    (i16)125,
    (i16)126,
    (i16)117,
    (i16)127,
    (i16)128,
    (i16)130,
    (i16)129,
    (i16)131,
    (i16)132,
    (i16)133,
    (i16)134,
    (i16)135,
    (i16)136,
    (i16)137,
    (i16)138,
    (i16)139,
    (i16)140,
    (i16)141,
    (i16)142,
    (i16)143,
    (i16)144,
    (i16)145,
    (i16)146,
    (i16)147,
    (i16)148,
    (i16)149,
    (i16)150,
    (i16)151,
    (i16)152,
    (i16)153,
    (i16)154,
    (i16)155,
    (i16)156,
    (i16)157,
    (i16)158,
    (i16)159,
    (i16)162,
    (i16)163,
    (i16)164,
    (i16)165,
    (i16)166,
    (i16)167,
    (i16)168,
    (i16)169,
    (i16)170,
    (i16)171,
    (i16)172,
    (i16)173,
    (i16)174,
    (i16)175,
    (i16)176,
    (i16)177,
    (i16)178,
    (i16)0,
    (i16)179,
    (i16)180,
    (i16)181,
    (i16)182,
    (i16)183,
    (i16)184,
    (i16)185,
    (i16)186,
    (i16)187,
    (i16)188,
    (i16)189,
    (i16)190,
    (i16)191,
    (i16)192,
    (i16)193,
    (i16)194,
    (i16)195,
    (i16)196,
    (i16)197,
    (i16)198,
    (i16)199,
    (i16)200,
    (i16)201,
    (i16)202,
    (i16)203,
    (i16)204,
    (i16)205,
    (i16)206,
    (i16)207,
    (i16)208,
    (i16)85,
    (i16)86,
    (i16)79,
    (i16)84,
    (i16)87,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0
};
static i16 qq_tables$jtocodes[209] = {
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)114,
    (i16)115,
    (i16)116,
    (i16)117,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)179,
    (i16)180,
    (i16)181,
    (i16)182,
    (i16)183,
    (i16)0,
    (i16)0,
    (i16)186,
    (i16)187,
    (i16)188,
    (i16)189,
    (i16)190,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)184,
    (i16)185,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)191,
    (i16)192,
    (i16)193,
    (i16)194,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0
};
static byte qq_tables$jhasvalue[209] = {
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)0u,
    (u8)2u,
    (u8)0u,
    (u8)2u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u
};
static u8 *  qq_tables$fflangnames[6] = {(byte*)"noff",(byte*)"windowsff",(byte*)"clangff",(byte*)"mlangff",(byte*)"callbackff",(byte*)"dummyff"};
static u8 *  qq_tables$opndnames[17] = {
    (byte*)"cnone",
    (byte*)"cmemory",
    (byte*)"cframe",
    (byte*)"cproc",
    (byte*)"cdllproc",
    (byte*)"cgenfield",
    (byte*)"clabel",
    (byte*)"cint",
    (byte*)"cword",
    (byte*)"creal",
    (byte*)"crange",
    (byte*)"cstring",
    (byte*)"cstringz",
    (byte*)"ctype",
    (byte*)"csymbol",
    (byte*)"coperator",
    (byte*)"?"
};
static u8 *  qq_tables$pclnames[273] = {
    (byte*)"kzero",
    (byte*)"knop",
    (byte*)"kskip",
    (byte*)"kprocdef",
    (byte*)"kprocentry",
    (byte*)"kprocend",
    (byte*)"kendmodule",
    (byte*)"kcomment",
    (byte*)"klabeldef",
    (byte*)"kpushm",
    (byte*)"kpushf",
    (byte*)"kpushmref",
    (byte*)"kpushfref",
    (byte*)"kpopm",
    (byte*)"kpopf",
    (byte*)"kstorem",
    (byte*)"kstoref",
    (byte*)"khostname",
    (byte*)"kpushci",
    (byte*)"kpushcu",
    (byte*)"kpushvoid",
    (byte*)"kpushnil",
    (byte*)"kpushcr",
    (byte*)"kpushcn",
    (byte*)"kpushtrue",
    (byte*)"kpushfalse",
    (byte*)"kpushcs",
    (byte*)"kpushenum",
    (byte*)"kpusht",
    (byte*)"kpushsymbol",
    (byte*)"kpushoperator",
    (byte*)"kpushptr",
    (byte*)"kpopptr",
    (byte*)"kzpopm",
    (byte*)"kzpopf",
    (byte*)"kdupl",
    (byte*)"kcopy",
    (byte*)"kswap",
    (byte*)"kconvrefpack",
    (byte*)"kjump",
    (byte*)"kjumpptr",
    (byte*)"kjumptrue",
    (byte*)"kjumpfalse",
    (byte*)"kjumpeq",
    (byte*)"kjumpne",
    (byte*)"kjumplt",
    (byte*)"kjumple",
    (byte*)"kjumpge",
    (byte*)"kjumpgt",
    (byte*)"kjumptesteq",
    (byte*)"kjumptestne",
    (byte*)"kjumplabel",
    (byte*)"kswitch",
    (byte*)"ktom",
    (byte*)"ktof",
    (byte*)"kformci",
    (byte*)"kforfci",
    (byte*)"kformm",
    (byte*)"kforff",
    (byte*)"kfordmci",
    (byte*)"kfordfci",
    (byte*)"kfordmm",
    (byte*)"kfordff",
    (byte*)"kcallproc",
    (byte*)"kcallptr",
    (byte*)"kreturn0",
    (byte*)"kreturn",
    (byte*)"kpopretval",
    (byte*)"kyield",
    (byte*)"kmodulecall",
    (byte*)"kmodulereturn",
    (byte*)"kcalldll",
    (byte*)"kcallmproc",
    (byte*)"kcallhost",
    (byte*)"kcallmsys",
    (byte*)"kunshare",
    (byte*)"kaddsp",
    (byte*)"kstop",
    (byte*)"kstoprunproc",
    (byte*)"kmakelist",
    (byte*)"kmakerecord",
    (byte*)"kmakearray",
    (byte*)"kmakebits",
    (byte*)"kmakestruct",
    (byte*)"kmakeset",
    (byte*)"kmakerange",
    (byte*)"kmakerangelen",
    (byte*)"kmakedict",
    (byte*)"kmakedecimal",
    (byte*)"kincrptr",
    (byte*)"kincrtom",
    (byte*)"kincrtof",
    (byte*)"kloadincr",
    (byte*)"kincrload",
    (byte*)"kdecrptr",
    (byte*)"kdecrtom",
    (byte*)"kdecrtof",
    (byte*)"kloaddecr",
    (byte*)"kdecrload",
    (byte*)"kincr",
    (byte*)"kdecr",
    (byte*)"kneg",
    (byte*)"kabs",
    (byte*)"knotl",
    (byte*)"kinot",
    (byte*)"kistruel",
    (byte*)"kasc",
    (byte*)"kchr",
    (byte*)"ksqrt",
    (byte*)"ksqr",
    (byte*)"kcube",
    (byte*)"ksin",
    (byte*)"kcos",
    (byte*)"ktan",
    (byte*)"kasin",
    (byte*)"kacos",
    (byte*)"katan",
    (byte*)"ksign",
    (byte*)"kln",
    (byte*)"klog",
    (byte*)"klg",
    (byte*)"kexp",
    (byte*)"kround",
    (byte*)"kfloor",
    (byte*)"kceil",
    (byte*)"kfract",
    (byte*)"kfmod",
    (byte*)"knegto",
    (byte*)"kabsto",
    (byte*)"kinotto",
    (byte*)"knotlto",
    (byte*)"klen",
    (byte*)"klwb",
    (byte*)"kupb",
    (byte*)"kbounds",
    (byte*)"kboundsx",
    (byte*)"kbitwidth",
    (byte*)"kbytesize",
    (byte*)"ktype",
    (byte*)"kelemtype",
    (byte*)"kbasetype",
    (byte*)"kusertype",
    (byte*)"kdictitems",
    (byte*)"kisfound",
    (byte*)"kminvalue",
    (byte*)"kmaxvalue",
    (byte*)"kisint",
    (byte*)"kisreal",
    (byte*)"kisstring",
    (byte*)"kisrange",
    (byte*)"kisnumber",
    (byte*)"kislist",
    (byte*)"kisrecord",
    (byte*)"kispointer",
    (byte*)"kisarray",
    (byte*)"kismutable",
    (byte*)"kisset",
    (byte*)"kisvoid",
    (byte*)"kisdef",
    (byte*)"kisequal",
    (byte*)"kconvert",
    (byte*)"ktypepun",
    (byte*)"kodd",
    (byte*)"keven",
    (byte*)"kadd",
    (byte*)"ksub",
    (byte*)"kmul",
    (byte*)"kdiv",
    (byte*)"kidiv",
    (byte*)"kirem",
    (byte*)"kidivrem",
    (byte*)"kiand",
    (byte*)"kior",
    (byte*)"kixor",
    (byte*)"kshl",
    (byte*)"kshr",
    (byte*)"kin",
    (byte*)"knotin",
    (byte*)"kinx",
    (byte*)"kandl",
    (byte*)"korl",
    (byte*)"keq",
    (byte*)"kne",
    (byte*)"klt",
    (byte*)"kle",
    (byte*)"kge",
    (byte*)"kgt",
    (byte*)"kmin",
    (byte*)"kmax",
    (byte*)"kconcat",
    (byte*)"kappend",
    (byte*)"kpower",
    (byte*)"katan2",
    (byte*)"kaddto",
    (byte*)"ksubto",
    (byte*)"kmulto",
    (byte*)"kdivto",
    (byte*)"kidivto",
    (byte*)"kandlto",
    (byte*)"korlto",
    (byte*)"kiandto",
    (byte*)"kiorto",
    (byte*)"kixorto",
    (byte*)"kshlto",
    (byte*)"kshrto",
    (byte*)"kminto",
    (byte*)"kmaxto",
    (byte*)"kconcatto",
    (byte*)"kappendto",
    (byte*)"kdot",
    (byte*)"kindex",
    (byte*)"kdotindex",
    (byte*)"kkeyindex",
    (byte*)"kdotref",
    (byte*)"kindexref",
    (byte*)"kdotindexref",
    (byte*)"kkeyindexref",
    (byte*)"kpopdot",
    (byte*)"kpopindex",
    (byte*)"kpopdotindex",
    (byte*)"kpopkeyindex",
    (byte*)"kexpand",
    (byte*)"kpushtry",
    (byte*)"kraise",
    (byte*)"kmaps",
    (byte*)"kmapss",
    (byte*)"kpushff",
    (byte*)"kpushmm",
    (byte*)"kpushfm",
    (byte*)"kpushmf",
    (byte*)"kmoveff",
    (byte*)"kzmoveff",
    (byte*)"kmovefm",
    (byte*)"kmovemf",
    (byte*)"kmovemm",
    (byte*)"kmovefci",
    (byte*)"kzmovefci",
    (byte*)"kmovemci",
    (byte*)"kpushfff",
    (byte*)"knop2",
    (byte*)"kpushci0",
    (byte*)"kpushvoid2",
    (byte*)"kpushvoid3",
    (byte*)"kunshare1",
    (byte*)"kunshare2",
    (byte*)"kunshare3",
    (byte*)"kprocentry1",
    (byte*)"kprocentry2",
    (byte*)"kjumpeqfci",
    (byte*)"kjumpnefci",
    (byte*)"kjumpltfci",
    (byte*)"kjumplefci",
    (byte*)"kjumpgefci",
    (byte*)"kjumpgtfci",
    (byte*)"kjumpeqff",
    (byte*)"kjumpneff",
    (byte*)"kjumpltff",
    (byte*)"kjumpleff",
    (byte*)"kjumpgeff",
    (byte*)"kjumpgtff",
    (byte*)"kaddfci",
    (byte*)"ksubfci",
    (byte*)"kaddff",
    (byte*)"ksubff",
    (byte*)"kindexff",
    (byte*)"kpushincrptrm",
    (byte*)"kpushincrptrf",
    (byte*)"kpopincrptrm",
    (byte*)"kpopincrptrf",
    (byte*)"kswitchf",
    (byte*)"klenf",
    (byte*)"kpushptrf",
    (byte*)"klastpcl"
};
static byte qq_tables$pclfmt[273][4] = {
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)14u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)12u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)14u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)14u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)9u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)10u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)11u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)13u,(u8)0u,(u8)0u},
    {(u8)13u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)14u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)15u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)1u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)1u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)1u,(u8)1u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)6u,(u8)1u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)1u,(u8)1u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)3u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)14u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)4u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)4u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)13u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)7u,(u8)13u,(u8)13u},
    {(u8)7u,(u8)7u,(u8)13u,(u8)13u},
    {(u8)7u,(u8)13u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)13u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)13u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)5u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)5u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)5u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)7u,(u8)7u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)1u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)1u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)1u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)1u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)7u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)7u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)6u,(u8)2u,(u8)2u,(u8)0u},
    {(u8)2u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)7u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)2u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)1u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)7u,(u8)7u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)2u,(u8)0u,(u8)0u,(u8)0u},
    {(u8)0u,(u8)0u,(u8)0u,(u8)0u}
};
static void *  qq_tables$cmdmap[273];
static u8 *  qq_tables$symbolnames[177] = {
    (byte*)"errorsym",
    (byte*)"dotsym",
    (byte*)"lexdotsym",
    (byte*)"anddotsym",
    (byte*)"commasym",
    (byte*)"semisym",
    (byte*)"colonsym",
    (byte*)"dcolonsym",
    (byte*)"assignsym",
    (byte*)"deepcopysym",
    (byte*)"sendtosym",
    (byte*)"pipesym",
    (byte*)"lbracksym",
    (byte*)"rbracksym",
    (byte*)"lsqsym",
    (byte*)"rsqsym",
    (byte*)"lcurlysym",
    (byte*)"rcurlysym",
    (byte*)"ptrsym",
    (byte*)"barsym",
    (byte*)"dbarsym",
    (byte*)"atsym",
    (byte*)"datsym",
    (byte*)"questionsym",
    (byte*)"addrsym",
    (byte*)"daddrsym",
    (byte*)"poundsym",
    (byte*)"curlsym",
    (byte*)"rangesym",
    (byte*)"ellipsissym",
    (byte*)"hashsym",
    (byte*)"addsym",
    (byte*)"subsym",
    (byte*)"mulsym",
    (byte*)"divsym",
    (byte*)"idivsym",
    (byte*)"iremsym",
    (byte*)"idivremsym",
    (byte*)"andlsym",
    (byte*)"orlsym",
    (byte*)"iandsym",
    (byte*)"iorsym",
    (byte*)"ixorsym",
    (byte*)"shlsym",
    (byte*)"shrsym",
    (byte*)"minsym",
    (byte*)"maxsym",
    (byte*)"appendsym",
    (byte*)"concatsym",
    (byte*)"insym",
    (byte*)"notinsym",
    (byte*)"inxsym",
    (byte*)"inrevsym",
    (byte*)"powersym",
    (byte*)"eqsym",
    (byte*)"nesym",
    (byte*)"ltsym",
    (byte*)"lesym",
    (byte*)"gesym",
    (byte*)"gtsym",
    (byte*)"isequalsym",
    (byte*)"notlsym",
    (byte*)"inotsym",
    (byte*)"istruelsym",
    (byte*)"abssym",
    (byte*)"sqrsym",
    (byte*)"signsym",
    (byte*)"ascsym",
    (byte*)"chrsym",
    (byte*)"mathssym",
    (byte*)"maths2sym",
    (byte*)"propsym",
    (byte*)"incrsym",
    (byte*)"decrsym",
    (byte*)"eolsym",
    (byte*)"eofsym",
    (byte*)"rawnamesym",
    (byte*)"docstringsym",
    (byte*)"intconstsym",
    (byte*)"decimalconstsym",
    (byte*)"realconstsym",
    (byte*)"charconstsym",
    (byte*)"wcharconstsym",
    (byte*)"stringconstsym",
    (byte*)"astringconstsym",
    (byte*)"wstringconstsym",
    (byte*)"boolconstsym",
    (byte*)"unitnamesym",
    (byte*)"namesym",
    (byte*)"stdtypesym",
    (byte*)"koutsym",
    (byte*)"kicharsym",
    (byte*)"kifsym",
    (byte*)"kthensym",
    (byte*)"kelsifsym",
    (byte*)"kelsesym",
    (byte*)"kelsecasesym",
    (byte*)"kelseswitchsym",
    (byte*)"kelseselectsym",
    (byte*)"kendsym",
    (byte*)"kunlesssym",
    (byte*)"kcasesym",
    (byte*)"kdocasesym",
    (byte*)"krecasesym",
    (byte*)"kwhensym",
    (byte*)"kforsym",
    (byte*)"kforallsym",
    (byte*)"ktosym",
    (byte*)"kbysym",
    (byte*)"kdosym",
    (byte*)"kdooncesym",
    (byte*)"kwhilesym",
    (byte*)"krepeatsym",
    (byte*)"kuntilsym",
    (byte*)"kreturnsym",
    (byte*)"kstopsym",
    (byte*)"kloopsym",
    (byte*)"kgotosym",
    (byte*)"kswitchsym",
    (byte*)"kdoswitchsym",
    (byte*)"kprintsym",
    (byte*)"ksprintsym",
    (byte*)"kreadsym",
    (byte*)"ksreadsym",
    (byte*)"ksreadlnsym",
    (byte*)"knewsym",
    (byte*)"kprocsym",
    (byte*)"kfunctionsym",
    (byte*)"klabelsym",
    (byte*)"krecordsym",
    (byte*)"kstructsym",
    (byte*)"kunionsym",
    (byte*)"kheadersym",
    (byte*)"kheadervarsym",
    (byte*)"kimportdllsym",
    (byte*)"ktypesym",
    (byte*)"ktypeattrsym",
    (byte*)"krefsym",
    (byte*)"kvarsym",
    (byte*)"kletsym",
    (byte*)"kslicesym",
    (byte*)"kmacrosym",
    (byte*)"kexpandsym",
    (byte*)"koperatorsym",
    (byte*)"kconstsym",
    (byte*)"kenumsym",
    (byte*)"kdirectivesym",
    (byte*)"kfflangsym",
    (byte*)"kglobalsym",
    (byte*)"kstaticsym",
    (byte*)"kcalignedsym",
    (byte*)"ktrysym",
    (byte*)"kexceptsym",
    (byte*)"kfinallysym",
    (byte*)"kraisesym",
    (byte*)"kyieldsym",
    (byte*)"kextendsym",
    (byte*)"kblocksym",
    (byte*)"kcastsym",
    (byte*)"kptypesym",
    (byte*)"compilervarsym",
    (byte*)"dollarsym",
    (byte*)"kevalsym",
    (byte*)"ktabledatasym",
    (byte*)"kmapsym",
    (byte*)"kclampsym",
    (byte*)"kswapsym",
    (byte*)"kcondcompsym",
    (byte*)"kerrorsym",
    (byte*)"sysconstsym",
    (byte*)"khostfnsym",
    (byte*)"khostsym",
    (byte*)"knilsym",
    (byte*)"kstrincludesym",
    (byte*)"specialopsym",
    (byte*)"klistsym",
    (byte*)"kdummysym"
};
static u8 *  qq_tables$parammodenames[4] = {(byte*)"Var ",(byte*)"In ",(byte*)"Out ",(byte*)"Opt "};
static u8 *  qq_tables$headerdirnames[10] = {(byte*)"hdr_module",(byte*)"hdr_import",(byte*)"hdr_subprog",(byte*)"hdr_sysmodule",(byte*)"hdr_sysimport",(byte*)"hdr_syssubprog",(byte*)"hdr_altpath",(byte*)"hdr_importpath",(byte*)"hdr_file",(byte*)"hdr_runexe"};
static u8 *  qq_tables$headervarnames[11] = {
    (byte*)"hv_devpath",
    (byte*)"hv_mmpath",
    (byte*)"hv_hdrpath",
    (byte*)"hv_ctarget",
    (byte*)"hv_windows",
    (byte*)"hv_linux",
    (byte*)"hv_optim",
    (byte*)"hv_mainmodule",
    (byte*)"hv_a",
    (byte*)"hv_b",
    (byte*)"hv_c"
};
static u8 *  qq_tables$namenames[25] = {
    (byte*)"genericid",
    (byte*)"programid",
    (byte*)"subprogid",
    (byte*)"moduleid",
    (byte*)"dllmoduleid",
    (byte*)"procid",
    (byte*)"dllprocid",
    (byte*)"recordid",
    (byte*)"typeid",
    (byte*)"fieldid",
    (byte*)"structfieldid",
    (byte*)"staticid",
    (byte*)"frameid",
    (byte*)"paramid",
    (byte*)"dllparamid",
    (byte*)"labelid",
    (byte*)"constid",
    (byte*)"enumid",
    (byte*)"aliasid",
    (byte*)"linkid",
    (byte*)"macroid",
    (byte*)"macroparamid",
    (byte*)"structblockid",
    (byte*)"unionblockid",
    (byte*)"endblockid"
};
static u8 *  qq_tables$objtypenames[3] = {(byte*)"normal_obj",(byte*)"slice_obj",(byte*)"extslice_obj"};
static u8 *  qq_tables$scopenames[3] = {(byte*)"local_scope",(byte*)"global_scope",(byte*)"export_scope"};
static u8 *  qq_tables$stnames[234] = {
    (byte*)"if",
    (byte*)"then",
    (byte*)"elsif",
    (byte*)"else",
    (byte*)"elsecase",
    (byte*)"elseswitch",
    (byte*)"case",
    (byte*)"docase",
    (byte*)"recase",
    (byte*)"when",
    (byte*)"for",
    (byte*)"forall",
    (byte*)"foreach",
    (byte*)"to",
    (byte*)"downto",
    (byte*)"by",
    (byte*)"do",
    (byte*)"doonce",
    (byte*)"end",
    (byte*)"while",
    (byte*)"repeat",
    (byte*)"until",
    (byte*)"always",
    (byte*)"return",
    (byte*)"yield",
    (byte*)"stop",
    (byte*)"redo",
    (byte*)"next",
    (byte*)"exit",
    (byte*)"goto",
    (byte*)"switch",
    (byte*)"doswitch",
    (byte*)"tabledata",
    (byte*)"enumdata",
    (byte*)"clamp",
    (byte*)"maps",
    (byte*)"mapss",
    (byte*)"eval",
    (byte*)"$windows",
    (byte*)"$linux",
    (byte*)"print",
    (byte*)"println",
    (byte*)"fprint",
    (byte*)"fprintln",
    (byte*)"sprint",
    (byte*)"sfprint",
    (byte*)"cp",
    (byte*)"cpl",
    (byte*)"read",
    (byte*)"readln",
    (byte*)"cast",
    (byte*)"$type",
    (byte*)"proc",
    (byte*)"procedure",
    (byte*)"sub",
    (byte*)"function",
    (byte*)"func",
    (byte*)"fun",
    (byte*)"method",
    (byte*)"type",
    (byte*)"record",
    (byte*)"struct",
    (byte*)"packrecord",
    (byte*)"union",
    (byte*)"ref",
    (byte*)"var",
    (byte*)"let",
    (byte*)"slice",
    (byte*)"macro",
    (byte*)"operator",
    (byte*)"static",
    (byte*)"$caligned",
    (byte*)"const",
    (byte*)"module",
    (byte*)"sysmodule",
    (byte*)"import",
    (byte*)"sysimport",
    (byte*)"subprog",
    (byte*)"syssubprog",
    (byte*)"altpath",
    (byte*)"importpath",
    (byte*)"runexe",
    (byte*)"importdll",
    (byte*)"importlib",
    (byte*)"strinclude",
    (byte*)"unless",
    (byte*)"try",
    (byte*)"except",
    (byte*)"finally",
    (byte*)"raise",
    (byte*)"out",
    (byte*)"global",
    (byte*)"export",
    (byte*)"host",
    (byte*)"clang",
    (byte*)"windows",
    (byte*)"callback",
    (byte*)"swap",
    (byte*)"void",
    (byte*)"int",
    (byte*)"word",
    (byte*)"real",
    (byte*)"bool",
    (byte*)"string",
    (byte*)"list",
    (byte*)"array",
    (byte*)"vector",
    (byte*)"bits",
    (byte*)"set",
    (byte*)"dict",
    (byte*)"decimal",
    (byte*)"longint",
    (byte*)"typetype",
    (byte*)"range",
    (byte*)"recordtype",
    (byte*)"cvoid",
    (byte*)"i8",
    (byte*)"i16",
    (byte*)"i32",
    (byte*)"i64",
    (byte*)"bit",
    (byte*)"u1",
    (byte*)"u2",
    (byte*)"u4",
    (byte*)"byte",
    (byte*)"u8",
    (byte*)"u16",
    (byte*)"u32",
    (byte*)"u64",
    (byte*)"r32",
    (byte*)"r64",
    (byte*)"int8",
    (byte*)"int16",
    (byte*)"int32",
    (byte*)"int64",
    (byte*)"word8",
    (byte*)"word16",
    (byte*)"word32",
    (byte*)"word64",
    (byte*)"real32",
    (byte*)"real64",
    (byte*)"stringc",
    (byte*)"stringz",
    (byte*)"cstring",
    (byte*)"ichar",
    (byte*)"million",
    (byte*)"billion",
    (byte*)"as",
    (byte*)"$lineno",
    (byte*)"$strlineno",
    (byte*)"$date",
    (byte*)"$time",
    (byte*)"$",
    (byte*)"and",
    (byte*)"or",
    (byte*)"iand",
    (byte*)"ior",
    (byte*)"ixor",
    (byte*)"in",
    (byte*)"notin",
    (byte*)"inx",
    (byte*)"inrev",
    (byte*)"rem",
    (byte*)"divrem",
    (byte*)"min",
    (byte*)"max",
    (byte*)"not",
    (byte*)"inot",
    (byte*)"istrue",
    (byte*)"abs",
    (byte*)"asc",
    (byte*)"chr",
    (byte*)"sqrt",
    (byte*)"sqr",
    (byte*)"cos",
    (byte*)"sin",
    (byte*)"tan",
    (byte*)"asin",
    (byte*)"acos",
    (byte*)"atan",
    (byte*)"atan2",
    (byte*)"sign",
    (byte*)"ln",
    (byte*)"log",
    (byte*)"exp",
    (byte*)"round",
    (byte*)"floor",
    (byte*)"ceil",
    (byte*)"fract",
    (byte*)"fmod",
    (byte*)"append",
    (byte*)"concat",
    (byte*)"len",
    (byte*)"lwb",
    (byte*)"upb",
    (byte*)"bounds",
    (byte*)"bitwidth",
    (byte*)"bytes",
    (byte*)"minvalue",
    (byte*)"maxvalue",
    (byte*)"basetype",
    (byte*)"usertype",
    (byte*)"elemtype",
    (byte*)"dictitems",
    (byte*)"isfound",
    (byte*)"isvoid",
    (byte*)"isdef",
    (byte*)"defined",
    (byte*)"isint",
    (byte*)"isreal",
    (byte*)"islist",
    (byte*)"isstring",
    (byte*)"isrange",
    (byte*)"ispointer",
    (byte*)"isarray",
    (byte*)"isrecord",
    (byte*)"isset",
    (byte*)"isnumber",
    (byte*)"ismutable",
    (byte*)"odd",
    (byte*)"even",
    (byte*)"fi",
    (byte*)"esac",
    (byte*)"od",
    (byte*)"nil",
    (byte*)"pnil",
    (byte*)"con",
    (byte*)"pi",
    (byte*)"true",
    (byte*)"false",
    (byte*)"$neg",
    (byte*)"$index",
    (byte*)"$list",
    (byte*)"$$dummy"
};
static i16 qq_tables$stsymbols[234] = {
    (i16)93,
    (i16)94,
    (i16)95,
    (i16)96,
    (i16)97,
    (i16)98,
    (i16)102,
    (i16)103,
    (i16)104,
    (i16)105,
    (i16)106,
    (i16)106,
    (i16)106,
    (i16)108,
    (i16)108,
    (i16)109,
    (i16)110,
    (i16)111,
    (i16)100,
    (i16)112,
    (i16)113,
    (i16)114,
    (i16)114,
    (i16)115,
    (i16)156,
    (i16)116,
    (i16)117,
    (i16)117,
    (i16)117,
    (i16)118,
    (i16)119,
    (i16)120,
    (i16)164,
    (i16)164,
    (i16)166,
    (i16)165,
    (i16)165,
    (i16)163,
    (i16)168,
    (i16)168,
    (i16)121,
    (i16)121,
    (i16)121,
    (i16)121,
    (i16)122,
    (i16)122,
    (i16)121,
    (i16)121,
    (i16)123,
    (i16)123,
    (i16)159,
    (i16)160,
    (i16)127,
    (i16)127,
    (i16)127,
    (i16)128,
    (i16)128,
    (i16)128,
    (i16)128,
    (i16)136,
    (i16)130,
    (i16)131,
    (i16)131,
    (i16)132,
    (i16)138,
    (i16)139,
    (i16)140,
    (i16)141,
    (i16)142,
    (i16)144,
    (i16)150,
    (i16)151,
    (i16)145,
    (i16)133,
    (i16)133,
    (i16)133,
    (i16)133,
    (i16)133,
    (i16)133,
    (i16)133,
    (i16)133,
    (i16)133,
    (i16)135,
    (i16)135,
    (i16)174,
    (i16)101,
    (i16)152,
    (i16)153,
    (i16)154,
    (i16)155,
    (i16)91,
    (i16)149,
    (i16)149,
    (i16)172,
    (i16)148,
    (i16)148,
    (i16)148,
    (i16)167,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)90,
    (i16)88,
    (i16)88,
    (i16)88,
    (i16)161,
    (i16)161,
    (i16)161,
    (i16)161,
    (i16)162,
    (i16)39,
    (i16)40,
    (i16)41,
    (i16)42,
    (i16)43,
    (i16)50,
    (i16)51,
    (i16)52,
    (i16)53,
    (i16)37,
    (i16)38,
    (i16)46,
    (i16)47,
    (i16)62,
    (i16)63,
    (i16)64,
    (i16)65,
    (i16)68,
    (i16)69,
    (i16)70,
    (i16)66,
    (i16)70,
    (i16)70,
    (i16)70,
    (i16)70,
    (i16)70,
    (i16)70,
    (i16)71,
    (i16)67,
    (i16)70,
    (i16)70,
    (i16)70,
    (i16)70,
    (i16)70,
    (i16)70,
    (i16)70,
    (i16)71,
    (i16)48,
    (i16)49,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)72,
    (i16)100,
    (i16)100,
    (i16)100,
    (i16)173,
    (i16)173,
    (i16)170,
    (i16)170,
    (i16)87,
    (i16)87,
    (i16)175,
    (i16)175,
    (i16)176,
    (i16)0
};
static i16 qq_tables$stsubcodes[234] = {
    (i16)0,
    (i16)0,
    (i16)9,
    (i16)0,
    (i16)12,
    (i16)14,
    (i16)12,
    (i16)13,
    (i16)16,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)1,
    (i16)0,
    (i16)1,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)63,
    (i16)64,
    (i16)65,
    (i16)0,
    (i16)14,
    (i16)15,
    (i16)0,
    (i16)1,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)70,
    (i16)71,
    (i16)72,
    (i16)73,
    (i16)74,
    (i16)75,
    (i16)70,
    (i16)71,
    (i16)79,
    (i16)80,
    (i16)13,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)1,
    (i16)0,
    (i16)0,
    (i16)1,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)1,
    (i16)4,
    (i16)2,
    (i16)5,
    (i16)3,
    (i16)6,
    (i16)7,
    (i16)8,
    (i16)10,
    (i16)'D',
    (i16)'L',
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)0,
    (i16)1,
    (i16)2,
    (i16)0,
    (i16)2,
    (i16)1,
    (i16)4,
    (i16)0,
    (i16)0,
    (i16)1,
    (i16)2,
    (i16)3,
    (i16)5,
    (i16)12,
    (i16)13,
    (i16)14,
    (i16)10,
    (i16)11,
    (i16)8,
    (i16)9,
    (i16)4,
    (i16)4,
    (i16)19,
    (i16)6,
    (i16)15,
    (i16)0,
    (i16)28,
    (i16)29,
    (i16)30,
    (i16)1,
    (i16)35,
    (i16)35,
    (i16)36,
    (i16)37,
    (i16)31,
    (i16)31,
    (i16)32,
    (i16)33,
    (i16)2,
    (i16)34,
    (i16)3,
    (i16)28,
    (i16)29,
    (i16)30,
    (i16)1,
    (i16)31,
    (i16)32,
    (i16)33,
    (i16)2,
    (i16)34,
    (i16)3,
    (i16)38,
    (i16)39,
    (i16)39,
    (i16)40,
    (i16)2,
    (i16)3,
    (i16)0,
    (i16)200,
    (i16)201,
    (i16)205,
    (i16)206,
    (i16)0,
    (i16)165,
    (i16)166,
    (i16)156,
    (i16)157,
    (i16)158,
    (i16)161,
    (i16)162,
    (i16)163,
    (i16)164,
    (i16)154,
    (i16)155,
    (i16)173,
    (i16)174,
    (i16)91,
    (i16)92,
    (i16)93,
    (i16)90,
    (i16)94,
    (i16)95,
    (i16)96,
    (i16)97,
    (i16)99,
    (i16)98,
    (i16)100,
    (i16)101,
    (i16)102,
    (i16)103,
    (i16)178,
    (i16)113,
    (i16)104,
    (i16)105,
    (i16)107,
    (i16)108,
    (i16)109,
    (i16)110,
    (i16)111,
    (i16)112,
    (i16)176,
    (i16)175,
    (i16)118,
    (i16)119,
    (i16)120,
    (i16)121,
    (i16)123,
    (i16)124,
    (i16)131,
    (i16)132,
    (i16)127,
    (i16)128,
    (i16)126,
    (i16)129,
    (i16)130,
    (i16)144,
    (i16)145,
    (i16)145,
    (i16)133,
    (i16)134,
    (i16)138,
    (i16)135,
    (i16)136,
    (i16)140,
    (i16)141,
    (i16)139,
    (i16)143,
    (i16)137,
    (i16)142,
    (i16)147,
    (i16)148,
    (i16)93,
    (i16)102,
    (i16)110,
    (i16)0,
    (i16)1,
    (i16)3,
    (i16)1,
    (i16)1,
    (i16)0,
    (i16)'-',
    (i16)(u64)23899u,
    (i16)0,
    (i16)0
};
static u8 *  qq_tables$hostfnnames[78] = {
    (byte*)"host_dummy",
    (byte*)"host_startprint",
    (byte*)"host_startprintcon",
    (byte*)"host_strstartprint",
    (byte*)"host_setformat",
    (byte*)"host_endprint",
    (byte*)"host_strendprint",
    (byte*)"host_print",
    (byte*)"host_print_nf",
    (byte*)"host_dprint",
    (byte*)"host_println",
    (byte*)"host_printnogap",
    (byte*)"host_printspace",
    (byte*)"host_readln",
    (byte*)"host_sreadln",
    (byte*)"host_sread",
    (byte*)"host_rereadln",
    (byte*)"host_reread",
    (byte*)"host_strtoval",
    (byte*)"host_tostr",
    (byte*)"host_leftstr",
    (byte*)"host_rightstr",
    (byte*)"host_convlc",
    (byte*)"host_convuc",
    (byte*)"host_iconvlc",
    (byte*)"host_iconvuc",
    (byte*)"host_stop",
    (byte*)"host_stopx",
    (byte*)"host_ismain",
    (byte*)"host_waitkey",
    (byte*)"host_testkey",
    (byte*)"host_execwait",
    (byte*)"host_execcmd",
    (byte*)"host_shellexec",
    (byte*)"host_system",
    (byte*)"host_makestr",
    (byte*)"host_makestrslice",
    (byte*)"host_makeref",
    (byte*)"host_makeiter",
    (byte*)"host_checkiter",
    (byte*)"host_nextiter",
    (byte*)"host_new",
    (byte*)"host_setoverload",
    (byte*)"host_getcmdparam",
    (byte*)"host_gethostname",
    (byte*)"host_getprogname",
    (byte*)"host_$setpcerror",
    (byte*)"host_$setdebug",
    (byte*)"host_$test2",
    (byte*)"host_$test",
    (byte*)"host_$refcount",
    (byte*)"host_ticks",
    (byte*)"host_clock",
    (byte*)"host_sleep",
    (byte*)"host_random",
    (byte*)"host_gethash",
    (byte*)"host_getos",
    (byte*)"host_gethostsize",
    (byte*)"host_iswindows",
    (byte*)"host_setmesshandler",
    (byte*)"host_$setfprintf",
    (byte*)"host_$getparam",
    (byte*)"host_allparams",
    (byte*)"host_makeempty",
    (byte*)"host_$procsymbols",
    (byte*)"host_$symbolowner",
    (byte*)"host_$symbolname",
    (byte*)"host_$symboldefs",
    (byte*)"host_$testcallback",
    (byte*)"host_$smallmemtotal",
    (byte*)"host_$id",
    (byte*)"host_copy",
    (byte*)"host_$nan",
    (byte*)"host_$infinity",
    (byte*)"host_allocexec",
    (byte*)"host_runnative",
    (byte*)"host_setlwb",
    (byte*)"host_last"
};
static byte qq_tables$hostnparams[78] = {
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)1u,
    (u8)2u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)3u,
    (u8)3u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)3u,
    (u8)3u,
    (u8)2u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)4u,
    (u8)3u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)0u
};
static byte qq_tables$hostisfn[78] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u
};
static byte qq_tables$hostinternal[78] = {
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u
};
static u8 *  qq_tables$errornames[7] = {(byte*)"pc_error",(byte*)"user_error",(byte*)"type_error",(byte*)"mixedtype_error",(byte*)"divide_error",(byte*)"stopmodule_error",(byte*)"bounds_error"};
static byte qq_tables$d_binopset[28] = {
    (u8)39u,
    (u8)40u,
    (u8)55u,
    (u8)56u,
    (u8)57u,
    (u8)58u,
    (u8)60u,
    (u8)59u,
    (u8)32u,
    (u8)33u,
    (u8)34u,
    (u8)35u,
    (u8)36u,
    (u8)37u,
    (u8)41u,
    (u8)42u,
    (u8)43u,
    (u8)44u,
    (u8)45u,
    (u8)46u,
    (u8)47u,
    (u8)49u,
    (u8)54u,
    (u8)61u,
    (u8)38u,
    (u8)71u,
    (u8)48u,
    (u8)25u
};
static byte qq_tables$binopset[178];
static byte qq_tables$d_unaryopset[9] = {(u8)62u,(u8)63u,(u8)65u,(u8)64u,(u8)66u,(u8)67u,(u8)68u,(u8)69u,(u8)70u};
static byte qq_tables$unaryopset[178];
static byte qq_tables$d_addopset[11] = {
    (u8)32u,
    (u8)33u,
    (u8)41u,
    (u8)42u,
    (u8)43u,
    (u8)49u,
    (u8)48u,
    (u8)46u,
    (u8)47u,
    (u8)25u,
    (u8)26u
};
static byte qq_tables$d_cmpopset[7] = {(u8)55u,(u8)56u,(u8)57u,(u8)58u,(u8)59u,(u8)60u,(u8)61u};
static byte qq_tables$d_mulopset[6] = {(u8)34u,(u8)35u,(u8)36u,(u8)37u,(u8)44u,(u8)45u};
static byte qq_tables$addopset[178];
static byte qq_tables$cmpopset[178];
static byte qq_tables$mulopset[178];
static byte qq_tables$exprendset[178];
static i64 qq_tables$d_exprstarterset[33] = {
    (i64)13,
    (i64)15,
    (i64)19,
    (i64)25,
    (i64)89,
    (i64)73,
    (i64)74,
    (i64)79,
    (i64)80,
    (i64)81,
    (i64)82,
    (i64)84,
    (i64)90,
    (i64)160,
    (i64)165,
    (i64)122,
    (i64)124,
    (i64)125,
    (i64)126,
    (i64)162,
    (i64)161,
    (i64)166,
    (i64)169,
    (i64)138,
    (i64)159,
    (i64)4,
    (i64)30,
    (i64)173,
    (i64)171,
    (i64)93,
    (i64)28,
    (i64)130,
    (i64)131
};
static byte qq_tables$exprstarterset[177];
static u8 *  qq_tables$ttname[251];
static struct qq_decls$strec *  qq_tables$ttnamedef[251];
static i16 qq_tables$ttbasetype[251];
static i16 qq_tables$tttarget[251];
static i64 qq_tables$ttlower[251];
static i64 qq_tables$ttlength[251];
static struct qq_decls$unitrec *  qq_tables$ttlowerexpr[251];
static struct qq_decls$unitrec *  qq_tables$ttlengthexpr[251];
static i64 qq_tables$ttsize[251];
static byte qq_tables$ttbitwidth[251];
static struct qq_decls$strec *  qq_tables$ttfields[251];
static byte qq_tables$ttcaligned[251];
static struct qq_decls$strec *  qq_tables$ttowner[251];
static i64 qq_tables$ntypes;
static i64 qq_tables$nuserxtypes;
static i64 qq_tables$userxtypebase;
static struct qq_decls$userxrec *  qq_tables$userxmodelist;
static struct qq_decls$strec *  qq_tables$ttnamedefx[5000];
static struct qq_decls$strec *  qq_tables$ttnamedefx2[5000];
static i64 qq_tables$ttposx[5000];
static i64 qq_tables$ttxmap[5000];
static byte qq_tables$ttxmoduleno[5000];
static byte qq_tables$hostlvset[78];
static i64 (*qq_dummyshow$labelmap)[];
static i64 qq_dummyshow$currlineno;
static struct qq_decls$strec *  qq_dummyshow$currpclproc;
static struct mlib$strbuffer qq_dummyshow$pclv;
static struct mlib$strbuffer *  qq_dummyshow$pcldest = (struct mlib$strbuffer *)&qq_dummyshow$pclv;
static struct qq_decls$objrec qq_vars$zeroobj;
static void *  msysc$_fnaddresses[]= {
    &main,
    &qqcli$getinputoptions,
    &qqcli$do_option,
    &qqcli$runqprogram,
    &qqcli$load_program,
    &qqcli$parse_program,
    &qqcli$rx_program,
    &qqcli$gxpcl_program,
    &qqcli$optimise_program,
    &qqcli$fixup_program,
    &qqcli$writeqa_program,
    &qqcli$initprogram,
    &qqcli$fixproc,
    &qqcli$fixupmodule,
    &qqcli$runprogram,
    &qqcli$disploop,
    &qqcli$disploop_fn,
    &qqcli$disploop_deb,
    &qqcli$setcmdmap,
    &qqcli$runproc_m,
    &qqcli$runproc,
    &qqcli$start,
    &qq_arrays$var_empty_array,
    &qq_arrays$obj_free_array,
    &qq_arrays$obj_free_vector,
    &qq_arrays$var_make_array,
    &qq_arrays$obj_newarray,
    &qq_arrays$obj_newarray_u,
    &qq_arrays$var_getix_array,
    &qq_arrays$var_putix_array,
    &qq_arrays$var_getixref_array,
    &qq_arrays$obj_append_array,
    &qq_arrays$var_appendto_array,
    &qq_arrays$obj_resize_array,
    &qq_arrays$var_dupl_array,
    &qq_arrays$var_dupl_vector,
    &qq_arrays$var_equal_array,
    &qq_arrays$var_concatto_array,
    &qq_arrays$var_getslice_array,
    &qq_arrays$var_putslice_array,
    &qq_arrays$u8inarray,
    &qq_arrays$u16inarray,
    &qq_arrays$u32inarray,
    &qq_arrays$u64inarray,
    &qq_arrays$var_inx_array,
    &qq_arrays$var_expand_array,
    &qq_arrays$var_nextiter_array,
    &qq_arrays$start,
    &qq_bits$obj_free_bits,
    &qq_bits$var_make_bits,
    &qq_bits$obj_newbits,
    &qq_bits$var_getix_bits,
    &qq_bits$var_putix_bits,
    &qq_bits$var_getixref_bits,
    &qq_bits$getindexoffset,
    &qq_bits$obj_append_bits,
    &qq_bits$var_appendto_bits,
    &qq_bits$obj_resize_bits,
    &qq_bits$var_dupl_bits,
    &qq_bits$var_equal_bits,
    &qq_bits$var_concatto_bits,
    &qq_bits$var_getslice_bits,
    &qq_bits$var_putslice_bits,
    &qq_bits$bits_bytesize,
    &qq_bits$getbitssize,
    &qq_bits$start,
    &qq_calldll$calldll,
    &qq_calldll$getlibprocaddr,
    &qq_calldll$vartopacked,
    &qq_calldll$packedtovar,
    &qq_calldll$loaddllfunction,
    &qq_calldll$start,
    &qq_decimal$obj_free_dec,
    &qq_decimal$var_dupl_dec,
    &qq_decimal$var_empty_dec,
    &qq_decimal$var_make_dec_str,
    &qq_decimal$var_make_dec_int,
    &qq_decimal$badnumber,
    &qq_decimal$bn_makestr,
    &qq_decimal$readexpon,
    &qq_decimal$bn_makeint,
    &qq_decimal$var_tostr_dec,
    &qq_decimal$obj_tostr_dec,
    &qq_decimal$tostring_scient,
    &qq_decimal$tostring_float,
    &qq_decimal$strvaln,
    &qq_decimal$bn_isint,
    &qq_decimal$obj_len_dec,
    &qq_decimal$bn_iszero,
    &qq_decimal$var_equal_dec,
    &qq_decimal$var_add_dec,
    &qq_decimal$var_sub_dec,
    &qq_decimal$var_mul_dec,
    &qq_decimal$var_div_dec,
    &qq_decimal$var_idiv_dec,
    &qq_decimal$var_irem_dec,
    &qq_decimal$var_neg_dec,
    &qq_decimal$var_abs_dec,
    &qq_decimal$var_compare_dec,
    &qq_decimal$bn_cmp,
    &qq_decimal$bn_equal,
    &qq_decimal$bn_add,
    &qq_decimal$bn_sub,
    &qq_decimal$bn_addu,
    &qq_decimal$bn_subu,
    &qq_decimal$makebignum,
    &qq_decimal$makesmallnum,
    &qq_decimal$smalltobig,
    &qq_decimal$freesmall,
    &qq_decimal$bn_init,
    &qq_decimal$bn_setzero,
    &qq_decimal$bn_move,
    &qq_decimal$bn_dupl,
    &qq_decimal$bn_setinf,
    &qq_decimal$bn_setnan,
    &qq_decimal$var_setnan,
    &qq_decimal$var_setinf,
    &qq_decimal$getbintype,
    &qq_decimal$bn_negto,
    &qq_decimal$bn_absto,
    &qq_decimal$bn_mul,
    &qq_decimal$bn_mulp,
    &qq_decimal$bn_mulu,
    &qq_decimal$smallmulto,
    &qq_decimal$bn_div,
    &qq_decimal$bn_idiv,
    &qq_decimal$bn_idivrem,
    &qq_decimal$bn_irem,
    &qq_decimal$bn_idivu,
    &qq_decimal$bn_fdivu,
    &qq_decimal$smalldiv,
    &qq_decimal$smallsubto,
    &qq_decimal$bn_getprec,
    &qq_decimal$bn_setprec,
    &qq_decimal$bn_getglobalprec,
    &qq_decimal$bn_setglobalprec,
    &qq_decimal$bn_makefloat,
    &qq_decimal$dectemp,
    &qq_decimal$freedectemp,
    &qq_decimal$bn_ipower,
    &qq_decimal$var_power_dec,
    &qq_decimal$var_convert_dec_int,
    &qq_decimal$bn_toint,
    &qq_decimal$start,
    &qq_decls$start,
    &qq_dicts$var_make_dict,
    &qq_dicts$obj_new_dict,
    &qq_dicts$obj_free_dict,
    &qq_dicts$var_dupl_dict,
    &qq_dicts$var_equal_dict,
    &qq_dicts$var_finddictitem,
    &qq_dicts$expanddict,
    &qq_dicts$adddictitem,
    &qq_dicts$var_checkiter_dict,
    &qq_dicts$var_nextiter_dict,
    &qq_dicts$start,
    &qq_iterators$var_make_iter,
    &qq_iterators$var_check_iter,
    &qq_iterators$var_next_iter,
    &qq_iterators$obj_free_iter,
    &qq_iterators$var_dupl_iter,
    &qq_iterators$start,
    &qq_jhandlers_hll$asmavailable,
    &qq_jhandlers_hll$disploop_asm,
    &qq_jhandlers_hll$initjhandlers,
    &qq_jhandlers_hll$start,
    &qq_khandlers$initkhandlers,
    &qq_khandlers$kunimpl,
    &qq_khandlers$k_pushci,
    &qq_khandlers$k_pushtrue,
    &qq_khandlers$k_pushfalse,
    &qq_khandlers$k_pushcu,
    &qq_khandlers$k_pushnil,
    &qq_khandlers$k_pushcs,
    &qq_khandlers$k_pushcr,
    &qq_khandlers$k_pushenum,
    &qq_khandlers$k_stop,
    &qq_khandlers$k_stoprunproc,
    &qq_khandlers$k_pushm,
    &qq_khandlers$k_pushf,
    &qq_khandlers$k_pushff,
    &qq_khandlers$k_pushmref,
    &qq_khandlers$k_pushfref,
    &qq_khandlers$k_popm,
    &qq_khandlers$k_storem,
    &qq_khandlers$k_zpopm,
    &qq_khandlers$k_popf,
    &qq_khandlers$k_storef,
    &qq_khandlers$k_zpopf,
    &qq_khandlers$k_popretval,
    &qq_khandlers$k_tom,
    &qq_khandlers$k_tof,
    &qq_khandlers$k_add,
    &qq_khandlers$k_sub,
    &qq_khandlers$k_mul,
    &qq_khandlers$k_div,
    &qq_khandlers$k_idiv,
    &qq_khandlers$k_irem,
    &qq_khandlers$k_iand,
    &qq_khandlers$k_ior,
    &qq_khandlers$k_ixor,
    &qq_khandlers$k_shl,
    &qq_khandlers$k_shr,
    &qq_khandlers$k_sqr,
    &qq_khandlers$k_sign,
    &qq_khandlers$k_sqrt,
    &qq_khandlers$k_sin,
    &qq_khandlers$k_cos,
    &qq_khandlers$k_tan,
    &qq_khandlers$k_asin,
    &qq_khandlers$k_acos,
    &qq_khandlers$k_atan,
    &qq_khandlers$k_ln,
    &qq_khandlers$k_log,
    &qq_khandlers$k_lg,
    &qq_khandlers$k_exp,
    &qq_khandlers$k_round,
    &qq_khandlers$k_floor,
    &qq_khandlers$k_ceil,
    &qq_khandlers$k_fract,
    &qq_khandlers$k_neg,
    &qq_khandlers$k_negto,
    &qq_khandlers$k_absto,
    &qq_khandlers$k_inotto,
    &qq_khandlers$k_atan2,
    &qq_khandlers$k_fmod,
    &qq_khandlers$k_abs,
    &qq_khandlers$k_inot,
    &qq_khandlers$k_istruel,
    &qq_khandlers$k_notl,
    &qq_khandlers$k_jumpeq,
    &qq_khandlers$k_jumpne,
    &qq_khandlers$k_jumplt,
    &qq_khandlers$k_jumple,
    &qq_khandlers$k_jumpge,
    &qq_khandlers$k_jumpgt,
    &qq_khandlers$k_jumpfalse,
    &qq_khandlers$k_jumptrue,
    &qq_khandlers$k_incrtom,
    &qq_khandlers$k_incrtof,
    &qq_khandlers$k_decrtom,
    &qq_khandlers$k_decrtof,
    &qq_khandlers$k_incrload,
    &qq_khandlers$k_loadincr,
    &qq_khandlers$k_decrload,
    &qq_khandlers$k_loaddecr,
    &qq_khandlers$k_incrptr,
    &qq_khandlers$k_decrptr,
    &qq_khandlers$k_pushvoid,
    &qq_khandlers$k_callproc,
    &qq_khandlers$k_callptr,
    &qq_khandlers$k_procentry,
    &qq_khandlers$k_return,
    &qq_khandlers$k_return0,
    &qq_khandlers$k_unshare,
    &qq_khandlers$k_unshare1,
    &qq_khandlers$k_formci,
    &qq_khandlers$k_forfci,
    &qq_khandlers$k_fordmci,
    &qq_khandlers$k_fordfci,
    &qq_khandlers$k_formm,
    &qq_khandlers$k_fordmm,
    &qq_khandlers$k_forff,
    &qq_khandlers$k_fordff,
    &qq_khandlers$k_comment,
    &qq_khandlers$k_makelist,
    &qq_khandlers$k_makedict,
    &qq_khandlers$k_makeset,
    &qq_khandlers$k_makerecord,
    &qq_khandlers$k_makestruct,
    &qq_khandlers$k_makearray,
    &qq_khandlers$k_makebits,
    &qq_khandlers$k_index,
    &qq_khandlers$k_popindex,
    &qq_khandlers$k_indexref,
    &qq_khandlers$k_keyindex,
    &qq_khandlers$k_popkeyindex,
    &qq_khandlers$k_keyindexref,
    &qq_khandlers$k_dot,
    &qq_khandlers$k_dotref,
    &qq_khandlers$k_popdot,
    &qq_khandlers$k_dotindex,
    &qq_khandlers$k_dotindexref,
    &qq_khandlers$k_popdotindex,
    &qq_khandlers$k_len,
    &qq_khandlers$k_upb,
    &qq_khandlers$k_lwb,
    &qq_khandlers$k_bounds,
    &qq_khandlers$k_boundsx,
    &qq_khandlers$do_bounds,
    &qq_khandlers$k_dictitems,
    &qq_khandlers$k_isfound,
    &qq_khandlers$k_append,
    &qq_khandlers$k_concat,
    &qq_khandlers$k_appendto,
    &qq_khandlers$k_concatto,
    &qq_khandlers$k_addto,
    &qq_khandlers$k_subto,
    &qq_khandlers$k_multo,
    &qq_khandlers$k_divto,
    &qq_khandlers$k_idivto,
    &qq_khandlers$k_iandto,
    &qq_khandlers$k_iorto,
    &qq_khandlers$k_ixorto,
    &qq_khandlers$k_shlto,
    &qq_khandlers$k_shrto,
    &qq_khandlers$k_copy,
    &qq_khandlers$k_dupl,
    &qq_khandlers$k_makerange,
    &qq_khandlers$k_makerangelen,
    &qq_khandlers$k_makedecimal,
    &qq_khandlers$resolvefield,
    &qq_khandlers$k_pushptr,
    &qq_khandlers$k_popptr,
    &qq_khandlers$k_islist,
    &qq_khandlers$k_isarray,
    &qq_khandlers$k_isstring,
    &qq_khandlers$k_isrecord,
    &qq_khandlers$k_swap,
    &qq_khandlers$k_jumptesteq,
    &qq_khandlers$k_jumptestne,
    &qq_khandlers$k_jump,
    &qq_khandlers$k_jumpptr,
    &qq_khandlers$k_incr,
    &qq_khandlers$k_decr,
    &qq_khandlers$k_chr,
    &qq_khandlers$k_asc,
    &qq_khandlers$k_pusht,
    &qq_khandlers$k_type,
    &qq_khandlers$k_basetype,
    &qq_khandlers$k_usertype,
    &qq_khandlers$k_elemtype,
    &qq_khandlers$k_nop,
    &qq_khandlers$k_modulecall,
    &qq_khandlers$k_modulereturn,
    &qq_khandlers$k_maxvalue,
    &qq_khandlers$k_minvalue,
    &qq_khandlers$k_callhost,
    &qq_khandlers$k_expand,
    &qq_khandlers$k_pushsymbol,
    &qq_khandlers$k_eq,
    &qq_khandlers$k_ne,
    &qq_khandlers$k_lt,
    &qq_khandlers$k_le,
    &qq_khandlers$k_ge,
    &qq_khandlers$k_gt,
    &qq_khandlers$do_cmp,
    &qq_khandlers$k_calldll,
    &qq_khandlers$k_in,
    &qq_khandlers$k_notin,
    &qq_khandlers$k_inx,
    &qq_khandlers$k_convrefpack,
    &qq_khandlers$k_isdef,
    &qq_khandlers$k_isvoid,
    &qq_khandlers$k_isint,
    &qq_khandlers$k_isnumber,
    &qq_khandlers$k_ismutable,
    &qq_khandlers$k_isreal,
    &qq_khandlers$k_isrange,
    &qq_khandlers$k_isset,
    &qq_khandlers$k_ispointer,
    &qq_khandlers$istype,
    &qq_khandlers$k_convert,
    &qq_khandlers$k_switch,
    &qq_khandlers$k_bytesize,
    &qq_khandlers$k_bitwidth,
    &qq_khandlers$k_min,
    &qq_khandlers$k_max,
    &qq_khandlers$k_addsp,
    &qq_khandlers$k_pushtry,
    &qq_khandlers$k_raise,
    &qq_khandlers$k_isequal,
    &qq_khandlers$k_minto,
    &qq_khandlers$k_maxto,
    &qq_khandlers$k_power,
    &qq_khandlers$domaths,
    &qq_khandlers$getmaths,
    &qq_khandlers$k_typepun,
    &qq_khandlers$k_andlto,
    &qq_khandlers$k_orlto,
    &qq_khandlers$k_notlto,
    &qq_khandlers$k_pushoperator,
    &qq_khandlers$k_maps,
    &qq_khandlers$k_mapss,
    &qq_khandlers$k_idivrem,
    &qq_khandlers$k_odd,
    &qq_khandlers$k_even,
    &qq_khandlers$start,
    &qq_host$callhostfunction,
    &qq_host$inithostlib,
    &qq_host$pch_leftstr,
    &qq_host$pch_rightstr,
    &qq_host$pch_convlc,
    &qq_host$pch_convuc,
    &qq_host$pch_waitkey,
    &qq_host$pch_execwait,
    &qq_host$pch_execcmd,
    &qq_host$pch_makestr,
    &qq_host$pch_makeref,
    &qq_host$pch_getcmdparam,
    &qq_host$pch_clock,
    &qq_host$pch_allocexec,
    &qq_host$pch_runnative,
    &qq_host$pch_setlwb,
    &qq_host$pch_ticks,
    &qq_host$pch_sleep,
    &qq_host$pch_random,
    &qq_host$pch_system,
    &qq_host$pch_$getparam,
    &qq_host$checkparam,
    &qq_host$leftstring,
    &qq_host$rightstring,
    &qq_host$padstring_right,
    &qq_host$padstring_left,
    &qq_host$getbounds,
    &qq_host$pch_new,
    &qq_host$pch_gethostname,
    &qq_host$pch_getprogname,
    &qq_host$pch_$test,
    &qq_host$pch_$test2,
    &qq_host$pch_$refcount,
    &qq_host$pch_testkey,
    &qq_host$pch_getos,
    &qq_host$pch_$procsymbols,
    &qq_host$pch_$symbolowner,
    &qq_host$pch_$symbolname,
    &qq_host$pch_$symboldefs,
    &qq_host$pch_setmesshandler,
    &qq_host$pch_$testcallback,
    &qq_host$pch_$smallmemtotal,
    &qq_host$pch_$id,
    &qq_host$pch_iswindows,
    &qq_host$pch_$setdebug,
    &qq_host$pch_copy,
    &qq_host$pch_gethash,
    &qq_host$pch_makeempty,
    &qq_host$pch_$infinity,
    &qq_host$pch_$nan,
    &qq_host$setcmdparam,
    &qq_host$pch_makeiter,
    &qq_host$pch_checkiter,
    &qq_host$pch_nextiter,
    &qq_host$start,
    &qq_lex$lexreadtoken,
    &qq_lex$lxreadstring,
    &qq_lex$lexinit,
    &qq_lex$readrawstring,
    &qq_lex$lookup,
    &qq_lex$gethashvaluez,
    &qq_lex$inithashtable,
    &qq_lex$addstname,
    &qq_lex$startlex,
    &qq_lex$addnamestr,
    &qq_lex$ps1,
    &qq_lex$ps2,
    &qq_lex$lex,
    &qq_lex$setinttype,
    &qq_lex$lxerror_s,
    &qq_lex$stacksource,
    &qq_lex$unstacksource,
    &qq_lex$makedecimal,
    &qq_lex$readdec,
    &qq_lex$readhex,
    &qq_lex$readbin,
    &qq_lex$readreal,
    &qq_lex$readrawxname,
    &qq_lex$start,
    &qq_lib$reportcterror,
    &qq_lib$geterrorinfo,
    &qq_lib$getlineno,
    &qq_lib$showerrorsource,
    &qq_lib$stopcompiler,
    &qq_lib$gerror,
    &qq_lib$gerror_s,
    &qq_lib$serror,
    &qq_lib$serror_s,
    &qq_lib$rxerror,
    &qq_lib$rxerror_s,
    &qq_lib$lxerror,
    &qq_lib$pcerror,
    &qq_lib$pcerror_s,
    &qq_lib$reportpcerror,
    &qq_lib$getpcerrorpos,
    &qq_lib$loaderror,
    &qq_lib$findmodulefrompc,
    &qq_lib$prterror,
    &qq_lib$pcustype,
    &qq_lib$pcustype_t,
    &qq_lib$pcmxtypes,
    &qq_lib$pcmxtypestt,
    &qq_lib$allocunitrec,
    &qq_lib$createintunit,
    &qq_lib$createboolunit,
    &qq_lib$createwordunit,
    &qq_lib$createrealunit,
    &qq_lib$createstringunit,
    &qq_lib$createunit0,
    &qq_lib$createunit1,
    &qq_lib$createunit2,
    &qq_lib$createname,
    &qq_lib$addlistunit,
    &qq_lib$getrangelwbunit,
    &qq_lib$getrangeupbunit,
    &qq_lib$createavname,
    &qq_lib$convtostringz,
    &qq_lib$findprocname,
    &qq_lib$strexpr,
    &qq_lib$strexpr_s,
    &qq_lib$jeval,
    &qq_lib$additem,
    &qq_lib$isalphanum,
    &qq_lib$getopcname,
    &qq_lib$convertstring,
    &qq_lib$extractstringz,
    &qq_lib$createavnamex,
    &qq_lib$storemode,
    &qq_lib$nextpoweroftwo,
    &qq_lib$raiseexception,
    &qq_lib$raise_error,
    &qq_lib$default_exception,
    &qq_lib$testelem,
    &qq_lib$setelem,
    &qq_lib$setelemblock,
    &qq_lib$ispoweroftwo,
    &qq_lib$deleteunit,
    &qq_lib$getenumname,
    &qq_lib$start,
    &qq_lists$start,
    &qq_lists$var_empty_list,
    &qq_lists$var_make_list,
    &qq_lists$obj_newlist,
    &qq_lists$obj_free_list,
    &qq_lists$var_getix_list,
    &qq_lists$var_getslice_list,
    &qq_lists$var_getixref_list,
    &qq_lists$var_putix_list,
    &qq_lists$var_putslice_list,
    &qq_lists$obj_append_list,
    &qq_lists$obj_resize_list,
    &qq_lists$var_appendto_list,
    &qq_lists$var_dupl_list,
    &qq_lists$var_mul_list,
    &qq_lists$var_equal_list,
    &qq_lists$var_concatto_list,
    &qq_lists$var_inx_list,
    &qq_lists$var_nextiter_list,
    &qq_modules$readprojectfile,
    &qq_modules$initheadervars,
    &qq_modules$readmoduledir,
    &qq_modules$addmodule,
    &qq_modules$addsubprogram,
    &qq_modules$addfirstsubprogram,
    &qq_modules$readsubprogram,
    &qq_modules$readimport,
    &qq_modules$readvar,
    &qq_modules$fixpath,
    &qq_modules$setmixedprogram,
    &qq_modules$setmixedimport,
    &qq_modules$loadmodules,
    &qq_modules$loadmodule,
    &qq_modules$addsyslib,
    &qq_modules$getsupportfile,
    &qq_modules$isabspath,
    &qq_modules$loadsourcefile,
    &qq_modules$readfileline,
    &qq_modules$findnextlineheader,
    &qq_modules$loadbundledfile,
    &qq_modules$loadqafile,
    &qq_modules$start,
    &qq_names$addglobalname,
    &qq_names$newstrec,
    &qq_names$addsymbol,
    &qq_names$addproc,
    &qq_names$createstroot,
    &qq_names$newusertypex,
    &qq_names$resolvedottedname,
    &qq_names$addgenfield,
    &qq_names$addusertype,
    &qq_names$makereftype,
    &qq_names$makeaxtype,
    &qq_names$makeslicetype,
    &qq_names$makestrtype,
    &qq_names$addanontype,
    &qq_names$createusertype,
    &qq_names$getalignment,
    &qq_names$duplfield,
    &qq_names$writesig,
    &qq_names$writedocs,
    &qq_names$createdupldef,
    &qq_names$createnewmoduledef,
    &qq_names$start,
    &qq_optim$optimise_module,
    &qq_optim$putnops,
    &qq_optim$optimise_op,
    &qq_optim$start,
    &qq_packed$var_loadpacked,
    &qq_packed$var_storepacked,
    &qq_packed$setfslength,
    &qq_packed$getfslength,
    &qq_packed$var_make_struct,
    &qq_packed$obj_new_struct,
    &qq_packed$var_dupl_struct,
    &qq_packed$obj_free_struct,
    &qq_packed$var_equal_struct,
    &qq_packed$var_getix_struct,
    &qq_packed$start,
    &qq_parse$parsemodule,
    &qq_parse$readexpression,
    &qq_parse$readassignment,
    &qq_parse$readorterms,
    &qq_parse$readandterms,
    &qq_parse$readcmpterms,
    &qq_parse$readinterms,
    &qq_parse$readrangeterm,
    &qq_parse$readaddterms,
    &qq_parse$readmulterms,
    &qq_parse$readpowerterms,
    &qq_parse$readterm2,
    &qq_parse$readtermsuffix,
    &qq_parse$readterm,
    &qq_parse$readxunit,
    &qq_parse$readsunit,
    &qq_parse$checksymbol,
    &qq_parse$checkequals,
    &qq_parse$checkbegin,
    &qq_parse$checkbeginend,
    &qq_parse$skipsemi,
    &qq_parse$readindex,
    &qq_parse$readdotsuffix,
    &qq_parse$readslist,
    &qq_parse$readcondsuffix,
    &qq_parse$readkeyindex,
    &qq_parse$readlbrack,
    &qq_parse$readif,
    &qq_parse$checkend,
    &qq_parse$readunless,
    &qq_parse$readwhile,
    &qq_parse$readrepeat,
    &qq_parse$readfor,
    &qq_parse$readdo,
    &qq_parse$readto,
    &qq_parse$makeblock,
    &qq_parse$readvardef,
    &qq_parse$readconstdef,
    &qq_parse$readreturn,
    &qq_parse$readprint,
    &qq_parse$readread,
    &qq_parse$readloopcontrol,
    &qq_parse$readintunit,
    &qq_parse$readswitchcase,
    &qq_parse$readgoto,
    &qq_parse$readstop,
    &qq_parse$readcast,
    &qq_parse$readset,
    &qq_parse$readtabledef,
    &qq_parse$readtry,
    &qq_parse$readsprint,
    &qq_parse$readsread,
    &qq_parse$readimportdll,
    &qq_parse$readffiparams,
    &qq_parse$readtypeparams,
    &qq_parse$readtypenameparams,
    &qq_parse$readrecorddef,
    &qq_parse$readrecordbody,
    &qq_parse$readrecordfields,
    &qq_parse$readstructbody,
    &qq_parse$addstructflag,
    &qq_parse$readprocdef,
    &qq_parse$readatfield,
    &qq_parse$istypestarter,
    &qq_parse$readmacrodef,
    &qq_parse$readhostparams,
    &qq_parse$pushlisttype,
    &qq_parse$poplisttype,
    &qq_parse$readcompilervar,
    &qq_parse$readmap,
    &qq_parse$lexchecksymbol,
    &qq_parse$readtypedef,
    &qq_parse$readtypespec,
    &qq_parse$readreturntype,
    &qq_parse$readprocsig,
    &qq_parse$readparams,
    &qq_parse$readparams_names,
    &qq_parse$checkoperator,
    &qq_parse$readlist,
    &qq_parse$start,
    &qq_print$pch_print,
    &qq_print$pch_print_nf,
    &qq_print$pch_printnogap,
    &qq_print$pch_println,
    &qq_print$pch_reread,
    &qq_print$pch_rereadln,
    &qq_print$pch_startprint,
    &qq_print$pch_startprintcon,
    &qq_print$pch_endprint,
    &qq_print$pch_strstartprint,
    &qq_print$pch_strendprint,
    &qq_print$pch_printspace,
    &qq_print$pch_readln,
    &qq_print$pc_readlinen,
    &qq_print$pch_sread,
    &qq_print$pch_sreadln,
    &qq_print$readname,
    &qq_print$readstring,
    &qq_print$readint,
    &qq_print$readhex,
    &qq_print$readbin,
    &qq_print$readreal,
    &qq_print$getreadfmtcode,
    &qq_print$stepkbpos,
    &qq_print$readany,
    &qq_print$readitem,
    &qq_print$strtoreal,
    &qq_print$strtoint,
    &qq_print$printnextfmtchars,
    &qq_print$pch_setformat,
    &qq_print$pc_getfmt,
    &qq_print$pc_strtofmt,
    &qq_print$initfmtcode,
    &qq_print$i64mintostr,
    &qq_print$u64tostr,
    &qq_print$i64tostrfmt,
    &qq_print$u64tostrfmt,
    &qq_print$strtostrfmt,
    &qq_print$expandstr,
    &qq_print$addstring,
    &qq_print$domultichar,
    &qq_print$printstr_n,
    &qq_print$pch_strtoval,
    &qq_print$tostr_int,
    &qq_print$tostr_word,
    &qq_print$tostr_real,
    &qq_print$tostr_str,
    &qq_print$pch_tostr,
    &qq_print$tostr_list,
    &qq_print$tostr_iterator,
    &qq_print$tostr_range,
    &qq_print$tostr_array,
    &qq_print$tostr_bits,
    &qq_print$tostr_struct,
    &qq_print$tostr_set,
    &qq_print$tostr_dict,
    &qq_print$tostr_decimal,
    &qq_print$tostr,
    &qq_print$tostr_record,
    &qq_print$start,
    &qq_pclgen$evalunit,
    &qq_pclgen$gencodemodule,
    &qq_pclgen$do_procdef,
    &qq_pclgen$genprocentry,
    &qq_pclgen$genprocexit,
    &qq_pclgen$evalref,
    &qq_pclgen$genjumpcond,
    &qq_pclgen$gcomparejump,
    &qq_pclgen$genjumpl,
    &qq_pclgen$reversecond,
    &qq_pclgen$stacklooplabels,
    &qq_pclgen$unstacklooplabels,
    &qq_pclgen$findlooplabel,
    &qq_pclgen$do_assign,
    &qq_pclgen$do_bin,
    &qq_pclgen$do_binref,
    &qq_pclgen$do_unary,
    &qq_pclgen$do_unaryref,
    &qq_pclgen$do_pushlist,
    &qq_pclgen$do_makedict,
    &qq_pclgen$do_call,
    &qq_pclgen$pushparams,
    &qq_pclgen$evalparam,
    &qq_pclgen$pushkwdparams,
    &qq_pclgen$do_if,
    &qq_pclgen$do_do,
    &qq_pclgen$do_exit,
    &qq_pclgen$do_to,
    &qq_pclgen$do_while,
    &qq_pclgen$do_repeat,
    &qq_pclgen$do_for,
    &qq_pclgen$do_forx,
    &qq_pclgen$do_print,
    &qq_pclgen$do_fprint,
    &qq_pclgen$do_read,
    &qq_pclgen$do_forall,
    &qq_pclgen$do_case,
    &qq_pclgen$do_case_nc,
    &qq_pclgen$do_try,
    &qq_pclgen$unitstoarray,
    &qq_pclgen$do_select,
    &qq_pclgen$do_andl,
    &qq_pclgen$do_orl,
    &qq_pclgen$do_incr,
    &qq_pclgen$do_new,
    &qq_pclgen$checkblockreturn,
    &qq_pclgen$do_callhost,
    &qq_pclgen$callhostfn,
    &qq_pclgen$genfree,
    &qq_pclgen$do_return,
    &qq_pclgen$do_multassign,
    &qq_pclgen$do_store,
    &qq_pclgen$getconstvalue,
    &qq_pclgen$do_convert,
    &qq_pclgen$checkelems,
    &qq_pclgen$do_switch,
    &qq_pclgen$do_simpleswitch,
    &qq_pclgen$do_makerecordkv,
    &qq_pclgen$do_idiv,
    &qq_pclgen$do_irem,
    &qq_pclgen$do_map,
    &qq_pclgen$pushstring,
    &qq_pclgen$start,
    &qq_pcllib$start,
    &qq_pcllib$resetpcl,
    &qq_pcllib$genpc,
    &qq_pcllib$genopnd_int,
    &qq_pcllib$genopnd_name,
    &qq_pcllib$genpc_int,
    &qq_pcllib$genpc_int2,
    &qq_pcllib$genpc_int4,
    &qq_pcllib$genpc_name,
    &qq_pcllib$genopnd_strz,
    &qq_pcllib$genopnd_str,
    &qq_pcllib$genopnd_obj,
    &qq_pcllib$genpc_real,
    &qq_pcllib$genpc_lab,
    &qq_pcllib$genopnd_lab,
    &qq_pcllib$gencomment,
    &qq_pcllib$getdottedname,
    &qq_pcllib$extendpcldata,
    &qq_pcllib$extendlabeltable,
    &qq_pcllib$pushint,
    &qq_pcllib$pushreal,
    &qq_pcllib$definelabel,
    &qq_pcllib$createfwdlabel,
    &qq_pcllib$definefwdlabel,
    &qq_pcllib$isstatic,
    &qq_records$var_make_record,
    &qq_records$obj_new_record,
    &qq_records$obj_free_record,
    &qq_records$var_dupl_record,
    &qq_records$var_equal_record,
    &qq_records$var_getix_record,
    &qq_records$var_putix_record,
    &qq_records$var_getixref_record,
    &qq_records$start,
    &qq_resolve$rx_module,
    &qq_resolve$rx_passdef,
    &qq_resolve$rx_deflist,
    &qq_resolve$rx_unit,
    &qq_resolve$rx_unitlist,
    &qq_resolve$evalmonop,
    &qq_resolve$evalbinop,
    &qq_resolve$makeintconst,
    &qq_resolve$makerealconst,
    &qq_resolve$resolvename,
    &qq_resolve$resolvetopname,
    &qq_resolve$resolvedot,
    &qq_resolve$resolvedot_sym,
    &qq_resolve$finddupl,
    &qq_resolve$expandmacro,
    &qq_resolve$copylistunit,
    &qq_resolve$copyunit,
    &qq_resolve$replaceunit,
    &qq_resolve$fixmode,
    &qq_resolve$fixmode2,
    &qq_resolve$fixusertypes,
    &qq_resolve$tx_typetable,
    &qq_resolve$getconstint,
    &qq_resolve$converttype,
    &qq_resolve$scanstruct,
    &qq_resolve$dobaseclass,
    &qq_resolve$start,
    &qq_sets$obj_free_set,
    &qq_sets$var_dupl_set,
    &qq_sets$var_equal_set,
    &qq_sets$getsetbytes,
    &qq_sets$var_make_set,
    &qq_sets$obj_newset,
    &qq_sets$var_emptyset,
    &qq_sets$var_getix_set,
    &qq_sets$var_putix_set,
    &qq_sets$var_getixref_set,
    &qq_sets$getoffset,
    &qq_sets$var_in_set,
    &qq_sets$iresizeset,
    &qq_sets$obj_resize_set,
    &qq_sets$iorsetbits,
    &qq_sets$ixorsetbits,
    &qq_sets$iandsetbits,
    &qq_sets$inotsetbits,
    &qq_sets$var_iorto_set,
    &qq_sets$var_iandto_set,
    &qq_sets$var_ixorto_set,
    &qq_sets$var_inotto_set,
    &qq_sets$var_checkiter_set,
    &qq_sets$var_nextiter_set,
    &qq_sets$start,
    &qq_strings$start,
    &qq_strings$var_empty_string,
    &qq_strings$var_make_string,
    &qq_strings$var_make_stringn,
    &qq_strings$obj_new_string,
    &qq_strings$obj_make_string,
    &qq_strings$obj_make_stringn,
    &qq_strings$obj_free_string,
    &qq_strings$var_dupl_string,
    &qq_strings$var_getix_string,
    &qq_strings$var_getixref_string,
    &qq_strings$var_getdotix_string,
    &qq_strings$var_getdotixref_string,
    &qq_strings$var_getslice_string,
    &qq_strings$stringslice,
    &qq_strings$var_putix_string,
    &qq_strings$var_putslice_string,
    &qq_strings$var_putdotix_string,
    &qq_strings$obj_resize_string,
    &qq_strings$var_add_string,
    &qq_strings$var_addto_string,
    &qq_strings$var_addto_string_ch,
    &qq_strings$var_equal_string,
    &qq_strings$var_compare_string,
    &qq_strings$cmpstring_len,
    &qq_strings$var_inx_string,
    &qq_strings$var_iconvcase,
    &qq_strings$var_makestrslicexobj,
    &qq_strings$obj_make_strslicexobj,
    &qq_strings$var_asc,
    &qq_strings$var_new_string,
    &qq_strings$var_new_stringn,
    &qq_strings$var_mul_string,
    &qq_strings$var_convert_string_list,
    &qq_strings$var_expand_string,
    &qq_strings$var_makechar,
    &qq_strings$var_nextiter_string,
    &qq_syslibs$findsyslib,
    &qq_syslibs$start,
    &qq_tables$start,
    &qq_dummyshow$printunit,
    &qq_dummyshow$writeallpcl,
    &qq_dummyshow$printglobalsymbols,
    &qq_dummyshow$printst,
    &qq_dummyshow$printglobalsymbols_full,
    &qq_dummyshow$printstfull,
    &qq_dummyshow$printtypetables,
    &qq_dummyshow$getpclname,
    &qq_dummyshow$showlogfile,
    &qq_dummyshow$showast,
    &qq_dummyshow$showpcl,
    &qq_dummyshow$showmpl,
    &qq_dummyshow$printsymbol,
    &qq_dummyshow$strmode,
    &qq_dummyshow$start,
    &qq_vars$var_unshareu,
    &qq_vars$obj_shareu,
    &qq_vars$void_new,
    &qq_vars$obj_new,
    &qq_vars$var_getintvalue,
    &qq_vars$var_fromobj,
    &qq_vars$var_free,
    &qq_vars$var_duplu,
    &qq_vars$var_neg,
    &qq_vars$var_abs,
    &qq_vars$var_inot,
    &qq_vars$var_istruel,
    &qq_vars$var_negto,
    &qq_vars$var_absto,
    &qq_vars$var_inotto,
    &qq_vars$var_add,
    &qq_vars$var_addmixed,
    &qq_vars$var_sub,
    &qq_vars$var_submixed,
    &qq_vars$var_mul,
    &qq_vars$var_mulmixed,
    &qq_vars$var_div,
    &qq_vars$var_divmixed,
    &qq_vars$var_idiv,
    &qq_vars$var_idivmixed,
    &qq_vars$var_irem,
    &qq_vars$var_iremmixed,
    &qq_vars$var_iand,
    &qq_vars$var_iandmixed,
    &qq_vars$var_ior,
    &qq_vars$var_iormixed,
    &qq_vars$var_ixor,
    &qq_vars$var_ixormixed,
    &qq_vars$var_shl,
    &qq_vars$var_shlmixed,
    &qq_vars$var_shr,
    &qq_vars$var_shrmixed,
    &qq_vars$var_in,
    &qq_vars$var_inx,
    &qq_vars$var_equal,
    &qq_vars$var_equalmixed,
    &qq_vars$var_compare,
    &qq_vars$var_comparemixed,
    &qq_vars$var_concat,
    &qq_vars$var_append,
    &qq_vars$var_min,
    &qq_vars$var_minmixed,
    &qq_vars$var_max,
    &qq_vars$var_maxmixed,
    &qq_vars$var_addto,
    &qq_vars$var_multo,
    &qq_vars$var_iandto,
    &qq_vars$var_iorto,
    &qq_vars$var_ixorto,
    &qq_vars$var_shlto,
    &qq_vars$var_shrto,
    &qq_vars$var_concatto,
    &qq_vars$var_appendto,
    &qq_vars$var_getix,
    &qq_vars$var_putix,
    &qq_vars$var_getixref,
    &qq_vars$var_getslice,
    &qq_vars$var_putslice,
    &qq_vars$var_getdotix,
    &qq_vars$var_putdotix,
    &qq_vars$var_getdotixref,
    &qq_vars$var_getdotslice,
    &qq_vars$var_putdotslice,
    &qq_vars$var_getdotsliceref,
    &qq_vars$var_expand,
    &qq_vars$var_minto,
    &qq_vars$var_maxto,
    &qq_vars$var_inplace,
    &qq_vars$var_inplace_unary,
    &qq_vars$var_loadptr,
    &qq_vars$var_storeptr,
    &qq_vars$var_loadbit,
    &qq_vars$var_storebit,
    &qq_vars$var_convert,
    &qq_vars$var_gethashvalue,
    &qq_vars$var_objtovar,
    &qq_vars$var_putdotix_intint,
    &qq_vars$var_power,
    &qq_vars$var_powermixed,
    &qq_vars$start,
    &msysc$m_init,
    &msysc$m_getdotindex,
    &msysc$m_setdotindex,
    &msysc$m_getdotslice,
    &msysc$m_setdotslice,
    &msysc$m_get_nprocs,
    &msysc$m_get_nexports,
    &msysc$m_get_procname,
    &msysc$m_get_procaddr,
    &msysc$m_get_procexport,
    &msysc$pushio,
    &msysc$m_print_startfile,
    &msysc$m_print_startstr,
    &msysc$m_print_startptr,
    &msysc$m_print_startcon,
    &msysc$m_print_setfmt,
    &msysc$m_print_end,
    &msysc$m_print_ptr,
    &msysc$m_print_i64,
    &msysc$m_print_u64,
    &msysc$m_print_r64,
    &msysc$m_print_r32,
    &msysc$m_print_c8,
    &msysc$m_print_str,
    &msysc$m_print_newline,
    &msysc$m_print_nogap,
    &msysc$m_print_space,
    &msysc$printstr,
    &msysc$printstr_n,
    &msysc$printstrn_app,
    &msysc$makezstring,
    &msysc$freezstring,
    &msysc$printchar,
    &msysc$nextfmtchars,
    &msysc$strtofmt,
    &msysc$domultichar,
    &msysc$expandstr,
    &msysc$u64tostr,
    &msysc$i64tostrfmt,
    &msysc$u64tostrfmt,
    &msysc$i64mintostr,
    &msysc$strtostrfmt,
    &msysc$tostr_i64,
    &msysc$tostr_u64,
    &msysc$tostr_r64,
    &msysc$tostr_str,
    &msysc$getfmt,
    &msysc$strint,
    &msysc$getstrint,
    &msysc$strword,
    &msysc$strreal,
    &msysc$getstr,
    &msysc$initreadbuffer,
    &msysc$m_read_conline,
    &msysc$m_read_fileline,
    &msysc$m_read_strline,
    &msysc$readitem,
    &msysc$strtoint,
    &msysc$m_read_i64,
    &msysc$m_read_r64,
    &msysc$m_read_str,
    &msysc$readstr,
    &msysc$rereadln,
    &msysc$reread,
    &msysc$valint,
    &msysc$valreal,
    &msysc$iconvlcn,
    &msysc$iconvucn,
    &msysc$convlcstring,
    &msysc$convucstring,
    &msysc$m_power_i64,
    &msysc$m_intoverflow,
    &msysc$m_dotindex,
    &msysc$m_dotslice,
    &msysc$m_popdotindex,
    &msysc$m_popdotslice,
    &msysc$m_imin,
    &msysc$m_imax,
    &msysc$m_sign,
    &msysc$m_tp_i64tor64,
    &msysc$m_tp_r64toi64,
    &msysc$m_tp_reftoi64,
    &msysc$m_tp_i64toref,
    &msysc$start,
    &mlib$pcm_alloc,
    &mlib$pcm_free,
    &mlib$pcm_freeac,
    &mlib$pcm_clearmem,
    &mlib$pcm_init,
    &mlib$pcm_getac,
    &mlib$pcm_newblock,
    &mlib$pcm_round,
    &mlib$pcm_allocz,
    &mlib$pcm_copyheapstring,
    &mlib$pcm_copyheapstringn,
    &mlib$pcm_copyheapblock,
    &mlib$allocmem,
    &mlib$reallocmem,
    &mlib$abortprogram,
    &mlib$getfilesize,
    &mlib$readrandom,
    &mlib$writerandom,
    &mlib$setfilepos,
    &mlib$getfilepos,
    &mlib$readfile,
    &mlib$writefile,
    &mlib$checkfile,
    &mlib$readlinen,
    &mlib$iconvlcn,
    &mlib$iconvucn,
    &mlib$convlcstring,
    &mlib$convucstring,
    &mlib$changeext,
    &mlib$extractext,
    &mlib$extractpath,
    &mlib$extractfile,
    &mlib$extractbasefile,
    &mlib$addext,
    &mlib$pcm_alloc32,
    &mlib$pcm_free32,
    &mlib$outbyte,
    &mlib$outword16,
    &mlib$outword32,
    &mlib$outword64,
    &mlib$outstring,
    &mlib$outblock,
    &mlib$myeof,
    &mlib$strbuffer_add,
    &mlib$gs_init,
    &mlib$gs_free,
    &mlib$gs_str,
    &mlib$gs_char,
    &mlib$gs_strn,
    &mlib$gs_strvar,
    &mlib$gs_strint,
    &mlib$gs_strln,
    &mlib$gs_strsp,
    &mlib$gs_line,
    &mlib$gs_getcol,
    &mlib$gs_leftstr,
    &mlib$gs_leftint,
    &mlib$gs_padto,
    &mlib$gs_println,
    &mlib$nextcmdparamnew,
    &mlib$readnextfileitem,
    &mlib$ipadstr,
    &mlib$padstr,
    &mlib$chr,
    &mlib$cmpstring,
    &mlib$cmpstringn,
    &mlib$eqstring,
    &mlib$cmpbytes,
    &mlib$eqbytes,
    &mlib$mseed,
    &mlib$mrandom,
    &mlib$mrandomp,
    &mlib$mrandomint,
    &mlib$mrandomrange,
    &mlib$mrandomreal,
    &mlib$mrandomreal1,
    &mlib$readline,
    &mlib$findfunction,
    &mlib$roundtoblock,
    &mlib$start,
    &mclib$start,
    &mwindows$os_init,
    &mwindows$os_execwait,
    &mwindows$os_execcmd,
    &mwindows$os_getch,
    &mwindows$os_kbhit,
    &mwindows$os_getdllinst,
    &mwindows$os_getdllprocaddr,
    &mwindows$os_initwindows,
    &mwindows$os_gxregisterclass,
    &mwindows$mainwndproc,
    &mwindows$os_setmesshandler,
    &mwindows$os_getchx,
    &mwindows$os_getos,
    &mwindows$os_gethostsize,
    &mwindows$os_shellexec,
    &mwindows$os_sleep,
    &mwindows$os_getstdin,
    &mwindows$os_getstdout,
    &mwindows$os_gethostname,
    &mwindows$os_getmpath,
    &mwindows$os_clock,
    &mwindows$os_ticks,
    &mwindows$os_hptimer,
    &mwindows$os_iswindows,
    &mwindows$os_getsystime,
    &mwindows$os_peek,
    &mwindows$os_allocexecmem,
    &mwindows$start,
    &mwindllc$os_calldllfunction,
    &mwindllc$os_pushargs,
    &mwindllc$calldll_cint,
    &mwindllc$calldll_creal,
    &mwindllc$os_dummycall,
    &mwindllc$start,
0};
static u8 *  msysc$_fnnames[]= {
    (byte*)"main",
    (byte*)"getinputoptions",
    (byte*)"do_option",
    (byte*)"runqprogram",
    (byte*)"load_program",
    (byte*)"parse_program",
    (byte*)"rx_program",
    (byte*)"gxpcl_program",
    (byte*)"optimise_program",
    (byte*)"fixup_program",
    (byte*)"writeqa_program",
    (byte*)"initprogram",
    (byte*)"fixproc",
    (byte*)"fixupmodule",
    (byte*)"runprogram",
    (byte*)"disploop",
    (byte*)"disploop_fn",
    (byte*)"disploop_deb",
    (byte*)"setcmdmap",
    (byte*)"runproc_m",
    (byte*)"runproc",
    (byte*)"start",
    (byte*)"var_empty_array",
    (byte*)"obj_free_array",
    (byte*)"obj_free_vector",
    (byte*)"var_make_array",
    (byte*)"obj_newarray",
    (byte*)"obj_newarray_u",
    (byte*)"var_getix_array",
    (byte*)"var_putix_array",
    (byte*)"var_getixref_array",
    (byte*)"obj_append_array",
    (byte*)"var_appendto_array",
    (byte*)"obj_resize_array",
    (byte*)"var_dupl_array",
    (byte*)"var_dupl_vector",
    (byte*)"var_equal_array",
    (byte*)"var_concatto_array",
    (byte*)"var_getslice_array",
    (byte*)"var_putslice_array",
    (byte*)"u8inarray",
    (byte*)"u16inarray",
    (byte*)"u32inarray",
    (byte*)"u64inarray",
    (byte*)"var_inx_array",
    (byte*)"var_expand_array",
    (byte*)"var_nextiter_array",
    (byte*)"start",
    (byte*)"obj_free_bits",
    (byte*)"var_make_bits",
    (byte*)"obj_newbits",
    (byte*)"var_getix_bits",
    (byte*)"var_putix_bits",
    (byte*)"var_getixref_bits",
    (byte*)"getindexoffset",
    (byte*)"obj_append_bits",
    (byte*)"var_appendto_bits",
    (byte*)"obj_resize_bits",
    (byte*)"var_dupl_bits",
    (byte*)"var_equal_bits",
    (byte*)"var_concatto_bits",
    (byte*)"var_getslice_bits",
    (byte*)"var_putslice_bits",
    (byte*)"bits_bytesize",
    (byte*)"getbitssize",
    (byte*)"start",
    (byte*)"calldll",
    (byte*)"getlibprocaddr",
    (byte*)"vartopacked",
    (byte*)"packedtovar",
    (byte*)"loaddllfunction",
    (byte*)"start",
    (byte*)"obj_free_dec",
    (byte*)"var_dupl_dec",
    (byte*)"var_empty_dec",
    (byte*)"var_make_dec_str",
    (byte*)"var_make_dec_int",
    (byte*)"badnumber",
    (byte*)"bn_makestr",
    (byte*)"readexpon",
    (byte*)"bn_makeint",
    (byte*)"var_tostr_dec",
    (byte*)"obj_tostr_dec",
    (byte*)"tostring_scient",
    (byte*)"tostring_float",
    (byte*)"strvaln",
    (byte*)"bn_isint",
    (byte*)"obj_len_dec",
    (byte*)"bn_iszero",
    (byte*)"var_equal_dec",
    (byte*)"var_add_dec",
    (byte*)"var_sub_dec",
    (byte*)"var_mul_dec",
    (byte*)"var_div_dec",
    (byte*)"var_idiv_dec",
    (byte*)"var_irem_dec",
    (byte*)"var_neg_dec",
    (byte*)"var_abs_dec",
    (byte*)"var_compare_dec",
    (byte*)"bn_cmp",
    (byte*)"bn_equal",
    (byte*)"bn_add",
    (byte*)"bn_sub",
    (byte*)"bn_addu",
    (byte*)"bn_subu",
    (byte*)"makebignum",
    (byte*)"makesmallnum",
    (byte*)"smalltobig",
    (byte*)"freesmall",
    (byte*)"bn_init",
    (byte*)"bn_setzero",
    (byte*)"bn_move",
    (byte*)"bn_dupl",
    (byte*)"bn_setinf",
    (byte*)"bn_setnan",
    (byte*)"var_setnan",
    (byte*)"var_setinf",
    (byte*)"getbintype",
    (byte*)"bn_negto",
    (byte*)"bn_absto",
    (byte*)"bn_mul",
    (byte*)"bn_mulp",
    (byte*)"bn_mulu",
    (byte*)"smallmulto",
    (byte*)"bn_div",
    (byte*)"bn_idiv",
    (byte*)"bn_idivrem",
    (byte*)"bn_irem",
    (byte*)"bn_idivu",
    (byte*)"bn_fdivu",
    (byte*)"smalldiv",
    (byte*)"smallsubto",
    (byte*)"bn_getprec",
    (byte*)"bn_setprec",
    (byte*)"bn_getglobalprec",
    (byte*)"bn_setglobalprec",
    (byte*)"bn_makefloat",
    (byte*)"dectemp",
    (byte*)"freedectemp",
    (byte*)"bn_ipower",
    (byte*)"var_power_dec",
    (byte*)"var_convert_dec_int",
    (byte*)"bn_toint",
    (byte*)"start",
    (byte*)"start",
    (byte*)"var_make_dict",
    (byte*)"obj_new_dict",
    (byte*)"obj_free_dict",
    (byte*)"var_dupl_dict",
    (byte*)"var_equal_dict",
    (byte*)"var_finddictitem",
    (byte*)"expanddict",
    (byte*)"adddictitem",
    (byte*)"var_checkiter_dict",
    (byte*)"var_nextiter_dict",
    (byte*)"start",
    (byte*)"var_make_iter",
    (byte*)"var_check_iter",
    (byte*)"var_next_iter",
    (byte*)"obj_free_iter",
    (byte*)"var_dupl_iter",
    (byte*)"start",
    (byte*)"asmavailable",
    (byte*)"disploop_asm",
    (byte*)"initjhandlers",
    (byte*)"start",
    (byte*)"initkhandlers",
    (byte*)"kunimpl",
    (byte*)"k_pushci",
    (byte*)"k_pushtrue",
    (byte*)"k_pushfalse",
    (byte*)"k_pushcu",
    (byte*)"k_pushnil",
    (byte*)"k_pushcs",
    (byte*)"k_pushcr",
    (byte*)"k_pushenum",
    (byte*)"k_stop",
    (byte*)"k_stoprunproc",
    (byte*)"k_pushm",
    (byte*)"k_pushf",
    (byte*)"k_pushff",
    (byte*)"k_pushmref",
    (byte*)"k_pushfref",
    (byte*)"k_popm",
    (byte*)"k_storem",
    (byte*)"k_zpopm",
    (byte*)"k_popf",
    (byte*)"k_storef",
    (byte*)"k_zpopf",
    (byte*)"k_popretval",
    (byte*)"k_tom",
    (byte*)"k_tof",
    (byte*)"k_add",
    (byte*)"k_sub",
    (byte*)"k_mul",
    (byte*)"k_div",
    (byte*)"k_idiv",
    (byte*)"k_irem",
    (byte*)"k_iand",
    (byte*)"k_ior",
    (byte*)"k_ixor",
    (byte*)"k_shl",
    (byte*)"k_shr",
    (byte*)"k_sqr",
    (byte*)"k_sign",
    (byte*)"k_sqrt",
    (byte*)"k_sin",
    (byte*)"k_cos",
    (byte*)"k_tan",
    (byte*)"k_asin",
    (byte*)"k_acos",
    (byte*)"k_atan",
    (byte*)"k_ln",
    (byte*)"k_log",
    (byte*)"k_lg",
    (byte*)"k_exp",
    (byte*)"k_round",
    (byte*)"k_floor",
    (byte*)"k_ceil",
    (byte*)"k_fract",
    (byte*)"k_neg",
    (byte*)"k_negto",
    (byte*)"k_absto",
    (byte*)"k_inotto",
    (byte*)"k_atan2",
    (byte*)"k_fmod",
    (byte*)"k_abs",
    (byte*)"k_inot",
    (byte*)"k_istruel",
    (byte*)"k_notl",
    (byte*)"k_jumpeq",
    (byte*)"k_jumpne",
    (byte*)"k_jumplt",
    (byte*)"k_jumple",
    (byte*)"k_jumpge",
    (byte*)"k_jumpgt",
    (byte*)"k_jumpfalse",
    (byte*)"k_jumptrue",
    (byte*)"k_incrtom",
    (byte*)"k_incrtof",
    (byte*)"k_decrtom",
    (byte*)"k_decrtof",
    (byte*)"k_incrload",
    (byte*)"k_loadincr",
    (byte*)"k_decrload",
    (byte*)"k_loaddecr",
    (byte*)"k_incrptr",
    (byte*)"k_decrptr",
    (byte*)"k_pushvoid",
    (byte*)"k_callproc",
    (byte*)"k_callptr",
    (byte*)"k_procentry",
    (byte*)"k_return",
    (byte*)"k_return0",
    (byte*)"k_unshare",
    (byte*)"k_unshare1",
    (byte*)"k_formci",
    (byte*)"k_forfci",
    (byte*)"k_fordmci",
    (byte*)"k_fordfci",
    (byte*)"k_formm",
    (byte*)"k_fordmm",
    (byte*)"k_forff",
    (byte*)"k_fordff",
    (byte*)"k_comment",
    (byte*)"k_makelist",
    (byte*)"k_makedict",
    (byte*)"k_makeset",
    (byte*)"k_makerecord",
    (byte*)"k_makestruct",
    (byte*)"k_makearray",
    (byte*)"k_makebits",
    (byte*)"k_index",
    (byte*)"k_popindex",
    (byte*)"k_indexref",
    (byte*)"k_keyindex",
    (byte*)"k_popkeyindex",
    (byte*)"k_keyindexref",
    (byte*)"k_dot",
    (byte*)"k_dotref",
    (byte*)"k_popdot",
    (byte*)"k_dotindex",
    (byte*)"k_dotindexref",
    (byte*)"k_popdotindex",
    (byte*)"k_len",
    (byte*)"k_upb",
    (byte*)"k_lwb",
    (byte*)"k_bounds",
    (byte*)"k_boundsx",
    (byte*)"do_bounds",
    (byte*)"k_dictitems",
    (byte*)"k_isfound",
    (byte*)"k_append",
    (byte*)"k_concat",
    (byte*)"k_appendto",
    (byte*)"k_concatto",
    (byte*)"k_addto",
    (byte*)"k_subto",
    (byte*)"k_multo",
    (byte*)"k_divto",
    (byte*)"k_idivto",
    (byte*)"k_iandto",
    (byte*)"k_iorto",
    (byte*)"k_ixorto",
    (byte*)"k_shlto",
    (byte*)"k_shrto",
    (byte*)"k_copy",
    (byte*)"k_dupl",
    (byte*)"k_makerange",
    (byte*)"k_makerangelen",
    (byte*)"k_makedecimal",
    (byte*)"resolvefield",
    (byte*)"k_pushptr",
    (byte*)"k_popptr",
    (byte*)"k_islist",
    (byte*)"k_isarray",
    (byte*)"k_isstring",
    (byte*)"k_isrecord",
    (byte*)"k_swap",
    (byte*)"k_jumptesteq",
    (byte*)"k_jumptestne",
    (byte*)"k_jump",
    (byte*)"k_jumpptr",
    (byte*)"k_incr",
    (byte*)"k_decr",
    (byte*)"k_chr",
    (byte*)"k_asc",
    (byte*)"k_pusht",
    (byte*)"k_type",
    (byte*)"k_basetype",
    (byte*)"k_usertype",
    (byte*)"k_elemtype",
    (byte*)"k_nop",
    (byte*)"k_modulecall",
    (byte*)"k_modulereturn",
    (byte*)"k_maxvalue",
    (byte*)"k_minvalue",
    (byte*)"k_callhost",
    (byte*)"k_expand",
    (byte*)"k_pushsymbol",
    (byte*)"k_eq",
    (byte*)"k_ne",
    (byte*)"k_lt",
    (byte*)"k_le",
    (byte*)"k_ge",
    (byte*)"k_gt",
    (byte*)"do_cmp",
    (byte*)"k_calldll",
    (byte*)"k_in",
    (byte*)"k_notin",
    (byte*)"k_inx",
    (byte*)"k_convrefpack",
    (byte*)"k_isdef",
    (byte*)"k_isvoid",
    (byte*)"k_isint",
    (byte*)"k_isnumber",
    (byte*)"k_ismutable",
    (byte*)"k_isreal",
    (byte*)"k_isrange",
    (byte*)"k_isset",
    (byte*)"k_ispointer",
    (byte*)"istype",
    (byte*)"k_convert",
    (byte*)"k_switch",
    (byte*)"k_bytesize",
    (byte*)"k_bitwidth",
    (byte*)"k_min",
    (byte*)"k_max",
    (byte*)"k_addsp",
    (byte*)"k_pushtry",
    (byte*)"k_raise",
    (byte*)"k_isequal",
    (byte*)"k_minto",
    (byte*)"k_maxto",
    (byte*)"k_power",
    (byte*)"domaths",
    (byte*)"getmaths",
    (byte*)"k_typepun",
    (byte*)"k_andlto",
    (byte*)"k_orlto",
    (byte*)"k_notlto",
    (byte*)"k_pushoperator",
    (byte*)"k_maps",
    (byte*)"k_mapss",
    (byte*)"k_idivrem",
    (byte*)"k_odd",
    (byte*)"k_even",
    (byte*)"start",
    (byte*)"callhostfunction",
    (byte*)"inithostlib",
    (byte*)"pch_leftstr",
    (byte*)"pch_rightstr",
    (byte*)"pch_convlc",
    (byte*)"pch_convuc",
    (byte*)"pch_waitkey",
    (byte*)"pch_execwait",
    (byte*)"pch_execcmd",
    (byte*)"pch_makestr",
    (byte*)"pch_makeref",
    (byte*)"pch_getcmdparam",
    (byte*)"pch_clock",
    (byte*)"pch_allocexec",
    (byte*)"pch_runnative",
    (byte*)"pch_setlwb",
    (byte*)"pch_ticks",
    (byte*)"pch_sleep",
    (byte*)"pch_random",
    (byte*)"pch_system",
    (byte*)"pch_$getparam",
    (byte*)"checkparam",
    (byte*)"leftstring",
    (byte*)"rightstring",
    (byte*)"padstring_right",
    (byte*)"padstring_left",
    (byte*)"getbounds",
    (byte*)"pch_new",
    (byte*)"pch_gethostname",
    (byte*)"pch_getprogname",
    (byte*)"pch_$test",
    (byte*)"pch_$test2",
    (byte*)"pch_$refcount",
    (byte*)"pch_testkey",
    (byte*)"pch_getos",
    (byte*)"pch_$procsymbols",
    (byte*)"pch_$symbolowner",
    (byte*)"pch_$symbolname",
    (byte*)"pch_$symboldefs",
    (byte*)"pch_setmesshandler",
    (byte*)"pch_$testcallback",
    (byte*)"pch_$smallmemtotal",
    (byte*)"pch_$id",
    (byte*)"pch_iswindows",
    (byte*)"pch_$setdebug",
    (byte*)"pch_copy",
    (byte*)"pch_gethash",
    (byte*)"pch_makeempty",
    (byte*)"pch_$infinity",
    (byte*)"pch_$nan",
    (byte*)"setcmdparam",
    (byte*)"pch_makeiter",
    (byte*)"pch_checkiter",
    (byte*)"pch_nextiter",
    (byte*)"start",
    (byte*)"lexreadtoken",
    (byte*)"lxreadstring",
    (byte*)"lexinit",
    (byte*)"readrawstring",
    (byte*)"lookup",
    (byte*)"gethashvaluez",
    (byte*)"inithashtable",
    (byte*)"addstname",
    (byte*)"startlex",
    (byte*)"addnamestr",
    (byte*)"ps1",
    (byte*)"ps2",
    (byte*)"lex",
    (byte*)"setinttype",
    (byte*)"lxerror_s",
    (byte*)"stacksource",
    (byte*)"unstacksource",
    (byte*)"makedecimal",
    (byte*)"readdec",
    (byte*)"readhex",
    (byte*)"readbin",
    (byte*)"readreal",
    (byte*)"readrawxname",
    (byte*)"start",
    (byte*)"reportcterror",
    (byte*)"geterrorinfo",
    (byte*)"getlineno",
    (byte*)"showerrorsource",
    (byte*)"stopcompiler",
    (byte*)"gerror",
    (byte*)"gerror_s",
    (byte*)"serror",
    (byte*)"serror_s",
    (byte*)"rxerror",
    (byte*)"rxerror_s",
    (byte*)"lxerror",
    (byte*)"pcerror",
    (byte*)"pcerror_s",
    (byte*)"reportpcerror",
    (byte*)"getpcerrorpos",
    (byte*)"loaderror",
    (byte*)"findmodulefrompc",
    (byte*)"prterror",
    (byte*)"pcustype",
    (byte*)"pcustype_t",
    (byte*)"pcmxtypes",
    (byte*)"pcmxtypestt",
    (byte*)"allocunitrec",
    (byte*)"createintunit",
    (byte*)"createboolunit",
    (byte*)"createwordunit",
    (byte*)"createrealunit",
    (byte*)"createstringunit",
    (byte*)"createunit0",
    (byte*)"createunit1",
    (byte*)"createunit2",
    (byte*)"createname",
    (byte*)"addlistunit",
    (byte*)"getrangelwbunit",
    (byte*)"getrangeupbunit",
    (byte*)"createavname",
    (byte*)"convtostringz",
    (byte*)"findprocname",
    (byte*)"strexpr",
    (byte*)"strexpr_s",
    (byte*)"jeval",
    (byte*)"additem",
    (byte*)"isalphanum",
    (byte*)"getopcname",
    (byte*)"convertstring",
    (byte*)"extractstringz",
    (byte*)"createavnamex",
    (byte*)"storemode",
    (byte*)"nextpoweroftwo",
    (byte*)"raiseexception",
    (byte*)"raise_error",
    (byte*)"default_exception",
    (byte*)"testelem",
    (byte*)"setelem",
    (byte*)"setelemblock",
    (byte*)"ispoweroftwo",
    (byte*)"deleteunit",
    (byte*)"getenumname",
    (byte*)"start",
    (byte*)"start",
    (byte*)"var_empty_list",
    (byte*)"var_make_list",
    (byte*)"obj_newlist",
    (byte*)"obj_free_list",
    (byte*)"var_getix_list",
    (byte*)"var_getslice_list",
    (byte*)"var_getixref_list",
    (byte*)"var_putix_list",
    (byte*)"var_putslice_list",
    (byte*)"obj_append_list",
    (byte*)"obj_resize_list",
    (byte*)"var_appendto_list",
    (byte*)"var_dupl_list",
    (byte*)"var_mul_list",
    (byte*)"var_equal_list",
    (byte*)"var_concatto_list",
    (byte*)"var_inx_list",
    (byte*)"var_nextiter_list",
    (byte*)"readprojectfile",
    (byte*)"initheadervars",
    (byte*)"readmoduledir",
    (byte*)"addmodule",
    (byte*)"addsubprogram",
    (byte*)"addfirstsubprogram",
    (byte*)"readsubprogram",
    (byte*)"readimport",
    (byte*)"readvar",
    (byte*)"fixpath",
    (byte*)"setmixedprogram",
    (byte*)"setmixedimport",
    (byte*)"loadmodules",
    (byte*)"loadmodule",
    (byte*)"addsyslib",
    (byte*)"getsupportfile",
    (byte*)"isabspath",
    (byte*)"loadsourcefile",
    (byte*)"readfileline",
    (byte*)"findnextlineheader",
    (byte*)"loadbundledfile",
    (byte*)"loadqafile",
    (byte*)"start",
    (byte*)"addglobalname",
    (byte*)"newstrec",
    (byte*)"addsymbol",
    (byte*)"addproc",
    (byte*)"createstroot",
    (byte*)"newusertypex",
    (byte*)"resolvedottedname",
    (byte*)"addgenfield",
    (byte*)"addusertype",
    (byte*)"makereftype",
    (byte*)"makeaxtype",
    (byte*)"makeslicetype",
    (byte*)"makestrtype",
    (byte*)"addanontype",
    (byte*)"createusertype",
    (byte*)"getalignment",
    (byte*)"duplfield",
    (byte*)"writesig",
    (byte*)"writedocs",
    (byte*)"createdupldef",
    (byte*)"createnewmoduledef",
    (byte*)"start",
    (byte*)"optimise_module",
    (byte*)"putnops",
    (byte*)"optimise_op",
    (byte*)"start",
    (byte*)"var_loadpacked",
    (byte*)"var_storepacked",
    (byte*)"setfslength",
    (byte*)"getfslength",
    (byte*)"var_make_struct",
    (byte*)"obj_new_struct",
    (byte*)"var_dupl_struct",
    (byte*)"obj_free_struct",
    (byte*)"var_equal_struct",
    (byte*)"var_getix_struct",
    (byte*)"start",
    (byte*)"parsemodule",
    (byte*)"readexpression",
    (byte*)"readassignment",
    (byte*)"readorterms",
    (byte*)"readandterms",
    (byte*)"readcmpterms",
    (byte*)"readinterms",
    (byte*)"readrangeterm",
    (byte*)"readaddterms",
    (byte*)"readmulterms",
    (byte*)"readpowerterms",
    (byte*)"readterm2",
    (byte*)"readtermsuffix",
    (byte*)"readterm",
    (byte*)"readxunit",
    (byte*)"readsunit",
    (byte*)"checksymbol",
    (byte*)"checkequals",
    (byte*)"checkbegin",
    (byte*)"checkbeginend",
    (byte*)"skipsemi",
    (byte*)"readindex",
    (byte*)"readdotsuffix",
    (byte*)"readslist",
    (byte*)"readcondsuffix",
    (byte*)"readkeyindex",
    (byte*)"readlbrack",
    (byte*)"readif",
    (byte*)"checkend",
    (byte*)"readunless",
    (byte*)"readwhile",
    (byte*)"readrepeat",
    (byte*)"readfor",
    (byte*)"readdo",
    (byte*)"readto",
    (byte*)"makeblock",
    (byte*)"readvardef",
    (byte*)"readconstdef",
    (byte*)"readreturn",
    (byte*)"readprint",
    (byte*)"readread",
    (byte*)"readloopcontrol",
    (byte*)"readintunit",
    (byte*)"readswitchcase",
    (byte*)"readgoto",
    (byte*)"readstop",
    (byte*)"readcast",
    (byte*)"readset",
    (byte*)"readtabledef",
    (byte*)"readtry",
    (byte*)"readsprint",
    (byte*)"readsread",
    (byte*)"readimportdll",
    (byte*)"readffiparams",
    (byte*)"readtypeparams",
    (byte*)"readtypenameparams",
    (byte*)"readrecorddef",
    (byte*)"readrecordbody",
    (byte*)"readrecordfields",
    (byte*)"readstructbody",
    (byte*)"addstructflag",
    (byte*)"readprocdef",
    (byte*)"readatfield",
    (byte*)"istypestarter",
    (byte*)"readmacrodef",
    (byte*)"readhostparams",
    (byte*)"pushlisttype",
    (byte*)"poplisttype",
    (byte*)"readcompilervar",
    (byte*)"readmap",
    (byte*)"lexchecksymbol",
    (byte*)"readtypedef",
    (byte*)"readtypespec",
    (byte*)"readreturntype",
    (byte*)"readprocsig",
    (byte*)"readparams",
    (byte*)"readparams_names",
    (byte*)"checkoperator",
    (byte*)"readlist",
    (byte*)"start",
    (byte*)"pch_print",
    (byte*)"pch_print_nf",
    (byte*)"pch_printnogap",
    (byte*)"pch_println",
    (byte*)"pch_reread",
    (byte*)"pch_rereadln",
    (byte*)"pch_startprint",
    (byte*)"pch_startprintcon",
    (byte*)"pch_endprint",
    (byte*)"pch_strstartprint",
    (byte*)"pch_strendprint",
    (byte*)"pch_printspace",
    (byte*)"pch_readln",
    (byte*)"pc_readlinen",
    (byte*)"pch_sread",
    (byte*)"pch_sreadln",
    (byte*)"readname",
    (byte*)"readstring",
    (byte*)"readint",
    (byte*)"readhex",
    (byte*)"readbin",
    (byte*)"readreal",
    (byte*)"getreadfmtcode",
    (byte*)"stepkbpos",
    (byte*)"readany",
    (byte*)"readitem",
    (byte*)"strtoreal",
    (byte*)"strtoint",
    (byte*)"printnextfmtchars",
    (byte*)"pch_setformat",
    (byte*)"pc_getfmt",
    (byte*)"pc_strtofmt",
    (byte*)"initfmtcode",
    (byte*)"i64mintostr",
    (byte*)"u64tostr",
    (byte*)"i64tostrfmt",
    (byte*)"u64tostrfmt",
    (byte*)"strtostrfmt",
    (byte*)"expandstr",
    (byte*)"addstring",
    (byte*)"domultichar",
    (byte*)"printstr_n",
    (byte*)"pch_strtoval",
    (byte*)"tostr_int",
    (byte*)"tostr_word",
    (byte*)"tostr_real",
    (byte*)"tostr_str",
    (byte*)"pch_tostr",
    (byte*)"tostr_list",
    (byte*)"tostr_iterator",
    (byte*)"tostr_range",
    (byte*)"tostr_array",
    (byte*)"tostr_bits",
    (byte*)"tostr_struct",
    (byte*)"tostr_set",
    (byte*)"tostr_dict",
    (byte*)"tostr_decimal",
    (byte*)"tostr",
    (byte*)"tostr_record",
    (byte*)"start",
    (byte*)"evalunit",
    (byte*)"gencodemodule",
    (byte*)"do_procdef",
    (byte*)"genprocentry",
    (byte*)"genprocexit",
    (byte*)"evalref",
    (byte*)"genjumpcond",
    (byte*)"gcomparejump",
    (byte*)"genjumpl",
    (byte*)"reversecond",
    (byte*)"stacklooplabels",
    (byte*)"unstacklooplabels",
    (byte*)"findlooplabel",
    (byte*)"do_assign",
    (byte*)"do_bin",
    (byte*)"do_binref",
    (byte*)"do_unary",
    (byte*)"do_unaryref",
    (byte*)"do_pushlist",
    (byte*)"do_makedict",
    (byte*)"do_call",
    (byte*)"pushparams",
    (byte*)"evalparam",
    (byte*)"pushkwdparams",
    (byte*)"do_if",
    (byte*)"do_do",
    (byte*)"do_exit",
    (byte*)"do_to",
    (byte*)"do_while",
    (byte*)"do_repeat",
    (byte*)"do_for",
    (byte*)"do_forx",
    (byte*)"do_print",
    (byte*)"do_fprint",
    (byte*)"do_read",
    (byte*)"do_forall",
    (byte*)"do_case",
    (byte*)"do_case_nc",
    (byte*)"do_try",
    (byte*)"unitstoarray",
    (byte*)"do_select",
    (byte*)"do_andl",
    (byte*)"do_orl",
    (byte*)"do_incr",
    (byte*)"do_new",
    (byte*)"checkblockreturn",
    (byte*)"do_callhost",
    (byte*)"callhostfn",
    (byte*)"genfree",
    (byte*)"do_return",
    (byte*)"do_multassign",
    (byte*)"do_store",
    (byte*)"getconstvalue",
    (byte*)"do_convert",
    (byte*)"checkelems",
    (byte*)"do_switch",
    (byte*)"do_simpleswitch",
    (byte*)"do_makerecordkv",
    (byte*)"do_idiv",
    (byte*)"do_irem",
    (byte*)"do_map",
    (byte*)"pushstring",
    (byte*)"start",
    (byte*)"start",
    (byte*)"resetpcl",
    (byte*)"genpc",
    (byte*)"genopnd_int",
    (byte*)"genopnd_name",
    (byte*)"genpc_int",
    (byte*)"genpc_int2",
    (byte*)"genpc_int4",
    (byte*)"genpc_name",
    (byte*)"genopnd_strz",
    (byte*)"genopnd_str",
    (byte*)"genopnd_obj",
    (byte*)"genpc_real",
    (byte*)"genpc_lab",
    (byte*)"genopnd_lab",
    (byte*)"gencomment",
    (byte*)"getdottedname",
    (byte*)"extendpcldata",
    (byte*)"extendlabeltable",
    (byte*)"pushint",
    (byte*)"pushreal",
    (byte*)"definelabel",
    (byte*)"createfwdlabel",
    (byte*)"definefwdlabel",
    (byte*)"isstatic",
    (byte*)"var_make_record",
    (byte*)"obj_new_record",
    (byte*)"obj_free_record",
    (byte*)"var_dupl_record",
    (byte*)"var_equal_record",
    (byte*)"var_getix_record",
    (byte*)"var_putix_record",
    (byte*)"var_getixref_record",
    (byte*)"start",
    (byte*)"rx_module",
    (byte*)"rx_passdef",
    (byte*)"rx_deflist",
    (byte*)"rx_unit",
    (byte*)"rx_unitlist",
    (byte*)"evalmonop",
    (byte*)"evalbinop",
    (byte*)"makeintconst",
    (byte*)"makerealconst",
    (byte*)"resolvename",
    (byte*)"resolvetopname",
    (byte*)"resolvedot",
    (byte*)"resolvedot_sym",
    (byte*)"finddupl",
    (byte*)"expandmacro",
    (byte*)"copylistunit",
    (byte*)"copyunit",
    (byte*)"replaceunit",
    (byte*)"fixmode",
    (byte*)"fixmode2",
    (byte*)"fixusertypes",
    (byte*)"tx_typetable",
    (byte*)"getconstint",
    (byte*)"converttype",
    (byte*)"scanstruct",
    (byte*)"dobaseclass",
    (byte*)"start",
    (byte*)"obj_free_set",
    (byte*)"var_dupl_set",
    (byte*)"var_equal_set",
    (byte*)"getsetbytes",
    (byte*)"var_make_set",
    (byte*)"obj_newset",
    (byte*)"var_emptyset",
    (byte*)"var_getix_set",
    (byte*)"var_putix_set",
    (byte*)"var_getixref_set",
    (byte*)"getoffset",
    (byte*)"var_in_set",
    (byte*)"iresizeset",
    (byte*)"obj_resize_set",
    (byte*)"iorsetbits",
    (byte*)"ixorsetbits",
    (byte*)"iandsetbits",
    (byte*)"inotsetbits",
    (byte*)"var_iorto_set",
    (byte*)"var_iandto_set",
    (byte*)"var_ixorto_set",
    (byte*)"var_inotto_set",
    (byte*)"var_checkiter_set",
    (byte*)"var_nextiter_set",
    (byte*)"start",
    (byte*)"start",
    (byte*)"var_empty_string",
    (byte*)"var_make_string",
    (byte*)"var_make_stringn",
    (byte*)"obj_new_string",
    (byte*)"obj_make_string",
    (byte*)"obj_make_stringn",
    (byte*)"obj_free_string",
    (byte*)"var_dupl_string",
    (byte*)"var_getix_string",
    (byte*)"var_getixref_string",
    (byte*)"var_getdotix_string",
    (byte*)"var_getdotixref_string",
    (byte*)"var_getslice_string",
    (byte*)"stringslice",
    (byte*)"var_putix_string",
    (byte*)"var_putslice_string",
    (byte*)"var_putdotix_string",
    (byte*)"obj_resize_string",
    (byte*)"var_add_string",
    (byte*)"var_addto_string",
    (byte*)"var_addto_string_ch",
    (byte*)"var_equal_string",
    (byte*)"var_compare_string",
    (byte*)"cmpstring_len",
    (byte*)"var_inx_string",
    (byte*)"var_iconvcase",
    (byte*)"var_makestrslicexobj",
    (byte*)"obj_make_strslicexobj",
    (byte*)"var_asc",
    (byte*)"var_new_string",
    (byte*)"var_new_stringn",
    (byte*)"var_mul_string",
    (byte*)"var_convert_string_list",
    (byte*)"var_expand_string",
    (byte*)"var_makechar",
    (byte*)"var_nextiter_string",
    (byte*)"findsyslib",
    (byte*)"start",
    (byte*)"start",
    (byte*)"printunit",
    (byte*)"writeallpcl",
    (byte*)"printglobalsymbols",
    (byte*)"printst",
    (byte*)"printglobalsymbols_full",
    (byte*)"printstfull",
    (byte*)"printtypetables",
    (byte*)"getpclname",
    (byte*)"showlogfile",
    (byte*)"showast",
    (byte*)"showpcl",
    (byte*)"showmpl",
    (byte*)"printsymbol",
    (byte*)"strmode",
    (byte*)"start",
    (byte*)"var_unshareu",
    (byte*)"obj_shareu",
    (byte*)"void_new",
    (byte*)"obj_new",
    (byte*)"var_getintvalue",
    (byte*)"var_fromobj",
    (byte*)"var_free",
    (byte*)"var_duplu",
    (byte*)"var_neg",
    (byte*)"var_abs",
    (byte*)"var_inot",
    (byte*)"var_istruel",
    (byte*)"var_negto",
    (byte*)"var_absto",
    (byte*)"var_inotto",
    (byte*)"var_add",
    (byte*)"var_addmixed",
    (byte*)"var_sub",
    (byte*)"var_submixed",
    (byte*)"var_mul",
    (byte*)"var_mulmixed",
    (byte*)"var_div",
    (byte*)"var_divmixed",
    (byte*)"var_idiv",
    (byte*)"var_idivmixed",
    (byte*)"var_irem",
    (byte*)"var_iremmixed",
    (byte*)"var_iand",
    (byte*)"var_iandmixed",
    (byte*)"var_ior",
    (byte*)"var_iormixed",
    (byte*)"var_ixor",
    (byte*)"var_ixormixed",
    (byte*)"var_shl",
    (byte*)"var_shlmixed",
    (byte*)"var_shr",
    (byte*)"var_shrmixed",
    (byte*)"var_in",
    (byte*)"var_inx",
    (byte*)"var_equal",
    (byte*)"var_equalmixed",
    (byte*)"var_compare",
    (byte*)"var_comparemixed",
    (byte*)"var_concat",
    (byte*)"var_append",
    (byte*)"var_min",
    (byte*)"var_minmixed",
    (byte*)"var_max",
    (byte*)"var_maxmixed",
    (byte*)"var_addto",
    (byte*)"var_multo",
    (byte*)"var_iandto",
    (byte*)"var_iorto",
    (byte*)"var_ixorto",
    (byte*)"var_shlto",
    (byte*)"var_shrto",
    (byte*)"var_concatto",
    (byte*)"var_appendto",
    (byte*)"var_getix",
    (byte*)"var_putix",
    (byte*)"var_getixref",
    (byte*)"var_getslice",
    (byte*)"var_putslice",
    (byte*)"var_getdotix",
    (byte*)"var_putdotix",
    (byte*)"var_getdotixref",
    (byte*)"var_getdotslice",
    (byte*)"var_putdotslice",
    (byte*)"var_getdotsliceref",
    (byte*)"var_expand",
    (byte*)"var_minto",
    (byte*)"var_maxto",
    (byte*)"var_inplace",
    (byte*)"var_inplace_unary",
    (byte*)"var_loadptr",
    (byte*)"var_storeptr",
    (byte*)"var_loadbit",
    (byte*)"var_storebit",
    (byte*)"var_convert",
    (byte*)"var_gethashvalue",
    (byte*)"var_objtovar",
    (byte*)"var_putdotix_intint",
    (byte*)"var_power",
    (byte*)"var_powermixed",
    (byte*)"start",
    (byte*)"m_init",
    (byte*)"m_getdotindex",
    (byte*)"m_setdotindex",
    (byte*)"m_getdotslice",
    (byte*)"m_setdotslice",
    (byte*)"m_get_nprocs",
    (byte*)"m_get_nexports",
    (byte*)"m_get_procname",
    (byte*)"m_get_procaddr",
    (byte*)"m_get_procexport",
    (byte*)"pushio",
    (byte*)"m_print_startfile",
    (byte*)"m_print_startstr",
    (byte*)"m_print_startptr",
    (byte*)"m_print_startcon",
    (byte*)"m_print_setfmt",
    (byte*)"m_print_end",
    (byte*)"m_print_ptr",
    (byte*)"m_print_i64",
    (byte*)"m_print_u64",
    (byte*)"m_print_r64",
    (byte*)"m_print_r32",
    (byte*)"m_print_c8",
    (byte*)"m_print_str",
    (byte*)"m_print_newline",
    (byte*)"m_print_nogap",
    (byte*)"m_print_space",
    (byte*)"printstr",
    (byte*)"printstr_n",
    (byte*)"printstrn_app",
    (byte*)"makezstring",
    (byte*)"freezstring",
    (byte*)"printchar",
    (byte*)"nextfmtchars",
    (byte*)"strtofmt",
    (byte*)"domultichar",
    (byte*)"expandstr",
    (byte*)"u64tostr",
    (byte*)"i64tostrfmt",
    (byte*)"u64tostrfmt",
    (byte*)"i64mintostr",
    (byte*)"strtostrfmt",
    (byte*)"tostr_i64",
    (byte*)"tostr_u64",
    (byte*)"tostr_r64",
    (byte*)"tostr_str",
    (byte*)"getfmt",
    (byte*)"strint",
    (byte*)"getstrint",
    (byte*)"strword",
    (byte*)"strreal",
    (byte*)"getstr",
    (byte*)"initreadbuffer",
    (byte*)"m_read_conline",
    (byte*)"m_read_fileline",
    (byte*)"m_read_strline",
    (byte*)"readitem",
    (byte*)"strtoint",
    (byte*)"m_read_i64",
    (byte*)"m_read_r64",
    (byte*)"m_read_str",
    (byte*)"readstr",
    (byte*)"rereadln",
    (byte*)"reread",
    (byte*)"valint",
    (byte*)"valreal",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"m_power_i64",
    (byte*)"m_intoverflow",
    (byte*)"m_dotindex",
    (byte*)"m_dotslice",
    (byte*)"m_popdotindex",
    (byte*)"m_popdotslice",
    (byte*)"m_imin",
    (byte*)"m_imax",
    (byte*)"m_sign",
    (byte*)"m_tp_i64tor64",
    (byte*)"m_tp_r64toi64",
    (byte*)"m_tp_reftoi64",
    (byte*)"m_tp_i64toref",
    (byte*)"start",
    (byte*)"pcm_alloc",
    (byte*)"pcm_free",
    (byte*)"pcm_freeac",
    (byte*)"pcm_clearmem",
    (byte*)"pcm_init",
    (byte*)"pcm_getac",
    (byte*)"pcm_newblock",
    (byte*)"pcm_round",
    (byte*)"pcm_allocz",
    (byte*)"pcm_copyheapstring",
    (byte*)"pcm_copyheapstringn",
    (byte*)"pcm_copyheapblock",
    (byte*)"allocmem",
    (byte*)"reallocmem",
    (byte*)"abortprogram",
    (byte*)"getfilesize",
    (byte*)"readrandom",
    (byte*)"writerandom",
    (byte*)"setfilepos",
    (byte*)"getfilepos",
    (byte*)"readfile",
    (byte*)"writefile",
    (byte*)"checkfile",
    (byte*)"readlinen",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"changeext",
    (byte*)"extractext",
    (byte*)"extractpath",
    (byte*)"extractfile",
    (byte*)"extractbasefile",
    (byte*)"addext",
    (byte*)"pcm_alloc32",
    (byte*)"pcm_free32",
    (byte*)"outbyte",
    (byte*)"outword16",
    (byte*)"outword32",
    (byte*)"outword64",
    (byte*)"outstring",
    (byte*)"outblock",
    (byte*)"myeof",
    (byte*)"strbuffer_add",
    (byte*)"gs_init",
    (byte*)"gs_free",
    (byte*)"gs_str",
    (byte*)"gs_char",
    (byte*)"gs_strn",
    (byte*)"gs_strvar",
    (byte*)"gs_strint",
    (byte*)"gs_strln",
    (byte*)"gs_strsp",
    (byte*)"gs_line",
    (byte*)"gs_getcol",
    (byte*)"gs_leftstr",
    (byte*)"gs_leftint",
    (byte*)"gs_padto",
    (byte*)"gs_println",
    (byte*)"nextcmdparamnew",
    (byte*)"readnextfileitem",
    (byte*)"ipadstr",
    (byte*)"padstr",
    (byte*)"chr",
    (byte*)"cmpstring",
    (byte*)"cmpstringn",
    (byte*)"eqstring",
    (byte*)"cmpbytes",
    (byte*)"eqbytes",
    (byte*)"mseed",
    (byte*)"mrandom",
    (byte*)"mrandomp",
    (byte*)"mrandomint",
    (byte*)"mrandomrange",
    (byte*)"mrandomreal",
    (byte*)"mrandomreal1",
    (byte*)"readline",
    (byte*)"findfunction",
    (byte*)"roundtoblock",
    (byte*)"start",
    (byte*)"start",
    (byte*)"os_init",
    (byte*)"os_execwait",
    (byte*)"os_execcmd",
    (byte*)"os_getch",
    (byte*)"os_kbhit",
    (byte*)"os_getdllinst",
    (byte*)"os_getdllprocaddr",
    (byte*)"os_initwindows",
    (byte*)"os_gxregisterclass",
    (byte*)"mainwndproc",
    (byte*)"os_setmesshandler",
    (byte*)"os_getchx",
    (byte*)"os_getos",
    (byte*)"os_gethostsize",
    (byte*)"os_shellexec",
    (byte*)"os_sleep",
    (byte*)"os_getstdin",
    (byte*)"os_getstdout",
    (byte*)"os_gethostname",
    (byte*)"os_getmpath",
    (byte*)"os_clock",
    (byte*)"os_ticks",
    (byte*)"os_hptimer",
    (byte*)"os_iswindows",
    (byte*)"os_getsystime",
    (byte*)"os_peek",
    (byte*)"os_allocexecmem",
    (byte*)"start",
    (byte*)"os_calldllfunction",
    (byte*)"os_pushargs",
    (byte*)"calldll_cint",
    (byte*)"calldll_creal",
    (byte*)"os_dummycall",
    (byte*)"start",
(byte*)""};
static i64 msysc$_fnnprocs=1234;
static i64 msysc$_fnnexports;
static i64 msysc$fmtparam;
static i64 msysc$needgap = (i64)0;
static i64 msysc$outdev = (i64)1;
static void *  msysc$outchan = 0;
static u8 *  msysc$fmtstr = 0;
static void *  msysc$outchan_stack[10];
static i64 msysc$outdev_stack[10];
static u8 *  msysc$fmtstr_stack[10];
static byte msysc$needgap_stack[10];
static u8 *  msysc$ptr_stack[10];
static i64 msysc$niostack = (i64)0;
static u8 msysc$digits[16] = {
    (u8)(i64)48,
    (u8)(i64)49,
    (u8)(i64)50,
    (u8)(i64)51,
    (u8)(i64)52,
    (u8)(i64)53,
    (u8)(i64)54,
    (u8)(i64)55,
    (u8)(i64)56,
    (u8)(i64)57,
    (u8)(i64)65,
    (u8)(i64)66,
    (u8)(i64)67,
    (u8)(i64)68,
    (u8)(i64)69,
    (u8)(i64)70
};
static struct msysc$fmtrec msysc$defaultfmt = {
    (u8)0u,
    (i8)(i64)0,
    (u8)10u,
    (u8)(i64)0,
    (u8)' ',
    (u8)'f',
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)'R',
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)(i64)0,
    (u8)0u
};
static u8 *  msysc$rd_buffer;
static i64 msysc$rd_length;
static u8 *  msysc$rd_pos;
static u8 *  msysc$rd_lastpos;
static i64 msysc$termchar;
static i64 msysc$itemerror;
static i64 msysc$$cmdskip;
static i64 msysc$nsysparams;
static i64 msysc$ncmdparams;
static i64 msysc$nenvstrings;
static u8 *  msysc$sysparams[128];
static u8 *(*msysc$cmdparams)[];
static u8 *(*msysc$envstrings)[];
static u64 msysc$mask63 = (u64)9223372036854775807u;
static r64 msysc$offset64 = (double)9223372036854775800.;
static r64 msysc$offset32 = (double)9223372036854775800.;
static u64 mlib$allocupper[301];
static i64 mlib$alloccode;
static i64 mlib$allocbytes;
static i64 mlib$fdebug = (i64)0;
static i64 mlib$rfsize;
static u64 mlib$maxmemory;
static i64 mlib$maxalloccode;
static void *  mlib$allocbase;
static byte mlib$pcm_setup = (byte)(i64)0;
static i64 mlib$show = (i64)0;
static i64 mlib$memtotal = (i64)0;
static i64 mlib$smallmemtotal = (i64)0;
static i64 mlib$smallmemobjs = (i64)0;
static i64 mlib$maxmemtotal = (i64)0;
static i32 *  mlib$memalloctable[3];
static i32 mlib$memallocsize[3];
static byte *  mlib$pcheapstart;
static byte *  mlib$pcheapend;
static byte *  mlib$pcheapptr;
static byte mlib$sizeindextable[2049];
static u64 *  mlib$freelist[9];
static u8 *  mlib$pmnames[6] = {(byte*)"pm_end",(byte*)"pm_option",(byte*)"pm_sourcefile",(byte*)"pm_libfile",(byte*)"pm_colon",(byte*)"pm_extra"};
static u64 mlib$seed[2] = {(u64)2993073034246558322u,(u64)1617678968452121188u};
static void *  mwindows$hconsole;
static void *  mwindows$hconsolein;
static struct mwindows$input_record mwindows$lastkey;
static struct mwindows$input_record mwindows$pendkey;
static i64 mwindows$keypending;
static i64 (*mwindows$wndproc_callbackfn)(void *) = 0;
static i64 mwindows$init_flag = (i64)0;

/* PROCDEFS */
int main(int _nargs, char** _args, char** _envstrings) {
    msysc$m_init(_nargs, (void*)_args, (void*)_envstrings);

// call main-start() routines...
    msysc$start();
    qqcli$start();

        i64 stopcode;
    qqcli$getinputoptions();
    if (!!(qq_decls$fverbose)) {
        msysc$m_print_startcon();
        msysc$m_print_str(qq_decls$dispatchnames[(qq_decls$dispatchtype)-1],NULL);
        msysc$m_print_str((byte*)"Opt:",NULL);
        msysc$m_print_i64((i64)qqcli$foptimise,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    stopcode = qqcli$runqprogram(qqcli$cliruncode,qqcli$inputfile,(u8 *(*)[])&(*msysc$cmdparams)[(qqcli$cmdstartindex)],((msysc$ncmdparams - qqcli$cmdstartindex) + (i64)1));
    qq_dummyshow$showlogfile();
    exit(stopcode);
    return 0;
}

static void qqcli$getinputoptions(void) {
        i64 paramno;
        i64 pmtype;
        u8 *  name;
        u8 *  value;
        u8 *  appstr;
        u8 *(*fnaddr)(void);
        i64 sw;
    fnaddr = (u8 *(*)(void))mlib$findfunction((byte*)"getbuiltin_app");
    paramno = (i64)1;
    L1 :;
    while (!!((pmtype = mlib$nextcmdparamnew(&paramno,&name,&value,(byte*)"q")))) {
        if ((pmtype==(i64)1)) {
            mlib$convlcstring(name);
            for (sw=(i64)1;sw<=(i64)34;++sw) {
L4 :;
                if (!!(mlib$eqstring(name,qqcli$optionnames[(sw)-1]))) {
                    qqcli$do_option(sw,value);
                    goto L6 ;
                }
;
L5 :;
            }
            {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Unknown option:",NULL);
                msysc$m_print_str(name,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)99);
            }
L6 :;
            ;
        }
        else if ((pmtype==(i64)2)) {
            if (!!(fnaddr)) {
                --(paramno);
                goto L3 ;
            }
;
            qqcli$inputfile = mlib$pcm_copyheapstring(name);
            goto L3 ;
        }
;
L2 :;
    }
L3 :;
    ;
    if (!!(fnaddr)) {
        appstr = ((*fnaddr))();
        qq_lib$loaderror((byte*)"DO BUILT-IN",(byte*)"",(byte*)"");
    }
    else if (!(!!(qqcli$inputfile))) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Q Interpreter I [mm4]",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Usage:",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"\t",NULL);
        msysc$m_print_nogap();
        msysc$m_print_str(msysc$sysparams[((i64)1)-1],NULL);
        msysc$m_print_str((byte*)"filename[.q]",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit(0);
    }
;
    if ((qq_decls$dispatchtype == (i64)3 || qq_decls$dispatchtype == (i64)4)) {
        qq_decls$hasbytecodes = (i64)1;
    }
    else {
        qq_decls$hasbytecodes = (i64)0;
    }
;
    qqcli$cmdstartindex = paramno;
    if (!!(qq_decls$fwritedocs)) {
        qq_decls$docsdev = fopen(mlib$changeext(qqcli$inputfile,(byte*)"txt"),(byte*)"wb");
    }
;
    if (((qq_decls$dispatchtype == (i64)5) && !(!!(qq_jhandlers_hll$asmavailable())))) {
        qq_decls$dispatchtype = (i64)2;
    }
;
}

static void qqcli$do_option(i64 sw,u8 *value) {
    if ((sw==(i64)1)) {
        qqcli$cliruncode = (i64)1;
    }
    else if ((sw==(i64)2)) {
        qqcli$cliruncode = (i64)2;
    }
    else if ((sw==(i64)3)) {
        qqcli$cliruncode = (i64)3;
    }
    else if ((sw==(i64)4)) {
        qqcli$cliruncode = (i64)4;
    }
    else if ((sw==(i64)5)) {
        qqcli$cliruncode = (i64)5;
    }
    else if ((sw==(i64)8)) {
        qqcli$cliruncode = (i64)6;
    }
    else if ((sw==(i64)9)) {
        qqcli$cliruncode = (i64)7;
    }
    else if ((sw==(i64)6)) {
        qqcli$foptimise = (i64)1;
    }
    else if ((sw==(i64)10)) {
        qqcli$fshowast1 = (i64)1;
    }
    else if ((sw==(i64)11)) {
        qqcli$fshowast2 = (i64)1;
    }
    else if ((sw==(i64)12)) {
        qqcli$fshowpcl1 = (i64)1;
    }
    else if ((sw==(i64)13)) {
        qqcli$fshowpcl2 = (i64)1;
    }
    else if ((sw==(i64)14)) {
        qqcli$fshowpcl3 = (i64)1;
    }
    else if ((sw==(i64)15)) {
        qqcli$fshowst = (i64)1;
    }
    else if ((sw==(i64)16)) {
        qqcli$fshowstflat = (i64)1;
    }
    else if ((sw==(i64)17)) {
        qqcli$fshowtypes = (i64)1;
    }
    else if ((sw==(i64)18)) {
        qqcli$fshowmodules = (i64)1;
    }
    else if ((sw==(i64)19)) {
        qqcli$fshowast1 = (i64)1;
        qqcli$fshowast2 = (i64)1;
        qqcli$fshowpcl1 = (i64)1;
        qqcli$fshowpcl2 = (i64)1;
        qqcli$fshowpcl3 = (i64)1;
        qqcli$fshowst = (i64)1;
        qqcli$fshowstflat = (i64)1;
        qqcli$fshowtypes = (i64)1;
        qqcli$fshowmodules = (i64)1;
    }
    else if ((sw==(i64)20)) {
        qq_decls$dispatchtype = (i64)2;
    }
    else if ((sw==(i64)22)) {
        qqcli$foptimise = (i64)0;
        qq_decls$dispatchtype = (i64)5;
    }
    else if ((sw==(i64)23)) {
        qq_decls$dispatchtype = (i64)3;
    }
    else if ((sw==(i64)24)) {
        qq_decls$dispatchtype = (i64)4;
    }
    else if ((sw==(i64)25)) {
        qq_decls$dispatchtype = (i64)1;
    }
    else if ((sw==(i64)7)) {
        qqcli$foptimise = (i64)1;
        qq_decls$dispatchtype = (i64)5;
    }
    else if ((sw==(i64)26)) {
        qq_decls$usesyslibs = (i64)0;
    }
    else if ((sw==(i64)27)) {
        qqcli$fwriteqa = (i64)1;
    }
    else if ((sw==(i64)28)) {
        qqcli$fwriteqa = (i64)2;
    }
    else if ((sw==(i64)29)) {
        qq_decls$fverbose = (i64)1;
    }
    else if ((sw==(i64)30)) {
        qq_decls$fwritedocs = (i64)1;
        qqcli$cliruncode = (i64)4;
    }
    else if ((sw==(i64)31)) {
        qq_decls$fwritedocs = (i64)2;
        qqcli$cliruncode = (i64)4;
    }
    else if ((sw==(i64)34)) {
        qq_decls$fnosys = (i64)1;
    }
    else if ((sw==(i64)32)) {
        qqcli$sourcestr = mlib$pcm_copyheapstring(value);
        qqcli$inputfile = (byte*)"$";
    }
    else if ((sw==(i64)33)) {
        qqcli$fshowtime = (i64)1;
    }
;
}

i64 qqcli$runqprogram(i64 run,u8 *filename,u8 *(*qparams)[],i64 nqparams) {
        i64 t;
        i64 stopcode;
    t = clock();
    qqcli$inputfile = filename;
    qqcli$runcode = run;
    qqcli$initprogram();
    qq_modules$readprojectfile(filename);
    qqcli$load_program();
    qqcli$parse_program();
    qqcli$rx_program();
    qqcli$writeqa_program();
    qqcli$gxpcl_program();
    qqcli$optimise_program();
    qqcli$fixup_program();
    stopcode = qqcli$runprogram(qparams,nqparams);
    return stopcode;
}

static void qqcli$load_program(void) {
    if (((i64)qqcli$runcode < (i64)2)) {
        return;
    }
;
    qq_modules$loadmodules();
}

static void qqcli$parse_program(void) {
        i64 m;
    if (((i64)qqcli$runcode < (i64)3)) {
        return;
    }
;
    m = (i64)1;
    for (m=(i64)1;m<=qq_decls$nmodules;++m) {
L7 :;
        qq_parse$parsemodule(m);
L8 :;
    }
L9 :;
    ;
    qq_resolve$fixusertypes();
    if (!!((i64)qqcli$fshowast1)) {
        qq_dummyshow$showast((byte*)"AST1");
    }
;
}

static void qqcli$rx_program(void) {
        i64 i;
    if (((i64)qqcli$runcode < (i64)4)) {
        return;
    }
;
    qq_resolve$tx_typetable();
    for (i=(i64)1;i<=qq_decls$nmodules;++i) {
L10 :;
        qq_resolve$rx_module(i);
L11 :;
    }
L12 :;
    ;
    if (!!((i64)qqcli$fshowast2)) {
        qq_dummyshow$showast((byte*)"AST2");
    }
;
}

static void qqcli$gxpcl_program(void) {
        i64 i;
    if (((i64)qqcli$runcode < (i64)5)) {
        return;
    }
;
    for (i=(i64)1;i<=qq_decls$nmodules;++i) {
L13 :;
        qq_pclgen$gencodemodule(i);
L14 :;
    }
L15 :;
    ;
    if (!!((i64)qqcli$fshowpcl1)) {
        qq_dummyshow$showpcl((i64)1);
    }
;
}

static void qqcli$optimise_program(void) {
        i64 i;
    if ((!(!!((i64)qqcli$foptimise)) || (qq_decls$dispatchtype != (i64)5))) {
        qqcli$fshowpcl2 = (i64)0;
        return;
    }
;
    for (i=(i64)1;i<=qq_decls$nmodules;++i) {
L16 :;
        qq_optim$optimise_module(i);
L17 :;
    }
L18 :;
    ;
    if (!!((i64)qqcli$fshowpcl2)) {
        qq_dummyshow$showpcl((i64)2);
    }
;
}

static void qqcli$fixup_program(void) {
        i64 i;
    if (((i64)qqcli$runcode < (i64)6)) {
        return;
    }
;
    qq_khandlers$initkhandlers();
    if ((qq_decls$dispatchtype == (i64)5)) {
        qq_jhandlers_hll$initjhandlers();
    }
;
    for (i=(i64)1;i<=qq_decls$nmodules;++i) {
L19 :;
        qqcli$fixupmodule(i);
L20 :;
    }
L21 :;
    ;
    if (!!((i64)qqcli$fshowpcl3)) {
        qq_dummyshow$showpcl((i64)3);
    }
;
}

static void qqcli$writeqa_program(void) {
        u8 filename[300];
        i64 sflist[200];
        void *  f;
        i64 offset;
        i64 nfiles;
        i64 fileno;
        i64 i;
    if (!(!!((i64)qqcli$fwriteqa))) {
        return;
    }
;
    strcpy(filename,mlib$changeext(qq_decls$sourcefilespecs[((i64)1)-1],(byte*)"qa"));
    nfiles = (i64)0;
    for (i=(i64)1;i<=qq_decls$nsourcefiles;++i) {
L22 :;
        if ((!!((i64)qq_decls$sourcefilesys[(i)-1]) && ((i64)qqcli$fwriteqa == (i64)1))) {
            goto L23 ;
        }
;
        sflist[(++(nfiles))-1] = i;
L23 :;
    }
L24 :;
    ;
    if ((nfiles == (i64)0)) {
        qq_lib$loaderror((byte*)"QA:no files",(byte*)"",(byte*)"");
    }
;
    f = fopen(filename,(byte*)"wb");
    if (!(!!(f))) {
        qq_lib$loaderror((byte*)"Can't create qa file #",filename,(byte*)"");
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Writing ",NULL);
    msysc$m_print_str(filename,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_setfmt((byte*)"=== QA # ===");
    msysc$m_print_i64(nfiles,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=nfiles;++i) {
L25 :;
        fileno = sflist[(i)-1];
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"=== # # # #/# ===");
        msysc$m_print_str(qq_decls$sourcefilenames[(fileno)-1],NULL);
        msysc$m_print_i64((i64)qq_decls$sourcefilesys[(fileno)-1],NULL);
        msysc$m_print_i64((i64)qq_decls$sourcefilesupport[(fileno)-1],NULL);
        msysc$m_print_i64(i,NULL);
        msysc$m_print_i64(nfiles,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        offset = mlib$getfilepos(f);
        mlib$writerandom(f,(byte *)qq_decls$sourcefiletext[(fileno)-1],offset,qq_decls$sourcefilesizes[(fileno)-1]);
L26 :;
    }
L27 :;
    ;
    msysc$m_print_startfile(f);
    msysc$m_print_str((byte*)"=== END ===",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    for (i=(i64)1;i<=nfiles;++i) {
L28 :;
        msysc$m_print_startfile(f);
        msysc$m_print_setfmt((byte*)"# #");
        msysc$m_print_i64(i,NULL);
        msysc$m_print_str(qq_decls$sourcefilenames[(sflist[(i)-1])-1],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L29 :;
    }
L30 :;
    ;
    fclose(f);
    exit(0);
}

static void qqcli$initprogram(void) {
    qq_lex$lexinit();
    qq_host$inithostlib();
    mwindows$os_initwindows();
}

static void qqcli$fixproc(struct qq_decls$strec *d) {
        i64 *  z;
        struct qq_decls$varrec *  p;
    if (!(!!((i64)(*d).procfixed))) {
        if ((qqcli$nprocs >= (i64)11000)) {
            qq_lib$gerror((byte*)"Too many procs",0);
        }
;
        z = (qq_decls$moduletable[((i64)(*d).moduleno)].pcstart + (*d).labelno);
        p = (struct qq_decls$varrec *)mlib$pcm_alloc((i64)16);
        qqcli$proctable[(++(qqcli$nprocs))-1] = z;
        qqcli$procdefs[(qqcli$nprocs)-1] = d;
        (*d).pcaddress = z;
        (*d).procfixed = (i64)1;
    }
;
}

static void qqcli$fixupmodule(i64 m) {
        i64 *  pc;
        i64 *  pcstart;
        i64 cmd;
        i64 y;
        struct qq_decls$strec *  d;
        struct qq_decls$varrec *  p;
        struct qq_decls$stringrec *  ps;
        i64 $av_1;
        i64 i;
    qqcli$setcmdmap();
    pc = (pcstart = qq_decls$moduletable[(m)].pcstart);
    L31 :;
    do {
        cmd = (*pc);
        (*pc) = (i64)qq_tables$cmdmap[(cmd)];
        ++(pc);
        if ((cmd==(i64)3)) {
            qqcli$fixproc((struct qq_decls$strec *)(*pc));
        }
;
                ($av_1 = (i64)qq_pcllib$pclnopnds[(cmd)]);
        for (i=(i64)1;i<=$av_1;++i) {
L34 :;
            switch ((i64)qq_tables$pclfmt[(cmd)][(i)-1]) {
            case 3:;
                {
                    d = (struct qq_decls$strec *)(*pc);
                    qqcli$fixproc(d);
                    (*pc) = (i64)(*d).pcaddress;
                }
                break;
            case 1:;
                {
                    d = (struct qq_decls$strec *)(*pc);
                    if (((*d).varptr == 0)) {
                        if ((qqcli$nstatics >= (i64)11000)) {
                            qq_lib$gerror((byte*)"Too many statics",0);
                        }
;
                        p = (struct qq_decls$varrec *)mlib$pcm_alloc((i64)16);
                        qqcli$statictable[(++(qqcli$nstatics))-1] = p;
                        qqcli$staticdefs[(qqcli$nstatics)-1] = d;
                        (*d).varptr = p;
                    }
;
                    (*pc) = (i64)(*d).varptr;
                }
                break;
            case 2:;
                {
                    d = (struct qq_decls$strec *)(*pc);
                    if ((d == 0)) {
                        qq_lib$loaderror((byte*)"D NIL",(byte*)"",(byte*)"");
                    }
;
                    (*pc) = ((*d).index * (i64)16);
                }
                break;
            case 5:;
                {
                    (*pc) = (*(struct qq_decls$strec *)(*pc)).genfieldindex;
                }
                break;
            case 11:;
                {
                    ps = (struct qq_decls$stringrec *)(*pc);
                    (*pc) = (i64)qq_strings$obj_make_stringn((*ps).svalue,(*ps).length,(i64)0);
                }
                break;
            case 6:;
                {
                    y = (i64)(pcstart + (*pc));
                    (*pc) = y;
                }
                break;
            } //SW
;
            ++(pc);
L35 :;
        }
L36 :;
        ;
L32 :;
    }
    while (!(cmd == (i64)6));
L33 :;
    ;
}

static i64 qqcli$runprogram(u8 *(*cmds)[],i64 ncmds) {
        i64 *  pcstart;
        i64 i;
    if (((i64)qqcli$runcode < (i64)7)) {
        return (i64)0;
    }
;
    for (i=(i64)1;i<=ncmds;++i) {
L37 :;
        qq_host$setcmdparam(i,(*cmds)[(i)-1]);
L38 :;
    }
L39 :;
    ;
    qq_decls$sptr = &qq_decls$varstack[((i64)1)-1];
    qq_decls$stacklimit = &qq_decls$varstack[((i64)69900)-1];
    pcstart = (qq_decls$pcptr = qq_decls$moduletable[(qq_decls$mainmoduleno)].pcstart);
    qq_decls$pcerrorpos = (i64)0;
    qqcli$disploop();
    return (*qq_decls$sptr).value;
}

static void qqcli$disploop(void) {
    if ((qq_decls$dispatchtype==(i64)2)) {
        qqcli$disploop_fn();
    }
    else if ((qq_decls$dispatchtype==(i64)3)) {
        qqcli$disploop_deb((i64)0);
    }
    else if ((qq_decls$dispatchtype==(i64)4)) {
        qqcli$disploop_deb((i64)1);
    }
    else if ((qq_decls$dispatchtype==(i64)5)) {
        qq_jhandlers_hll$disploop_asm();
    }
    else {
        qq_lib$loaderror((byte*)"Dispatch not supported: ##",qq_decls$dispatchnames[(qq_decls$dispatchtype)-1],(byte*)"");
    }
;
}

static void qqcli$disploop_fn(void) {
    L40 :;
    do {
        ((*(void (*)(void))(*qq_decls$pcptr)))();
L41 :;
    }
    while (!!!(qq_decls$stopped));
L42 :;
    ;
}

static void qqcli$disploop_deb(i64 fdeb) {
    mlib$fdebug = fdeb;
    L43 :;
    do {
        if (!!(mlib$fdebug)) {
            msysc$m_print_startcon();
            msysc$m_print_str(qq_tables$pclnames[((*qq_decls$pcptr))],NULL);
            msysc$m_print_str((byte*)"PCPTR=",NULL);
            msysc$m_print_ptr(qq_decls$pcptr,NULL);
            msysc$m_print_str((byte*)"SPTR=",NULL);
            msysc$m_print_ptr(qq_decls$sptr,NULL);
            msysc$m_print_str(qq_tables$ttname[((i64)(*qq_decls$sptr).tag)],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
        ++(qq_decls$pclcounts[((*qq_decls$pcptr))]);
        ((*qq_khandlers$khandlertable[((*qq_decls$pcptr))]))();
L44 :;
    }
    while (!!!(qq_decls$stopped));
L45 :;
    ;
}

static void qqcli$setcmdmap(void) {
        i64 i;
    for (i=(i64)1;i<=(i64)272;++i) {
L46 :;
        if ((qq_decls$dispatchtype==(i64)2)) {
            qq_tables$cmdmap[(i)] = qq_khandlers$khandlertable[(i)];
        }
        else if ((qq_decls$dispatchtype==(i64)3) || (qq_decls$dispatchtype==(i64)4)) {
            qq_tables$cmdmap[(i)] = (void *)i;
        }
        else if ((qq_decls$dispatchtype==(i64)5)) {
            qq_tables$cmdmap[(i)] = qq_jhandlers_hll$jhandlertable[(i)];
        }
;
L47 :;
    }
L48 :;
    ;
}

i64 qqcli$runproc_m(void *amsg) {
        struct qq_decls$varrec a;
        struct qq_decls$varrec dest;
        static i64 rmsg_typeno;
        i64 i;
        i64 result;
        struct qq_decls$objrec obj;
    if ((rmsg_typeno == (i64)0)) {
        for (i=(i64)1;i<=qq_tables$ntypes;++i) {
L49 :;
            if (!!(mlib$eqstring(qq_tables$ttname[(i)],(byte*)"ws_msg64"))) {
                rmsg_typeno = i;
                goto L51 ;
            }
;
L50 :;
        }
L51 :;
        ;
    }
;
    if ((rmsg_typeno == (i64)0)) {
        mlib$abortprogram((byte*)"mainwndproc: can't find rmsg");
    }
;
    memset(&obj,(i32)(i64)0,(u64)32u);
    obj.refcount = (i64)99;
    obj.ptr = (byte *)amsg;
    obj.usertag = rmsg_typeno;
    a.tagx = (i64)272;
    a.objptr = &obj;
    ++(qq_decls$pcllevel);
    qqcli$runproc(qq_decls$pcl_callbackfn,&a,0,&dest);
    --(qq_decls$pcllevel);
    result = dest.value;
    result = (i64)0;
    return result;
}

void qqcli$runproc(void *fnptr,struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *dest) {
        struct qq_decls$varrec *  oldsptr;
        byte *  oldframeptr;
        i64 *  oldpcptr;
        byte oldstopped;
        i64 nparams;
    (*dest).tagx = (i64)1;
    (*dest).value = (i64)0;
    oldstopped = qq_decls$stopped;
    oldpcptr = qq_decls$pcptr;
    oldsptr = qq_decls$sptr;
    oldframeptr = qq_decls$frameptr;
    (*++(qq_decls$sptr)).tagx = (i64)999;
    if ((!!(b) && !!((i64)(*b).tag))) {
        nparams = (i64)2;
        (*++(qq_decls$sptr)) = (*a);
        (*++(qq_decls$sptr)) = (*b);
    }
    else if ((!!(a) && !!((i64)(*a).tag))) {
        nparams = (i64)1;
        (*++(qq_decls$sptr)) = (*a);
    }
    else {
        nparams = (i64)0;
    }
;
    (*++(qq_decls$sptr)).tagx = (i64)21;
    (*qq_decls$sptr).retaddr = qq_decls$stopseq;
    (*qq_decls$sptr).frameptr_low = (i64)qq_decls$frameptr;
    qq_decls$frameptr = (byte *)qq_decls$sptr;
    qq_decls$pcptr = (i64 *)fnptr;
    qqcli$disploop();
    if (((i64)(*(qq_decls$sptr - (i64)11)).tag == (i64)21)) {
        (*dest) = (*qq_decls$sptr);
    }
    else {
        --(qq_decls$sptr);
        (*dest) = (*qq_decls$sptr);
        if (((i64)(*dest).tag == (i64)0)) {
            (*dest).tagx = (i64)1;
            (*dest).value = (i64)0;
        }
;
    }
;
    qq_decls$pcptr = oldpcptr;
    qq_decls$stopped = (i64)oldstopped;
    qq_decls$sptr = oldsptr;
    qq_decls$frameptr = oldframeptr;
    qq_decls$stopped = (i64)oldstopped;
}

// START
void qqcli$start(void) {
    qq_arrays$start();
    qq_bits$start();
    qq_calldll$start();
    qq_decimal$start();
    qq_decls$start();
    qq_dicts$start();
    qq_iterators$start();
    qq_jhandlers_hll$start();
    qq_khandlers$start();
    qq_host$start();
    qq_lex$start();
    qq_lib$start();
    qq_lists$start();
    qq_modules$start();
    qq_names$start();
    qq_optim$start();
    qq_packed$start();
    qq_parse$start();
    qq_print$start();
    qq_pclgen$start();
    qq_pcllib$start();
    qq_records$start();
    qq_resolve$start();
    qq_sets$start();
    qq_strings$start();
    qq_syslibs$start();
    qq_tables$start();
    qq_dummyshow$start();
    qq_vars$start();

}

void qq_arrays$var_empty_array(i64 tag,i64 elemtype,i64 lower,struct qq_decls$varrec *dest) {
    (*dest).objptr = qq_arrays$obj_newarray(elemtype,lower,(i64)0);
    (*dest).tagx = (tag | (i64)256);
}

void qq_arrays$obj_free_array(struct qq_decls$objrec *p) {
    if (!!((*p).length)) {
        mlib$pcm_free((*p).ptr,((*p).alloc64 * qq_tables$ttsize[((i64)(*p).elemtag)]));
    }
;
    mlib$pcm_free32(p);
}

void qq_arrays$obj_free_vector(struct qq_decls$objrec *p) {
    if (!!((*p).length)) {
        mlib$pcm_free((*p).ptr,qq_tables$ttsize[((i64)(*p).usertag)]);
    }
;
    mlib$pcm_free32(p);
}

void qq_arrays$var_make_array(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 lower,i64 n,i64 axtype,i64 elemtype) {
        struct qq_decls$objrec *  p;
        byte *  q;
        i64 m;
        i64 $av_1;
    if ((axtype != (i64)14)) {
        m = qq_tables$ttlength[(axtype)];
        if ((n != m)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"N=",NULL);
            msysc$m_print_i64(n,NULL);
            msysc$m_print_str((byte*)"M=",NULL);
            msysc$m_print_i64(m,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            qq_lib$pcerror((byte*)"Too few/too many elements");
        }
;
    }
    else if (!!(n)) {
        if ((elemtype == (i64)0)) {
                        {i64 $temp = (i64)(*((a + n) - (i64)1)).tag;
if (($temp==(i64)1)) {
                elemtype = (i64)1;
            }
            else if (($temp==(i64)3)) {
                elemtype = (i64)3;
            }
            else if (($temp==(i64)2)) {
                elemtype = (i64)2;
            }
            else {
                elemtype = (i64)1;
            }
            };
        }
;
    }
    else if ((elemtype == (i64)0)) {
        elemtype = (i64)1;
    }
;
    p = qq_arrays$obj_newarray(elemtype,lower,n);
    q = (*p).ptr;
    $av_1 = n;
    while ($av_1-- > 0) {
L52 :;
        qq_packed$var_storepacked(q,a,elemtype);
        q += qq_tables$ttsize[(elemtype)];
        ++(a);
L53 :;
    }
L54 :;
    ;
    if ((axtype == (i64)14)) {
        (*dest).tagx = (i64)270;
    }
    else {
        (*dest).tagx = (i64)266;
        (*p).usertag = axtype;
    }
;
    (*dest).objptr = p;
}

struct qq_decls$objrec *qq_arrays$obj_newarray(i64 elemtype,i64 lower,i64 length) {
        struct qq_decls$objrec *  p;
        i64 elemsize;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    if ((lower >= (i64)0 && lower <= (i64)1)) {
        (*p).flags = msysc$m_setdotindex((*p).flags,(i64)0,(u64)lower);
    }
    else {
        qq_lib$pcerror((byte*)"Lwb not 0/1");
    }
;
    (*p).length = length;
    (*p).objtype = (i64)0;
    (*p).elemtag = elemtype;
    elemsize = qq_tables$ttsize[(elemtype)];
    if (!!(length)) {
        (*p).ptr = (byte *)mlib$pcm_allocz((length * elemsize));
        (*p).alloc64 = (mlib$allocbytes / elemsize);
    }
;
    return p;
}

struct qq_decls$objrec *qq_arrays$obj_newarray_u(i64 usertag) {
        struct qq_decls$objrec *  p;
        i64 elemsize;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    (*p).objtype = (i64)0;
    (*p).usertag = usertag;
    elemsize = qq_tables$ttsize[((i64)qq_tables$tttarget[(usertag)])];
    if (!!(qq_tables$ttlength[(usertag)])) {
        (*p).ptr = (byte *)mlib$pcm_allocz(qq_tables$ttsize[(usertag)]);
        (*p).alloc64 = (mlib$allocbytes / elemsize);
    }
;
    return p;
}

void qq_arrays$var_getix_array(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  p;
        i64 elemtype;
        i64 length;
    v = (*a);
    p = (*a).objptr;
    if (((i64)v.tag == (i64)10)) {
        length = qq_tables$ttlength[((i64)(*p).usertag)];
        index -= qq_tables$ttlower[((i64)(*p).usertag)];
        elemtype = (i64)qq_tables$tttarget[((i64)(*p).usertag)];
    }
    else {
        length = (*p).length;
        elemtype = (i64)(*p).elemtag;
        index -= (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    }
;
    if (((u64)index >= (u64)length)) {
        qq_lib$pcerror((byte*)"ax[int] bounds");
    }
;
    if ((elemtype == (i64)31)) {
        (*a).tagx = (i64)1;
        (*a).value = (i64)(*((*p).ptr + index));
    }
    else {
        qq_packed$var_loadpacked(((*p).ptr + (index * qq_tables$ttsize[(elemtype)])),elemtype,a,0);
    }
;
}

void qq_arrays$var_putix_array(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  p;
        i64 elemtype;
        i64 length;
        i64 lower;
    v = (*a);
    p = v.objptr;
    if (((i64)v.tag == (i64)10)) {
        length = qq_tables$ttlength[((i64)(*p).usertag)];
        lower = qq_tables$ttlower[((i64)(*p).usertag)];
        elemtype = (i64)qq_tables$tttarget[((i64)(*p).usertag)];
    }
    else {
        length = (*p).length;
        lower = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
        elemtype = (i64)(*p).elemtag;
    }
;
    index -= lower;
    if (((u64)index >= (u64)length)) {
        if ((index < (i64)0)) {
            qq_lib$pcerror((byte*)"lwb");
        }
        else if ((index == length)) {
            if (((i64)v.tag == (i64)10)) {
                qq_lib$pcerror((byte*)"Can't append user type");
            }
;
            qq_arrays$obj_append_array(p,x);
        }
        else {
            qq_lib$pcerror((byte*)"ax[i]:=x bounds");
        }
;
    }
;
    if ((elemtype == (i64)31)) {
        if (((i64)(*x).tag != (i64)1)) {
            qq_lib$pcerror((byte*)"rhs not int");
        }
;
        (*a).tagx = (i64)1;
        (*((*p).ptr + index)) = (*x).value;
    }
    else {
        qq_packed$var_storepacked(((*p).ptr + (index * qq_tables$ttsize[(elemtype)])),x,elemtype);
    }
;
}

void qq_arrays$var_getixref_array(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  p;
        i64 elemtype;
        i64 length;
        i64 lower;
    v = (*a);
    p = v.objptr;
    if (((i64)v.tag == (i64)10)) {
        length = qq_tables$ttlength[((i64)(*p).usertag)];
        lower = qq_tables$ttlower[((i64)(*p).usertag)];
        elemtype = (i64)qq_tables$tttarget[((i64)(*p).usertag)];
    }
    else {
        length = (*p).length;
        lower = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
        elemtype = (i64)(*p).elemtag;
    }
;
    index -= lower;
    if (((u64)index >= (u64)length)) {
        if ((index < (i64)0)) {
            qq_lib$pcerror((byte*)"lwb");
        }
        else {
            if (((u64)index == (u64)length)) {
                qq_lib$pcerror((byte*)"PUTIXREF NEEDS IAPPEND");
                p = (*a).objptr;
            }
            else {
                qq_lib$pcerror((byte*)"ax[i]:=x bounds");
            }
;
        }
;
    }
;
    (*a).tagx = (i64)24;
    (*a).elemtag = elemtype;
    (*a).ptr = ((*p).ptr + (index * qq_tables$ttsize[(elemtype)]));
}

static void qq_arrays$obj_append_array(struct qq_decls$objrec *a,struct qq_decls$varrec *x) {
        i64 n;
        byte *  q;
    if (((i64)(*a).objtype != (i64)0)) {
        qq_lib$pcerror((byte*)"Can't extend slice");
    }
;
    if (!(!!(msysc$m_getdotindex((i64)(*a).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"Not mutable");
    }
;
    n = ((*a).length + (i64)1);
    if ((n > (*a).alloc64)) {
        qq_arrays$obj_resize_array(a,n);
    }
    else {
        (*a).length = n;
    }
;
    q = ((*a).ptr + ((n - (i64)1) * qq_tables$ttsize[((i64)(*a).elemtag)]));
    qq_packed$var_storepacked(q,x,(i64)(*a).elemtag);
}

void qq_arrays$var_appendto_array(struct qq_decls$varrec *a,struct qq_decls$varrec *x) {
    qq_arrays$obj_append_array((*a).objptr,x);
}

void qq_arrays$obj_resize_array(struct qq_decls$objrec *p,i64 n) {
        byte *  q;
        i64 elemsize;
    elemsize = qq_tables$ttsize[((i64)(*p).elemtag)];
    if ((n <= (*p).alloc64)) {
        (*p).length = n;
    }
    else {
        q = (byte *)mlib$pcm_alloc((n * elemsize));
        if (!!((*p).length)) {
            memcpy(q,(*p).ptr,(u64)((*p).length * elemsize));
            mlib$pcm_free((*p).ptr,((*p).alloc64 * elemsize));
        }
;
        (*p).ptr = q;
        (*p).length = n;
        (*p).alloc64 = (mlib$allocbytes / elemsize);
    }
;
}

void qq_arrays$var_dupl_array(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    q = qq_arrays$obj_newarray((i64)(*p).elemtag,(i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0),(*p).length);
    (*a).objptr = q;
    if (!!((*p).length)) {
        memcpy((*q).ptr,(*p).ptr,(u64)((*p).length * qq_tables$ttsize[((i64)(*p).elemtag)]));
    }
;
}

void qq_arrays$var_dupl_vector(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 length;
    p = (*a).objptr;
    length = qq_tables$ttlength[((i64)(*p).usertag)];
    q = qq_arrays$obj_newarray_u((i64)(*p).usertag);
    (*a).objptr = q;
    if (!!(length)) {
        memcpy((*q).ptr,(*p).ptr,(u64)qq_tables$ttsize[((i64)(*p).usertag)]);
    }
;
}

i64 qq_arrays$var_equal_array(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 length;
        i64 elemsize;
    p = (*a).objptr;
    q = (*b).objptr;
    elemsize = (i64)(*p).elemtag;
    if (((i64)(*p).elemtag != (i64)(*q).elemtag)) {
        return (i64)0;
    }
;
    length = (*p).length;
    if ((length != (*q).length)) {
        return (i64)0;
    }
;
    if ((length == (i64)0)) {
        return (i64)1;
    }
;
    return mlib$eqbytes((*p).ptr,(*q).ptr,(qq_tables$ttsize[((i64)(*p).elemtag)] * length));
}

void qq_arrays$var_concatto_array(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        byte *  d;
        i64 alen;
        i64 blen;
        i64 newlen;
        i64 elemsize;
        struct qq_decls$objrec *  pa;
        struct qq_decls$objrec *  pb;
    pa = (*a).objptr;
    pb = (*b).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*pa).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"concatarray/not mut");
    }
;
    if (((i64)(*pa).elemtag != (i64)(*pb).elemtag)) {
        qq_lib$pcerror((byte*)"concat/not compat");
    }
;
    elemsize = qq_tables$ttsize[((i64)(*pa).elemtag)];
    alen = (*pa).length;
    blen = (*pb).length;
    if ((alen == (i64)0)) {
        if (!!(blen)) {
            qq_arrays$obj_resize_array(pa,blen);
            d = (*pa).ptr;
            memcpy(d,(*pb).ptr,(u64)(blen * elemsize));
        }
;
    }
    else if (!!(blen)) {
        newlen = (alen + blen);
        qq_arrays$obj_resize_array(pa,newlen);
        d = ((*pa).ptr + (alen * elemsize));
        memcpy(d,(*pb).ptr,(u64)(blen * elemsize));
    }
;
}

void qq_arrays$var_getslice_array(struct qq_decls$varrec *a,i64 i,i64 j) {
        i64 alower;
        i64 elemsize;
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    alower = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    elemsize = qq_tables$ttsize[((i64)(*p).elemtag)];
    if ((((i < alower) || (j > (((*p).length + alower) - (i64)1))) || (i > j))) {
        qq_lib$pcerror((byte*)"array/slice bounds");
    }
;
    q = qq_vars$obj_new();
    (*q).objtype = (i64)1;
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)1,msysc$m_getdotindex((i64)(*p).flags,(i64)1));
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)0,(u64)1u);
    (*q).ptr = ((*p).ptr + ((i - alower) * elemsize));
    (*q).elemtag = (i64)(*p).elemtag;
        {i64 $temp = (i64)(*p).objtype;
if (($temp==(i64)1)) {
        (*q).objptr2 = (*p).objptr2;
        qq_vars$obj_shareu((*q).objptr2);
    }
    else if (($temp==(i64)2)) {
        (*q).objptr2 = 0;
        (*q).objtype = (i64)2;
    }
    else {
        (*q).objptr2 = p;
        ++((*p).refcount);
    }
    };
    (*q).length = ((j - i) + (i64)1);
    (*a).objptr = q;
}

void qq_arrays$var_putslice_array(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x) {
        byte *  r;
        byte *  s;
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 length;
        i64 sublength;
        i64 elemsize;
    if (((i64)(*a).tag == (i64)10)) {
        qq_lib$pcerror((byte*)"userax/putslice");
    }
;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"Not mutable");
    }
;
    length = (*p).length;
    if ((((i < (i64)1) || (j > (*p).length)) || (i > j))) {
        qq_lib$pcerror((byte*)"array/slice bounds");
    }
;
    sublength = ((j - i) + (i64)1);
    q = (*x).objptr;
    if (((*q).length < sublength)) {
        qq_lib$pcerror((byte*)"substr too short");
    }
;
    if (((i64)(*p).elemtag != (i64)(*q).elemtag)) {
        qq_lib$pcerror((byte*)"Not compat");
    }
;
    elemsize = qq_tables$ttsize[((i64)(*p).elemtag)];
    r = ((*p).ptr + ((i - (i64)1) * elemsize));
    s = (*q).ptr;
    memcpy(r,s,(u64)(sublength * elemsize));
}

static i64 qq_arrays$u8inarray(byte a,struct qq_decls$objrec *p) {
        i64 i;
        byte *  q;
        i64 $av_1;
    i = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    q = (*p).ptr;
    $av_1 = (*p).length;
    while ($av_1-- > 0) {
L55 :;
        if (((i64)(*q) == (i64)a)) {
            return i;
        }
;
        ++(q);
        ++(i);
L56 :;
    }
L57 :;
    ;
    return (i64)(-9223372036854775807-1);
}

i64 qq_arrays$u16inarray(u16 a,struct qq_decls$objrec *p) {
        i64 i;
        u16 *  q;
        i64 $av_1;
    i = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    q = (u16 *)(*p).ptr;
    $av_1 = (*p).length;
    while ($av_1-- > 0) {
L58 :;
        if (((i64)(*q) == (i64)a)) {
            return i;
        }
;
        ++(q);
        ++(i);
L59 :;
    }
L60 :;
    ;
    return (i64)(-9223372036854775807-1);
}

i64 qq_arrays$u32inarray(u32 a,struct qq_decls$objrec *p) {
        i64 i;
        u32 *  q;
        i64 $av_1;
    i = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    q = (u32 *)(*p).ptr;
    $av_1 = (*p).length;
    while ($av_1-- > 0) {
L61 :;
        if (((i64)(*q) == (i64)a)) {
            return i;
        }
;
        ++(q);
        ++(i);
L62 :;
    }
L63 :;
    ;
    return (i64)(-9223372036854775807-1);
}

i64 qq_arrays$u64inarray(u64 a,struct qq_decls$objrec *p) {
        i64 i;
        u64 *  q;
        i64 $av_1;
    i = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    q = (u64 *)(*p).ptr;
    $av_1 = (*p).length;
    while ($av_1-- > 0) {
L64 :;
        if (((*q) == a)) {
            return i;
        }
;
        ++(q);
        ++(i);
L65 :;
    }
L66 :;
    ;
    return (i64)(-9223372036854775807-1);
}

i64 qq_arrays$var_inx_array(struct qq_decls$varrec *a,struct qq_decls$varrec *b,i64 usertag) {
        i64 n;
        struct qq_decls$objrec *  q;
        i64 elemtag;
    q = (*b).objptr;
    if (!!(usertag)) {
        elemtag = (i64)qq_tables$tttarget[(usertag)];
    }
    else {
        elemtag = (i64)(*q).elemtag;
    }
;
    if ((elemtag==(i64)28) || (elemtag==(i64)31)) {
        n = qq_arrays$u8inarray((byte)(*a).value,q);
    }
    else if ((elemtag==(i64)29) || (elemtag==(i64)32)) {
        n = qq_arrays$u16inarray((u16)(*a).value,q);
    }
    else if ((elemtag==(i64)30) || (elemtag==(i64)33)) {
        n = qq_arrays$u32inarray((u32)(*a).value,q);
    }
    else if ((elemtag==(i64)1) || (elemtag==(i64)2)) {
        n = qq_arrays$u64inarray((u64)(*a).value,q);
    }
    else {
        qq_lib$pcustype((byte*)"x in array",b);
    }
;
    return n;
}

void qq_arrays$var_expand_array(struct qq_decls$varrec *p,struct qq_decls$varrec *dest,i64 m) {
        byte *  q;
        i64 n;
        i64 elemtype;
        i64 length;
        struct qq_decls$objrec *  pa;
        i64 $av_1;
    pa = (*p).objptr;
    if (((i64)(*p).tag == (i64)14)) {
        length = (*pa).length;
        elemtype = (i64)(*pa).elemtag;
    }
    else {
        length = qq_tables$ttlength[((i64)(*pa).usertag)];
        elemtype = (i64)qq_tables$tttarget[((i64)(*pa).usertag)];
    }
;
    q = (*pa).ptr;
    n = (i64)1;
    $av_1 = m;
    while ($av_1-- > 0) {
L67 :;
        if ((n > length)) {
            (*dest).tagx = (i64)0;
        }
        else {
            qq_packed$var_loadpacked(q,elemtype,dest,0);
            q += qq_tables$ttsize[(elemtype)];
        }
;
        ++(n);
        --(dest);
L68 :;
    }
L69 :;
    ;
}

void qq_arrays$var_nextiter_array(struct qq_decls$varrec *a,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 elemtype;
        i64 index;
    p = (*a).objptr;
    q = (*p).objptr2;
    elemtype = (i64)(*q).elemtag;
    if (((i64)(*p).iterpos >= (i64)(*p).iterupper)) {
        (*dest).tagx = (i64)0;
        return;
    }
;
    ++((*p).iterpos);
    index = ((i64)(*p).iterpos - (i64)msysc$m_getdotindex((i64)(*q).flags,(i64)0));
    qq_packed$var_loadpacked(((*q).ptr + (index * qq_tables$ttsize[(elemtype)])),elemtype,dest,0);
}

// START
void qq_arrays$start(void) {

}

void qq_bits$obj_free_bits(struct qq_decls$objrec *p,i64 tag) {
    if (!!((*p).length)) {
        mlib$pcm_free((*p).ptr,qq_bits$getbitssize((*p).alloc64,(i64)(*p).elemtag));
    }
;
    mlib$pcm_free32(p);
}

void qq_bits$var_make_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 lower,i64 n,i64 bxtype,i64 elemtype) {
        struct qq_decls$objrec *  p;
        byte *  q;
        i64 bitwidthx;
        i64 offset;
        i64 $av_1;
    p = qq_bits$obj_newbits(elemtype,lower,n);
    q = (*p).ptr;
    bitwidthx = (i64)qq_tables$ttbitwidth[(elemtype)];
    offset = (i64)0;
    $av_1 = n;
    while ($av_1-- > 0) {
L70 :;
        qq_vars$var_storebit(q,offset,a,elemtype,bitwidthx);
        offset += bitwidthx;
        if ((offset >= (i64)8)) {
            ++(q);
            offset = (i64)0;
        }
;
        ++(a);
L71 :;
    }
L72 :;
    ;
    (*dest).tagx = (bxtype | (i64)256);
    (*dest).objptr = p;
}

struct qq_decls$objrec *qq_bits$obj_newbits(i64 elemtype,i64 lower,i64 length) {
        struct qq_decls$objrec *  p;
        i64 nbytes;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)0,(u64)lower);
    (*p).length = length;
    (*p).objtype = (i64)0;
    (*p).elemtag = elemtype;
    if (!!(length)) {
        nbytes = qq_bits$getbitssize(length,elemtype);
        (*p).ptr = (byte *)mlib$pcm_allocz(nbytes);
        (*p).alloc64 = (mlib$allocbytes * ((i64)8 / (i64)qq_tables$ttbitwidth[(elemtype)]));
    }
;
    return p;
}

void qq_bits$var_getix_bits(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  p;
        byte *  q;
        i64 elemtype;
        i64 shift;
    p = (*a).objptr;
    elemtype = (i64)(*p).elemtag;
    index -= (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    if (((u64)index >= (u64)(*p).length)) {
        qq_lib$pcerror((byte*)"ax[int] bounds");
    }
;
    q = (*p).ptr;
    (*a).tagx = (i64)1;
    index += (i64)(*p).indexoffset;
    switch ((i64)(*p).elemtag) {
    case 35:;
        {
            (*a).value = (i64)!!(((i64)(*(q + (index >> (i64)3))) & ((i64)1 << (index & (i64)7))));
        }
        break;
    case 36:;
        {
            shift = ((index & (i64)3) * (i64)2);
            (*a).value = (((i64)(*(q + (index >> (i64)2))) & ((i64)3 << shift)) >> shift);
        }
        break;
    case 37:;
        {
            shift = ((index & (i64)1) * (i64)4);
            (*a).value = (((i64)(*(q + (index >> (i64)1))) & ((i64)15 << shift)) >> shift);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"bitix",(i64)(*p).elemtag);
    }
    } //SW
;
}

void qq_bits$var_putix_bits(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        struct qq_decls$objrec *  p;
        byte *  q;
        i64 elemtype;
        i64 newoffset;
    p = (*a).objptr;
    elemtype = (i64)(*p).elemtag;
    index -= (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    if (((u64)index >= (u64)(*p).length)) {
        if ((index < (i64)0)) {
            qq_lib$pcerror((byte*)"lwb");
        }
        else if ((index == (*p).length)) {
            qq_bits$obj_append_bits(p,x);
        }
        else {
            qq_lib$pcerror((byte*)"bx[i]:=x bounds");
        }
;
    }
;
    q = qq_bits$getindexoffset((*p).ptr,(i64)(*p).indexoffset,index,elemtype,&newoffset);
    qq_vars$var_storebit(q,(newoffset * (i64)qq_tables$ttbitwidth[(elemtype)]),x,elemtype,(i64)0);
}

void qq_bits$var_getixref_bits(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  p;
        byte *  q;
        i64 newoffset;
        i64 elemtype;
    p = (*a).objptr;
    elemtype = (i64)(*p).elemtag;
    index -= (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    if (((u64)index >= (u64)(*p).length)) {
        qq_lib$pcerror((byte*)"&bx[i] bounds");
    }
;
    q = qq_bits$getindexoffset((*p).ptr,(i64)(*p).indexoffset,index,elemtype,&newoffset);
    (*a).tagx = (i64)18;
    (*a).elemtag = elemtype;
    (*a).ptr = q;
    (*a).bitoffset = (newoffset * (i64)qq_tables$ttbitwidth[(elemtype)]);
}

static byte *qq_bits$getindexoffset(byte *p,i64 offset,i64 index,i64 t,i64 *newoffset) {
    index += offset;
    switch (t) {
    case 35:;
        {
            p += (index >> (i64)3);
            (*newoffset) = (index & (i64)7);
        }
        break;
    case 36:;
        {
            p += (index >> (i64)2);
            (*newoffset) = (index & (i64)3);
        }
        break;
    case 37:;
        {
            index += (offset >> (i64)2);
            p += (index >> (i64)1);
            (*newoffset) = (index & (i64)1);
        }
        break;
    } //SW
;
    return p;
}

static void qq_bits$obj_append_bits(struct qq_decls$objrec *a,struct qq_decls$varrec *x) {
        i64 n;
        i64 newoffset;
        i64 elemtype;
        byte *  q;
    if (((i64)(*a).objtype != (i64)0)) {
        qq_lib$pcerror((byte*)"Can't extend slice");
    }
;
    if (!(!!(msysc$m_getdotindex((i64)(*a).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"Not mutable");
    }
;
    n = ((*a).length + (i64)1);
    elemtype = (i64)(*a).elemtag;
    if ((n > (*a).alloc64)) {
        qq_bits$obj_resize_bits(a,n);
    }
    else {
        (*a).length = n;
    }
;
    q = qq_bits$getindexoffset((*a).ptr,(i64)(*a).indexoffset,(n - (i64)msysc$m_getdotindex((i64)(*a).flags,(i64)0)),elemtype,&newoffset);
    qq_vars$var_storebit(q,(newoffset * (i64)qq_tables$ttbitwidth[(elemtype)]),x,elemtype,(i64)0);
}

void qq_bits$var_appendto_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *x) {
    qq_bits$obj_append_bits((*a).objptr,x);
}

void qq_bits$obj_resize_bits(struct qq_decls$objrec *p,i64 n) {
        byte *  q;
        i64 newsize;
        i64 elemtype;
    elemtype = (i64)(*p).elemtag;
    if ((n <= (*p).alloc64)) {
        (*p).length = n;
    }
    else {
        newsize = qq_bits$getbitssize(n,elemtype);
        q = (byte *)mlib$pcm_alloc(newsize);
        if (!!((*p).length)) {
            memcpy(q,(*p).ptr,(u64)qq_bits$bits_bytesize(p));
            mlib$pcm_free((*p).ptr,qq_bits$getbitssize((*p).alloc64,elemtype));
        }
;
        (*p).ptr = q;
        (*p).length = n;
        (*p).alloc64 = (mlib$allocbytes * ((i64)8 / (i64)qq_tables$ttbitwidth[(elemtype)]));
    }
;
}

void qq_bits$var_dupl_bits(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    q = qq_bits$obj_newbits((i64)(*p).elemtag,(i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0),(*p).length);
    (*q).indexoffset = (i64)(*p).indexoffset;
    (*a).objptr = q;
    if (!!((*p).length)) {
        memcpy((*q).ptr,(*p).ptr,(u64)qq_bits$bits_bytesize(p));
    }
;
}

i64 qq_bits$var_equal_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 length;
        i64 elemsize;
    p = (*a).objptr;
    q = (*b).objptr;
    elemsize = (i64)(*p).elemtag;
    if (((i64)(*p).elemtag != (i64)(*q).elemtag)) {
        return (i64)0;
    }
;
    length = (*p).length;
    if ((length != (*q).length)) {
        return (i64)0;
    }
;
    if ((length == (i64)0)) {
        return (i64)1;
    }
;
    return mlib$eqbytes((*p).ptr,(*q).ptr,qq_bits$bits_bytesize(p));
}

void qq_bits$var_concatto_bits(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        byte *  d;
        i64 alen;
        i64 blen;
        i64 newlen;
        i64 elemsize;
        struct qq_decls$objrec *  pa;
        struct qq_decls$objrec *  pb;
    qq_lib$pcerror_s((byte*)"VAR/BITS/NOT READY",(byte*)"var_concatto_bits");
    pa = (*a).objptr;
    pb = (*b).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*pa).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"concatarray/not mut");
    }
;
    if (((i64)(*pa).elemtag != (i64)(*pb).elemtag)) {
        qq_lib$pcerror((byte*)"concat/not compat");
    }
;
    elemsize = qq_tables$ttsize[((i64)(*pa).elemtag)];
    alen = (*pa).length;
    blen = (*pb).length;
    if ((alen == (i64)0)) {
        if (!!(blen)) {
            qq_bits$obj_resize_bits(pa,blen);
            d = (*pa).ptr;
            memcpy(d,(*pb).ptr,(u64)(blen * elemsize));
        }
;
    }
    else if (!!(blen)) {
        newlen = (alen + blen);
        qq_bits$obj_resize_bits(pa,newlen);
        d = ((*pa).ptr + (alen * elemsize));
        memcpy(d,(*pb).ptr,(u64)(blen * elemsize));
    }
;
}

void qq_bits$var_getslice_bits(struct qq_decls$varrec *a,i64 i,i64 j) {
        i64 alower;
        i64 elemtype;
        i64 newoffset;
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    alower = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    elemtype = (i64)(*p).elemtag;
    if ((((i < alower) || (j > (((*p).length + alower) - (i64)1))) || (i > j))) {
        qq_lib$pcerror((byte*)"bits/slice bounds");
    }
;
    q = qq_vars$obj_new();
    (*q).objtype = (i64)1;
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)1,msysc$m_getdotindex((i64)(*p).flags,(i64)1));
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)0,(u64)1u);
    (*q).elemtag = elemtype;
    (*q).ptr = qq_bits$getindexoffset((*p).ptr,(i64)(*p).indexoffset,(i - alower),elemtype,&newoffset);
    (*q).indexoffset = newoffset;
        {i64 $temp = (i64)(*p).objtype;
if (($temp==(i64)1)) {
        (*q).objptr2 = (*p).objptr2;
        qq_vars$obj_shareu((*q).objptr2);
    }
    else if (($temp==(i64)2)) {
        (*q).objptr2 = 0;
        (*q).objtype = (i64)2;
    }
    else {
        (*q).objptr2 = p;
        ++((*p).refcount);
    }
    };
    (*q).length = ((j - i) + (i64)1);
    (*a).objptr = q;
}

void qq_bits$var_putslice_bits(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x) {
        byte *  pp;
        byte *  qq;
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 length;
        i64 sublength;
        i64 elemtype;
        i64 offsetp;
        i64 offsetq;
        i64 bitwidthx;
        struct qq_decls$varrec v;
        i64 $av_1;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"Not mutable");
    }
;
    length = (*p).length;
    elemtype = (i64)(*p).elemtag;
    if ((((i < (i64)1) || (j > (*p).length)) || (i > j))) {
        qq_lib$pcerror((byte*)"bits/slice bounds");
    }
;
    sublength = ((j - i) + (i64)1);
    q = (*x).objptr;
    if (((*q).length < sublength)) {
        qq_lib$pcerror((byte*)"substr too short");
    }
;
    if (((i64)(*p).elemtag != (i64)(*q).elemtag)) {
        qq_lib$pcerror((byte*)"Not compat");
    }
;
    bitwidthx = (i64)qq_tables$ttbitwidth[(elemtype)];
    pp = qq_bits$getindexoffset((*p).ptr,(i64)(*p).indexoffset,(i - (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0)),elemtype,&offsetp);
    qq = qq_bits$getindexoffset((*q).ptr,(i64)(*q).indexoffset,(i64)0,elemtype,&offsetq);
    offsetq *= bitwidthx;
    offsetq *= bitwidthx;
    $av_1 = sublength;
    while ($av_1-- > 0) {
L73 :;
        qq_vars$var_loadbit(qq,offsetq,elemtype,(i64)0,&v);
        qq_vars$var_storebit(pp,offsetp,&v,elemtype,(i64)0);
        offsetp += bitwidthx;
        if ((offsetp >= (i64)8)) {
            ++(pp);
            offsetp = (i64)0;
        }
;
        offsetq += bitwidthx;
        if ((offsetq >= (i64)8)) {
            ++(qq);
            offsetq = (i64)0;
        }
;
L74 :;
    }
L75 :;
    ;
}

i64 qq_bits$bits_bytesize(struct qq_decls$objrec *p) {
    return qq_bits$getbitssize((*p).length,(i64)(*p).elemtag);
}

i64 qq_bits$getbitssize(i64 n,i64 t) {
        i64 nbits;
    nbits = (n * (i64)qq_tables$ttbitwidth[(t)]);
    return ((((nbits - (i64)1) / (i64)64) + (i64)1) * (i64)8);
}

// START
void qq_bits$start(void) {

}

void qq_calldll$calldll(struct qq_decls$strec *d,struct qq_decls$varrec *args,struct qq_decls$varrec *result,i64 nargs) {
        struct qq_decls$strec *  e;
        i64 arglist[100];
        i64 n;
        i64 retcode;
        i64 retval;
        void (*fnaddr)(void);
        i64 i;
    if ((nargs > (i64)100)) {
        qq_lib$pcerror((byte*)"Too many dll args");
    }
;
    e = (*d).deflist;
    n = (i64)0;
    for (i=(i64)1;i<=nargs;++i) {
L76 :;
        if ((e == 0)) {
            if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)8))) {
                arglist[(i)-1] = (i64)qq_calldll$vartopacked(args,0);
                ++(args);
            }
            else {
                qq_lib$pcerror((byte*)"Too many dll args");
            }
;
        }
        else {
            arglist[(i)-1] = (i64)qq_calldll$vartopacked(args,e);
            ++(args);
            e = (*e).nextdef;
        }
;
L77 :;
    }
L78 :;
    ;
    if (((i64)(*d).mode == (i64)3)) {
        retcode = (i64)82;
    }
    else {
        retcode = (i64)73;
    }
;
    fnaddr = (void (*)(void))qq_calldll$getlibprocaddr(d);
    retval = (i64)mwindllc$os_calldllfunction((void (*)(void))fnaddr,retcode,nargs,(i64 (*)[])&arglist,0);
    if (!!((i64)(*d).mode)) {
        qq_calldll$packedtovar((u64)retval,(i64)(*d).mode,result);
    }
;
}

static void (*qq_calldll$getlibprocaddr(struct qq_decls$strec *d))(void) {
        void (*fnaddr)(void);
    fnaddr = (void (*)(void))qq_decls$dllprocaddr[((*d).index)-1];
    if ((fnaddr == 0)) {
        if (((i64)qq_decls$libtypes[((i64)qq_decls$dllproclibindex[((*d).index)-1])-1] == (i64)68)) {
            fnaddr = (void (*)(void))qq_calldll$loaddllfunction(d);
        }
        else {
            mlib$abortprogram((byte*)"LOADLIB MISSING");
        }
;
    }
;
    return fnaddr;
}

static u64 qq_calldll$vartopacked(struct qq_decls$varrec *p,struct qq_decls$strec *d) {
        i64 s;
        i64 t;
        struct qq_decls$objrec *  a;
    s = (i64)(*p).tag;
    if ((d == 0)) {
        if ((s==(i64)12)) {
            a = (*p).objptr;
            return (u64)msysc$m_tp_reftoi64(qq_lib$convtostringz((*a).strptr,(*a).length));
        }
        else if ((s==(i64)1) || (s==(i64)3) || (s==(i64)2) || (s==(i64)24)) {
            return (u64)(*p).value;
        }
        else {
            qq_lib$pcerror((byte*)"Bad variadic param");
        }
;
    }
;
    t = (i64)(*d).mode;
    switch ((i64)qq_tables$ttbasetype[(t)]) {
    case 1:;
    case 2:;
    case 30:;
    case 33:;
    case 29:;
    case 32:;
        {
            if ((s==(i64)1) || (s==(i64)2) || (s==(i64)24) || (s==(i64)17)) {
                return (u64)(*p).value;
            }
            else if ((s==(i64)3)) {
                return (u64)(i64)(*p).xvalue;
            }
            else {
                //error:
L79 :;
;
                msysc$m_print_startcon();
                msysc$m_print_setfmt((byte*)"'#' should be '#' (param # #)");
                msysc$m_print_str(qq_dummyshow$strmode(s,(i64)1),NULL);
                msysc$m_print_str(qq_dummyshow$strmode(t,(i64)0),NULL);
                msysc$m_print_str((*d).name,NULL);
                msysc$m_print_i64((*d).index,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                qq_lib$pcerror((byte*)"DLL: wrong param type");
            }
;
        }
        break;
    case 3:;
        {
            if ((s==(i64)1) || (s==(i64)2)) {
                return (u64)msysc$m_tp_r64toi64((r64)(*p).value);
            }
            else if ((s==(i64)3)) {
                return (u64)msysc$m_tp_r64toi64((*p).xvalue);
            }
            else {
                goto L79 ;
;
            }
;
        }
        break;
    case 40:;
        {
            if ((s==(i64)12)) {
                a = (*p).objptr;
                return (u64)msysc$m_tp_reftoi64(qq_lib$convtostringz((*a).strptr,(*a).length));
            }
            else if ((s==(i64)24)) {
                return (u64)msysc$m_tp_reftoi64((*p).ptr);
            }
            else {
                goto L79 ;
;
            }
;
        }
        break;
    case 24:;
        {
            if ((s==(i64)24)) {
                return (u64)(*p).ptr;
            }
            else if ((s==(i64)14) || (s==(i64)10)) {
                return (u64)(*(*p).objptr).ptr;
            }
            else {
                goto L79 ;
;
            }
;
        }
        break;
    case 42:;
        {
            return (u64)((byte *)(*p).objptr + (i64)8);
        }
        break;
    default: {
        qq_lib$pcmxtypestt((byte*)"DLL params:",s,t);
    }
    } //SW
;
    return (u64)0u;
}

static void qq_calldll$packedtovar(u64 retval,i64 t,struct qq_decls$varrec *dest) {
        i64 tbase;
    tbase = (i64)qq_tables$ttbasetype[(t)];
    switch (tbase) {
    case 0:;
        {
        }
        break;
    case 3:;
        {
            (*dest).tagx = (i64)3;
            (*dest).xvalue = *(r64*)&retval;
        }
        break;
    case 34:;
        {
            qq_lib$pcerror((byte*)"dll/r32ret");
        }
        break;
    case 1:;
    case 2:;
        {
            (*dest).tagx = (i64)1;
            (*dest).value = (i64)retval;
        }
        break;
    case 30:;
        {
            (*dest).tagx = (i64)1;
            (*dest).value = (i64)(i32)retval;
        }
        break;
    case 33:;
        {
            (*dest).tagx = (i64)1;
            (*dest).value = (i64)(u32)retval;
        }
        break;
    case 29:;
        {
            (*dest).tagx = (i64)1;
            (*dest).value = (i64)(i16)retval;
        }
        break;
    case 32:;
        {
            (*dest).tagx = (i64)1;
            (*dest).value = (i64)(u16)retval;
        }
        break;
    case 24:;
        {
            (*dest).tagx = (i64)24;
            (*dest).ptr = (byte *)retval;
            (*dest).elemtag = (i64)qq_tables$tttarget[(t)];
        }
        break;
    case 40:;
        {
            qq_strings$var_make_string((u8 *)retval,dest,(i64)0);
        }
        break;
    default: {
        qq_lib$pcerror_s((byte*)"Rettype not supported:",qq_tables$ttname[(t)]);
    }
    } //SW
;
}

static void (*qq_calldll$loaddllfunction(struct qq_decls$strec *d))(void) {
        i64 fnindex;
        i64 libindex;
        u64 dllinst;
        void (*fnaddr)(void);
        u8 *  name;
    fnindex = (*d).index;
    fnaddr = (void (*)(void))qq_decls$dllprocaddr[(fnindex)-1];
    if (!!(fnaddr)) {
        return (void (*)(void))fnaddr;
    }
;
    libindex = (i64)qq_decls$dllproclibindex[(fnindex)-1];
    dllinst = qq_decls$dllinsttable[(libindex)-1];
    if (((i64)dllinst == (i64)0)) {
        dllinst = mwindows$os_getdllinst((*qq_decls$libtable[(libindex)-1]).name);
        if (((i64)dllinst == (i64)0)) {
            qq_lib$pcerror_s((byte*)"Can't load DLL:",(*qq_decls$libtable[(libindex)-1]).name);
        }
;
        qq_decls$dllinsttable[(libindex)-1] = dllinst;
    }
;
    name = (!!((*d).truename) ? (*d).truename : (*d).name);
    fnaddr = (void (*)(void))mwindows$os_getdllprocaddr((i64)dllinst,name);
    if ((fnaddr == 0)) {
        qq_lib$pcerror_s((byte*)"Can't find DLL func:",name);
    }
;
    qq_decls$dllprocaddr[(fnindex)-1] = fnaddr;
    return (void (*)(void))fnaddr;
}

// START
void qq_calldll$start(void) {

}

void qq_decimal$obj_free_dec(struct qq_decls$objrec *p) {
    if (!!((*p).length)) {
        mlib$pcm_free((*p).num,((*p).length * (i64)4));
    }
;
    mlib$pcm_free32(p);
}

void qq_decimal$var_dupl_dec(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 size;
    q = (*a).objptr;
    p = qq_vars$obj_new();
    (*p).length = (*q).length;
    (*p).expon = (i64)(*q).expon;
    (*p).neg = (i64)(*q).neg;
    (*p).numtype = (i64)(*q).numtype;
    size = ((*q).length * (i64)4);
    if (!!(size)) {
        (*p).num = (i32 (*)[])mlib$pcm_alloc(size);
        memcpy((*p).num,(*q).num,(u64)size);
    }
;
    (*a).objptr = p;
}

void qq_decimal$var_empty_dec(struct qq_decls$varrec *dest) {
    (*dest).tagx = (i64)260;
    (*dest).objptr = qq_decimal$makebignum((i64)0);
}

void qq_decimal$var_make_dec_str(u8 *s,i64 length,struct qq_decls$varrec *dest) {
    (*dest).tagx = (i64)260;
    (*dest).objptr = qq_decimal$bn_makestr(s,length);
}

void qq_decimal$var_make_dec_int(i64 a,struct qq_decls$varrec *dest) {
    (*dest).tagx = (i64)260;
    (*dest).objptr = qq_decimal$bn_makeint(a);
}

static struct qq_decls$objrec *qq_decimal$badnumber(void) {
        struct qq_decls$objrec *  c;
    c = qq_decimal$makebignum((i64)0);
    (*c).numtype = (i64)3;
    return c;
}

static struct qq_decls$objrec *qq_decimal$bn_makestr(u8 *s,i64 length) {
        u8 *  t;
        u8 *  u;
        u8 *  oldt;
        i64 tlength;
        i64 neg;
        i64 dpindex;
        i64 expon;
        i64 nonzeros;
        i64 talloc;
        i64 dpseen;
        i64 leadingzeros;
        i64 trailingzeros;
        i64 zerosafterdp;
        i64 d;
        i64 n;
        i64 wd;
        i64 dp;
        i64 wdp;
        i64 w;
        i64 d2;
        i64 na;
        i64 nb;
        struct qq_decls$objrec *  a;
        i64 $av_1;
        i64 $av_2;
        i64 i;
    if ((length == (i64)0)) {
        length = strlen(s);
    }
;
    if ((length <= (i64)0)) {
        return qq_decimal$badnumber();
    }
;
    t = (u8 *)malloc((u64)(length + (i64)1));
    memcpy((void *)t,(void *)s,(u64)length);
    (*(t + length)) = (u64)0u;
    oldt = t;
    tlength = (length + (i64)1);
    s = t;
    talloc = ((length + (i64)1) + (i64)10);
    neg = (i64)0;
        {u64 $temp = (u64)(*s);
if (($temp=='+')) {
        ++(s);
    }
    else if (($temp=='-')) {
        neg = (i64)1;
        ++(s);
    }
    };
    t = (u = (u8 *)mlib$pcm_alloc(talloc));
    dpindex = (i64)-1;
    dpseen = (zerosafterdp = (i64)0);
    nonzeros = (i64)0;
    leadingzeros = (trailingzeros = (i64)0);
    expon = (i64)0;
    L80 :;
    switch ((i64)(u64)(*s)) {
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        {
            (*(u)++) = (u64)(*(s)++);
            trailingzeros = (i64)0;
            nonzeros = (i64)1;
        }
        break;
    case 48:;
        {
            if (!!(nonzeros)) {
                ++(trailingzeros);
                (*(u)++) = (u64)(*(s)++);
            }
            else {
                ++(leadingzeros);
                if (!!(dpseen)) {
                    ++(zerosafterdp);
                }
;
                ++(s);
            }
;
        }
        break;
    case 95:;
    case 39:;
    case 96:;
    case 32:;
    case 13:;
    case 10:;
        {
            ++(s);
        }
        break;
    case 46:;
        {
            if ((!!(dpseen) || (dpindex >= (i64)0))) {
                return qq_decimal$badnumber();
            }
;
            if (!!(nonzeros)) {
                dpindex = (u - t);
            }
            else {
                dpseen = (i64)1;
            }
;
            ++(s);
        }
        break;
    case 0:;
        {
            goto L81 ;
        }
        break;
    case 101:;
    case 69:;
        {
            expon = qq_decimal$readexpon((s + (i64)1));
            goto L81 ;
        }
        break;
    default: {
        return qq_decimal$badnumber();
    }
    } //SW
goto L80 ;
L81 :;
    ;
    (*u) = (u64)0u;
    length = (u - t);
    if ((dpindex < (i64)0)) {
        if (!!(dpseen)) {
            dpindex = -(zerosafterdp);
        }
        else {
            dpindex = length;
        }
;
    }
;
    length -= trailingzeros;
    (*(t + length)) = (u64)0u;
    if ((length == (i64)0)) {
        return qq_decimal$bn_makeint((i64)0);
    }
;
    d = ((dpindex - (i64)1) + expon);
    n = length;
    dp = (i64)0;
    na = (i64)1;
    nb = (n - na);
    w = (i64)9;
    if ((d >= (i64)0)) {
        wd = (d / w);
        wdp = (d % w);
    }
    else {
        d2 = m$llabs((d + (i64)1));
        wd = -(((d2 / w) + (i64)1));
        wdp = ((w - (i64)1) - (d2 % w));
    }
;
    na = (wdp + (i64)1);
    nb = msysc$m_imax((n - na),(i64)0);
    L82 :;
    while (!!((nb % w))) {
        ++(nb);
L83 :;
    }
L84 :;
    ;
    length = ((nb / w) + (i64)1);
    u = (t + n);
    $av_1 = ((na + nb) - n);
    while ($av_1-- > 0) {
L85 :;
        (*(u)++) = '0';
L86 :;
    }
L87 :;
    ;
    n = (na + nb);
    (*(t + n)) = (u64)0u;
    a = qq_decimal$makebignum(length);
    (*a).neg = neg;
    (*a).expon = wd;
    u = t;
    (*(*a).num)[((i64)0)] = qq_decimal$strvaln(u,na);
    u += na;
        ($av_2 = (length - (i64)1));
    for (i=(i64)1;i<=$av_2;++i) {
L88 :;
        (*(*a).num)[(i)] = qq_decimal$strvaln(u,w);
        u += w;
L89 :;
    }
L90 :;
    ;
    mlib$pcm_free((void *)t,talloc);
    free((void *)oldt);
    return a;
}

static i64 qq_decimal$readexpon(u8 *s) {
        i64 neg;
        i64 expon;
    neg = (expon = (i64)0);
        {u64 $temp = (u64)(*s);
if (($temp=='+')) {
        ++(s);
    }
    else if (($temp=='-')) {
        neg = (i64)1;
        ++(s);
    }
    };
    L91 :;
    switch ((i64)(u64)(*s)) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        {
            expon = ((expon * (i64)10) + (i64)((u64)(*s) - '0'));
            ++(s);
        }
        break;
    case 95:;
    case 39:;
    case 96:;
    case 32:;
        {
            ++(s);
        }
        break;
    case 0:;
        {
            goto L92 ;
        }
        break;
    default: {
        qq_lib$pcerror((byte*)"make expon?");
    }
    } //SW
goto L91 ;
L92 :;
    ;
    if (!!(neg)) {
        return -(expon);
    }
    else {
        return expon;
    }
;
}

static struct qq_decls$objrec *qq_decimal$bn_makeint(i64 x) {
        struct qq_decls$objrec *  a;
        u8 str[256];
    if ((x == (i64)0)) {
        a = qq_decimal$makebignum((i64)0);
    }
    else if ((x >= (i64)0 && x <= (i64)999999999)) {
        a = qq_decimal$makebignum((i64)1);
        (*(*a).num)[((i64)0)] = x;
    }
    else if ((-(x) >= (i64)0 && -(x) <= (i64)999999999)) {
        a = qq_decimal$makebignum((i64)1);
        (*(*a).num)[((i64)0)] = -(x);
        (*a).neg = (i64)1;
    }
    else {
        msysc$m_print_startstr(str);
        msysc$m_print_i64(x,NULL);
        msysc$m_print_end();
        ;
        a = qq_decimal$bn_makestr(str,(i64)0);
    }
;
    return a;
}

u8 *qq_decimal$var_tostr_dec(struct qq_decls$varrec *a,i64 fmt) {
    return qq_decimal$obj_tostr_dec((*a).objptr,fmt);
}

static u8 *qq_decimal$obj_tostr_dec(struct qq_decls$objrec *a,i64 fmt) {
        u8 *  s;
        u8 *  t;
    t = 0;
    if ((a == 0)) {
        t = (byte*)"<void>";
    }
    else {
                {i64 $temp = (i64)(*a).numtype;
if (($temp==(i64)0)) {
            t = (((fmt == (i64)69) || (fmt == (i64)70)) ? (byte*)"0.0" : (byte*)"0");
        }
        else if (($temp==(i64)2)) {
            t = (!!((i64)(*a).neg) ? (byte*)"-Infinity" : (byte*)"Infinity");
        }
        else if (($temp==(i64)3)) {
            t = (byte*)"<NaN>";
        }
        };
    }
;
    if (!!(t)) {
        s = (u8 *)mlib$pcm_alloc((qq_decimal$decstrsize = (strlen(t) + (i64)1)));
        strcpy(s,t);
        return s;
    }
;
    if (((fmt == (i64)0) || (fmt == (i64)65))) {
        if ((!!(qq_decimal$bn_isint(a)) && ((((i64)(*a).expon - (*a).length) * (i64)9) < (i64)60))) {
            fmt = (i64)73;
        }
        else if ((m$llabs(((i64)(*a).expon * (i64)9)) < (i64)60)) {
            fmt = (i64)70;
        }
        else {
            fmt = (i64)69;
        }
;
    }
;
    if ((fmt == (i64)69)) {
        s = qq_decimal$tostring_scient(a);
    }
    else {
        s = qq_decimal$tostring_float(a,fmt);
    }
;
    return s;
}

static u8 *qq_decimal$tostring_scient(struct qq_decls$objrec *a) {
        u8 *  s;
        u8 *  t;
        i64 expon;
        i64 nchars;
        i64 shift;
        i64 x;
        i64 scale;
        i64 $av_1;
        i64 i;
    nchars = (i64)3;
    expon = ((i64)(*a).expon * (i64)9);
    x = (i64)(*(*a).num)[((i64)0)];
    scale = (i64)1;
    shift = (i64)0;
    L93 :;
    while ((x >= (i64)10)) {
        x = (x / (i64)10);
        scale *= (i64)10;
        ++(expon);
        ++(shift);
L94 :;
    }
L95 :;
    ;
    nchars = (((*a).length * (i64)9) + (i64)16);
    s = (t = (u8 *)mlib$pcm_alloc((qq_decimal$decstrsize = nchars)));
    if (!!((i64)(*a).neg)) {
        (*(t)++) = '-';
    }
;
    msysc$m_print_startstr(t);
    msysc$m_print_i64(x,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)".",NULL);
    msysc$m_print_end();
    ;
    t += strlen(t);
    if (!!(shift)) {
        msysc$m_print_startstr(t);
        msysc$m_print_i64(shift,(byte*)"v");
        msysc$m_print_nogap();
        msysc$m_print_i64(((i64)(*(*a).num)[((i64)0)] - (x * scale)),(byte*)"z*");
        msysc$m_print_end();
        ;
        t += strlen(t);
    }
;
        ($av_1 = ((*a).length - (i64)1));
    for (i=(i64)1;i<=$av_1;++i) {
L96 :;
        msysc$m_print_startstr(t);
        msysc$m_print_i64((i64)(*(*a).num)[(i)],(byte*)"z9");
        msysc$m_print_end();
        ;
        t += strlen(t);
L97 :;
    }
L98 :;
    ;
    L99 :;
    while ((((u64)(*(t - (i64)1)) == '0') && ((u64)(*(t - (i64)2)) != '.'))) {
        --(t);
L100 :;
    }
L101 :;
    ;
    msysc$m_print_startstr(t);
    msysc$m_print_str((byte*)"e",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(expon,NULL);
    msysc$m_print_end();
    ;
    t += strlen(t);
    (*t) = (u64)0u;
    return s;
}

static u8 *qq_decimal$tostring_float(struct qq_decls$objrec *a,i64 fmt) {
        i64 expon;
        i64 upper;
        i64 nchars;
        i64 w;
        i64 prel;
        i64 showdot;
        u8 *  s;
        u8 *  t;
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
        i64 $av_4;
        i64 i;
    expon = (i64)(*a).expon;
    upper = ((*a).length - (i64)1);
    if (((fmt == (i64)73) && !!(qq_decimal$bn_isint(a)))) {
        showdot = (i64)0;
    }
    else {
        showdot = (i64)1;
    }
;
    w = (i64)9;
    nchars = (i64)3;
    if ((expon < (i64)0)) {
        nchars += (m$llabs((expon - (i64)1)) * w);
    }
;
    nchars += ((*a).length * w);
    if (((expon - upper) > (i64)0)) {
        nchars += ((expon - upper) * w);
    }
;
    nchars += (i64)8;
    s = (t = (u8 *)mlib$pcm_alloc((qq_decimal$decstrsize = nchars)));
    if (!!((i64)(*a).neg)) {
        (*(t)++) = '-';
    }
;
    prel = (i64)0;
    if ((expon < (i64)0)) {
        prel = (i64)1;
        (*(t)++) = '0';
        (*(t)++) = '.';
        $av_2 = (m$llabs(expon) - (i64)1);
        while ($av_2-- > 0) {
L102 :;
            $av_1 = (i64)9;
            while ($av_1-- > 0) {
L105 :;
                (*(t)++) = '0';
L106 :;
            }
L107 :;
            ;
L103 :;
        }
L104 :;
        ;
    }
;
    for (i=(i64)0;i<=upper;++i) {
L108 :;
        msysc$m_print_startstr(t);
        msysc$m_print_i64((i64)(*(*a).num)[(i)],(((i > (i64)0) || !!(prel)) ? (byte*)"z9" : (byte*)""));
        msysc$m_print_end();
        ;
        t += strlen(t);
        if ((((expon == i) && (i < upper)) && !!(showdot))) {
            (*(t)++) = '.';
        }
;
L109 :;
    }
L110 :;
    ;
    $av_4 = (expon - upper);
    while ($av_4-- > 0) {
L111 :;
        $av_3 = (i64)9;
        while ($av_3-- > 0) {
L114 :;
            (*(t)++) = '0';
L115 :;
        }
L116 :;
        ;
L112 :;
    }
L113 :;
    ;
    if (((expon >= upper) && !!(showdot))) {
        (*(t)++) = '.';
        (*(t)++) = '0';
    }
;
    (*t) = (u64)0u;
    return s;
}

static i64 qq_decimal$strvaln(u8 *s,i64 n) {
        i64 a;
        i64 $av_1;
    a = (i64)0;
    $av_1 = n;
    while ($av_1-- > 0) {
L117 :;
        if (((u64)(*s) != '_')) {
            a = (((a * (i64)10) + (i64)(u64)(*s)) - (i64)48);
        }
;
        ++(s);
L118 :;
    }
L119 :;
    ;
    return a;
}

static i64 qq_decimal$bn_isint(struct qq_decls$objrec *a) {
    return (i64)((*a).length <= ((i64)(*a).expon + (i64)1));
}

i64 qq_decimal$obj_len_dec(struct qq_decls$objrec *a) {
    return qq_decimal$bn_getprec(a);
    if (!(!!(qq_decimal$bn_isint(a)))) {
        return (i64)0;
    }
;
    if (!!(qq_decimal$bn_iszero(a))) {
        return (i64)1;
    }
;
    return (strlen(msysc$strint((i64)(*(*a).num)[((i64)0)],0)) + ((i64)(*a).expon * (i64)9));
}

i64 qq_decimal$bn_iszero(struct qq_decls$objrec *a) {
    return (i64)((i64)(*a).numtype == (i64)0);
}

i64 qq_decimal$var_equal_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    return qq_decimal$bn_equal((*a).objptr,(*b).objptr);
}

void qq_decimal$var_add_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  dest;
    dest = qq_decimal$bn_init();
    qq_decimal$bn_add(dest,(*a).objptr,(*b).objptr);
    (*a).objptr = dest;
}

void qq_decimal$var_sub_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  dest;
    dest = qq_decimal$bn_init();
    qq_decimal$bn_sub(dest,(*a).objptr,(*b).objptr);
    (*a).objptr = dest;
}

void qq_decimal$var_mul_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  dest;
    dest = qq_decimal$bn_init();
    qq_decimal$bn_mul(dest,(*a).objptr,(*b).objptr);
    (*a).objptr = dest;
}

void qq_decimal$var_div_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  dest;
    dest = qq_decimal$bn_init();
    qq_decimal$bn_div(dest,(*a).objptr,(*b).objptr,(i64)0);
    (*a).objptr = dest;
}

void qq_decimal$var_idiv_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  dest;
    dest = qq_decimal$bn_init();
    qq_decimal$bn_idiv(dest,(*a).objptr,(*b).objptr);
    (*a).objptr = dest;
}

void qq_decimal$var_irem_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  dest;
    dest = qq_decimal$bn_init();
    qq_decimal$bn_irem(dest,(*a).objptr,(*b).objptr);
    (*a).objptr = dest;
}

void qq_decimal$var_neg_dec(struct qq_decls$varrec *a) {
    qq_decimal$bn_negto((*a).objptr);
}

void qq_decimal$var_abs_dec(struct qq_decls$varrec *a) {
    qq_decimal$bn_absto((*a).objptr);
}

i64 qq_decimal$var_compare_dec(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    return qq_decimal$bn_cmp((*a).objptr,(*b).objptr);
}

static i64 qq_decimal$bn_cmp(struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        struct qq_decls$objrec *  d;
        i64 neg;
    if (!!(qq_decimal$bn_equal(a,b))) {
        return (i64)0;
    }
;
    d = qq_decimal$bn_init();
    qq_decimal$bn_sub(d,a,b);
    neg = (i64)(*d).neg;
    qq_decimal$obj_free_dec(d);
    if (!!(neg)) {
        return (i64)-1;
    }
    else {
        return (i64)1;
    }
;
}

static i64 qq_decimal$bn_equal(struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
    if ((((i64)(*a).numtype != (i64)1) && ((i64)(*a).numtype == (i64)(*b).numtype))) {
        return (i64)((i64)(*a).neg == (i64)(*b).neg);
    }
;
    if ((((((*a).length != (*b).length) || ((i64)(*a).numtype != (i64)(*b).numtype)) || ((i64)(*a).neg != (i64)(*b).neg)) || ((i64)(*a).expon != (i64)(*b).expon))) {
        return (i64)0;
    }
;
    if (((*a).length == (i64)0)) {
        return (i64)1;
    }
;
    return mlib$eqbytes((*a).num,(*b).num,((*a).length * (i64)4));
}

static i64 qq_decimal$bn_add(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 nega;
        i64 negb;
    switch (qq_decimal$getbintype(a,b)) {
    case 1:;
        {
        }
        break;
    case 2:;
        {
            qq_decimal$bn_setzero(dest);
            return (i64)1;
        }
        break;
    case 5:;
        {
            qq_decimal$bn_dupl(dest,a);
            return (i64)1;
        }
        break;
    case 7:;
        {
            qq_decimal$bn_dupl(dest,b);
            return (i64)1;
        }
        break;
    default: {
        qq_decimal$bn_setnan(dest);
        return (i64)0;
    }
    } //SW
;
    nega = (i64)(*a).neg;
    negb = (i64)(*b).neg;
    if ((!(!!(nega)) && !(!!(negb)))) {
        qq_decimal$bn_addu(dest,a,b);
    }
    else if ((!!(nega) && !!(negb))) {
        qq_decimal$bn_addu(dest,a,b);
        qq_decimal$bn_negto(dest);
    }
    else if ((!(!!(nega)) && !!(negb))) {
        qq_decimal$bn_subu(dest,a,b);
    }
    else {
        qq_decimal$bn_subu(dest,b,a);
    }
;
    return (i64)1;
}

static i64 qq_decimal$bn_sub(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 nega;
        i64 negb;
    switch (qq_decimal$getbintype(a,b)) {
    case 1:;
        {
        }
        break;
    case 2:;
        {
            qq_decimal$bn_setzero(dest);
            return (i64)1;
        }
        break;
    case 5:;
        {
            qq_decimal$bn_dupl(dest,a);
            return (i64)1;
        }
        break;
    case 7:;
        {
            qq_decimal$bn_dupl(dest,b);
            qq_decimal$bn_negto(dest);
            return (i64)1;
        }
        break;
    default: {
        qq_decimal$bn_setnan(dest);
        return (i64)0;
    }
    } //SW
;
    nega = (i64)(*a).neg;
    negb = (i64)(*b).neg;
    if ((!(!!(nega)) && !(!!(negb)))) {
        qq_decimal$bn_subu(dest,a,b);
    }
    else if ((!!(nega) && !!(negb))) {
        qq_decimal$bn_subu(dest,b,a);
    }
    else if ((!(!!(nega)) && !!(negb))) {
        qq_decimal$bn_addu(dest,a,b);
    }
    else {
        qq_decimal$bn_subu(dest,b,a);
    }
;
    return (i64)1;
}

static void qq_decimal$bn_addu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 preca;
        i64 precb;
        i64 precc;
        i64 uppera;
        i64 upperb;
        i64 upperc;
        i64 offset;
        i64 carry;
        i64 expona;
        i64 exponb;
        i64 dc;
        u64 j;
        i32 (*pa)[];
        i32 (*pb)[];
        i32 *  c;
        i32 *  c2;
        i64 i;
    if (((i64)(*a).expon < (i64)(*b).expon)) {
        {struct qq_decls$objrec *  temp = a; a = b; b = temp; };
    }
;
    expona = (i64)(*a).expon;
    exponb = (i64)(*b).expon;
    preca = (*a).length;
    precb = (*b).length;
    offset = (expona - exponb);
    uppera = (preca - (i64)1);
    upperb = (precb - (i64)1);
    if ((uppera > (upperb + offset))) {
        upperc = uppera;
    }
    else {
        upperc = (upperb + offset);
    }
;
    precc = (upperc + (i64)1);
    c = (i32 *)qq_decimal$makesmallnum(precc);
    carry = (i64)0;
    pa = (i32 (*)[])(*a).num;
    pb = (i32 (*)[])(*b).num;
    for (i=upperc;i>=(i64)0;--i) {
L120 :;
        j = (u64)(i - offset);
        if (((i <= uppera) && (j <= (u64)upperb))) {
            dc = (((i64)(*pa)[(i)] + (i64)(*pb)[((i64)j)]) + carry);
        }
        else if ((i <= uppera)) {
            dc = ((i64)(*pa)[(i)] + carry);
        }
        else if ((j <= (u64)upperb)) {
            dc = ((i64)(*pb)[((i64)j)] + carry);
        }
        else {
            dc = carry;
        }
;
        if ((dc >= (i64)1000000000)) {
            carry = (i64)1;
            (*(c + i)) = (dc - (i64)1000000000);
        }
        else {
            (*(c + i)) = dc;
            carry = (i64)0;
        }
;
L121 :;
    }
L122 :;
    ;
    if (!!(carry)) {
        c2 = (i32 *)qq_decimal$makesmallnum((precc + (i64)1));
        (*c2) = carry;
        memcpy((c2 + (i64)1),c,(u64)(precc * (i64)4));
        qq_decimal$freesmall((i32 *)c,precc);
        c = c2;
        ++(precc);
    }
;
    qq_decimal$smalltobig(dest,(i32 *)c,precc,precc,(i64)0);
    (*dest).expon = (expona + carry);
}

static void qq_decimal$bn_subu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 preca;
        i64 precb;
        i64 precc;
        i64 uppera;
        i64 upperb;
        i64 upperc;
        i64 offset;
        i64 carry;
        i64 expona;
        i64 isneg;
        i64 diff;
        u64 j;
        i32 (*pa)[];
        i32 (*pb)[];
        i32 *  c;
        i64 i;
    isneg = (i64)0;
    if (((i64)(*a).expon < (i64)(*b).expon)) {
        {struct qq_decls$objrec *  temp = a; a = b; b = temp; };
        isneg = (i64)1;
    }
;
    //retry:
L123 :;
;
    expona = (i64)(*a).expon;
    preca = (*a).length;
    precb = (*b).length;
    offset = (expona - (i64)(*b).expon);
    uppera = (preca - (i64)1);
    upperb = (precb - (i64)1);
    if ((uppera > (upperb + offset))) {
        upperc = uppera;
    }
    else {
        upperc = (upperb + offset);
    }
;
    precc = (upperc + (i64)1);
    c = (i32 *)qq_decimal$makesmallnum(precc);
    carry = (i64)0;
    pa = (i32 (*)[])(*a).num;
    pb = (i32 (*)[])(*b).num;
    for (i=upperc;i>=(i64)0;--i) {
L124 :;
        j = (u64)(i - offset);
        if (((i <= uppera) && (j <= (u64)upperb))) {
            diff = (((i64)(*pa)[(i)] - (i64)(*pb)[((i64)j)]) - carry);
        }
        else if ((i <= uppera)) {
            diff = ((i64)(*pa)[(i)] - carry);
        }
        else if ((j <= (u64)upperb)) {
            diff = (-((i64)(*pb)[((i64)j)]) - carry);
        }
        else {
            diff = -(carry);
        }
;
        if ((diff < (i64)0)) {
            carry = (i64)1;
            (*(c + i)) = (diff + (i64)1000000000);
        }
        else {
            (*(c + i)) = diff;
            carry = (i64)0;
        }
;
L125 :;
    }
L126 :;
    ;
    if (!!(carry)) {
        if (!!(isneg)) {
            qq_lib$pcerror((byte*)"SUBU/CARRY");
        }
;
        {struct qq_decls$objrec *  temp = a; a = b; b = temp; };
        isneg = (i64)1;
        qq_decimal$freesmall((i32 *)c,precc);
        goto L123 ;
;
    }
;
    qq_decimal$smalltobig(dest,(i32 *)c,precc,precc,(i64)0);
    (*dest).neg = isneg;
    (*dest).expon = (expona - qq_decimal$stblz);
}

static struct qq_decls$objrec *qq_decimal$makebignum(i64 length) {
        struct qq_decls$objrec *  a;
    a = qq_vars$obj_new();
    if (!!(length)) {
        (*a).num = (i32 (*)[])mlib$pcm_alloc((length * (i64)4));
        (*a).numtype = (i64)1;
    }
    else {
        (*a).num = 0;
        (*a).numtype = (i64)0;
    }
;
    (*a).length = length;
    (*a).expon = (i64)0;
    (*a).neg = (i64)0;
    return a;
}

static i32 *qq_decimal$makesmallnum(i64 length) {
    return (i32 *)mlib$pcm_alloc((length * (i64)4));
}

static struct qq_decls$objrec *qq_decimal$smalltobig(struct qq_decls$objrec *c,i32 *a,i64 length,i64 alloc,i64 offset) {
        i32 *  p;
        i64 leadingzeros;
        i64 trailingzeros;
        i64 nonzeros;
        i64 newlength;
        i64 $av_1;
    qq_decimal$bn_setzero(c);
    p = (i32 *)a;
    leadingzeros = (trailingzeros = (nonzeros = (i64)0));
    $av_1 = length;
    while ($av_1-- > 0) {
L127 :;
        if (!!((i64)(*(p)++))) {
            nonzeros = (i64)1;
            trailingzeros = (i64)0;
        }
        else {
            if (!!(nonzeros)) {
                ++(trailingzeros);
            }
            else {
                ++(leadingzeros);
            }
;
        }
;
L128 :;
    }
L129 :;
    ;
    qq_decimal$stblz = leadingzeros;
    if (!!(nonzeros)) {
        newlength = ((length - trailingzeros) - leadingzeros);
        if ((newlength==length && length==alloc)) {
            (*c).num = (i32 (*)[])a;
        }
        else {
            (*c).num = (i32 (*)[])qq_decimal$makesmallnum(newlength);
            memcpy((*c).num,(a + leadingzeros),(u64)(newlength * (i64)4));
            qq_decimal$freesmall((i32 *)(a + offset),alloc);
        }
;
        (*c).length = newlength;
        (*c).numtype = (i64)1;
        (*c).expon = ((length - (i64)1) - leadingzeros);
    }
    else if (!!(alloc)) {
        qq_decimal$freesmall((i32 *)(a + offset),alloc);
    }
;
    return c;
}

static void qq_decimal$freesmall(i32 *p,i64 length) {
    mlib$pcm_free(p,(length * (i64)4));
}

struct qq_decls$objrec *qq_decimal$bn_init(void) {
        struct qq_decls$objrec *  a;
    a = qq_decimal$makebignum((i64)0);
    return a;
}

static void qq_decimal$bn_setzero(struct qq_decls$objrec *a) {
    if (!!(a)) {
        if (!!((*a).num)) {
            qq_decimal$freesmall((i32 *)(*a).num,(*a).length);
        }
;
        (*a).num = 0;
        (*a).length = (i64)0;
        (*a).neg = (i64)0;
        (*a).expon = (i64)0;
        (*a).numtype = (i64)0;
    }
;
}

static void qq_decimal$bn_move(struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
    qq_decimal$bn_setzero(a);
    memcpy(&(*a).bignumdescr,&(*b).bignumdescr,24);
    memset(&((*b).bignumdescr),0,24);
}

static void qq_decimal$bn_dupl(struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        struct qq_decls$objrec *  c;
        i64 size;
    c = qq_decimal$bn_init();
    (*c) = (*b);
    if (!!((*c).length)) {
        (*c).num = (i32 (*)[])qq_decimal$makesmallnum((size = (*c).length));
        memcpy((*c).num,(*b).num,(u64)(size * (i64)4));
    }
;
    qq_decimal$bn_move(a,c);
    qq_decimal$obj_free_dec(c);
}

static void qq_decimal$bn_setinf(struct qq_decls$objrec *dest) {
    qq_decimal$bn_setzero(dest);
    (*dest).numtype = (i64)2;
}

static void qq_decimal$bn_setnan(struct qq_decls$objrec *dest) {
    qq_decimal$bn_setzero(dest);
    (*dest).numtype = (i64)3;
}

void qq_decimal$var_setnan(struct qq_decls$varrec *dest) {
    (*dest).tagx = (i64)260;
    (*dest).objptr = qq_decimal$makebignum((i64)0);
    qq_decimal$bn_setnan((*dest).objptr);
}

void qq_decimal$var_setinf(struct qq_decls$varrec *dest) {
    (*dest).tagx = (i64)260;
    (*dest).objptr = qq_decimal$makebignum((i64)0);
    qq_decimal$bn_setinf((*dest).objptr);
}

static i64 qq_decimal$getbintype(struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 atype;
        i64 btype;
    atype = (i64)(*a).numtype;
    btype = (i64)(*b).numtype;
    if (((atype == (i64)3) || (btype == (i64)3))) {
        return (i64)4;
    }
;
    if ((atype==(i64)1)) {
        if ((btype==(i64)1)) {
            return (i64)1;
        }
        else if ((btype==(i64)0)) {
            return (i64)5;
        }
        else {
            return (i64)6;
        }
;
    }
    else if ((atype==(i64)0)) {
        if ((btype==(i64)1)) {
            return (i64)7;
        }
        else if ((btype==(i64)0)) {
            return (i64)2;
        }
        else {
            return (i64)9;
        }
;
    }
    else {
        if ((btype==(i64)1)) {
            return (i64)8;
        }
        else if ((btype==(i64)0)) {
            return (i64)10;
        }
        else {
            return (i64)3;
        }
;
    }
;
}

static void qq_decimal$bn_negto(struct qq_decls$objrec *a) {
    if (!(!!(qq_decimal$bn_iszero(a)))) {
        (*a).neg = (i64)!(!!((i64)(*a).neg));
    }
;
}

static void qq_decimal$bn_absto(struct qq_decls$objrec *a) {
    (*a).neg = (i64)0;
}

static i64 qq_decimal$bn_mul(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 neg;
    switch (qq_decimal$getbintype(a,b)) {
    case 1:;
        {
        }
        break;
    case 2:;
    case 5:;
    case 7:;
        {
            qq_decimal$bn_setzero(dest);
            return (i64)1;
        }
        break;
    default: {
        qq_decimal$bn_setnan(dest);
        return (i64)0;
    }
    } //SW
;
    neg = (i64)((i64)(*a).neg != (i64)(*b).neg);
    qq_decimal$bn_mulu(dest,a,b);
    if (!!(neg)) {
        qq_decimal$bn_negto(dest);
    }
;
    return (i64)1;
}

static i64 qq_decimal$bn_mulp(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,i64 prec) {
        i64 res;
    res = qq_decimal$bn_mul(dest,a,b);
    if (!!(res)) {
        qq_decimal$bn_setprec(dest,((prec == (i64)0) ? qq_decimal$currprec : prec));
    }
;
    return res;
}

static void qq_decimal$bn_mulu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 uppera;
        i64 upperb;
        i64 precc;
        i64 expona;
        i64 exponb;
        i64 ax;
        i64 bx;
        i64 cx;
        i64 cx1;
        i64 nc2;
        i64 pd;
        i64 pr;
        i64 p;
        i64 carry;
        i64 x;
        i32 *  c;
    expona = (i64)(*a).expon;
    exponb = (i64)(*b).expon;
    uppera = ((*a).length - (i64)1);
    upperb = ((*b).length - (i64)1);
    precc = ((uppera + upperb) + (i64)2);
    nc2 = precc;
    c = (i32 *)qq_decimal$makesmallnum(nc2);
    memset(c,(i32)(i64)0,(u64)(precc * (i64)4));
    cx = (precc - (i64)1);
    for (bx=upperb;bx>=(i64)0;--bx) {
L130 :;
        carry = (i64)0;
        cx1 = cx;
        for (ax=uppera;ax>=(i64)0;--ax) {
L133 :;
            p = (((i64)(*(*a).num)[(ax)] * (i64)(*(*b).num)[(bx)]) + carry);
            pd = (p / (i64)1000000000);
            pr = (p - (pd * (i64)1000000000));
            x = ((i64)(*(c + cx1)) + pr);
            if ((x > (i64)999999999)) {
                carry = (pd + (i64)1);
                (*(c + (cx1)--)) = (x - (i64)1000000000);
            }
            else {
                carry = pd;
                (*(c + (cx1)--)) = x;
            }
;
L134 :;
        }
L135 :;
        ;
        (*(c + cx1)) = carry;
        --(cx);
L131 :;
    }
L132 :;
    ;
    qq_decimal$smalltobig(dest,(i32 *)c,precc,nc2,(i64)0);
    (*dest).expon = (((expona + exponb) + (i64)1) - qq_decimal$stblz);
}

static i64 qq_decimal$smallmulto(i32 *p,i32 *q,i64 plen,i64 m) {
        i32 *  pp;
        i32 *  qq;
        i64 carry;
        i64 d;
        i64 $av_1;
        i64 $av_2;
    if ((m==(i64)0)) {
        (*p) = (i64)0;
        return (i64)1;
    }
    else if ((m==(i64)1)) {
        memcpy(p,q,(u64)(plen * (i64)4));
        return plen;
    }
;
    pp = (i32 *)((p + plen) - (i64)1);
    qq = (i32 *)((q + plen) - (i64)1);
    carry = (i64)0;
    $av_1 = plen;
    while ($av_1-- > 0) {
L136 :;
        d = (((i64)(*qq) * m) + carry);
        (*pp) = (d % (i64)1000000000);
        carry = (d / (i64)1000000000);
        --(qq);
        --(pp);
L137 :;
    }
L138 :;
    ;
    if (!!(carry)) {
        pp = (i32 *)(p + plen);
        $av_2 = plen;
        while ($av_2-- > 0) {
L139 :;
            (*pp) = (i64)(*(pp - (i64)1));
            --(pp);
L140 :;
        }
L141 :;
        ;
        (*pp) = carry;
        ++(plen);
    }
;
    return plen;
}

static i64 qq_decimal$bn_div(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,i64 prec) {
        i64 neg;
    switch (qq_decimal$getbintype(a,b)) {
    case 1:;
        {
        }
        break;
    case 7:;
        {
            qq_decimal$bn_setzero(dest);
            return (i64)1;
        }
        break;
    case 2:;
    case 5:;
        {
            qq_decimal$bn_setinf(dest);
            return (i64)0;
        }
        break;
    default: {
        qq_decimal$bn_setnan(dest);
        return (i64)0;
    }
    } //SW
;
    neg = (i64)((i64)(*a).neg != (i64)(*b).neg);
    qq_decimal$bn_fdivu(dest,a,b,prec);
    if (!!(neg)) {
        qq_decimal$bn_negto(dest);
    }
;
    return (i64)1;
}

static i64 qq_decimal$bn_idiv(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 neg;
    switch (qq_decimal$getbintype(a,b)) {
    case 1:;
        {
        }
        break;
    case 7:;
        {
            qq_decimal$bn_setzero(dest);
            return (i64)1;
        }
        break;
    case 2:;
    case 5:;
        {
            qq_decimal$bn_setinf(dest);
            return (i64)0;
        }
        break;
    default: {
        qq_decimal$bn_setnan(dest);
        return (i64)0;
    }
    } //SW
;
    neg = (i64)((i64)(*a).neg != (i64)(*b).neg);
    qq_decimal$bn_idivu(dest,a,b,0);
    if (!!(neg)) {
        qq_decimal$bn_negto(dest);
    }
;
    return (i64)1;
}

static i64 qq_decimal$bn_idivrem(struct qq_decls$objrec *dest,struct qq_decls$objrec *rm,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        i64 nega;
        i64 negb;
    switch (qq_decimal$getbintype(a,b)) {
    case 1:;
        {
        }
        break;
    case 7:;
        {
            qq_decimal$bn_setzero(dest);
            qq_decimal$bn_setzero(rm);
            return (i64)1;
        }
        break;
    case 2:;
    case 5:;
        {
            qq_decimal$bn_setinf(dest);
            qq_decimal$bn_setzero(rm);
            return (i64)0;
        }
        break;
    default: {
        qq_decimal$bn_setnan(dest);
        return (i64)0;
    }
    } //SW
;
    nega = (i64)(*a).neg;
    negb = (i64)(*b).neg;
    qq_decimal$bn_idivu(dest,a,b,rm);
    if ((nega != negb)) {
        qq_decimal$bn_negto(dest);
    }
;
    if (!!(nega)) {
        qq_decimal$bn_negto(rm);
    }
;
    return (i64)1;
}

static i64 qq_decimal$bn_irem(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b) {
        struct qq_decls$objrec *  d;
        i64 nega;
    switch (qq_decimal$getbintype(a,b)) {
    case 1:;
        {
        }
        break;
    case 7:;
        {
            qq_decimal$bn_dupl(dest,b);
            return (i64)1;
        }
        break;
    case 2:;
    case 5:;
        {
            qq_decimal$bn_setinf(dest);
            qq_decimal$bn_setzero(dest);
            return (i64)0;
        }
        break;
    default: {
        qq_decimal$bn_setnan(dest);
        return (i64)0;
    }
    } //SW
;
    nega = (i64)(*a).neg;
    d = qq_decimal$bn_init();
    qq_decimal$bn_idivu(d,a,b,dest);
    if (!!(nega)) {
        qq_decimal$bn_negto(dest);
    }
;
    qq_decimal$obj_free_dec(d);
    return (i64)1;
}

static void qq_decimal$bn_idivu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,struct qq_decls$objrec *rm) {
        i32 *  c;
        i32 *  x;
        i64 expona;
        i64 exponb;
        i64 badjust;
        i64 na;
        i64 nb;
        i64 nc;
        i64 nx;
        i64 nx2;
        i64 cx;
        i64 nupper;
        i64 uppera;
        i64 upperb;
        i64 upperc;
        i64 n;
        i64 k;
        i64 nexta;
        i32 *  pa;
        i32 *  pb;
        struct qq_decls$objrec *  d;
        i64 i;
    na = (*a).length;
    nb = (*b).length;
    expona = (i64)(*a).expon;
    exponb = (i64)(*b).expon;
    badjust = ((exponb + (i64)1) - nb);
    if (((na > (expona + (i64)1)) || (nb > (exponb + (i64)1)))) {
        qq_lib$pcerror((byte*)"idivu:a or b not int");
    }
;
    nc = (expona + (i64)1);
    if ((expona < exponb)) {
        qq_decimal$bn_setzero(dest);
        if (!!(rm)) {
            qq_decimal$bn_dupl(rm,a);
        }
;
        return;
    }
;
    uppera = (na - (i64)1);
    upperb = (nb - (i64)1);
    upperc = (nc - (i64)1);
    pa = (i32 *)(*a).num;
    pb = (i32 *)(*b).num;
    n = nb;
    x = (i32 *)qq_decimal$makesmallnum((nx2 = (n + (i64)1)));
    nx = n;
    nupper = (nc - badjust);
    for (i=(i64)0;i<=upperb;++i) {
L142 :;
        if ((i <= uppera)) {
            (*(x + i)) = (i64)(*(pa + i));
        }
        else {
            (*(x + i)) = (i64)0;
        }
;
L143 :;
    }
L144 :;
    ;
    c = (i32 *)qq_decimal$makesmallnum(nc);
    cx = (i64)0;
    L145 :;
    while (1) {
        k = qq_decimal$smalldiv((i32 *)x,(i32 *)pb,&nx,nb);
        (*(c + (cx)++)) = k;
        if ((n >= nupper)) {
            goto L146 ;
        }
;
        nexta = ((n > uppera) ? (i64)0 : (i64)(*(pa + n)));
        ++(n);
        if (((nx == (i64)1) && ((i64)(*x) == (i64)0))) {
            (*x) = nexta;
        }
        else {
            (*(x + nx)) = nexta;
            ++(nx);
        }
;
    }
L146 :;
    ;
    if ((!!(rm) && (exponb < nb))) {
        qq_decimal$smalltobig(rm,(i32 *)x,nx,nx2,(i64)0);
    }
    else {
        qq_decimal$freesmall((i32 *)x,nx2);
    }
;
    if (((cx == (i64)1) && ((i64)(*c) == (i64)0))) {
        qq_decimal$freesmall((i32 *)c,nc);
        qq_decimal$bn_setzero(dest);
        if (!!(rm)) {
            qq_decimal$bn_dupl(rm,a);
        }
;
        return;
    }
;
    if ((((i64)(*c) == (i64)0) && (cx >= (i64)2))) {
        qq_decimal$smalltobig(dest,(i32 *)(c + (i64)1),(cx - (i64)1),nc,(i64)-1);
    }
    else {
        qq_decimal$smalltobig(dest,(i32 *)c,cx,nc,(i64)0);
    }
;
    if ((!!(rm) && (exponb >= nb))) {
        d = qq_decimal$bn_init();
        qq_decimal$bn_mulu(d,b,dest);
        qq_decimal$bn_subu(rm,a,d);
        qq_decimal$obj_free_dec(d);
    }
;
}

static void qq_decimal$bn_fdivu(struct qq_decls$objrec *dest,struct qq_decls$objrec *a,struct qq_decls$objrec *b,i64 precision) {
        i32 *  c;
        i32 *  x;
        i64 expona;
        i64 exponb;
        i64 na;
        i64 nb;
        i64 nc;
        i64 nx;
        i64 nx2;
        i64 cx;
        i64 nc2;
        i64 uppera;
        i64 upperb;
        i64 upperc;
        i64 n;
        i64 k;
        i64 nexta;
        i32 *  pa;
        i32 *  pb;
        i64 i;
    na = (*a).length;
    nb = (*b).length;
    expona = (i64)(*a).expon;
    exponb = (i64)(*b).expon;
    if (!!(precision)) {
        precision = (((precision - (i64)1) / (i64)9) + (i64)1);
    }
    else {
        precision = qq_decimal$currprec;
    }
;
    nc = precision;
    uppera = (na - (i64)1);
    upperb = (nb - (i64)1);
    upperc = (nc - (i64)1);
    pa = (i32 *)(*a).num;
    pb = (i32 *)(*b).num;
    n = nb;
    x = (i32 *)qq_decimal$makesmallnum((nx2 = (n + (i64)1)));
    nx = n;
    for (i=(i64)0;i<=upperb;++i) {
L147 :;
        if ((i <= uppera)) {
            (*(x + i)) = (i64)(*(pa + i));
        }
        else {
            (*(x + i)) = (i64)0;
        }
;
L148 :;
    }
L149 :;
    ;
    c = (i32 *)qq_decimal$makesmallnum((nc2 = (nc + (i64)1)));
    cx = (i64)0;
    L150 :;
    while (1) {
        k = qq_decimal$smalldiv((i32 *)x,(i32 *)pb,&nx,nb);
        (*(c + (cx)++)) = k;
        if ((cx > nc)) {
            goto L151 ;
        }
;
        nexta = ((n > uppera) ? (i64)0 : (i64)(*(pa + n)));
        ++(n);
        if (((nx == (i64)1) && ((i64)(*x) == (i64)0))) {
            (*x) = nexta;
        }
        else {
            (*(x + nx)) = nexta;
            ++(nx);
        }
;
    }
L151 :;
    ;
    qq_decimal$freesmall((i32 *)x,nx2);
    if (((cx == (i64)1) && ((i64)(*c) == (i64)0))) {
        qq_decimal$freesmall((i32 *)c,nc2);
        qq_decimal$bn_setzero(dest);
        return;
    }
;
    if ((((i64)(*c) == (i64)0) && (cx >= (i64)2))) {
        qq_decimal$smalltobig(dest,(i32 *)(c + (i64)1),(cx - (i64)1),nc2,(i64)-1);
        (*dest).expon = ((expona - exponb) - (i64)1);
    }
    else {
        qq_decimal$smalltobig(dest,(i32 *)c,cx,nc2,(i64)0);
        (*dest).expon = (expona - exponb);
    }
;
}

static i64 qq_decimal$smalldiv(i32 *x,i32 *b,i64 *xlen,i64 nb) {
        i64 k;
        i64 count;
        i64 xx;
        i64 y;
        i32 xi;
        i32 bi;
        i32 *  e;
        i64 esize;
        i64 ne;
        i64 nx;
        i64 $av_1;
        i64 i;
    nx = (*xlen);
    k = (i64)0;
    count = (i64)0;
    e = (i32 *)qq_decimal$makesmallnum((esize = (nb + (i64)1)));
    L152 :;
    while (1) {
        if ((nx < nb)) {
            goto L153 ;
        }
        else if ((nx > nb)) {
            xx = (((i64)(*x) * (i64)1000000000) + (i64)(*(x + (i64)1)));
            y = (xx / ((i64)(*b) + (i64)1));
        }
        else {
            if (((i64)(*x) >= ((i64)(*b) + (i64)1))) {
                y = ((i64)(*x) / ((i64)(*b) + (i64)1));
            }
            else {
                y = (i64)1;
                                ($av_1 = (nb - (i64)1));
                for (i=(i64)0;i<=$av_1;++i) {
L154 :;
                    xi = (i64)(*(x + i));
                    bi = (i64)(*(b + i));
                    if (((i64)xi < (i64)bi)) {
                        y = (i64)0;
                        goto L153 ;
                    }
                    else if (((i64)xi > (i64)bi)) {
                        goto L156 ;
                    }
;
L155 :;
                }
L156 :;
                ;
            }
;
        }
;
        k += y;
        if ((y > (i64)1)) {
            ne = qq_decimal$smallmulto((i32 *)e,(i32 *)b,nb,y);
            nx = qq_decimal$smallsubto((i32 *)x,(i32 *)e,nx,ne);
        }
        else if (!!(y)) {
            nx = qq_decimal$smallsubto((i32 *)x,(i32 *)b,nx,nb);
        }
        else {
            qq_lib$pcerror((byte*)"smalldiv:Y=0");
        }
;
    }
L153 :;
    ;
    qq_decimal$freesmall((i32 *)e,esize);
    (*xlen) = nx;
    return k;
}

static i64 qq_decimal$smallsubto(i32 *p,i32 *q,i64 plen,i64 qlen) {
        i32 *  pp;
        i32 *  qq;
        i64 carry;
        i64 diff;
        i64 z;
        i64 $av_1;
        i64 $av_2;
    pp = (i32 *)((p + plen) - (i64)1);
    qq = (i32 *)((q + qlen) - (i64)1);
    carry = (i64)0;
    z = (i64)0;
    $av_1 = plen;
    while ($av_1-- > 0) {
L157 :;
        if ((qq >= q)) {
            diff = (((i64)(*pp) - (i64)(*qq)) - carry);
            --(qq);
        }
        else {
            diff = ((i64)(*pp) - carry);
        }
;
        if ((diff < (i64)0)) {
            carry = (i64)1;
            (*pp) = (diff + (i64)1000000000);
        }
        else {
            (*pp) = diff;
            carry = (i64)0;
        }
;
        if (!!((i64)(*pp))) {
            z = (i64)0;
        }
        else {
            ++(z);
        }
;
        --(pp);
L158 :;
    }
L159 :;
    ;
    if (!!(carry)) {
        qq_lib$pcerror((byte*)"SSUBTO/CARRY?");
    }
;
    if ((z == plen)) {
        --(z);
    }
;
    if (!!(z)) {
        plen -= z;
        pp = (i32 *)p;
        qq = (i32 *)(p + z);
        $av_2 = plen;
        while ($av_2-- > 0) {
L160 :;
            (*(pp)++) = (i64)(*(qq)++);
L161 :;
        }
L162 :;
        ;
    }
;
    return plen;
}

static i64 qq_decimal$bn_getprec(struct qq_decls$objrec *a) {
    return ((*a).length * (i64)9);
}

static void qq_decimal$bn_setprec(struct qq_decls$objrec *a,i64 prec) {
        i64 oldlength;
        i64 newlength;
        struct qq_decls$objrec *  c;
        i64 $av_1;
        i64 i;
    if (((i64)(*a).numtype != (i64)1)) {
        return;
    }
;
    if (((prec < (i64)1) || (prec > (i64)10000000))) {
        return;
    }
;
    prec = ((((prec - (i64)1) / (i64)9) + (i64)1) * (i64)9);
    newlength = (prec / (i64)9);
    oldlength = (*a).length;
    if ((oldlength <= newlength)) {
        return;
    }
;
    c = qq_decimal$makebignum(newlength);
    (*c).neg = (i64)(*a).neg;
    (*c).expon = (i64)(*a).expon;
        ($av_1 = (newlength - (i64)1));
    for (i=(i64)0;i<=$av_1;++i) {
L163 :;
        if ((i < oldlength)) {
            (*(*c).num)[(i)] = (i64)(*(*a).num)[(i)];
        }
        else {
            (*(*c).num)[(i)] = (i64)0;
        }
;
L164 :;
    }
L165 :;
    ;
    qq_decimal$bn_move(a,c);
    qq_decimal$obj_free_dec(c);
}

static i64 qq_decimal$bn_getglobalprec(void) {
    return (qq_decimal$currprec * (i64)9);
}

static void qq_decimal$bn_setglobalprec(i64 prec) {
    qq_decimal$currprec = (((prec - (i64)1) / (i64)9) + (i64)1);
}

static struct qq_decls$objrec *qq_decimal$bn_makefloat(r64 x) {
        u8 str[2048];
    msysc$m_print_startstr(str);
    msysc$m_print_r64(x,(byte*)".15g");
    msysc$m_print_end();
    ;
    return qq_decimal$bn_makestr((u8 *)str,(i64)0);
}

struct qq_decls$varrec *qq_decimal$dectemp(struct qq_decls$varrec *a) {
    qq_decimal$vtemp.tagx = (i64)260;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)1)) {
        qq_decimal$vtemp.objptr = qq_decimal$bn_makeint((*a).value);
    }
    else if (($temp==(i64)3)) {
        qq_decimal$vtemp.objptr = qq_decimal$bn_makefloat((*a).xvalue);
    }
    else {
        qq_lib$pcerror((byte*)"dectemp");
    }
    };
    (*a) = qq_decimal$vtemp;
    return a;
}

void qq_decimal$freedectemp(void) {
    qq_decimal$obj_free_dec(qq_decimal$vtemp.objptr);
}

static void qq_decimal$bn_ipower(struct qq_decls$objrec *d,struct qq_decls$objrec *a,i64 n) {
        struct qq_decls$objrec *  e;
        struct qq_decls$objrec *  f;
    if ((n < (i64)0)) {
        qq_decimal$bn_setzero(d);
    }
    else if ((n == (i64)0)) {
        qq_decimal$bn_move(d,qq_decimal$bn_makeint((i64)1));
    }
    else if ((n == (i64)1)) {
        qq_decimal$bn_dupl(d,a);
    }
    else if (((n & (i64)1) == (i64)0)) {
        e = qq_decimal$bn_init();
        qq_decimal$bn_mulu(e,a,a);
        qq_decimal$bn_ipower(d,e,(n / (i64)2));
        qq_decimal$obj_free_dec(e);
    }
    else {
        e = qq_decimal$bn_init();
        f = qq_decimal$bn_init();
        qq_decimal$bn_mulu(e,a,a);
        qq_decimal$bn_ipower(f,e,((n - (i64)1) / (i64)2));
        qq_decimal$bn_mulu(d,a,f);
        qq_decimal$obj_free_dec(e);
        qq_decimal$obj_free_dec(f);
    }
;
}

void qq_decimal$var_power_dec(struct qq_decls$varrec *a,i64 n) {
        struct qq_decls$objrec *  dest;
    dest = qq_decimal$bn_init();
    qq_decimal$bn_ipower(dest,(*a).objptr,n);
    (*a).objptr = dest;
}

i64 qq_decimal$var_convert_dec_int(struct qq_decls$varrec *a) {
    return qq_decimal$bn_toint((*a).objptr);
}

static i64 qq_decimal$bn_toint(struct qq_decls$objrec *a) {
        i64 x;
        i64 $av_1;
        i64 $av_2;
        i64 i;
    if (!(!!(qq_decimal$bn_isint(a)))) {
        qq_lib$pcerror((byte*)"dec-float->int not ready");
        return (i64)0;
    }
;
    if (!!(qq_decimal$bn_iszero(a))) {
        return (i64)0;
    }
;
    x = (i64)0;
        ($av_1 = ((*a).length - (i64)1));
    for (i=(i64)0;i<=$av_1;++i) {
L166 :;
        x = ((x * (i64)1000000000) + (i64)(*(*a).num)[(i)]);
L167 :;
    }
L168 :;
    ;
        ($av_2 = (i64)(*a).expon);
    for (i=(*a).length;i<=$av_2;++i) {
L169 :;
        x *= (i64)1000000000;
L170 :;
    }
L171 :;
    ;
    if (!!((i64)(*a).neg)) {
        return -(x);
    }
    else {
        return x;
    }
;
}

// START
void qq_decimal$start(void) {

}

// START
void qq_decls$start(void) {

}

void qq_dicts$var_make_dict(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  b;
        struct qq_decls$varrec v;
        i64 $av_1;
    p = qq_dicts$obj_new_dict(n);
    b = (*p).varptr;
    v.tagx = (i64)265;
    v.objptr = p;
    $av_1 = n;
    while ($av_1-- > 0) {
L172 :;
        qq_dicts$adddictitem(&v,a,(a + (i64)1));
        a += (i64)2;
L173 :;
    }
L174 :;
    ;
    (*p).dictitems = n;
    (*dest) = v;
}

struct qq_decls$objrec *qq_dicts$obj_new_dict(i64 n) {
        struct qq_decls$objrec *  p;
        i64 m;
    m = msysc$m_imax((i64)16,qq_lib$nextpoweroftwo((n * (i64)2)));
    p = qq_lists$obj_newlist(m,(i64)1,0);
    (*p).dictitems = (i64)0;
    return p;
}

void qq_dicts$obj_free_dict(struct qq_decls$objrec *p,i64 internal) {
        struct qq_decls$varrec *  q;
        i64 $av_1;
    q = (*p).varptr;
    $av_1 = (*p).length;
    while ($av_1-- > 0) {
L175 :;
        if (!!((i64)(*q).hasref)) {
            qq_vars$var_unshareu(q);
        }
;
        ++(q);
L176 :;
    }
L177 :;
    ;
    if (!!((*p).length)) {
        mlib$pcm_free((*p).varptr,((i64)(*p).alloc32 * (i64)16));
    }
;
    if (!(!!(internal))) {
        mlib$pcm_free32(p);
    }
;
}

void qq_dicts$var_dupl_dict(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        struct qq_decls$varrec *  plist;
        struct qq_decls$varrec *  qlist;
        i64 $av_1;
    p = (*a).objptr;
    q = qq_dicts$obj_new_dict((i64)(*p).dictitems);
    (*q) = (*p);
    (*q).refcount = (i64)1;
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)1,(u64)1u);
    (*a).objptr = q;
    if (((*q).length == (i64)0)) {
        return;
    }
;
    qlist = ((*q).varptr = (struct qq_decls$varrec *)mlib$pcm_alloc(((*p).length * (i64)16)));
    (*q).alloc32 = (mlib$allocbytes / (i64)16);
    plist = (*p).varptr;
    $av_1 = (*q).length;
    while ($av_1-- > 0) {
L178 :;
        (*qlist) = (*plist);
        if (!!((i64)(*qlist).hasref)) {
            qq_vars$var_duplu(qlist);
        }
;
        ++(qlist);
        ++(plist);
L179 :;
    }
L180 :;
    ;
}

i64 qq_dicts$var_equal_dict(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
    qq_lib$pcerror((byte*)"EQUALDICT");
    return (i64)1;
}

struct qq_decls$varrec *qq_dicts$var_finddictitem(struct qq_decls$varrec *vd,struct qq_decls$varrec *p,i64 doins) {
        i64 index;
        i64 size;
        i64 keytag;
        i64 wrapped;
        i64 limit;
        i64 keyvalue;
        struct qq_decls$varrec *  q;
        struct qq_decls$objrec *  pa;
        struct qq_decls$objrec *  qa;
        struct qq_decls$objrec *  d;
    //retry:
L181 :;
;
    d = (*vd).objptr;
    size = ((*d).length / (i64)2);
    index = (qq_vars$var_gethashvalue(p) & (size - (i64)1));
    q = ((*d).varptr + (index * (i64)2));
    wrapped = (i64)0;
    keytag = (i64)(*p).tag;
    keyvalue = (*p).value;
    pa = (*p).objptr;
    L182 :;
    while (1) {
        if (((i64)(*q).tag == (i64)0)) {
            goto L183 ;
        }
        else if (((i64)(*q).tag == keytag)) {
            if ((keytag==(i64)1) || (keytag==(i64)3) || (keytag==(i64)2) || (keytag==(i64)6)) {
                if (((*q).value == keyvalue)) {
                    ++(q);
                    if (!!((i64)(*q).hasref)) {
                        ++((*(*q).objptr).refcount);
                    }
;
                    return q;
                }
;
            }
            else if ((keytag==(i64)12)) {
                qa = (*q).objptr;
                if (((*pa).length == (*qa).length)) {
                    if ((memcmp((void *)(*pa).strptr,(void *)(*qa).strptr,(u64)(*pa).length) == (i64)0)) {
                        ++(q);
                        if (!!((i64)(*q).hasref)) {
                            ++((*(*q).objptr).refcount);
                        }
;
                        return q;
                    }
;
                }
;
            }
;
        }
;
        ++(index);
        q += (i64)2;
        if ((index >= size)) {
            if (!!(wrapped)) {
                qq_lib$pcerror((byte*)"DICT FULL?");
            }
;
            wrapped = (i64)1;
            index = (i64)0;
            q = (*d).varptr;
        }
;
    }
L183 :;
    ;
    if (!!(doins)) {
        limit = ((size * (i64)3) / (i64)4);
        if (((i64)(*d).dictitems >= limit)) {
            qq_dicts$expanddict(vd);
            goto L181 ;
;
        }
;
        (*q) = (*p);
        if (!!((i64)(*q).hasref)) {
            ++((*(*q).objptr).refcount);
        }
;
        ++((*d).dictitems);
        return (q + (i64)1);
    }
    else {
        return 0;
    }
;
}

static void qq_dicts$expanddict(struct qq_decls$varrec *vd) {
        i64 n;
        i64 m;
        i64 i;
        i64 oldrefcount;
        struct qq_decls$objrec *  d;
        struct qq_decls$objrec *  e;
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  q;
        struct qq_decls$varrec *  r;
        struct qq_decls$varrec ev;
        static byte inuse;
    if (!!((i64)inuse)) {
        qq_lib$pcerror((byte*)"expanddict?");
    }
;
    inuse = (i64)1;
    d = (*vd).objptr;
    n = (i64)(*d).alloc32;
    m = (n / (i64)2);
    p = (*d).varptr;
    e = qq_dicts$obj_new_dict((m * (i64)2));
    qq_vars$var_objtovar((i64)9,e,&ev);
    q = p;
    for (i=(i64)1;i<=m;++i) {
L184 :;
        if (((i64)(*q).tag != (i64)0)) {
            r = qq_dicts$var_finddictitem(&ev,q,(i64)1);
            ++(q);
            (*r) = (*(q)++);
            if (!!((i64)(*r).hasref)) {
                ++((*(*r).objptr).refcount);
            }
;
        }
        else {
            q += (i64)2;
        }
;
L185 :;
    }
L186 :;
    ;
    qq_dicts$obj_free_dict(d,(i64)1);
    oldrefcount = (i64)(*d).refcount;
    (*d) = (*e);
    mlib$pcm_free(e,(i64)8);
    (*d).refcount = oldrefcount;
    inuse = (i64)0;
}

static void qq_dicts$adddictitem(struct qq_decls$varrec *d,struct qq_decls$varrec *p,struct qq_decls$varrec *q) {
        struct qq_decls$objrec *  da;
        struct qq_decls$varrec *  r;
    da = (*d).objptr;
    if (((*da).length == (i64)0)) {
        qq_lib$pcerror((byte*)"NULL DICT");
    }
;
    r = qq_dicts$var_finddictitem(d,p,(i64)1);
    if (!!((i64)(*q).hasref)) {
        ++((*(*q).objptr).refcount);
    }
;
    if (!!((i64)(*r).hasref)) {
        qq_vars$var_unshareu(r);
    }
;
    (*r) = (*q);
}

void qq_dicts$var_checkiter_dict(struct qq_decls$varrec *a,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        struct qq_decls$varrec *  d;
    p = (*a).objptr;
    q = (*p).objptr2;
    (*dest).tagx = (i64)5;
    (*dest).value = (i64)0;
    if (((i64)(*p).iterpos >= ((i64)(*p).iterupper - (i64)1))) {
        return;
    }
;
    (*p).iterpos += (i32)(i64)2;
    d = (((*q).varptr + (i64)(*p).iterpos) - (i64)1);
    L187 :;
    while (((i64)(*d).tag == (i64)0)) {
        d += (i64)2;
        (*p).iterpos += (i32)(i64)2;
        if (((i64)(*p).iterpos > (i64)(*p).iterupper)) {
            return;
        }
;
L188 :;
    }
L189 :;
    ;
    (*p).iterpos -= (i32)(i64)2;
    (*dest).value = (i64)1;
}

void qq_dicts$var_nextiter_dict(struct qq_decls$varrec *a,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  d;
    p = (*a).objptr;
    if (((i64)(*p).iterpos >= ((i64)(*p).iterupper - (i64)1))) {
        (*dest).tagx = (i64)0;
        return;
    }
;
    (*p).iterpos += (i32)(i64)2;
    d = (((*(*p).objptr2).varptr + (i64)(*p).iterpos) - (i64)1);
    if (((i64)(*d).tag == (i64)0)) {
        qq_lib$pcerror((byte*)"nextiter/dict?");
    }
;
    (*dest).tagx = (i64)1;
    (*dest).value = (i64)(*p).iterpos;
}

// START
void qq_dicts$start(void) {

}

void qq_iterators$var_make_iter(struct qq_decls$varrec *a,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 pos;
        i64 upper;
    p = qq_vars$obj_new();
    q = (*a).objptr;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)12)) {
        pos = (i64)0;
        upper = (*q).length;
    }
    else if (($temp==(i64)13)) {
        pos = ((i64)(*q).lower16 - (i64)1);
        upper = ((*q).length + (i64)(*p).iterpos);
    }
    else if (($temp==(i64)14)) {
        pos = ((i64)msysc$m_getdotindex((i64)(*q).flags,(i64)0) - (i64)1);
        upper = ((*q).length + (i64)(*p).iterpos);
    }
    else if (($temp==(i64)8)) {
        pos = (i64)-1;
        upper = ((*q).length - (i64)1);
    }
    else if (($temp==(i64)9)) {
        pos = (i64)-1;
        upper = (*q).length;
    }
    else {
        qq_lib$pcerror((byte*)"Bad Iterator target");
    }
    };
    (*p).objptr2 = q;
    (*p).itertag = (i64)(*a).tag;
    (*p).iterpos = pos;
    (*p).iterupper = upper;
    ++((*q).refcount);
    (*dest).tagx = (i64)281;
    (*dest).objptr = p;
}

void qq_iterators$var_check_iter(struct qq_decls$varrec *a,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  p;
    if (((i64)(*a).tag != (i64)25)) {
        qq_lib$pcerror((byte*)"Not iterator");
    }
;
    p = (*a).objptr;
        {i64 $temp = (i64)(*p).itertag;
if (($temp==(i64)12) || ($temp==(i64)13) || ($temp==(i64)14)) {
        (*dest).tagx = (i64)5;
        if (((i64)(*p).iterpos >= (i64)(*p).iterupper)) {
            (*dest).value = (i64)0;
        }
        else {
            (*dest).value = (i64)1;
        }
;
    }
    else if (($temp==(i64)9)) {
        qq_dicts$var_checkiter_dict(a,dest);
    }
    else if (($temp==(i64)8)) {
        qq_sets$var_checkiter_set(a,dest);
    }
    else {
        qq_lib$pcerror_s((byte*)"checkiter not ready:",qq_tables$ttname[((i64)(*p).itertag)]);
    }
    };
}

void qq_iterators$var_next_iter(struct qq_decls$varrec *a,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  p;
    if (((i64)(*a).tag != (i64)25)) {
        qq_lib$pcerror((byte*)"Not iterator");
    }
;
    p = (*a).objptr;
        {i64 $temp = (i64)(*p).itertag;
if (($temp==(i64)12)) {
        qq_strings$var_nextiter_string(a,dest);
    }
    else if (($temp==(i64)13)) {
        qq_lists$var_nextiter_list(a,dest);
    }
    else if (($temp==(i64)14)) {
        qq_arrays$var_nextiter_array(a,dest);
    }
    else if (($temp==(i64)9)) {
        qq_dicts$var_nextiter_dict(a,dest);
    }
    else if (($temp==(i64)8)) {
        qq_sets$var_nextiter_set(a,dest);
    }
    else {
        qq_lib$pcustype((byte*)"nextiter not ready",a);
    }
    };
}

void qq_iterators$obj_free_iter(struct qq_decls$objrec *p) {
        struct qq_decls$varrec v;
    v.tagx = (i64)(*p).itertag;
    v.objptr = (*p).objptr2;
    qq_vars$var_unshareu(&v);
    mlib$pcm_free32(p);
}

void qq_iterators$var_dupl_iter(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    q = (*a).objptr;
    p = qq_vars$obj_new();
    (*p).objptr2 = (*q).objptr2;
    ++((*(*p).objptr2).refcount);
    (*p).itertag = (i64)(*q).itertag;
    (*p).iterpos = (i64)(*q).iterpos;
    (*p).iterupper = (i64)(*q).iterupper;
    (*a).objptr = p;
}

// START
void qq_iterators$start(void) {

}

i64 qq_jhandlers_hll$asmavailable(void) {
    return (i64)0;
}

i64 *qq_jhandlers_hll$disploop_asm(void) {
    mlib$abortprogram((byte*)"-ASM NOT AVAILABLE");
    return (i64 *)0;
}

void qq_jhandlers_hll$initjhandlers(void) {
}

// START
void qq_jhandlers_hll$start(void) {

}

void qq_khandlers$initkhandlers(void) {
        u8 *  name;
        static i64 handlersdone = (i64)0;
        i64 $av_2;
        i64 i;
        i64 k;
    if (!!(handlersdone)) {
        return;
    }
;
        ($av_2 = msysc$m_get_nprocs());
    for (i=(i64)1;i<=$av_2;++i) {
L190 :;
        name = msysc$m_get_procname(i);
        if (!!(mlib$eqbytes((void *)name,(byte*)"k_",(i64)2))) {
            for (k=(i64)0;k<=(i64)272;++k) {
L193 :;
                if (!!(mlib$eqstring((name + (i64)2),(qq_tables$pclnames[(k)] + (i64)1)))) {
                    qq_khandlers$khandlertable[(k)] = (void (*)(void))msysc$m_get_procaddr(i);
                    goto L195 ;
                }
;
L194 :;
            }
            {
                qq_lib$pcerror_s((byte*)"Unknown khandler",name);
            }
L195 :;
            ;
        }
;
L191 :;
    }
L192 :;
    ;
    for (i=(i64)0;i<=(i64)272;++i) {
L196 :;
        if ((qq_khandlers$khandlertable[(i)] == 0)) {
            qq_khandlers$khandlertable[(i)] = (void (*)(void))qq_khandlers$kunimpl;
        }
;
L197 :;
    }
L198 :;
    ;
    handlersdone = (i64)1;
}

void qq_khandlers$kunimpl(void) {
    if (!!(qq_decls$hasbytecodes)) {
        qq_lib$pcerror_s((byte*)"Unimplemented:",qq_tables$pclnames[((*qq_decls$pcptr))]);
    }
    else {
        qq_lib$pcerror((byte*)"Unimplemented (use -fdebug to see opcode)");
    }
;
}

void qq_khandlers$k_pushci(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = (*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushtrue(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)5;
    (*qq_decls$sptr).value = (i64)1;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_pushfalse(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)5;
    (*qq_decls$sptr).value = (i64)0;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_pushcu(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)2;
    (*qq_decls$sptr).value = (*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushnil(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)24;
    (*qq_decls$sptr).elemtag = (i64)0;
    (*qq_decls$sptr).ptr = 0;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_pushcs(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)268;
    (*qq_decls$sptr).objptr = (struct qq_decls$objrec *)(*(qq_decls$pcptr + (i64)1));
    ++((*(*qq_decls$sptr).objptr).refcount);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushcr(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)3;
    (*qq_decls$sptr).xvalue = (r64)msysc$m_tp_i64tor64((*(qq_decls$pcptr + (i64)1)));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushenum(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)7;
    (*qq_decls$sptr).elemtag = (*(qq_decls$pcptr + (i64)2));
    (*qq_decls$sptr).value = (*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)3);
}

void qq_khandlers$k_stop(void) {
    qq_decls$stopped = (i64)1;
}

void qq_khandlers$k_stoprunproc(void) {
    qq_decls$stopped = (i64)1;
}

void qq_khandlers$k_pushm(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr) = (*(struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)1)));
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        ++((*(*qq_decls$sptr).objptr).refcount);
    }
;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushf(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr) = (*(struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1))));
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        ++((*(*qq_decls$sptr).objptr).refcount);
    }
;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushff(void) {
    qq_decls$sptr += (i64)2;
    (*(qq_decls$sptr - (i64)1)) = (*(struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1))));
    if (!!((i64)(*(qq_decls$sptr - (i64)1)).hasref)) {
        ++((*(*(qq_decls$sptr - (i64)1)).objptr).refcount);
    }
;
    (*qq_decls$sptr) = (*(struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)2))));
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        ++((*(*qq_decls$sptr).objptr).refcount);
    }
;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
}

void qq_khandlers$k_pushmref(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)17;
    (*qq_decls$sptr).varptr = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushfref(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)17;
    (*qq_decls$sptr).varptr = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1)));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_popm(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)1));
    if (!!((i64)(*p).hasref)) {
        qq_vars$var_unshareu(p);
    }
;
    (*p) = (*qq_decls$sptr);
    --(qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_storem(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)1));
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        ++((*(*qq_decls$sptr).objptr).refcount);
    }
;
    if (!!((i64)(*p).hasref)) {
        qq_vars$var_unshareu(p);
    }
;
    (*p) = (*qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_zpopm(void) {
    (*(struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)1))) = (*qq_decls$sptr);
    --(qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_popf(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1)));
    if (!!((i64)(*p).hasref)) {
        qq_vars$var_unshareu(p);
    }
;
    (*p) = (*qq_decls$sptr);
    --(qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_storef(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1)));
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        ++((*(*qq_decls$sptr).objptr).refcount);
    }
;
    if (!!((i64)(*p).hasref)) {
        qq_vars$var_unshareu(p);
    }
;
    (*p) = (*qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_zpopf(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1)));
    (*p) = (*qq_decls$sptr);
    --(qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_popretval(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1)));
    (*p) = (*qq_decls$sptr);
    --(qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_tom(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)2));
    --((*p).value);
    if (!!((*p).value)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)3);
    }
;
}

void qq_khandlers$k_tof(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)2)));
    --((*p).value);
    if (!!((*p).value)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)3);
    }
;
}

void qq_khandlers$k_add(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_add(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_sub(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_sub(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_mul(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_mul(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_div(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_div(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_idiv(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_idiv(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_irem(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_irem(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_iand(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_iand(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_ior(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_ior(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_ixor(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_ixor(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_shl(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_shl(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_shr(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_shr(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_sqr(void) {
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1)) {
        (*qq_decls$sptr).value = ((*qq_decls$sptr).value*(*qq_decls$sptr).value);
    }
    else if (($temp==(i64)3)) {
        (*qq_decls$sptr).xvalue = ((*qq_decls$sptr).xvalue*(*qq_decls$sptr).xvalue);
    }
    else {
        qq_lib$pcustype((byte*)"Sqr",qq_decls$sptr);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_sign(void) {
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1)) {
        (*qq_decls$sptr).value = (((*qq_decls$sptr).value < (i64)0) ? (i64)-1 : (((*qq_decls$sptr).value > (i64)0) ? (i64)1 : (i64)0));
    }
    else if (($temp==(i64)3)) {
        (*qq_decls$sptr).tag = (i64)1;
        (*qq_decls$sptr).value = (((*qq_decls$sptr).xvalue < (double)0.) ? (i64)-1 : (((*qq_decls$sptr).xvalue > (double)0.) ? (i64)1 : (i64)0));
    }
    else {
        qq_lib$pcustype((byte*)"Sign",qq_decls$sptr);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_sqrt(void) {
    qq_khandlers$domaths((i64)108);
}

void qq_khandlers$k_sin(void) {
    qq_khandlers$domaths((i64)111);
}

void qq_khandlers$k_cos(void) {
    qq_khandlers$domaths((i64)112);
}

void qq_khandlers$k_tan(void) {
    qq_khandlers$domaths((i64)113);
}

void qq_khandlers$k_asin(void) {
    qq_khandlers$domaths((i64)114);
}

void qq_khandlers$k_acos(void) {
    qq_khandlers$domaths((i64)115);
}

void qq_khandlers$k_atan(void) {
    qq_khandlers$domaths((i64)116);
}

void qq_khandlers$k_ln(void) {
    qq_khandlers$domaths((i64)118);
}

void qq_khandlers$k_log(void) {
    qq_khandlers$domaths((i64)119);
}

void qq_khandlers$k_lg(void) {
    qq_khandlers$domaths((i64)120);
}

void qq_khandlers$k_exp(void) {
    qq_khandlers$domaths((i64)121);
}

void qq_khandlers$k_round(void) {
    qq_khandlers$domaths((i64)122);
}

void qq_khandlers$k_floor(void) {
    qq_khandlers$domaths((i64)123);
}

void qq_khandlers$k_ceil(void) {
    qq_khandlers$domaths((i64)124);
}

void qq_khandlers$k_fract(void) {
    qq_khandlers$domaths((i64)125);
}

void qq_khandlers$k_neg(void) {
        struct qq_decls$varrec x;
    x = (*qq_decls$sptr);
    qq_vars$var_neg(qq_decls$sptr);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_negto(void) {
        struct qq_decls$varrec *  px;
    px = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_negto(px)))) {
        qq_vars$var_inplace_unary(px,(void (*)(struct qq_decls$varrec *))qq_vars$var_neg);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_absto(void) {
        struct qq_decls$varrec *  px;
    px = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_absto(px)))) {
        qq_vars$var_inplace_unary(px,(void (*)(struct qq_decls$varrec *))qq_vars$var_abs);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_inotto(void) {
        struct qq_decls$varrec *  px;
    px = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_inotto(px)))) {
        qq_vars$var_inplace_unary(px,(void (*)(struct qq_decls$varrec *))qq_vars$var_inot);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_atan2(void) {
    qq_lib$pcerror((byte*)"ATAN2 NOT READY");
}

void qq_khandlers$k_fmod(void) {
    qq_lib$pcerror((byte*)"FMOD NOT READY");
}

void qq_khandlers$k_abs(void) {
        struct qq_decls$varrec x;
    x = (*qq_decls$sptr);
    qq_vars$var_abs(qq_decls$sptr);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_inot(void) {
        struct qq_decls$varrec x;
    x = (*qq_decls$sptr);
    qq_vars$var_inot(qq_decls$sptr);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_istruel(void) {
        i64 res;
    res = qq_vars$var_istruel(qq_decls$sptr);
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_notl(void) {
        i64 res;
    res = (i64)!(!!(qq_vars$var_istruel(qq_decls$sptr)));
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_jumpeq(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  x;
    y = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
    if (!!(qq_vars$var_equal(x,y))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
}

void qq_khandlers$k_jumpne(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_equal(x,y)))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
}

void qq_khandlers$k_jumplt(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = qq_decls$sptr;
    x = (qq_decls$sptr - (i64)1);
    qq_decls$sptr -= (i64)2;
    if ((qq_vars$var_compare(x,y) < (i64)0)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
}

void qq_khandlers$k_jumple(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
    if ((qq_vars$var_compare(x,y) <= (i64)0)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
}

void qq_khandlers$k_jumpge(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = qq_decls$sptr;
    x = (qq_decls$sptr - (i64)1);
    qq_decls$sptr -= (i64)2;
    if ((qq_vars$var_compare(x,y) >= (i64)0)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
}

void qq_khandlers$k_jumpgt(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
    if ((qq_vars$var_compare(x,y) > (i64)0)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
}

void qq_khandlers$k_jumpfalse(void) {
        struct qq_decls$varrec *  x;
    x = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_istruel(x)))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
}

void qq_khandlers$k_jumptrue(void) {
        struct qq_decls$varrec *  x;
    x = (qq_decls$sptr)--;
    if (!!(qq_vars$var_istruel(x))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
    }
;
}

void qq_khandlers$k_incrtom(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)1));
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1)) {
        ++((*p).value);
    }
    else if (($temp==(i64)17)) {
        ++((*p).varptr);
    }
    else if (($temp==(i64)24)) {
        (*p).ptr += qq_tables$ttsize[((i64)(*p).elemtag)];
    }
    else if (($temp==(i64)3)) {
        (*p).xvalue += (double)1.;
    }
    else {
        qq_lib$pcustype((byte*)"incrtom",p);
    }
    };
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_incrtof(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1)));
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1) || ($temp==(i64)2)) {
        ++((*p).value);
    }
    else if (($temp==(i64)17)) {
        ++((*p).varptr);
    }
    else if (($temp==(i64)24)) {
        (*p).ptr += qq_tables$ttsize[((i64)(*p).elemtag)];
    }
    else if (($temp==(i64)3)) {
        (*p).xvalue += (double)1.;
    }
    else {
        qq_lib$pcustype((byte*)"incrtof",p);
    }
    };
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_decrtom(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)1));
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1) || ($temp==(i64)2)) {
        --((*p).value);
    }
    else if (($temp==(i64)17)) {
        --((*p).varptr);
    }
    else if (($temp==(i64)24)) {
        (*p).value -= qq_tables$ttsize[((i64)(*p).elemtag)];
    }
    else if (($temp==(i64)3)) {
        (*p).xvalue -= (double)1.;
    }
    else {
        qq_lib$pcustype((byte*)"decrtom",p);
    }
    };
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_decrtof(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)1)));
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)1) || ($temp==(i64)2)) {
        --((*p).value);
    }
    else if (($temp==(i64)3)) {
        (*p).xvalue -= (double)1.;
    }
    else if (($temp==(i64)17)) {
        --((*p).varptr);
    }
    else if (($temp==(i64)24)) {
        (*p).ptr -= qq_tables$ttsize[((i64)(*p).elemtag)];
    }
    else {
        qq_lib$pcustype((byte*)"decrtof",p);
    }
    };
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_incrload(void) {
        struct qq_decls$varrec v;
    v = (*qq_decls$sptr);
    qq_khandlers$k_incrptr();
    qq_vars$var_loadptr(&v,++(qq_decls$sptr));
}

void qq_khandlers$k_loadincr(void) {
        struct qq_decls$varrec v;
    v = (*qq_decls$sptr);
    qq_vars$var_loadptr(qq_decls$sptr,qq_decls$sptr);
    ++(qq_decls$sptr);
    (*qq_decls$sptr) = v;
    qq_khandlers$k_incrptr();
}

void qq_khandlers$k_decrload(void) {
        struct qq_decls$varrec v;
    v = (*qq_decls$sptr);
    qq_khandlers$k_decrptr();
    qq_vars$var_loadptr(&v,++(qq_decls$sptr));
}

void qq_khandlers$k_loaddecr(void) {
        struct qq_decls$varrec v;
    v = (*qq_decls$sptr);
    qq_vars$var_loadptr(qq_decls$sptr,qq_decls$sptr);
    ++(qq_decls$sptr);
    (*qq_decls$sptr) = v;
    qq_khandlers$k_decrptr();
}

void qq_khandlers$k_incrptr(void) {
        struct qq_decls$varrec *  p;
    p = (qq_decls$sptr)--;
    switch ((i64)(*p).tag) {
    case 17:;
        {
            p = (*p).varptr;
            switch ((i64)(*p).tag) {
            case 1:;
            case 2:;
                {
                    ++((*p).value);
                }
                break;
            case 17:;
                {
                    ++((*p).varptr);
                }
                break;
            case 24:;
                {
                    (*p).ptr += qq_tables$ttsize[((i64)(*p).elemtag)];
                }
                break;
            case 3:;
                {
                    (*p).xvalue += (double)1.;
                }
                break;
            default: {
                qq_lib$pcustype((byte*)"incrptr/refvar",p);
            }
            } //SW
;
        }
        break;
    case 24:;
        {
            switch ((i64)(*p).elemtag) {
            case 31:;
            case 28:;
                {
                    ++((*(*p).ptr));
                }
                break;
            case 32:;
            case 29:;
                {
                    ++((*(u16 *)(*p).ptr));
                }
                break;
            default: {
                qq_lib$pcustype_t((byte*)"incrptr/ref",(i64)(*p).elemtag);
            }
            } //SW
;
        }
        break;
    default: {
        qq_lib$pcustype((byte*)"incrptr",p);
    }
    } //SW
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_decrptr(void) {
        struct qq_decls$varrec *  p;
    p = (qq_decls$sptr)--;
    switch ((i64)(*p).tag) {
    case 17:;
        {
            p = (*p).varptr;
            switch ((i64)(*p).tag) {
            case 1:;
            case 2:;
                {
                    --((*p).value);
                }
                break;
            case 17:;
                {
                    --((*p).varptr);
                }
                break;
            case 24:;
                {
                    (*p).ptr -= qq_tables$ttsize[((i64)(*p).elemtag)];
                }
                break;
            case 3:;
                {
                    (*p).xvalue -= (double)1.;
                }
                break;
            default: {
                qq_lib$pcustype((byte*)"incrptr/refvar",p);
            }
            } //SW
;
        }
        break;
    case 24:;
        {
            switch ((i64)(*p).elemtag) {
            case 31:;
            case 28:;
                {
                    --((*(*p).ptr));
                }
                break;
            case 32:;
            case 29:;
                {
                    --((*(u16 *)(*p).ptr));
                }
                break;
            default: {
                qq_lib$pcustype_t((byte*)"incrptr/ref",(i64)(*p).elemtag);
            }
            } //SW
;
        }
        break;
    default: {
        qq_lib$pcustype((byte*)"incrptr",p);
    }
    } //SW
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_pushvoid(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)0;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_callproc(void) {
        static i64 count = (i64)100;
    if ((--(count) == (i64)0)) {
        count = (i64)100;
        mwindows$os_peek();
    }
;
    if ((qq_decls$sptr >= qq_decls$stacklimit)) {
        qq_lib$pcerror((byte*)"Stack Overflow");
    }
;
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)21;
    (*qq_decls$sptr).retaddr = (qq_decls$pcptr + (i64)3);
    (*qq_decls$sptr).frameptr_low = (i64)(u64)qq_decls$frameptr;
    qq_decls$frameptr = (byte *)qq_decls$sptr;
    qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
}

void qq_khandlers$k_callptr(void) {
        struct qq_decls$strec *  d;
    if (((i64)(*qq_decls$sptr).tag != (i64)23)) {
        qq_lib$pcerror((byte*)"Probably undefined function");
    }
;
    d = (*qq_decls$sptr).def;
    if (((i64)(*d).nameid == (i64)19)) {
        d = (*d).alias;
    }
;
    if (((i64)(*d).nparams != (*(qq_decls$pcptr + (i64)1)))) {
        qq_lib$pcerror_s((byte*)"Callptr: wrong # params; need:",msysc$strint((i64)(*d).nparams,0));
    }
;
    (*qq_decls$sptr).tagx = (i64)21;
    (*qq_decls$sptr).retaddr = (qq_decls$pcptr + (i64)3);
    (*qq_decls$sptr).frameptr_low = (i64)(u64)qq_decls$frameptr;
    qq_decls$frameptr = (byte *)qq_decls$sptr;
    qq_decls$pcptr = (*d).pcaddress;
}

void qq_khandlers$k_procentry(void) {
        i64 $av_1;
    $av_1 = (*(qq_decls$pcptr + (i64)1));
    while ($av_1-- > 0) {
L199 :;
        ++(qq_decls$sptr);
        (*qq_decls$sptr).tagx = (i64)0;
L200 :;
    }
L201 :;
    ;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_return(void) {
        i64 nargs;
        i64 $av_1;
    if ((u64)0u) {
        if (((i64)(*qq_decls$sptr).tag != (i64)21)) {
            qq_lib$pcerror_s((byte*)"Not tretaddr:",qq_tables$ttname[((i64)(*qq_decls$sptr).tag)]);
        }
;
    }
;
    nargs = (*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (*qq_decls$sptr).retaddr;
    (*(i32 *)&qq_decls$frameptr) = (i64)(*qq_decls$sptr).frameptr_low;
    --(qq_decls$sptr);
    $av_1 = nargs;
    while ($av_1-- > 0) {
L202 :;
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        --(qq_decls$sptr);
L203 :;
    }
L204 :;
    ;
}

void qq_khandlers$k_return0(void) {
    if ((u64)0u) {
        if (((i64)(*qq_decls$sptr).tag != (i64)21)) {
            qq_lib$pcerror_s((byte*)"Not tretaddr:",qq_tables$ttname[((i64)(*qq_decls$sptr).tag)]);
        }
;
    }
;
    qq_decls$pcptr = (*qq_decls$sptr).retaddr;
    (*(i32 *)&qq_decls$frameptr) = (i64)(*qq_decls$sptr).frameptr_low;
    --(qq_decls$sptr);
}

void qq_khandlers$k_unshare(void) {
        i64 $av_1;
    $av_1 = (*(qq_decls$pcptr + (i64)1));
    while ($av_1-- > 0) {
L205 :;
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        --(qq_decls$sptr);
L206 :;
    }
L207 :;
    ;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_unshare1(void) {
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    --(qq_decls$sptr);
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_formci(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)2));
    ++((*p).value);
    if (((*p).value <= (*(qq_decls$pcptr + (i64)3)))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_forfci(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)2)));
    ++((*p).value);
    if (((*p).value <= (*(qq_decls$pcptr + (i64)3)))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_fordmci(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)2));
    --((*p).value);
    if (((*p).value >= (*(qq_decls$pcptr + (i64)3)))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_fordfci(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)2)));
    --((*p).value);
    if (((*p).value >= (*(qq_decls$pcptr + (i64)3)))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_formm(void) {
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  q;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)2));
    q = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)3));
    ++((*p).value);
    if (((*p).value <= (*q).value)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_fordmm(void) {
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  q;
    p = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)2));
    q = (struct qq_decls$varrec *)(*(qq_decls$pcptr + (i64)3));
    --((*p).value);
    if (((*p).value >= (*q).value)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_forff(void) {
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  q;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)2)));
    q = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)3)));
    ++((*p).value);
    if (((*p).value <= (*q).value)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_fordff(void) {
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  q;
    p = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)2)));
    q = (struct qq_decls$varrec *)(qq_decls$frameptr + (*(qq_decls$pcptr + (i64)3)));
    --((*p).value);
    if (((*p).value >= (*q).value)) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
    }
    else {
        qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
    }
;
}

void qq_khandlers$k_comment(void) {
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_makelist(void) {
        struct qq_decls$varrec *  x;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)1));
    x = ((qq_decls$sptr - n) + (i64)1);
    qq_decls$sptr = x;
    qq_lists$var_make_list(x,qq_decls$sptr,n,(*(qq_decls$pcptr + (i64)2)));
    (*(*qq_decls$sptr).objptr).flags = msysc$m_setdotindex((*(*qq_decls$sptr).objptr).flags,(i64)1,(u64)0u);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)3);
}

void qq_khandlers$k_makedict(void) {
        struct qq_decls$varrec *  x;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)1));
    x = ((qq_decls$sptr - (n * (i64)2)) + (i64)1);
    qq_dicts$var_make_dict(x,x,n);
    qq_decls$sptr = x;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_makeset(void) {
        struct qq_decls$varrec *  x;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)1));
    x = ((qq_decls$sptr - n) + (i64)1);
    qq_sets$var_make_set(x,x,n);
    qq_decls$sptr = x;
    (*(*qq_decls$sptr).objptr).flags = msysc$m_setdotindex((*(*qq_decls$sptr).objptr).flags,(i64)1,(u64)0u);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_makerecord(void) {
        struct qq_decls$varrec *  x;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)1));
    x = ((qq_decls$sptr - n) + (i64)1);
    qq_records$var_make_record(x,x,n,(*(qq_decls$pcptr + (i64)2)));
    qq_decls$sptr = x;
    (*(*qq_decls$sptr).objptr).flags = msysc$m_setdotindex((*(*qq_decls$sptr).objptr).flags,(i64)1,(u64)0u);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)3);
}

void qq_khandlers$k_makestruct(void) {
        struct qq_decls$varrec *  x;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)1));
    x = ((qq_decls$sptr - n) + (i64)1);
    qq_packed$var_make_struct(x,x,n,(*(qq_decls$pcptr + (i64)2)));
    qq_decls$sptr = x;
    (*(*qq_decls$sptr).objptr).flags = msysc$m_setdotindex((*(*qq_decls$sptr).objptr).flags,(i64)1,(u64)0u);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)3);
}

void qq_khandlers$k_makearray(void) {
        struct qq_decls$varrec *  x;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)2));
    x = ((qq_decls$sptr - n) + (i64)1);
    qq_arrays$var_make_array(x,x,(*(qq_decls$pcptr + (i64)1)),n,(*(qq_decls$pcptr + (i64)3)),(*(qq_decls$pcptr + (i64)4)));
    qq_decls$sptr = x;
    (*(*qq_decls$sptr).objptr).flags = msysc$m_setdotindex((*(*qq_decls$sptr).objptr).flags,(i64)1,(u64)0u);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)5);
}

void qq_khandlers$k_makebits(void) {
        struct qq_decls$varrec *  x;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)2));
    x = ((qq_decls$sptr - n) + (i64)1);
    qq_bits$var_make_bits(x,x,(*(qq_decls$pcptr + (i64)1)),n,(*(qq_decls$pcptr + (i64)3)),(*(qq_decls$pcptr + (i64)4)));
    qq_decls$sptr = x;
    (*(*qq_decls$sptr).objptr).flags = msysc$m_setdotindex((*(*qq_decls$sptr).objptr).flags,(i64)1,(u64)0u);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)5);
}

void qq_khandlers$k_index(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
        {i64 $temp = (i64)(*y).tag;
if (($temp==(i64)1)) {
        qq_vars$var_getix(qq_decls$sptr,(*y).value);
    }
    else if (($temp==(i64)6)) {
        qq_vars$var_getslice(qq_decls$sptr,msysc$m_getdotslice((*y).dummy,(i64)16,(i64)63),(i64)(*y).range_upper);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Index",&x,y);
    }
    };
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_popindex(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  z;
    z = (qq_decls$sptr)--;
    y = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
        {i64 $temp = (i64)(*z).tag;
if (($temp==(i64)1)) {
        qq_vars$var_putix(y,(*z).value,x);
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
    }
    else if (($temp==(i64)6)) {
        qq_vars$var_putslice(y,msysc$m_getdotslice((*z).dummy,(i64)16,(i64)63),(i64)(*z).range_upper,x);
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
    }
    else {
        qq_lib$pcmxtypes((byte*)"Popindex",y,z);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_indexref(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
        {i64 $temp = (i64)(*y).tag;
if (($temp==(i64)1)) {
        qq_vars$var_getixref(qq_decls$sptr,(*y).value);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Indexref",qq_decls$sptr,y);
    }
    };
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_keyindex(void) {
        struct qq_decls$varrec *  d;
        struct qq_decls$varrec *  k;
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  def;
    def = (qq_decls$sptr)--;
    k = (qq_decls$sptr)--;
    d = qq_decls$sptr;
    if (((i64)(*d).tag != (i64)9)) {
        qq_lib$pcustype((byte*)"dict{}",d);
    }
;
    p = qq_dicts$var_finddictitem(d,k,(i64)0);
    if (!!((i64)(*d).hasref)) {
        qq_vars$var_unshareu(d);
    }
;
    if (!!((i64)(*k).hasref)) {
        qq_vars$var_unshareu(k);
    }
;
    if (!!(p)) {
        (*qq_decls$sptr) = (*p);
        if (!!((i64)(*def).hasref)) {
            qq_vars$var_unshareu(def);
        }
;
    }
    else {
        (*qq_decls$sptr) = (*def);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_popkeyindex(void) {
        struct qq_decls$varrec *  d;
        struct qq_decls$varrec *  k;
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  x;
    k = (qq_decls$sptr)--;
    d = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
    if (((i64)(*d).tag != (i64)9)) {
        qq_lib$pcustype((byte*)"dict{}:=",d);
    }
;
    p = qq_dicts$var_finddictitem(d,k,(i64)1);
    if (((i64)(*p).tag != (i64)0)) {
        if (!!((i64)(*p).hasref)) {
            qq_vars$var_unshareu(p);
        }
;
    }
;
    (*p) = (*x);
    if (!!((i64)(*d).hasref)) {
        qq_vars$var_unshareu(d);
    }
;
    if (!!((i64)(*k).hasref)) {
        qq_vars$var_unshareu(k);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_keyindexref(void) {
        struct qq_decls$varrec *  d;
        struct qq_decls$varrec *  k;
        struct qq_decls$varrec *  p;
    k = (qq_decls$sptr)--;
    d = qq_decls$sptr;
    if (((i64)(*d).tag != (i64)9)) {
        qq_lib$pcustype((byte*)"&dict{}",d);
    }
;
    p = qq_dicts$var_finddictitem(d,k,(i64)0);
    if ((p == 0)) {
        qq_lib$pcerror((byte*)"&dict{} not found");
    }
;
    if (!!((i64)(*p).hasref)) {
        ++((*(*p).objptr).refcount);
    }
;
    if (!!((i64)(*k).hasref)) {
        qq_vars$var_unshareu(k);
    }
;
    if (!!((i64)(*d).hasref)) {
        qq_vars$var_unshareu(d);
    }
;
    (*qq_decls$sptr).tagx = (i64)17;
    (*qq_decls$sptr).varptr = p;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_dot(void) {
        struct qq_decls$strec *  d;
        struct qq_decls$varrec *  p;
        i64 rectype;
        struct qq_decls$varrec v;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)15) || ($temp==(i64)16)) {
    }
    else {
        qq_lib$pcustype((byte*)"dot/not record",qq_decls$sptr);
    }
    };
    rectype = (i64)(*(*qq_decls$sptr).objptr).usertag;
    d = qq_khandlers$resolvefield((*(qq_decls$pcptr + (i64)1)),rectype);
        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)9)) {
        p = ((*(*qq_decls$sptr).objptr).varptr + ((i64)(*d).fieldoffset / (i64)16));
        if (!!((i64)(*p).hasref)) {
            ++((*(*p).objptr).refcount);
        }
;
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        (*qq_decls$sptr) = (*p);
    }
    else if (($temp==(i64)10)) {
        qq_packed$var_loadpacked(((*(*qq_decls$sptr).objptr).ptr + (i64)(*d).fieldoffset),(i64)(*d).mode,&v,0);
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        (*qq_decls$sptr) = v;
    }
    else if (($temp==(i64)5)) {
        (*qq_decls$sptr).tagx = (i64)23;
        (*qq_decls$sptr).def = d;
    }
    else if (($temp==(i64)19)) {
        (*qq_decls$sptr).tagx = (i64)23;
        (*qq_decls$sptr).def = (*d).alias;
    }
    else {
        qq_lib$pcerror_s((byte*)"DOT: can't do this fieldtype:",qq_tables$namenames[((i64)(*d).nameid)]);
    }
    };
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_dotref(void) {
        struct qq_decls$strec *  d;
        struct qq_decls$varrec *  p;
        byte *  q;
        i64 rectype;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)15) || ($temp==(i64)16)) {
    }
    else {
        qq_lib$pcerror((byte*)"dot/not record");
    }
    };
    rectype = (i64)(*(*qq_decls$sptr).objptr).usertag;
    d = qq_khandlers$resolvefield((*(qq_decls$pcptr + (i64)1)),rectype);
        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)9)) {
        p = ((*(*qq_decls$sptr).objptr).varptr + ((i64)(*d).fieldoffset / (i64)16));
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        (*qq_decls$sptr).tagx = (i64)17;
        (*qq_decls$sptr).varptr = p;
    }
    else if (($temp==(i64)10)) {
        q = ((*(*qq_decls$sptr).objptr).ptr + (i64)(*d).fieldoffset);
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        (*qq_decls$sptr).tagx = (i64)24;
        (*qq_decls$sptr).ptr = q;
        (*qq_decls$sptr).elemtag = (i64)(*d).mode;
    }
    else {
        qq_lib$pcerror_s((byte*)"DOTREF: can't do this fieldtype:",qq_tables$namenames[((i64)(*d).nameid)]);
    }
    };
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_popdot(void) {
        struct qq_decls$strec *  d;
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    x = (qq_decls$sptr)--;
    y = (qq_decls$sptr)--;
        {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)15) || ($temp==(i64)16)) {
    }
    else {
        qq_lib$pcustype((byte*)"dot/not record",x);
    }
    };
    d = qq_khandlers$resolvefield((*(qq_decls$pcptr + (i64)1)),(i64)(*(*x).objptr).usertag);
    if (!(!!((i64)(*x).hasref))) {
        qq_lib$pcerror((byte*)"POPDOT");
    }
;
    if (!(!!(msysc$m_getdotindex((i64)(*(*x).objptr).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"Not mutable");
    }
;
        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)9)) {
        p = ((*(*x).objptr).varptr + ((i64)(*d).fieldoffset / (i64)16));
        if (!!((i64)(*p).hasref)) {
            qq_vars$var_unshareu(p);
        }
;
        (*p) = (*y);
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
    }
    else if (($temp==(i64)10)) {
        qq_packed$var_storepacked(((*(*x).objptr).ptr + (i64)(*d).fieldoffset),y,(i64)(*d).mode);
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
    }
    else {
        qq_lib$pcerror_s((byte*)"POPDOT: can't do this fieldtype:",qq_tables$namenames[((i64)(*d).nameid)]);
    }
    };
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_dotindex(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
        {i64 $temp = (i64)(*y).tag;
if (($temp==(i64)1)) {
        qq_vars$var_getdotix(qq_decls$sptr,(*y).value);
    }
    else if (($temp==(i64)6)) {
        qq_vars$var_getdotslice(qq_decls$sptr,msysc$m_getdotslice((*y).dummy,(i64)16,(i64)63),(i64)(*y).range_upper);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Dotindex",&x,y);
    }
    };
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_dotindexref(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
        {i64 $temp = (i64)(*y).tag;
if (($temp==(i64)1)) {
        qq_vars$var_getdotixref(qq_decls$sptr,(*y).value);
    }
    else if (($temp==(i64)6)) {
        qq_vars$var_getdotsliceref(qq_decls$sptr,msysc$m_getdotslice((*y).dummy,(i64)16,(i64)63),(i64)(*y).range_upper);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Dotindexref",qq_decls$sptr,y);
    }
    };
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_popdotindex(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  z;
    z = (qq_decls$sptr)--;
    y = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
        {i64 $temp = (i64)(*z).tag;
if (($temp==(i64)1)) {
        qq_vars$var_putdotix(y,(*z).value,x);
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
    }
    else if (($temp==(i64)6)) {
        qq_vars$var_putdotslice(y,msysc$m_getdotslice((*z).dummy,(i64)16,(i64)63),(i64)(*z).range_upper,x);
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
    }
    else {
        qq_lib$pcmxtypes((byte*)"Popdotindex",y,z);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_len(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$objrec *  p;
        i64 n;
        i64 t;
    x = qq_decls$sptr;
    p = (*x).objptr;
        {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)13) || ($temp==(i64)15) || ($temp==(i64)14) || ($temp==(i64)9) || ($temp==(i64)11)) {
        n = (*p).length;
    }
    else if (($temp==(i64)12)) {
        n = (*p).length;
    }
    else if (($temp==(i64)15) || ($temp==(i64)10) || ($temp==(i64)16)) {
        n = qq_tables$ttlength[((i64)(*p).usertag)];
    }
    else if (($temp==(i64)8)) {
        n = (*p).length;
    }
    else if (($temp==(i64)6)) {
        n = (((i64)(*x).range_upper - msysc$m_getdotslice((*x).dummy,(i64)16,(i64)63)) + (i64)1);
    }
    else if (($temp==(i64)4)) {
        n = qq_decimal$obj_len_dec(p);
    }
    else if (($temp==(i64)7)) {
        t = (i64)(*x).elemtag;
        goto L208 ;
;
        n = qq_tables$ttlength[((i64)(*x).elemtag)];
    }
    else if (($temp==(i64)19)) {
        t = (*qq_decls$sptr).value;
        //dotype:
L208 :;
;
                {i64 $temp = (i64)qq_tables$ttbasetype[(t)];
if (($temp==(i64)7)) {
            n = qq_tables$ttlower[(t)];
        }
        else {
            qq_lib$pcustype((byte*)"t.len",x);
        }
        };
    }
    else {
        qq_lib$pcustype((byte*)"Len",x);
    }
    };
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_upb(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$objrec *  p;
        i64 n;
        i64 t;
    x = qq_decls$sptr;
    p = (*x).objptr;
        {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)13)) {
        n = (((*p).length + (i64)(*p).lower16) - (i64)1);
    }
    else if (($temp==(i64)12) || ($temp==(i64)9)) {
        n = (*p).length;
    }
    else if (($temp==(i64)14) || ($temp==(i64)11)) {
        n = (((*p).length + (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0)) - (i64)1);
    }
    else if (($temp==(i64)15) || ($temp==(i64)16)) {
        n = qq_tables$ttlength[((i64)(*p).usertag)];
    }
    else if (($temp==(i64)10)) {
        t = (i64)(*p).usertag;
        goto L209 ;
;
    }
    else if (($temp==(i64)8)) {
        n = ((*p).length - (i64)1);
    }
    else if (($temp==(i64)6)) {
        n = (i64)(*x).range_upper;
    }
    else if (($temp==(i64)7)) {
        t = (i64)(*x).elemtag;
        goto L209 ;
;
    }
    else if (($temp==(i64)19)) {
        t = (*qq_decls$sptr).value;
        //dotype:
L209 :;
;
                {i64 $temp = (i64)qq_tables$ttbasetype[(t)];
if (($temp==(i64)7) || ($temp==(i64)10)) {
            n = ((qq_tables$ttlength[(t)] + qq_tables$ttlower[(t)]) - (i64)1);
        }
        else {
            qq_lib$pcustype((byte*)"t.upb",x);
        }
        };
    }
    else {
        qq_lib$pcustype((byte*)"Upb",x);
    }
    };
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_lwb(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$objrec *  p;
        i64 n;
        i64 t;
    x = qq_decls$sptr;
    p = (*x).objptr;
        {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)13)) {
        n = (i64)(*p).lower16;
    }
    else if (($temp==(i64)12) || ($temp==(i64)9)) {
        n = (i64)1;
    }
    else if (($temp==(i64)14) || ($temp==(i64)11)) {
        n = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
    }
    else if (($temp==(i64)15) || ($temp==(i64)16)) {
        n = (i64)1;
    }
    else if (($temp==(i64)10)) {
        n = qq_tables$ttlower[((i64)(*p).usertag)];
    }
    else if (($temp==(i64)8)) {
        n = (i64)0;
    }
    else if (($temp==(i64)6)) {
        n = msysc$m_getdotslice((*x).dummy,(i64)16,(i64)63);
    }
    else if (($temp==(i64)7)) {
        n = qq_tables$ttlower[((i64)(*x).elemtag)];
    }
    else if (($temp==(i64)19)) {
        t = (*qq_decls$sptr).value;
        //dotype:
L210 :;
;
                {i64 $temp = (i64)qq_tables$ttbasetype[(t)];
if (($temp==(i64)7)) {
            n = qq_tables$ttlower[(t)];
        }
        else {
            qq_lib$pcustype((byte*)"t.lwb",x);
        }
        };
    }
    else {
        qq_lib$pcustype((byte*)"Lwb",x);
    }
    };
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_bounds(void) {
    qq_khandlers$do_bounds((i64)0);
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_boundsx(void) {
    qq_khandlers$do_bounds((i64)1);
    ++(qq_decls$pcptr);
}

static void qq_khandlers$do_bounds(i64 sx) {
        i64 a;
        i64 b;
        i64 m;
        i64 t;
        struct qq_decls$objrec *  p;
    m = (i64)(*qq_decls$sptr).tag;
    p = (*qq_decls$sptr).objptr;
    if ((m==(i64)13)) {
        a = (i64)(*p).lower16;
        b = (((*p).length + a) - (i64)1);
    }
    else if ((m==(i64)14) || (m==(i64)11)) {
        a = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0);
        b = (((*p).length + a) - (i64)1);
    }
    else if ((m==(i64)12) || (m==(i64)9)) {
        a = (i64)1;
        b = (*p).length;
    }
    else if ((m==(i64)6)) {
        //freddy:
L211 :;
;
        a = msysc$m_getdotslice((*qq_decls$sptr).dummy,(i64)16,(i64)63);
        b = (i64)(*qq_decls$sptr).range_upper;
    }
    else if ((m==(i64)16) || (m==(i64)15)) {
        a = (i64)1;
        b = qq_tables$ttlength[((i64)(*p).usertag)];
    }
    else if ((m==(i64)10)) {
        t = (i64)(*p).usertag;
        goto L212 ;
;
    }
    else if ((m==(i64)8)) {
        a = (i64)0;
        b = ((*p).length - (i64)1);
    }
    else if ((m==(i64)7)) {
        t = (i64)(*qq_decls$sptr).elemtag;
        goto L212 ;
;
    }
    else if ((m==(i64)19)) {
        t = (*qq_decls$sptr).value;
        //dotype:
L212 :;
;
                {i64 $temp = (i64)qq_tables$ttbasetype[(t)];
if (($temp==(i64)7) || ($temp==(i64)10) || ($temp==(i64)16)) {
            a = qq_tables$ttlower[(t)];
            b = ((qq_tables$ttlength[(t)] + a) - (i64)1);
        }
        else {
            qq_lib$pcustype((byte*)"t.bounds",qq_decls$sptr);
        }
        };
    }
    else {
        qq_lib$pcustype((byte*)"Bounds",qq_decls$sptr);
    }
;
    if (!!(sx)) {
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        (*qq_decls$sptr).tagx = (i64)1;
        (*qq_decls$sptr).value = a;
        ++(qq_decls$sptr);
        (*qq_decls$sptr).tagx = (i64)1;
        (*qq_decls$sptr).value = b;
    }
    else {
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        (*qq_decls$sptr).tagx = (i64)6;
        (*qq_decls$sptr).dummy = msysc$m_setdotslice((*qq_decls$sptr).dummy,(i64)16,(i64)63,a);
        (*qq_decls$sptr).range_upper = (u64)b;
    }
;
}

void qq_khandlers$k_dictitems(void) {
        i64 n;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)9)) {
        n = (i64)(*(*qq_decls$sptr).objptr).dictitems;
    }
    else if (($temp==(i64)4)) {
        n = (*(*qq_decls$sptr).objptr).length;
    }
    else {
        qq_lib$pcustype((byte*)"Dictitems/digits",qq_decls$sptr);
    }
    };
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_isfound(void) {
    if (((i64)(*qq_decls$sptr).tag != (i64)1)) {
        qq_lib$pcerror((byte*)"isfound");
    }
;
    (*qq_decls$sptr).value = (i64)((*qq_decls$sptr).value != (i64)(-9223372036854775807-1));
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_append(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_append(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_concat(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_concat(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_appendto(void) {
        struct qq_decls$varrec *  px;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
        {i64 $temp = (i64)(*px).tag;
if (($temp==(i64)17)) {
        qq_vars$var_appendto((*px).varptr,y);
    }
    else {
        qq_lib$pcustype((byte*)"Appendto",px);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_concatto(void) {
        struct qq_decls$varrec *  px;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
        {i64 $temp = (i64)(*px).tag;
if (($temp==(i64)17)) {
        qq_vars$var_concatto((*px).varptr,y);
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
    }
    else {
        qq_lib$pcustype((byte*)"Concatto",px);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_addto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_addto(px,y)))) {
        qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_add,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_addmixed);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_subto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_sub,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_submixed);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_multo(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_multo(px,y)))) {
        qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_mul,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_mulmixed);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_divto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_div,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_divmixed);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_idivto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_idiv,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_idivmixed);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_iandto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_iandto(px,y)))) {
        qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_iand,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_iandmixed);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_iorto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_iorto(px,y)))) {
        qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_ior,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_iormixed);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_ixorto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_ixorto(px,y)))) {
        qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_ixor,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_ixormixed);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_shlto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_shlto(px,y)))) {
        qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_shl,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_shlmixed);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_shrto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_shrto(px,y)))) {
        qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_shr,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_shrmixed);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_copy(void) {
        struct qq_decls$varrec x;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        x = (*qq_decls$sptr);
        qq_vars$var_duplu(qq_decls$sptr);
        qq_vars$var_unshareu(&x);
        qq_decls$ppp = (*qq_decls$sptr).objptr;
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_dupl(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr) = (*(qq_decls$sptr - (i64)1));
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        ++((*(*qq_decls$sptr).objptr).refcount);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_makerange(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 lower;
        i64 upper;
    y = (qq_decls$sptr)--;
    x = qq_decls$sptr;
    if ((((i64)(*x).tag != (i64)1) || ((i64)(*y).tag != (i64)1))) {
        qq_lib$pcerror((byte*)"makerange/not int");
    }
;
    (*qq_decls$sptr).tagx = (i64)6;
    lower = (*x).value;
    upper = (*y).value;
    if (!((lower >= (i64)-281474976710656 && lower <= (i64)281474976710655))) {
        qq_lib$pcerror((byte*)"Range lwb bounds");
    }
;
    (*qq_decls$sptr).range_upper = (u64)upper;
    (*qq_decls$sptr).dummy = msysc$m_setdotslice((*qq_decls$sptr).dummy,(i64)16,(i64)63,lower);
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_makerangelen(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    x = qq_decls$sptr;
    if ((((i64)(*x).tag != (i64)1) || ((i64)(*y).tag != (i64)1))) {
        qq_lib$pcerror((byte*)"makerangelen/not int");
    }
;
    (*qq_decls$sptr).tagx = (i64)6;
    (*qq_decls$sptr).range_upper = (u64)(((*x).value + (*y).value) - (i64)1);
    (*qq_decls$sptr).dummy = msysc$m_setdotslice((*qq_decls$sptr).dummy,(i64)16,(i64)63,(*x).value);
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_makedecimal(void) {
        struct qq_decls$varrec x;
        struct qq_decls$objrec *  p;
    x = (*qq_decls$sptr);
    if (((i64)x.tag != (i64)12)) {
        qq_lib$pcerror((byte*)"Not str");
    }
;
    p = x.objptr;
    if (((*p).length == (i64)0)) {
        qq_lib$pcerror((byte*)"Null str");
    }
;
    qq_decimal$var_make_dec_str((*p).strptr,(*p).length,qq_decls$sptr);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    ++(qq_decls$pcptr);
}

static struct qq_decls$strec *qq_khandlers$resolvefield(i64 index,i64 rectype) {
        struct qq_decls$strec *  d;
        struct qq_decls$genfieldrec *  g;
    if ((index == (i64)0)) {
        qq_lib$pcerror((byte*)"Not a field");
    }
;
    g = (struct qq_decls$genfieldrec *)qq_decls$genfieldtable[(index)-1];
    L213 :;
    while (!!(g)) {
        d = (*g).def;
        if (((i64)(*(*d).owner).mode == rectype)) {
            return d;
        }
;
        g = (struct qq_decls$genfieldrec *)(*g).nextdef;
L214 :;
    }
L215 :;
    ;
    qq_lib$pcerror_s((byte*)"Can't resolve field:",(*d).name);
    return (struct qq_decls$strec *)0;
}

void qq_khandlers$k_pushptr(void) {
        struct qq_decls$varrec *  p;
    p = qq_decls$sptr;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)17)) {
        if (!(!!((*p).varptr))) {
            qq_lib$pcerror((byte*)"Nil^");
        }
;
        (*qq_decls$sptr) = (*(*p).varptr);
    }
    else if (($temp==(i64)24)) {
        if (!(!!((*p).ptr))) {
            qq_lib$pcerror((byte*)"Nil^");
        }
;
        qq_packed$var_loadpacked((*p).ptr,(i64)(*p).elemtag,qq_decls$sptr,0);
    }
    else if (($temp==(i64)18)) {
        qq_vars$var_loadbit((*p).ptr,(i64)(*p).bitoffset,(i64)(*p).elemtag,(i64)(*p).bitlength,qq_decls$sptr);
    }
    else {
        qq_lib$pcustype((byte*)"Pushptr",p);
    }
    };
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        ++((*(*qq_decls$sptr).objptr).refcount);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_popptr(void) {
        struct qq_decls$varrec *  p;
        struct qq_decls$varrec *  x;
    p = (qq_decls$sptr)--;
    x = (qq_decls$sptr)--;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)17)) {
        if (!!((i64)(*(*p).varptr).hasref)) {
            qq_vars$var_unshareu((*p).varptr);
        }
;
        (*(*p).varptr) = (*x);
    }
    else if (($temp==(i64)24)) {
        qq_packed$var_storepacked((*p).ptr,x,(i64)(*p).elemtag);
    }
    else if (($temp==(i64)18)) {
        qq_vars$var_storebit((*p).ptr,(i64)(*p).bitoffset,x,(i64)(*p).elemtag,(i64)(*p).bitlength);
    }
    else {
        qq_lib$pcustype((byte*)"Popptr",p);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_islist(void) {
    qq_khandlers$istype((i64)13,(i64)0);
}

void qq_khandlers$k_isarray(void) {
    qq_khandlers$istype((i64)14,(i64)0);
}

void qq_khandlers$k_isstring(void) {
    qq_khandlers$istype((i64)12,(i64)0);
}

void qq_khandlers$k_isrecord(void) {
    qq_khandlers$istype((i64)15,(i64)0);
}

void qq_khandlers$k_swap(void) {
        byte tempbuffer[1024];
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec v;
        i64 s;
        i64 t;
        i64 n;
        byte *  p;
        byte *  q;
        i64 a;
    x = (qq_decls$sptr)--;
    y = (qq_decls$sptr)--;
    if (((i64)(*x).tag != (i64)(*y).tag)) {
        qq_lib$pcerror((byte*)"Swap mismatch");
    }
;
        {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)17)) {
        v = (*(*x).varptr);
        (*(*x).varptr) = (*(*y).varptr);
        (*(*y).varptr) = v;
    }
    else if (($temp==(i64)24)) {
        s = (i64)(*x).elemtag;
        t = (i64)(*y).elemtag;
        if ((s != t)) {
            goto L216 ;
;
        }
;
        n = qq_tables$ttsize[(s)];
        if ((n==(i64)1)) {
            p = (*x).ptr;
            q = (*y).ptr;
            a = (i64)(*p);
            (*p) = (i64)(*q);
            (*q) = a;
        }
        else {
            if ((qq_tables$ttsize[(s)] <= (i64)1024)) {
                memcpy(&tempbuffer,(*x).ptr,(u64)n);
                memcpy((*x).ptr,(*y).ptr,(u64)n);
                memcpy((*y).ptr,&tempbuffer,(u64)n);
            }
            else {
                goto L216 ;
;
            }
;
        }
;
    }
    else {
        //swaperror:
L216 :;
;
        qq_lib$pcmxtypes((byte*)"Swap",x,y);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_jumptesteq(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 xt;
        i64 yt;
        i64 res;
    y = (qq_decls$sptr)--;
    x = qq_decls$sptr;
    xt = (i64)(*x).tag;
    yt = (i64)(*y).tag;
    if ((xt != yt)) {
                {i64 $temp = ((xt << (i64)16) | yt);
if (($temp==(i64)65542)) {
            if (!(((*x).value >= msysc$m_getdotslice((*y).dummy,(i64)16,(i64)63) && (*x).value <= (i64)(*y).range_upper))) {
                qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
                return;
            }
;
        }
        else if (($temp==(i64)65544)) {
            if (!(!!(qq_sets$var_in_set(x,y)))) {
                qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
                return;
            }
;
        }
        };
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
        --(qq_decls$sptr);
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
        return;
    }
;
    res = qq_vars$var_equal(x,y);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    if (!!(res)) {
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
        --(qq_decls$sptr);
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
        return;
    }
;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_jumptestne(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 xt;
        i64 yt;
        i64 res;
    y = (qq_decls$sptr)--;
    x = qq_decls$sptr;
    xt = (i64)(*x).tag;
    yt = (i64)(*y).tag;
    if ((xt != yt)) {
                {i64 $temp = ((xt << (i64)16) | yt);
if (($temp==(i64)65542)) {
            if (((*x).value >= msysc$m_getdotslice((*y).dummy,(i64)16,(i64)63) && (*x).value <= (i64)(*y).range_upper)) {
                --(qq_decls$sptr);
                qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
                return;
            }
;
        }
        else if (($temp==(i64)65544)) {
            if (!!(qq_sets$var_in_set(x,y))) {
                --(qq_decls$sptr);
                qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
                return;
            }
;
        }
        };
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
        return;
    }
;
    res = qq_vars$var_equal(x,y);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    if (!(!!(res))) {
        qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
        return;
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    --(qq_decls$sptr);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_jump(void) {
    qq_decls$pcptr = (i64 *)(*(qq_decls$pcptr + (i64)1));
}

void qq_khandlers$k_jumpptr(void) {
        struct qq_decls$strec *  d;
    if (((i64)(*qq_decls$sptr).tag != (i64)23)) {
        qq_lib$pcerror((byte*)"symbol expected");
    }
;
    d = (*qq_decls$sptr).def;
    ++(qq_decls$sptr);
    if (((i64)(*d).nameid != (i64)15)) {
        qq_lib$pcerror((byte*)"label expected");
    }
;
    if (!(!!((i64)(*d).procfixed))) {
        (*d).pcaddress = (qq_decls$moduletable[((i64)(*d).moduleno)].pcstart + (*d).labelno);
        (*d).procfixed = (i64)1;
    }
;
    qq_decls$pcptr = (*d).pcaddress;
}

void qq_khandlers$k_incr(void) {
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1)) {
        ++((*qq_decls$sptr).value);
    }
    else {
        qq_lib$pcustype((byte*)"incr",qq_decls$sptr);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_decr(void) {
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1)) {
        --((*qq_decls$sptr).value);
    }
    else {
        qq_lib$pcustype((byte*)"decr",qq_decls$sptr);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_chr(void) {
    if (((i64)(*qq_decls$sptr).tag == (i64)1)) {
        qq_strings$var_makechar((*qq_decls$sptr).value,qq_decls$sptr);
    }
    else {
        qq_lib$pcustype((byte*)"CHR",qq_decls$sptr);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_asc(void) {
        i64 c;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)12)) {
        if (!!((*(*qq_decls$sptr).objptr).length)) {
            c = (i64)(u64)(*(*(*qq_decls$sptr).objptr).strptr);
        }
        else {
            c = (i64)0;
        }
;
        qq_vars$var_unshareu(qq_decls$sptr);
        (*qq_decls$sptr).tagx = (i64)1;
        (*qq_decls$sptr).value = c;
    }
    else {
        qq_lib$pcustype((byte*)"ASC",qq_decls$sptr);
    }
    };
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_pusht(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)19;
    (*qq_decls$sptr).value = (*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_type(void) {
        i64 t;
    t = (i64)(*qq_decls$sptr).tag;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)19;
    (*qq_decls$sptr).value = t;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_basetype(void) {
        i64 t;
    t = (i64)(*qq_decls$sptr).tag;
    if ((t==(i64)15) || (t==(i64)16) || (t==(i64)10)) {
        t = (i64)qq_tables$ttbasetype[((i64)(*(*qq_decls$sptr).objptr).usertag)];
    }
    else if ((t==(i64)7)) {
        t = (i64)qq_tables$ttbasetype[((i64)(*qq_decls$sptr).elemtag)];
    }
;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)19;
    (*qq_decls$sptr).value = t;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_usertype(void) {
        i64 t;
    t = (i64)(*qq_decls$sptr).tag;
    if ((t==(i64)15) || (t==(i64)16) || (t==(i64)10)) {
        t = (i64)(*(*qq_decls$sptr).objptr).usertag;
    }
    else if ((t==(i64)7)) {
        t = (i64)(*qq_decls$sptr).elemtag;
    }
;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)19;
    (*qq_decls$sptr).value = t;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_elemtype(void) {
        i64 t;
    t = (i64)(*qq_decls$sptr).tag;
    if ((t==(i64)14) || (t==(i64)11)) {
        t = (i64)(*(*qq_decls$sptr).objptr).elemtag;
    }
    else if ((t==(i64)24) || (t==(i64)17) || (t==(i64)18) || (t==(i64)7)) {
        t = (i64)(*qq_decls$sptr).elemtag;
    }
    else if ((t==(i64)8)) {
        t = (i64)35;
    }
    else if ((t==(i64)10)) {
        t = (i64)qq_tables$tttarget[((i64)(*(*qq_decls$sptr).objptr).usertag)];
    }
    else {
        qq_lib$pcustype_t((byte*)"elemtype",t);
    }
;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)19;
    (*qq_decls$sptr).value = t;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_nop(void) {
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_modulecall(void) {
        struct qq_decls$strec *  d;
        i64 moduleno;
    d = (struct qq_decls$strec *)(*(qq_decls$pcptr + (i64)1));
    moduleno = (i64)(*d).moduleno;
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)21;
    (*qq_decls$sptr).retaddr = (qq_decls$pcptr + (i64)2);
    qq_decls$pcptr = qq_decls$moduletable[(moduleno)].pcstart;
}

void qq_khandlers$k_modulereturn(void) {
    qq_decls$pcptr = (*qq_decls$sptr).retaddr;
    --(qq_decls$sptr);
}

void qq_khandlers$k_maxvalue(void) {
        i64 a;
    if (((i64)(*qq_decls$sptr).tag == (i64)19)) {
        (*qq_decls$sptr).tag = (*qq_decls$sptr).value;
    }
;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)31)) {
        a = (i64)255;
    }
    else if (($temp==(i64)32)) {
        a = (i64)65536;
    }
    else if (($temp==(i64)33)) {
        a = (i64)4294967295;
    }
    else if (($temp==(i64)2) || ($temp==(i64)2)) {
        a = (i64)-1;
    }
    else if (($temp==(i64)28)) {
        a = (i64)127;
    }
    else if (($temp==(i64)29)) {
        a = (i64)32767;
    }
    else if (($temp==(i64)30)) {
        a = (i64)2147483647;
    }
    else if (($temp==(i64)1) || ($temp==(i64)1)) {
        a = (i64)9223372036854775807;
    }
    else {
        qq_lib$pcustype((byte*)"MAXVALUE",qq_decls$sptr);
    }
    };
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = a;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_minvalue(void) {
        i64 a;
    if (((i64)(*qq_decls$sptr).tag == (i64)19)) {
        (*qq_decls$sptr).tag = (*qq_decls$sptr).value;
    }
;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)2) || ($temp==(i64)31) || ($temp==(i64)32) || ($temp==(i64)33) || ($temp==(i64)2)) {
        a = (i64)0;
    }
    else if (($temp==(i64)28)) {
        a = (i64)-128;
    }
    else if (($temp==(i64)29)) {
        a = (i64)-32768;
    }
    else if (($temp==(i64)30)) {
        a = (i64)-2147483648;
    }
    else if (($temp==(i64)1) || ($temp==(i64)1)) {
        a = (i64)(-9223372036854775807-1);
    }
    else {
        qq_lib$pcustype((byte*)"MINVALUE",qq_decls$sptr);
    }
    };
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = a;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_callhost(void) {
        i64 n;
    n = (*(qq_decls$pcptr + (i64)1));
    qq_host$callhostfunction(n);
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_expand(void) {
        struct qq_decls$varrec *  dest;
        i64 n;
    n = (*(qq_decls$pcptr + (i64)1));
    dest = ((qq_decls$sptr + n) - (i64)1);
    qq_vars$var_expand(qq_decls$sptr,dest,n);
    qq_decls$sptr = dest;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushsymbol(void) {
        struct qq_decls$strec *  d;
    d = (struct qq_decls$strec *)(*(qq_decls$pcptr + (i64)1));
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)23;
    (*qq_decls$sptr).def = (struct qq_decls$strec *)(*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_eq(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 res;
    y = qq_decls$sptr;
    x = --(qq_decls$sptr);
    res = qq_vars$var_equal(x,y);
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    (*qq_decls$sptr).tagx = (i64)5;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_ne(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 res;
    y = qq_decls$sptr;
    x = --(qq_decls$sptr);
    res = (i64)!(!!(qq_vars$var_equal(x,y)));
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    (*qq_decls$sptr).tagx = (i64)5;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_lt(void) {
    qq_khandlers$do_cmp((i64)183);
}

void qq_khandlers$k_le(void) {
    qq_khandlers$do_cmp((i64)184);
}

void qq_khandlers$k_ge(void) {
    qq_khandlers$do_cmp((i64)185);
}

void qq_khandlers$k_gt(void) {
    qq_khandlers$do_cmp((i64)186);
}

static void qq_khandlers$do_cmp(i64 opc) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 res;
    y = qq_decls$sptr;
    x = --(qq_decls$sptr);
    res = qq_vars$var_compare(x,y);
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    (*qq_decls$sptr).tagx = (i64)5;
    if ((opc==(i64)183)) {
        (*qq_decls$sptr).value = (i64)(res < (i64)0);
    }
    else if ((opc==(i64)184)) {
        (*qq_decls$sptr).value = (i64)(res <= (i64)0);
    }
    else if ((opc==(i64)185)) {
        (*qq_decls$sptr).value = (i64)(res >= (i64)0);
    }
    else {
        (*qq_decls$sptr).value = (i64)(res > (i64)0);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_calldll(void) {
        struct qq_decls$strec *  d;
        i64 nargs;
    d = (struct qq_decls$strec *)(*(qq_decls$pcptr + (i64)1));
    nargs = (*(qq_decls$pcptr + (i64)2));
    qq_calldll$calldll(d,((qq_decls$sptr - nargs) + (i64)1),(qq_decls$sptr - nargs),nargs);
    qq_decls$sptr -= nargs;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)3);
}

void qq_khandlers$k_in(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 n;
    y = qq_decls$sptr;
    x = --(qq_decls$sptr);
    n = qq_vars$var_in(x,y);
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_notin(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 n;
    y = qq_decls$sptr;
    x = --(qq_decls$sptr);
    n = (i64)!(!!(qq_vars$var_in(x,y)));
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_inx(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 n;
    y = qq_decls$sptr;
    x = --(qq_decls$sptr);
    n = qq_vars$var_inx(x,y);
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_convrefpack(void) {
        struct qq_decls$varrec *  a;
        i64 elemtype;
        void *  p;
        struct qq_decls$objrec *  pa;
    switch ((i64)(*qq_decls$sptr).tag) {
    case 17:;
        {
            a = (*qq_decls$sptr).varptr;
            pa = (*a).objptr;
            switch ((i64)(*a).tag) {
            case 1:;
            case 2:;
            case 24:;
                {
                    p = &(*a).value;
                    elemtype = (i64)1;
                }
                break;
            case 3:;
                {
                    p = &(*a).value;
                    elemtype = (i64)3;
                }
                break;
            case 14:;
                {
                    p = (*pa).ptr;
                    elemtype = (i64)(*pa).elemtag;
                }
                break;
            case 11:;
                {
                    (*qq_decls$sptr).ptr = (*pa).ptr;
                    (*qq_decls$sptr).bitoffset = ((i64)(*pa).indexoffset * (i64)qq_tables$ttbitwidth[((i64)(*pa).elemtag)]);
                    (*qq_decls$sptr).bitlength = (i64)0;
                    (*qq_decls$sptr).tagx = (i64)18;
                    (*qq_decls$sptr).elemtag = (i64)(*pa).elemtag;
                    ++(qq_decls$pcptr);
                    return;
                }
                break;
            case 8:;
                {
                    (*qq_decls$sptr).ptr = (*pa).ptr;
                    (*qq_decls$sptr).bitoffset = (i64)0;
                    (*qq_decls$sptr).bitlength = (i64)0;
                    (*qq_decls$sptr).tagx = (i64)18;
                    (*qq_decls$sptr).elemtag = (i64)35;
                    ++(qq_decls$pcptr);
                    return;
                }
                break;
            case 12:;
                {
                    p = (void *)(*pa).strptr;
                    elemtype = (i64)31;
                    if ((p == 0)) {
                        p = (byte*)"";
                    }
;
                }
                break;
            case 16:;
                {
                    p = (*pa).ptr;
                    elemtype = (i64)(*pa).usertag;
                }
                break;
            case 10:;
                {
                    p = (*pa).ptr;
                    elemtype = (i64)(*pa).usertag;
                }
                break;
            case 4:;
                {
                    p = (*pa).num;
                    elemtype = (i64)30;
                }
                break;
            default: {
                qq_lib$pcustype((byte*)"Getrefpack1",a);
            }
            } //SW
;
        }
        break;
    case 24:;
    case 18:;
        {
            ++(qq_decls$pcptr);
            return;
        }
        break;
    default: {
        qq_lib$pcustype((byte*)"Getrefpack2",qq_decls$sptr);
    }
    } //SW
;
    //done:
L217 :;
;
    (*qq_decls$sptr).tagx = (i64)24;
    (*qq_decls$sptr).ptr = (byte *)p;
    (*qq_decls$sptr).elemtag = elemtype;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_isdef(void) {
        i64 res;
    res = (i64)((i64)(*qq_decls$sptr).tag != (i64)0);
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_isvoid(void) {
        i64 res;
    res = (i64)((i64)(*qq_decls$sptr).tag == (i64)0);
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_isint(void) {
    qq_khandlers$istype((i64)1,(i64)2);
}

void qq_khandlers$k_isnumber(void) {
        i64 res;
    if (((i64)(*qq_decls$sptr).tag == (i64)1 || (i64)(*qq_decls$sptr).tag == (i64)3 || (i64)(*qq_decls$sptr).tag == (i64)4 || (i64)(*qq_decls$sptr).tag == (i64)2)) {
        res = (i64)1;
    }
    else {
        res = (i64)0;
    }
;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_ismutable(void) {
        i64 res;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        res = (i64)msysc$m_getdotindex((i64)(*(*qq_decls$sptr).objptr).flags,(i64)1);
    }
    else {
        res = (i64)1;
    }
;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_isreal(void) {
    qq_khandlers$istype((i64)3,(i64)0);
}

void qq_khandlers$k_isrange(void) {
    qq_khandlers$istype((i64)6,(i64)0);
}

void qq_khandlers$k_isset(void) {
    qq_khandlers$istype((i64)8,(i64)0);
}

void qq_khandlers$k_ispointer(void) {
    qq_khandlers$istype((i64)17,(i64)24);
}

static void qq_khandlers$istype(i64 t1,i64 t2) {
        i64 res;
        i64 t;
    t = (i64)(*qq_decls$sptr).tag;
    res = (i64)(t == t1);
    if ((!(!!(res)) && !!(t2))) {
        res = (i64)(t == t2);
    }
;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_convert(void) {
        struct qq_decls$varrec x;
        i64 t;
    t = (*(qq_decls$pcptr + (i64)1));
    if (((i64)(*qq_decls$sptr).tag != t)) {
        x = (*qq_decls$sptr);
        qq_vars$var_convert(&x,t,qq_decls$sptr);
        if (!!((i64)x.hasref)) {
            qq_vars$var_unshareu(&x);
        }
;
    }
;
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_switch(void) {
        i64 index;
        i64 n;
        i64 lower;
    n = (*(qq_decls$pcptr + (i64)1));
    lower = (*(qq_decls$pcptr + (i64)2));
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1) || ($temp==(i64)19)) {
    }
    else {
        qq_lib$pcerror_s((byte*)"switch not int",qq_tables$ttname[((i64)(*qq_decls$sptr).tag)]);
    }
    };
    index = ((*qq_decls$sptr).value - lower);
    --(qq_decls$sptr);
    if (((u64)index >= (u64)n)) {
        qq_decls$pcptr = (i64 *)(*((qq_decls$pcptr + (n * (i64)2)) + (i64)4));
    }
    else {
        qq_decls$pcptr = (i64 *)(*((qq_decls$pcptr + (index * (i64)2)) + (i64)4));
    }
;
}

void qq_khandlers$k_bytesize(void) {
        i64 n;
        i64 t;
        struct qq_decls$objrec *  p;
    p = (*qq_decls$sptr).objptr;
    t = (i64)(*qq_decls$sptr).tag;
    if ((t==(i64)19)) {
        t = (*qq_decls$sptr).value;
    }
    else if ((t==(i64)16) || (t==(i64)15) || (t==(i64)10)) {
        t = (i64)(*(*qq_decls$sptr).objptr).usertag;
    }
;
    if ((t==(i64)14)) {
        n = ((*p).length * qq_tables$ttsize[((i64)(*p).elemtag)]);
    }
    else if ((t==(i64)8)) {
        n = qq_bits$getbitssize((*p).length,(i64)35);
    }
    else if ((t==(i64)12)) {
        n = (*p).length;
    }
    else if ((t==(i64)11)) {
        n = qq_bits$bits_bytesize(p);
    }
    else if ((t==(i64)13) || (t==(i64)9)) {
        n = ((*p).length * (i64)16);
    }
    else if ((t==(i64)15) || (t==(i64)16) || (t==(i64)10)) {
        n = qq_tables$ttsize[(t)];
    }
    else if ((t==(i64)4)) {
        n = (*p).length;
        if (!!(n)) {
            n = (n * (i64)4);
        }
;
    }
    else {
        n = qq_tables$ttsize[(t)];
    }
;
    if (!!((i64)(*qq_decls$sptr).hasref)) {
        qq_vars$var_unshareu(qq_decls$sptr);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = n;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_bitwidth(void) {
    if (((i64)(*qq_decls$sptr).tag == (i64)19)) {
        (*qq_decls$sptr).value = (i64)qq_tables$ttbitwidth[((*qq_decls$sptr).value)];
    }
    else if (!!((i64)qq_tables$ttbitwidth[((i64)(*qq_decls$sptr).tag)])) {
        (*qq_decls$sptr).value = (i64)qq_tables$ttbitwidth[((i64)(*qq_decls$sptr).tag)];
    }
    else {
        qq_lib$pcerror((byte*)"bitwidth");
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_min(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    x = qq_decls$sptr;
    if ((qq_vars$var_compare(x,y) < (i64)0)) {
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
    }
    else {
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
        (*qq_decls$sptr) = (*y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_max(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
    y = (qq_decls$sptr)--;
    x = qq_decls$sptr;
    if ((qq_vars$var_compare(x,y) >= (i64)0)) {
        if (!!((i64)(*y).hasref)) {
            qq_vars$var_unshareu(y);
        }
;
    }
    else {
        if (!!((i64)(*x).hasref)) {
            qq_vars$var_unshareu(x);
        }
;
        (*qq_decls$sptr) = (*y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_addsp(void) {
    qq_decls$sptr -= (*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_pushtry(void) {
    (*++(qq_decls$sptr)).tagx = (i64)22;
    (*qq_decls$sptr).ptr = (byte *)(*(qq_decls$pcptr + (i64)1));
    (*qq_decls$sptr).frameoffset = (qq_decls$frameptr - (byte *)qq_decls$sptr);
    (*qq_decls$sptr).exceptiontype = (*(qq_decls$pcptr + (i64)2));
    (*qq_decls$sptr).nexceptions = (*(qq_decls$pcptr + (i64)3));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)4);
}

void qq_khandlers$k_raise(void) {
    if (((i64)(*qq_decls$sptr).tag != (i64)1)) {
        qq_lib$pcerror((byte*)"Raise: not Int on stack [not proceeding direct to RAISE]");
    }
;
    qq_decls$pcptr = qq_lib$raiseexception((*qq_decls$sptr).value);
}

void qq_khandlers$k_isequal(void) {
        struct qq_decls$varrec *  x;
        struct qq_decls$varrec *  y;
        i64 res;
    y = (qq_decls$sptr)--;
    x = qq_decls$sptr;
    if (((!!((i64)(*x).hasref) && !!((i64)(*y).hasref)) && ((*x).objptr == (*y).objptr))) {
        res = (i64)1;
    }
    else {
        res = (i64)0;
    }
;
    if (!!((i64)(*x).hasref)) {
        qq_vars$var_unshareu(x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    (*qq_decls$sptr).tagx = (i64)1;
    (*qq_decls$sptr).value = res;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_minto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_minto(px,y)))) {
        qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_min,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_minmixed);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_maxto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    if (!(!!(qq_vars$var_maxto(px,y)))) {
        qq_vars$var_inplace(px,y,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_max,(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))qq_vars$var_maxmixed);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_power(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec x;
    y = (qq_decls$sptr)--;
    x = (*qq_decls$sptr);
    qq_vars$var_power(qq_decls$sptr,y);
    if (!!((i64)x.hasref)) {
        qq_vars$var_unshareu(&x);
    }
;
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

static void qq_khandlers$domaths(i64 opcode) {
    switch ((i64)(*qq_decls$sptr).tag) {
    case 1:;
        {
            (*qq_decls$sptr).tagx = (i64)3;
            (*qq_decls$sptr).xvalue = qq_khandlers$getmaths(opcode,(r64)(*qq_decls$sptr).value);
        }
        break;
    case 3:;
        {
            (*qq_decls$sptr).xvalue = qq_khandlers$getmaths(opcode,(*qq_decls$sptr).xvalue);
        }
        break;
    default: {
        qq_lib$pcustype((byte*)"Maths:",qq_decls$sptr);
    }
    } //SW
;
    ++(qq_decls$pcptr);
}

static r64 qq_khandlers$getmaths(i64 opcode,r64 x) {
    switch (opcode) {
    case 108:;
        {
            return sqrt(x);
        }
        break;
    case 111:;
        {
            return sin(x);
        }
        break;
    case 112:;
        {
            return cos(x);
        }
        break;
    case 113:;
        {
            return tan(x);
        }
        break;
    case 114:;
        {
            return asin(x);
        }
        break;
    case 115:;
        {
            return acos(x);
        }
        break;
    case 116:;
        {
            return atan(x);
        }
        break;
    case 118:;
        {
            return log(x);
        }
        break;
    case 119:;
        {
            return log10(x);
        }
        break;
    case 121:;
        {
            return exp(x);
        }
        break;
    case 122:;
        {
            if ((x >= (double)0.)) {
                return floor((x + (double)0.5));
            }
            else {
                return ceil((x - (double)0.5));
            }
;
        }
        break;
    case 123:;
        {
            return floor(x);
        }
        break;
    case 124:;
        {
            x = ceil(x);
            if ((x == (double)0.)) {
                x = (double)0.;
            }
;
            return ceil(x);
        }
        break;
    default: {
        qq_lib$pcerror_s((byte*)"Maths",qq_tables$pclnames[(opcode)]);
    }
    } //SW
;
    return (double)0.;
}

void qq_khandlers$k_typepun(void) {
    (*qq_decls$sptr).tagx = (*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_andlto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
        struct qq_decls$varrec *  x;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    x = (*px).varptr;
    if ((((i64)(*px).tag != (i64)17) || ((i64)(*x).tag != (i64)1))) {
        qq_lib$pcerror((byte*)"andlto");
    }
;
    (*x).value &= qq_vars$var_istruel(y);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_orlto(void) {
        struct qq_decls$varrec *  y;
        struct qq_decls$varrec *  px;
        struct qq_decls$varrec *  x;
    y = (qq_decls$sptr)--;
    px = (qq_decls$sptr)--;
    x = (*px).varptr;
    if ((((i64)(*px).tag != (i64)17) || ((i64)(*x).tag != (i64)1))) {
        qq_lib$pcerror((byte*)"orlto");
    }
;
    (*x).value |= qq_vars$var_istruel(y);
    if (!!((i64)(*y).hasref)) {
        qq_vars$var_unshareu(y);
    }
;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_notlto(void) {
        struct qq_decls$varrec *  px;
        struct qq_decls$varrec *  x;
    px = (qq_decls$sptr)--;
    x = (*px).varptr;
    if ((((i64)(*px).tag != (i64)17) || ((i64)(*x).tag != (i64)1))) {
        qq_lib$pcerror((byte*)"notlto");
    }
;
    (*x).value ^= (i64)1;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_pushoperator(void) {
    ++(qq_decls$sptr);
    (*qq_decls$sptr).tagx = (i64)20;
    (*qq_decls$sptr).value = (*(qq_decls$pcptr + (i64)1));
    qq_decls$pcptr = (qq_decls$pcptr + (i64)2);
}

void qq_khandlers$k_maps(void) {
    qq_khandlers$k_mapss();
}

void qq_khandlers$k_mapss(void) {
        static i64 codeseq[10];
        i64 nargs;
        i64 $av_1;
        i64 i;
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)20)) {
        codeseq[((i64)1)-1] = (i64)qq_tables$cmdmap[((*qq_decls$sptr).value)];
        --(qq_decls$sptr);
        codeseq[((i64)2)-1] = (*(qq_decls$pcptr + (i64)1));
        codeseq[((i64)3)-1] = (*(qq_decls$pcptr + (i64)2));
    }
    else if (($temp==(i64)23)) {
        nargs = (((*qq_decls$pcptr) == (i64)qq_tables$cmdmap[((i64)224)]) ? (i64)1 : (i64)2);
                ($av_1 = -((nargs + (i64)1)));
        for (i=(i64)0;i>=$av_1;--i) {
L218 :;
            (*((qq_decls$sptr + i) + (i64)1)) = (*(qq_decls$sptr + i));
L219 :;
        }
L220 :;
        ;
        (*(qq_decls$sptr - nargs)).tagx = (i64)0;
        ++(qq_decls$sptr);
        codeseq[((i64)1)-1] = (i64)qq_tables$cmdmap[((i64)64)];
        codeseq[((i64)2)-1] = nargs;
        codeseq[((i64)3)-1] = (i64)0;
        codeseq[((i64)4)-1] = (*(qq_decls$pcptr + (i64)1));
        codeseq[((i64)5)-1] = (*(qq_decls$pcptr + (i64)2));
    }
    else {
        qq_lib$pcerror((byte*)"Apply:no op");
    }
    };
    qq_decls$pcptr = &codeseq[((i64)1)-1];
}

void qq_khandlers$k_idivrem(void) {
    qq_lib$pcerror((byte*)"IDIVREM");
}

void qq_khandlers$k_odd(void) {
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1) || ($temp==(i64)2)) {
        (*qq_decls$sptr).value = (i64)msysc$m_getdotindex((*qq_decls$sptr).value,(i64)0);
    }
    else {
        qq_lib$pcustype((byte*)"Odd",qq_decls$sptr);
    }
    };
    (*qq_decls$sptr).tagx = (i64)1;
    ++(qq_decls$pcptr);
}

void qq_khandlers$k_even(void) {
        {i64 $temp = (i64)(*qq_decls$sptr).tag;
if (($temp==(i64)1) || ($temp==(i64)2)) {
        (*qq_decls$sptr).value = (i64)!(msysc$m_getdotindex((*qq_decls$sptr).value,(i64)0));
    }
    else {
        qq_lib$pcustype((byte*)"Even",qq_decls$sptr);
    }
    };
    (*qq_decls$sptr).tagx = (i64)1;
    ++(qq_decls$pcptr);
}

// START
void qq_khandlers$start(void) {

}

void qq_host$callhostfunction(i64 hostfn) {
        void (*fnaddr)(void);
        i64 nparams;
        i64 isfn;
        i64 $av_1;
    fnaddr = (void (*)(void))qq_host$hosttable[(hostfn)];
    nparams = (i64)qq_tables$hostnparams[(hostfn)];
    isfn = (i64)qq_tables$hostisfn[(hostfn)];
    if ((fnaddr == 0)) {
        qq_lib$pcerror_s((byte*)"Hostfn not implemented:",qq_tables$hostfnnames[(hostfn)]);
    }
;
    switch ((nparams + isfn)) {
    case 0:;
        {
            ((*(void (*)(void))fnaddr))();
        }
        break;
    case 1:;
        {
            ((*(void (*)(struct qq_decls$varrec *))fnaddr))(qq_decls$sptr);
        }
        break;
    case 2:;
        {
            ((*(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *))fnaddr))(qq_decls$sptr,(qq_decls$sptr - (i64)1));
        }
        break;
    case 3:;
        {
            ((*(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,struct qq_decls$varrec *))fnaddr))(qq_decls$sptr,(qq_decls$sptr - (i64)1),(qq_decls$sptr - (i64)2));
        }
        break;
    case 4:;
        {
            ((*(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,struct qq_decls$varrec *,struct qq_decls$varrec *))fnaddr))(qq_decls$sptr,(qq_decls$sptr - (i64)1),(qq_decls$sptr - (i64)2),(qq_decls$sptr - (i64)3));
        }
        break;
    case 5:;
        {
            ((*(void (*)(struct qq_decls$varrec *,struct qq_decls$varrec *,struct qq_decls$varrec *,struct qq_decls$varrec *,struct qq_decls$varrec *))fnaddr))(qq_decls$sptr,(qq_decls$sptr - (i64)1),(qq_decls$sptr - (i64)2),(qq_decls$sptr - (i64)3),(qq_decls$sptr - (i64)4));
        }
        break;
    default: {
        qq_lib$pcerror((byte*)"callhost/proc");
    }
    } //SW
;
    $av_1 = nparams;
    while ($av_1-- > 0) {
L221 :;
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            if (!!((i64)(*qq_decls$sptr).hasref)) {
                qq_vars$var_unshareu(qq_decls$sptr);
            }
;
        }
;
        --(qq_decls$sptr);
L222 :;
    }
L223 :;
    ;
}

void qq_host$inithostlib(void) {
        u8 *  name;
        i64 n;
        i64 i;
        i64 k;
    n = msysc$m_get_nprocs();
    for (i=(i64)1;i<=n;++i) {
L224 :;
        name = msysc$m_get_procname(i);
        if (!!(mlib$eqbytes((void *)name,(byte*)"pch_",(i64)4))) {
            for (k=(i64)0;k<=(i64)77;++k) {
L227 :;
                if (!!(mlib$eqstring((name + (i64)4),(qq_tables$hostfnnames[(k)] + (i64)5)))) {
                    qq_host$hosttable[(k)] = (void (*)(void))msysc$m_get_procaddr(i);
                    goto L229 ;
                }
;
L228 :;
            }
            {
                qq_lib$loaderror((byte*)"Unknown hostfn",name,(byte*)"");
            }
L229 :;
            ;
        }
;
L225 :;
    }
L226 :;
    ;
}

static void qq_host$pch_leftstr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result) {
        i64 n;
        i64 length;
        i64 padchar;
        u8 *  s;
        struct qq_decls$objrec *  pa;
    padchar = (i64)32;
        {i64 $temp = (i64)(*c).tag;
if (($temp==(i64)0)) {
    }
    else if (($temp==(i64)12)) {
        if (((*(*c).objptr).length == (i64)1)) {
            padchar = (i64)(u64)(*(*(*c).objptr).strptr);
        }
        else {
            qq_lib$pcerror((byte*)"left/padx");
        }
;
    }
    else if (($temp==(i64)1)) {
        padchar = (*c).value;
    }
    else {
        qq_lib$pcerror((byte*)"left/pad?");
    }
    };
        {i64 $temp = (i64)(*b).tag;
if (($temp==(i64)0)) {
        n = (i64)1;
    }
    else if (($temp==(i64)1)) {
        n = (*b).value;
    }
    else {
        qq_lib$pcerror((byte*)"left:bad n");
    }
    };
    if (((i64)(*a).tag != (i64)12)) {
        qq_lib$pcerror((byte*)"left:not str");
    }
;
    pa = (*a).objptr;
    length = (*pa).length;
    s = (*pa).strptr;
    if ((n == (i64)0)) {
        qq_strings$var_empty_string(result,(i64)1);
        return;
    }
;
    (*result).tagx = (i64)268;
    if ((n > (i64)0)) {
        if ((n <= length)) {
            qq_host$leftstring(a,n,result);
        }
        else {
            qq_host$padstring_right(a,n,padchar,result);
        }
;
    }
    else {
        n = -(n);
        if ((n < length)) {
            qq_host$leftstring(a,(length - n),result);
        }
        else {
            qq_strings$var_empty_string(result,(i64)1);
        }
;
    }
;
}

static void qq_host$pch_rightstr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result) {
        i64 n;
        i64 length;
        i64 padchar;
        u8 *  s;
        struct qq_decls$objrec *  pa;
    padchar = (i64)32;
        {i64 $temp = (i64)(*c).tag;
if (($temp==(i64)0)) {
    }
    else if (($temp==(i64)12)) {
        if (((*(*c).objptr).length == (i64)1)) {
            padchar = (i64)(u64)(*(*(*c).objptr).strptr);
        }
        else {
            qq_lib$pcerror((byte*)"right/padx");
        }
;
    }
    else if (($temp==(i64)1)) {
        padchar = (*c).value;
    }
    else {
        qq_lib$pcerror((byte*)"right/pad?");
    }
    };
        {i64 $temp = (i64)(*b).tag;
if (($temp==(i64)0)) {
        n = (i64)1;
    }
    else if (($temp==(i64)1)) {
        n = (*b).value;
    }
    else {
        qq_lib$pcerror((byte*)"right:bad n");
    }
    };
    pa = (*a).objptr;
    if (((i64)(*a).tag != (i64)12)) {
        qq_lib$pcerror((byte*)"right:not str");
    }
;
    length = (*pa).length;
    s = (*pa).strptr;
    (*result).tagx = (i64)268;
    if ((n == (i64)0)) {
        qq_strings$var_empty_string(result,(i64)1);
        return;
    }
;
    if ((n > (i64)0)) {
        if ((n <= length)) {
            qq_host$rightstring(a,n,result);
        }
        else {
            qq_host$padstring_left(a,n,padchar,result);
        }
;
    }
    else {
        n = -(n);
        if ((n < length)) {
            qq_host$rightstring(a,(length - n),result);
        }
        else {
            qq_strings$var_empty_string(result,(i64)1);
        }
;
    }
;
}

static void qq_host$pch_convlc(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result) {
    qq_host$checkparam(a,(i64)12,(i64)-999999);
    (*result) = (*a);
    ++((*(*result).objptr).refcount);
    qq_vars$var_duplu(result);
    qq_strings$var_iconvcase(result,b,(i64)0);
}

static void qq_host$pch_convuc(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result) {
    qq_host$checkparam(a,(i64)12,(i64)-999999);
    (*result) = (*a);
    ++((*(*result).objptr).refcount);
    if (!!((i64)(*result).hasref)) {
        if (!!((i64)(*result).hasref)) {
            qq_vars$var_duplu(result);
        }
;
    }
;
    qq_strings$var_iconvcase(result,b,(i64)1);
}

static void qq_host$pch_waitkey(struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = mwindows$os_getch();
}

static void qq_host$pch_execwait(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result) {
        u8 *  workdir;
        i64 flag;
        struct qq_decls$objrec *  pa;
    qq_host$checkparam(a,(i64)12,(i64)-999999);
    pa = (*a).objptr;
    flag = qq_host$checkparam(b,(i64)1,(i64)0);
    if (((i64)(*c).tag == (i64)0)) {
        workdir = 0;
    }
    else {
        qq_host$checkparam(c,(i64)12,(i64)-999999);
        workdir = qq_lib$convtostringz((*(*c).objptr).strptr,(*(*c).objptr).length);
    }
;
    (*result).tagx = (i64)1;
    (*result).value = mwindows$os_execwait(qq_lib$convtostringz((*pa).strptr,(*pa).length),flag,workdir);
}

static void qq_host$pch_execcmd(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *result) {
        u8 *  workdir;
        i64 flag;
        struct qq_decls$objrec *  pa;
    qq_host$checkparam(a,(i64)12,(i64)-999999);
    pa = (*a).objptr;
    flag = qq_host$checkparam(b,(i64)1,(i64)0);
    if (((i64)(*c).tag == (i64)0)) {
        workdir = 0;
    }
    else {
        qq_host$checkparam(c,(i64)12,(i64)-999999);
        workdir = qq_lib$convtostringz((*(*c).objptr).strptr,(*(*c).objptr).length);
    }
;
    (*result).tagx = (i64)1;
    (*result).value = mwindows$os_execcmd(qq_lib$convtostringz((*pa).strptr,(*pa).length),flag);
}

static void qq_host$pch_makestr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result) {
        i64 n;
    switch ((i64)(*a).tag) {
    case 24:;
        {
        }
        break;
    case 1:;
        {
        }
        break;
    default: {
        qq_lib$pcerror((byte*)"makestr");
    }
    } //SW
;
    n = qq_vars$var_getintvalue(b);
    (*result).tagx = (i64)268;
    (*result).objptr = qq_strings$obj_make_strslicexobj((u8 *)(*a).ptr,n);
}

static void qq_host$pch_makeref(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result) {
        byte *  ptr;
    switch ((i64)qq_tables$ttbasetype[((i64)(*a).tag)]) {
    case 17:;
    case 24:;
    case 1:;
        {
            ptr = (*a).ptr;
        }
        break;
    case 12:;
    case 14:;
    case 13:;
    case 8:;
        {
            ptr = (*(*a).objptr).ptr;
        }
        break;
    default: {
        qq_lib$pcerror((byte*)"makeref");
    }
    } //SW
;
    (*result).tagx = (i64)24;
    (*result).ptr = ptr;
    (*result).elemtag = qq_vars$var_getintvalue(b);
        {i64 $temp = (i64)(*result).elemtag;
if (($temp==(i64)35) || ($temp==(i64)36) || ($temp==(i64)37)) {
        (*result).tag = (i64)18;
        (*result).bitoffset = (i64)0;
        (*result).bitlength = (i64)0;
    }
    };
}

static void qq_host$pch_getcmdparam(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
        i64 n;
    if (((i64)(*a).tag == (i64)0)) {
        (*result).tagx = (i64)1;
        (*result).value = qq_decls$nqparams;
        return;
    }
;
    n = qq_vars$var_getintvalue(a);
    if (!((n >= (i64)1 && n <= qq_decls$nqparams))) {
        qq_lib$pcerror((byte*)"getcmdpm");
    }
;
    qq_strings$var_make_string(qq_decls$qparamtable[(n)-1],result,(i64)0);
}

static void qq_host$pch_clock(struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = mwindows$os_clock();
}

static void qq_host$pch_allocexec(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
        i64 n;
        byte *  p;
    n = qq_vars$var_getintvalue(a);
    p = mwindows$os_allocexecmem(n);
    (*result).tagx = (i64)24;
    (*result).ptr = p;
    (*result).elemtag = (i64)31;
}

static void qq_host$pch_runnative(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result) {
        i64 (*fnptr)(i64);
    if (((i64)(*a).tag != (i64)24)) {
        qq_lib$pcerror((byte*)"runnative?");
    }
;
    fnptr = (i64 (*)(i64))(*a).ptr;
    (*result).value = ((*fnptr))((*b).value);
    (*result).tagx = (i64)1;
}

static void qq_host$pch_setlwb(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 n;
        struct qq_decls$objrec *  p;
    if (!(!!((i64)(*a).hasref))) {
        goto L230 ;
;
    }
;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"not mutable");
    }
;
    n = qq_host$checkparam(b,(i64)1,(i64)-999999);
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)13)) {
        if (!((n >= (i64)-32768 && n <= (i64)32767))) {
            qq_lib$pcerror((byte*)"lwb not i16");
        }
;
        (*p).lower16 = n;
    }
    else if (($temp==(i64)14) || ($temp==(i64)11)) {
        if (!((n >= (i64)0 && n <= (i64)1))) {
            qq_lib$pcerror((byte*)"lwb not 0/1");
        }
;
        (*p).flags = msysc$m_setdotindex((*p).flags,(i64)0,(u64)n);
    }
    else {
        //error:
L230 :;
;
        qq_lib$pcerror((byte*)"Can't set lwb");
    }
    };
}

static void qq_host$pch_ticks(struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = mwindows$os_ticks();
}

static void qq_host$pch_sleep(struct qq_decls$varrec *a) {
    qq_host$checkparam(a,(i64)1,(i64)-999999);
    mwindows$os_sleep((*a).value);
}

static void qq_host$pch_random(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
        i64 n;
        i64 x;
    (*result).tagx = (i64)1;
    if (((i64)(*a).tag == (i64)6)) {
        x = mlib$mrandomrange(msysc$m_getdotslice((*a).dummy,(i64)16,(i64)63),(i64)(*a).range_upper);
    }
    else {
        qq_host$checkparam(a,(i64)1,(i64)-999999);
        n = (*a).value;
        if ((n > (i64)1)) {
            x = mlib$mrandomint(n);
        }
        else if ((n == (i64)0)) {
            x = (i64)mlib$mrandom();
        }
        else if ((n == (i64)1)) {
            (*result).tagx = (i64)3;
            (*result).xvalue = mlib$mrandomreal();
            return;
        }
        else {
            mlib$mseed((u64)-(n),(u64)0u);
            x = (i64)0;
        }
;
    }
;
    (*result).value = x;
}

static void qq_host$pch_system(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    qq_host$checkparam(a,(i64)12,(i64)-999999);
    (*result).tagx = (i64)1;
    (*result).value = system(qq_lib$convtostringz((*(*a).objptr).strptr,(*(*a).objptr).length));
}

static void qq_host$pch_$getparam(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    qq_host$checkparam(a,(i64)1,(i64)-999999);
    (*result) = (*(struct qq_decls$varrec *)(qq_decls$frameptr - ((*a).value * (i64)16)));
    if (!!((i64)(*result).hasref)) {
        ++((*(*result).objptr).refcount);
    }
;
}

static i64 qq_host$checkparam(struct qq_decls$varrec *p,i64 tag,i64 defaultx) {
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)0)) {
        if ((defaultx == (i64)-999999)) {
            qq_lib$pcerror((byte*)"Missing host param");
        }
;
        return defaultx;
    }
    else if (($temp==tag)) {
        return (*p).value;
    }
    };
    if ((tag == (i64)1)) {
                {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)3)) {
            return (i64)(*p).xvalue;
        }
        };
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str(qq_tables$ttname[((i64)(*p).tag)],NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    qq_lib$pcerror((byte*)"Host param wrong type");
    return (i64)0;
}

static void qq_host$leftstring(struct qq_decls$varrec *a,i64 n,struct qq_decls$varrec *result) {
    qq_strings$var_make_stringn((*(*a).objptr).strptr,n,result,(i64)1);
}

static void qq_host$rightstring(struct qq_decls$varrec *a,i64 n,struct qq_decls$varrec *result) {
    qq_strings$var_make_stringn(((*(*a).objptr).strptr + ((*(*a).objptr).length - n)),n,result,(i64)1);
}

static void qq_host$padstring_right(struct qq_decls$varrec *a,i64 n,i64 fillchar,struct qq_decls$varrec *result) {
        u8 *  s;
        i64 length;
        i64 $av_1;
    length = (*(*a).objptr).length;
    qq_strings$var_new_stringn(n,result);
    s = (*(*result).objptr).strptr;
    if (!!(length)) {
        memcpy((void *)s,(void *)(*(*a).objptr).strptr,(u64)length);
        s += length;
    }
;
    $av_1 = (n - length);
    while ($av_1-- > 0) {
L231 :;
        (*s) = (u64)fillchar;
        ++(s);
L232 :;
    }
L233 :;
    ;
}

static void qq_host$padstring_left(struct qq_decls$varrec *a,i64 n,i64 fillchar,struct qq_decls$varrec *result) {
        u8 *  s;
        i64 length;
        i64 padlen;
        i64 $av_1;
    length = (*(*a).objptr).length;
    padlen = (n - length);
    qq_strings$var_make_stringn(0,n,result,(i64)0);
    s = (*(*result).objptr).strptr;
    s += padlen;
    if (!!(length)) {
        memcpy((void *)s,(void *)(*(*a).objptr).strptr,(u64)length);
    }
;
    $av_1 = padlen;
    while ($av_1-- > 0) {
L234 :;
        --(s);
        (*s) = (u64)fillchar;
L235 :;
    }
L236 :;
    ;
}

static void qq_host$getbounds(struct qq_decls$varrec *p,struct qq_host$dimrec *dims,i64 lower) {
        i64 n;
    if (!(!!(p))) {
        qq_lib$pcerror((byte*)"New: no bounds");
    }
;
    switch ((i64)(*p).tag) {
    case 0:;
        {
            (*dims).lbound = lower;
            (*dims).upper = (i64)0;
            (*dims).length = (i64)0;
        }
        break;
    case 6:;
        {
            (*dims).lbound = msysc$m_getdotslice((*p).dummy,(i64)16,(i64)63);
            (*dims).upper = (i64)(*p).range_upper;
            (*dims).length = (((i64)(*p).range_upper - msysc$m_getdotslice((*p).dummy,(i64)16,(i64)63)) + (i64)1);
            if (((*dims).length < (i64)0)) {
                (*dims).length = (i64)0;
                (*dims).upper = ((*dims).lbound - (i64)1);
            }
;
        }
        break;
    default: {
        n = qq_vars$var_getintvalue(p);
        (*dims).lbound = lower;
        (*dims).upper = ((*dims).length = n);
    }
    } //SW
;
}

static void qq_host$pch_new(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *c,struct qq_decls$varrec *d,struct qq_decls$varrec *result) {
        struct qq_decls$varrec v;
        i64 t;
        i64 offset;
        i64 elemtype;
        i64 usertag;
        struct qq_host$dimrec dims;
        byte *  qbyte;
        struct qq_decls$objrec *  p;
        i64 $av_1;
        i64 $av_2;
    t = qq_vars$var_getintvalue(a);
    if (((t < (i64)0) || (t > qq_tables$ntypes))) {
        qq_lib$pcustype_t((byte*)"New:bad type",t);
    }
;
    v.tagx = (t | (i64)256);
    usertag = (i64)0;
    switch ((i64)qq_tables$ttbasetype[(t)]) {
    case 12:;
        {
            qq_strings$var_new_string(b,c,result);
            return;
        }
        break;
    case 13:;
        {
            qq_host$getbounds(b,&dims,(i64)1);
            p = qq_lists$obj_newlist(dims.length,dims.lbound,c);
            v.objptr = p;
        }
        break;
    case 14:;
        {
            elemtype = qq_vars$var_getintvalue(b);
            qq_host$getbounds(c,&dims,(i64)1);
            if (((elemtype >= (i64)35) && (elemtype <= (i64)37))) {
                v.tag = (t = (i64)11);
                goto L237 ;
;
            }
;
            p = qq_arrays$obj_newarray(elemtype,dims.lbound,dims.length);
            //doarray2:
L238 :;
;
            v.objptr = p;
            if (!!(dims.length)) {
                if ((!!(d) && ((i64)(*d).tag != (i64)0))) {
                    qbyte = (*p).ptr;
                    $av_1 = dims.length;
                    while ($av_1-- > 0) {
L239 :;
                        qq_packed$var_storepacked(qbyte,d,elemtype);
                        qbyte += qq_tables$ttsize[(elemtype)];
L240 :;
                    }
L241 :;
                    ;
                }
;
            }
;
        }
        break;
    case 10:;
        {
            usertag = t;
            v.tag = (i64)10;
            elemtype = (i64)qq_tables$tttarget[(t)];
            dims.length = qq_tables$ttlength[(t)];
            dims.lbound = qq_tables$ttlower[(t)];
            dims.upper = ((dims.length + dims.lbound) - (i64)1);
            d = b;
            p = qq_arrays$obj_newarray_u(t);
            goto L238 ;
;
        }
        break;
    case 11:;
        {
            elemtype = qq_vars$var_getintvalue(b);
            if (!((elemtype >= (i64)35 && elemtype <= (i64)37))) {
                qq_lib$pcerror((byte*)"new: bad bits elem");
            }
;
            qq_host$getbounds(c,&dims,(i64)1);
            //dobits2:
L237 :;
;
            p = qq_bits$obj_newbits(elemtype,dims.lbound,dims.length);
            v.objptr = p;
            if (!!(dims.length)) {
                if ((!!(d) && ((i64)(*d).tag != (i64)0))) {
                    qbyte = (*p).ptr;
                    offset = (i64)0;
                    $av_2 = dims.length;
                    while ($av_2-- > 0) {
L242 :;
                        qq_vars$var_storebit(qbyte,offset,d,elemtype,(i64)0);
                        offset += (i64)qq_tables$ttbitwidth[(elemtype)];
                        if ((offset >= (i64)8)) {
                            offset = (i64)0;
                            ++(qbyte);
                        }
;
L243 :;
                    }
L244 :;
                    ;
                }
;
            }
;
        }
        break;
    case 8:;
        {
            qq_host$getbounds(b,&dims,(i64)0);
            if ((dims.lbound < (i64)0)) {
                qq_lib$pcerror((byte*)"new:set:lwb");
            }
;
            if ((dims.lbound != (i64)0)) {
                dims.lbound = (i64)0;
                dims.length = (dims.upper + (i64)1);
            }
;
            p = qq_sets$obj_newset(dims.length);
            v.objptr = p;
        }
        break;
    case 15:;
        {
            p = qq_records$obj_new_record(t,b);
            qq_vars$var_fromobj(t,p,&v);
            v.tag = (i64)15;
            usertag = t;
        }
        break;
    case 16:;
        {
            p = qq_packed$obj_new_struct(t);
            qq_vars$var_objtovar(t,p,&v);
            v.tag = (i64)16;
            usertag = t;
            if ((!!(b) && ((i64)(*b).tag != (i64)0))) {
                qq_lib$pcerror((byte*)"New: struct init");
            }
;
        }
        break;
    case 1:;
    case 2:;
    case 3:;
    case 17:;
        {
            v.value = (i64)0;
            v.hasref = (i64)0;
            if ((!!(b) && ((i64)(*b).tag != (i64)0))) {
                qq_lib$pcerror((byte*)"NEW(int/value)");
            }
;
        }
        break;
    case 9:;
        {
            qq_host$getbounds(b,&dims,(i64)1);
            if ((dims.lbound != (i64)1)) {
                qq_lib$pcerror((byte*)"new:dict:lwb");
            }
;
            p = qq_dicts$obj_new_dict(dims.length);
            v.objptr = p;
        }
        break;
    case 4:;
        {
            qq_decimal$var_empty_dec(result);
            return;
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"new",t);
    }
    } //SW
;
    //finish:
L245 :;
;
    if (!!(usertag)) {
        (*v.objptr).usertag = usertag;
    }
;
    (*result) = v;
}

void qq_host$pch_gethostname(struct qq_decls$varrec *result) {
        static u8 name[256];
    strcpy(name,mwindows$os_gethostname());
    qq_strings$var_make_string(name,result,(i64)0);
}

void qq_host$pch_getprogname(struct qq_decls$varrec *result) {
        static u8 name[256];
    strcpy(name,qqcli$inputfile);
    qq_strings$var_make_string(name,result,(i64)0);
}

static void qq_host$pch_$test(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
        struct qq_decls$objrec *  p;
    p = (*a).objptr;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"$TEST:",NULL);
    msysc$m_print_str((byte*)"A=",NULL);
    msysc$m_print_ptr(a,NULL);
    msysc$m_print_str((byte*)"A.OBJPTR=",NULL);
    msysc$m_print_ptr((*a).objptr,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    (*result).tagx = (i64)0;
}

static void qq_host$pch_$test2(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    (*result).tagx = (i64)0;
}

static void qq_host$pch_$refcount(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    if (!!((i64)(*a).hasref)) {
        (*result).value = (i64)(*(*a).objptr).refcount;
    }
    else {
        (*result).value = (i64)0;
    }
;
}

static void qq_host$pch_testkey(struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = mwindows$os_kbhit();
}

static void qq_host$pch_getos(struct qq_decls$varrec *result) {
    qq_strings$var_make_string(mwindows$os_getos(),result,(i64)0);
}

static void qq_host$pch_$procsymbols(struct qq_decls$varrec *result) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  q;
        struct qq_decls$procrec *  pp;
        i64 $av_1;
    p = qq_lists$obj_newlist(qq_decls$nproclist,(i64)1,0);
    q = (*p).varptr;
    pp = (struct qq_decls$procrec *)qq_decls$proclist;
    $av_1 = qq_decls$nproclist;
    while ($av_1-- > 0) {
L246 :;
        (*q).tagx = (i64)23;
        (*q).def = (*pp).def;
        ++(q);
        pp = (struct qq_decls$procrec *)(*pp).nextproc;
L247 :;
    }
L248 :;
    ;
    (*result).tagx = (i64)269;
    (*result).objptr = p;
}

static void qq_host$pch_$symbolowner(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    qq_host$checkparam(a,(i64)23,(i64)-999999);
    (*result).tagx = (i64)23;
    (*result).def = (*(*a).def).owner;
}

static void qq_host$pch_$symbolname(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    qq_host$checkparam(a,(i64)23,(i64)-999999);
    qq_strings$var_make_string((*(*a).def).name,result,(i64)0);
}

static void qq_host$pch_$symboldefs(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  q;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
        i64 n;
        i64 $av_1;
    qq_host$checkparam(a,(i64)23,(i64)-999999);
    d = (*a).def;
    e = (*d).deflist;
    n = (i64)0;
    L249 :;
    while (!!(e)) {
        ++(n);
        e = (*e).nextdef;
L250 :;
    }
L251 :;
    ;
    p = qq_lists$obj_newlist(n,(i64)1,0);
    q = (*p).varptr;
    e = (*d).deflist;
    $av_1 = n;
    while ($av_1-- > 0) {
L252 :;
        (*q).tagx = (i64)23;
        (*q).def = e;
        ++(q);
        e = (*e).nextdef;
L253 :;
    }
L254 :;
    ;
    (*result).tagx = (i64)269;
    (*result).objptr = p;
}

void qq_host$pch_setmesshandler(struct qq_decls$varrec *fn) {
    if ((((i64)(*fn).tag != (i64)23) || ((i64)(*(*fn).def).nameid != (i64)5))) {
        qq_lib$pcerror((byte*)"Not proc ref");
    }
;
    qq_decls$pcl_callbackfn = (void (*)(void))(*(*fn).def).pcaddress;
    mwindows$os_setmesshandler(&qqcli$runproc_m);
}

static void qq_host$pch_$testcallback(void) {
        struct qq_decls$varrec v;
    v.tagx = (i64)1;
    v.value = (i64)123456;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"TEST CALLBACK ????",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

static void qq_host$pch_$smallmemtotal(struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = (mlib$smallmemtotal / (i64)16);
}

static void qq_host$pch_$id(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = (*a).value;
}

void qq_host$pch_iswindows(struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = mwindows$os_iswindows();
}

static void qq_host$pch_$setdebug(struct qq_decls$varrec *a) {
    qq_host$checkparam(a,(i64)1,(i64)-999999);
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"SETDEBUG.................",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlib$fdebug = (*a).value;
}

static void qq_host$pch_copy(struct qq_decls$varrec *a,struct qq_decls$varrec *dest) {
    (*dest) = (*a);
    if (!!((i64)(*dest).hasref)) {
        qq_vars$var_duplu(dest);
    }
;
}

static void qq_host$pch_gethash(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    (*result).tagx = (i64)1;
    (*result).value = qq_vars$var_gethashvalue(a);
}

static void qq_host$pch_makeempty(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
        struct qq_decls$objrec *  p;
        i64 t;
    t = (i64)qq_tables$ttbasetype[((i64)(*a).tag)];
    if ((t == (i64)19)) {
        t = (*a).value;
    }
;
    p = (*a).objptr;
    if ((t==(i64)13)) {
        qq_lists$var_empty_list((i64)(*p).lower16,result);
        return;
    }
    else if ((t==(i64)12)) {
        p = qq_strings$emptystring;
        ++((*p).refcount);
    }
    else if ((t==(i64)14)) {
        qq_arrays$var_empty_array(t,(i64)(*p).elemtag,(i64)msysc$m_getdotindex((i64)(*p).flags,(i64)0),result);
        return;
    }
    else {
        qq_lib$pcustype_t((byte*)"makeempty?",t);
    }
;
    (*result).tagx = (t | (i64)256);
    (*result).objptr = p;
}

static void qq_host$pch_$infinity(struct qq_decls$varrec *dest) {
    qq_decimal$var_setinf(dest);
}

static void qq_host$pch_$nan(struct qq_decls$varrec *dest) {
    qq_decimal$var_setnan(dest);
}

void qq_host$setcmdparam(i64 index,u8 *s) {
    if ((s == 0)) {
        qq_decls$nqparams = index;
    }
    else if ((index <= (i64)32)) {
        qq_decls$qparamtable[(index)-1] = mlib$pcm_copyheapstring(s);
        qq_decls$nqparams=(qq_decls$nqparams>index?qq_decls$nqparams:index);
;
    }
;
}

static void qq_host$pch_makeiter(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    qq_iterators$var_make_iter(a,result);
}

static void qq_host$pch_checkiter(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    qq_iterators$var_check_iter(a,result);
}

static void qq_host$pch_nextiter(struct qq_decls$varrec *a,struct qq_decls$varrec *result) {
    qq_iterators$var_next_iter(a,result);
}

// START
void qq_host$start(void) {

}

void qq_lex$lexreadtoken(void) {
        i64 c;
        i64 hsum;
        i64 commentseen;
    qq_decls$nextlx.subcode = (i64)0;
    L255 :;
    switch ((qq_lex$lxstart = qq_lex$lxsptr, (i64)(u64)(*(qq_lex$lxsptr)++))) {
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 36:;
    case 95:;
        {
            //dolower:
L257 :;
;
            qq_decls$nextlx.svalue = (qq_lex$lxsptr - (i64)1);
            //doname:
L258 :;
;
            hsum = (i64)(u64)(*qq_decls$nextlx.svalue);
            L259 :;
            switch ((c = (i64)(u64)(*(qq_lex$lxsptr)++))) {
            case 65:;
            case 66:;
            case 67:;
            case 68:;
            case 69:;
            case 70:;
            case 71:;
            case 72:;
            case 73:;
            case 74:;
            case 75:;
            case 76:;
            case 77:;
            case 78:;
            case 79:;
            case 80:;
            case 81:;
            case 82:;
            case 83:;
            case 84:;
            case 85:;
            case 86:;
            case 87:;
            case 88:;
            case 89:;
            case 90:;
                {
                    (*(qq_lex$lxsptr - (i64)1)) = (u64)(c + (i64)32);
                    hsum = ((((hsum << (i64)4) - hsum) + c) + (i64)32);
                }
                break;
            case 97:;
            case 98:;
            case 99:;
            case 100:;
            case 101:;
            case 102:;
            case 103:;
            case 104:;
            case 105:;
            case 106:;
            case 107:;
            case 108:;
            case 109:;
            case 110:;
            case 111:;
            case 112:;
            case 113:;
            case 114:;
            case 115:;
            case 116:;
            case 117:;
            case 118:;
            case 119:;
            case 120:;
            case 121:;
            case 122:;
            case 48:;
            case 49:;
            case 50:;
            case 51:;
            case 52:;
            case 53:;
            case 54:;
            case 55:;
            case 56:;
            case 57:;
            case 95:;
            case 36:;
                {
                    hsum = (((hsum << (i64)4) - hsum) + c);
                }
                break;
            default: {
                --(qq_lex$lxsptr);
                goto L260 ;
            }
            } //SW
goto L259 ;
L260 :;
            ;
            qq_lex$lookup(qq_decls$nextlx.svalue,(qq_lex$lxsptr - qq_decls$nextlx.svalue),(((hsum << (i64)5) - hsum) & (i64)65535));
            return;
        }
        break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
        {
            //doupper:
L261 :;
;
            qq_decls$nextlx.svalue = (qq_lex$lxsptr - (i64)1);
            (*qq_decls$nextlx.svalue) += (u8)(i64)32;
            goto L258 ;
;
        }
        break;
    case 102:;
        {
            if (((u64)(*qq_lex$lxsptr) != '"')) {
                goto L257 ;
;
            }
;
            qq_lex$readrawstring();
            return;
        }
        break;
    case 70:;
        {
            if (((u64)(*qq_lex$lxsptr) != '"')) {
                goto L261 ;
;
            }
;
            qq_lex$readrawstring();
            return;
        }
        break;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        {
                        {u64 $temp = (u64)(*qq_lex$lxsptr);
if (($temp==')') || ($temp==(u64)13u) || ($temp==',') || ($temp==' ')) {
                qq_decls$nextlx.symbol = (i64)79;
                qq_decls$nextlx.subcode = (i64)1;
                qq_decls$nextlx.value = (i64)((u64)(*qq_lex$lxstart) - '0');
            }
            else if (($temp=='x') || ($temp=='X')) {
                                {u64 $temp = (u64)(*qq_lex$lxstart);
if (($temp=='0')) {
                    ++(qq_lex$lxsptr);
                    qq_lex$readhex();
                }
                else if (($temp=='2')) {
                    ++(qq_lex$lxsptr);
                    qq_lex$readbin();
                }
                else {
                    qq_lib$lxerror((byte*)"Bad base");
                }
                };
            }
            else {
                --(qq_lex$lxsptr);
                qq_lex$readdec();
            }
            };
            return;
        }
        break;
    case 33:;
        {
            //docomment:
L262 :;
;
            L263 :;
            switch ((c = (i64)(u64)(*(qq_lex$lxsptr)++))) {
            case 13:;
                {
                    ++(qq_lex$lxsptr);
                    goto L264 ;
                }
                break;
            case 10:;
                {
                    goto L264 ;
                }
                break;
            case 26:;
            case 0:;
                {
                    --(qq_lex$lxsptr);
                    goto L264 ;
                }
                break;
            } //SW
goto L263 ;
L264 :;
            ;
            qq_decls$nextlx.symbol = (i64)75;
            return;
        }
        break;
    case 35:;
        {
            qq_decls$nextlx.svalue = qq_lex$lxsptr;
            L265 :;
            switch ((c = (i64)(u64)(*(qq_lex$lxsptr)++))) {
            case 13:;
            case 10:;
            case 26:;
            case 0:;
                {
                    --(qq_lex$lxsptr);
                    goto L266 ;
                }
                break;
            } //SW
goto L265 ;
L266 :;
            ;
            qq_lex$nextlxlength = (qq_lex$lxsptr - qq_decls$nextlx.svalue);
            qq_decls$nextlx.symbol = (i64)78;
            return;
        }
        break;
    case 92:;
        {
            commentseen = (i64)0;
            L267 :;
            switch ((i64)(u64)(*(qq_lex$lxsptr)++)) {
            case 13:;
                {
                    ++(qq_lex$lxsptr);
                    goto L268 ;
                }
                break;
            case 10:;
                {
                    goto L268 ;
                }
                break;
            case 26:;
            case 0:;
                {
                    qq_decls$nextlx.symbol = (i64)76;
                    --(qq_lex$lxsptr);
                    return;
                }
                break;
            case 32:;
            case 9:;
                {
                }
                break;
            case 33:;
                {
                    commentseen = (i64)1;
                }
                break;
            default: {
                if (!(!!(commentseen))) {
                    qq_lib$lxerror((byte*)"\\ not followed by eol");
                }
;
            }
            } //SW
goto L267 ;
L268 :;
            ;
            L269 :;
            switch ((i64)(u64)(*(qq_lex$lxsptr)++)) {
            case 13:;
                {
                    ++(qq_lex$lxsptr);
                }
                break;
            case 10:;
                {
                }
                break;
            case 32:;
            case 9:;
                {
                }
                break;
            default: {
                --(qq_lex$lxsptr);
                goto L270 ;
            }
            } //SW
goto L269 ;
L270 :;
            ;
        }
        break;
    case 123:;
        {
            qq_decls$nextlx.symbol = (i64)17;
            return;
        }
        break;
    case 125:;
        {
            qq_decls$nextlx.symbol = (i64)18;
            return;
        }
        break;
    case 46:;
        {
            switch ((i64)(u64)(*qq_lex$lxsptr)) {
            case 46:;
                {
                    ++(qq_lex$lxsptr);
                    if (((u64)(*qq_lex$lxsptr) == '.')) {
                        ++(qq_lex$lxsptr);
                        qq_decls$nextlx.symbol = (i64)30;
                    }
                    else {
                        qq_decls$nextlx.symbol = (i64)29;
                        qq_decls$nextlx.subcode = (i64)195;
                    }
;
                    return;
                }
                break;
            case 48:;
            case 49:;
            case 50:;
            case 51:;
            case 52:;
            case 53:;
            case 54:;
            case 55:;
            case 56:;
            case 57:;
                {
                    --(qq_lex$lxsptr);
                    qq_lex$readreal();
                    return;
                }
                break;
            default: {
                qq_decls$nextlx.symbol = (i64)2;
                return;
            }
            } //SW
;
        }
        break;
    case 44:;
        {
            qq_decls$nextlx.symbol = (i64)5;
            return;
        }
        break;
    case 59:;
        {
            qq_decls$nextlx.symbol = (i64)6;
            return;
        }
        break;
    case 58:;
        {
            switch ((i64)(u64)(*qq_lex$lxsptr)) {
            case 61:;
                {
                    ++(qq_lex$lxsptr);
                    qq_decls$nextlx.symbol = (i64)9;
                    qq_decls$nextlx.subcode = (i64)2;
                }
                break;
            case 58:;
                {
                    ++(qq_lex$lxsptr);
                                        {u64 $temp = (u64)(*qq_lex$lxsptr);
if (($temp=='=')) {
                        ++(qq_lex$lxsptr);
                        qq_decls$nextlx.symbol = (i64)10;
                        qq_decls$nextlx.subcode = (i64)3;
                    }
                    else {
                        qq_decls$nextlx.symbol = (i64)8;
                    }
                    };
                }
                break;
            default: {
                qq_decls$nextlx.symbol = (i64)7;
            }
            } //SW
;
            return;
        }
        break;
    case 40:;
        {
            qq_decls$nextlx.symbol = (i64)13;
            return;
        }
        break;
    case 41:;
        {
            qq_decls$nextlx.symbol = (i64)14;
            return;
        }
        break;
    case 91:;
        {
            qq_decls$nextlx.symbol = (i64)15;
            return;
        }
        break;
    case 93:;
        {
            qq_decls$nextlx.symbol = (i64)16;
            return;
        }
        break;
    case 124:;
        {
            if (((u64)(*qq_lex$lxsptr) == '|')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)21;
            }
            else {
                qq_decls$nextlx.symbol = (i64)20;
            }
;
            return;
        }
        break;
    case 94:;
        {
            qq_decls$nextlx.symbol = (i64)19;
            qq_decls$nextlx.subcode = (i64)68;
            return;
        }
        break;
    case 64:;
        {
            if (((u64)(*qq_lex$lxsptr) == '@')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)23;
            }
            else {
                qq_decls$nextlx.symbol = (i64)22;
            }
;
            return;
        }
        break;
    case 63:;
        {
            qq_decls$nextlx.symbol = (i64)24;
            return;
        }
        break;
    case 126:;
        {
            qq_decls$nextlx.symbol = (i64)28;
            return;
        }
        break;
    case 43:;
        {
            qq_decls$nextlx.symbol = (i64)32;
            if (((u64)(*qq_lex$lxsptr) == '+')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)73;
                qq_decls$nextlx.subcode = (i64)85;
                return;
            }
            else {
                qq_decls$nextlx.subcode = (i64)149;
            }
;
            return;
        }
        break;
    case 45:;
        {
            qq_decls$nextlx.symbol = (i64)33;
                        {u64 $temp = (u64)(*qq_lex$lxsptr);
if (($temp=='-')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)73;
                qq_decls$nextlx.subcode = (i64)86;
                return;
            }
            else if (($temp=='>')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)12;
            }
            else {
                qq_decls$nextlx.subcode = (i64)150;
            }
            };
            return;
        }
        break;
    case 42:;
        {
            qq_decls$nextlx.symbol = (i64)34;
            if (((u64)(*qq_lex$lxsptr) == '*')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)54;
                qq_decls$nextlx.subcode = (i64)177;
            }
            else {
                qq_decls$nextlx.subcode = (i64)151;
            }
;
            return;
        }
        break;
    case 47:;
        {
            qq_decls$nextlx.symbol = (i64)35;
            qq_decls$nextlx.subcode = (i64)152;
            return;
        }
        break;
    case 37:;
        {
            qq_decls$nextlx.symbol = (i64)36;
            qq_decls$nextlx.subcode = (i64)153;
            return;
        }
        break;
    case 61:;
        {
                        {u64 $temp = (u64)(*qq_lex$lxsptr);
if (($temp=='>')) {
                qq_decls$nextlx.symbol = (i64)11;
                ++(qq_lex$lxsptr);
            }
            else if (($temp=='=')) {
                qq_decls$nextlx.symbol = (i64)61;
                qq_decls$nextlx.subcode = (i64)146;
                ++(qq_lex$lxsptr);
            }
            else {
                qq_decls$nextlx.symbol = (i64)55;
                qq_decls$nextlx.subcode = (i64)167;
            }
            };
            return;
        }
        break;
    case 60:;
        {
            switch ((i64)(u64)(*qq_lex$lxsptr)) {
            case 61:;
                {
                    ++(qq_lex$lxsptr);
                    qq_decls$nextlx.symbol = (i64)58;
                    qq_decls$nextlx.subcode = (i64)170;
                }
                break;
            case 62:;
                {
                    ++(qq_lex$lxsptr);
                    qq_decls$nextlx.symbol = (i64)56;
                    qq_decls$nextlx.subcode = (i64)168;
                }
                break;
            case 60:;
                {
                    ++(qq_lex$lxsptr);
                    qq_decls$nextlx.symbol = (i64)44;
                    qq_decls$nextlx.subcode = (i64)159;
                }
                break;
            default: {
                qq_decls$nextlx.symbol = (i64)57;
                qq_decls$nextlx.subcode = (i64)169;
            }
            } //SW
;
            return;
        }
        break;
    case 62:;
        {
            switch ((i64)(u64)(*qq_lex$lxsptr)) {
            case 61:;
                {
                    ++(qq_lex$lxsptr);
                    qq_decls$nextlx.symbol = (i64)59;
                    qq_decls$nextlx.subcode = (i64)171;
                }
                break;
            case 62:;
                {
                    ++(qq_lex$lxsptr);
                    qq_decls$nextlx.symbol = (i64)45;
                    qq_decls$nextlx.subcode = (i64)160;
                }
                break;
            default: {
                qq_decls$nextlx.symbol = (i64)60;
                qq_decls$nextlx.subcode = (i64)172;
            }
            } //SW
;
            return;
        }
        break;
    case 38:;
        {
                        {u64 $temp = (u64)(*qq_lex$lxsptr);
if (($temp=='&')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)26;
                qq_decls$nextlx.subcode = (i64)175;
            }
            else if (($temp=='.')) {
                ++(qq_lex$lxsptr);
                qq_decls$nextlx.symbol = (i64)4;
            }
            else {
                qq_decls$nextlx.symbol = (i64)25;
                qq_decls$nextlx.subcode = (i64)67;
            }
            };
            return;
        }
        break;
    case 39:;
        {
            qq_lex$lxreadstring((i64)39);
            return;
        }
        break;
    case 34:;
        {
            qq_lex$lxreadstring((i64)34);
            return;
        }
        break;
    case 96:;
        {
            qq_lex$readrawxname();
            return;
        }
        break;
    case 32:;
    case 9:;
        {
        }
        break;
    case 13:;
        {
            ++(qq_lex$lxsptr);
            qq_decls$nextlx.symbol = (i64)75;
            return;
        }
        break;
    case 10:;
        {
            qq_decls$nextlx.symbol = (i64)75;
            return;
        }
        break;
    case 26:;
    case 0:;
        {
            qq_decls$nextlx.symbol = (i64)76;
            --(qq_lex$lxsptr);
            return;
        }
        break;
    default: {
        qq_decls$nextlx.symbol = (i64)1;
        qq_decls$nextlx.value = c;
        return;
    }
    } //SW
goto L255 ;
L256 :;
    ;
}

static void qq_lex$lxreadstring(i64 termchar) {
        u8 *  dest;
        u8 *  pstart;
        i64 c;
        i64 d;
        i64 length;
        i64 hasescape;
        u8 str[8];
        i64 $av_1;
    if ((termchar == (i64)34)) {
        qq_decls$nextlx.symbol = (i64)84;
    }
    else {
        qq_decls$nextlx.symbol = (i64)82;
        qq_decls$nextlx.subcode = (i64)1;
    }
;
    pstart = qq_lex$lxsptr;
    length = (i64)0;
    hasescape = (i64)0;
    L271 :;
    switch ((c = (i64)(u64)(*(qq_lex$lxsptr)++))) {
    case 92:;
        {
            c = (i64)(u64)(*qq_lex$lxsptr);
            if ((c >= (i64)65 && c <= (i64)90)) {
                c += (i64)32;
            }
;
            ++(qq_lex$lxsptr);
            hasescape = (i64)1;
            switch (c) {
            case 97:;
            case 98:;
            case 99:;
            case 114:;
            case 102:;
            case 108:;
            case 110:;
            case 115:;
            case 116:;
            case 118:;
            case 121:;
            case 122:;
            case 48:;
            case 34:;
            case 113:;
            case 92:;
            case 39:;
                {
                    ++(length);
                }
                break;
            case 119:;
                {
                    length += (i64)2;
                }
                break;
            case 120:;
                {
                    qq_lex$lxsptr += (i64)2;
                    ++(length);
                }
                break;
            default: {
                qq_lib$lxerror((byte*)"Bad str escape");
            }
            } //SW
;
        }
        break;
    case 34:;
    case 39:;
        {
            if ((c == termchar)) {
                if (((i64)(u64)(*qq_lex$lxsptr) == c)) {
                    hasescape = (i64)1;
                    ++(qq_lex$lxsptr);
                    ++(length);
                }
                else {
                    goto L272 ;
                }
;
            }
            else {
                ++(length);
            }
;
        }
        break;
    case 13:;
    case 10:;
    case 0:;
        {
            qq_lib$lxerror((byte*)"String not terminated");
        }
        break;
    default: {
        ++(length);
    }
    } //SW
goto L271 ;
L272 :;
    ;
    qq_lex$nextlxlength = length;
    if ((length == (i64)0)) {
        qq_decls$nextlx.svalue = (byte*)"";
        return;
    }
    else if (!(!!(hasescape))) {
        qq_decls$nextlx.svalue = mlib$pcm_copyheapstringn(pstart,length);
        return;
    }
;
    qq_decls$nextlx.svalue = (dest = (u8 *)mlib$pcm_alloc((length + (i64)1)));
    L273 :;
    while (1) {
        switch ((c = (i64)(u64)(*(pstart)++))) {
        case 92:;
            {
                c = (i64)(u64)(*pstart);
                if (((c >= (i64)65) && (c <= (i64)90))) {
                    c += (i64)32;
                }
;
                ++(pstart);
                switch (c) {
                case 97:;
                    {
                        c = (i64)7;
                    }
                    break;
                case 98:;
                    {
                        c = (i64)8;
                    }
                    break;
                case 99:;
                case 114:;
                    {
                        c = (i64)13;
                    }
                    break;
                case 101:;
                    {
                        c = (i64)26;
                    }
                    break;
                case 102:;
                    {
                        c = (i64)12;
                    }
                    break;
                case 108:;
                case 110:;
                    {
                        c = (i64)10;
                    }
                    break;
                case 115:;
                    {
                        c = (i64)27;
                    }
                    break;
                case 116:;
                    {
                        c = (i64)9;
                    }
                    break;
                case 118:;
                    {
                        c = (i64)11;
                    }
                    break;
                case 119:;
                    {
                        (*(dest)++) = (u64)13u;
                        c = (i64)10;
                    }
                    break;
                case 120:;
                    {
                        c = (i64)0;
                        $av_1 = (i64)2;
                        while ($av_1-- > 0) {
L275 :;
                                                        {i64 $temp = (d = (i64)(u64)(*(pstart)++));
if (($temp==(i64)65) || ($temp==(i64)66) || ($temp==(i64)67) || ($temp==(i64)68) || ($temp==(i64)69) || ($temp==(i64)70)) {
                                c = ((((c * (i64)16) + d) - (i64)65) + (i64)10);
                            }
                            else if (($temp==(i64)97) || ($temp==(i64)98) || ($temp==(i64)99) || ($temp==(i64)100) || ($temp==(i64)101) || ($temp==(i64)102)) {
                                c = ((((c * (i64)16) + d) - (i64)97) + (i64)10);
                            }
                            else if (($temp==(i64)48) || ($temp==(i64)49) || ($temp==(i64)50) || ($temp==(i64)51) || ($temp==(i64)52) || ($temp==(i64)53) || ($temp==(i64)54) || ($temp==(i64)55) || ($temp==(i64)56) || ($temp==(i64)57)) {
                                c = (((c * (i64)16) + d) - (i64)48);
                            }
                            else {
                                qq_lib$lxerror((byte*)"Bad \\x code");
                            }
                            };
L276 :;
                        }
L277 :;
                        ;
                    }
                    break;
                case 121:;
                    {
                        c = (i64)16;
                    }
                    break;
                case 122:;
                case 48:;
                    {
                        c = (i64)0;
                    }
                    break;
                case 34:;
                case 81:;
                    {
                        c = (i64)34;
                    }
                    break;
                case 92:;
                    {
                        c = (i64)92;
                    }
                    break;
                case 39:;
                    {
                        c = (i64)39;
                    }
                    break;
                default: {
                    str[((i64)1)-1] = (u64)c;
                    str[((i64)2)-1] = (u64)0u;
                    qq_lex$lxerror_s((byte*)"Unknown string escape: \\%s",(u8 *)str);
                }
                } //SW
;
            }
            break;
        case 34:;
        case 39:;
            {
                if ((c == termchar)) {
                    if (((i64)(u64)(*pstart) == c)) {
                        ++(pstart);
                    }
                    else {
                        goto L274 ;
                    }
;
                }
;
            }
            break;
        case 13:;
        case 10:;
        case 26:;
        case 0:;
            {
                qq_lib$lxerror((byte*)"String not terminated");
            }
            break;
        } //SW
;
        (*(dest)++) = (u64)c;
    }
L274 :;
    ;
    (*(qq_decls$nextlx.svalue + qq_lex$nextlxlength)) = (u64)0u;
}

void qq_lex$lexinit(void) {
    memset(&qq_lex$hashtable,(i32)(i64)0,(u64)7340032u);
    qq_lex$hashtablelast = &qq_lex$hashtable[((i64)65535)];
    qq_lex$inithashtable();
}

static void qq_lex$readrawstring(void) {
        u8 *  pstart;
        i64 length;
    qq_decls$nextlx.symbol = (i64)84;
    pstart = ++(qq_lex$lxsptr);
    length = (i64)0;
    L278 :;
    switch ((i64)(u64)(*(qq_lex$lxsptr)++)) {
    case 34:;
        {
            goto L279 ;
        }
        break;
    case 13:;
    case 10:;
    case 0:;
        {
            qq_lib$lxerror((byte*)"Raw string not terminated");
            --(qq_lex$lxsptr);
            goto L279 ;
        }
        break;
    default: {
        ++(length);
    }
    } //SW
goto L278 ;
L279 :;
    ;
    qq_lex$nextlxlength = length;
    qq_decls$nextlx.svalue = mlib$pcm_copyheapstringn(pstart,length);
}

i64 qq_lex$lookup(u8 *name,i64 length,i64 hashindex) {
        i64 wrapped;
        i64 n;
        struct qq_decls$strec *  d;
    d = &qq_lex$hashtable[(hashindex)];
    wrapped = (i64)0;
    L280 :;
    while (1) {
        if ((((n = (i64)(*d).namelen) == length) && (memcmp((void *)(*d).name,(void *)name,(u64)n) == (i64)0))) {
            qq_decls$nextlx.symptr = (struct qq_decls$strec *)d;
            qq_decls$nextlx.symbol = (i64)(*d).symbolcode;
            qq_decls$nextlx.subcode = (i64)(*d).subcode;
            return (i64)1;
        }
        else if ((n == (i64)0)) {
            goto L281 ;
        }
;
        if ((++(d) > qq_lex$hashtablelast)) {
            if (!!(wrapped)) {
                mlib$abortprogram((byte*)"HASHTABLE FULL");
            }
;
            wrapped = (i64)1;
            d = &qq_lex$hashtable[((i64)0)];
        }
;
    }
L281 :;
    ;
    (*d).name = mlib$pcm_copyheapstringn(name,length);
    (*d).namelen = length;
    (*d).symbolcode = (i64)89;
    qq_decls$nextlx.symptr = (struct qq_decls$strec *)d;
    qq_decls$nextlx.symbol = (i64)(*d).symbolcode;
    qq_decls$nextlx.subcode = (i64)(*d).subcode;
    return (i64)0;
}

i64 qq_lex$gethashvaluez(u8 *s) {
        i64 c;
        i64 hsum;
    if (((i64)(u64)(*s) == (i64)0)) {
        return (i64)0;
    }
;
    hsum = (i64)(u64)(*(s)++);
    L282 :;
    while (1) {
        c = (i64)(u64)(*(s)++);
        if ((c == (i64)0)) {
            goto L283 ;
        }
;
        hsum = (((hsum << (i64)4) - hsum) + c);
    }
L283 :;
    ;
    return (((hsum << (i64)5) - hsum) & (i64)65535);
}

static void qq_lex$inithashtable(void) {
        i64 i;
        u8 *  name;
    for (i=(i64)1;i<=(i64)234;++i) {
L284 :;
        qq_lex$addstname(qq_tables$stnames[(i)-1],(i64)qq_tables$stsymbols[(i)-1],(i64)qq_tables$stsubcodes[(i)-1]);
L285 :;
    }
L286 :;
    ;
    for (i=(i64)1;i<=(i64)77;++i) {
L287 :;
        if (!(!!((i64)qq_tables$hostinternal[(i)]))) {
            name = (qq_tables$hostfnnames[(i)] + (i64)5);
            qq_lex$addstname(name,(i64)171,i);
        }
;
L288 :;
    }
L289 :;
    ;
}

static void qq_lex$addstname(u8 *name,i64 symbol,i64 subcode) {
    if (!!(qq_lex$lookup(name,strlen(name),qq_lex$gethashvaluez(name)))) {
        msysc$m_print_startcon();
        msysc$m_print_str(name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mlib$abortprogram((byte*)"Dupl ST entry");
    }
;
    (*qq_decls$nextlx.symptr).symbolcode = symbol;
    (*qq_decls$nextlx.symptr).subcode = subcode;
}

void qq_lex$startlex(i64 fileno,i64 moduleno) {
    if (!(!!((i64)qqcli$fwriteqa))) {
        qq_lex$lxsource = (qq_lex$lxsptr = qq_decls$sourcefiletext[(fileno)-1]);
    }
    else {
        qq_lex$lxsource = (qq_lex$lxsptr = mlib$pcm_copyheapstring(qq_decls$sourcefiletext[(fileno)-1]));
    }
;
    qq_lex$lxfileno = fileno;
    qq_decls$nextlx.symbol = (i64)6;
    qq_decls$nextlx.subcode = (i64)0;
    qq_decls$nextlx.pos = msysc$m_setdotslice(qq_decls$nextlx.pos,(i64)24,(i64)31,moduleno);
}

struct qq_decls$strec *qq_lex$addnamestr(u8 *name) {
        struct qq_decls$lexrec oldlx;
        struct qq_decls$strec *  symptr;
    oldlx = qq_decls$nextlx;
    qq_lex$nextlxlength = strlen(name);
    qq_decls$nextlx.svalue = (u8 *)mlib$pcm_alloc((qq_lex$nextlxlength + (i64)1));
    memcpy((void *)qq_decls$nextlx.svalue,(void *)name,(u64)(qq_lex$nextlxlength + (i64)1));
    qq_lex$lookup(qq_decls$nextlx.svalue,qq_lex$nextlxlength,qq_lex$gethashvaluez(name));
    symptr = (struct qq_decls$strec *)qq_decls$nextlx.symptr;
    qq_decls$nextlx = oldlx;
    return symptr;
}

void qq_lex$ps1(u8 *caption) {
    msysc$m_print_startcon();
    msysc$m_print_str(caption,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)":::",NULL);
    msysc$m_print_end();
    ;
    qq_dummyshow$printsymbol(&qq_decls$lx);
}

void qq_lex$ps2(u8 *caption) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"\t",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(caption,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)":##",NULL);
    msysc$m_print_end();
    ;
    qq_dummyshow$printsymbol(&qq_decls$nextlx);
}

void qq_lex$lex(void) {
    qq_decls$lx = qq_decls$nextlx;
    qq_lex$lxlength = qq_lex$nextlxlength;
    qq_decls$lx.pos = msysc$m_setdotslice(qq_decls$lx.pos,(i64)0,(i64)23,(u64)(qq_lex$lxstart - qq_lex$lxsource));
    //reenter:
L290 :;
;
    qq_lex$lexreadtoken();
    //reenter2:
L291 :;
;
    switch ((i64)qq_decls$nextlx.symbol) {
    case 88:;
        {
                        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)79)) {
                                {i64 $temp = (i64)(*qq_decls$nextlx.symptr).subcode;
if (($temp==(i64)2)) {
                    qq_decls$lx.value *= (i64)1000000;
                }
                else if (($temp==(i64)3)) {
                    qq_decls$lx.value *= (i64)1000000000;
                }
                else if (($temp==(i64)1)) {
                    qq_decls$lx.value *= (i64)1000;
                }
                else {
                    qq_lib$lxerror((byte*)"Can't do this unit index");
                }
                };
                qq_decls$lx.subcode = qq_lex$setinttype((u64)qq_decls$lx.value);
                goto L290 ;
;
            }
            else if (($temp==(i64)81)) {
                qq_lib$lxerror((byte*)"unit symbol after float?");
            }
            else {
                qq_decls$nextlx.symbol = (i64)89;
            }
            };
        }
        break;
    case 102:;
    case 119:;
    case 103:;
    case 120:;
    case 106:;
    case 107:;
    case 110:;
    case 108:;
    case 127:;
    case 128:;
    case 135:;
    case 101:;
    case 130:;
    case 131:;
    case 132:;
    case 136:;
    case 112:;
    case 152:;
    case 164:;
    case 93:;
        {
            if (((i64)qq_decls$lx.symbol == (i64)100)) {
                qq_decls$lx.subcode = (i64)qq_decls$nextlx.symbol;
                goto L290 ;
;
            }
;
        }
        break;
    case 170:;
        {
                        {i64 $temp = (i64)qq_decls$nextlx.subcode;
if (($temp==(i64)3)) {
                qq_decls$nextlx.symbol = (i64)79;
                qq_decls$nextlx.value = (i64)0;
                qq_decls$nextlx.subcode = (i64)1;
            }
            else if (($temp==(i64)1)) {
                qq_decls$nextlx.symbol = (i64)81;
                qq_decls$nextlx.xvalue = (double)3.1415926535897931;
                qq_decls$nextlx.subcode = (i64)3;
            }
            else if (($temp==(i64)2)) {
                qq_decls$nextlx.symbol = (i64)84;
                qq_decls$nextlx.svalue = (byte*)"\t";
                qq_lex$nextlxlength = (i64)1;
            }
            else {
                qq_lib$lxerror((byte*)"sysconst?");
            }
            };
        }
        break;
    case 75:;
        {
            switch ((i64)qq_decls$lx.symbol) {
            case 5:;
            case 15:;
            case 13:;
            case 9:;
            case 6:;
                {
                    qq_lex$lexreadtoken();
                    goto L291 ;
;
                    goto L290 ;
;
                }
                break;
            default: {
                if ((!!((i64)qq_tables$binopset[((i64)qq_decls$lx.symbol)]) && !(((i64)qq_decls$lx.symbol == (i64)47 || (i64)qq_decls$lx.symbol == (i64)46)))) {
                    qq_lex$lexreadtoken();
                    goto L291 ;
;
                }
;
            }
            } //SW
;
            qq_decls$nextlx.symbol = (i64)6;
        }
        break;
    case 50:;
        {
            if (((i64)qq_decls$lx.symbol == (i64)62)) {
                qq_decls$lx.symbol = (i64)51;
                qq_decls$lx.subcode = (i64)162;
                goto L290 ;
;
            }
;
        }
        break;
    } //SW
;
}

static i64 qq_lex$setinttype(u64 a) {
    if ((a < (u64)9223372036854775807u)) {
        return (i64)1;
    }
    else {
        return (i64)2;
    }
;
}

void qq_lex$lxerror_s(u8 *mess,u8 *a) {
        u8 str[256];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt(mess);
    msysc$m_print_str(a,NULL);
    msysc$m_print_end();
    ;
    qq_lib$lxerror((u8 *)str);
}

void qq_lex$stacksource(i64 fileno) {
    if ((qq_lex$sourcelevel >= (i64)20)) {
        qq_lib$lxerror((byte*)"Include file/macro overflow");
    }
;
    ++(qq_lex$sourcelevel);
    qq_lex$lxstart_stack[(qq_lex$sourcelevel)-1] = qq_lex$lxstart;
    qq_lex$lxsptr_stack[(qq_lex$sourcelevel)-1] = qq_lex$lxsptr;
    qq_lex$lxfileno_stack[(qq_lex$sourcelevel)-1] = qq_lex$lxfileno;
    qq_lex$lxnextlx_stack[(qq_lex$sourcelevel)-1] = qq_decls$nextlx;
    qq_lex$lxstart = (qq_lex$lxsptr = qq_decls$sourcefiletext[(fileno)-1]);
    qq_decls$nextlx.pos = (i64)1;
    qq_lex$lxfileno = fileno;
    qq_decls$nextlx.symbol = (i64)6;
    qq_decls$nextlx.subcode = (i64)0;
}

void qq_lex$unstacksource(void) {
    if ((qq_lex$sourcelevel > (i64)0)) {
        qq_lex$lxstart = qq_lex$lxstart_stack[(qq_lex$sourcelevel)-1];
        qq_lex$lxsptr = qq_lex$lxsptr_stack[(qq_lex$sourcelevel)-1];
        qq_decls$nextlx = qq_lex$lxnextlx_stack[(qq_lex$sourcelevel)-1];
        qq_lex$lxfileno = qq_lex$lxfileno_stack[(qq_lex$sourcelevel)-1];
        --(qq_lex$sourcelevel);
    }
;
}

static void qq_lex$makedecimal(u8 *s,i64 length,i64 base) {
    if ((base != (i64)10)) {
        qq_lib$lxerror((byte*)"MAKEDECIMAL/16/2");
    }
;
    qq_decls$nextlx.symbol = (i64)80;
    qq_decls$nextlx.subcode = (i64)4;
    qq_decls$nextlx.svalue = mlib$pcm_copyheapstringn(s,length);
    qq_lex$nextlxlength = length;
}

static void qq_lex$readdec(void) {
        i64 c;
        u8 *  dest;
        u8 *  destend;
        u8 *  pstart;
        i64 islong;
        i64 length;
        byte str[1024];
        u64 a;
        i64 $av_1;
    islong = (i64)0;
    pstart = qq_lex$lxsptr;
    dest = (u8 *)str;
    destend = ((dest + (i64)1024) - (i64)10);
    a = (u64)0u;
    L292 :;
    while (1) {
        switch ((c = (i64)(u64)(*(qq_lex$lxsptr)++))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                a = (u64)((((i64)a * (i64)10) + c) - (i64)48);
                (*(dest)++) = (u64)c;
            }
            break;
        case 101:;
        case 69:;
            {
                qq_lex$lxsptr = pstart;
                qq_lex$readreal();
                return;
            }
            break;
        case 46:;
            {
                if (((u64)(*qq_lex$lxsptr) != '.')) {
                    qq_lex$lxsptr = pstart;
                    qq_lex$readreal();
                    return;
                }
;
                --(qq_lex$lxsptr);
                goto L293 ;
            }
            break;
        case 95:;
        case 39:;
            {
            }
            break;
        case 108:;
        case 76:;
            {
                (*dest) = (u64)0u;
                qq_lex$makedecimal((u8 *)str,(dest - str),(i64)10);
                return;
            }
            break;
        case 98:;
        case 66:;
            {
                length = (dest - str);
                if ((length > (i64)64)) {
                    qq_lib$lxerror((byte*)"bin overflow");
                }
;
                dest = (u8 *)str;
                a = (u64)0u;
                $av_1 = length;
                while ($av_1-- > 0) {
L294 :;
                    if (((u64)(*dest) >= '2')) {
                        qq_lib$lxerror((byte*)"bad bin digit");
                    }
;
                    a = (u64)((((i64)a * (i64)2) + (i64)(u64)(*(dest)++)) - (i64)48);
L295 :;
                }
L296 :;
                ;
                goto L297 ;
;
            }
            break;
        default: {
            --(qq_lex$lxsptr);
            goto L293 ;
        }
        } //SW
;
        if ((dest >= destend)) {
            qq_lib$lxerror((byte*)"Numlit too long");
        }
;
    }
L293 :;
    ;
    length = (dest - str);
    if (((length > (i64)20) || ((length == (i64)20) && !!(strncmp((u8 *)str,qq_lex$u64maxstr,(u64)20u))))) {
        qq_lex$makedecimal((u8 *)str,length,(i64)10);
        return;
    }
;
    //finish:
L297 :;
;
    qq_decls$nextlx.symbol = (i64)79;
    qq_decls$nextlx.subcode = qq_lex$setinttype(a);
    qq_decls$nextlx.value = (i64)a;
}

static void qq_lex$readhex(void) {
        i64 c;
        u8 *  dest;
        u8 *  destend;
        u8 *  pstart;
        i64 length;
        byte str[1024];
        u64 a;
    pstart = qq_lex$lxsptr;
    dest = (u8 *)str;
    destend = ((dest + (i64)1024) - (i64)10);
    a = (u64)0u;
    L298 :;
    while (1) {
        switch ((c = (i64)(u64)(*(qq_lex$lxsptr)++))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                a = (u64)((((i64)a * (i64)16) + c) - (i64)48);
                (*(dest)++) = (u64)c;
            }
            break;
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
            {
                (*(dest)++) = (u64)c;
                a = (u64)(((((i64)a * (i64)16) + c) - (i64)65) + (i64)10);
            }
            break;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
            {
                (*(dest)++) = (u64)(c - (i64)32);
                a = (u64)(((((i64)a * (i64)16) + c) - (i64)97) + (i64)10);
            }
            break;
        case 95:;
        case 39:;
            {
            }
            break;
        case 108:;
        case 76:;
            {
                (*dest) = (u64)0u;
                qq_lex$makedecimal((u8 *)str,(dest - str),(i64)16);
                return;
            }
            break;
        case 46:;
            {
                --(qq_lex$lxsptr);
                goto L299 ;
            }
            break;
        default: {
            --(qq_lex$lxsptr);
            goto L299 ;
        }
        } //SW
;
        if ((dest >= destend)) {
            qq_lib$lxerror((byte*)"Numlit too long");
        }
;
    }
L299 :;
    ;
    length = (dest - str);
    if ((length > (i64)16)) {
        qq_lex$makedecimal((u8 *)str,length,(i64)16);
        return;
    }
;
    qq_decls$nextlx.symbol = (i64)79;
    qq_decls$nextlx.subcode = qq_lex$setinttype(a);
    qq_decls$nextlx.value = (i64)a;
}

static void qq_lex$readbin(void) {
        i64 c;
        u8 *  dest;
        u8 *  destend;
        u8 *  pstart;
        i64 length;
        byte str[1024];
        u64 a;
    pstart = qq_lex$lxsptr;
    dest = (u8 *)str;
    destend = ((dest + (i64)1024) - (i64)10);
    a = (u64)0u;
    L300 :;
    while (1) {
        switch ((c = (i64)(u64)(*(qq_lex$lxsptr)++))) {
        case 48:;
        case 49:;
            {
                a = (u64)((((i64)a * (i64)2) + c) - (i64)48);
                (*(dest)++) = (u64)c;
            }
            break;
        case 95:;
        case 39:;
            {
            }
            break;
        case 108:;
        case 76:;
            {
                (*dest) = (u64)0u;
                qq_lex$makedecimal((u8 *)str,(dest - str),(i64)2);
                return;
            }
            break;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                qq_lib$lxerror((byte*)"bin bad digit");
            }
            break;
        case 46:;
            {
                --(qq_lex$lxsptr);
                goto L301 ;
            }
            break;
        default: {
            --(qq_lex$lxsptr);
            goto L301 ;
        }
        } //SW
;
        if ((dest >= destend)) {
            qq_lib$lxerror((byte*)"bin overflow");
        }
;
    }
L301 :;
    ;
    length = (dest - str);
    if ((length > (i64)64)) {
        qq_lex$makedecimal((u8 *)str,length,(i64)2);
        return;
    }
;
    qq_decls$nextlx.symbol = (i64)79;
    qq_decls$nextlx.subcode = qq_lex$setinttype(a);
    qq_decls$nextlx.value = (i64)a;
}

static void qq_lex$readreal(void) {
        i64 c;
        i64 negexpon;
        i64 dotseen;
        i64 length;
        i64 fractlen;
        i64 expon;
        i64 expseen;
        r64 x;
        u8 str[1024];
        u8 *  dest;
        u8 *  destend;
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
        i64 i;
    dest = (u8 *)str;
    destend = ((dest + (i64)1024) - (i64)100);
    length = (negexpon = (dotseen = (expseen = (expon = (fractlen = (i64)0)))));
    L302 :;
    while (1) {
        switch ((c = (i64)(u64)(*(qq_lex$lxsptr)++))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                (*(dest)++) = (u64)c;
                ++(length);
                if (!!(dotseen)) {
                    ++(fractlen);
                }
;
            }
            break;
        case 46:;
            {
                if (!!(dotseen)) {
                    --(qq_lex$lxsptr);
                    goto L303 ;
                }
;
                dotseen = (i64)1;
                (*(dest)++) = (u64)c;
            }
            break;
        case 101:;
        case 69:;
            {
                if (!!(expseen)) {
                    qq_lib$lxerror((byte*)"double expon");
                }
;
                expseen = (i64)1;
                (*(dest)++) = (u64)c;
                L304 :;
                while (((u64)(*qq_lex$lxsptr) == ' ')) {
                    ++(qq_lex$lxsptr);
L305 :;
                }
L306 :;
                ;
                if (((u64)(*qq_lex$lxsptr) == '+' || (u64)(*qq_lex$lxsptr) == '-')) {
                    if (((u64)(*qq_lex$lxsptr) == '-')) {
                        negexpon = (i64)1;
                    }
;
                    (*(dest)++) = (u64)(*(qq_lex$lxsptr)++);
                }
;
                expon = (i64)0;
                L307 :;
                switch ((c = (i64)(u64)(*(qq_lex$lxsptr)++))) {
                case 48:;
                case 49:;
                case 50:;
                case 51:;
                case 52:;
                case 53:;
                case 54:;
                case 55:;
                case 56:;
                case 57:;
                    {
                        expon = (((expon * (i64)10) + c) - (i64)48);
                        (*(dest)++) = (u64)c;
                        if ((dest >= destend)) {
                            qq_lib$lxerror((byte*)"expon?");
                        }
;
                    }
                    break;
                case 95:;
                case 39:;
                    {
                    }
                    break;
                case 108:;
                case 76:;
                    {
                        (*dest) = (u64)0u;
                        qq_lex$makedecimal((u8 *)str,(dest - str),(i64)10);
                        return;
                    }
                    break;
                default: {
                    --(qq_lex$lxsptr);
                    goto L303 ;
                }
                } //SW
goto L307 ;
L308 :;
                ;
            }
            break;
        case 95:;
        case 39:;
            {
            }
            break;
        case 108:;
        case 76:;
            {
                qq_lex$makedecimal((u8 *)str,(dest - str),(i64)10);
                return;
            }
            break;
        default: {
            --(qq_lex$lxsptr);
            goto L303 ;
        }
        } //SW
;
        if ((dest >= destend)) {
            qq_lib$lxerror((byte*)"r64lit too long");
        }
;
    }
L303 :;
    ;
    (*dest) = (u64)0u;
    if (!!(negexpon)) {
        expon = -(expon);
    }
;
    expon -= fractlen;
    x = (double)0.;
        ($av_1 = (length + dotseen));
    for (i=(i64)1;i<=$av_1;++i) {
L309 :;
        c = (i64)(u64)str[(i)-1];
        if ((c != (i64)46)) {
            x = (((x * (double)10.) + (r64)c) - (r64)'0');
        }
;
L310 :;
    }
L311 :;
    ;
    if ((expon >= (i64)0)) {
        $av_2 = expon;
        while ($av_2-- > 0) {
L312 :;
            x *= (double)10.;
L313 :;
        }
L314 :;
        ;
    }
    else {
        $av_3 = -(expon);
        while ($av_3-- > 0) {
L315 :;
            x /= (double)10.;
L316 :;
        }
L317 :;
        ;
    }
;
    qq_decls$nextlx.xvalue = x;
    qq_decls$nextlx.symbol = (i64)81;
    qq_decls$nextlx.subcode = (i64)3;
}

static void qq_lex$readrawxname(void) {
        i64 c;
        i64 hsum;
    qq_decls$nextlx.svalue = qq_lex$lxsptr;
    hsum = (i64)0;
    L318 :;
    switch ((c = (i64)(u64)(*(qq_lex$lxsptr)++))) {
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    case 95:;
    case 36:;
        {
            hsum = (((hsum << (i64)4) - hsum) + c);
        }
        break;
    default: {
        --(qq_lex$lxsptr);
        goto L319 ;
    }
    } //SW
goto L318 ;
L319 :;
    ;
    qq_lex$lookup(qq_decls$nextlx.svalue,(qq_lex$lxsptr - qq_decls$nextlx.svalue),(((hsum << (i64)5) - hsum) & (i64)65535));
    return;
}

// START
void qq_lex$start(void) {

}

void qq_lib$reportcterror(u8 *errortype,u8 *mess,i64 pos,struct qq_decls$strec *currproc) {
    qq_lib$geterrorinfo((u64)pos,currproc);
    msysc$m_print_startcon();
    msysc$m_print_str(errortype,NULL);
    msysc$m_print_str((byte*)"Error:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"    ",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(mess,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    qq_lib$showerrorsource();
    qq_lib$stopcompiler((struct qq_decls$modulerec *)qq_decls$errormodule,qq_decls$errorlineno);
}

void qq_lib$geterrorinfo(u64 pos,struct qq_decls$strec *currproc) {
        u8 *  stoken;
        u8 *  sline;
        u8 *  smodule;
        u8 *  slineend;
        u8 *  s;
        i64 length;
        i64 column;
        i64 soffset;
        i64 moduleno;
        i64 $av_1;
        i64 i;
    soffset = (i64)msysc$m_getdotslice(pos,(i64)0,(i64)23);
    moduleno = (i64)msysc$m_getdotslice(pos,(i64)24,(i64)31);
    if (((soffset == (i64)0) && (moduleno == (i64)0))) {
        //default:
L320 :;
;
        strcpy(qq_decls$errorline,(byte*)"<no data>");
        strcpy(qq_decls$errorpointer,(byte*)"???");
        qq_decls$errormodule = (struct qq_decls$modulerec *)&qq_decls$moduletable[((i64)1)];
        qq_decls$errorlineno = (i64)1;
        return;
    }
;
    if ((moduleno == (i64)0)) {
        qq_decls$errormodule = (struct qq_decls$modulerec *)&qq_decls$moduletable[((i64)0)];
    }
    else if ((currproc == 0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Geterrorinfo: can't find module",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        goto L320 ;
;
        exit((i64)1);
    }
    else if (((i64)(*currproc).nameid == (i64)5)) {
        qq_decls$errormodule = (struct qq_decls$modulerec *)&qq_decls$moduletable[((i64)(*(*currproc).owner).moduleno)];
        qq_decls$sterrorproc = currproc;
    }
    else if (!!(moduleno)) {
        qq_decls$errormodule = (struct qq_decls$modulerec *)&qq_decls$moduletable[(moduleno)];
    }
    else {
        qq_decls$errormodule = (struct qq_decls$modulerec *)&qq_decls$moduletable[((i64)(*currproc).moduleno)];
        qq_decls$sterrorproc = 0;
    }
;
    smodule = qq_decls$sourcefiletext[((i64)(*qq_decls$errormodule).fileno)-1];
    stoken = (smodule + soffset);
    sline = (slineend = stoken);
    L321 :;
    while (((sline > smodule) && ((i64)(u64)(*sline) != (i64)10))) {
        --(sline);
L322 :;
    }
L323 :;
    ;
    if (((i64)(u64)(*sline) == (i64)10)) {
        ++(sline);
    }
;
    s = sline;
    qq_decls$errorlineno = (i64)1;
    L324 :;
    while ((s > smodule)) {
        if (((i64)(u64)(*s) == (i64)10)) {
            ++(qq_decls$errorlineno);
        }
;
        --(s);
L325 :;
    }
L326 :;
    ;
    L327 :;
    while (!(((u64)(*slineend) == (i64)13 || (u64)(*slineend) == (i64)10 || (u64)(*slineend) == (i64)26 || (u64)(*slineend) == (i64)0))) {
        ++(slineend);
L328 :;
    }
L329 :;
    ;
    length = (slineend - sline);
    length=(length>(i64)0?length:(i64)0);
;
    column = ((stoken - sline) + (i64)1);
    length=(length<(i64)255?length:(i64)255);
;
    memcpy(&qq_decls$errorline,(void *)sline,(u64)length);
    qq_decls$errorline[((length + (i64)1))-1] = (u64)0u;
        ($av_1 = (column - (i64)1));
    for (i=(i64)1;i<=$av_1;++i) {
L330 :;
        if (!(((u64)qq_decls$errorline[(i)-1] == (i64)9 || (u64)qq_decls$errorline[(i)-1] == ' '))) {
            qq_decls$errorpointer[(i)-1] = ' ';
        }
        else {
            qq_decls$errorpointer[(i)-1] = (u64)qq_decls$errorline[(i)-1];
        }
;
L331 :;
    }
L332 :;
    ;
    qq_decls$errorpointer[(column)-1] = '^';
    qq_decls$errorpointer[((column + (i64)1))-1] = (u64)0u;
}

i64 qq_lib$getlineno(u8 *source,i64 offset) {
        i64 lineno;
        u8 *  sline;
        u8 *  s;
    sline = (source + offset);
    L333 :;
    while (((sline > source) && ((i64)(u64)(*sline) != (i64)10))) {
        --(sline);
L334 :;
    }
L335 :;
    ;
    if (((i64)(u64)(*sline) == (i64)10)) {
        ++(sline);
    }
;
    s = sline;
    lineno = (i64)1;
    L336 :;
    while ((s > source)) {
        if (((i64)(u64)(*s) == (i64)10)) {
            ++(lineno);
        }
;
        --(s);
L337 :;
    }
L338 :;
    ;
    return lineno;
}

static void qq_lib$showerrorsource(void) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Line:",NULL);
    msysc$m_print_i64(qq_decls$errorlineno,NULL);
    msysc$m_print_str((byte*)"in Module",NULL);
    msysc$m_print_str((*qq_decls$errormodule).name,NULL);
    msysc$m_print_nogap();
    msysc$m_print_str((byte*)".q:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    if (!!(qq_decls$sterrorproc)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"In function:",NULL);
        msysc$m_print_str((*qq_decls$sterrorproc).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)" |",NULL);
    msysc$m_print_str(qq_decls$errorline,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)" |",NULL);
    msysc$m_print_str(qq_decls$errorpointer,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

void qq_lib$stopcompiler(struct qq_decls$modulerec *m,i64 lineno) {
        void *  f;
    f = fopen((byte*)"$error.tmp",(byte*)"w");
    msysc$m_print_startfile(f);
    msysc$m_print_str(qq_decls$sourcefilespecs[((i64)(*m).fileno)-1],NULL);
    msysc$m_print_i64(lineno,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    fclose(f);
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mwindows$os_getch();
    exit((i64)1);
}

void qq_lib$gerror(u8 *mess,struct qq_decls$unitrec *p) {
    qq_lib$reportcterror((byte*)"Code Gen",mess,(!!(p) ? (i64)(*p).pos : qq_decls$qpos),qq_decls$stcurrproc);
}

void qq_lib$gerror_s(u8 *mess,u8 *param,struct qq_decls$unitrec *p) {
        u8 str[300];
    msysc$m_print_startstr(str);
    msysc$m_print_str(mess,NULL);
    msysc$m_print_str(param,NULL);
    msysc$m_print_end();
    ;
    qq_lib$reportcterror((byte*)"Code Gen",(u8 *)str,(!!(p) ? (i64)(*p).pos : qq_decls$qpos),qq_decls$stcurrproc);
}

void qq_lib$serror(u8 *mess) {
    qq_lib$reportcterror((byte*)"Syntax",mess,(i64)qq_decls$lx.pos,qq_decls$stcurrproc);
}

void qq_lib$serror_s(u8 *mess,u8 *param) {
        u8 str[300];
    strcpy((u8 *)str,mess);
    strcat((u8 *)str,(byte*)" ");
    strcat((u8 *)str,param);
    qq_lib$reportcterror((byte*)"Syntax",str,(i64)qq_decls$lx.pos,qq_decls$stcurrproc);
}

void qq_lib$rxerror(u8 *mess,struct qq_decls$unitrec *p) {
    qq_lib$reportcterror((byte*)"Resolve",mess,(!!(p) ? (i64)(*p).pos : qq_decls$qpos),qq_decls$stcurrproc);
}

void qq_lib$rxerror_s(u8 *mess,u8 *param,struct qq_decls$unitrec *p) {
        u8 str[300];
    strcpy((u8 *)str,mess);
    strcat((u8 *)str,(byte*)" ");
    strcat((u8 *)str,param);
    qq_lib$rxerror(str,p);
}

void qq_lib$lxerror(u8 *mess) {
    qq_lib$reportcterror((byte*)"Lex",mess,(i64)qq_decls$lx.pos,qq_decls$stcurrproc);
}

void qq_lib$pcerror(u8 *mess) {
    qq_lib$errormess = mess;
    qq_lib$getpcerrorpos(qq_decls$pcptr);
    qq_lib$reportpcerror(mess,qq_decls$pcerrorpos,(*qq_decls$pcerrormodule).def);
}

void qq_lib$pcerror_s(u8 *mess,u8 *param) {
        u8 str[300];
    qq_lib$errormess = mess;
    qq_lib$getpcerrorpos(qq_decls$pcptr);
    strcpy((u8 *)str,mess);
    strcat((u8 *)str,(byte*)" ");
    strcat((u8 *)str,param);
    qq_lib$reportpcerror(str,qq_decls$pcerrorpos,(*qq_decls$pcerrormodule).def);
}

void qq_lib$reportpcerror(u8 *mess,i64 pos,struct qq_decls$strec *currproc) {
        struct qq_decls$varrec *  s;
        struct qq_decls$varrec *  send;
        i64 *  pc;
        i64 count;
        i64 elineno;
        struct qq_decls$modulerec *  emodule;
    qq_lib$geterrorinfo((u64)pos,currproc);
    emodule = (struct qq_decls$modulerec *)qq_decls$errormodule;
    elineno = qq_decls$errorlineno;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)" ",(byte*)"80p*");
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"PC Error:",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"    ",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(mess,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    qq_lib$showerrorsource();
    s = qq_decls$sptr;
    send = &qq_decls$varstack[((i64)1)-1];
    count = (i64)0;
    L339 :;
    while (((s >= send) && (count < (i64)5))) {
        if (((i64)(*s).tag == (i64)21)) {
            pc = ((*s).retaddr - (i64)3);
            qq_lib$getpcerrorpos(pc);
            qq_lib$geterrorinfo((u64)qq_decls$pcerrorpos,(*qq_decls$pcerrormodule).def);
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"Called from line",NULL);
            msysc$m_print_i64(qq_decls$errorlineno,NULL);
            msysc$m_print_str((byte*)"in",NULL);
            msysc$m_print_str((*qq_decls$errormodule).name,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            ++(count);
        }
;
        --(s);
L340 :;
    }
L341 :;
    ;
    qq_lib$stopcompiler((struct qq_decls$modulerec *)emodule,elineno);
}

static void qq_lib$getpcerrorpos(i64 *pc) {
        i64 offset;
        i64 *  pcstart;
        i32 *  pcsrcstart;
    qq_decls$pcerrormodule = &qq_decls$moduletable[(qq_lib$findmodulefrompc(pc))];
    pcstart = (*qq_decls$pcerrormodule).pcstart;
    pcsrcstart = (*qq_decls$pcerrormodule).pcsrcstart;
    offset = (pc - pcstart);
    qq_decls$pcerrorpos = (i64)(*(pcsrcstart + offset));
}

void qq_lib$loaderror(u8 *mess,u8 *mess2,u8 *mess3) {
        u8 str[512];
    if (!!(strchr(mess,(i32)'#'))) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt(mess);
        msysc$m_print_str(mess2,NULL);
        msysc$m_print_str(mess3,NULL);
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startstr(str);
        msysc$m_print_str(mess,NULL);
        msysc$m_print_end();
        ;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Load Error:",NULL);
    msysc$m_print_str(str,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Stopping",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)1);
}

static i64 qq_lib$findmodulefrompc(i64 *pc) {
        i64 i;
    for (i=(i64)1;i<=qq_decls$nmodules;++i) {
L342 :;
        if (((pc >= qq_decls$moduletable[(i)].pcstart) && (pc < qq_decls$moduletable[(i)].pcend))) {
            return i;
        }
;
L343 :;
    }
L344 :;
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Can't find pcptr module",NULL);
    msysc$m_print_ptr(pc,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    if (!!(qq_lib$errormess)) {
        msysc$m_print_startcon();
        msysc$m_print_setfmt((byte*)"(#)");
        msysc$m_print_str(qq_lib$errormess,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    exit((i64)1);
    return (i64)0;
}

void qq_lib$prterror(u8 *mess) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"Print error:",NULL);
    msysc$m_print_str(mess,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mwindows$os_getch();
    exit((i64)1);
}

void qq_lib$pcustype(u8 *mess,struct qq_decls$varrec *x) {
    qq_lib$pcustype_t(mess,(i64)(*x).tag);
}

void qq_lib$pcustype_t(u8 *mess,i64 t) {
        u8 str[256];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"Type not supported: # : #");
    msysc$m_print_str(mess,NULL);
    msysc$m_print_str(qq_tables$ttname[(t)],NULL);
    msysc$m_print_end();
    ;
    qq_lib$getpcerrorpos(qq_decls$pcptr);
    qq_lib$reportpcerror(str,qq_decls$pcerrorpos,(*qq_decls$pcerrormodule).def);
}

void qq_lib$pcmxtypes(u8 *mess,struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
    qq_lib$pcmxtypestt(mess,(i64)(*x).tag,(i64)(*y).tag);
}

void qq_lib$pcmxtypestt(u8 *mess,i64 t,i64 u) {
        u8 str[256];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"Types not supported: # : #/#");
    msysc$m_print_str(mess,NULL);
    msysc$m_print_str(qq_tables$ttname[(t)],NULL);
    msysc$m_print_str(qq_tables$ttname[(u)],NULL);
    msysc$m_print_end();
    ;
    qq_lib$getpcerrorpos(qq_decls$pcptr);
    qq_lib$reportpcerror(str,qq_decls$pcerrorpos,(*qq_decls$pcerrormodule).def);
}

struct qq_decls$unitrec *qq_lib$allocunitrec(void) {
        struct qq_decls$unitrec *  p;
    p = (struct qq_decls$unitrec *)mlib$pcm_alloc((i64)32);
    (*p).word1 = ((*p).nextunit = ((*p).a = ((*p).b = 0)));
    (*p).nextunit = ((*p).a = ((*p).b = 0));
    (*p).pos = (i64)qq_decls$lx.pos;
    return p;
}

struct qq_decls$unitrec *qq_lib$createintunit(i64 a) {
        struct qq_decls$unitrec *  u;
    u = qq_lib$allocunitrec();
    (*u).tag = (i64)50;
    (*u).value = a;
    return u;
}

struct qq_decls$unitrec *qq_lib$createboolunit(i64 a) {
        struct qq_decls$unitrec *  u;
    u = qq_lib$allocunitrec();
    (*u).tag = (i64)55;
    (*u).value = a;
    return u;
}

struct qq_decls$unitrec *qq_lib$createwordunit(i64 a) {
        struct qq_decls$unitrec *  u;
    u = qq_lib$allocunitrec();
    (*u).tag = (i64)51;
    (*u).value = a;
    return u;
}

struct qq_decls$unitrec *qq_lib$createrealunit(r64 x) {
        struct qq_decls$unitrec *  u;
    u = qq_lib$allocunitrec();
    (*u).tag = (i64)54;
    (*u).xvalue = x;
    return u;
}

struct qq_decls$unitrec *qq_lib$createstringunit(u8 *s,i64 slength) {
        struct qq_decls$unitrec *  u;
    if ((slength == (i64)-1)) {
        slength = strlen(s);
    }
;
    u = qq_lib$allocunitrec();
    (*u).tag = (i64)57;
    (*u).svalue = (u8 *)mlib$pcm_alloc((slength + (i64)1));
    if (!!(slength)) {
        memcpy((void *)(*u).svalue,(void *)s,(u64)slength);
    }
;
    (*((*u).svalue + slength)) = (u64)0u;
    (*u).slength = slength;
    return u;
}

struct qq_decls$unitrec *qq_lib$createunit0(i64 tag) {
        struct qq_decls$unitrec *  u;
    u = qq_lib$allocunitrec();
    (*u).tag = tag;
    return u;
}

struct qq_decls$unitrec *qq_lib$createunit1(i64 tag,struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  u;
    u = qq_lib$allocunitrec();
    (*u).tag = tag;
    (*u).a = p;
    return u;
}

struct qq_decls$unitrec *qq_lib$createunit2(i64 tag,struct qq_decls$unitrec *p,struct qq_decls$unitrec *q) {
        struct qq_decls$unitrec *  u;
    u = qq_lib$allocunitrec();
    (*u).tag = tag;
    (*u).a = p;
    (*u).b = q;
    return u;
}

struct qq_decls$unitrec *qq_lib$createname(struct qq_decls$strec *p) {
        struct qq_decls$unitrec *  u;
    u = (struct qq_decls$unitrec *)qq_lib$allocunitrec();
    (*u).tag = (i64)47;
    (*u).def = (struct qq_decls$strec *)p;
    return (struct qq_decls$unitrec *)u;
}

void qq_lib$addlistunit(struct qq_decls$unitrec **ulist,struct qq_decls$unitrec **ulistx,struct qq_decls$unitrec *p) {
    L345 :;
    while (!!(p)) {
        if (((*ulist) == 0)) {
            (*ulist) = ((*ulistx) = p);
        }
        else {
            (*(*ulistx)).nextunit = p;
        }
;
        (*ulistx) = p;
        p = (*p).nextunit;
L346 :;
    }
L347 :;
    ;
}

struct qq_decls$unitrec *qq_lib$getrangelwbunit(struct qq_decls$unitrec *p) {
    if (((i64)(*p).tag == (i64)195)) {
        return (*p).a;
    }
    else {
        return qq_lib$createunit1((i64)119,p);
    }
;
}

struct qq_decls$unitrec *qq_lib$getrangeupbunit(struct qq_decls$unitrec *p) {
    if (((i64)(*p).tag == (i64)195)) {
        return (*p).b;
    }
    else {
        return qq_lib$createunit1((i64)120,p);
    }
;
}

struct qq_decls$unitrec *qq_lib$createavname(void) {
        struct qq_decls$strec *  p;
        u8 str[32];
        u8 *  name;
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"av$",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(++(qq_lib$nextavindex),NULL);
    msysc$m_print_end();
    ;
    name = mlib$pcm_copyheapstring((u8 *)str);
    p = qq_lex$addnamestr(name);
    return (struct qq_decls$unitrec *)qq_lib$createname((struct qq_decls$strec *)p);
}

u8 *qq_lib$convtostringz(u8 *svalue,i64 length) {
        static u8 strbuffer1[2000];
        static u8 strbuffer2[2000];
        static u8 strbuffer3[2000];
        static u8 strbuffer4[2000];
        static u8 strbuffer5[2000];
        static u8 strbuffer6[2000];
        static i64 strindex = (i64)0;
        static u8 (*table[6])[] = {(u8 (*)[])&strbuffer1,(u8 (*)[])&strbuffer2,(u8 (*)[])&strbuffer3,(u8 (*)[])&strbuffer4,(u8 (*)[])&strbuffer5,(u8 (*)[])&strbuffer6};
        u8 (*p)[];
    if ((length >= (i64)2000)) {
        qq_lib$pcerror((byte*)"Convtostringz>=2000");
    }
;
    if ((svalue == 0)) {
        return (byte*)"";
    }
;
    if ((++(strindex) == (i64)6)) {
        strindex = (i64)0;
    }
;
    p = table[(strindex)];
    memcpy(p,(void *)svalue,(u64)length);
    (*p)[(length)] = (u64)0u;
    return (u8 *)p;
}

u8 *qq_lib$findprocname(void (*fnptr)(void)) {
        i64 n;
        i64 i;
    n = msysc$m_get_nprocs();
    for (i=(i64)1;i<=n;++i) {
L348 :;
        if ((msysc$m_get_procaddr(i) == fnptr)) {
            return msysc$m_get_procname(i);
        }
;
L349 :;
    }
L350 :;
    ;
    return (byte*)"?";
}

struct mlib$strbuffer *qq_lib$strexpr(struct qq_decls$unitrec *p) {
    mlib$gs_init((struct mlib$strbuffer *)qq_lib$exprstr);
    qq_lib$jeval(p);
    return (struct mlib$strbuffer *)qq_lib$exprstr;
}

u8 *qq_lib$strexpr_s(struct qq_decls$unitrec *p) {
    if ((p == 0)) {
        return (byte*)"";
    }
;
    mlib$gs_init((struct mlib$strbuffer *)qq_lib$exprstr);
    qq_lib$jeval(p);
    return (*qq_lib$exprstr).strptr;
}

static void qq_lib$jeval(struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  q;
        u8 str[500];
        i64 i;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)50)) {
        qq_lib$additem(msysc$strint((*p).value,0));
    }
    else if (($temp==(i64)54)) {
        qq_lib$additem(msysc$strreal((r64)(*p).value,0));
    }
    else if (($temp==(i64)57)) {
        if (((*p).slength > (i64)250)) {
            strcpy((u8 *)str,(byte*)"LONGSTR)");
        }
        else {
            qq_lib$convertstring((*p).svalue,(u8 *)str);
        }
;
        qq_lib$additem((byte*)"\"");
        qq_lib$additem((u8 *)str);
        qq_lib$additem((byte*)"\"");
    }
    else if (($temp==(i64)47)) {
        qq_lib$additem((*(*p).def).name);
    }
    else if (($temp==(i64)149) || ($temp==(i64)150) || ($temp==(i64)151) || ($temp==(i64)152) || ($temp==(i64)153) || ($temp==(i64)155) || ($temp==(i64)156) || ($temp==(i64)157) || ($temp==(i64)158) || ($temp==(i64)159) || ($temp==(i64)160) || ($temp==(i64)161) || ($temp==(i64)162) || ($temp==(i64)173) || ($temp==(i64)174) || ($temp==(i64)195) || ($temp==(i64)167) || ($temp==(i64)168) || ($temp==(i64)169) || ($temp==(i64)170) || ($temp==(i64)171) || ($temp==(i64)172) || ($temp==(i64)154) || ($temp==(i64)177) || ($temp==(i64)176)) {
        strcpy((u8 *)str,qq_lib$getopcname((i64)(*p).tag));
        qq_lib$additem((byte*)"(");
        qq_lib$jeval((*p).a);
        qq_lib$additem((u8 *)str);
        qq_lib$jeval((*p).b);
        qq_lib$additem((byte*)")");
    }
    else if (($temp==(i64)89) || ($temp==(i64)90) || ($temp==(i64)92) || ($temp==(i64)95) || ($temp==(i64)94) || ($temp==(i64)96) || ($temp==(i64)97) || ($temp==(i64)113) || ($temp==(i64)98) || ($temp==(i64)99) || ($temp==(i64)100) || ($temp==(i64)101) || ($temp==(i64)102) || ($temp==(i64)103) || ($temp==(i64)104) || ($temp==(i64)106) || ($temp==(i64)105) || ($temp==(i64)107) || ($temp==(i64)108) || ($temp==(i64)109) || ($temp==(i64)110) || ($temp==(i64)111) || ($temp==(i64)112) || ($temp==(i64)119) || ($temp==(i64)120) || ($temp==(i64)118) || ($temp==(i64)121) || ($temp==(i64)123) || ($temp==(i64)124) || ($temp==(i64)144) || ($temp==(i64)145) || ($temp==(i64)133) || ($temp==(i64)134) || ($temp==(i64)135) || ($temp==(i64)129) || ($temp==(i64)136) || ($temp==(i64)138) || ($temp==(i64)139) || ($temp==(i64)143) || ($temp==(i64)140) || ($temp==(i64)131) || ($temp==(i64)132) || ($temp==(i64)130) || ($temp==(i64)91) || ($temp==(i64)93) || ($temp==(i64)142) || ($temp==(i64)125) || ($temp==(i64)127) || ($temp==(i64)128) || ($temp==(i64)126) || ($temp==(i64)142) || ($temp==(i64)137) || ($temp==(i64)147) || ($temp==(i64)148)) {
        strcpy((u8 *)str,qq_lib$getopcname((i64)(*p).tag));
        qq_lib$additem((u8 *)str);
        qq_lib$additem((byte*)"(");
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)")");
    }
    else if (($temp==(i64)32)) {
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)"(");
        q = (*p).b;
        L351 :;
        while (!!(q)) {
            qq_lib$jeval(q);
            q = (*q).nextunit;
            if (!!(q)) {
                qq_lib$additem((byte*)",");
            }
;
L352 :;
        }
L353 :;
        ;
        qq_lib$additem((byte*)")");
    }
    else if (($temp==(i64)33)) {
        qq_lib$additem((byte*)"Host<");
        qq_lib$additem((qq_tables$hostfnnames[((*p).index)] + (i64)5));
        qq_lib$additem((byte*)">(");
        q = (*p).a;
        L354 :;
        while (!!(q)) {
            qq_lib$jeval(q);
            q = (*q).nextunit;
            if (!!(q)) {
                qq_lib$additem((byte*)",");
            }
;
L355 :;
        }
L356 :;
        ;
        qq_lib$additem((byte*)")");
    }
    else if (($temp==(i64)60) || ($temp==(i64)61)) {
        qq_lib$jeval((*p).a);
        if (((i64)(*p).tag == (i64)61)) {
            qq_lib$additem((byte*)".");
        }
;
        qq_lib$additem((byte*)"[");
        qq_lib$jeval((*p).b);
        qq_lib$additem((byte*)"]");
    }
    else if (($temp==(i64)62)) {
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)"{");
        qq_lib$jeval((*p).b);
        qq_lib$additem((byte*)"}");
    }
    else if (($temp==(i64)59)) {
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)".");
        qq_lib$jeval((*p).b);
    }
    else if (($temp==(i64)197)) {
        qq_lib$additem((byte*)"(");
        q = (*p).a;
        L357 :;
        while (!!(q)) {
            qq_lib$jeval(q);
            q = (*q).nextunit;
            if (!!(q)) {
                qq_lib$additem((byte*)",");
            }
;
L358 :;
        }
L359 :;
        ;
        qq_lib$additem((byte*)")");
    }
    else if (($temp==(i64)198) || ($temp==(i64)199)) {
        qq_lib$additem((byte*)"[");
        q = (*p).a;
        L360 :;
        while (!!(q)) {
            qq_lib$jeval(q);
            q = (*q).nextunit;
            if (!!(q)) {
                qq_lib$additem((byte*)",");
            }
;
L361 :;
        }
L362 :;
        ;
        qq_lib$additem((byte*)"]");
    }
    else if (($temp==(i64)2)) {
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)":=");
        qq_lib$jeval((*p).b);
    }
    else if (($temp==(i64)41)) {
        qq_lib$additem(qq_dummyshow$strmode((i64)(*p).mode,(i64)0));
    }
    else if (($temp==(i64)43)) {
        qq_lib$additem(qq_dummyshow$strmode((i64)(*p).mode,(i64)0));
        qq_lib$additem((byte*)"(");
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)")");
    }
    else if (($temp==(i64)5)) {
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)":");
        qq_lib$jeval((*p).b);
    }
    else if (($temp==(i64)67)) {
        qq_lib$additem((byte*)"&");
        qq_lib$jeval((*p).a);
    }
    else if (($temp==(i64)66)) {
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)"^");
    }
    else if (($temp==(i64)68)) {
        qq_lib$additem((byte*)"^");
        qq_lib$jeval((*p).a);
    }
    else if (($temp==(i64)34)) {
        qq_lib$additem((byte*)"nil");
    }
    else if (($temp==(i64)48)) {
        qq_lib$jeval((*p).a);
        qq_lib$additem((byte*)".$");
    }
    else if (($temp==(i64)46)) {
        qq_lib$additem((byte*)"CMPCHAIN:");
        q = (*p).a;
        qq_lib$jeval(q);
        for (i=(i64)1;i<=(i64)4;++i) {
L363 :;
            q = (*q).nextunit;
            if (((i64)(*p).cmpgenop[(i)-1] == (i64)0)) {
                goto L365 ;
            }
;
            qq_lib$additem(qq_tables$jtagnames[((i64)(*p).cmpgenop[(i)-1])]);
            qq_lib$jeval(q);
L364 :;
        }
L365 :;
        ;
    }
    else if (($temp==(i64)45)) {
        qq_lib$additem((byte*)"map(");
        qq_lib$jeval((*p).a);
        q = (*p).b;
        qq_lib$additem((byte*)",");
        qq_lib$jeval(q);
        if (!!((q = (*q).nextunit))) {
            qq_lib$additem((byte*)",");
            qq_lib$jeval(q);
        }
;
        qq_lib$additem((byte*)")");
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str(qq_tables$jtagnames[((i64)(*p).tag)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$loaderror((byte*)"CAN'T DO JEVAL:",qq_tables$jtagnames[((i64)(*p).tag)],(byte*)"");
    }
    };
}

void qq_lib$additem(u8 *s) {
        u8 *  d;
        i64 lastchar;
        i64 nextchar;
    d = (*qq_lib$exprstr).strptr;
    if (!!((i64)(*qq_lib$exprstr).length)) {
        lastchar = (i64)(u64)(*((d + (i64)(*qq_lib$exprstr).length) - (i64)1));
        nextchar = (i64)(u64)(*s);
        if ((!!(qq_lib$isalphanum(lastchar)) && !!(qq_lib$isalphanum(nextchar)))) {
            mlib$strbuffer_add((struct mlib$strbuffer *)qq_lib$exprstr,(byte*)" ",(i64)-1);
        }
;
    }
;
    mlib$strbuffer_add((struct mlib$strbuffer *)qq_lib$exprstr,s,(i64)-1);
}

static i64 qq_lib$isalphanum(i64 c) {
    if (((((c >= (i64)65) && (c <= (i64)90)) || ((c >= (i64)97) && (c <= (i64)122))) || ((c >= (i64)48) && (c <= (i64)57)))) {
        return (i64)1;
    }
;
    return (i64)0;
}

u8 *qq_lib$getopcname(i64 opc) {
        u8 *  s;
    s = qq_tables$jshortnames[(opc)];
    if ((s == 0)) {
        s = (qq_tables$jtagnames[(opc)] + (i64)1);
    }
;
    return s;
}

void qq_lib$convertstring(u8 *s,u8 *t) {
        i64 c;
    L366 :;
    while (!!((c = (i64)(u64)(*(s)++)))) {
        switch (c) {
        case 34:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = '"';
            }
            break;
        case 10:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 'n';
            }
            break;
        case 13:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 'c';
            }
            break;
        case 9:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = 't';
            }
            break;
        case 92:;
            {
                (*(t)++) = (u64)92u;
                (*(t)++) = (u64)92u;
            }
            break;
        case 7:;
        case 8:;
        case 26:;
        case 27:;
            {
                (*(t)++) = '<';
                (*(t)++) = (u64)((c / (i64)10) + (i64)48);
                (*(t)++) = (u64)((c % (i64)10) + (i64)48);
                (*(t)++) = '>';
            }
            break;
        default: {
            (*(t)++) = (u64)c;
        }
        } //SW
;
L367 :;
    }
L368 :;
    ;
    (*t) = (u64)0u;
}

u8 *qq_lib$extractstringz(struct qq_decls$varrec *p) {
        struct qq_decls$objrec *  q;
    q = (*p).objptr;
    if (((i64)(*p).tag != (i64)12)) {
        qq_lib$pcerror((byte*)"estrz?");
    }
;
    if (!!((*q).length)) {
        return mlib$pcm_copyheapstring(qq_lib$convtostringz((*q).strptr,(*q).length));
    }
    else {
        return mlib$pcm_copyheapstring((byte*)"");
    }
;
}

struct qq_decls$unitrec *qq_lib$createavnamex(struct qq_decls$strec *owner) {
        struct qq_decls$unitrec *  p;
        struct qq_decls$strec *  d;
    p = qq_lib$createavname();
    qq_resolve$resolvename(owner,p,(i64)0);
    d = (*p).def;
    if (((i64)(*d).nameid == (i64)12)) {
        ++(qq_pclgen$nproclocals);
        (*d).index = qq_pclgen$nproclocals;
        (*qq_pclgen$pproclocals) = qq_pclgen$nproclocals;
    }
;
    return p;
}

void qq_lib$storemode(struct qq_decls$strec *owner,i64 m,i16 *p) {
        struct qq_decls$userxrec *  q;
    (*p) = m;
    if ((m >= (i64)0)) {
        return;
    }
;
    q = (struct qq_decls$userxrec *)mlib$pcm_alloc((i64)24);
    (*q).owner = owner;
    if ((owner == 0)) {
        qq_lib$serror((byte*)"STOREMODE/OWNER=0");
    }
;
    (*q).pmode = p;
    (*q).nextmode = (struct qq_decls$userxrec *)qq_tables$userxmodelist;
    qq_tables$userxmodelist = (struct qq_decls$userxrec *)q;
}

i64 qq_lib$nextpoweroftwo(i64 x) {
        i64 a;
    if ((x == (i64)0)) {
        return (i64)0;
    }
;
    a = (i64)1;
    L369 :;
    while ((a < x)) {
        a <<= (i64)1;
L370 :;
    }
L371 :;
    ;
    return a;
}

i64 *qq_lib$raiseexception(i64 exceptno) {
        struct qq_decls$varrec *  stackend;
        struct qq_decls$varrec *  oldsptr;
    stackend = &qq_decls$varstack[((i64)1)-1];
    oldsptr = qq_decls$sptr;
    L372 :;
    while (1) {
        if ((qq_decls$sptr <= stackend)) {
            qq_decls$sptr = oldsptr;
            qq_lib$default_exception(exceptno);
        }
;
        if ((((i64)(*qq_decls$sptr).tag == (i64)22) && ((exceptno == (i64)0) || ((i64)(*qq_decls$sptr).exceptiontype == exceptno)))) {
            goto L373 ;
        }
;
        if (!!((i64)(*qq_decls$sptr).hasref)) {
            qq_vars$var_unshareu(qq_decls$sptr);
        }
;
        --(qq_decls$sptr);
    }
L373 :;
    ;
    qq_decls$frameptr = ((byte *)qq_decls$sptr + (i64)(*qq_decls$sptr).frameoffset);
    return (i64 *)(*qq_decls$sptr).ptr;
}

void qq_lib$raise_error(i64 error_no) {
    (*++(qq_decls$sptr)).tagx = (i64)1;
    (*qq_decls$sptr).value = error_no;
    qq_decls$err_pcptr = qq_decls$pcptr;
    qq_decls$pcptr = qq_decls$raiseseq;
}

static void qq_lib$default_exception(i64 exceptno) {
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"DEFAULT EXCEPTION HANDLER",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    if ((exceptno==(i64)1)) {
        qq_lib$pcerror((byte*)"PC/ERROR");
    }
    else if ((exceptno==(i64)2)) {
        qq_lib$pcerror((byte*)"USER/ERROR");
    }
    else if ((exceptno==(i64)3)) {
        qq_decls$pcptr = qq_decls$err_pcptr;
        qq_lib$pcerror((byte*)"PCUSTYPEDEF");
    }
    else if ((exceptno==(i64)4)) {
        qq_decls$pcptr = qq_decls$err_pcptr;
        qq_lib$pcerror((byte*)"PCMXTYPESDEF");
    }
    else if ((exceptno==(i64)5)) {
        qq_decls$pcptr = qq_decls$err_pcptr;
        qq_lib$pcerror((byte*)"EXCEPTION/DIVIDE BY ZERO");
    }
    else if ((exceptno==(i64)6)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"STOPMODULEERROR",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else if ((exceptno==(i64)7)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"BOUNDSERROR",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"Exception:",NULL);
        msysc$m_print_str(qq_tables$errornames[(exceptno)-1],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    exit((i64)1);
}

i64 qq_lib$testelem(byte (*p)[],i64 n) {
    if (!!(((i64)(*p)[((n >> (i64)3))] & (i64)qq_lib$bytemasks[((n & (i64)7))]))) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

void qq_lib$setelem(byte (*p)[],i64 n) {
    (*p)[((n >> (i64)3))] |= (byte)(i64)qq_lib$bytemasks[((n & (i64)7))];
}

void qq_lib$setelemblock(byte (*p)[],i64 a,i64 b) {
        i64 ax;
        i64 bx;
        i64 nwords;
        i64 nx;
        i64 alast;
        i64 bfirst;
        u64 *  q;
        i64 $av_1;
        i64 i;
    if ((a > b)) {
        return;
    }
;
    ax = (a & (i64)-64);
    bx = ((b & (i64)-64) + (i64)64);
    nx = ax;
    alast = (bfirst = (i64)-1);
    nwords = ((bx - ax) / (i64)64);
    if ((nwords == (i64)1)) {
        if (((ax != a) || (b != (bx - (i64)1)))) {
            for (i=a;i<=b;++i) {
L374 :;
                qq_lib$setelem(p,i);
L375 :;
            }
L376 :;
            ;
            return;
        }
;
    }
    else {
        if ((ax != a)) {
            --(nwords);
            nx = (ax + (i64)64);
            alast = (nx - (i64)1);
        }
;
        if ((b != (bx - (i64)1))) {
            --(nwords);
            bfirst = (b & (i64)-64);
        }
;
    }
;
    if ((alast >= (i64)0)) {
        for (i=a;i<=alast;++i) {
L377 :;
            qq_lib$setelem(p,i);
L378 :;
        }
L379 :;
        ;
    }
;
    q = (u64 *)&(*p)[((nx >> (i64)3))];
    $av_1 = nwords;
    while ($av_1-- > 0) {
L380 :;
        (*q) = (u64)18446744073709551615u;
        ++(q);
L381 :;
    }
L382 :;
    ;
    if ((bfirst >= (i64)0)) {
        for (i=bfirst;i<=b;++i) {
L383 :;
            qq_lib$setelem(p,i);
L384 :;
        }
L385 :;
        ;
    }
;
}

i64 qq_lib$ispoweroftwo(i64 x) {
        i64 a;
        i64 n;
        i64 $av_1;
    a = (i64)1;
    n = (i64)0;
    $av_1 = (i64)60;
    while ($av_1-- > 0) {
L386 :;
        ++(n);
        a = (a << (i64)1);
        if ((a == x)) {
            return n;
        }
;
L387 :;
    }
L388 :;
    ;
    return (i64)0;
}

void qq_lib$deleteunit(struct qq_decls$unitrec *p,struct qq_decls$unitrec *q) {
        struct qq_decls$unitrec *  r;
    r = (*p).nextunit;
    (*p) = (*q);
    (*p).nextunit = r;
}

u8 *qq_lib$getenumname(i64 m,i64 index) {
        struct qq_decls$strec *  e;
    e = qq_tables$ttfields[(m)];
    L389 :;
    while (!!(e)) {
        if (((((i64)(*e).nameid == (i64)17) && ((i64)(*e).mode == m)) && ((*e).index == index))) {
            return (*e).name;
        }
;
L390 :;
        e = (*e).nextdef;
L392 :;
            }
L391 :;
    ;
    return (byte*)"?";
}

// START
void qq_lib$start(void) {

}

// START
void qq_lists$start(void) {

    qq_lists$emptylist = qq_vars$obj_new();
    (*qq_lists$emptylist).lower16 = (i64)1;
    (*qq_lists$emptylist).objtype = (i64)0;
}

void qq_lists$var_empty_list(i64 lower,struct qq_decls$varrec *dest) {
    (*dest).objptr = qq_lists$obj_newlist((i64)0,lower,0);
    (*dest).tagx = (i64)269;
}

void qq_lists$var_make_list(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n,i64 lower) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  b;
        i64 $av_1;
    p = qq_lists$obj_newlist(n,lower,0);
    b = (*p).varptr;
    if ((!!(n) && !!(a))) {
        $av_1 = n;
        while ($av_1-- > 0) {
L393 :;
            (*b) = (*a);
            ++(a);
            ++(b);
L394 :;
        }
L395 :;
        ;
    }
;
    (*dest).tagx = (i64)269;
    (*dest).objptr = p;
}

struct qq_decls$objrec *qq_lists$obj_newlist(i64 n,i64 lower,struct qq_decls$varrec *defval) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  a;
        i64 $av_1;
        i64 $av_2;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    if (!((lower >= (i64)-32768 && lower <= (i64)32767))) {
        qq_lib$pcerror((byte*)"List LWB not 16-bit");
    }
;
    (*p).lower16 = lower;
    (*p).length = n;
    (*p).objtype = (i64)0;
    if (!!(n)) {
        (*p).varptr = (a = (struct qq_decls$varrec *)mlib$pcm_alloc((n * (i64)16)));
        (*p).alloc64 = (mlib$allocbytes / (i64)16);
        if ((!!(defval) && ((i64)(*defval).tag != (i64)0))) {
            $av_1 = n;
            while ($av_1-- > 0) {
L396 :;
                if (!!((i64)(*defval).hasref)) {
                    ++((*(*defval).objptr).refcount);
                }
;
                (*a) = (*defval);
                ++(a);
L397 :;
            }
L398 :;
            ;
        }
        else {
            $av_2 = n;
            while ($av_2-- > 0) {
L399 :;
                (*a).tagx = (i64)0;
                ++(a);
L400 :;
            }
L401 :;
            ;
        }
;
    }
;
    return p;
}

void qq_lists$obj_free_list(struct qq_decls$objrec *p) {
        struct qq_decls$varrec *  q;
        i64 $av_1;
    q = (*p).varptr;
    $av_1 = (*p).length;
    while ($av_1-- > 0) {
L402 :;
        if (!!((i64)(*q).hasref)) {
            qq_vars$var_unshareu(q);
        }
;
        ++(q);
L403 :;
    }
L404 :;
    ;
    if (!!((*p).length)) {
        mlib$pcm_free((*p).varptr,((*p).alloc64 * (i64)16));
    }
;
    mlib$pcm_free32(p);
}

void qq_lists$var_getix_list(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  q;
        u64 offset;
        i64 lower;
    q = (*a).objptr;
    lower = (i64)(*q).lower16;
    offset = (u64)(index - lower);
    if ((offset >= (u64)(*q).length)) {
        qq_lib$pcerror((byte*)"getlist[int] bounds");
    }
;
    (*a) = (*((*q).varptr + (i64)offset));
    if (!!((i64)(*a).hasref)) {
        ++((*(*a).objptr).refcount);
    }
;
}

void qq_lists$var_getslice_list(struct qq_decls$varrec *a,i64 i,i64 j) {
        struct qq_decls$varrec v;
        i64 alower;
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    alower = (i64)(*p).lower16;
    if ((((i < alower) || (j > (((*p).length + alower) - (i64)1))) || (i > j))) {
        qq_lib$pcerror((byte*)"list/slice bounds");
    }
;
    q = qq_vars$obj_new();
    v.objptr = q;
    (*q).objtype = (i64)1;
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)1,msysc$m_getdotindex((i64)(*p).flags,(i64)1));
    (*q).lower16 = (i64)1;
    (*q).varptr = (((*p).varptr + i) - alower);
        {i64 $temp = (i64)(*p).objtype;
if (($temp==(i64)1)) {
        (*q).objptr2 = (*p).objptr2;
        qq_vars$obj_shareu((*q).objptr2);
    }
    else if (($temp==(i64)2)) {
        (*q).objptr2 = 0;
        (*q).objtype = (i64)2;
    }
    else {
        (*q).objptr2 = p;
        ++((*p).refcount);
    }
    };
    (*q).length = ((j - i) + (i64)1);
    (*a).objptr = q;
}

void qq_lists$var_getixref_list(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$varrec *  p;
        struct qq_decls$objrec *  q;
        u64 offset;
        struct qq_decls$varrec v;
    q = (*a).objptr;
    offset = (u64)(index - (i64)(*q).lower16);
    if ((offset >= (u64)(*q).length)) {
        if (((i64)offset < (i64)0)) {
            qq_lib$pcerror((byte*)"&list[int] lwb");
        }
        else if (((i64)offset == (*q).length)) {
            if (((i64)(*q).objtype != (i64)0)) {
                qq_lib$pcerror((byte*)"Can't extend slice/ext");
            }
;
            v.tagx = (i64)0;
            qq_lists$obj_append_list(q,&v);
        }
        else {
            qq_lib$pcerror((byte*)"putlist[int] bounds");
        }
;
    }
;
    p = ((*q).varptr + (i64)offset);
    (*a).tagx = (i64)17;
    (*a).varptr = p;
}

void qq_lists$var_putix_list(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        struct qq_decls$varrec *  dest;
        struct qq_decls$objrec *  q;
        u64 offset;
    q = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*q).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"List not mutable");
    }
;
    offset = (u64)(index - (i64)(*q).lower16);
    if ((offset >= (u64)(*q).length)) {
        if (((i64)offset < (i64)0)) {
            qq_lib$pcerror((byte*)"putlist[int] lwb");
        }
        else if (((i64)offset == (*q).length)) {
            if (((i64)(*q).objtype != (i64)0)) {
                qq_lib$pcerror((byte*)"Can't extend slice/ext");
            }
;
            qq_lists$obj_append_list(q,x);
            return;
        }
        else {
            qq_lib$pcerror((byte*)"putlist[int] bounds");
        }
;
    }
;
    dest = ((*q).varptr + (i64)offset);
    if (!!((i64)(*dest).hasref)) {
        qq_vars$var_unshareu(dest);
    }
;
    (*dest) = (*x);
}

void qq_lists$var_putslice_list(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x) {
        struct qq_decls$varrec *  r;
        struct qq_decls$varrec *  s;
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 length;
        i64 sublength;
        i64 $av_1;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"List not mutable");
    }
;
    length = (*p).length;
    if ((((i < (i64)1) || (j > (*p).length)) || (i > j))) {
        qq_lib$pcerror((byte*)"list/slice bounds");
    }
;
    sublength = ((j - i) + (i64)1);
    q = (*x).objptr;
    if (((*q).length < sublength)) {
        qq_lib$pcerror((byte*)"substr too short");
    }
;
    r = (((*p).varptr + i) - (i64)1);
    s = (*q).varptr;
    $av_1 = sublength;
    while ($av_1-- > 0) {
L405 :;
        (*r) = (*s);
        if (!!((i64)(*r).hasref)) {
            ++((*(*r).objptr).refcount);
        }
;
        ++(r);
        ++(s);
L406 :;
    }
L407 :;
    ;
}

static void qq_lists$obj_append_list(struct qq_decls$objrec *a,struct qq_decls$varrec *x) {
        i64 n;
    if (((i64)(*a).objtype != (i64)0)) {
        qq_lib$pcerror((byte*)"Can't extend slice");
    }
;
    if (!(!!(msysc$m_getdotindex((i64)(*a).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"list/append not mutable");
    }
;
    n = ((*a).length + (i64)1);
    if ((n > (*a).alloc64)) {
        qq_lists$obj_resize_list(a,n);
    }
    else {
        (*a).length = n;
    }
;
    if (!!(x)) {
        (*(((*a).varptr + n) - (i64)1)) = (*x);
    }
;
}

void qq_lists$obj_resize_list(struct qq_decls$objrec *p,i64 n) {
        struct qq_decls$varrec *  q;
        u32 allocated;
    if ((n <= (*p).alloc64)) {
        (*p).length = n;
    }
    else {
        q = (struct qq_decls$varrec *)mlib$pcm_alloc((n * (i64)16));
        allocated = (mlib$allocbytes / (i64)16);
        if (!!((*p).length)) {
            memcpy(q,(*p).varptr,(u64)((*p).length * (i64)16));
            mlib$pcm_free((*p).varptr,((*p).alloc64 * (i64)16));
        }
;
        (*p).varptr = q;
        (*p).length = n;
        (*p).alloc64 = (i64)allocated;
    }
;
}

void qq_lists$var_appendto_list(struct qq_decls$varrec *a,struct qq_decls$varrec *x) {
    qq_lists$obj_append_list((*a).objptr,x);
}

void qq_lists$var_dupl_list(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        struct qq_decls$varrec *  plist;
        struct qq_decls$varrec *  qlist;
        i64 $av_1;
    p = (*a).objptr;
    q = qq_vars$obj_new();
    (*q) = (*p);
    (*q).refcount = (i64)1;
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)1,(u64)1u);
    (*q).objtype = (i64)0;
    (*a).objptr = q;
    if (((*q).length == (i64)0)) {
        return;
    }
;
    qlist = ((*q).varptr = (struct qq_decls$varrec *)mlib$pcm_alloc(((*p).length * (i64)16)));
    (*q).alloc64 = (mlib$allocbytes / (i64)16);
    plist = (*p).varptr;
    $av_1 = (*q).length;
    while ($av_1-- > 0) {
L408 :;
        (*qlist) = (*plist);
        if (((i64)(*qlist).tag == (i64)15)) {
            if (!!((i64)(*qlist).hasref)) {
                ++((*(*qlist).objptr).refcount);
            }
;
        }
        else {
            if (!!((i64)(*qlist).hasref)) {
                qq_vars$var_duplu(qlist);
            }
;
        }
;
        ++(qlist);
        ++(plist);
L409 :;
    }
L410 :;
    ;
}

void qq_lists$var_mul_list(struct qq_decls$varrec *p,i64 m) {
        i64 oldlength;
        i64 newlength;
        i64 n;
        struct qq_decls$objrec *  q;
        struct qq_decls$objrec *  r;
        struct qq_decls$varrec *  a;
        struct qq_decls$varrec *  b;
        i64 $av_1;
    q = (*p).objptr;
    oldlength = (*q).length;
    newlength = (oldlength * m);
    if ((oldlength == (i64)0)) {
        return;
    }
;
    if ((newlength < (i64)0)) {
        qq_lib$pcerror((byte*)"list*int <0");
    }
    else if ((newlength == (i64)0)) {
        (*p).objptr = qq_lists$obj_newlist((i64)0,(i64)(*q).lower16,0);
        return;
    }
;
    r = qq_lists$obj_newlist(newlength,(i64)(*q).lower16,0);
    a = (*r).varptr;
    b = (*q).varptr;
    n = (i64)0;
    $av_1 = newlength;
    while ($av_1-- > 0) {
L411 :;
        (*a) = (*b);
        if (!!((i64)(*a).hasref)) {
            ++((*(*a).objptr).refcount);
        }
;
        ++(a);
        if ((oldlength > (i64)1)) {
            ++(b);
            if ((++(n) == oldlength)) {
                b = (*q).varptr;
                n = (i64)0;
            }
;
        }
;
L412 :;
    }
L413 :;
    ;
    (*p).objptr = r;
}

i64 qq_lists$var_equal_list(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 xlen;
        i64 ylen;
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
        struct qq_decls$varrec *  a;
        struct qq_decls$varrec *  b;
        i64 $av_1;
    px = (*x).objptr;
    py = (*y).objptr;
    if ((px == py)) {
        return (i64)1;
    }
;
    xlen = (*px).length;
    ylen = (*py).length;
    if ((xlen != ylen)) {
        return (i64)0;
    }
;
    if ((xlen == (i64)0)) {
        return (i64)1;
    }
;
    a = (*px).varptr;
    b = (*py).varptr;
    $av_1 = xlen;
    while ($av_1-- > 0) {
L414 :;
        if ((qq_vars$var_equal(a,b) == (i64)0)) {
            return (i64)0;
        }
;
        ++(a);
        ++(b);
L415 :;
    }
L416 :;
    ;
    return (i64)1;
}

void qq_lists$var_concatto_list(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$varrec *  d;
        i64 alen;
        i64 blen;
        i64 newlen;
        struct qq_decls$objrec *  pa;
        struct qq_decls$objrec *  pb;
        i64 $av_1;
        i64 $av_2;
    pa = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*pa).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"concatlist/not mut");
    }
;
    pb = (*b).objptr;
    alen = (*pa).length;
    blen = (*pb).length;
    if ((alen == (i64)0)) {
        if (!!(blen)) {
            qq_lists$obj_resize_list(pa,blen);
            d = (*pa).varptr;
            memcpy(d,(*pb).varptr,(u64)(blen * (i64)16));
            $av_1 = blen;
            while ($av_1-- > 0) {
L417 :;
                if (!!((i64)(*d).hasref)) {
                    ++((*(*d).objptr).refcount);
                }
;
                ++(d);
L418 :;
            }
L419 :;
            ;
        }
;
    }
    else if (!!(blen)) {
        newlen = (alen + blen);
        qq_lists$obj_resize_list(pa,newlen);
        d = ((*pa).varptr + alen);
        memcpy(d,(*pb).varptr,(u64)(blen * (i64)16));
        $av_2 = blen;
        while ($av_2-- > 0) {
L420 :;
            if (!!((i64)(*d).hasref)) {
                ++((*(*d).objptr).refcount);
            }
;
            ++(d);
L421 :;
        }
L422 :;
        ;
    }
;
}

i64 qq_lists$var_inx_list(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 n;
        i64 lowerm1;
        struct qq_decls$varrec *  x;
        i64 i;
    n = (*(*b).objptr).length;
    lowerm1 = ((i64)(*(*b).objptr).lower16 - (i64)1);
    x = (*(*b).objptr).varptr;
    for (i=(i64)1;i<=n;++i) {
L423 :;
        if ((qq_vars$var_equal(a,x) == (i64)1)) {
            return (i + lowerm1);
        }
;
        ++(x);
L424 :;
    }
L425 :;
    ;
    return (i64)(-9223372036854775807-1);
}

void qq_lists$var_nextiter_list(struct qq_decls$varrec *a,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    q = (*p).objptr2;
    if (((i64)(*p).iterpos >= (i64)(*p).iterupper)) {
        (*dest).tagx = (i64)0;
        return;
    }
;
    ++((*p).iterpos);
    (*dest) = (*(((*q).varptr + (i64)(*p).iterpos) - (i64)(*q).lower16));
    if (!!((i64)(*dest).hasref)) {
        ++((*(*dest).objptr).refcount);
    }
;
}

void qq_modules$readprojectfile(u8 *filename) {
        i64 fileno;
        i64 headerdir;
        i64 dir;
        i64 oldsyslib;
        u8 *  basefile;
    if (!(!!(mlib$checkfile(filename)))) {
        qq_lib$loaderror((byte*)"Can't find main module or project: ##",filename,(byte*)"");
    }
;
    if (!!(mlib$eqstring(mlib$convlcstring(mlib$extractext(filename,(i64)0)),(byte*)"qa"))) {
        filename = qq_modules$loadqafile(filename,0);
    }
;
    fileno = qq_modules$getsupportfile(filename,(byte*)"",(byte*)"",(i64)0,(i64)0);
    basefile = mlib$extractbasefile(qq_decls$sourcefilenames[(fileno)-1]);
    qq_decls$moduletable[((i64)0)].name = basefile;
    qq_decls$moduletable[((i64)0)].fileno = fileno;
    qq_modules$initheadervars();
    qq_decls$headermode = (i64)1;
    headerdir = (i64)0;
    qq_decls$stprogram = qq_names$createdupldef(0,qq_lex$addnamestr((byte*)"$prog"),(i64)1);
    qq_decls$moduletable[((i64)0)].stmodule = qq_decls$stprogram;
    qq_modules$addfirstsubprogram(basefile,fileno);
    qq_lex$startlex(fileno,(i64)0);
    L426 :;
    while (1) {
        qq_lex$lex();
        qq_parse$skipsemi();
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)133)) {
            headerdir = (i64)1;
            dir = (i64)qq_decls$lx.subcode;
            qq_modules$dirpos = (i64)qq_decls$lx.pos;
            qq_lex$lex();
            if ((dir==(i64)1)) {
                qq_modules$readmoduledir();
                qq_modules$headervars[((i64)8)-1] = (byte*)"";
            }
            else if ((dir==(i64)4)) {
                oldsyslib = qq_modules$issyslib;
                qq_modules$issyslib = (i64)1;
                qq_modules$readmoduledir();
                qq_modules$issyslib = oldsyslib;
                qq_modules$headervars[((i64)8)-1] = (byte*)"";
            }
            else if ((dir==(i64)3)) {
                qq_modules$altpathx = (byte*)"";
                qq_modules$issyslib = (i64)0;
                qq_modules$readsubprogram();
            }
            else if ((dir==(i64)6)) {
                if (((i64)(u64)(*qq_modules$importpathx) == (i64)0)) {
                    qq_modules$importpathx = qq_modules$headervars[((i64)1)-1];
                }
;
                qq_modules$issyslib = (i64)1;
                qq_modules$readsubprogram();
            }
            else if ((dir==(i64)2)) {
                if ((((i64)qq_decls$lx.symbol == (i64)89) && !!(mlib$eqstring((*qq_decls$lx.symptr).name,(byte*)"qlib")))) {
                    goto L428 ;
;
                }
;
                qq_modules$issyslib = (i64)0;
                qq_modules$altpathx = (byte*)"";
                qq_modules$readimport();
            }
            else if ((dir==(i64)5)) {
                //$sysimport:
L428 :;
;
                if (((i64)(u64)(*qq_modules$importpathx) == (i64)0)) {
                    qq_modules$importpathx = qq_modules$headervars[((i64)1)-1];
                }
;
                qq_modules$issyslib = (i64)1;
                qq_modules$altpathx = (byte*)"";
                qq_modules$readimport();
            }
            else if ((dir==(i64)7)) {
                qq_modules$altpathx = qq_modules$fixpath(qq_modules$readvar());
            }
            else if ((dir==(i64)8)) {
                qq_modules$importpathx = qq_modules$fixpath(qq_modules$readvar());
                qq_modules$subprogpath = (!!((u64)(*qq_modules$importpathx)) ? qq_modules$importpathx : qq_modules$headerpathx);
            }
            else {
                qq_lib$loaderror((byte*)"Hdr directive not ready:##",qq_tables$headerdirnames[(dir)-1],(byte*)"");
            }
;
            qq_parse$checksymbol((i64)6);
        }
        else if (($temp==(i64)6)) {
        }
        else if (($temp==(i64)76)) {
            goto L427 ;
        }
        else {
            if (!!(qq_lex$sourcelevel)) {
                qq_modules$setmixedimport();
                qq_lex$unstacksource();
            }
            else {
                qq_modules$setmixedprogram(basefile);
                goto L427 ;
            }
;
        }
        };
    }
L427 :;
    ;
    if ((qq_decls$nmodules == (i64)0)) {
        qq_lib$loaderror((byte*)"No modules specified",(byte*)"",(byte*)"");
    }
;
    qq_modules$addsyslib();
}

static void qq_modules$initheadervars(void) {
        i64 i;
    for (i=(i64)1;i<=(i64)11;++i) {
L429 :;
        qq_modules$headervars[(i)-1] = (byte*)"";
L430 :;
    }
L431 :;
    ;
    qq_modules$headervars[((i64)1)-1] = (byte*)"c:/qxqq/";
    qq_modules$headervars[((i64)2)-1] = (byte*)"";
    qq_modules$subprogpath = (qq_modules$headerpathx = (qq_modules$headervars[((i64)3)-1] = mlib$pcm_copyheapstring(qq_decls$sourcefilepaths[((i64)1)-1])));
    qq_modules$headervars[((i64)5)-1] = (byte*)"1";
    qq_modules$headervars[((i64)8)-1] = (byte*)"1";
}

static void qq_modules$readmoduledir(void) {
        u8 *  modulename;
        u8 *  modulefilespec;
        struct qq_decls$strec *  stalias;
    qq_parse$checksymbol((i64)89);
    modulename = (modulefilespec = mlib$pcm_copyheapstring((*qq_decls$lx.symptr).name));
    mlib$convlcstring(modulename);
    stalias = 0;
    qq_lex$lex();
    if ((((i64)qq_decls$lx.symbol == (i64)89) && !!(mlib$eqstring((*qq_decls$lx.symptr).name,(byte*)"as")))) {
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)89)) {
            stalias = (struct qq_decls$strec *)qq_decls$lx.symptr;
            qq_lex$lex();
        }
        else {
            stalias = qq_lex$addnamestr(qq_modules$readvar());
        }
;
    }
;
    qq_modules$addmodule(modulename,stalias);
}

static void qq_modules$addmodule(u8 *modulename,struct qq_decls$strec *stalias) {
        struct qq_decls$modulerec *  pm;
        struct qq_decls$subprogrec *  ps;
        i64 i;
    for (i=(i64)1;i<=qq_decls$nmodules;++i) {
L432 :;
        if (!!(mlib$eqstring(qq_decls$moduletable[(i)].name,modulename))) {
            qq_lib$loaderror((byte*)"Duplicate module name: # (Line:#)",modulename,(byte*)"");
        }
;
L433 :;
    }
L434 :;
    ;
    for (i=(i64)1;i<=qq_decls$nsubprogs;++i) {
L435 :;
        if (!!(mlib$eqstring(qq_decls$subprogtable[(i)].name,modulename))) {
            qq_lib$loaderror((byte*)"Clashing subprog/module name: # (Line:#)",modulename,(byte*)"");
        }
;
L436 :;
    }
L437 :;
    ;
    if ((qq_decls$nmodules >= (i64)100)) {
        qq_lib$loaderror((byte*)"Too many modules",modulename,(byte*)"");
    }
;
    pm = (struct qq_decls$modulerec *)&qq_decls$moduletable[(++(qq_decls$nmodules))];
    (*pm).moduleno = qq_decls$nmodules;
    (*pm).name = mlib$pcm_copyheapstring(modulename);
    (*pm).subprogno = qq_decls$nsubprogs;
    (*pm).stmodule = (qq_decls$stmodule = qq_names$createnewmoduledef(qq_decls$stprogram,qq_lex$addnamestr(modulename),(i64)3));
    (*pm).path = (!!((u64)(*qq_modules$altpathx)) ? qq_modules$altpathx : qq_modules$subprogpath);
    (*pm).issyslib = qq_modules$issyslib;
    (*qq_decls$stmodule).moduleno = qq_decls$nmodules;
    qq_decls$moduletosub[(qq_decls$nmodules)] = qq_decls$nsubprogs;
    ps = &qq_decls$subprogtable[(qq_decls$nsubprogs)];
    if (((i64)(*ps).startmodule == (i64)0)) {
        (*ps).startmodule = ((*ps).endmodule = qq_decls$nmodules);
    }
    else {
        (*ps).endmodule = qq_decls$nmodules;
    }
;
    if (!!(stalias)) {
        qq_lib$loaderror((byte*)"MODULE/AS NOT READY",(byte*)"",(byte*)"");
    }
;
}

static void qq_modules$addsubprogram(u8 *subprogname,i64 fileno) {
        struct qq_decls$subprogrec *  ps;
        i64 i;
    if ((qq_decls$nsubprogs >= (i64)30)) {
        qq_lib$loaderror((byte*)"Too many subprograms",subprogname,(byte*)"");
    }
;
    for (i=(i64)1;i<=qq_decls$nsubprogs;++i) {
L438 :;
        if (!!(mlib$eqstring(qq_decls$subprogtable[(i)].name,subprogname))) {
            qq_lib$loaderror((byte*)"Duplicate subprog name: # (Line:#)",subprogname,(byte*)"");
        }
;
L439 :;
    }
L440 :;
    ;
    ps = (struct qq_decls$subprogrec *)&qq_decls$subprogtable[(++(qq_decls$nsubprogs))];
    (*ps).name = mlib$pcm_copyheapstring(subprogname);
    qq_modules$subprogpath = ((*ps).path = (!!((u64)(*qq_modules$importpathx)) ? qq_modules$importpathx : qq_modules$subprogpath));
    qq_decls$stsubprog = qq_names$createnewmoduledef(qq_decls$stprogram,qq_lex$addnamestr(subprogname),(i64)2);
    (*qq_decls$stsubprog).subprogno = qq_decls$nsubprogs;
    (*ps).stsubprog = qq_decls$stsubprog;
    (*ps).fileno = fileno;
    (*ps).issyslib = qq_modules$issyslib;
}

static void qq_modules$addfirstsubprogram(u8 *progname,i64 fileno) {
        struct qq_decls$subprogrec *  ps;
    qq_decls$nsubprogs = (i64)1;
    ps = (struct qq_decls$subprogrec *)&qq_decls$subprogtable[((i64)1)];
    (*ps).name = mlib$pcm_copyheapstring(progname);
    (*ps).path = qq_modules$headerpathx;
    qq_decls$stsubprog = qq_names$createnewmoduledef(qq_decls$stprogram,qq_lex$addnamestr(progname),(i64)2);
    (*qq_decls$stsubprog).subprogno = (i64)1;
    (*ps).stsubprog = qq_decls$stsubprog;
    (*ps).fileno = fileno;
    qq_decls$mainmoduleno = (i64)1;
}

static void qq_modules$readsubprogram(void) {
        u8 *  subprogname;
        u8 *  subprogfilespec;
    qq_parse$checksymbol((i64)89);
    subprogname = (subprogfilespec = mlib$pcm_copyheapstring((*qq_decls$lx.symptr).name));
    mlib$convlcstring(subprogname);
    qq_lex$lex();
    if (((i64)qq_decls$lx.symbol == (i64)105)) {
        qq_lex$lex();
        qq_lex$lex();
    }
;
    qq_modules$addsubprogram(subprogname,(i64)0);
}

static void qq_modules$readimport(void) {
        u8 *  subprogname;
        u8 *  path;
        i64 fileno;
    qq_parse$checksymbol((i64)89);
    subprogname = mlib$pcm_copyheapstring((*qq_decls$lx.symptr).name);
    mlib$convlcstring(subprogname);
    qq_lex$lex();
    path = (!!((u64)(*qq_modules$importpathx)) ? qq_modules$importpathx : qq_modules$subprogpath);
    fileno = qq_modules$getsupportfile(subprogname,(byte*)"q",path,(i64)0,(i64)0);
    qq_modules$addsubprogram(subprogname,fileno);
    qq_lex$stacksource(fileno);
}

static u8 *qq_modules$readvar(void) {
        u8 *  s;
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)84)) {
        s = mlib$pcm_copyheapstring(qq_decls$lx.svalue);
    }
    else if (($temp==(i64)134)) {
        s = qq_modules$headervars[((i64)qq_decls$lx.subcode)-1];
    }
    else {
        qq_lib$loaderror((byte*)"readvar/bad expr",(byte*)"",(byte*)"");
        s = (byte*)"?";
    }
    };
    qq_lex$lex();
    return s;
}

static u8 *qq_modules$fixpath(u8 *path) {
        u8 newpath[300];
        i64 n;
    n = strlen(path);
    if ((n == (i64)0)) {
        return path;
    }
;
    if (((u64)(*((path + n) - (i64)1)) == (u64)92u || (u64)(*((path + n) - (i64)1)) == '/')) {
        return path;
    }
;
    strcpy(newpath,path);
    strcat(newpath,(byte*)"\\");
    return mlib$pcm_copyheapstring(newpath);
}

static void qq_modules$setmixedprogram(u8 *basefile) {
        u8 name[100];
        i64 oldns;
    msysc$m_print_startstr(name);
    msysc$m_print_str((byte*)"$",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(basefile,NULL);
    msysc$m_print_end();
    ;
    oldns = qq_decls$nsubprogs;
    qq_decls$nsubprogs = (i64)1;
    qq_modules$addmodule(name,0);
    qq_decls$nsubprogs = oldns;
    qq_decls$moduletable[(qq_decls$nmodules)].fileno = (i64)1;
    qq_decls$mainmoduleno = qq_decls$nmodules;
}

static void qq_modules$setmixedimport(void) {
        u8 name[100];
    msysc$m_print_startstr(name);
    msysc$m_print_str((byte*)"$",NULL);
    msysc$m_print_nogap();
    msysc$m_print_str(qq_decls$subprogtable[(qq_decls$nsubprogs)].name,NULL);
    msysc$m_print_end();
    ;
    qq_modules$addmodule(name,0);
    qq_decls$moduletable[(qq_decls$nmodules)].fileno = qq_decls$subprogtable[(qq_decls$nsubprogs)].fileno;
}

void qq_modules$loadmodules(void) {
        struct qq_decls$modulerec *  pm;
        i64 i;
    for (i=(i64)1;i<=qq_decls$nmodules;++i) {
L441 :;
        pm = (struct qq_decls$modulerec *)&qq_decls$moduletable[(i)];
        qq_modules$loadmodule((struct qq_decls$modulerec *)pm);
L442 :;
    }
L443 :;
    ;
}

static void qq_modules$loadmodule(struct qq_decls$modulerec *pm) {
    if (!!((i64)(*pm).fileno)) {
        return;
    }
;
    (*pm).fileno = qq_modules$getsupportfile((*pm).name,(byte*)"q",(*pm).path,(i64)(*pm).issyslib,(i64)0);
}

static void qq_modules$addsyslib(void) {
        i64 $av_1;
        i64 i;
        u8 *  name;
    if (!!(qq_decls$fnosys)) {
        return;
    }
;
    for (i=(i64)1;i<=qq_decls$nsubprogs;++i) {
L444 :;
        if (!!(mlib$eqstring(qq_decls$subprogtable[(i)].name,(byte*)"qlib"))) {
            return;
        }
;
L445 :;
    }
L446 :;
    ;
    qq_modules$issyslib = (i64)1;
    qq_modules$importpathx = qq_modules$headervars[((i64)1)-1];
    qq_modules$altpathx = (byte*)"";
    qq_modules$addsubprogram((byte*)"qlib",(i64)0);
    for ($av_1=(i64)1;$av_1<=(i64)12;++$av_1) {
    (name = qq_syslibs$syslibnames[($av_1)-1]);
L447 :;
        qq_modules$addmodule(mlib$extractbasefile(name),0);
L448 :;
    }L449 :;
    ;
}

i64 qq_modules$getsupportfile(u8 *filename,u8 *ext,u8 *path,i64 issyslib,i64 issupport) {
        u8 filespec[300];
        u8 filespec2[300];
        u8 *  file;
        i64 fileno;
    file = filename;
    if (!!((u64)(*ext))) {
        strcpy(filespec,mlib$addext(filename,ext));
        file = (u8 *)filespec;
    }
;
    if (!!((i64)qq_modules$freadqa)) {
        return qq_modules$loadbundledfile(file,issyslib,issupport);
    }
;
    if ((!!(issyslib) && !!(qq_decls$usesyslibs))) {
        fileno = qq_syslibs$findsyslib(file);
        if (!!(fileno)) {
            return fileno;
        }
;
    }
;
    if (!(!!(qq_modules$isabspath(file)))) {
        strcpy(filespec2,path);
        strcat(filespec2,file);
        file = (u8 *)filespec2;
    }
;
    if (((file == 0) || !(!!(mlib$checkfile(file))))) {
        qq_lib$loaderror((byte*)"Can't find file: ##",file,(byte*)"");
    }
;
    fileno = qq_modules$loadsourcefile(file);
    qq_decls$sourcefilesys[(fileno)-1] = issyslib;
    qq_decls$sourcefilesupport[(fileno)-1] = issupport;
    return fileno;
}

static i64 qq_modules$isabspath(u8 *filespec) {
        u8 *  path;
    path = mlib$extractpath(filespec);
    if ((((u64)(*path) == (u64)92u || (u64)(*path) == '/') || (((i64)(u64)(*path) != (i64)0) && ((u64)(*(path + (i64)1)) == ':')))) {
        return (i64)1;
    }
;
    return (i64)0;
}

i64 qq_modules$loadsourcefile(u8 *filespec) {
        u8 *  s;
        u8 *  basefilename;
    if ((qq_decls$nsourcefiles > (i64)200)) {
        qq_lib$loaderror((byte*)"Too many source files",(byte*)"",(byte*)"");
    }
;
    basefilename = mlib$extractfile(filespec);
    ++(qq_decls$nsourcefiles);
    qq_decls$sourcefilespecs[(qq_decls$nsourcefiles)-1] = mlib$pcm_copyheapstring(filespec);
    qq_decls$sourcefilepaths[(qq_decls$nsourcefiles)-1] = mlib$pcm_copyheapstring(mlib$extractpath(filespec));
    qq_decls$sourcefilenames[(qq_decls$nsourcefiles)-1] = mlib$pcm_copyheapstring(basefilename);
    s = (u8 *)mlib$readfile(filespec);
    if (!(!!(s))) {
        qq_lib$loaderror((byte*)"LSF can't load ",filespec,(byte*)"");
    }
;
    qq_decls$sourcefiletext[(qq_decls$nsourcefiles)-1] = s;
    qq_decls$sourcefilesizes[(qq_decls$nsourcefiles)-1] = mlib$rfsize;
    (*(s + mlib$rfsize)) = (u64)0u;
    return qq_decls$nsourcefiles;
}

static u8 *qq_modules$readfileline(u8 *s) {
        u8 str[2048];
        u8 *  t;
        i64 n;
        i64 c;
    t = str;
    n = (i64)0;
    L451 :;
        {i64 $temp = (c = (i64)(u64)(*(s)++));
if (($temp==(i64)0)) {
        --(s);
        goto L452 ;
    }
    else if (($temp==(i64)10)) {
        goto L452 ;
    }
    else {
        if ((n < (i64)2048)) {
            (*(t)++) = (u64)c;
        }
;
    }
    }goto L451 ;
L452 :;
    ;
    (*t) = (u64)0u;
    msysc$m_read_strline(str);
    ;
    return s;
}

static u8 *qq_modules$findnextlineheader(u8 *s) {
        i64 c;
    L453 :;
        {i64 $temp = (c = (i64)(u64)(*(s)++));
if (($temp==(i64)0)) {
        return 0;
    }
    else if (($temp==(i64)10)) {
        if (((((u64)(*s) == '=') && ((u64)(*(s + (i64)1)) == '=')) && ((u64)(*(s + (i64)2)) == '='))) {
            return (s + (i64)3);
        }
;
    }
    }goto L453 ;
L454 :;
    ;
    return (u8 *)0;
}

static i64 qq_modules$loadbundledfile(u8 *filespec,i64 issyslib,i64 support) {
        i64 fileno;
        u8 *  file;
        i64 i;
    file = mlib$extractfile(filespec);
    for (i=(i64)1;i<=qq_decls$nsourcefiles;++i) {
L455 :;
        if ((!!(mlib$eqstring(file,qq_decls$sourcefilenames[(i)-1])) && (support == (i64)qq_decls$sourcefilesupport[(i)-1]))) {
            return i;
        }
;
L456 :;
    }
L457 :;
    ;
    fileno = qq_syslibs$findsyslib(file);
    if (!!(fileno)) {
        return fileno;
    }
;
    qq_lib$loaderror((byte*)"Can't find bundled file: ##",filespec,(byte*)"");
    return (i64)0;
}

static u8 *qq_modules$loadqafile(u8 *filespec,u8 *builtinstr) {
        u8 *  s;
        u8 *  t;
        u8 name[100];
        u8 newfilespec[300];
        i64 sys;
        i64 support;
        i64 i;
    qq_modules$freadqa = (i64)1;
    if (!!(filespec)) {
        s = (u8 *)mlib$readfile(filespec);
        if ((s == 0)) {
            qq_lib$loaderror((byte*)"Can't find QA file ##",filespec,(byte*)"");
        }
;
        strcpy(newfilespec,mlib$extractpath(filespec));
    }
    else {
        s = builtinstr;
        newfilespec[((i64)1)-1] = (u64)0u;
    }
;
    s = qq_modules$readfileline((s + (i64)3));
    msysc$readstr(name,(i64)110,(i64)0);
    if (!(!!(mlib$eqstring(name,(byte*)"qa")))) {
        qq_lib$loaderror((byte*)"QA: bad header",(byte*)"",(byte*)"");
    }
;
    --(s);
    if (!!(qq_decls$nsourcefiles)) {
        qq_lib$loaderror((byte*)"QA/table not empty",(byte*)"",(byte*)"");
    }
;
    s = qq_modules$findnextlineheader(s);
    L458 :;
    while (1) {
        if ((s == 0)) {
            qq_lib$loaderror((byte*)"Unexpected EOF in QA file",(byte*)"",(byte*)"");
            goto L459 ;
        }
;
        s = qq_modules$readfileline(s);
        msysc$readstr(name,(i64)110,(i64)0);
        {
            sys = msysc$m_read_i64((i64)0);
            ;
            support = msysc$m_read_i64((i64)0);
            ;
        }
        if (!!(mlib$eqstring(name,(byte*)"end"))) {
            goto L459 ;
        }
;
        if ((qq_decls$nsourcefiles >= (i64)200)) {
            qq_lib$loaderror((byte*)"Too many files in QA",(byte*)"",(byte*)"");
        }
;
        t = qq_modules$findnextlineheader(s);
        if ((t == 0)) {
            qq_lib$loaderror((byte*)"QA error",(byte*)"",(byte*)"");
        }
;
        ++(qq_decls$nsourcefiles);
        qq_decls$sourcefilenames[(qq_decls$nsourcefiles)-1] = (qq_decls$sourcefilespecs[(qq_decls$nsourcefiles)-1] = mlib$pcm_copyheapstring(name));
        qq_decls$sourcefilesizes[(qq_decls$nsourcefiles)-1] = ((t - s) - (i64)3);
        qq_decls$sourcefiletext[(qq_decls$nsourcefiles)-1] = s;
        qq_decls$sourcefilepaths[(qq_decls$nsourcefiles)-1] = (byte*)"";
        qq_decls$sourcefilespecs[(qq_decls$nsourcefiles)-1] = (byte*)"";
        qq_decls$sourcefilesys[(qq_decls$nsourcefiles)-1] = sys;
        qq_decls$sourcefilesupport[(qq_decls$nsourcefiles)-1] = support;
        s = t;
    }
L459 :;
    ;
    for (i=(i64)1;i<=qq_decls$nsourcefiles;++i) {
L460 :;
        (*(qq_decls$sourcefiletext[(i)-1] + qq_decls$sourcefilesizes[(i)-1])) = (u64)0u;
L461 :;
    }
L462 :;
    ;
    strcat(newfilespec,qq_decls$sourcefilenames[((i64)1)-1]);
    return mlib$pcm_copyheapstring(newfilespec);
}

// START
void qq_modules$start(void) {

}

struct qq_decls$strec *qq_names$addglobalname(u8 *name) {
        struct qq_decls$lexrec oldlx;
        struct qq_decls$strec *  d;
    oldlx = qq_decls$nextlx;
    qq_lex$lookup(name,strlen(name),qq_lex$gethashvaluez(name));
    d = (struct qq_decls$strec *)qq_decls$nextlx.symptr;
    qq_decls$nextlx = oldlx;
    return d;
}

static struct qq_decls$strec *qq_names$newstrec(void) {
        struct qq_decls$strec *  p;
    p = (struct qq_decls$strec *)mlib$pcm_alloc((i64)112);
    memset(p,(i32)(i64)0,(u64)112u);
    return p;
}

struct qq_decls$strec *qq_names$addsymbol(struct qq_decls$strec *owner,struct qq_decls$strec *d,i64 id,i64 isglobal) {
        struct qq_decls$strec *  e;
        struct qq_decls$strec *  f;
    e = qq_names$newstrec();
    (*e).name = (*d).name;
    (*e).namelen = (i64)(*d).namelen;
    (*e).owner = owner;
    (*e).nameid = id;
    (*e).flags = msysc$m_setdotindex((*e).flags,(i64)9,(u64)((id == (i64)12) || (id == (i64)13)));
    if (!!(qq_decls$currmodule)) {
        (*e).moduleno = (i64)(*qq_decls$currmodule).moduleno;
    }
;
    (*e).firstdupl = d;
    (*e).flags = msysc$m_setdotslice((*e).flags,(i64)0,(i64)1,(u64)isglobal);
    if (((i64)(*owner).nameid != (i64)5)) {
        (*e).nextdupl = (*d).nextdupl;
        (*d).nextdupl = e;
        if ((!!((*e).nextdupl) && ((*(*e).nextdupl).owner == owner))) {
            msysc$m_print_startcon();
            msysc$m_print_str((*e).name,NULL);
            msysc$m_print_str((byte*)"in",NULL);
            msysc$m_print_str((*owner).name,NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            qq_lib$serror((byte*)"AS:Duplicate name");
        }
;
    }
    else {
        f = (*owner).deflist;
        L463 :;
        while (!!(f)) {
            if (((*f).firstdupl == (*e).firstdupl)) {
                msysc$m_print_startcon();
                msysc$m_print_str((*e).name,NULL);
                msysc$m_print_str((byte*)"in",NULL);
                msysc$m_print_str((*owner).name,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                qq_lib$serror((byte*)"AS2:Duplicate name");
            }
;
            f = (*f).nextdef;
L464 :;
        }
L465 :;
        ;
    }
;
    if (((*owner).deflist == 0)) {
        (*owner).deflist = e;
    }
    else {
        (*(*owner).deflistx).nextdef = e;
    }
;
    (*owner).deflistx = e;
    return e;
}

void qq_names$addproc(struct qq_decls$strec *d) {
        struct qq_decls$procrec *  p;
    p = (struct qq_decls$procrec *)mlib$pcm_allocz((i64)16);
    (*p).def = d;
    if ((qq_decls$proclist == 0)) {
        qq_decls$proclist = (struct qq_decls$procrec *)p;
    }
    else {
        (*qq_decls$proclistx).nextproc = (struct qq_decls$procrec *)p;
    }
;
    qq_decls$proclistx = (struct qq_decls$procrec *)p;
    ++(qq_decls$nproclist);
}

struct qq_decls$strec *qq_names$createstroot(u8 *name) {
        struct qq_decls$strec *  d;
    d = qq_names$newstrec();
    (*d).name = mlib$pcm_copyheapstring(name);
    (*d).namelen = strlen(name);
    (*d).nameid = (i64)1;
    return d;
}

i64 qq_names$newusertypex(struct qq_decls$strec *d,struct qq_decls$strec *e) {
    if ((qq_tables$nuserxtypes >= (i64)5000)) {
        qq_lib$serror((byte*)"Too many external user types");
    }
;
    ++(qq_tables$nuserxtypes);
    qq_tables$ttnamedefx[(qq_tables$nuserxtypes)] = (struct qq_decls$strec *)d;
    qq_tables$ttnamedefx2[(qq_tables$nuserxtypes)] = (struct qq_decls$strec *)e;
    qq_tables$ttxmoduleno[(qq_tables$nuserxtypes)] = (i64)(*qq_decls$stcurrmodule).moduleno;
    qq_tables$ttposx[(qq_tables$nuserxtypes)] = (i64)qq_decls$lx.pos;
    return -(qq_tables$nuserxtypes);
}

struct qq_decls$strec *qq_names$resolvedottedname(struct qq_decls$strec *owner,struct qq_decls$strec *d) {
        struct qq_decls$strec *  e;
    e = (*d).nextdupl;
    L466 :;
    while ((!!(e) && ((*e).owner != owner))) {
        e = (*e).nextdupl;
L467 :;
    }
L468 :;
    ;
    return e;
}

void qq_names$addgenfield(struct qq_decls$strec *d) {
        i64 index;
        struct qq_decls$strec *  dgen;
        struct qq_decls$genfieldrec *  g;
    dgen = (*d).firstdupl;
    index = (*dgen).genfieldindex;
    if ((index == (i64)0)) {
        if ((qq_decls$ngenfields >= (i64)1000)) {
            qq_lib$pcerror((byte*)"Too many genfields");
        }
;
        (*dgen).genfieldindex = (index = ++(qq_decls$ngenfields));
    }
;
    g = (struct qq_decls$genfieldrec *)mlib$pcm_alloc((i64)16);
    (*g).def = d;
    (*g).nextdef = (struct qq_decls$genfieldrec *)qq_decls$genfieldtable[(index)-1];
    qq_decls$genfieldtable[(index)-1] = (struct qq_decls$genfieldrec *)g;
}

i64 qq_names$addusertype(struct qq_decls$strec *d) {
    if ((qq_tables$ntypes >= (i64)250)) {
        qq_lib$pcerror((byte*)"Too many types");
    }
;
    ++(qq_tables$ntypes);
    (*d).mode = qq_tables$ntypes;
    qq_tables$ttnamedef[(qq_tables$ntypes)] = d;
    qq_tables$ttname[(qq_tables$ntypes)] = (*d).name;
    return qq_tables$ntypes;
}

i64 qq_names$makereftype(i64 target,struct qq_decls$strec *owner) {
        i64 newtype;
        i64 i;
    if ((owner == 0)) {
        for (i=(i64)43;i<=qq_tables$ntypes;++i) {
L469 :;
            if ((((i64)qq_tables$ttbasetype[(i)] == (i64)24) && ((i64)qq_tables$tttarget[(i)] == target))) {
                return i;
            }
;
L470 :;
        }
L471 :;
        ;
    }
;
    newtype = qq_names$addanontype();
    qq_tables$ttbasetype[(newtype)] = (i64)24;
    qq_lib$storemode(qq_decls$stcurrproc,target,&qq_tables$tttarget[(newtype)]);
    qq_tables$ttsize[(newtype)] = (i64)8;
    qq_tables$ttbitwidth[(newtype)] = (i64)64;
    return newtype;
}

i64 qq_names$makeaxtype(i64 target,struct qq_decls$unitrec *plower,struct qq_decls$unitrec *plength) {
        i64 newtype;
    newtype = qq_names$addanontype();
    qq_tables$ttbasetype[(newtype)] = (i64)10;
    qq_lib$storemode(qq_decls$stcurrproc,target,&qq_tables$tttarget[(newtype)]);
    qq_tables$ttlower[(newtype)] = (i64)1;
    qq_tables$ttlengthexpr[(newtype)] = plength;
    qq_tables$ttlowerexpr[(newtype)] = plower;
    return newtype;
}

i64 qq_names$makeslicetype(i64 target) {
        i64 newtype;
    newtype = qq_names$addanontype();
    qq_tables$ttbasetype[(newtype)] = (i64)42;
    qq_lib$storemode(qq_decls$stcurrproc,target,&qq_tables$tttarget[(newtype)]);
    qq_tables$ttlower[(newtype)] = (i64)1;
    qq_tables$ttsize[(newtype)] = (i64)16;
    return newtype;
}

i64 qq_names$makestrtype(i64 m,struct qq_decls$unitrec *pwidth) {
        i64 newtype;
    newtype = qq_names$addanontype();
    qq_tables$ttbasetype[(newtype)] = m;
    qq_tables$ttlengthexpr[(newtype)] = pwidth;
    qq_tables$ttlower[(newtype)] = (i64)1;
    qq_tables$ttowner[(newtype)] = qq_decls$stcurrproc;
    return newtype;
}

i64 qq_names$addanontype(void) {
        u8 str[32];
    if ((qq_tables$ntypes >= (i64)250)) {
        qq_lib$pcerror((byte*)"Too many types");
    }
;
    ++(qq_tables$ntypes);
    msysc$m_print_startstr(str);
    msysc$m_print_str((byte*)"$T",NULL);
    msysc$m_print_nogap();
    msysc$m_print_i64(qq_tables$ntypes,NULL);
    msysc$m_print_end();
    ;
    qq_tables$ttname[(qq_tables$ntypes)] = mlib$pcm_copyheapstring(str);
    qq_tables$ttowner[(qq_tables$ntypes)] = qq_decls$stcurrproc;
    return qq_tables$ntypes;
}

void qq_names$createusertype(struct qq_decls$strec *d,i64 m) {
    qq_lib$storemode(qq_decls$stcurrproc,m,&(*d).mode);
    if (((m > (i64)42) && (qq_tables$ttnamedef[(m)] == 0))) {
        qq_tables$ttnamedef[(m)] = d;
        qq_tables$ttname[(m)] = (*d).name;
        qq_tables$ttowner[(m)] = (*d).owner;
    }
;
}

i64 qq_names$getalignment(i64 m) {
        i64 a;
        {i64 $temp = (i64)qq_tables$ttbasetype[(m)];
if (($temp==(i64)10)) {
        return qq_names$getalignment((i64)qq_tables$tttarget[(m)]);
    }
    else if (($temp==(i64)16)) {
    }
    };
    a = qq_tables$ttsize[(m)];
    if ((a==(i64)1) || (a==(i64)2) || (a==(i64)4) || (a==(i64)8)) {
        return a;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_str(qq_tables$ttname[(m)],NULL);
    msysc$m_print_i64(a,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    qq_lib$pcerror((byte*)"Getalign not 1248");
    return (i64)0;
}

void qq_names$duplfield(struct qq_decls$strec *p,struct qq_decls$strec *q) {
    if (!!((*p).code)) {
        qq_lib$serror((byte*)"DUPLFIELD");
    }
;
    (*q).atfield = (*p).atfield;
    (*q).index = (*p).index;
    (*q).fieldoffset = (i64)(*p).fieldoffset;
}

static void qq_names$writesig(struct qq_decls$strec *d,void *dev) {
        struct qq_decls$strec *  e;
        i64 n;
    msysc$m_print_startfile(dev);
    msysc$m_print_setfmt((byte*)"# #(");
    msysc$m_print_str((!!(msysc$m_getdotindex((i64)(*d).flags,(i64)4)) ? (byte*)"function" : (byte*)"proc"),NULL);
    msysc$m_print_str((*d).name,NULL);
    msysc$m_print_end();
    ;
    e = (*d).deflist;
    n = (i64)0;
    L472 :;
    while (!!(e)) {
        if (((i64)(*e).nameid == (i64)13)) {
            ++(n);
            if ((!!(msysc$m_getdotindex((i64)(*e).flags,(i64)7)) && !!((*e).code))) {
                msysc$m_print_startfile(dev);
                msysc$m_print_setfmt((byte*)"#=#");
                msysc$m_print_str((*e).name,NULL);
                msysc$m_print_str((*qq_lib$strexpr((*e).code)).strptr,NULL);
                msysc$m_print_end();
                ;
            }
            else if (!!(msysc$m_getdotindex((i64)(*e).flags,(i64)7))) {
                msysc$m_print_startfile(dev);
                msysc$m_print_str((byte*)"?",NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((*e).name,NULL);
                msysc$m_print_end();
                ;
            }
            else {
                msysc$m_print_startfile(dev);
                msysc$m_print_str((*e).name,NULL);
                msysc$m_print_end();
                ;
            }
;
            if ((n < (i64)(*d).nparams)) {
                msysc$m_print_startfile(dev);
                msysc$m_print_str((byte*)", ",NULL);
                msysc$m_print_end();
                ;
            }
;
        }
;
L473 :;
        e = (*e).nextdef;
L475 :;
            }
L474 :;
    ;
    msysc$m_print_startfile(dev);
    msysc$m_print_setfmt((byte*)")\tarray [#]");
    msysc$m_print_str((*(*d).owner).name,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

void qq_names$writedocs(struct qq_decls$strec *d,u8 *(*docstrings)[],i64 ndocstrings) {
        i64 i;
    if (!(!!(qq_decls$docsdev))) {
        return;
    }
;
    if (((qq_decls$fwritedocs == (i64)1) && ((i64)(*d).moduleno != (i64)1))) {
        return;
    }
;
    qq_names$writesig(d,qq_decls$docsdev);
    for (i=(i64)1;i<=ndocstrings;++i) {
L476 :;
        msysc$m_print_startfile(qq_decls$docsdev);
        msysc$m_print_setfmt((byte*)"# #");
        msysc$m_print_str((byte*)"#",NULL);
        msysc$m_print_str((*docstrings)[(i)-1],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
L477 :;
    }
L478 :;
    ;
    msysc$m_print_startfile(qq_decls$docsdev);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
}

struct qq_decls$strec *qq_names$createdupldef(struct qq_decls$strec *owner,struct qq_decls$strec *symptr,i64 id) {
        struct qq_decls$strec *  p;
    p = qq_names$newstrec();
    (*p).name = (*symptr).name;
    (*p).namelen = (i64)(*symptr).namelen;
    (*p).symbolcode = (i64)89;
    (*p).owner = owner;
    (*p).nameid = id;
    (*p).nextdupl = (*symptr).nextdupl;
    (*symptr).nextdupl = p;
    if (!!(owner)) {
        if (((*owner).deflist == 0)) {
            (*owner).deflist = ((*owner).deflistx = p);
        }
        else {
            (*(*owner).deflistx).nextdef = p;
            (*owner).deflistx = p;
        }
;
    }
;
    return p;
}

struct qq_decls$strec *qq_names$createnewmoduledef(struct qq_decls$strec *owner,struct qq_decls$strec *symptr,i64 id) {
    return qq_names$createdupldef(owner,symptr,id);
}

// START
void qq_names$start(void) {

}

void qq_optim$optimise_module(i64 n) {
        i64 cmd;
        i64 nopnds;
        i64 size;
        i64 x;
        i64 i;
    size = (i64)0;
    qq_optim$pc = (qq_optim$pcstart = qq_decls$moduletable[(n)].pcstart);
    size = (qq_decls$moduletable[(n)].pcsize + (i64)1);
    qq_optim$labelmap = (i64 (*)[])mlib$pcm_allocz((size * (i64)8));
    L479 :;
    do {
        cmd = (*qq_optim$pc);
        nopnds = (i64)qq_pcllib$pclnopnds[(cmd)];
        for (i=(i64)1;i<=nopnds;++i) {
L482 :;
                        {i64 $temp = (i64)qq_tables$pclfmt[(cmd)][(i)-1];
if (($temp==(i64)0)) {
                goto L484 ;
            }
            else if (($temp==(i64)6)) {
                x = (*(qq_optim$pc + i));
                (*qq_optim$labelmap)[(x)] = (i64)1;
            }
            };
L483 :;
        }
L484 :;
        ;
        qq_optim$pc += (nopnds + (i64)1);
L480 :;
    }
    while (!(cmd == (i64)0 || cmd == (i64)6));
L481 :;
    ;
    qq_optim$pc = qq_optim$pcstart;
    L485 :;
    do {
        cmd = (*qq_optim$pc);
        qq_optim$optimise_op(cmd);
L486 :;
    }
    while (!(cmd == (i64)6));
L487 :;
    ;
    if (!!(size)) {
        mlib$pcm_free(qq_optim$labelmap,size);
    }
;
}

static void qq_optim$putnops(i64 offset,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L488 :;
        (*(qq_optim$pc + (offset)++)) = (i64)2;
L489 :;
    }
L490 :;
    ;
}

static void qq_optim$optimise_op(i64 cmd) {
        i64 skip;
        i64 offset;
        i64 secondlab;
        i64 cmd2;
        i64 skip2;
        i64 x;
        i64 y;
        i64 z;
        i64 a;
        i64 b;
        i64 thisloc;
        i64 thislab;
        i64 destcmd;
        i64 destlab;
    skip = ((i64)qq_pcllib$pclnopnds[(cmd)] + (i64)1);
    a = (*(qq_optim$pc + (i64)1));
    b = (*(qq_optim$pc + (i64)2));
    offset = (qq_optim$pc - qq_optim$pcstart);
    if ((cmd==(i64)75)) {
        if ((a==(i64)1) || (a==(i64)2) || (a==(i64)3)) {
            (*qq_optim$pc) = (a==1?(i64)243:(a==2?(i64)244:(a==3?(i64)245:(i64)0)));
            qq_optim$putnops((i64)1,(i64)1);
            skip = (i64)2;
            return;
        }
;
    }
    else if ((cmd==(i64)4)) {
        if ((a==(i64)1) || (a==(i64)2)) {
            (*qq_optim$pc) = (a==1?(i64)246:(a==2?(i64)247:(i64)0));
            qq_optim$putnops((i64)1,(i64)1);
            skip = (i64)2;
            return;
        }
;
    }
    else if ((cmd==(i64)39) || (cmd==(i64)43) || (cmd==(i64)44) || (cmd==(i64)45) || (cmd==(i64)46) || (cmd==(i64)47) || (cmd==(i64)48)) {
        thisloc = offset;
        thislab = a;
        if (((cmd == (i64)39) && ((thisloc + (i64)2) == thislab))) {
            (*qq_optim$pc) = (i64)239;
            (*(qq_optim$pc + (i64)1)) = (i64)0;
            qq_optim$pc += skip;
            return;
        }
        else if ((destcmd == (i64)39)) {
            destcmd = (*(qq_optim$pcstart + thislab));
            destlab = (*((qq_optim$pcstart + thislab) + (i64)1));
            (*(qq_optim$pc + (i64)1)) = destlab;
            qq_optim$pc += skip;
            return;
        }
;
    }
;
    if (!!((*qq_optim$labelmap)[((offset + skip))])) {
        qq_optim$pc += skip;
        return;
    }
;
    secondlab = (i64)0;
    cmd2 = (*(qq_optim$pc + skip));
    skip2 = ((i64)qq_pcllib$pclnopnds[(cmd2)] + (i64)1);
    if (!!((*qq_optim$labelmap)[(((offset + skip) + skip2))])) {
        secondlab = (i64)1;
    }
;
    switch (cmd) {
    case 10:;
        {
            switch (b) {
            case 10:;
                {
                    if (!!(secondlab)) {
                        goto L491 ;
;
                    }
;
                    switch ((*(qq_optim$pc + (i64)4))) {
                    case 10:;
                        {
                            (*qq_optim$pc) = (i64)238;
                            (*(qq_optim$pc + (i64)2)) = (*(qq_optim$pc + (i64)3));
                            (*(qq_optim$pc + (i64)3)) = (*(qq_optim$pc + (i64)5));
                            qq_optim$putnops((i64)4,(i64)2);
                            skip = (i64)6;
                        }
                        break;
                    case 164:;
                        {
                            (*qq_optim$pc) = (i64)262;
                            (*(qq_optim$pc + (i64)2)) = (*(qq_optim$pc + (i64)3));
                            qq_optim$putnops((i64)3,(i64)1);
                            skip = (i64)5;
                        }
                        break;
                    case 165:;
                        {
                            (*qq_optim$pc) = (i64)263;
                            (*(qq_optim$pc + (i64)2)) = (*(qq_optim$pc + (i64)3));
                            qq_optim$putnops((i64)3,(i64)1);
                            skip = (i64)5;
                        }
                        break;
                    case 43:;
                        {
                            (*qq_optim$pc) = (i64)254;
                            goto L492 ;
;
                        }
                        break;
                    case 44:;
                        {
                            (*qq_optim$pc) = (i64)255;
                            goto L492 ;
;
                        }
                        break;
                    case 45:;
                        {
                            (*qq_optim$pc) = (i64)256;
                            //dojumpxxff:
L492 :;
;
                            x = (*(qq_optim$pc + (i64)1));
                            y = (*(qq_optim$pc + (i64)3));
                            z = (*(qq_optim$pc + (i64)5));
                            (*(qq_optim$pc + (i64)1)) = z;
                            (*(qq_optim$pc + (i64)2)) = x;
                            (*(qq_optim$pc + (i64)3)) = y;
                            skip = (i64)6;
                        }
                        break;
                    case 46:;
                        {
                            (*qq_optim$pc) = (i64)257;
                            goto L492 ;
;
                        }
                        break;
                    case 47:;
                        {
                            (*qq_optim$pc) = (i64)258;
                            goto L492 ;
;
                        }
                        break;
                    case 48:;
                        {
                            (*qq_optim$pc) = (i64)259;
                            goto L492 ;
;
                        }
                        break;
                    case 210:;
                        {
                            (*qq_optim$pc) = (i64)264;
                            (*(qq_optim$pc + (i64)2)) = (*(qq_optim$pc + (i64)3));
                            qq_optim$putnops((i64)3,(i64)1);
                            skip = (i64)5;
                        }
                        break;
                    default: {
                        //dopushff:
L491 :;
;
                        (*qq_optim$pc) = (i64)226;
                        (*(qq_optim$pc + (i64)2)) = (*(qq_optim$pc + (i64)3));
                        qq_optim$putnops((i64)3,(i64)1);
                        skip = (i64)4;
                    }
                    } //SW
;
                }
                break;
            case 9:;
                {
                    (*qq_optim$pc) = (i64)228;
                    (*(qq_optim$pc + (i64)2)) = (*(qq_optim$pc + (i64)3));
                    qq_optim$putnops((i64)3,(i64)1);
                    skip = (i64)4;
                }
                break;
            case 18:;
                {
                    if (!!(secondlab)) {
                        goto L493 ;
;
                    }
;
                    switch ((*(qq_optim$pc + (i64)4))) {
                    case 164:;
                        {
                            (*qq_optim$pc) = (i64)260;
                            (*(qq_optim$pc + (i64)2)) = (*(qq_optim$pc + (i64)3));
                            qq_optim$putnops((i64)3,(i64)1);
                            skip = (i64)5;
                        }
                        break;
                    case 165:;
                        {
                            (*qq_optim$pc) = (i64)261;
                            (*(qq_optim$pc + (i64)2)) = (*(qq_optim$pc + (i64)3));
                            qq_optim$putnops((i64)3,(i64)1);
                            skip = (i64)5;
                        }
                        break;
                    case 45:;
                        {
                            (*qq_optim$pc) = (i64)250;
                            //dojumpxxfci:
L494 :;
;
                            x = (*(qq_optim$pc + (i64)1));
                            y = (*(qq_optim$pc + (i64)3));
                            z = (*(qq_optim$pc + (i64)5));
                            (*(qq_optim$pc + (i64)1)) = z;
                            (*(qq_optim$pc + (i64)2)) = x;
                            (*(qq_optim$pc + (i64)3)) = y;
                            skip = (i64)6;
                        }
                        break;
                    case 46:;
                        {
                            (*qq_optim$pc) = (i64)251;
                            goto L494 ;
;
                        }
                        break;
                    case 47:;
                        {
                            (*qq_optim$pc) = (i64)252;
                            goto L494 ;
;
                        }
                        break;
                    case 48:;
                        {
                            (*qq_optim$pc) = (i64)253;
                            goto L494 ;
;
                        }
                        break;
                    case 43:;
                        {
                            (*qq_optim$pc) = (i64)248;
                            goto L494 ;
;
                        }
                        break;
                    case 44:;
                        {
                            (*qq_optim$pc) = (i64)249;
                            goto L494 ;
;
                        }
                        break;
                    } //SW
;
                }
                break;
            case 13:;
                {
                    (*qq_optim$pc) = (i64)233;
                    goto L495 ;
;
                }
                break;
            case 14:;
                {
                    (*qq_optim$pc) = (i64)230;
                    //domoveff:
L495 :;
;
                    x = a;
                    (*(qq_optim$pc + (i64)1)) = (*(qq_optim$pc + (i64)3));
                    (*(qq_optim$pc + (i64)2)) = x;
                    qq_optim$putnops((i64)3,(i64)1);
                    skip = (i64)4;
                }
                break;
            case 34:;
                {
                    (*qq_optim$pc) = (i64)231;
                    goto L495 ;
;
                }
                break;
            case 52:;
                {
                    (*qq_optim$pc) = (i64)269;
                    (*(qq_optim$pc + (i64)2)) = (*(qq_optim$pc + (i64)3));
                    (*(qq_optim$pc + (i64)3)) = (*(qq_optim$pc + (i64)4));
                    qq_optim$putnops((i64)4,(i64)1);
                    skip = (i64)5;
                }
                break;
            case 131:;
                {
                    (*qq_optim$pc) = (i64)270;
                    qq_optim$putnops((i64)2,(i64)1);
                    skip = (i64)3;
                }
                break;
            case 31:;
                {
                    (*qq_optim$pc) = (i64)271;
                    qq_optim$putnops((i64)2,(i64)1);
                    skip = (i64)3;
                }
                break;
            } //SW
;
        }
        break;
    case 9:;
        {
            if ((b==(i64)9)) {
                (*qq_optim$pc) = (i64)227;
                (*(qq_optim$pc + (i64)2)) = (*(qq_optim$pc + (i64)3));
                qq_optim$putnops((i64)3,(i64)1);
                skip = (i64)4;
            }
            else if ((b==(i64)10)) {
                (*qq_optim$pc) = (i64)229;
                (*(qq_optim$pc + (i64)2)) = (*(qq_optim$pc + (i64)3));
                qq_optim$putnops((i64)3,(i64)1);
                skip = (i64)4;
            }
            else if ((b==(i64)13)) {
                (*qq_optim$pc) = (i64)234;
                goto L495 ;
;
            }
            else if ((b==(i64)14)) {
                (*qq_optim$pc) = (i64)232;
                goto L495 ;
;
            }
;
        }
        break;
    case 18:;
        {
            if ((b==(i64)13)) {
                (*qq_optim$pc) = (i64)237;
                goto L495 ;
;
            }
            else if ((b==(i64)14)) {
                (*qq_optim$pc) = (i64)235;
                goto L495 ;
;
            }
            else if ((b==(i64)34)) {
                (*qq_optim$pc) = (i64)236;
                goto L495 ;
;
            }
            else {
                if (((a == (i64)0) && !((b == (i64)223 || b == (i64)77)))) {
                    (*qq_optim$pc) = (i64)240;
                }
;
            }
;
        }
        break;
    case 20:;
        {
            if ((a==(i64)20)) {
                if ((!(!!(secondlab)) && (b == (i64)20))) {
                    (*qq_optim$pc) = (i64)242;
                    qq_optim$putnops((i64)1,(i64)2);
                    skip = (i64)3;
                }
                else {
                    (*qq_optim$pc) = (i64)241;
                    qq_optim$putnops((i64)1,(i64)1);
                    skip = (i64)2;
                }
;
            }
;
        }
        break;
    case 12:;
        {
            if ((b==(i64)92)) {
                if (!(!!(secondlab))) {
                                        {i64 $temp = (*(qq_optim$pc + (i64)3));
if (($temp==(i64)31)) {
                        (*qq_optim$pc) = (i64)266;
                        qq_optim$putnops((i64)2,(i64)1);
                        skip = (i64)4;
                    }
                    else if (($temp==(i64)32)) {
                        (*qq_optim$pc) = (i64)268;
                        qq_optim$putnops((i64)2,(i64)1);
                        skip = (i64)4;
                    }
                    };
                }
;
            }
;
        }
        break;
    case 11:;
        {
            if ((b==(i64)92)) {
                if (!(!!(secondlab))) {
                                        {i64 $temp = (*(qq_optim$pc + (i64)3));
if (($temp==(i64)31)) {
                        (*qq_optim$pc) = (i64)265;
                        qq_optim$putnops((i64)2,(i64)1);
                        skip = (i64)4;
                    }
                    else if (($temp==(i64)32)) {
                        (*qq_optim$pc) = (i64)267;
                        qq_optim$putnops((i64)2,(i64)1);
                        skip = (i64)4;
                    }
                    };
                }
;
            }
;
        }
        break;
    } //SW
;
    //finish:
L493 :;
;
    qq_optim$pc += skip;
}

// START
void qq_optim$start(void) {

}

void qq_packed$var_loadpacked(void *p,i64 t,struct qq_decls$varrec *dest,struct qq_decls$objrec *ownerobj) {
        i64 length;
        struct qq_decls$objrec *  s;
        u8 *  ss;
        i64 $av_1;
    (*dest).tagx = (i64)1;
    switch ((i64)qq_tables$ttbasetype[(t)]) {
    case 28:;
        {
            (*dest).value = (i64)(*(i8 *)p);
        }
        break;
    case 29:;
        {
            (*dest).value = (i64)(*(i16 *)p);
        }
        break;
    case 30:;
        {
            (*dest).value = (i64)(*(i32 *)p);
        }
        break;
    case 1:;
        {
            (*dest).value = (*(i64 *)p);
        }
        break;
    case 31:;
        {
            (*dest).value = (i64)(*(byte *)p);
        }
        break;
    case 32:;
        {
            (*dest).value = (i64)(*(u16 *)p);
        }
        break;
    case 33:;
        {
            (*dest).value = (i64)(*(u32 *)p);
        }
        break;
    case 2:;
        {
            (*dest).tagx = (i64)2;
            (*dest).value = (i64)(*(u32 *)p);
        }
        break;
    case 3:;
        {
            (*dest).tagx = (i64)3;
            (*dest).xvalue = (*(r64 *)p);
        }
        break;
    case 34:;
        {
            (*dest).tagx = (i64)3;
            (*dest).xvalue = (r64)(*(r32 *)p);
        }
        break;
    case 38:;
        {
            (*dest).tagx = (i64)268;
            length = qq_tables$ttlength[(t)];
            if ((length >= (i64)2)) {
                length = qq_packed$getfslength((u8 *)p,length);
            }
            else {
                length = (i64)1;
            }
;
            s = qq_strings$obj_make_strslicexobj((u8 *)p,length);
            (*dest).objptr = s;
        }
        break;
    case 39:;
        {
            (*dest).tagx = (i64)268;
            ss = (u8 *)p;
            $av_1 = qq_tables$ttlength[(t)];
            while ($av_1-- > 0) {
L496 :;
                if (((i64)(u64)(*ss) == (i64)0)) {
                    goto L498 ;
                }
;
                ++(ss);
L497 :;
            }
L498 :;
            ;
            s = qq_strings$obj_make_strslicexobj((u8 *)p,(ss - (u8 *)p));
            (*dest).objptr = s;
        }
        break;
    default: {
                {i64 $temp = (i64)qq_tables$ttbasetype[(t)];
if (($temp==(i64)24)) {
            (*dest).tagx = (i64)24;
            (*dest).ptr = (byte *)(*(i64 *)p);
            (*dest).elemtag = (i64)qq_tables$tttarget[(t)];
        }
        else if (($temp==(i64)16)) {
            s = qq_vars$obj_new();
            (*s).flags = msysc$m_setdotindex((*s).flags,(i64)1,(u64)1u);
            (*s).ptr = (byte *)p;
            (*dest).objptr = s;
            (*dest).tagx = (i64)272;
            (*s).usertag = t;
            if (!!(ownerobj)) {
                (*s).objtype = (i64)1;
                (*s).objptr2 = ownerobj;
                ++((*ownerobj).refcount);
            }
            else {
                (*s).objtype = (i64)2;
            }
;
        }
        else if (($temp==(i64)10)) {
            s = qq_arrays$obj_newarray((i64)qq_tables$tttarget[(t)],qq_tables$ttlower[(t)],qq_tables$ttlength[(t)]);
            (*s).flags = msysc$m_setdotindex((*s).flags,(i64)1,(u64)1u);
            (*s).ptr = (byte *)p;
            (*dest).objptr = s;
            (*dest).tagx = (i64)266;
            (*s).usertag = t;
            if (!!(ownerobj)) {
                (*s).objtype = (i64)1;
                (*s).objptr2 = ownerobj;
                ++((*ownerobj).refcount);
            }
            else {
                (*s).objtype = (i64)2;
            }
;
        }
        else {
            qq_lib$pcmxtypestt((byte*)"loadpacked",(i64)qq_tables$ttbasetype[(t)],t);
        }
        };
    }
    } //SW
;
}

void qq_packed$var_storepacked(byte *p,struct qq_decls$varrec *q,i64 t) {
        i64 plength;
        i64 qlength;
        i64 s;
        i64 sbase;
        i64 tbase;
        struct qq_decls$objrec *  qa;
    s = (sbase = (i64)(*q).tag);
    tbase = (i64)qq_tables$ttbasetype[(t)];
    switch (sbase) {
    case 1:;
    case 2:;
    case 24:;
        {
            switch (tbase) {
            case 28:;
            case 31:;
                {
                    (*p) = (*q).value;
                    return;
                }
                break;
            case 29:;
            case 32:;
                {
                    (*(u16 *)p) = (*q).value;
                    return;
                }
                break;
            case 30:;
            case 33:;
                {
                    (*(i32 *)p) = (*q).value;
                    return;
                }
                break;
            case 1:;
            case 2:;
            case 24:;
                {
                    (*(i64 *)p) = (*q).value;
                    return;
                }
                break;
            case 34:;
                {
                    (*(r32 *)p) = (r32)(*q).value;
                    return;
                }
                break;
            case 3:;
                {
                    (*(r64 *)p) = (r64)(*q).value;
                    return;
                }
                break;
            } //SW
;
        }
        break;
    case 3:;
        {
            switch (tbase) {
            case 30:;
            case 33:;
                {
                    (*(i32 *)p) = (i64)(*q).xvalue;
                    return;
                }
                break;
            case 1:;
            case 2:;
                {
                    (*(i64 *)p) = (i64)(*q).xvalue;
                    return;
                }
                break;
            case 34:;
                {
                    (*(r32 *)p) = (r32)(*q).xvalue;
                    return;
                }
                break;
            case 3:;
                {
                    (*(r64 *)p) = (*q).xvalue;
                    return;
                }
                break;
            case 29:;
            case 32:;
                {
                    (*(i16 *)p) = (i64)(*q).xvalue;
                    return;
                }
                break;
            } //SW
;
        }
        break;
    case 12:;
        {
            qa = (*q).objptr;
            plength = qq_tables$ttlength[(t)];
            qlength = (*qa).length;
            switch (tbase) {
            case 38:;
                {
                    if ((t == tbase)) {
                        if ((qlength != (i64)1)) {
                            qq_lib$pcerror((byte*)"Str not len 1");
                        }
;
                        (*(u8 *)p) = (u64)(*(*qa).strptr);
                        return;
                    }
;
                    if ((qlength > plength)) {
                        qlength = plength;
                    }
;
                    memcpy(p,(void *)(*qa).strptr,(u64)qlength);
                    qq_packed$setfslength((u8 *)p,plength,qlength);
                    return;
                }
                break;
            case 39:;
                {
                    if ((qlength >= plength)) {
                        memcpy(p,(void *)(*qa).strptr,(u64)plength);
                        (*((p + plength) - (i64)1)) = (i64)0;
                    }
                    else {
                        memcpy(p,(void *)(*qa).strptr,(u64)qlength);
                        (*(p + qlength)) = (i64)0;
                    }
;
                    return;
                }
                break;
            } //SW
;
        }
        break;
    case 16:;
        {
            s = (i64)(*(*q).objptr).usertag;
            if ((s != t)) {
                qq_lib$pcmxtypestt((byte*)"spack struct",s,t);
            }
;
            memcpy(p,(*(*q).objptr).ptr,(u64)qq_tables$ttsize[(t)]);
            return;
        }
        break;
    case 10:;
        {
            s = (i64)(*(*q).objptr).usertag;
            if ((s != t)) {
                qq_lib$pcmxtypestt((byte*)"spack array",s,t);
            }
;
            memcpy(p,(*(*q).objptr).ptr,(u64)qq_tables$ttsize[(t)]);
            return;
        }
        break;
    } //SW
;
    qq_lib$pcmxtypestt((byte*)"storepacked (source->dest)",s,t);
}

static void qq_packed$setfslength(u8 *s,i64 m,i64 n) {
    if ((m == n)) {
    }
    else if ((n == (m - (i64)1))) {
        (*((s + m) - (i64)1)) = (u64)0u;
    }
    else {
        (*((s + m) - (i64)2)) = (u64)0u;
        (*((s + m) - (i64)1)) = (u64)n;
    }
;
}

i64 qq_packed$getfslength(u8 *s,i64 m) {
    s += (m - (i64)1);
    if (((i64)(u64)(*(s - (i64)1)) == (i64)0)) {
        return (i64)(u64)(*s);
    }
    else if (((i64)(u64)(*s) == (i64)0)) {
        return (m - (i64)1);
    }
    else {
        return m;
    }
;
}

void qq_packed$var_make_struct(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n,i64 rectype) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec **  r;
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  b;
        i64 m;
        byte *  q;
        i64 $av_1;
    p = qq_packed$obj_new_struct(rectype);
    b = (*p).varptr;
    m = qq_tables$ttlength[(rectype)];
    d = qq_tables$ttnamedef[(rectype)];
    r = (struct qq_decls$strec **)(*d).topfieldlist;
    if ((n < m)) {
        qq_lib$pcerror((byte*)"Too few elements");
    }
    else if ((n > m)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"N=",NULL);
        msysc$m_print_i64(n,NULL);
        msysc$m_print_str((byte*)"M=",NULL);
        msysc$m_print_i64(m,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$pcerror((byte*)"Too many elements");
    }
;
    q = (*p).ptr;
    $av_1 = n;
    while ($av_1-- > 0) {
L499 :;
        qq_packed$var_storepacked(q,a,(i64)(*(*r)).mode);
        q += qq_tables$ttsize[((i64)(*(*r)).mode)];
        ++(r);
        ++(a);
L500 :;
    }
L501 :;
    ;
    (*dest).tagx = (i64)272;
    (*p).usertag = rectype;
    (*dest).objptr = p;
}

struct qq_decls$objrec *qq_packed$obj_new_struct(i64 m) {
        struct qq_decls$objrec *  p;
        i64 size;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    (*p).usertag = m;
    size = qq_tables$ttsize[(m)];
    if (!!(size)) {
        (*p).ptr = (byte *)mlib$pcm_allocz(size);
    }
;
    return p;
}

void qq_packed$var_dupl_struct(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 size;
    p = (*a).objptr;
    size = qq_tables$ttsize[((i64)(*p).usertag)];
    q = qq_packed$obj_new_struct((i64)(*p).usertag);
    (*a).objptr = q;
    memcpy((*q).ptr,(*p).ptr,(u64)size);
}

void qq_packed$obj_free_struct(struct qq_decls$objrec *p) {
    mlib$pcm_free((*p).ptr,qq_tables$ttsize[((i64)(*p).usertag)]);
    mlib$pcm_free32(p);
}

i64 qq_packed$var_equal_struct(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
    return mlib$eqbytes((*(*x).objptr).ptr,(*(*y).objptr).ptr,qq_tables$ttsize[((i64)(*x).tag)]);
}

void qq_packed$var_getix_struct(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec **  r;
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  p;
    v = (*a);
    p = (*a).objptr;
    if (((index < (i64)1) || (index > qq_tables$ttlength[((i64)(*a).tag)]))) {
        qq_lib$pcerror((byte*)"struct[int] bounds");
    }
;
    d = qq_tables$ttnamedef[((i64)(*p).usertag)];
    r = (struct qq_decls$strec **)(((*d).topfieldlist + index) - (i64)1);
    qq_packed$var_loadpacked(((*p).ptr + (i64)(*(*r)).fieldoffset),(i64)(*(*r)).mode,a,0);
}

// START
void qq_packed$start(void) {

}

void qq_parse$parsemodule(i64 n) {
        struct qq_decls$unitrec *  p;
    if (!!(qq_decls$moduletable[(n)].parsed)) {
        return;
    }
;
    qq_decls$currmodule = (struct qq_decls$modulerec *)&qq_decls$moduletable[(n)];
    qq_lex$startlex((i64)(*qq_decls$currmodule).fileno,n);
    qq_decls$stcurrmodule = (*qq_decls$currmodule).def;
    qq_lex$lex();
    qq_lex$lex();
    qq_decls$stcurrproc = qq_decls$stcurrmodule;
    p = qq_parse$readsunit((i64)0);
    (*qq_decls$stcurrmodule).code = (qq_decls$moduletable[(n)].ast = p);
    qq_parse$skipsemi();
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)5)) {
        qq_lib$serror((byte*)"Comma seq not allowed");
    }
    else if (($temp==(i64)76)) {
    }
    else {
        qq_lex$ps1((byte*)"EOF");
        qq_lib$serror((byte*)"Bad symbol at eof");
    }
    };
}

static struct qq_decls$unitrec *qq_parse$readexpression(void) {
        struct qq_decls$unitrec *  p;
    p = qq_parse$readterm2();
    if (!!((i64)qq_tables$exprendset[((i64)qq_decls$lx.symbol)])) {
        return p;
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)9 || (i64)qq_decls$lx.symbol == (i64)10)) {
        return qq_parse$readassignment(p);
    }
    else {
        return qq_parse$readorterms(p);
    }
;
}

static struct qq_decls$unitrec *qq_parse$readassignment(struct qq_decls$unitrec *p) {
        i64 pos;
        i64 opc;
    if (!!((i64)qq_tables$exprendset[((i64)qq_decls$lx.symbol)])) {
        return p;
    }
;
    p = qq_parse$readorterms(p);
    if (((i64)qq_decls$lx.symbol == (i64)9 || (i64)qq_decls$lx.symbol == (i64)10)) {
        opc = (i64)qq_decls$lx.subcode;
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        p = qq_lib$createunit2(opc,p,qq_parse$readassignment(qq_parse$readterm2()));
        (*p).pos = pos;
    }
;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readorterms(struct qq_decls$unitrec *p) {
        i64 pos;
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
    if (!!((i64)qq_tables$exprendset[((i64)qq_decls$lx.symbol)])) {
        return p;
    }
;
    p = qq_parse$readandterms(p);
    L502 :;
    while (((i64)qq_decls$lx.symbol == (i64)40)) {
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)9)) {
            qq_lex$lex();
            p = qq_lib$createunit2((i64)185,p,qq_parse$readexpression());
            (*p).pos = pos;
            goto L504 ;
        }
;
        p = qq_lib$createunit2((i64)166,p,qq_parse$readandterms(qq_parse$readterm2()));
        (*p).pos = pos;
L503 :;
    }
L504 :;
    ;
    L505 :;
    while (((i64)qq_decls$lx.symbol == (i64)12)) {
        qq_lex$lex();
        q = (r = qq_parse$readterm2());
        if (((i64)(*q).tag == (i64)32)) {
            r = (*q).b;
            L508 :;
            while (!!((*r).nextunit)) {
L509 :;
                r = (*r).nextunit;
L511 :;
                            }
L510 :;
            ;
            (*r).nextunit = p;
            p = q;
        }
        else {
            p = qq_lib$createunit2((i64)32,q,p);
        }
;
L506 :;
    }
L507 :;
    ;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readandterms(struct qq_decls$unitrec *p) {
        i64 pos;
    p = qq_parse$readcmpterms(p);
    L512 :;
    while (((i64)qq_decls$lx.symbol == (i64)39)) {
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)9)) {
            qq_lex$lex();
            p = qq_lib$createunit2((i64)184,p,qq_parse$readexpression());
            (*p).pos = pos;
            goto L514 ;
        }
;
        p = qq_lib$createunit2((i64)165,p,qq_parse$readcmpterms(qq_parse$readterm2()));
        (*p).pos = pos;
L513 :;
    }
L514 :;
    ;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readcmpterms(struct qq_decls$unitrec *p) {
        i64 pos;
        i64 n;
        struct qq_decls$unitrec *  px;
        struct qq_decls$unitrec *  q;
        byte genops[4];
    p = qq_parse$readinterms(p);
    if (!(!!((i64)qq_tables$cmpopset[((i64)qq_decls$lx.symbol)]))) {
        return p;
    }
;
    memset(&(genops),0,4);
    px = p;
    p = qq_lib$createunit1((i64)46,p);
    n = (i64)0;
    L515 :;
    while (!!((i64)qq_tables$cmpopset[((i64)qq_decls$lx.symbol)])) {
        ++(n);
        if ((n > (i64)4)) {
            qq_lib$serror((byte*)"cmpchain: Too many items");
        }
;
        genops[(n)-1] = (i64)qq_decls$lx.subcode;
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        q = qq_parse$readinterms(qq_parse$readterm2());
        (*px).nextunit = q;
        px = q;
        (*q).pos = pos;
L516 :;
    }
L517 :;
    ;
    if ((n == (i64)1)) {
        (*p).tag = (i64)genops[((i64)1)-1];
        q = (*p).a;
        (*p).b = (*q).nextunit;
        (*q).nextunit = 0;
    }
    else {
        memcpy(&(*p).cmpgenop,&genops,4);
    }
;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readinterms(struct qq_decls$unitrec *p) {
        i64 pos;
        i64 opc;
    p = qq_parse$readrangeterm(p);
    L518 :;
    switch ((i64)qq_decls$lx.symbol) {
    case 50:;
    case 51:;
    case 52:;
        {
            opc = (i64)qq_decls$lx.subcode;
            pos = (i64)qq_decls$lx.pos;
            qq_lex$lex();
            p = qq_lib$createunit2(opc,p,qq_parse$readrangeterm(qq_parse$readterm2()));
            (*p).pos = pos;
        }
        break;
    default: {
        goto L519 ;
    }
    } //SW
goto L518 ;
L519 :;
    ;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readrangeterm(struct qq_decls$unitrec *p) {
        i64 pos;
    p = qq_parse$readaddterms(p);
    if (((i64)qq_decls$lx.symbol == (i64)29)) {
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        p = qq_lib$createunit2((i64)195,p,qq_parse$readaddterms(qq_parse$readterm2()));
        (*p).pos = pos;
    }
;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readaddterms(struct qq_decls$unitrec *p) {
        i64 pos;
        i64 opc;
        struct qq_decls$unitrec *  q;
    p = qq_parse$readmulterms(p);
    L520 :;
    while (!!((i64)qq_tables$addopset[((i64)qq_decls$lx.symbol)])) {
                {i64 $temp = (opc = (i64)qq_decls$lx.subcode);
if (($temp==(i64)67)) {
            opc = (i64)176;
        }
        };
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)9)) {
            qq_lex$lex();
            p = qq_lib$createunit2((i64)qq_tables$jtocodes[(opc)],p,qq_parse$readassignment(qq_parse$readterm2()));
            (*p).pos = pos;
            goto L522 ;
        }
;
        q = qq_parse$readmulterms(qq_parse$readterm2());
        p = qq_lib$createunit2(opc,p,q);
        (*p).pos = pos;
L521 :;
    }
L522 :;
    ;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readmulterms(struct qq_decls$unitrec *p) {
        i64 pos;
        i64 opc;
    p = qq_parse$readpowerterms(p);
    L523 :;
    while (!!((i64)qq_tables$mulopset[((i64)qq_decls$lx.symbol)])) {
        opc = (i64)qq_decls$lx.subcode;
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)9)) {
            qq_lex$lex();
            p = qq_lib$createunit2((i64)qq_tables$jtocodes[(opc)],p,qq_parse$readassignment(qq_parse$readterm2()));
            (*p).pos = pos;
            goto L525 ;
        }
;
        p = qq_lib$createunit2(opc,p,qq_parse$readpowerterms(qq_parse$readterm2()));
        (*p).pos = pos;
L524 :;
    }
L525 :;
    ;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readpowerterms(struct qq_decls$unitrec *p) {
        i64 pos;
    L526 :;
    while (((i64)qq_decls$lx.symbol == (i64)54)) {
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        p = qq_lib$createunit2((i64)177,p,qq_parse$readpowerterms(qq_parse$readterm2()));
        (*p).pos = pos;
L527 :;
    }
L528 :;
    ;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readterm2(void) {
        struct qq_decls$unitrec *  p;
        i64 pos;
    pos = (i64)qq_decls$lx.pos;
    p = qq_parse$readterm();
    p = qq_parse$readtermsuffix(p,pos);
    return p;
}

static struct qq_decls$unitrec *qq_parse$readtermsuffix(struct qq_decls$unitrec *p,i64 pos) {
        struct qq_decls$unitrec *  q;
        i64 opc;
        i64 nparams;
    L529 :;
    switch ((i64)qq_decls$lx.symbol) {
    case 13:;
        {
            qq_lex$lex();
            q = qq_parse$readslist(&nparams,(i64)1);
            qq_parse$checksymbol((i64)14);
            qq_lex$lex();
            p = qq_lib$createunit2((i64)32,p,q);
            p = qq_parse$readcondsuffix(p);
        }
        break;
    case 19:;
        {
            p = qq_lib$createunit1((i64)66,p);
            qq_lex$lex();
        }
        break;
    case 15:;
        {
            p = qq_parse$readindex(p,(i64)0);
        }
        break;
    case 2:;
        {
            p = qq_parse$readdotsuffix(p);
        }
        break;
    case 17:;
        {
            p = qq_parse$readkeyindex(p);
        }
        break;
    case 7:;
        {
            if ((qq_parse$listtype==(i64)331808391504)) {
                qq_lex$lex();
                p = qq_lib$createunit2((i64)4,p,qq_parse$readexpression());
            }
            else if ((qq_parse$listtype==(i64)1413695812)) {
                qq_lex$lex();
                p = qq_lib$createunit2((i64)5,p,qq_parse$readexpression());
            }
            else {
                goto L530 ;
            }
;
        }
        break;
    case 73:;
        {
                        {i64 $temp = (i64)qq_decls$lx.subcode;
if (($temp==(i64)85)) {
                opc = (i64)87;
            }
            else if (($temp==(i64)86)) {
                opc = (i64)88;
            }
            };
            qq_lex$lex();
            p = qq_lib$createunit1(opc,p);
        }
        break;
    default: {
        goto L530 ;
    }
    } //SW
goto L529 ;
L530 :;
    ;
    (*p).pos = pos;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readterm(void) {
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
        i64 opc;
        i64 pos;
        i64 nparams;
        i64 length;
        struct qq_parse$readterm$dummy ustr;
    pos = (i64)qq_decls$lx.pos;
    switch ((i64)qq_decls$lx.symbol) {
    case 89:;
        {
            p = (struct qq_decls$unitrec *)qq_lib$createname((struct qq_decls$strec *)qq_decls$lx.symptr);
            (*p).pos = (i64)qq_decls$lx.pos;
            qq_lex$lex();
        }
        break;
    case 79:;
        {
                        {i64 $temp = (i64)qq_decls$lx.subcode;
if (($temp==(i64)1)) {
                p = qq_lib$createintunit(qq_decls$lx.value);
            }
            else if (($temp==(i64)2)) {
                p = qq_lib$createwordunit(qq_decls$lx.value);
            }
            else {
                qq_lib$serror((byte*)"Unknown intconst type");
            }
            };
            qq_lex$lex();
        }
        break;
    case 81:;
        {
            p = qq_lib$createrealunit(qq_decls$lx.xvalue);
            qq_lex$lex();
        }
        break;
    case 84:;
        {
            p = qq_lib$createstringunit(qq_decls$lx.svalue,(i64)-1);
            qq_lex$lex();
        }
        break;
    case 80:;
        {
            p = qq_lib$createstringunit(qq_decls$lx.svalue,(i64)-1);
            (*p).tag = (i64)82;
            qq_lex$lex();
        }
        break;
    case 82:;
        {
            length = strlen(qq_decls$lx.svalue);
            ustr.sa = (i64)0;
            if ((length > (i64)8)) {
                qq_lib$serror((byte*)"char const too long");
            }
;
            memcpy(ustr.str,(void *)qq_decls$lx.svalue,(u64)length);
            p = qq_lib$createintunit(ustr.sa);
            qq_lex$lex();
        }
        break;
    case 87:;
        {
            p = qq_lib$createboolunit((i64)qq_decls$lx.subcode);
            qq_lex$lex();
        }
        break;
    case 13:;
        {
            p = qq_parse$readlbrack();
        }
        break;
    case 90:;
        {
            if (((i64)qq_decls$lx.subcode == (i64)0)) {
                qq_lex$lex();
                if ((((i64)qq_decls$lx.symbol == (i64)2) && ((i64)qq_decls$nextlx.symbol == (i64)136))) {
                    qq_lex$lex();
                    qq_lex$lex();
                    p = qq_lib$createunit0((i64)41);
                    (*p).mode = (i64)0;
                }
                else {
                    p = qq_lib$createunit0((i64)69);
                }
;
            }
            else {
                p = qq_parse$readcast();
            }
;
        }
        break;
    case 32:;
        {
            p = qq_parse$checkoperator();
            if (!(!!(p))) {
                qq_lex$lex();
                p = qq_parse$readterm2();
            }
;
        }
        break;
    case 33:;
        {
            p = qq_parse$checkoperator();
            if (!(!!(p))) {
                qq_lex$lex();
                if (((i64)qq_decls$lx.symbol == (i64)9)) {
                    opc = (i64)89;
                    goto L531 ;
;
                }
;
                p = qq_parse$readterm2();
                if (((i64)(*p).tag == (i64)50)) {
                    (*p).value = -((*p).value);
                }
                else {
                    p = qq_lib$createunit1((i64)89,p);
                }
;
            }
;
        }
        break;
    case 62:;
    case 64:;
    case 63:;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 73:;
    case 74:;
    case 70:;
    case 71:;
        {
            p = qq_parse$checkoperator();
            if (!(!!(p))) {
                opc = (i64)qq_decls$lx.subcode;
                qq_lex$lex();
                if (((i64)qq_decls$lx.symbol == (i64)9)) {
                    //dounary:
L531 :;
;
                    qq_lex$lex();
                    p = qq_lib$createunit1((i64)qq_tables$jtocodes[(opc)],qq_parse$readterm2());
                }
                else {
                    p = qq_lib$createunit1(opc,qq_parse$readterm2());
                }
;
            }
;
        }
        break;
    case 34:;
    case 35:;
    case 36:;
    case 37:;
    case 39:;
    case 40:;
    case 41:;
    case 42:;
    case 43:;
    case 44:;
    case 45:;
    case 50:;
    case 51:;
    case 52:;
    case 55:;
    case 56:;
    case 57:;
    case 58:;
    case 59:;
    case 60:;
    case 54:;
    case 48:;
    case 49:;
    case 26:;
    case 72:;
    case 61:;
    case 175:;
        {
            p = qq_parse$checkoperator();
        }
        break;
    case 15:;
        {
            p = qq_parse$readset();
        }
        break;
    case 46:;
    case 47:;
        {
            if (!!((p = qq_parse$checkoperator()))) {
            }
            else {
                opc = (i64)qq_decls$lx.subcode;
                qq_parse$lexchecksymbol((i64)13);
                qq_lex$lex();
                p = qq_parse$readexpression();
                qq_parse$checksymbol((i64)5);
                qq_lex$lex();
                p = qq_lib$createunit2(opc,p,qq_parse$readexpression());
                qq_parse$checksymbol((i64)14);
                qq_lex$lex();
            }
;
        }
        break;
    case 122:;
        {
            p = qq_parse$readsprint();
        }
        break;
    case 124:;
    case 125:;
        {
            p = qq_parse$readsread();
        }
        break;
    case 25:;
    case 19:;
        {
            opc = (i64)qq_decls$lx.subcode;
            qq_lex$lex();
            p = qq_lib$createunit1(opc,qq_parse$readterm2());
            if (((i64)(*(*p).a).tag == (i64)32)) {
                if (!!((*(*p).a).b)) {
                    qq_lib$serror((byte*)"Params not allowed");
                }
;
                (*p).a = (*(*p).a).a;
            }
;
        }
        break;
    case 126:;
        {
            qq_parse$lexchecksymbol((i64)13);
            qq_lex$lex();
            q = qq_parse$readslist(&nparams,(i64)0);
            qq_parse$checksymbol((i64)14);
            qq_lex$lex();
            p = qq_lib$createunit1((i64)81,q);
            (*p).nparams = nparams;
        }
        break;
    case 161:;
        {
            p = qq_parse$readcompilervar();
            qq_lex$lex();
        }
        break;
    case 162:;
        {
            if (!!(qq_parse$intabledata)) {
                if ((qq_parse$tabledataname == 0)) {
                    qq_lib$serror((byte*)"$:No enum");
                }
;
                p = qq_lib$createstringunit(qq_parse$tabledataname,(i64)-1);
            }
            else {
                if ((qq_parse$ndollar <= (i64)0)) {
                    qq_lib$serror((byte*)"[$] No array");
                }
;
                p = qq_lib$createunit1((i64)120,qq_parse$dollarstack[(qq_parse$ndollar)-1]);
            }
;
            qq_lex$lex();
        }
        break;
    case 2:;
    case 149:;
        {
            qq_parse$lexchecksymbol((i64)89);
            p = (struct qq_decls$unitrec *)qq_lib$createname((struct qq_decls$strec *)qq_decls$lx.symptr);
            (*p).pos = (i64)qq_decls$lx.pos;
            qq_lex$lex();
        }
        break;
    case 165:;
        {
            p = qq_parse$readmap();
        }
        break;
    case 166:;
        {
            qq_parse$lexchecksymbol((i64)13);
            qq_lex$lex();
            p = qq_parse$readexpression();
            qq_parse$checksymbol((i64)5);
            qq_lex$lex();
            q = qq_parse$readexpression();
            if ((((i64)qq_decls$lx.symbol == (i64)14) && ((i64)(*q).tag == (i64)195))) {
                r = (*q).b;
                q = (*q).a;
            }
            else {
                qq_parse$checksymbol((i64)5);
                qq_lex$lex();
                r = qq_parse$readexpression();
                qq_parse$checksymbol((i64)14);
            }
;
            qq_lex$lex();
            q = qq_lib$createunit2((i64)174,p,q);
            p = qq_lib$createunit2((i64)173,q,r);
        }
        break;
    case 118:;
        {
            p = qq_parse$readgoto();
        }
        break;
    case 93:;
        {
            p = qq_parse$readif();
        }
        break;
    case 101:;
        {
            p = qq_parse$readunless();
        }
        break;
    case 102:;
    case 103:;
    case 119:;
    case 120:;
        {
            p = qq_parse$readswitchcase();
        }
        break;
    case 106:;
        {
            p = qq_parse$readfor();
        }
        break;
    case 108:;
        {
            p = qq_parse$readto();
        }
        break;
    case 110:;
    case 111:;
        {
            p = qq_parse$readdo();
        }
        break;
    case 112:;
        {
            p = qq_parse$readwhile();
        }
        break;
    case 113:;
        {
            p = qq_parse$readrepeat();
        }
        break;
    case 117:;
        {
            p = qq_parse$readloopcontrol();
        }
        break;
    case 115:;
        {
            p = qq_parse$readreturn();
        }
        break;
    case 156:;
        {
            qq_parse$yieldseen = (i64)1;
            qq_lex$lex();
            p = qq_parse$readcondsuffix(qq_lib$createunit1((i64)40,qq_parse$readexpression()));
        }
        break;
    case 116:;
        {
            p = qq_parse$readstop();
        }
        break;
    case 121:;
        {
            p = qq_parse$readprint();
        }
        break;
    case 123:;
        {
            p = qq_parse$readread();
        }
        break;
    case 152:;
        {
            p = qq_parse$readtry();
        }
        break;
    case 155:;
        {
            qq_lex$lex();
            p = qq_lib$createunit1((i64)31,qq_parse$readexpression());
        }
        break;
    case 167:;
        {
            qq_parse$lexchecksymbol((i64)13);
            qq_lex$lex();
            p = qq_parse$readexpression();
            qq_parse$checksymbol((i64)5);
            qq_lex$lex();
            q = qq_parse$readexpression();
            qq_parse$checksymbol((i64)14);
            qq_lex$lex();
            p = qq_lib$createunit2((i64)36,p,q);
        }
        break;
    case 171:;
        {
            p = qq_parse$readhostparams(0,(i64)1);
        }
        break;
    case 173:;
        {
            p = qq_lib$createunit0((((i64)qq_decls$lx.subcode == (i64)1) ? (i64)35 : (i64)34));
            qq_lex$lex();
        }
        break;
    case 174:;
        {
            qq_lex$lex();
            p = qq_lib$createunit1((i64)58,qq_parse$readterm2());
        }
        break;
    case 163:;
        {
            qq_lex$lex();
            p = qq_lib$createunit1((i64)42,qq_parse$readexpression());
        }
        break;
    case 176:;
        {
            p = qq_parse$readlist();
        }
        break;
    default: {
        //error:
L532 :;
;
        msysc$m_print_startcon();
        msysc$m_print_str(qq_tables$symbolnames[((i64)qq_decls$lx.symbol)-1],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$serror((byte*)"readterm?");
    }
    } //SW
;
    (*p).pos = pos;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readxunit(void) {
    return qq_parse$readexpression();
}

static struct qq_decls$unitrec *qq_parse$readsunit(i64 inwhile) {
        i64 lineno;
        i64 globalflag;
        i64 staticflag;
        struct qq_decls$unitrec *  ulist;
        struct qq_decls$unitrec *  ulistx;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
    lineno = (i64)qq_decls$lx.pos;
    ulist = (ulistx = 0);
    globalflag = (i64)0;
    staticflag = (i64)0;
    L533 :;
    do {
        L536 :;
        while (((i64)qq_decls$lx.symbol == (i64)6)) {
            qq_lex$lex();
L537 :;
        }
L538 :;
        ;
        switch ((i64)qq_decls$lx.symbol) {
        case 150:;
            {
                qq_lex$lex();
                staticflag = (i64)1;
                goto L533 ;
            }
            break;
        case 149:;
            {
                if (!!(globalflag)) {
                    qq_lib$serror((byte*)"global global?");
                }
;
                globalflag = (i64)qq_decls$lx.subcode;
                qq_lex$lex();
                goto L533 ;
            }
            break;
        case 127:;
        case 128:;
            {
                qq_parse$readprocdef(globalflag);
                globalflag = (i64)0;
            }
            break;
        case 139:;
        case 140:;
            {
                //dovar:
L539 :;
;
                q = qq_parse$readvardef((i64)((i64)qq_decls$lx.symbol == (i64)140),globalflag,staticflag);
                L540 :;
                while (!!(q)) {
                    r = (*q).nextunit;
                    (*q).nextunit = 0;
                    qq_lib$addlistunit(&ulist,&ulistx,q);
                    q = r;
L541 :;
                }
L542 :;
                ;
                globalflag = (staticflag = (i64)0);
            }
            break;
        case 145:;
            {
                if (!!(staticflag)) {
                    qq_lib$serror((byte*)"static?");
                }
;
                qq_parse$readconstdef(globalflag);
                globalflag = (i64)0;
            }
            break;
        case 136:;
            {
                qq_parse$readtypedef(globalflag);
                globalflag = (i64)0;
            }
            break;
        case 130:;
        case 131:;
            {
                qq_parse$readrecorddef(globalflag,0);
                globalflag = (i64)0;
            }
            break;
        case 164:;
            {
                qq_parse$readtabledef(globalflag);
                globalflag = (i64)0;
            }
            break;
        case 78:;
            {
                if ((qq_parse$ndocstrings >= (i64)50)) {
                    qq_lib$serror((byte*)"Too many docstrings for fn");
                }
;
                qq_parse$docstrings[(++(qq_parse$ndocstrings))-1] = mlib$pcm_copyheapstringn(qq_decls$lx.svalue,qq_lex$lxlength);
                qq_lex$lex();
            }
            break;
        case 135:;
            {
                qq_parse$readimportdll();
            }
            break;
        case 142:;
            {
                qq_parse$readmacrodef(globalflag);
                globalflag = (i64)0;
            }
            break;
        case 76:;
            {
                goto L535 ;
            }
            break;
        case 14:;
        case 94:;
        case 95:;
        case 96:;
        case 114:;
        case 105:;
        case 11:;
        case 97:;
        case 98:;
        case 153:;
        case 100:;
        case 18:;
            {
                goto L535 ;
            }
            break;
        case 89:;
            {
                                {i64 $temp = (i64)qq_decls$nextlx.symbol;
if (($temp==(i64)8) || ($temp==(i64)7)) {
                    p = qq_lib$createunit1((i64)1,(struct qq_decls$unitrec *)qq_lib$createname((struct qq_decls$strec *)qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)15,(i64)0)));
                    qq_lex$lex();
                    qq_decls$lx.symbol = (i64)6;
                    qq_lib$addlistunit(&ulist,&ulistx,p);
                }
                else if (($temp==(i64)89)) {
                    goto L539 ;
;
                }
                else {
                    goto L543 ;
;
                }
                };
            }
            break;
        case 110:;
            {
                if (!!(inwhile)) {
                    goto L535 ;
                }
;
                goto L543 ;
;
            }
            break;
        case 133:;
            {
                L544 :;
                do {
                    qq_lex$lex();
L545 :;
                }
                while (!((i64)qq_decls$lx.symbol == (i64)6));
L546 :;
                ;
            }
            break;
        case 6:;
            {
            }
            break;
        case 15:;
            {
                goto L543 ;
;
            }
            break;
        default: {
            if ((!!(qq_parse$istypestarter()) && ((i64)qq_decls$nextlx.symbol != (i64)13))) {
                goto L539 ;
;
            }
            else {
                //doexec:
L543 :;
;
                p = qq_parse$readexpression();
                if ((((i64)(*p).tag == (i64)47) && ((i64)qq_decls$lx.symbol == (i64)89))) {
                    qq_lib$serror((byte*)"Possibly var/let needed");
                }
;
                qq_lib$addlistunit(&ulist,&ulistx,p);
                if (((i64)qq_decls$lx.symbol == (i64)110)) {
                    goto L535 ;
                }
;
            }
;
        }
        } //SW
;
L534 :;
    }
    while (!((i64)qq_decls$lx.symbol != (i64)6));
L535 :;
    ;
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)14) || ($temp==(i64)94) || ($temp==(i64)95) || ($temp==(i64)96) || ($temp==(i64)114) || ($temp==(i64)105) || ($temp==(i64)110) || ($temp==(i64)11) || ($temp==(i64)97) || ($temp==(i64)98) || ($temp==(i64)153) || ($temp==(i64)100) || ($temp==(i64)18) || ($temp==(i64)5) || ($temp==(i64)20) || ($temp==(i64)76)) {
    }
    else {
        qq_lib$serror((byte*)"Readsunit: \";\" expected, or bad unit starter");
    }
    };
    if (((ulist == 0) || !!((*ulist).nextunit))) {
        return qq_lib$createunit1((i64)8,ulist);
    }
    else {
        return ulist;
    }
;
}

void qq_parse$checksymbol(i64 symbol) {
        u8 str[100];
    if (((i64)qq_decls$lx.symbol != symbol)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"# expected, not #");
        msysc$m_print_str(qq_tables$symbolnames[(symbol)-1],NULL);
        msysc$m_print_str(qq_tables$symbolnames[((i64)qq_decls$lx.symbol)-1],NULL);
        msysc$m_print_end();
        ;
        qq_lib$serror((u8 *)str);
    }
;
}

static void qq_parse$checkequals(void) {
    if (((i64)qq_decls$lx.symbol != (i64)55)) {
        qq_lib$serror((byte*)"\"=\" expected");
    }
;
}

static i64 qq_parse$checkbegin(i64 fbrack) {
        i64 closesym;
    qq_parse$skipsemi();
    if ((((i64)qq_decls$lx.symbol == (i64)13) && !!(fbrack))) {
        closesym = (i64)14;
        qq_lex$lex();
    }
    else if (((i64)qq_decls$lx.symbol == (i64)17)) {
        closesym = (i64)18;
        qq_lex$lex();
    }
    else {
        closesym = (i64)100;
    }
;
    return closesym;
}

static void qq_parse$checkbeginend(i64 closesym,i64 kwd,i64 startline) {
    qq_parse$skipsemi();
    if (((closesym == (i64)14) || (closesym == (i64)18))) {
        qq_parse$checksymbol(closesym);
    }
    else {
        qq_parse$checkend(closesym,kwd,(i64)0,startline);
    }
;
    qq_lex$lex();
}

void qq_parse$skipsemi(void) {
    L547 :;
    while (((i64)qq_decls$lx.symbol == (i64)6)) {
        qq_lex$lex();
L548 :;
    }
L549 :;
    ;
}

static struct qq_decls$unitrec *qq_parse$readindex(struct qq_decls$unitrec *p,i64 dot) {
        struct qq_decls$unitrec *  q;
    qq_lex$lex();
    L550 :;
    while (1) {
        if ((qq_parse$ndollar >= (i64)10)) {
            qq_lib$serror((byte*)"Too many nested a[$]");
        }
;
        qq_parse$dollarstack[(++(qq_parse$ndollar))-1] = p;
        q = qq_parse$readexpression();
        --(qq_parse$ndollar);
        p = qq_lib$createunit2((!!(dot) ? (i64)61 : (i64)60),p,q);
        if (((i64)qq_decls$lx.symbol != (i64)5)) {
            goto L551 ;
        }
;
        qq_lex$lex();
    }
L551 :;
    ;
    qq_parse$checksymbol((i64)16);
    qq_lex$lex();
    return p;
}

static struct qq_decls$unitrec *qq_parse$readdotsuffix(struct qq_decls$unitrec *p) {
    L552 :;
    while (((i64)qq_decls$lx.symbol == (i64)2)) {
        qq_lex$lex();
        switch ((i64)qq_decls$lx.symbol) {
        case 15:;
            {
                p = qq_parse$readindex(p,(i64)1);
            }
            break;
        case 89:;
            {
                p = qq_lib$createunit2((i64)59,p,(struct qq_decls$unitrec *)qq_lib$createname((struct qq_decls$strec *)qq_decls$lx.symptr));
                qq_lex$lex();
            }
            break;
        case 72:;
            {
                //doprop:
L555 :;
;
                p = qq_lib$createunit1((i64)qq_decls$lx.subcode,p);
                qq_lex$lex();
            }
            break;
        case 136:;
            {
                if (((i64)(*p).tag != (i64)41)) {
                    p = qq_lib$createunit1((i64)125,p);
                }
;
                qq_lex$lex();
            }
            break;
        case 47:;
            {
                qq_decls$lx.subcode = (i64)132;
                goto L555 ;
;
            }
            break;
        case 46:;
            {
                qq_decls$lx.subcode = (i64)131;
                qq_decls$lx.symbol = (i64)72;
                goto L555 ;
;
            }
            break;
        case 162:;
            {
                if (!(((i64)(*p).tag == (i64)47 || (i64)(*p).tag == (i64)59))) {
                    qq_lib$serror((byte*)"...name.$ needed");
                }
;
                p = qq_lib$createunit1((i64)48,p);
                qq_lex$lex();
            }
            break;
        default: {
            qq_lib$serror((byte*)"Unknown dot suffix");
        }
        } //SW
;
L553 :;
    }
L554 :;
    ;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readslist(i64 *nparams,i64 ftrailing) {
        struct qq_decls$unitrec *  ulist;
        struct qq_decls$unitrec *  ulistx;
        i64 donulls;
    ulist = (ulistx = 0);
    (*nparams) = (i64)0;
    qq_parse$skipsemi();
    if (((i64)qq_decls$lx.symbol == (i64)14)) {
        return ulist;
    }
;
    qq_parse$pushlisttype((i64)331808391504);
    donulls = (i64)1;
    L556 :;
    while (1) {
        qq_parse$skipsemi();
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)5)) {
            qq_lib$serror((byte*)"null comma expr not allowed");
        }
        else if (($temp==(i64)14)) {
            goto L557 ;
        }
        else {
            qq_lib$addlistunit(&ulist,&ulistx,qq_parse$readexpression());
            ++((*nparams));
            if (((i64)qq_decls$lx.symbol == (i64)5)) {
                qq_lex$lex();
                if (((i64)qq_decls$lx.symbol == (i64)14)) {
                    if ((((*nparams) != (i64)1) || !(!!(ftrailing)))) {
                        qq_lib$serror((byte*)"Trailing comma");
                    }
;
                    goto L557 ;
                }
;
            }
            else {
                qq_parse$skipsemi();
                if (((i64)qq_decls$lx.symbol == (i64)14)) {
                    goto L557 ;
                }
;
                qq_lib$serror((byte*)"SLIST?");
            }
;
        }
        };
    }
L557 :;
    ;
    qq_parse$poplisttype();
    return ulist;
}

static struct qq_decls$unitrec *qq_parse$readcondsuffix(struct qq_decls$unitrec *p) {
    switch ((i64)qq_decls$lx.symbol) {
    case 105:;
        {
            qq_lex$lex();
            return qq_lib$createunit2((i64)9,qq_parse$readexpression(),qq_lib$createunit1((i64)8,p));
        }
        break;
    case 101:;
        {
            qq_lex$lex();
            return qq_lib$createunit2((i64)9,qq_lib$createunit1((i64)91,qq_parse$readexpression()),qq_lib$createunit1((i64)8,p));
        }
        break;
    default: {
        return p;
    }
    } //SW
;
}

static struct qq_decls$unitrec *qq_parse$readkeyindex(struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  q;
    qq_lex$lex();
    q = qq_parse$readexpression();
    if (((i64)qq_decls$lx.symbol == (i64)5)) {
        qq_lex$lex();
        (*q).nextunit = qq_parse$readexpression();
    }
;
    p = qq_lib$createunit2((i64)62,p,q);
    qq_parse$checksymbol((i64)18);
    qq_lex$lex();
    return p;
}

static struct qq_decls$unitrec *qq_parse$readlbrack(void) {
        struct qq_decls$unitrec *  ulist;
        struct qq_decls$unitrec *  ulistx;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
        i64 length;
        i64 lower;
        i64 lowerseen;
        i64 elemtype;
        i64 opc;
    qq_lex$lex();
    ulist = (ulistx = 0);
    length = (i64)0;
    lower = (i64)1;
    lowerseen = (i64)0;
    elemtype = (i64)0;
    if ((((i64)qq_decls$lx.symbol == (i64)90) && ((i64)qq_decls$nextlx.symbol == (i64)7))) {
        elemtype = (i64)qq_decls$lx.subcode;
        qq_lex$lex();
        qq_lex$lex();
    }
;
    if ((((i64)qq_decls$lx.symbol == (i64)79) && ((i64)qq_decls$nextlx.symbol == (i64)7))) {
        lower = qq_decls$lx.value;
        lowerseen = (i64)1;
        qq_lex$lex();
        qq_lex$lex();
    }
;
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)14)) {
        qq_lex$lex();
        p = qq_lib$createunit0((i64)197);
        (*p).length = (i64)0;
        (*p).lower = lower;
        (*p).elemtype = elemtype;
        return p;
    }
    else {
        if ((((!!((i64)qq_tables$binopset[((i64)qq_decls$lx.symbol)]) || !!((i64)qq_tables$unaryopset[((i64)qq_decls$lx.symbol)])) || ((i64)qq_decls$lx.symbol == (i64)72)) && ((i64)qq_decls$nextlx.symbol == (i64)14))) {
            opc = (i64)qq_tables$jpclcodes[((i64)qq_decls$lx.subcode)];
            if (((i64)qq_decls$lx.symbol == (i64)25)) {
                opc = (i64)190;
            }
;
            //doopc:
L558 :;
;
            if ((opc == (i64)0)) {
                qq_lib$pcerror((byte*)"Bad op");
            }
;
            p = qq_lib$createunit0((i64)7);
            (*p).pclopcode = opc;
            qq_lex$lex();
            qq_parse$checksymbol((i64)14);
            qq_lex$lex();
            return p;
        }
        else {
                        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)175)) {
                                {i64 $temp = (i64)qq_decls$lx.subcode;
if (($temp==(i64)45)) {
                    opc = (i64)101;
                }
                else if (($temp==(i64)23899)) {
                    opc = (i64)210;
                }
                else {
                    opc = (i64)0;
                }
                };
                goto L558 ;
;
            }
            else if (($temp==(i64)50)) {
                opc = (i64)176;
                goto L558 ;
;
            }
            else if (($temp==(i64)51)) {
                opc = (i64)177;
                goto L558 ;
;
            }
            else if (($temp==(i64)52)) {
                opc = (i64)178;
                goto L558 ;
;
            }
            else if (($temp==(i64)26)) {
                opc = (i64)189;
                goto L558 ;
;
            }
            else {
                p = qq_parse$readxunit();
            }
            };
        }
;
    }
    };
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)14)) {
        qq_lex$lex();
        if (!!(lowerseen)) {
            p = qq_lib$createunit2((i64)5,qq_lib$createintunit(lower),p);
        }
;
        return p;
    }
    else if (($temp==(i64)5)) {
        length = (i64)1;
        if (((i64)qq_decls$nextlx.symbol == (i64)14)) {
            qq_lex$lex();
            qq_lex$lex();
            p = qq_lib$createunit1((i64)197,p);
            (*p).length = length;
            (*p).lower = lower;
            (*p).elemtype = elemtype;
            return p;
        }
;
        ulist = (ulistx = p);
        L559 :;
        do {
            qq_lex$lex();
            if (((i64)qq_decls$lx.symbol == (i64)14)) {
                goto L561 ;
            }
;
            if (((i64)qq_decls$lx.symbol == (i64)5)) {
                qq_lib$serror((byte*)",, null expr not allowed");
            }
;
            qq_lib$addlistunit(&ulist,&ulistx,qq_parse$readxunit());
            ++(length);
            qq_parse$skipsemi();
L560 :;
        }
        while (!((i64)qq_decls$lx.symbol != (i64)5));
L561 :;
        ;
        qq_parse$checksymbol((i64)14);
        qq_lex$lex();
        p = qq_lib$createunit1((i64)197,ulist);
        (*p).length = length;
        (*p).lower = lower;
        (*p).elemtype = elemtype;
        return p;
    }
    else if (($temp==(i64)20)) {
        qq_lex$lex();
        q = qq_parse$readxunit();
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)20)) {
            qq_lex$lex();
            r = qq_parse$readsunit((i64)0);
            qq_parse$checksymbol((i64)14);
            qq_lex$lex();
            (*q).nextunit = r;
            return qq_lib$createunit2((i64)9,p,q);
        }
        else if (($temp==(i64)14)) {
            qq_lex$lex();
            return qq_lib$createunit2((i64)9,p,q);
        }
        };
        qq_lib$addlistunit(&ulist,&ulistx,q);
        qq_parse$checksymbol((i64)5);
        if (((i64)qq_decls$nextlx.symbol != (i64)20)) {
            L562 :;
            do {
                qq_lex$lex();
                qq_lib$addlistunit(&ulist,&ulistx,qq_parse$readxunit());
L563 :;
            }
            while (!((i64)qq_decls$lx.symbol != (i64)5));
L564 :;
            ;
            qq_parse$checksymbol((i64)20);
        }
        else {
            qq_lex$lex();
        }
;
        qq_lex$lex();
        r = qq_parse$readxunit();
        qq_parse$checksymbol((i64)14);
        qq_lex$lex();
        (*p).nextunit = r;
        return qq_lib$createunit2((i64)10,p,ulist);
    }
    else if (($temp==(i64)6)) {
        ulist = (ulistx = p);
        L565 :;
        do {
            qq_parse$skipsemi();
            if (((i64)qq_decls$lx.symbol == (i64)14)) {
                goto L567 ;
            }
;
            qq_lib$addlistunit(&ulist,&ulistx,qq_parse$readexpression());
L566 :;
        }
        while (!((i64)qq_decls$lx.symbol != (i64)6));
L567 :;
        ;
        qq_parse$checksymbol((i64)14);
        qq_lex$lex();
        return qq_parse$makeblock(ulist);
    }
    else {
        qq_lib$serror((byte*)"(x ...");
    }
    };
    return (struct qq_decls$unitrec *)0;
}

static struct qq_decls$unitrec *qq_parse$readif(void) {
        i64 line;
        i64 kwd;
        struct qq_decls$unitrec *  pthen;
        struct qq_decls$unitrec *  pcond;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  p;
    line = (i64)qq_decls$lx.pos;
    kwd = (i64)qq_decls$lx.symbol;
    qq_lex$lex();
    pcond = qq_parse$readsunit((i64)0);
    qq_parse$skipsemi();
    qq_parse$checksymbol((i64)94);
    qq_lex$lex();
    pthen = qq_parse$readsunit((i64)0);
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)95)) {
        qq_decls$lx.symbol = (i64)93;
        pelse = qq_parse$readif();
    }
    else if (($temp==(i64)96)) {
        qq_lex$lex();
        pelse = qq_parse$readsunit((i64)0);
        qq_parse$checkend((i64)100,kwd,(i64)0,(i64)0);
        qq_lex$lex();
    }
    else if (($temp==(i64)97) || ($temp==(i64)98)) {
        qq_decls$lx.symbol = kwd;
        pelse = qq_parse$makeblock(qq_parse$readswitchcase());
    }
    else {
        pelse = 0;
        qq_parse$checkend((i64)100,kwd,(i64)0,(i64)0);
        qq_lex$lex();
    }
    };
    (*pthen).nextunit = pelse;
    p = qq_lib$createunit2((i64)9,pcond,pthen);
    (*p).pos = line;
    return p;
}

static void qq_parse$checkend(i64 endsym,i64 endkwd1,i64 endkwd2,i64 startline) {
        u8 str[100];
    if ((endsym==(i64)qq_decls$lx.symbol && (i64)qq_decls$lx.symbol==(i64)14)) {
        return;
    }
;
    if (((i64)qq_decls$lx.symbol != (i64)100)) {
        strcpy((u8 *)str,(byte*)"Bad 'end' ");
        //error:
L568 :;
;
        if (!!(startline)) {
            msysc$m_print_startstr((str + strlen((u8 *)str)));
            msysc$m_print_setfmt((byte*)" (from line #)");
            msysc$m_print_i64(startline,NULL);
            msysc$m_print_end();
            ;
        }
;
        qq_lib$serror((u8 *)str);
    }
;
    if (((i64)qq_decls$lx.subcode == (i64)0)) {
        return;
    }
;
    if (!(((!!(endkwd1) && (endkwd1 == (i64)qq_decls$lx.subcode)) || (!!(endkwd2) && (endkwd2 == (i64)qq_decls$lx.subcode))))) {
        strcpy((u8 *)str,(byte*)"Mismatched 'end'");
        goto L568 ;
;
    }
;
}

static struct qq_decls$unitrec *qq_parse$readunless(void) {
        i64 line;
        struct qq_decls$unitrec *  pcond;
        struct qq_decls$unitrec *  pthen;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  p;
    line = (i64)qq_decls$lx.pos;
    qq_lex$lex();
    pcond = qq_parse$readsunit((i64)0);
    qq_parse$checksymbol((i64)94);
    qq_lex$lex();
    pthen = qq_parse$readsunit((i64)0);
    if (((i64)qq_decls$lx.symbol == (i64)96)) {
        qq_lex$lex();
        pelse = qq_parse$readsunit((i64)0);
    }
    else {
        pelse = 0;
    }
;
    qq_parse$checkend((i64)100,(i64)101,(i64)0,(i64)0);
    qq_lex$lex();
    (*pthen).nextunit = pelse;
    p = qq_lib$createunit2((i64)9,qq_lib$createunit1((i64)91,pcond),pthen);
    (*p).pos = line;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readwhile(void) {
        i64 pos;
        struct qq_decls$unitrec *  pcond;
        struct qq_decls$unitrec *  pbody;
        struct qq_decls$unitrec *  p;
    pos = (i64)qq_decls$lx.pos;
    qq_lex$lex();
    pcond = qq_parse$readsunit((i64)1);
    if (((i64)qq_decls$lx.symbol == (i64)5)) {
        qq_lex$lex();
        (*pcond).nextunit = qq_parse$readsunit((i64)1);
    }
;
    qq_parse$checksymbol((i64)110);
    qq_lex$lex();
    pbody = qq_parse$readsunit((i64)0);
    qq_parse$checkend((i64)100,(i64)112,(i64)110,(i64)0);
    qq_lex$lex();
    p = qq_lib$createunit2((i64)27,pcond,pbody);
    (*p).pos = pos;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readrepeat(void) {
        i64 pos;
        struct qq_decls$unitrec *  pbody;
        struct qq_decls$unitrec *  pcond;
        struct qq_decls$unitrec *  p;
    pos = (i64)qq_decls$lx.pos;
    qq_lex$lex();
    pbody = qq_parse$readsunit((i64)0);
    qq_parse$checksymbol((i64)114);
    qq_lex$lex();
    pcond = qq_parse$readexpression();
    p = qq_lib$createunit2((i64)28,pbody,pcond);
    (*p).pos = pos;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readfor(void) {
        i64 line;
        i64 opc;
        i64 down;
        i64 isforeach;
        struct qq_decls$unitrec *  pstep;
        struct qq_decls$unitrec *  pvar;
        struct qq_decls$unitrec *  pcond;
        struct qq_decls$unitrec *  pfrom;
        struct qq_decls$unitrec *  pto;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  pbody;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  plist;
        struct qq_decls$unitrec *  pvar2;
    line = (i64)qq_decls$lx.pos;
    isforeach = (i64)qq_decls$lx.subcode;
    qq_lex$lex();
    pvar = qq_parse$readterm2();
    if (((i64)(*pvar).tag != (i64)47)) {
        qq_lib$serror((byte*)"For: name expected");
    }
    else {
        (*(*pvar).def).forindex = (i64)1;
    }
;
    opc = (i64)17;
    pstep = 0;
    pcond = 0;
    pvar2 = 0;
    if (((i64)qq_decls$lx.symbol == (i64)5)) {
        qq_lex$lex();
        pvar2 = qq_parse$readterm2();
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)50 || (i64)qq_decls$lx.symbol == (i64)53)) {
        down = (i64)((i64)qq_decls$lx.symbol == (i64)53);
        qq_lex$lex();
        plist = qq_parse$readexpression();
                {i64 $temp = (i64)(*plist).tag;
if (($temp==(i64)195)) {
            opc = (i64)17;
            pfrom = (*plist).a;
            pto = (*plist).b;
        }
        else if (($temp==(i64)121)) {
            (*plist).tag = (i64)122;
            opc = (i64)18;
        }
        else {
            opc = (i64)21;
        }
        };
    }
    else {
        if (((i64)qq_decls$lx.symbol == (i64)9)) {
            qq_lex$lex();
            pfrom = qq_parse$readexpression();
        }
        else {
            pfrom = qq_lib$createintunit((i64)1);
        }
;
        qq_parse$checksymbol((i64)108);
        down = (i64)((i64)qq_decls$lx.subcode == (i64)1);
        opc = (i64)17;
        qq_lex$lex();
        pto = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)109)) {
            qq_lex$lex();
            pstep = qq_parse$readexpression();
            if (((i64)(*pstep).tag != (i64)50)) {
                qq_lib$serror((byte*)"BY needs int constant");
            }
;
            if (((*pstep).value < (i64)0)) {
                qq_lib$serror((byte*)"Step must be positive");
            }
            else if (((*pstep).value == (i64)0)) {
                qq_lib$serror((byte*)"Zero step");
            }
;
            (*pstep).value = m$llabs((*pstep).value);
            if (((*pstep).value == (i64)1)) {
                pstep = 0;
            }
;
        }
;
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)105)) {
        qq_lex$lex();
        pcond = qq_parse$readexpression();
    }
;
    qq_parse$checksymbol((i64)110);
    qq_lex$lex();
    pbody = qq_parse$readsunit((i64)0);
    if ((pcond != 0)) {
        pbody = qq_parse$makeblock(qq_lib$createunit2((i64)9,pcond,pbody));
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)96)) {
        qq_lex$lex();
        pelse = qq_parse$readsunit((i64)0);
        (*pbody).nextunit = pelse;
    }
    else {
        pelse = 0;
    }
;
    qq_parse$checkend((i64)100,(i64)106,(i64)110,(i64)0);
    qq_lex$lex();
    if ((opc==(i64)21)) {
        (*pvar).nextunit = plist;
        (*plist).nextunit = pvar2;
        p = qq_lib$createunit2((!!(down) ? (i64)22 : (i64)21),pvar,pbody);
    }
    else if ((opc==(i64)18)) {
        (*pvar).nextunit = plist;
        p = qq_lib$createunit2((!!(down) ? (i64)20 : (i64)18),pvar,pbody);
    }
    else {
        (*pvar).nextunit = pfrom;
        (*pfrom).nextunit = pto;
        (*pto).nextunit = pstep;
        p = qq_lib$createunit2((!!(down) ? (i64)19 : (i64)17),pvar,pbody);
    }
;
    if (!!(isforeach)) {
        if (((i64)(*p).tag == (i64)21)) {
            (*p).tag = (i64)23;
        }
        else {
            qq_lib$serror((byte*)"Foreach?");
        }
;
    }
;
    (*p).pos = line;
    if ((!!(pvar2) && !((opc == (i64)21 || opc == (i64)22)))) {
        qq_lib$serror((byte*)"for i,j not allowed");
    }
;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readdo(void) {
        struct qq_decls$unitrec *  p;
        i64 line;
        i64 opc;
    line = (i64)qq_decls$lx.pos;
    opc = (((i64)qq_decls$lx.symbol == (i64)110) ? (i64)24 : (i64)25);
    qq_lex$lex();
    p = qq_parse$readsunit((i64)0);
    qq_parse$checkend((i64)100,(i64)110,(i64)0,(i64)0);
    qq_lex$lex();
    p = qq_lib$createunit1(opc,p);
    (*p).pos = line;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readto(void) {
        i64 line;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  pcount;
        struct qq_decls$unitrec *  pbody;
    line = (i64)qq_decls$lx.pos;
    qq_lex$lex();
    pcount = qq_parse$readexpression();
    qq_parse$checksymbol((i64)110);
    qq_lex$lex();
    pbody = qq_parse$readsunit((i64)0);
    qq_parse$checkend((i64)100,(i64)108,(i64)110,(i64)0);
    qq_lex$lex();
    (*pcount).nextunit = qq_lib$createavname();
    p = qq_lib$createunit2((i64)26,pcount,pbody);
    (*p).pos = line;
    return p;
}

static struct qq_decls$unitrec *qq_parse$makeblock(struct qq_decls$unitrec *p) {
    return qq_lib$createunit1((i64)8,p);
}

static struct qq_decls$unitrec *qq_parse$readvardef(i64 islet,i64 isglobal,i64 isstatic) {
        i64 nvars;
        i64 varid;
        i64 m;
        i64 opc;
        struct qq_decls$strec *  d;
        struct qq_decls$unitrec *  ulist;
        struct qq_decls$unitrec *  ulistx;
        struct qq_decls$unitrec *  p;
    if ((qq_decls$stcurrproc == qq_decls$stmglobals)) {
        isstatic = (i64)1;
    }
;
    m = qq_parse$readtypespec((i64)((i64)qq_decls$lx.symbol == (i64)139),0);
    if (((i64)(*qq_decls$stcurrproc).nameid == (i64)5)) {
        varid = (!!(isstatic) ? (i64)11 : (i64)12);
    }
    else {
        varid = (i64)11;
    }
;
    nvars = (i64)0;
    ulist = (ulistx = 0);
    L569 :;
    while (((i64)qq_decls$lx.symbol == (i64)89)) {
        ++(nvars);
        d = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,varid,isglobal);
        qq_lib$storemode(qq_decls$stcurrproc,m,&(*d).mode);
        qq_lex$lex();
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)9) || ($temp==(i64)10)) {
            opc = (i64)qq_decls$lx.subcode;
            if ((varid == (i64)11)) {
                if (((i64)(*qq_decls$stcurrproc).nameid == (i64)5)) {
                    qq_lib$serror((byte*)"Need '=' for static in proc");
                }
;
            }
;
            (*d).flags = msysc$m_setdotslice((*d).flags,(i64)11,(i64)12,(u64)(((i64)qq_decls$lx.symbol == (i64)9) ? (i64)2 : (i64)3));
            qq_lex$lex();
            (*d).code = qq_parse$readexpression();
            if ((varid == (i64)12)) {
                p = qq_lib$createunit2(opc,(struct qq_decls$unitrec *)qq_lib$createname((struct qq_decls$strec *)d),(*d).code);
                qq_lib$addlistunit(&ulist,&ulistx,p);
            }
;
        }
        else if (($temp==(i64)55)) {
            if ((varid != (i64)11)) {
                qq_lib$serror((byte*)"Need ':=' for non-static");
            }
;
            qq_lex$lex();
            (*d).flags = msysc$m_setdotslice((*d).flags,(i64)11,(i64)12,(u64)1u);
            (*d).code = qq_parse$readexpression();
        }
        else {
            if (!!(islet)) {
                qq_lib$serror((byte*)"let needs :=");
            }
;
        }
        };
        if (((i64)qq_decls$lx.symbol != (i64)5)) {
            goto L571 ;
        }
;
        qq_lex$lex();
L570 :;
    }
L571 :;
    ;
    if ((nvars == (i64)0)) {
        qq_lib$serror((byte*)"No vars declared");
    }
;
    return ulist;
}

static void qq_parse$readconstdef(i64 isglobal) {
        i64 nvars;
        struct qq_decls$strec *  d;
    qq_lex$lex();
    nvars = (i64)0;
    L572 :;
    while (((i64)qq_decls$lx.symbol == (i64)89)) {
        ++(nvars);
        d = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)16,isglobal);
        qq_parse$lexchecksymbol((i64)55);
        qq_lex$lex();
        (*d).code = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol != (i64)5)) {
            goto L574 ;
        }
;
        qq_lex$lex();
L573 :;
    }
L574 :;
    ;
    if ((nvars == (i64)0)) {
        qq_lib$serror((byte*)"No consts declared");
    }
;
}

static struct qq_decls$unitrec *qq_parse$readreturn(void) {
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
    qq_lex$lex();
    q = 0;
    if (!!((i64)qq_tables$exprstarterset[((i64)qq_decls$lx.symbol)])) {
        q = qq_parse$readexpression();
    }
;
    p = qq_lib$createunit1((i64)39,q);
    return qq_parse$readcondsuffix(p);
}

static struct qq_decls$unitrec *qq_parse$readprint(void) {
        i64 opc;
        i64 isfprint;
        i64 fshowname;
        struct qq_decls$unitrec *  pformat;
        struct qq_decls$unitrec *  pdev;
        struct qq_decls$unitrec *  printlist;
        struct qq_decls$unitrec *  printlistx;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
        struct mlib$strbuffer *  expr;
        u8 *  s;
    qq_parse$pushlisttype((i64)362090680912);
    opc = (i64)qq_decls$lx.subcode;
    if ((opc==(i64)72) || (opc==(i64)73)) {
        isfprint = (i64)1;
    }
    else {
        isfprint = (i64)0;
    }
;
    qq_lex$lex();
    printlist = (printlistx = 0);
    pformat = (pdev = 0);
    if (((i64)qq_decls$lx.symbol == (i64)22)) {
        qq_lex$lex();
        pdev = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)5)) {
            qq_lex$lex();
        }
        else {
            goto L575 ;
;
        }
;
    }
;
    if (!!(isfprint)) {
        pformat = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)5)) {
            qq_lex$lex();
        }
        else {
            goto L575 ;
;
        }
;
    }
;
    if (!(!!((i64)qq_tables$exprstarterset[((i64)qq_decls$lx.symbol)]))) {
        goto L575 ;
;
    }
;
    L576 :;
    while (1) {
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)5)) {
            qq_lib$addlistunit(&printlist,&printlistx,qq_lib$createunit0((i64)76));
        }
        else if (($temp==(i64)162)) {
            qq_lib$addlistunit(&printlist,&printlistx,qq_lib$createunit0((i64)77));
            qq_lex$lex();
        }
        else {
            fshowname = (i64)0;
            if (((i64)qq_decls$lx.symbol == (i64)55)) {
                fshowname = (i64)1;
                qq_lex$lex();
            }
;
            p = qq_parse$readexpression();
            if (((i64)qq_decls$lx.symbol == (i64)7)) {
                qq_lex$lex();
                p = qq_lib$createunit2((i64)78,p,qq_parse$readexpression());
            }
;
            if (!!(fshowname)) {
                expr = (struct mlib$strbuffer *)qq_lib$strexpr(p);
                mlib$strbuffer_add((struct mlib$strbuffer *)expr,(byte*)"=",(i64)-1);
                s = (*expr).strptr;
                mlib$iconvucn((*expr).strptr,(i64)(*expr).length);
                qq_lib$addlistunit(&printlist,&printlistx,(q = qq_lib$createstringunit(s,(i64)(*expr).length)));
            }
;
            qq_lib$addlistunit(&printlist,&printlistx,p);
        }
        };
        if (((i64)qq_decls$lx.symbol != (i64)5)) {
            goto L577 ;
        }
;
        qq_lex$lex();
    }
L577 :;
    ;
    //finish:
L575 :;
;
    if (((opc == (i64)70) && (printlist == 0))) {
        qq_lib$serror((byte*)"No print items");
    }
;
    if ((((opc == (i64)72) && (printlist == 0)) && (pformat == 0))) {
        qq_lib$serror((byte*)"No print items");
    }
;
    qq_parse$poplisttype();
    if (!!(isfprint)) {
        if ((pformat == 0)) {
            qq_lib$serror((byte*)"No fmt str");
        }
;
        if ((pformat == 0)) {
            pformat = qq_parse$makeblock(pformat);
        }
;
        (*pformat).nextunit = printlist;
        return qq_lib$createunit2(opc,pdev,pformat);
        return pformat;
    }
    else {
        return qq_lib$createunit2(opc,pdev,printlist);
    }
;
}

static struct qq_decls$unitrec *qq_parse$readread(void) {
        i64 opc;
        struct qq_decls$unitrec *  pformat;
        struct qq_decls$unitrec *  pdev;
        struct qq_decls$unitrec *  readlist;
        struct qq_decls$unitrec *  readlistx;
        struct qq_decls$unitrec *  p;
    qq_parse$pushlisttype((i64)362090680912);
    opc = (i64)qq_decls$lx.subcode;
    qq_lex$lex();
    readlist = (readlistx = 0);
    pformat = (pdev = 0);
    if (((i64)qq_decls$lx.symbol == (i64)22)) {
        if ((opc == (i64)79)) {
            qq_lib$serror((byte*)"@ on read");
        }
;
        qq_lex$lex();
        pdev = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)5)) {
            qq_lex$lex();
        }
        else {
            goto L578 ;
;
        }
;
    }
;
    if (!(!!((i64)qq_tables$exprstarterset[((i64)qq_decls$lx.symbol)]))) {
        goto L578 ;
;
    }
;
    L579 :;
    while (1) {
        p = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)7)) {
            qq_lex$lex();
            p = qq_lib$createunit2((i64)78,p,qq_parse$readexpression());
        }
;
        qq_lib$addlistunit(&readlist,&readlistx,p);
        if (((i64)qq_decls$lx.symbol != (i64)5)) {
            goto L580 ;
        }
;
        qq_lex$lex();
    }
L580 :;
    ;
    //finish:
L578 :;
;
    if (((opc == (i64)79) && (readlist == 0))) {
        qq_lib$serror((byte*)"No read items");
    }
;
    qq_parse$poplisttype();
    return qq_lib$createunit2(opc,pdev,readlist);
}

static struct qq_decls$unitrec *qq_parse$readloopcontrol(void) {
        i64 opc;
        struct qq_decls$unitrec *  p;
    opc = (i64)qq_decls$lx.subcode;
    qq_lex$lex();
    if ((((i64)qq_decls$lx.symbol == (i64)89) && !!(mlib$eqstring((*qq_decls$lx.symptr).name,(byte*)"all")))) {
        qq_lex$lex();
        p = qq_lib$createunit1(opc,qq_lib$createintunit((i64)0));
    }
    else if (!!((i64)qq_tables$exprstarterset[((i64)qq_decls$lx.symbol)])) {
        p = qq_lib$createunit1(opc,qq_parse$readintunit());
    }
    else {
        p = qq_lib$createunit1(opc,qq_lib$createintunit((i64)1));
    }
;
    return qq_parse$readcondsuffix(p);
}

static struct qq_decls$unitrec *qq_parse$readintunit(void) {
        struct qq_decls$unitrec *  p;
    p = qq_parse$readexpression();
    if (((i64)(*p).tag != (i64)50)) {
        qq_lib$serror((byte*)"int expr needed");
    }
;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readswitchcase(void) {
        i64 pos;
        i64 kwd;
        i64 opc;
        i64 rangeused;
        i64 nwhen;
        struct qq_decls$unitrec *  pexpr;
        struct qq_decls$unitrec *  pwhenlist;
        struct qq_decls$unitrec *  pwhenlistx;
        struct qq_decls$unitrec *  pwhen;
        struct qq_decls$unitrec *  pwhenx;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  pthen;
        struct qq_decls$unitrec *  pwhenthen;
    pos = (i64)qq_decls$lx.pos;
    kwd = (i64)qq_decls$lx.symbol;
    opc = (i64)qq_decls$lx.subcode;
    qq_lex$lex();
    qq_parse$skipsemi();
    if (((i64)qq_decls$lx.symbol == (i64)105)) {
        if ((kwd == (i64)119)) {
            qq_lib$serror((byte*)"switch expr missing");
        }
;
        pexpr = qq_lib$createunit0((i64)0);
    }
    else {
        pexpr = qq_parse$readsunit((i64)0);
    }
;
    pwhenlist = (pwhenlistx = 0);
    rangeused = (i64)0;
    nwhen = (i64)0;
    qq_parse$skipsemi();
    L581 :;
    while (((i64)qq_decls$lx.symbol == (i64)105)) {
        pos = (i64)qq_decls$lx.pos;
        qq_lex$lex();
        pwhen = (pwhenx = 0);
        L584 :;
        while (1) {
            p = qq_parse$readexpression();
            ++(nwhen);
            (*p).pos = pos;
            if (((i64)(*p).tag == (i64)195)) {
                rangeused = (i64)1;
            }
;
            qq_lib$addlistunit(&pwhen,&pwhenx,p);
            if (((i64)qq_decls$lx.symbol != (i64)5)) {
                goto L585 ;
            }
;
            qq_lex$lex();
        }
L585 :;
        ;
        if (((i64)qq_decls$lx.symbol != (i64)94)) {
            qq_parse$checksymbol((i64)11);
        }
;
        qq_lex$lex();
        pthen = qq_parse$readsunit((i64)0);
        pwhenthen = qq_lib$createunit2((i64)11,pwhen,pthen);
        (*pwhenthen).pos = pos;
        qq_lib$addlistunit(&pwhenlist,&pwhenlistx,pwhenthen);
L582 :;
    }
L583 :;
    ;
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)96)) {
        qq_lex$lex();
        pelse = qq_parse$readsunit((i64)0);
        qq_parse$checkend((i64)100,kwd,(i64)0,(i64)0);
        qq_lex$lex();
    }
    else if (($temp==(i64)95)) {
        qq_decls$lx.symbol = kwd;
        pelse = qq_parse$makeblock(qq_parse$readif());
    }
    else if (($temp==(i64)97) || ($temp==(i64)98)) {
        qq_decls$lx.symbol = kwd;
        pelse = qq_parse$readswitchcase();
    }
    else {
        pelse = 0;
        qq_parse$checkend((i64)100,kwd,(i64)0,(i64)0);
        qq_lex$lex();
    }
    };
    (*pexpr).nextunit = pelse;
    p = qq_lib$createunit2(opc,pexpr,pwhenlist);
    (*p).pos = pos;
    return p;
}

static struct qq_decls$unitrec *qq_parse$readgoto(void) {
    qq_lex$lex();
    return qq_parse$readcondsuffix(qq_lib$createunit1((i64)37,qq_parse$readexpression()));
}

static struct qq_decls$unitrec *qq_parse$readstop(void) {
        struct qq_decls$unitrec *  p;
    qq_lex$lex();
    if (!!((i64)qq_tables$exprstarterset[((i64)qq_decls$lx.symbol)])) {
        p = qq_lib$createunit1((i64)38,qq_parse$readexpression());
    }
    else {
        p = qq_lib$createunit1((i64)38,qq_lib$createintunit((i64)0));
    }
;
    return qq_parse$readcondsuffix(p);
}

static struct qq_decls$unitrec *qq_parse$readcast(void) {
        struct qq_decls$unitrec *  p;
        i64 t;
        i64 opc;
    t = (i64)qq_decls$lx.subcode;
    qq_lex$lex();
    if (((t == (i64)6) && ((i64)qq_decls$lx.symbol == (i64)13))) {
        qq_lex$lex();
        p = qq_parse$readexpression();
        if (((i64)(*p).tag == (i64)5 || (i64)(*p).tag == (i64)4)) {
            (*p).tag = (i64)196;
        }
        else if (((i64)(*p).tag == (i64)195)) {
        }
        else {
            qq_lib$serror((byte*)"need a..b or a:n");
        }
;
        qq_parse$checksymbol((i64)14);
        qq_lex$lex();
        return p;
    }
;
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)22) || ($temp==(i64)13)) {
    }
    else {
        p = qq_lib$createunit0((i64)41);
        (*p).mode = t;
        return p;
    }
    };
    if (((i64)qq_decls$lx.symbol == (i64)22)) {
        qq_lex$lex();
        opc = (i64)44;
    }
    else {
        opc = (i64)43;
    }
;
    qq_parse$checksymbol((i64)13);
    p = qq_parse$readterm();
    p = qq_lib$createunit1(opc,p);
    qq_lib$storemode(qq_decls$stcurrproc,t,&(*p).mode);
    return p;
}

static struct qq_decls$unitrec *qq_parse$readset(void) {
        i64 length;
        i64 nkeyvalues;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  ulist;
        struct qq_decls$unitrec *  ulistx;
    qq_lex$lex();
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)16)) {
        qq_lex$lex();
        return qq_lib$createunit1((i64)198,0);
    }
    else if (($temp==(i64)7)) {
        qq_parse$lexchecksymbol((i64)16);
        qq_lex$lex();
        return qq_lib$createunit1((i64)199,0);
    }
    };
    qq_parse$pushlisttype((i64)1413695812);
    p = qq_parse$readexpression();
    length = (i64)1;
    nkeyvalues = (i64)0;
    if (((i64)(*p).tag == (i64)5)) {
        ++(nkeyvalues);
    }
;
    ulist = (ulistx = p);
    L586 :;
    while (((i64)qq_decls$lx.symbol == (i64)5)) {
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)16)) {
            goto L588 ;
        }
;
        qq_lib$addlistunit(&ulist,&ulistx,(p = qq_parse$readexpression()));
        if (((i64)(*p).tag == (i64)5)) {
            ++(nkeyvalues);
        }
;
        ++(length);
        qq_parse$skipsemi();
L587 :;
    }
L588 :;
    ;
    qq_parse$checksymbol((i64)16);
    qq_lex$lex();
    if (!!(nkeyvalues)) {
        if ((length > nkeyvalues)) {
            qq_lib$serror((byte*)"dict: mixed elements");
        }
;
        p = qq_lib$createunit1((i64)199,ulist);
    }
    else {
        p = qq_lib$createunit1((i64)198,ulist);
    }
;
    (*p).length = length;
    qq_parse$poplisttype();
    return p;
}

void qq_parse$readtabledef(i64 isglobal) {
        i64 i;
        i64 ncols;
        i64 nrows;
        i64 enums;
        i64 nextenumvalue;
        i64 startline;
        i64 closesym;
        i64 enummode;
        i64 firstvalue;
        byte commas;
        byte semis;
        struct qq_decls$unitrec *  ulist;
        struct qq_decls$unitrec *  ulistx;
        struct qq_decls$unitrec *  p;
        struct qq_decls$strec *  varnames[20];
        struct qq_decls$unitrec *  plist[20];
        struct qq_decls$unitrec *  plistx[20];
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
    commas = (i64)0;
    semis = (i64)0;
    enums = (i64)qq_decls$lx.subcode;
    qq_lex$lex();
    e = 0;
    enummode = (i64)0;
    if (((i64)qq_decls$lx.symbol == (i64)13)) {
        if (!(!!(enums))) {
            qq_lib$serror((byte*)"use 'enumdata'");
        }
;
        enums = (i64)1;
        qq_lex$lex();
        qq_parse$checksymbol((i64)89);
        e = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)8,isglobal);
        enummode = qq_names$addusertype(e);
        qq_lex$lex();
        qq_parse$checksymbol((i64)14);
        qq_lex$lex();
    }
;
    firstvalue = (nextenumvalue = (i64)1);
    nrows = (i64)0;
    ncols = (i64)0;
    L589 :;
    while (((i64)qq_decls$lx.symbol == (i64)89)) {
        if ((++(ncols) > (i64)20)) {
            qq_lib$serror((byte*)"tabledata/too many columns");
        }
;
        varnames[(ncols)-1] = (struct qq_decls$strec *)qq_decls$lx.symptr;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)5)) {
            qq_lex$lex();
        }
        else {
            goto L591 ;
        }
;
L590 :;
    }
L591 :;
    ;
    qq_parse$checkequals();
    qq_lex$lex();
    qq_parse$skipsemi();
    startline = (i64)qq_decls$lx.pos;
    closesym = qq_parse$checkbegin((i64)0);
    qq_parse$skipsemi();
    for (i=(i64)1;i<=ncols;++i) {
L592 :;
        plist[(i)-1] = (plistx[(i)-1] = 0);
L593 :;
    }
L594 :;
    ;
    ulist = (ulistx = 0);
    qq_parse$intabledata = (i64)1;
    L595 :;
    while (1) {
        qq_parse$skipsemi();
        if ((ncols > (i64)0)) {
            qq_parse$checksymbol((i64)13);
            qq_lex$lex();
        }
;
        if ((++(nrows) > (i64)500)) {
            qq_lib$serror((byte*)"tabledata:too many rows");
        }
;
        if (!!(enums)) {
            qq_parse$checksymbol((i64)89);
            d = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)17,isglobal);
            (*d).mode = enummode;
            qq_lex$lex();
                        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)55)) {
                if ((nrows > (i64)1)) {
                    qq_lib$serror((byte*)"tabledata '=' not 1st");
                }
;
                qq_lex$lex();
                p = qq_parse$readexpression();
                if (((i64)(*p).tag == (i64)50)) {
                    firstvalue = (nextenumvalue = (*p).value);
                }
                else {
                    qq_lib$serror((byte*)"TABLEDATA: COMPLEX ENUM VAL");
                }
;
            }
            };
            (*d).index = (nextenumvalue)++;
            qq_parse$tabledataname = (*d).name;
            if (!!(ncols)) {
                qq_parse$checksymbol((i64)5);
                qq_lex$lex();
            }
;
        }
;
        for (i=(i64)1;i<=ncols;++i) {
L597 :;
            qq_lib$addlistunit(&plist[(i)-1],&plistx[(i)-1],qq_parse$readexpression());
            if ((i == ncols)) {
                qq_parse$checksymbol((i64)14);
            }
            else {
                qq_parse$checksymbol((i64)5);
            }
;
            qq_lex$lex();
L598 :;
        }
L599 :;
        ;
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)5)) {
            ++(commas);
            qq_lex$lex();
            if (((i64)qq_decls$lx.symbol == closesym)) {
                goto L596 ;
            }
;
        }
        else {
            qq_parse$skipsemi();
            if (((i64)qq_decls$lx.symbol == closesym)) {
                goto L596 ;
            }
;
            ++(semis);
        }
        };
    }
L596 :;
    ;
    if ((!!((i64)semis) && !!((i64)commas))) {
        qq_lib$serror((byte*)"mixed commas");
    }
;
    qq_parse$intabledata = (i64)0;
    qq_parse$skipsemi();
    qq_parse$checkbeginend(closesym,(i64)164,startline);
    if ((nrows == (i64)0)) {
        qq_lib$serror((byte*)"No table data");
    }
;
    for (i=(i64)1;i<=ncols;++i) {
L600 :;
        d = qq_names$addsymbol(qq_decls$stcurrproc,varnames[(i)-1],(i64)11,isglobal);
        p = ((*d).code = qq_lib$createunit1((i64)197,plist[(i)-1]));
        (*p).length = nrows;
        (*p).lower = firstvalue;
L601 :;
    }
L602 :;
    ;
    if ((e == 0)) {
        return;
    }
;
    (*e).mode = enummode;
    qq_tables$ttfields[(enummode)] = (*qq_decls$stcurrproc).deflist;
    qq_tables$ttlength[(enummode)] = nrows;
    qq_tables$ttlower[(enummode)] = firstvalue;
    qq_tables$ttbasetype[(enummode)] = (i64)7;
}

static struct qq_decls$unitrec *qq_parse$readtry(void) {
        struct qq_decls$unitrec *  ptry;
        struct qq_decls$unitrec *  pexceptlist;
        struct qq_decls$unitrec *  pexceptlistx;
        struct qq_decls$unitrec *  px;
        struct qq_decls$unitrec *  exlist;
        struct qq_decls$unitrec *  exlistx;
    qq_lex$lex();
    ptry = qq_parse$readsunit((i64)0);
    pexceptlist = (pexceptlistx = 0);
    L603 :;
    while (((i64)qq_decls$lx.symbol == (i64)153)) {
        qq_lex$lex();
        exlist = (exlistx = 0);
        L606 :;
        while (1) {
            qq_lib$addlistunit(&exlist,&exlistx,qq_parse$readexpression());
            if (((i64)qq_decls$lx.symbol != (i64)5)) {
                goto L607 ;
            }
;
            qq_lex$lex();
        }
L607 :;
        ;
        qq_parse$checksymbol((i64)94);
        qq_lex$lex();
        px = qq_parse$readsunit((i64)0);
        qq_lib$addlistunit(&pexceptlist,&pexceptlistx,qq_lib$createunit2((i64)30,exlist,px));
L604 :;
    }
L605 :;
    ;
    qq_parse$checkend((i64)100,(i64)152,(i64)0,(i64)0);
    qq_lex$lex();
    return qq_lib$createunit2((i64)29,ptry,pexceptlist);
}

static struct qq_decls$unitrec *qq_parse$readsprint(void) {
        i64 opc;
        i64 isfprint;
        struct qq_decls$unitrec *  pformat;
        struct qq_decls$unitrec *  pdev;
        struct qq_decls$unitrec *  printlist;
        struct qq_decls$unitrec *  printlistx;
        struct qq_decls$unitrec *  p;
    qq_parse$pushlisttype((i64)362090680912);
    opc = (i64)qq_decls$lx.subcode;
    qq_parse$lexchecksymbol((i64)13);
    qq_lex$lex();
    if ((opc==(i64)75)) {
        isfprint = (i64)1;
    }
    else {
        isfprint = (i64)0;
    }
;
    printlist = (printlistx = 0);
    pformat = (pdev = 0);
    if (((i64)qq_decls$lx.symbol == (i64)22)) {
        qq_lex$lex();
        pdev = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)5)) {
            qq_lex$lex();
        }
        else {
            goto L608 ;
;
        }
;
    }
;
    if (!!(isfprint)) {
        pformat = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)5)) {
            qq_lex$lex();
        }
        else {
            goto L608 ;
;
        }
;
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)14)) {
        goto L608 ;
;
    }
;
    L609 :;
    while (1) {
        if (((i64)qq_decls$lx.symbol == (i64)5)) {
            qq_lib$addlistunit(&printlist,&printlistx,qq_lib$createunit0((i64)76));
        }
        else {
            p = qq_parse$readexpression();
            if (((i64)qq_decls$lx.symbol == (i64)7)) {
                qq_lex$lex();
                p = qq_lib$createunit2((i64)78,p,qq_parse$readexpression());
            }
;
            qq_lib$addlistunit(&printlist,&printlistx,p);
        }
;
        if (((i64)qq_decls$lx.symbol != (i64)5)) {
            goto L610 ;
        }
;
        qq_lex$lex();
    }
L610 :;
    ;
    qq_parse$checksymbol((i64)14);
    //finish:
L608 :;
;
    qq_lex$lex();
    if ((((opc == (i64)70) || (opc == (i64)72)) && (printlist == 0))) {
        qq_lib$serror((byte*)"No print items");
    }
;
    qq_parse$poplisttype();
    if (!!(isfprint)) {
        if ((pformat == 0)) {
            qq_lib$serror((byte*)"No fmt str");
        }
;
        (*pformat).nextunit = printlist;
        return qq_lib$createunit2(opc,pdev,pformat);
    }
    else {
        return qq_lib$createunit2(opc,pdev,printlist);
    }
;
}

static struct qq_decls$unitrec *qq_parse$readsread(void) {
        i64 opc;
        struct qq_decls$unitrec *  pformat;
        struct qq_decls$unitrec *  pdev;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  readlist;
        struct qq_decls$unitrec *  readlistx;
    qq_parse$pushlisttype((i64)362090680912);
    opc = (i64)qq_decls$lx.subcode;
    qq_parse$lexchecksymbol((i64)13);
    qq_lex$lex();
    readlist = (readlistx = 0);
    pformat = (pdev = 0);
    if (((i64)qq_decls$lx.symbol == (i64)22)) {
        if ((opc == (i64)79)) {
            qq_lib$serror((byte*)"@ on read");
        }
;
        qq_lex$lex();
        pdev = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)5)) {
            qq_lex$lex();
        }
        else {
            goto L611 ;
;
        }
;
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)14)) {
        goto L611 ;
;
    }
;
    L612 :;
    while (1) {
        p = qq_parse$readexpression();
        if (((i64)qq_decls$lx.symbol == (i64)7)) {
            qq_lex$lex();
            p = qq_lib$createunit2((i64)78,p,qq_parse$readexpression());
        }
;
        qq_lib$addlistunit(&readlist,&readlistx,p);
        if (((i64)qq_decls$lx.symbol != (i64)5)) {
            goto L613 ;
        }
;
        qq_lex$lex();
    }
L613 :;
    ;
    qq_parse$checksymbol((i64)14);
    //finish:
L611 :;
;
    qq_lex$lex();
    if (((opc == (i64)79) && (readlist == 0))) {
        qq_lib$serror((byte*)"No read items");
    }
;
    qq_parse$poplisttype();
    return qq_lib$createunit2(opc,pdev,readlist);
}

static void qq_parse$readimportdll(void) {
        u8 str[256];
        struct qq_decls$strec *  stproc;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  stname;
        i64 closesym;
        i64 startpos;
        i64 isfunc;
        i64 isnew;
        i64 libtype;
    libtype = (i64)qq_decls$lx.subcode;
    qq_parse$lexchecksymbol((i64)89);
    stname = (struct qq_decls$strec *)qq_decls$lx.symptr;
    qq_parse$lexchecksymbol((i64)55);
    qq_lex$lex();
    isnew = (i64)1;
    d = (*stname).nextdupl;
    L614 :;
    while (!!(d)) {
        if (((i64)(*d).nameid == (i64)4)) {
            stname = d;
            isnew = (i64)0;
            goto L616 ;
        }
;
        d = (*d).nextdupl;
L615 :;
    }
L616 :;
    ;
    if (!!(isnew)) {
        stname = qq_names$addsymbol(qq_decls$stprogram,stname,(i64)4,(i64)0);
        if ((qq_decls$nlibfiles >= (i64)50)) {
            qq_lib$serror((byte*)"Too many DLL libs");
        }
;
        qq_decls$libtable[(++(qq_decls$nlibfiles))-1] = stname;
        qq_decls$libtypes[(qq_decls$nlibfiles)-1] = libtype;
        (*stname).index = qq_decls$nlibfiles;
    }
;
    qq_parse$currdllindex = (*stname).index;
    closesym = qq_parse$checkbegin((i64)1);
    startpos = (i64)qq_decls$lx.pos;
    L617 :;
    while (1) {
        qq_parse$skipsemi();
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)148)) {
            qq_lex$lex();
        }
        else if (($temp==(i64)127) || ($temp==(i64)128)) {
            isfunc = (i64)((i64)qq_decls$lx.symbol == (i64)128);
            qq_lex$lex();
                        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)89)) {
                stproc = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)6,(i64)1);
            }
            else if (($temp==(i64)84)) {
                strcpy(str,qq_decls$lx.svalue);
                mlib$convlcstring(str);
                stproc = qq_names$addsymbol(qq_decls$stcurrproc,qq_names$addglobalname(str),(i64)6,(i64)1);
                (*stproc).truename = mlib$pcm_copyheapstring(qq_decls$lx.svalue);
            }
            else {
                qq_lib$serror((byte*)"fn name expected");
            }
            };
            (*stproc).flags = msysc$m_setdotindex((*stproc).flags,(i64)4,(u64)isfunc);
            (*stproc).flags = msysc$m_setdotindex((*stproc).flags,(i64)2,(u64)1u);
            if ((qq_decls$ndllprocs >= (i64)2000)) {
                qq_lib$serror((byte*)"Too many DLL procs");
            }
;
            qq_decls$dllproctable[(++(qq_decls$ndllprocs))-1] = stproc;
            qq_decls$dllproclibindex[(qq_decls$ndllprocs)-1] = qq_parse$currdllindex;
            (*stproc).index = qq_decls$ndllprocs;
            qq_lex$lex();
            if ((((i64)qq_decls$lx.symbol == (i64)89) && !!(mlib$eqstring((*qq_decls$lx.symptr).name,(byte*)"as")))) {
                qq_parse$lexchecksymbol((i64)89);
                d = qq_names$addsymbol((*stproc).owner,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)18,(i64)1);
                (*d).alias = stproc;
                qq_lex$lex();
            }
;
            qq_parse$readffiparams(stproc);
        }
        else if (($temp==(i64)136)) {
            qq_parse$readtypedef((i64)1);
        }
        else {
            goto L618 ;
        }
        };
    }
L618 :;
    ;
    qq_parse$checkbeginend(closesym,(i64)135,startpos);
}

static void qq_parse$readffiparams(struct qq_decls$strec *stproc) {
        i64 pret;
        i64 ptype;
    if (((i64)qq_decls$lx.symbol == (i64)13)) {
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)14)) {
            qq_lex$lex();
        }
        else {
            ptype = qq_parse$readtypespec((i64)0,0);
            if (((i64)qq_decls$lx.symbol == (i64)5 || (i64)qq_decls$lx.symbol == (i64)14)) {
                qq_parse$readtypeparams(stproc,ptype);
            }
            else {
                qq_parse$readtypenameparams(stproc,ptype);
            }
;
        }
;
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)7 || (i64)qq_decls$lx.symbol == (i64)11)) {
        if (!(!!(msysc$m_getdotindex((i64)(*stproc).flags,(i64)4)))) {
            qq_lib$serror((byte*)"Return type for proc?");
        }
;
        qq_lex$lex();
    }
;
    pret = (i64)0;
    if (!!(msysc$m_getdotindex((i64)(*stproc).flags,(i64)4))) {
        if (((i64)qq_decls$lx.symbol == (i64)6)) {
            qq_lib$serror((byte*)"Return type missing");
        }
;
        pret = qq_parse$readtypespec((i64)0,0);
    }
;
    qq_lib$storemode((*stproc).owner,pret,&(*stproc).mode);
}

static void qq_parse$readtypeparams(struct qq_decls$strec *stproc,i64 ptype) {
        u8 str[32];
        i64 nparams;
        struct qq_decls$strec *  stname;
    nparams = (i64)0;
    L619 :;
    while (1) {
        ++(nparams);
        msysc$m_print_startstr(str);
        msysc$m_print_str((byte*)"$",NULL);
        msysc$m_print_nogap();
        msysc$m_print_i64(nparams,NULL);
        msysc$m_print_end();
        ;
        stname = qq_names$addsymbol(stproc,qq_names$addglobalname(str),(i64)14,(i64)0);
        qq_lib$storemode(stproc,ptype,&(*stname).mode);
        ++((*stproc).nparams);
        if (((i64)qq_decls$lx.symbol == (i64)5)) {
            qq_lex$lex();
            if (((i64)qq_decls$lx.symbol == (i64)30)) {
                (*stproc).flags = msysc$m_setdotindex((*stproc).flags,(i64)8,(u64)1u);
                qq_lex$lex();
                goto L620 ;
            }
;
            ptype = qq_parse$readtypespec((i64)0,0);
        }
        else {
            goto L620 ;
        }
;
    }
L620 :;
    ;
    qq_parse$checksymbol((i64)14);
    qq_lex$lex();
}

static void qq_parse$readtypenameparams(struct qq_decls$strec *stproc,i64 ptype) {
        struct qq_decls$strec *  stname;
    qq_parse$checksymbol((i64)89);
    stname = qq_names$addsymbol(stproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)14,(i64)0);
    qq_lib$storemode(stproc,ptype,&(*stname).mode);
    ++((*stproc).nparams);
    qq_lex$lex();
    L621 :;
    while (1) {
        if (((i64)qq_decls$lx.symbol == (i64)55)) {
            qq_lex$lex();
            (*stname).code = qq_parse$readexpression();
            (*stname).flags = msysc$m_setdotindex((*stname).flags,(i64)7,(u64)1u);
        }
;
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)5)) {
            qq_lex$lex();
            if (((i64)qq_decls$lx.symbol == (i64)30)) {
                (*stproc).flags = msysc$m_setdotindex((*stproc).flags,(i64)8,(u64)1u);
                qq_lex$lex();
                goto L622 ;
            }
;
            if (!!(qq_parse$istypestarter())) {
                ptype = qq_parse$readtypespec((i64)0,0);
            }
;
            qq_parse$checksymbol((i64)89);
            stname = qq_names$addsymbol(stproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)14,(i64)0);
            qq_lib$storemode(stproc,ptype,&(*stname).mode);
            ++((*stproc).nparams);
            qq_lex$lex();
        }
        else {
            goto L622 ;
        }
        };
    }
L622 :;
    ;
    qq_parse$checksymbol((i64)14);
    qq_lex$lex();
}

void qq_parse$readrecorddef(i64 isglobal,struct qq_decls$strec *d) {
        i64 kwd;
        i64 baseclass;
        i64 m;
        i64 startline;
        i64 closesym;
        i64 caligned;
        struct qq_decls$strec *  nameptr;
    baseclass = (i64)0;
    if (!!(d)) {
        kwd = (i64)136;
        goto L623 ;
;
    }
;
    kwd = (i64)qq_decls$lx.symbol;
    qq_parse$lexchecksymbol((i64)89);
    nameptr = (struct qq_decls$strec *)qq_decls$lx.symptr;
    qq_lex$lex();
    if (((i64)qq_decls$lx.symbol == (i64)13)) {
        qq_lex$lex();
        baseclass = qq_parse$readtypespec((i64)0,0);
        qq_parse$checksymbol((i64)14);
        qq_lex$lex();
    }
;
    qq_parse$checkequals();
    qq_lex$lex();
    d = qq_names$addsymbol(qq_decls$stcurrproc,nameptr,((kwd == (i64)130) ? (i64)7 : (i64)8),isglobal);
    if (!!(baseclass)) {
        if ((baseclass > (i64)0)) {
            qq_lib$serror((byte*)"baseclass?");
        }
;
        if ((qq_decls$nbaseclasses >= (i64)255)) {
            qq_lib$serror((byte*)"Too many base classes");
        }
;
        ++(qq_decls$nbaseclasses);
        qq_lib$storemode(qq_decls$stcurrproc,baseclass,&qq_decls$baseclasstable[(qq_decls$nbaseclasses)]);
        (*d).baseclassindex = qq_decls$nbaseclasses;
        qq_decls$baseclassdef[(qq_decls$nbaseclasses)] = (struct qq_decls$strec *)d;
    }
;
    //gotname:
L623 :;
;
    closesym = qq_parse$checkbegin((i64)1);
    startline = (i64)qq_decls$lx.pos;
    if ((kwd == (i64)130)) {
        m = qq_parse$readrecordbody(d);
    }
    else {
        caligned = (i64)0;
        m = qq_parse$readstructbody(d,caligned);
    }
;
    qq_parse$checkbeginend(closesym,(i64)130,startline);
}

static i64 qq_parse$readrecordbody(struct qq_decls$strec *owner) {
        struct qq_decls$strec *  oldstcurrproc;
        struct qq_decls$strec *  e;
        i64 m;
    m = qq_names$addanontype();
    oldstcurrproc = qq_decls$stcurrproc;
    qq_decls$stcurrproc = owner;
    L624 :;
    switch ((i64)qq_decls$lx.symbol) {
    case 145:;
        {
            qq_parse$readconstdef((i64)0);
        }
        break;
    case 139:;
        {
            qq_parse$readrecordfields(owner);
        }
        break;
    case 128:;
    case 127:;
        {
            qq_parse$readprocdef((i64)0);
        }
        break;
    case 130:;
        {
            qq_parse$readrecorddef((i64)0,0);
        }
        break;
    case 136:;
        {
            qq_lex$lex();
            qq_lib$serror((byte*)"CLASS TYPE");
        }
        break;
    case 100:;
    case 14:;
    case 18:;
        {
            goto L625 ;
        }
        break;
    case 76:;
        {
            qq_lib$serror((byte*)"Class eof?");
            goto L625 ;
        }
        break;
    case 6:;
        {
            qq_lex$lex();
        }
        break;
    default: {
        if ((!!(qq_parse$istypestarter()) && ((i64)qq_decls$nextlx.symbol != (i64)13))) {
            qq_parse$readrecordfields(owner);
        }
        else {
            qq_lib$serror((byte*)"Unknown record field decl");
        }
;
    }
    } //SW
goto L624 ;
L625 :;
    ;
    qq_tables$ttfields[(m)] = (*owner).deflist;
    qq_tables$ttlength[(m)] = (i64)(*owner).nfields;
    qq_tables$ttlower[(m)] = (i64)1;
    qq_tables$ttbasetype[(m)] = (i64)15;
    qq_names$createusertype(owner,m);
    e = (*owner).deflist;
    L626 :;
    while (!!(e)) {
        qq_names$addgenfield(e);
        e = (*e).nextdef;
L627 :;
    }
L628 :;
    ;
    qq_tables$ttsize[(m)] = ((i64)16 * (i64)(*owner).nfields);
    qq_decls$stcurrproc = oldstcurrproc;
    return m;
}

static void qq_parse$readrecordfields(struct qq_decls$strec *owner) {
        i64 nvars;
        i64 offset;
        i64 index;
        i64 m;
        struct qq_decls$strec *  d;
    m = qq_parse$readtypespec((i64)1,0);
    nvars = (i64)0;
    index = (i64)(*owner).nfields;
    offset = (index * (i64)16);
    L629 :;
    while (((i64)qq_decls$lx.symbol == (i64)89)) {
        ++(nvars);
        d = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)9,(i64)0);
        qq_lib$storemode(owner,m,&(*d).mode);
        (*d).atfield = 0;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)22)) {
            qq_lex$lex();
            (*d).atfield = qq_parse$readatfield();
            (*d).fieldoffset = (i64)(*(*d).atfield).fieldoffset;
            (*d).index = (*(*d).atfield).index;
        }
        else {
            (*d).fieldoffset = offset;
            offset += (i64)16;
            (*d).index = ++(index);
        }
;
        if (((i64)qq_decls$lx.symbol != (i64)5)) {
            goto L631 ;
        }
;
        qq_lex$lex();
L630 :;
    }
L631 :;
    ;
    if ((nvars == (i64)0)) {
        qq_lib$serror((byte*)"No fields");
    }
;
    (*qq_decls$stcurrproc).nfields += (i16)nvars;
}

static i64 qq_parse$readstructbody(struct qq_decls$strec *owner,i64 caligned) {
        i64 m;
        i64 ngroups;
        i64 nvars;
        i64 t;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
    m = qq_names$addanontype();
    ngroups = (i64)0;
    L632 :;
    while (1) {
        qq_parse$skipsemi();
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)131)) {
            ++(ngroups);
            qq_lex$lex();
            qq_parse$addstructflag(owner,(i64)22);
        }
        else if (($temp==(i64)132)) {
            ++(ngroups);
            qq_lex$lex();
            qq_parse$addstructflag(owner,(i64)23);
        }
        else if (($temp==(i64)100)) {
            if (!!(ngroups)) {
                --(ngroups);
                qq_lex$lex();
                qq_parse$addstructflag(owner,(i64)24);
            }
            else {
                goto L633 ;
            }
;
        }
        else if (($temp==(i64)14)) {
            goto L633 ;
        }
        else {
            t = qq_parse$readtypespec((i64)0,0);
            nvars = (i64)0;
            L634 :;
            while (((i64)qq_decls$lx.symbol == (i64)89)) {
                ++(nvars);
                d = qq_names$addsymbol(owner,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)10,(i64)0);
                qq_lib$storemode(owner,t,&(*d).mode);
                qq_lex$lex();
                if (((i64)qq_decls$lx.symbol != (i64)5)) {
                    goto L636 ;
                }
;
                qq_parse$lexchecksymbol((i64)89);
L635 :;
            }
L636 :;
            ;
            if ((nvars == (i64)0)) {
                qq_lib$serror((byte*)"struct decl?");
            }
;
        }
        };
    }
L633 :;
    ;
    qq_tables$ttfields[(m)] = (*owner).deflist;
    qq_tables$ttlength[(m)] = (i64)(*owner).nfields;
    qq_tables$ttlower[(m)] = (i64)1;
    qq_tables$ttcaligned[(m)] = caligned;
    qq_tables$ttbasetype[(m)] = (i64)16;
    qq_names$createusertype(owner,m);
    e = (*owner).deflist;
    L637 :;
    while (!!(e)) {
                {i64 $temp = (i64)(*e).nameid;
if (($temp==(i64)22) || ($temp==(i64)23) || ($temp==(i64)24)) {
        }
        else {
            qq_names$addgenfield(e);
        }
        };
        e = (*e).nextdef;
L638 :;
    }
L639 :;
    ;
    return m;
}

static void qq_parse$addstructflag(struct qq_decls$strec *owner,i64 id) {
        static i64 structseqno;
        u8 str[32];
    msysc$m_print_startstr(str);
    msysc$m_print_setfmt((byte*)"$$#");
    msysc$m_print_i64(++(structseqno),NULL);
    msysc$m_print_end();
    ;
    qq_names$addsymbol(owner,qq_names$addglobalname(str),id,(i64)0);
}

static void qq_parse$readprocdef(i64 isglobal) {
        i64 kwd;
        i64 startline;
        i64 closesym;
        i64 shortfun;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  oldstcurrproc;
    kwd = (i64)qq_decls$lx.symbol;
    shortfun = (i64)qq_decls$lx.subcode;
    qq_parse$lexchecksymbol((i64)89);
    if (((i64)(*qq_decls$stcurrproc).nameid == (i64)5)) {
        qq_lib$serror((byte*)"Nested proc");
    }
;
    oldstcurrproc = qq_decls$stcurrproc;
    qq_decls$stcurrproc = (d = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)5,isglobal));
    qq_names$addproc(d);
    qq_lex$lex();
    if (((i64)qq_decls$lx.symbol == (i64)57)) {
        qq_parse$lexchecksymbol((i64)84);
        qq_lex$lex();
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)60)) {
            qq_lex$lex();
        }
        else if (($temp==(i64)59)) {
            qq_decls$lx.symbol = (i64)55;
        }
        else {
            qq_lib$serror((byte*)"\">\" expected");
        }
        };
    }
;
    qq_parse$readprocsig(d,(i64)(kwd == (i64)128));
    qq_parse$checkequals();
    qq_lex$lex();
    startline = (i64)qq_decls$lx.pos;
    if (!(!!(shortfun))) {
        closesym = qq_parse$checkbegin((i64)0);
        (*d).code = qq_parse$readsunit((i64)0);
        qq_parse$checkbeginend(closesym,kwd,startline);
    }
    else {
        (*d).code = qq_parse$readexpression();
        qq_parse$checksymbol((i64)6);
    }
;
    if (!!(mlib$eqstring((*d).name,(byte*)"start"))) {
        (*qq_decls$currmodule).startfn = d;
    }
    else if (!!(mlib$eqstring((*d).name,(byte*)"main"))) {
        (*qq_decls$currmodule).mainfn = d;
    }
;
    (*qq_decls$stcurrproc).flags = msysc$m_setdotindex((*qq_decls$stcurrproc).flags,(i64)4,(u64)(kwd == (i64)128));
    if (!!(qq_parse$ndocstrings)) {
        if (!!(qq_decls$fwritedocs)) {
            qq_names$writedocs(qq_decls$stcurrproc,&qq_parse$docstrings,qq_parse$ndocstrings);
        }
;
        qq_parse$ndocstrings = (i64)0;
    }
;
    qq_decls$stcurrproc = oldstcurrproc;
}

static struct qq_decls$strec *qq_parse$readatfield(void) {
        struct qq_decls$strec *  p;
        struct qq_decls$strec *  d;
    qq_parse$checksymbol((i64)89);
    d = (struct qq_decls$strec *)qq_decls$lx.symptr;
    qq_lex$lex();
    p = (*qq_decls$stcurrproc).deflist;
    L640 :;
    while (!!(p)) {
        if (!!(mlib$eqstring((*p).name,(*d).name))) {
            return p;
        }
;
        p = (*p).nextdef;
L641 :;
    }
L642 :;
    ;
    qq_lib$serror_s((byte*)"Can't find @ field",(*d).name);
    return (struct qq_decls$strec *)0;
}

static i64 qq_parse$istypestarter(void) {
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)90) || ($temp==(i64)138) || ($temp==(i64)139) || ($temp==(i64)141) || ($temp==(i64)15)) {
        return (i64)1;
    }
    else {
        if (((i64)qq_decls$lx.symbol == (i64)89)) {
            if (((i64)qq_decls$nextlx.symbol == (i64)89)) {
                return (i64)1;
            }
;
        }
;
    }
    };
    return (i64)0;
}

static void qq_parse$readmacrodef(i64 isglobal) {
        struct qq_decls$strec *  stmacro;
        struct qq_decls$strec *  stname;
        struct qq_decls$strec *  owner;
    qq_parse$lexchecksymbol((i64)89);
    stmacro = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)20,isglobal);
    owner = stmacro;
    qq_lex$lex();
    if (((i64)qq_decls$lx.symbol == (i64)13)) {
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol != (i64)14)) {
            L643 :;
            while (1) {
                                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)89)) {
                    stname = qq_names$addsymbol(owner,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)21,(i64)0);
                    (*stname).firstdupl = (struct qq_decls$strec *)qq_decls$lx.symptr;
                    qq_lex$lex();
                    if (((i64)qq_decls$lx.symbol == (i64)14)) {
                        goto L644 ;
                    }
;
                    qq_parse$checksymbol((i64)5);
                    qq_lex$lex();
                }
                else {
                    qq_lib$serror((byte*)"macro def params");
                }
                };
            }
L644 :;
            ;
        }
;
        qq_lex$lex();
    }
;
    qq_parse$checkequals();
    qq_lex$lex();
    (*stmacro).code = qq_parse$readexpression();
}

static struct qq_decls$unitrec *qq_parse$readhostparams(struct qq_decls$unitrec *lhs,i64 isfn) {
        i64 fnindex;
        i64 nargs;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
    fnindex = (i64)qq_decls$lx.subcode;
    qq_parse$lexchecksymbol((i64)13);
    qq_lex$lex();
    q = qq_parse$readslist(&nargs,(i64)0);
    qq_parse$checksymbol((i64)14);
    qq_lex$lex();
    if (!!(lhs)) {
        (*lhs).nextunit = q;
        q = lhs;
    }
;
    p = qq_lib$createunit1((i64)33,q);
    (*p).index = fnindex;
    return p;
}

static void qq_parse$pushlisttype(i64 ltype) {
    if ((qq_parse$nlisttype >= (i64)20)) {
        qq_lib$serror((byte*)"listtype overflow");
    }
;
    qq_parse$listtypestack[(++(qq_parse$nlisttype))-1] = qq_parse$listtype;
    qq_parse$listtype = ltype;
}

static void qq_parse$poplisttype(void) {
    qq_parse$listtype = qq_parse$listtypestack[((qq_parse$nlisttype)--)-1];
}

static struct qq_decls$unitrec *qq_parse$readcompilervar(void) {
        u8 str[100];
        struct mwindows$rsystemtime tm;
        static u8 *  monthnames[12] = {
    (byte*)"Jan",
    (byte*)"Feb",
    (byte*)"Mar",
    (byte*)"Apr",
    (byte*)"May",
    (byte*)"Jun",
    (byte*)"Jul",
    (byte*)"Aug",
    (byte*)"Sep",
    (byte*)"Oct",
    (byte*)"Nov",
    (byte*)"Dec"
};
        {i64 $temp = (i64)qq_decls$lx.subcode;
if (($temp==(i64)200)) {
        return qq_lib$createintunit(qq_lib$getlineno(qq_decls$sourcefiletext[((i64)(*qq_decls$currmodule).fileno)-1],(i64)msysc$m_getdotslice((i64)qq_decls$lx.pos,(i64)0,(i64)23)));
    }
    else if (($temp==(i64)201)) {
        msysc$getstrint(qq_lib$getlineno(qq_decls$sourcefiletext[((i64)(*qq_decls$currmodule).fileno)-1],(i64)msysc$m_getdotslice((i64)qq_decls$lx.pos,(i64)0,(i64)23)),str);
    }
    else if (($temp==(i64)205)) {
        mwindows$os_getsystime((struct mwindows$rsystemtime *)&tm);
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#-#-#");
        msysc$m_print_i64((i64)tm.day,NULL);
        msysc$m_print_str(monthnames[((i64)tm.month)-1],NULL);
        msysc$m_print_i64((i64)tm.year,(byte*)"4");
        msysc$m_print_end();
        ;
    }
    else if (($temp==(i64)206)) {
        mwindows$os_getsystime((struct mwindows$rsystemtime *)&tm);
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#:#:#");
        msysc$m_print_i64((i64)tm.hour,(byte*)"2");
        msysc$m_print_i64((i64)tm.minute,(byte*)"z2");
        msysc$m_print_i64((i64)tm.second,(byte*)"z2");
        msysc$m_print_end();
        ;
    }
    else {
        qq_lib$serror((byte*)"compiler var not impl");
    }
    };
    return qq_lib$createstringunit(mlib$pcm_copyheapstring((u8 *)str),(i64)-1);
}

static struct qq_decls$unitrec *qq_parse$readmap(void) {
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  a;
    qq_parse$lexchecksymbol((i64)13);
    qq_lex$lex();
    p = (struct qq_decls$unitrec *)qq_parse$readexpression();
    qq_parse$checksymbol((i64)5);
    qq_lex$lex();
    a = (struct qq_decls$unitrec *)qq_parse$readexpression();
    if (((i64)qq_decls$lx.symbol == (i64)5)) {
        qq_lex$lex();
        (*a).nextunit = qq_parse$readexpression();
    }
;
    qq_parse$checksymbol((i64)14);
    qq_lex$lex();
    return qq_lib$createunit2((i64)45,(struct qq_decls$unitrec *)p,(struct qq_decls$unitrec *)a);
}

void qq_parse$lexchecksymbol(i64 symbol) {
    qq_lex$lex();
    qq_parse$checksymbol(symbol);
}

static void qq_parse$readtypedef(i64 isglobal) {
        i64 ptype;
        struct qq_decls$strec *  d;
    qq_parse$lexchecksymbol((i64)89);
    d = qq_names$addsymbol(qq_decls$stcurrproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)8,isglobal);
    qq_parse$lexchecksymbol((i64)55);
    qq_lex$lex();
    if (((i64)qq_decls$lx.symbol == (i64)130)) {
        qq_lex$lex();
        (*d).nameid = (i64)7;
        qq_parse$readrecorddef(isglobal,d);
        return;
    }
;
    ptype = qq_parse$readtypespec((i64)0,d);
    qq_names$createusertype(d,ptype);
}

static i64 qq_parse$readtypespec(i64 allowvar,struct qq_decls$strec *owner) {
        i64 t;
        i64 startline;
        i64 closesym;
        i64 caligned;
        struct qq_decls$strec *  d;
        struct qq_decls$unitrec *  lowerdims[10];
        struct qq_decls$unitrec *  lengthdims[10];
        i64 ndims;
        struct qq_decls$unitrec *  x;
        struct qq_decls$unitrec *  lowerx;
        struct qq_decls$unitrec *  upperx;
        struct qq_decls$unitrec *  lengthx;
        i64 i;
        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)15)) {
        //dolsq:
L645 :;
;
        qq_lex$lex();
        ndims = (i64)0;
        qq_parse$pushlisttype((i64)0);
        L646 :;
        while (1) {
            lowerx = (lengthx = 0);
            if ((((i64)qq_decls$lx.symbol == (i64)16) || ((i64)qq_decls$lx.symbol == (i64)5))) {
            }
            else {
                x = qq_parse$readexpression();
                if (((i64)(*x).tag == (i64)195)) {
                    lowerx = (*x).a;
                    upperx = (*x).b;
                    if ((((i64)(*lowerx).tag == (i64)50) && ((i64)(*upperx).tag == (i64)50))) {
                        lengthx = qq_lib$createintunit((((*upperx).value - (*lowerx).value) + (i64)1));
                    }
                    else {
                        lengthx = qq_lib$createunit2((i64)150,upperx,lowerx);
                        lengthx = qq_lib$createunit2((i64)149,lengthx,qq_lib$createintunit((i64)1));
                    }
;
                }
                else {
                                        {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)16) || ($temp==(i64)5)) {
                        lengthx = x;
                    }
                    else if (($temp==(i64)7)) {
                        lowerx = x;
                        qq_lex$lex();
                        if (!((((i64)qq_decls$lx.symbol == (i64)5) || ((i64)qq_decls$lx.symbol == (i64)16)))) {
                            lengthx = qq_parse$readexpression();
                        }
;
                    }
                    };
                }
;
            }
;
            lowerdims[(++(ndims))-1] = lowerx;
            lengthdims[(ndims)-1] = lengthx;
            if (((i64)qq_decls$lx.symbol != (i64)5)) {
                goto L647 ;
            }
;
            qq_lex$lex();
        }
L647 :;
        ;
        qq_parse$checksymbol((i64)16);
        qq_lex$lex();
        qq_parse$poplisttype();
        t = qq_parse$readtypespec((i64)0,0);
        for (i=ndims;i>=(i64)1;--i) {
L648 :;
            t = qq_names$makeaxtype(t,lowerdims[(i)-1],lengthdims[(i)-1]);
L649 :;
        }
L650 :;
        ;
        return t;
    }
    else if (($temp==(i64)138)) {
        qq_lex$lex();
        if ((((i64)qq_decls$lx.symbol == (i64)90) && ((i64)qq_decls$lx.subcode == (i64)0))) {
            qq_lex$lex();
            return qq_names$makereftype((i64)0,owner);
        }
        else {
            return qq_names$makereftype(qq_parse$readtypespec((i64)0,0),owner);
        }
;
    }
    else if (($temp==(i64)89)) {
        d = (struct qq_decls$strec *)qq_decls$lx.symptr;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)2)) {
            qq_parse$lexchecksymbol((i64)89);
            t = qq_names$newusertypex((struct qq_decls$strec *)d,(struct qq_decls$strec *)qq_decls$lx.symptr);
            qq_lex$lex();
            return t;
        }
        else {
            return qq_names$newusertypex((struct qq_decls$strec *)d,0);
        }
;
    }
    else if (($temp==(i64)90)) {
                {i64 $temp = (i64)qq_decls$lx.subcode;
if (($temp==(i64)39)) {
            qq_lex$lex();
            if (((i64)qq_decls$lx.symbol == (i64)34)) {
                qq_lex$lex();
                return qq_names$makestrtype((i64)39,qq_parse$readexpression());
            }
            else {
                return (i64)40;
            }
;
        }
        else if (($temp==(i64)38)) {
            qq_parse$lexchecksymbol((i64)34);
            qq_lex$lex();
            return qq_names$makestrtype((i64)38,qq_parse$readexpression());
        }
        else if (($temp==(i64)14)) {
            qq_parse$lexchecksymbol((i64)15);
            goto L645 ;
;
        }
        else {
            t = (i64)qq_decls$lx.subcode;
            qq_lex$lex();
            return t;
        }
        };
    }
    else if (($temp==(i64)130)) {
        if ((owner == 0)) {
            qq_lib$serror((byte*)"anon record");
        }
;
        qq_lex$lex();
        closesym = qq_parse$checkbegin((i64)1);
        startline = (i64)qq_decls$lx.pos;
        t = qq_parse$readrecordbody(owner);
        qq_parse$checkbeginend(closesym,(i64)130,startline);
        return t;
    }
    else if (($temp==(i64)131)) {
        if ((owner == 0)) {
            qq_lib$serror((byte*)"anon struct");
        }
;
        qq_lex$lex();
        caligned = (i64)0;
        if (((i64)qq_decls$lx.symbol == (i64)151)) {
            caligned = (i64)1;
            qq_lex$lex();
        }
;
        closesym = qq_parse$checkbegin((i64)1);
        startline = (i64)qq_decls$lx.pos;
        t = qq_parse$readstructbody(owner,caligned);
        qq_parse$checkbeginend(closesym,(i64)131,startline);
        return t;
    }
    else if (($temp==(i64)139)) {
        if (!(!!(allowvar))) {
            qq_lib$serror((byte*)"var types not allowed");
        }
;
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)7)) {
            qq_lex$lex();
            return qq_parse$readtypespec((i64)0,0);
        }
;
        return (i64)27;
    }
    else if (($temp==(i64)141)) {
        qq_parse$lexchecksymbol((i64)15);
        qq_parse$lexchecksymbol((i64)16);
        qq_lex$lex();
        t = qq_names$makeslicetype(qq_parse$readtypespec((i64)0,0));
    }
    else {
        qq_lib$serror((byte*)"Type expected");
    }
    };
    return t;
}

static void qq_parse$readreturntype(struct qq_decls$strec *stproc) {
    (*stproc).mode = qq_parse$readtypespec((i64)((i64)(*stproc).nameid == (i64)5),0);
}

static void qq_parse$readprocsig(struct qq_decls$strec *stproc,i64 isfunc) {
    (*stproc).mode = (i64)0;
    if (((i64)qq_decls$lx.symbol == (i64)13)) {
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol != (i64)14)) {
            qq_parse$readparams(stproc,(i64)0);
        }
        else {
            qq_lex$lex();
        }
;
        if ((((i64)qq_decls$lx.symbol == (i64)7) || ((i64)qq_decls$lx.symbol == (i64)11))) {
            qq_lex$lex();
            qq_parse$readreturntype(stproc);
        }
        else if (!!(qq_parse$istypestarter())) {
            qq_parse$readreturntype(stproc);
        }
;
    }
    else if ((((i64)qq_decls$lx.symbol == (i64)7) || ((i64)qq_decls$lx.symbol == (i64)11))) {
        qq_lex$lex();
        qq_parse$readreturntype(stproc);
    }
;
    if ((!!(isfunc) && ((i64)(*stproc).mode == (i64)0))) {
        if (((i64)(*stproc).nameid == (i64)5)) {
            (*stproc).mode = (i64)27;
        }
        else {
            qq_lib$serror((byte*)"MFunc needs return type");
        }
;
    }
    else if ((!(!!(isfunc)) && ((i64)(*stproc).mode != (i64)0))) {
        qq_lib$serror((byte*)"Ret type given to sub/proc");
    }
;
}

static void qq_parse$readparams(struct qq_decls$strec *stproc,i64 pmode) {
        i64 isbyref;
        i64 isoptional;
        struct qq_decls$strec *  d;
    isbyref = (i64)0;
    isoptional = (i64)0;
    if ((pmode != (i64)0)) {
        goto L651 ;
;
    }
;
    if (!(!!(qq_parse$istypestarter()))) {
        qq_parse$readparams_names(stproc);
        return;
    }
;
    if (((i64)qq_decls$lx.symbol == (i64)14)) {
        qq_lex$lex();
        return;
    }
;
    L652 :;
    while (1) {
        isbyref = (isoptional = (i64)0);
        if (!!(qq_parse$istypestarter())) {
            pmode = qq_parse$readtypespec((i64)((i64)(*stproc).nameid != (i64)6),0);
        }
        else if ((pmode == (i64)0)) {
            qq_lib$serror((byte*)"Type expected");
        }
;
        //gotmode:
L651 :;
;
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)25)) {
            isbyref = (i64)1;
            qq_lex$lex();
        }
        else if (($temp==(i64)24)) {
            isoptional = (i64)1;
            qq_lex$lex();
        }
        else if (($temp==(i64)30)) {
            (*stproc).flags = msysc$m_setdotindex((*stproc).flags,(i64)8,(u64)1u);
            qq_parse$lexchecksymbol((i64)14);
            qq_lex$lex();
            return;
        }
        };
        qq_parse$checksymbol((i64)89);
        ++((*stproc).nparams);
        d = qq_names$addsymbol(stproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)13,(i64)0);
        qq_lib$storemode(stproc,pmode,&(*d).mode);
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)55)) {
            isoptional = (i64)1;
            qq_lex$lex();
            (*d).code = qq_parse$readexpression();
        }
;
        if ((!!(isbyref) && !!(isoptional))) {
            qq_lib$serror((byte*)"Mixed byref/optional");
        }
;
        (*d).flags = msysc$m_setdotindex((*d).flags,(i64)5,(u64)isbyref);
        (*d).flags = msysc$m_setdotindex((*d).flags,(i64)7,(u64)isoptional);
                {i64 $temp = (i64)qq_decls$lx.symbol;
if (($temp==(i64)5)) {
            qq_lex$lex();
        }
        else {
            goto L653 ;
        }
        };
    }
L653 :;
    ;
    qq_parse$checksymbol((i64)14);
    qq_lex$lex();
}

static void qq_parse$readparams_names(struct qq_decls$strec *stproc) {
        i64 isbyref;
        i64 isoptional;
        struct qq_decls$strec *  d;
    isbyref = (isoptional = (i64)0);
    L654 :;
    while (1) {
        if (((i64)qq_decls$lx.symbol == (i64)25)) {
            ++(isbyref);
            qq_lex$lex();
        }
;
        if (((i64)qq_decls$lx.symbol == (i64)24)) {
            ++(isoptional);
            qq_lex$lex();
        }
;
        qq_parse$checksymbol((i64)89);
        d = qq_names$addsymbol(stproc,(struct qq_decls$strec *)qq_decls$lx.symptr,(i64)13,(i64)0);
        (*d).mode = (i64)27;
        ++((*stproc).nparams);
        qq_lex$lex();
        if (((i64)qq_decls$lx.symbol == (i64)55)) {
            isoptional = (i64)1;
            qq_lex$lex();
            (*d).code = qq_parse$readexpression();
        }
;
        if ((!!(isbyref) && !!(isoptional))) {
            qq_lib$serror((byte*)"Mixed byref/optional");
        }
;
        (*d).flags = msysc$m_setdotindex((*d).flags,(i64)5,(u64)isbyref);
        (*d).flags = msysc$m_setdotindex((*d).flags,(i64)7,(u64)isoptional);
        isbyref = (isoptional = (i64)0);
        if (((i64)qq_decls$lx.symbol == (i64)5)) {
            qq_lex$lex();
            if (((i64)qq_decls$lx.symbol == (i64)30)) {
                (*stproc).flags = msysc$m_setdotindex((*stproc).flags,(i64)8,(u64)1u);
                qq_lex$lex();
                goto L655 ;
            }
;
        }
        else {
            goto L655 ;
        }
;
    }
L655 :;
    ;
    qq_parse$checksymbol((i64)14);
    qq_lex$lex();
}

static struct qq_decls$unitrec *qq_parse$checkoperator(void) {
        struct qq_decls$unitrec *  p;
        i64 opc;
    if (((i64)qq_decls$nextlx.symbol == (i64)5 || (i64)qq_decls$nextlx.symbol == (i64)14 || (i64)qq_decls$nextlx.symbol == (i64)6)) {
        p = qq_lib$createunit0((i64)7);
        if (((i64)qq_decls$lx.symbol == (i64)175)) {
                        {i64 $temp = (i64)qq_decls$lx.subcode;
if (($temp==(i64)45)) {
                opc = (i64)101;
            }
            else if (($temp==(i64)23899)) {
                opc = (i64)210;
            }
            else {
                opc = (i64)0;
            }
            };
            (*p).pclopcode = opc;
        }
        else {
            (*p).pclopcode = (i64)qq_tables$jpclcodes[((i64)qq_decls$lx.subcode)];
        }
;
        qq_lex$lex();
        return p;
    }
;
    return (struct qq_decls$unitrec *)0;
}

static struct qq_decls$unitrec *qq_parse$readlist(void) {
        struct qq_decls$unitrec *  ulist;
        struct qq_decls$unitrec *  ulistx;
        struct qq_decls$unitrec *  p;
        i64 length;
    qq_lex$lex();
    qq_parse$skipsemi();
    ulist = (ulistx = 0);
    length = (i64)0;
    L656 :;
    while (((i64)qq_decls$lx.symbol != (i64)100)) {
        qq_lib$addlistunit(&ulist,&ulistx,qq_parse$readexpression());
        ++(length);
        qq_parse$skipsemi();
L657 :;
    }
L658 :;
    ;
    qq_lex$lex();
    p = qq_lib$createunit1((i64)197,ulist);
    (*p).length = length;
    (*p).lower = (i64)1;
    return p;
}

// START
void qq_parse$start(void) {

}

void qq_print$pch_print(struct qq_decls$varrec *p,struct qq_decls$varrec *fmt) {
        struct qq_decls$varrec v;
        struct qq_decls$varrec emptyfmt;
    if ((fmt == 0)) {
        fmt = &emptyfmt;
        emptyfmt.tagx = (i64)0;
    }
;
    if ((qq_print$mfmtstr == 0)) {
        if (!!((i64)qq_print$mgapneeded)) {
            qq_print$printstr_n((byte*)" ",(i64)1);
        }
        else {
            qq_print$mgapneeded = (i64)1;
        }
;
    }
    else {
        qq_print$printnextfmtchars((i64)0);
    }
;
    qq_print$listdepth = (i64)0;
    qq_print$pch_tostr(p,fmt,&v);
    qq_print$printstr_n((*v.objptr).strptr,(*v.objptr).length);
    if (!!((i64)v.hasref)) {
        qq_vars$var_unshareu(&v);
    }
;
}

void qq_print$pch_print_nf(struct qq_decls$varrec *p) {
    qq_print$pch_print(p,0);
}

void qq_print$pch_printnogap(void) {
    qq_print$mgapneeded = (i64)0;
}

void qq_print$pch_println(void) {
    if (!!(qq_print$mfmtstr)) {
        qq_print$printnextfmtchars((i64)1);
    }
;
    qq_print$mgapneeded = (i64)0;
    qq_print$printstr_n((byte*)"\n",(i64)-1);
}

void qq_print$pch_reread(void) {
    qq_print$kb_pos = qq_print$kb_lastpos;
    qq_print$kb_length = qq_print$kb_lastlength;
}

void qq_print$pch_rereadln(void) {
    qq_print$kb_pos = qq_print$kb_start;
    qq_print$kb_length = qq_print$kb_linelength;
}

static void qq_print$pch_startprint(struct qq_decls$varrec *p) {
        struct qq_decls$objrec *  s;
    switch (++(qq_print$noclevels)) {
    case 0:;
    case 1:;
        {
        }
        break;
    case 7:;
        {
            qq_lib$prterror((byte*)"print #x overflow");
        }
        break;
    default: {
        qq_print$moutdevstack[((qq_print$noclevels - (i64)1))] = qq_print$moutdev;
        qq_print$moutchanstack[((qq_print$noclevels - (i64)1))] = qq_print$moutchan;
        qq_print$moutvarstack[((qq_print$noclevels - (i64)1))] = qq_print$moutvar;
        qq_print$mfmtstrstack[((qq_print$noclevels - (i64)1))] = qq_print$mfmtstr;
        qq_print$mfmtcurrstack[((qq_print$noclevels - (i64)1))] = qq_print$mfmtcurr;
        qq_print$mgapstack[((qq_print$noclevels - (i64)1))] = (i64)qq_print$mgapneeded;
    }
    } //SW
;
    qq_print$mfmtstr = 0;
    qq_print$mfmtcurr = 0;
    if ((p == 0)) {
        goto L659 ;
;
    }
;
    switch ((i64)(*p).tag) {
    case 1:;
        {
            switch ((*p).value) {
            case 0:;
                {
                    //doconsole:
L659 :;
;
                    qq_print$moutdev = (i64)0;
                    qq_print$moutchan = 0;
                }
                break;
            case 1:;
                {
                    qq_print$moutdev = (i64)2;
                    qq_print$moutchan = 0;
                    qq_print$moutvar.tagx = (i64)268;
                    s = qq_vars$obj_new();
                    (*s).flags = msysc$m_setdotindex((*s).flags,(i64)1,(u64)1u);
                    qq_print$moutvar.objptr = s;
                }
                break;
            case 2:;
                {
                    if ((qq_print$testfilech == 0)) {
                        qq_lib$prterror((byte*)"@2: file not open");
                    }
;
                    qq_print$moutdev = (i64)1;
                    qq_print$moutchan = qq_print$testfilech;
                }
                break;
            default: {
                qq_print$moutdev = (i64)1;
                qq_print$moutchan = (void *)(*p).value;
            }
            } //SW
;
        }
        break;
    case 17:;
        {
            p = (*p).varptr;
            switch ((i64)(*p).tag) {
            case 12:;
                {
                    qq_print$moutdev = (i64)4;
                    qq_print$moutchan = 0;
                    qq_print$moutvar.tagx = (i64)17;
                    qq_print$moutvar.varptr = p;
                }
                break;
            default: {
                msysc$m_print_startcon();
                msysc$m_print_str(qq_tables$ttname[((i64)(*p).tag)],NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                qq_lib$prterror((byte*)"Print@^?");
            }
            } //SW
;
        }
        break;
    default: {
        switch ((i64)(*p).tag) {
        case 15:;
        case 16:;
            {
                qq_print$moutdev = (i64)0;
            }
            break;
        default: {
            msysc$m_print_startcon();
            msysc$m_print_str(qq_tables$ttname[((i64)(*p).tag)],NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
            qq_lib$prterror((byte*)"Can't do startprint...");
        }
        } //SW
;
    }
    } //SW
;
    qq_print$mgapneeded = (i64)0;
}

void qq_print$pch_startprintcon(void) {
        struct qq_decls$varrec v;
    v.tagx = (i64)1;
    v.value = (i64)0;
    qq_print$pch_startprint(&v);
}

void qq_print$pch_endprint(void) {
        struct qq_decls$varrec *  p;
    if (!!(qq_print$mfmtstr)) {
        qq_print$printnextfmtchars((i64)1);
    }
;
    switch (qq_print$moutdev) {
    case 4:;
        {
            p = qq_print$moutvar.varptr;
        }
        break;
    } //SW
;
    if ((qq_print$mfmtstr != 0)) {
        mlib$pcm_free((void *)qq_print$mfmtstr,(strlen(qq_print$mfmtstr) + (i64)1));
    }
;
    if ((--(qq_print$noclevels) == (i64)-1)) {
        qq_lib$prterror((byte*)"resetoc??");
    }
;
    if ((qq_print$noclevels == (i64)0)) {
        qq_print$moutdev = (i64)0;
    }
    else {
        qq_print$moutdev = (i64)qq_print$moutdevstack[(qq_print$noclevels)];
        qq_print$moutchan = qq_print$moutchanstack[(qq_print$noclevels)];
        qq_print$moutvar = qq_print$moutvarstack[(qq_print$noclevels)];
        qq_print$mgapneeded = (i64)qq_print$mgapstack[(qq_print$noclevels)];
        qq_print$mfmtstr = qq_print$mfmtstrstack[(qq_print$noclevels)];
        qq_print$mfmtcurr = qq_print$mfmtcurrstack[(qq_print$noclevels)];
    }
;
    qq_print$mgapneeded = (i64)0;
}

void qq_print$pch_strstartprint(void) {
        struct qq_decls$varrec p;
    p.tagx = (i64)1;
    p.value = (i64)1;
    qq_print$pch_startprint(&p);
}

void qq_print$pch_strendprint(struct qq_decls$varrec *dest) {
    if (!!(qq_print$mfmtstr)) {
        qq_print$printnextfmtchars((i64)1);
    }
;
    if ((qq_print$moutdev != (i64)2)) {
        qq_lib$prterror((byte*)"STRENDPRT/NOT STR");
    }
;
    (*dest) = qq_print$moutvar;
    qq_print$moutvar.tagx = (i64)0;
    qq_print$pch_endprint();
}

void qq_print$pch_printspace(void) {
    qq_print$mgapneeded = (i64)0;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)" ",NULL);
    msysc$m_print_end();
    ;
}

void qq_print$pch_readln(struct qq_decls$varrec *dev) {
        void *  ch;
        i64 length;
        struct qq_decls$objrec *  pdev;
    if ((qq_print$kb_start == 0)) {
        qq_print$kb_start = (u8 *)mlib$pcm_alloc((i64)1048576);
        qq_print$kb_size = (i64)1048576;
        qq_print$kb_lastpos = qq_print$kb_start;
        qq_print$kb_pos = qq_print$kb_start;
        qq_print$kb_length = (i64)0;
        qq_print$kb_lastlength = (i64)0;
        qq_print$kb_linelength = (i64)0;
    }
;
    switch ((i64)(*dev).tag) {
    case 0:;
        {
            //doconsole:
L660 :;
;
            mlib$readlinen(0,qq_print$kb_start,qq_print$kb_size);
            qq_print$kb_length = strlen(qq_print$kb_start);
        }
        break;
    case 1:;
        {
            switch ((*dev).value) {
            case 0:;
                {
                    goto L660 ;
;
                }
                break;
            case 1:;
                {
                    if ((qq_print$testfilech == 0)) {
                        qq_lib$prterror((byte*)"R@2: file not open");
                    }
;
                    ch = qq_print$testfilech;
                }
                break;
            default: {
                ch = (void *)(*dev).value;
            }
            } //SW
;
            qq_print$pc_readlinen(ch,qq_print$kb_start,qq_print$kb_size);
            qq_print$kb_length = strlen(qq_print$kb_start);
        }
        break;
    case 12:;
        {
            pdev = (*dev).objptr;
            length = (*pdev).length;
            if ((length == (i64)0)) {
                qq_print$kb_length = (i64)0;
                (*qq_print$kb_start) = (u64)0u;
            }
            else if ((length >= qq_print$kb_size)) {
                qq_lib$prterror((byte*)"KB overflow");
            }
            else {
                qq_print$kb_length = length;
                memcpy((void *)qq_print$kb_start,(void *)(*pdev).strptr,(u64)length);
            }
;
        }
        break;
    default: {
        qq_lib$pcustype((byte*)"readln@",dev);
    }
    } //SW
;
    qq_print$kb_pos = qq_print$kb_start;
    qq_print$kb_lastpos = qq_print$kb_pos;
    qq_print$kb_linelength = qq_print$kb_length;
}

static void qq_print$pc_readlinen(void *handlex,u8 *buffer,i64 size) {
        u8 *  p;
        i64 n;
        byte crseen;
    (*buffer) = (u64)0u;
    fgets(buffer,(size - (i64)2),handlex);
    n = strlen(buffer);
    if ((n == (i64)0)) {
        return;
    }
;
    p = ((buffer + n) - (i64)1);
    crseen = (i64)0;
    L661 :;
    while (((p >= buffer) && (((i64)(u64)(*p) == (i64)13) || ((i64)(u64)(*p) == (i64)10)))) {
        if ((((i64)(u64)(*p) == (i64)13) || ((i64)(u64)(*p) == (i64)10))) {
            crseen = (i64)1;
        }
;
        (*(p)--) = (u64)0u;
L662 :;
    }
L663 :;
    ;
    if ((!(!!((i64)crseen)) && ((n + (i64)4) > size))) {
        msysc$m_print_startcon();
        msysc$m_print_i64(size,NULL);
        msysc$m_print_i64(n,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mlib$abortprogram((byte*)"line too long");
    }
;
}

void qq_print$pch_sread(struct qq_decls$varrec *fmt,struct qq_decls$varrec *dest) {
        i64 fmtcode;
    fmtcode = qq_print$getreadfmtcode(fmt);
    qq_print$kb_lastpos = qq_print$kb_pos;
    qq_print$kb_lastlength = qq_print$kb_length;
    switch (fmtcode) {
    case 73:;
        {
            qq_print$stepkbpos(qq_print$readint(qq_print$kb_pos,qq_print$kb_length,dest,(i64)0));
        }
        break;
    case 82:;
        {
            qq_print$stepkbpos(qq_print$readreal(qq_print$kb_pos,qq_print$kb_length,dest));
        }
        break;
    case 78:;
        {
            qq_print$stepkbpos(qq_print$readname(qq_print$kb_pos,qq_print$kb_length,dest));
        }
        break;
    case 83:;
        {
            qq_print$stepkbpos(qq_print$readstring(qq_print$kb_pos,qq_print$kb_length,dest));
        }
        break;
    case 72:;
        {
            qq_print$stepkbpos(qq_print$readhex(qq_print$kb_pos,qq_print$kb_length,dest));
        }
        break;
    case 66:;
        {
            qq_print$stepkbpos(qq_print$readbin(qq_print$kb_pos,qq_print$kb_length,dest));
        }
        break;
    case 65:;
        {
            qq_print$stepkbpos(qq_print$readany(qq_print$kb_pos,qq_print$kb_length,dest));
        }
        break;
    case 76:;
        {
            if ((qq_print$kb_length == (i64)0)) {
                qq_strings$var_empty_string(dest,(i64)0);
            }
            else {
                qq_strings$var_make_stringn(qq_print$kb_pos,qq_print$kb_length,dest,(i64)1);
                qq_print$kb_pos += qq_print$kb_length;
                qq_print$kb_length = (i64)0;
            }
;
        }
        break;
    case 67:;
        {
            if ((qq_print$kb_length == (i64)0)) {
                qq_strings$var_empty_string(dest,(i64)0);
            }
            else {
                qq_print$termchar = (u64)(*qq_print$kb_pos);
                //dochar:
L664 :;
;
                (*dest).tagx = (i64)1;
                (*dest).value = (i64)(u64)qq_print$termchar;
                ++(qq_print$kb_pos);
                --(qq_print$kb_length);
            }
;
        }
        break;
    case 90:;
        {
            goto L664 ;
;
        }
        break;
    case 69:;
        {
            (*dest).tagx = (i64)1;
            (*dest).value = qq_print$itemerror;
        }
        break;
    case 68:;
        {
            qq_print$stepkbpos(qq_print$readint(qq_print$kb_pos,qq_print$kb_length,dest,(i64)1));
        }
        break;
    default: {
        qq_lib$prterror((byte*)"SREAD/FMT?");
    }
    } //SW
;
}

void qq_print$pch_sreadln(struct qq_decls$varrec *dev,struct qq_decls$varrec *dest) {
    qq_print$pch_readln(dev);
    qq_strings$var_make_stringn(qq_print$kb_start,qq_print$kb_length,dest,(i64)1);
}

static u8 *qq_print$readname(u8 *s,i64 length,struct qq_decls$varrec *dest) {
        u8 *  send;
        u8 *  itemstr;
        i64 itemlength;
    send = qq_print$readitem(s,length,&itemstr,&itemlength);
    qq_strings$var_make_stringn(itemstr,itemlength,dest,(i64)1);
    mlib$iconvlcn((*(*dest).objptr).strptr,(*(*dest).objptr).length);
    return send;
}

static u8 *qq_print$readstring(u8 *s,i64 length,struct qq_decls$varrec *dest) {
        u8 *  send;
        u8 *  itemstr;
        i64 itemlength;
    send = qq_print$readitem(s,length,&itemstr,&itemlength);
    qq_strings$var_make_stringn(itemstr,itemlength,dest,(i64)1);
    return send;
}

static u8 *qq_print$readint(u8 *sold,i64 length,struct qq_decls$varrec *dest,i64 dodec) {
        u8 *  s;
        u8 *  send;
        i64 itemlength;
    send = qq_print$readitem(sold,length,&s,&itemlength);
    qq_print$strtoint(s,itemlength,dest,dodec);
    return send;
}

static u8 *qq_print$readhex(u8 *sold,i64 length,struct qq_decls$varrec *dest) {
        u8 str[256];
        u8 *  p;
        u8 *  s;
        i64 aa;
        i64 t;
        i64 nalloc;
        u8 c;
    if ((length == (i64)0)) {
        (*dest).tagx = (i64)1;
        (*dest).value = (i64)0;
        qq_print$termchar = (u64)0u;
        return sold;
    }
;
    L665 :;
    while ((!!(length) && (((u64)(*sold) == ' ') || ((i64)(u64)(*sold) == (i64)9)))) {
        ++(sold);
        --(length);
L666 :;
    }
L667 :;
    ;
    if ((length <= (i64)256)) {
        s = (u8 *)str;
        nalloc = (i64)0;
    }
    else {
        nalloc = (length + (i64)1);
        s = (u8 *)mlib$pcm_alloc(nalloc);
    }
;
    p = s;
    L668 :;
    while (!!(length)) {
        c = (u64)toupper((i32)(u64)(*sold));
        ++(sold);
        --(length);
        if ((((u64)c >= '0') && ((u64)c <= '9'))) {
            (*p) = (u64)c;
            ++(p);
        }
        else if ((((u64)c >= 'A') && ((u64)c <= 'F'))) {
            (*p) = (u64)c;
            ++(p);
        }
        else if (((u64)c == '_')) {
        }
        else {
            qq_print$termchar = (u64)c;
            goto L670 ;
        }
;
L669 :;
    }
L670 :;
    ;
    (*p) = (u64)0u;
    length = (p - s);
    if ((length <= (i64)16)) {
        t = (i64)1;
    }
    else {
        t = (i64)4;
    }
;
    p = s;
    switch (t) {
    case 1:;
        {
            aa = (i64)0;
            L671 :;
            while (1) {
                c = (u64)(*p);
                ++(p);
                if (((i64)(u64)c == (i64)0)) {
                    goto L672 ;
                }
;
                if (((u64)c < 'A')) {
                    aa = (((aa * (i64)16) + (i64)(u64)c) - (i64)48);
                }
                else {
                    aa = (((aa * (i64)16) + (i64)((u64)c - 'A')) + (i64)10);
                }
;
            }
L672 :;
            ;
            (*dest).tagx = (i64)1;
            (*dest).value = aa;
        }
        break;
    default: {
        qq_lib$prterror((byte*)"Readhex/long");
    }
    } //SW
;
    if (!!(nalloc)) {
        mlib$pcm_free((void *)s,nalloc);
    }
;
    return sold;
}

static u8 *qq_print$readbin(u8 *sold,i64 length,struct qq_decls$varrec *dest) {
        u8 str[256];
        u8 *  p;
        u8 *  s;
        i64 aa;
        i64 t;
        i64 nalloc;
        u8 c;
    if ((length == (i64)0)) {
        (*dest).tagx = (i64)1;
        (*dest).value = (i64)0;
        qq_print$termchar = (u64)0u;
        return sold;
    }
;
    L673 :;
    while ((!!(length) && (((u64)(*sold) == ' ') || ((i64)(u64)(*sold) == (i64)9)))) {
        ++(sold);
        --(length);
L674 :;
    }
L675 :;
    ;
    if ((length <= (i64)256)) {
        s = (u8 *)str;
        nalloc = (i64)0;
    }
    else {
        nalloc = (length + (i64)1);
        s = (u8 *)mlib$pcm_alloc(nalloc);
    }
;
    p = s;
    L676 :;
    while (!!(length)) {
        c = (u64)toupper((i32)(u64)(*sold));
        ++(sold);
        --(length);
        if ((((u64)c >= '0') && ((u64)c <= '1'))) {
            (*p) = (u64)c;
            ++(p);
        }
        else if (((u64)c == '_')) {
        }
        else {
            qq_print$termchar = (u64)c;
            goto L678 ;
        }
;
L677 :;
    }
L678 :;
    ;
    (*p) = (u64)0u;
    length = (p - s);
    if ((length <= (i64)64)) {
        t = (i64)1;
    }
    else {
        t = (i64)4;
    }
;
    p = s;
    switch (t) {
    case 1:;
        {
            aa = (i64)0;
            L679 :;
            while (1) {
                c = (u64)(*p);
                ++(p);
                if (((i64)(u64)c == (i64)0)) {
                    goto L680 ;
                }
;
                aa = (((aa * (i64)2) + (i64)(u64)c) - (i64)48);
            }
L680 :;
            ;
            (*dest).tagx = (i64)1;
            (*dest).value = aa;
        }
        break;
    default: {
        qq_lib$prterror((byte*)"Readbin/long");
    }
    } //SW
;
    if (!!(nalloc)) {
        mlib$pcm_free((void *)s,nalloc);
    }
;
    return sold;
}

static u8 *qq_print$readreal(u8 *sold,i64 length,struct qq_decls$varrec *dest) {
        u8 *  send;
        u8 *  itemstr;
        i64 itemlength;
    send = qq_print$readitem(sold,length,&itemstr,&itemlength);
    qq_print$strtoreal(itemstr,itemlength,dest);
    return send;
}

i64 qq_print$getreadfmtcode(struct qq_decls$varrec *p) {
        u8 c;
    if (((p == 0) || ((i64)(*p).tag == (i64)0))) {
        return (i64)65;
    }
;
    if (((i64)(*p).tag != (i64)12)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"P=%s",NULL);
        msysc$m_print_str(qq_tables$ttname[((i64)(*p).tag)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$prterror((byte*)"Readfmt?");
    }
;
    if (((*(*p).objptr).length == (i64)0)) {
        return (i64)65;
    }
;
    c = (u64)toupper((i32)(u64)(*(*(*p).objptr).strptr));
    switch ((i64)(u64)c) {
    case 73:;
    case 82:;
    case 78:;
    case 83:;
    case 70:;
    case 84:;
    case 90:;
    case 67:;
    case 76:;
    case 72:;
    case 66:;
    case 65:;
    case 69:;
    case 68:;
        {
            return (i64)(u64)c;
        }
        break;
    } //SW
;
    qq_lib$prterror((byte*)"Readfmt2?");
    return (i64)0;
}

static void qq_print$stepkbpos(u8 *s) {
        i64 newlen;
    newlen = (s - qq_print$kb_pos);
    if ((newlen == (i64)0)) {
        return;
    }
;
    if ((newlen >= qq_print$kb_length)) {
        qq_print$kb_pos = (qq_print$kb_pos + qq_print$kb_length);
        qq_print$kb_length = (i64)0;
    }
    else {
        qq_print$kb_pos = (qq_print$kb_pos + newlen);
        qq_print$kb_length -= newlen;
    }
;
}

static u8 *qq_print$readany(u8 *sold,i64 length,struct qq_decls$varrec *dest) {
        u8 *  p;
        u8 *  s;
        i64 digits;
        i64 expon;
        i64 other;
        u8 *  send;
        i64 itemlength;
        i64 $av_1;
    qq_print$itemerror = (i64)0;
    send = qq_print$readitem(sold,length,&s,&itemlength);
    p = s;
    digits = (expon = (other = (i64)0));
    $av_1 = itemlength;
    while ($av_1-- > 0) {
L681 :;
        switch ((i64)(u64)(*(p)++)) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 43:;
        case 45:;
        case 95:;
            {
                digits = (i64)1;
            }
            break;
        case 69:;
        case 101:;
        case 46:;
            {
                expon = (i64)1;
            }
            break;
        default: {
            other = (i64)1;
        }
        } //SW
;
L682 :;
    }
L683 :;
    ;
    (*dest).tagx = (i64)1;
    if ((!!(other) || (itemlength == (i64)0))) {
        (*dest).value = (i64)5395539;
        qq_strings$var_make_stringn(s,itemlength,dest,(i64)1);
    }
    else if (!!(expon)) {
        qq_print$strtoreal(s,itemlength,dest);
    }
    else {
        qq_print$strtoint(s,itemlength,dest,(i64)0);
    }
;
    return send;
}

static u8 *qq_print$readitem(u8 *s,i64 length,u8 **itemstr,i64 *itemlength) {
        u8 *  p;
        u8 quotechar;
        u8 c;
    L684 :;
    while ((!!(length) && (((u64)(*s) == ' ') || ((i64)(u64)(*s) == (i64)9)))) {
        ++(s);
        --(length);
L685 :;
    }
L686 :;
    ;
    (*itemstr) = s;
    if ((length == (i64)0)) {
        qq_print$termchar = (u64)0u;
        (*itemlength) = (i64)0;
        return s;
    }
;
    quotechar = (u64)0u;
    if (((u64)(*s) == '"')) {
        quotechar = '"';
        ++(s);
        --(length);
    }
    else if (((u64)(*s) == (u64)39u)) {
        quotechar = (u64)39u;
        ++(s);
        --(length);
    }
;
    p = ((*itemstr) = s);
    L687 :;
    while (!!(length)) {
        c = (u64)(*(s)++);
        --(length);
        switch ((i64)(u64)c) {
        case 32:;
        case 9:;
        case 44:;
        case 61:;
            {
                if ((!!((u64)quotechar) || (p == s))) {
                    goto L690 ;
;
                }
;
                qq_print$termchar = (u64)c;
                goto L689 ;
            }
            break;
        default: {
            //normalchar:
L690 :;
;
            if (((u64)c == (u64)quotechar)) {
                if ((!!(length) && ((u64)(*s) == (u64)quotechar))) {
                    (*p) = (u64)c;
                    ++(s);
                    ++(p);
                }
                else {
                    qq_print$termchar = (u64)(*s);
                    if ((((u64)qq_print$termchar == ',') || ((u64)qq_print$termchar == '='))) {
                        ++(s);
                        qq_print$termchar = (u64)(*s);
                    }
;
                    goto L689 ;
                }
;
            }
            else {
                (*p) = (u64)c;
                ++(p);
            }
;
        }
        } //SW
;
L688 :;
    }
L689 :;
    ;
    if ((length == (i64)0)) {
        qq_print$termchar = (u64)0u;
    }
;
    (*itemlength) = (p - (*itemstr));
    return s;
}

static void qq_print$strtoreal(u8 *s,i64 length,struct qq_decls$varrec *dest) {
        u8 str[512];
        r64 x;
        i32 numlength;
    (*dest).tagx = (i64)3;
    if (((length >= (i64)512) || (length == (i64)0))) {
        (*dest).xvalue = (double)0.;
        return;
    }
;
    memcpy(str,(void *)s,(u64)length);
    str[((length + (i64)1))-1] = (u64)0u;
    qq_print$itemerror = (i64)0;
    if (((sscanf((u8 *)str,(byte*)"%lf%n",&x,&numlength) == (i64)0) || ((i64)numlength != length))) {
        if (((i64)numlength == length)) {
            x = (double)0.;
        }
;
        qq_print$itemerror = (i64)1;
    }
;
    (*dest).xvalue = x;
}

static void qq_print$strtoint(u8 *s,i64 length,struct qq_decls$varrec *dest,i64 dodec) {
        u8 *  p;
        u8 *  q;
        byte signd;
        i64 aa;
        i64 cat;
        i64 t;
        u8 c;
    qq_print$itemerror = (i64)0;
    if ((length == (i64)0)) {
        (*dest).tagx = (i64)1;
        (*dest).value = (i64)0;
        return;
    }
;
    signd = (i64)0;
    if ((!!(length) && ((u64)(*s) == '-'))) {
        signd = (i64)1;
        ++(s);
        --(length);
    }
    else if ((!!(length) && ((u64)(*s) == '+'))) {
        ++(s);
        --(length);
    }
;
    L691 :;
    while ((((u64)(*s) == '0') && (length > (i64)1))) {
        ++(s);
        --(length);
L692 :;
    }
L693 :;
    ;
    p = (q = s);
    L694 :;
    while (!!(length)) {
        c = (u64)(*(q)++);
        --(length);
        if ((((u64)c >= '0') && ((u64)c <= '9'))) {
            (*p) = (u64)c;
            ++(p);
        }
        else {
            if (((u64)c == '_')) {
            }
            else {
                qq_print$itemerror = (i64)1;
                goto L696 ;
            }
;
        }
;
L695 :;
    }
L696 :;
    ;
    (*p) = (u64)0u;
    length = (p - s);
    if ((length <= (i64)18)) {
        cat = (i64)65;
    }
    else if ((length == (i64)19)) {
                {i64 $temp = mlib$cmpstring(s,(byte*)"9223372036854775808");
if (($temp==(i64)-1)) {
            cat = (i64)65;
        }
        else if (($temp==(i64)0)) {
            cat = (i64)66;
        }
        else {
            cat = (i64)67;
        }
        };
    }
    else if ((length == (i64)20)) {
        if ((mlib$cmpstring(s,(byte*)"18446744073709551615") <= (i64)0)) {
            cat = (i64)67;
        }
        else {
            cat = (i64)68;
        }
;
    }
    else {
        cat = (i64)68;
    }
;
    if (!!(dodec)) {
        cat = (i64)68;
    }
;
    if (!!((i64)signd)) {
        if ((cat==(i64)66)) {
            cat = (i64)65;
        }
        else if ((cat==(i64)67)) {
            cat = (i64)68;
        }
;
    }
;
    if ((cat==(i64)65)) {
        t = (i64)1;
    }
    else if ((cat==(i64)66) || (cat==(i64)67)) {
        t = (i64)2;
    }
    else {
        t = (i64)4;
    }
;
    p = s;
    if ((t != (i64)4)) {
        aa = (i64)0;
        L697 :;
        while (1) {
            c = (u64)(*p);
            ++(p);
            if (((i64)(u64)c == (i64)0)) {
                goto L698 ;
            }
;
            aa = ((aa * (i64)10) + (i64)((u64)c - '0'));
        }
L698 :;
        ;
        if (!!((i64)signd)) {
            aa = -(aa);
        }
;
        (*dest).tagx = t;
        (*dest).value = aa;
    }
    else {
        qq_decimal$var_make_dec_str(s,length,dest);
    }
;
}

static void qq_print$printnextfmtchars(i64 lastx) {
        u8 c;
        u8 *  pstart;
        i64 n;
    pstart = qq_print$mfmtcurr;
    n = (i64)0;
    L699 :;
    while (1) {
        c = (u64)(*qq_print$mfmtcurr);
        switch ((i64)(u64)c) {
        case 35:;
            {
                if (!!(lastx)) {
                    goto L701 ;
;
                }
;
                ++(qq_print$mfmtcurr);
                if (!!(n)) {
                    qq_print$printstr_n(pstart,n);
                }
;
                return;
            }
            break;
        case 0:;
            {
                if (!!(n)) {
                    qq_print$printstr_n(pstart,n);
                }
                else if (!(!!(lastx))) {
                    qq_print$printstr_n((byte*)"|",(i64)1);
                }
;
                return;
            }
            break;
        case 126:;
            {
                if (!!(n)) {
                    qq_print$printstr_n(pstart,n);
                    n = (i64)0;
                }
;
                ++(qq_print$mfmtcurr);
                c = (u64)(*qq_print$mfmtcurr);
                if (!!((u64)c)) {
                    ++(qq_print$mfmtcurr);
                    qq_print$printstr_n((u8 *)&c,(i64)1);
                }
;
                pstart = qq_print$mfmtcurr;
            }
            break;
        default: {
            //skip:
L701 :;
;
            ++(n);
            ++(qq_print$mfmtcurr);
        }
        } //SW
;
    }
L700 :;
    ;
}

static void qq_print$pch_setformat(struct qq_decls$varrec *p) {
        i64 n;
        u8 *  s;
    if (((i64)(*p).tag != (i64)12)) {
        qq_lib$prterror((byte*)"(str)");
    }
;
    if (!!(qq_print$mfmtstr)) {
        qq_lib$prterror((byte*)"Setfmt?");
    }
;
    n = (*(*p).objptr).length;
    qq_print$mfmtstr = (u8 *)mlib$pcm_alloc((n + (i64)1));
    if (!!(n)) {
        memcpy((void *)qq_print$mfmtstr,(void *)(*(*p).objptr).strptr,(u64)n);
    }
;
    s = (qq_print$mfmtstr + n);
    (*s) = (u64)0u;
    qq_print$mfmtcurr = qq_print$mfmtstr;
}

struct qq_print$fmtrec *qq_print$pc_getfmt(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt) {
    if (((p == 0) || ((i64)(*p).tag == (i64)0))) {
        return (struct qq_print$fmtrec *)&qq_print$defaultfmt;
    }
    else {
        if (((i64)(*p).tag != (i64)12)) {
            qq_lib$prterror((byte*)"pc_getfmt/not str?");
        }
;
        if (((*(*p).objptr).strptr == 0)) {
            return (struct qq_print$fmtrec *)&qq_print$defaultfmt;
        }
        else {
            qq_print$pc_strtofmt((*(*p).objptr).strptr,(*(*p).objptr).length,(struct qq_print$fmtrec *)fmt);
            return (struct qq_print$fmtrec *)fmt;
        }
;
    }
;
}

void qq_print$pc_strtofmt(u8 *s,i64 slen,struct qq_print$fmtrec *fmt) {
        i64 c;
        byte wset;
        i64 n;
        u8 str[100];
    qq_print$initfmtcode((struct qq_print$fmtrec *)fmt);
    memcpy(str,(void *)s,(u64)slen);
    str[(slen)] = (u64)0u;
    s = (u8 *)str;
    wset = (i64)0;
    L702 :;
    while (!!((u64)(*s))) {
        c = (i64)(u64)(*s);
        ++(s);
        switch (c) {
        case 66:;
        case 98:;
            {
                (*fmt).base = (i64)2;
            }
            break;
        case 72:;
        case 104:;
            {
                (*fmt).base = (i64)16;
            }
            break;
        case 79:;
        case 111:;
            {
                (*fmt).base = (i64)8;
            }
            break;
        case 88:;
        case 120:;
            {
                c = (i64)(u64)(*s);
                if (!!(c)) {
                    switch (c) {
                    case 50:;
                    case 51:;
                    case 52:;
                    case 53:;
                    case 54:;
                    case 55:;
                    case 56:;
                    case 57:;
                        {
                            c = (c - (i64)48);
                        }
                        break;
                    case 49:;
                        {
                            ++(s);
                            c = (i64)(u64)(*s);
                            if ((c >= (i64)48 && c <= (i64)54)) {
                                c = ((c - (i64)48) + (i64)10);
                            }
;
                        }
                        break;
                    default: {
                        c = (i64)10;
                    }
                    } //SW
;
                    (*fmt).base = c;
                    ++(s);
                }
;
            }
            break;
        case 81:;
        case 113:;
            {
                (*fmt).quotechar = '"';
            }
            break;
        case 126:;
            {
                (*fmt).quotechar = '~';
            }
            break;
        case 74:;
        case 106:;
            {
                (*fmt).justify = (u64)toupper((i32)(u64)(*s));
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 65:;
            {
                (*fmt).lettercase = 'A';
            }
            break;
        case 97:;
            {
                (*fmt).lettercase = 'a';
            }
            break;
        case 90:;
        case 122:;
            {
                (*fmt).padchar = '0';
            }
            break;
        case 83:;
        case 115:;
            {
                (*fmt).sepchar = (u64)(*s);
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 80:;
        case 112:;
            {
                (*fmt).padchar = (u64)(*s);
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 84:;
        case 116:;
            {
                (*fmt).suffix = (u64)(*s);
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 85:;
        case 117:;
            {
                (*fmt).usigned = 'U';
            }
            break;
        case 87:;
        case 119:;
            {
                (*fmt).usigned = 'U';
            }
            break;
        case 69:;
        case 101:;
            {
                (*fmt).realfmt = 'e';
            }
            break;
        case 70:;
        case 102:;
            {
                (*fmt).realfmt = 'f';
            }
            break;
        case 71:;
        case 103:;
            {
                (*fmt).realfmt = 'g';
            }
            break;
        case 46:;
            {
                wset = (i64)1;
            }
            break;
        case 44:;
        case 95:;
            {
                (*fmt).sepchar = (u64)c;
            }
            break;
        case 43:;
            {
                (*fmt).plus = '+';
            }
            break;
        case 77:;
        case 109:;
            {
                (*fmt).charmode = 'M';
            }
            break;
        case 78:;
        case 110:;
            {
                (*fmt).newline = (u64)1u;
            }
            break;
        case 67:;
        case 99:;
            {
                (*fmt).charmode = 'C';
            }
            break;
        case 89:;
        case 121:;
            {
                (*fmt).showtype = 'Y';
            }
            break;
        default: {
            if (((c >= (i64)48) && (c <= (i64)57))) {
                n = (c - (i64)48);
                L705 :;
                while (1) {
                    c = (i64)(u64)(*s);
                    if (((i64)(u64)(*s) == (i64)0)) {
                        goto L706 ;
                    }
;
                    if (((c >= (i64)48) && (c <= (i64)57))) {
                        ++(s);
                        n = (((n * (i64)10) + c) - (i64)48);
                    }
                    else {
                        goto L706 ;
                    }
;
                }
L706 :;
                ;
                if (!(!!((i64)wset))) {
                    (*fmt).minwidth = (n<(i64)1023?n:(i64)1023);
                    wset = (i64)1;
                }
                else {
                    (*fmt).precision = (n<(i64)100?n:(i64)100);
                }
;
            }
;
        }
        } //SW
;
L703 :;
    }
L704 :;
    ;
}

static void qq_print$initfmtcode(struct qq_print$fmtrec *f) {
    (*f) = qq_print$defaultfmt;
}

static i64 qq_print$i64mintostr(u8 *s,i64 base,i64 sep) {
        u8 t[1024];
        i64 i;
        i64 j;
        i64 k;
        i64 g;
    switch (base) {
    case 10:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"9223372036854775808");
            j = (i64)3;
        }
        break;
    case 16:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"8000000000000000");
            j = (i64)1;
        }
        break;
    case 2:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"1000000000000000000000000000000000000000000000000000000000000000");
            j = (i64)7;
        }
        break;
    default: {
        strcpy((u8 *)&t[((i64)0)],(byte*)"<mindint>");
    }
    } //SW
;
    i = strlen((u8 *)&t[((i64)0)]);
    s += i;
    if (!!(sep)) {
        s += j;
    }
;
    (*s) = (u64)0u;
    k = (i64)0;
    g = ((base == (i64)10) ? (i64)3 : (i64)4);
    L707 :;
    while (!!(i)) {
        --(s);
        (*s) = (u64)t[(((i)-- - (i64)1))];
        if (((!!(sep) && !!(i)) && (++(k) == g))) {
            --(s);
            (*s) = (u64)sep;
            k = (i64)0;
        }
;
L708 :;
    }
L709 :;
    ;
    return strlen(s);
}

static i64 qq_print$u64tostr(u64 aa,u8 *s,u64 base,i64 sep) {
        u8 t[1024];
        i64 i;
        i64 j;
        i64 k;
        i64 g;
        u8 *  s0;
    i = (i64)0;
    k = (i64)0;
    g = (((i64)base == (i64)10) ? (i64)3 : (i64)4);
    L710 :;
    do {
        t[(++(i))] = (u64)qq_print$digits[((i64)(aa % base))];
        aa = (aa / base);
        if (((!!(sep) && ((i64)aa != (i64)0)) && (++(k) == g))) {
            t[(++(i))] = (u64)sep;
            k = (i64)0;
        }
;
L711 :;
    }
    while (!((i64)aa == (i64)0));
L712 :;
    ;
    j = i;
    s0 = s;
    L713 :;
    while (!!(i)) {
        (*s) = (u64)t[((i)--)];
        ++(s);
L714 :;
    }
L715 :;
    ;
    (*s) = (u64)0u;
    return j;
}

static i64 qq_print$i64tostrfmt(i64 aa,u8 *s,struct qq_print$fmtrec *fmt,i64 usigned) {
        u8 str[1024];
        i64 n;
        static u64 mindint = (u64)9223372036854775808u;
    if (!!((u64)(*fmt).usigned)) {
        usigned = (i64)1;
    }
;
    if (((aa == (i64)mindint) && !(!!(usigned)))) {
        str[((i64)0)] = '-';
        n = (qq_print$i64mintostr((u8 *)&str[((i64)1)],(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar) + (i64)1);
    }
    else {
        if (((!(!!(usigned)) && (aa < (i64)0)) || !!((u64)(*fmt).plus))) {
            if ((aa < (i64)0)) {
                aa = -(aa);
                str[((i64)0)] = '-';
            }
            else {
                str[((i64)0)] = '+';
            }
;
            n = (qq_print$u64tostr((u64)aa,(u8 *)&str[((i64)1)],(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar) + (i64)1);
        }
        else {
            n = qq_print$u64tostr((u64)aa,(u8 *)str,(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar);
        }
;
    }
;
    if (!!((u64)(*fmt).suffix)) {
        str[(n)] = (u64)(*fmt).suffix;
        str[(++(n))] = (u64)0u;
    }
;
    if (((((i64)(*fmt).base > (i64)10) || !!((u64)(*fmt).suffix)) && ((u64)(*fmt).lettercase == 'a'))) {
        mlib$convlcstring((u8 *)str);
    }
;
    return qq_print$expandstr((u8 *)str,s,n,(struct qq_print$fmtrec *)fmt);
}

static i64 qq_print$u64tostrfmt(i64 aa,u8 *s,struct qq_print$fmtrec *fmt) {
        u8 str[1024];
        i64 n;
    n = qq_print$u64tostr((u64)aa,(u8 *)str,(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar);
    if (!!((u64)(*fmt).suffix)) {
        str[(n)] = (u64)(*fmt).suffix;
        str[(++(n))] = (u64)0u;
    }
;
    return qq_print$expandstr((u8 *)str,s,n,(struct qq_print$fmtrec *)fmt);
}

static i64 qq_print$strtostrfmt(u8 *s,u8 *t,i64 n,struct qq_print$fmtrec *fmt) {
        u8 *  u;
        u8 *  v;
        u8 str[256];
        i64 w;
        i64 nheap;
    nheap = (i64)0;
    if ((!!((u64)(*fmt).quotechar) || !!((u64)(*fmt).lettercase))) {
        if ((n < (i64)256)) {
            u = (u8 *)str;
        }
        else {
            nheap = (n + (i64)3);
            u = (u8 *)mlib$pcm_alloc(nheap);
        }
;
        if (!!((u64)(*fmt).quotechar)) {
            v = u;
            (*v) = (u64)(*fmt).quotechar;
            ++(v);
            if (!!(n)) {
                strcpy(v,s);
                v += n;
            }
;
            (*v) = (u64)(*fmt).quotechar;
            ++(v);
            (*v) = (u64)0u;
            n += (i64)2;
        }
        else {
            memcpy((void *)u,(void *)s,(u64)n);
        }
;
        switch ((i64)(u64)(*fmt).lettercase) {
        case 97:;
            {
                mlib$convlcstring(u);
            }
            break;
        case 65:;
            {
                mlib$convucstring(u);
            }
            break;
        } //SW
;
        s = u;
    }
;
    w = (i64)(*fmt).minwidth;
    if ((w > n)) {
        n = qq_print$expandstr(s,t,n,(struct qq_print$fmtrec *)fmt);
    }
    else {
        memcpy((void *)t,(void *)s,(u64)n);
    }
;
    if (!!(nheap)) {
        mlib$pcm_free((void *)u,nheap);
    }
;
    return n;
}

static i64 qq_print$expandstr(u8 *s,u8 *t,i64 n,struct qq_print$fmtrec *fmt) {
        i64 i;
        i64 w;
        i64 m;
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
        i64 $av_4;
        i64 $av_5;
    w = (i64)(*fmt).minwidth;
    if (((w == (i64)0) || (w <= n))) {
        strncpy(t,s,(u64)n);
        (*(t + n)) = (u64)0u;
        return n;
    }
;
    if (((u64)(*fmt).justify == 'L')) {
        strncpy(t,s,(u64)n);
        t += n;
                ($av_1 = (w - n));
        for (i=(i64)1;i<=$av_1;++i) {
L716 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L717 :;
        }
L718 :;
        ;
        (*t) = (u64)0u;
    }
    else if (((u64)(*fmt).justify == 'R')) {
        if (((((u64)(*fmt).padchar == '0') && !!((i64)(*fmt).base)) && (((u64)(*s) == '-') || ((u64)(*s) == '+')))) {
            (*t) = (u64)(*s);
            ++(t);
            $av_2 = (w - n);
            while ($av_2-- > 0) {
L719 :;
                (*t) = (u64)(*fmt).padchar;
                ++(t);
L720 :;
            }
L721 :;
            ;
            strncpy(t,(s + (i64)1),(u64)(n - (i64)1));
            (*((t + n) - (i64)1)) = (u64)0u;
        }
        else {
            $av_3 = (w - n);
            while ($av_3-- > 0) {
L722 :;
                (*t) = (u64)(*fmt).padchar;
                ++(t);
L723 :;
            }
L724 :;
            ;
            strncpy(t,s,(u64)n);
            (*(t + n)) = (u64)0u;
        }
;
    }
    else {
        m = (((w - n) + (i64)1) / (i64)2);
        $av_4 = m;
        while ($av_4-- > 0) {
L725 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L726 :;
        }
L727 :;
        ;
        strncpy(t,s,(u64)n);
        t += n;
        $av_5 = ((w - n) - m);
        while ($av_5-- > 0) {
L728 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L729 :;
        }
L730 :;
        ;
        (*t) = (u64)0u;
    }
;
    return w;
}

void qq_print$addstring(struct qq_decls$objrec *p,u8 *t,i64 n) {
        i64 oldlen;
        i64 newlen;
        i64 oldbytes;
        i64 newbytes;
        u8 *  newptr;
    if (((n == (i64)0) || ((i64)(u64)(*t) == (i64)0))) {
        return;
    }
;
    if ((n < (i64)0)) {
        n = strlen(t);
    }
;
    oldlen = (*p).length;
    if (((i64)(*p).refcount == (i64)0)) {
        if ((oldlen == (i64)0)) {
            memcpy((void *)(*p).strptr,(void *)t,(u64)n);
            (*p).length = n;
        }
        else {
            memcpy((void *)((*p).strptr + oldlen),(void *)t,(u64)n);
            (*p).length = (oldlen + n);
        }
;
        return;
    }
;
    if ((oldlen == (i64)0)) {
        (*p).strptr = (u8 *)mlib$pcm_alloc(n);
        (*p).length = n;
        (*p).alloc64 = mlib$allocbytes;
        memcpy((void *)(*p).strptr,(void *)t,(u64)n);
    }
    else {
        newlen = (oldlen + n);
        oldbytes = (*p).alloc64;
        newbytes = (oldlen + n);
        if ((newbytes <= oldbytes)) {
            memcpy((void *)((*p).strptr + oldlen),(void *)t,(u64)n);
        }
        else {
            newptr = (u8 *)mlib$pcm_alloc(newbytes);
            memcpy((void *)newptr,(void *)(*p).strptr,(u64)oldlen);
            memcpy((void *)(newptr + oldlen),(void *)t,(u64)n);
            (*p).alloc64 = mlib$allocbytes;
            mlib$pcm_free((void *)(*p).strptr,oldbytes);
            (*p).strptr = newptr;
        }
;
        (*p).length = newlen;
    }
;
}

static void qq_print$domultichar(u8 *p,i64 n,u8 *dest,struct qq_print$fmtrec *fmt) {
        u8 str[20];
        u8 *  q;
        i64 nchars;
        i64 $av_1;
    q = (u8 *)str;
    nchars = n;
    $av_1 = n;
    while ($av_1-- > 0) {
L731 :;
        if (((i64)(u64)(*p) == (i64)0)) {
            goto L733 ;
        }
;
        (*q) = (u64)(*p);
        ++(q);
        ++(p);
L732 :;
    }
L733 :;
    ;
    (*q) = (u64)0u;
    qq_print$expandstr(str,dest,nchars,(struct qq_print$fmtrec *)fmt);
}

static void qq_print$printstr_n(u8 *s,i64 n) {
        struct qq_decls$varrec *  p;
    if ((n == (i64)-1)) {
        n = strlen(s);
    }
;
    if ((n == (i64)0)) {
        return;
    }
;
    switch (qq_print$moutdev) {
    case 0:;
        {
            msysc$printstrn_app(s,n,0);
        }
        break;
    case 1:;
        {
            msysc$printstrn_app(s,n,qq_print$moutchan);
        }
        break;
    case 2:;
        {
            qq_print$addstring(qq_print$moutvar.objptr,s,n);
        }
        break;
    case 4:;
        {
            p = qq_print$moutvar.varptr;
            if (((i64)(*p).tag != (i64)12)) {
                qq_lib$prterror((byte*)"prtstrn1");
            }
;
            qq_print$addstring(qq_print$moutvar.objptr,s,n);
        }
        break;
    case 3:;
        {
        }
        break;
    } //SW
;
}

void qq_print$pch_strtoval(struct qq_decls$varrec *p,struct qq_decls$varrec *fmt,struct qq_decls$varrec *dest) {
        i64 fmtcode;
        i64 length;
        struct qq_decls$objrec *  q;
        u8 str[1024];
        u8 *  s;
    s = (u8 *)str;
    q = (*p).objptr;
    if (((*q).length < (i64)1024)) {
        memcpy((void *)s,(void *)(*q).strptr,(u64)(*q).length);
        str[(((*q).length + (i64)1))-1] = (u64)0u;
    }
    else {
        qq_lib$pcerror((byte*)"STRTOVAL/string too long");
    }
;
    fmtcode = qq_print$getreadfmtcode(fmt);
    if (((i64)(*p).tag != (i64)12)) {
        qq_lib$prterror((byte*)"strval");
    }
;
    length = (*(*p).objptr).length;
    switch (fmtcode) {
    case 73:;
        {
            qq_print$readint(s,length,dest,(i64)0);
        }
        break;
    case 68:;
        {
            qq_print$readint(s,length,dest,(i64)1);
        }
        break;
    case 82:;
        {
            qq_print$readreal(s,length,dest);
        }
        break;
    case 78:;
        {
            qq_print$readname(s,length,dest);
        }
        break;
    case 83:;
        {
            qq_print$readstring(s,length,dest);
        }
        break;
    case 72:;
        {
            qq_print$readhex(s,length,dest);
        }
        break;
    case 66:;
        {
            qq_print$readbin(s,length,dest);
        }
        break;
    case 65:;
        {
            qq_print$readany(s,length,dest);
        }
        break;
    default: {
        qq_lib$prterror((byte*)"strval:fmt?");
    }
    } //SW
;
}

static void qq_print$tostr_int(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 str[1024];
    switch ((i64)(u64)(*fmt).charmode) {
    case 77:;
        {
            qq_print$domultichar((u8 *)&(*p).value,(i64)8,str,(struct qq_print$fmtrec *)fmt);
        }
        break;
    case 67:;
        {
            str[((i64)0)] = (u64)(*p).value;
            str[((i64)1)] = (u64)0u;
        }
        break;
    default: {
        qq_print$i64tostrfmt((*p).value,str,(struct qq_print$fmtrec *)fmt,(i64)0);
    }
    } //SW
;
    if (!!((u64)(*fmt).showtype)) {
        qq_print$addstring(dest,(byte*)"I:",(i64)2);
    }
;
    qq_print$addstring(dest,str,strlen(str));
}

static void qq_print$tostr_word(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 str[1024];
    switch ((i64)(u64)(*fmt).charmode) {
    case 77:;
        {
            qq_print$domultichar((u8 *)&(*p).uvalue,(i64)8,str,(struct qq_print$fmtrec *)fmt);
        }
        break;
    case 67:;
        {
            str[((i64)1)] = (u64)(*p).uvalue;
            str[((i64)2)] = (u64)0u;
        }
        break;
    default: {
        qq_print$u64tostrfmt((*p).value,str,(struct qq_print$fmtrec *)fmt);
    }
    } //SW
;
    if (!!((u64)(*fmt).showtype)) {
        qq_print$addstring(dest,(byte*)"W:",(i64)2);
    }
;
    qq_print$addstring(dest,str,strlen(str));
}

static void qq_print$tostr_real(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 str[1024];
        u8 str2[1024];
        u8 cfmt[10];
        i64 n;
    if (!!((i64)(*fmt).precision)) {
        cfmt[((i64)1)-1] = '.';
        cfmt[((i64)2)-1] = '*';
        cfmt[((i64)3)-1] = (u64)(*fmt).realfmt;
        cfmt[((i64)4)-1] = (u64)0u;
        msysc$m_print_startstr(str);
        msysc$m_print_i64((i64)(*fmt).precision,(byte*)"v");
        msysc$m_print_r64((*p).xvalue,cfmt);
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startstr(str);
        msysc$m_print_r64((*p).xvalue,(byte*)"fmt");
        msysc$m_print_end();
        ;
    }
;
    n = strlen(str);
    if ((n < (i64)(*fmt).minwidth)) {
        qq_print$expandstr(str,str2,n,(struct qq_print$fmtrec *)fmt);
        strcpy(str,str2);
    }
;
    qq_print$addstring(dest,str,strlen(str));
}

static void qq_print$tostr_str(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        i64 oldlen;
        i64 newlen;
        u8 *  s;
        struct qq_decls$objrec *  q;
    q = (*p).objptr;
    oldlen = (*q).length;
    newlen = oldlen;
    if ((!!((u64)(*fmt).quotechar) || ((i64)(*fmt).minwidth > newlen))) {
        if (!!((u64)(*fmt).quotechar)) {
            newlen += (i64)2;
        }
;
        if (((i64)(*fmt).minwidth > newlen)) {
            newlen = (i64)(*fmt).minwidth;
        }
;
        s = (u8 *)mlib$pcm_alloc((newlen + (i64)1));
        qq_print$strtostrfmt((*q).strptr,s,oldlen,(struct qq_print$fmtrec *)fmt);
        qq_print$addstring(dest,s,newlen);
        mlib$pcm_free((void *)s,(newlen + (i64)1));
    }
    else {
        qq_print$addstring(dest,(*q).strptr,oldlen);
    }
;
}

static void qq_print$pch_tostr(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *result) {
        struct qq_print$fmtrec fmt;
        struct qq_print$fmtrec *  ifmt;
        struct qq_decls$objrec *  p;
    ifmt = (struct qq_print$fmtrec *)qq_print$pc_getfmt(b,&fmt);
    p = qq_strings$obj_new_string((i64)0);
    qq_print$listdepth = (i64)0;
    qq_print$tostr(a,(struct qq_print$fmtrec *)ifmt,p);
    (*result).tagx = (i64)268;
    (*result).objptr = p;
}

static void qq_print$tostr_list(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        struct qq_decls$varrec *  q;
        i64 i;
        i64 n;
        struct qq_decls$objrec *  r;
        i64 $av_1;
    ++(qq_print$listdepth);
    r = (*p).objptr;
    if ((((i64)(*r).refcount < (i64)0) || (qq_print$listdepth > (i64)4))) {
        qq_print$addstring(dest,(byte*)"...",(i64)3);
        --(qq_print$listdepth);
        return;
    }
;
    (*r).refcount = -((i64)(*r).refcount);
    q = (*r).varptr;
    n = (*(*p).objptr).length;
    if (!!((u64)(*fmt).newline)) {
        $av_1 = n;
        while ($av_1-- > 0) {
L734 :;
            qq_print$tostr(q,(struct qq_print$fmtrec *)fmt,dest);
            qq_print$addstring(dest,(byte*)"\n",(i64)-1);
            ++(q);
L735 :;
        }
L736 :;
        ;
    }
    else {
        qq_print$addstring(dest,(byte*)"(",(i64)1);
        for (i=n;i>=(i64)1;--i) {
L737 :;
            qq_print$tostr(q,(struct qq_print$fmtrec *)fmt,dest);
            ++(q);
            if ((i != (i64)1)) {
                qq_print$addstring(dest,(byte*)",",(i64)1);
            }
;
L738 :;
        }
L739 :;
        ;
        qq_print$addstring(dest,(byte*)")",(i64)1);
    }
;
    (*r).refcount = -((i64)(*r).refcount);
    --(qq_print$listdepth);
}

static void qq_print$tostr_iterator(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        struct qq_decls$objrec *  r;
    r = (*p).objptr;
    qq_print$addstring(dest,(byte*)"Iterator:",(i64)-1);
    qq_print$addstring(dest,qq_tables$ttname[((i64)(*r).itertag)],(i64)-1);
    qq_print$addstring(dest,(byte*)" ",(i64)-1);
    qq_print$addstring(dest,msysc$strint((i64)(*r).iterpos,0),(i64)-1);
}

static void qq_print$tostr_range(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 str[1024];
    qq_print$i64tostrfmt(msysc$m_getdotslice((*p).dummy,(i64)16,(i64)63),str,(struct qq_print$fmtrec *)fmt,(i64)0);
    strcat(str,(byte*)"..");
    qq_print$addstring(dest,str,(i64)-1);
    qq_print$i64tostrfmt((i64)(*p).range_upper,str,(struct qq_print$fmtrec *)fmt,(i64)0);
    qq_print$addstring(dest,str,(i64)-1);
}

static void qq_print$tostr_array(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 str[1024];
        byte *  q;
        i64 i;
        i64 m;
        i64 elemtype;
        i64 a;
        i64 b;
        i64 lower;
        i64 length;
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  pa;
    m = (i64)(*p).tag;
    pa = (*p).objptr;
    if (((i64)(*p).tag == (i64)14)) {
        length = (*pa).length;
        lower = (i64)msysc$m_getdotindex((i64)(*pa).flags,(i64)0);
        elemtype = (i64)(*pa).elemtag;
    }
    else {
        length = qq_tables$ttlength[((i64)(*pa).usertag)];
        lower = qq_tables$ttlower[((i64)(*pa).usertag)];
        elemtype = (i64)qq_tables$tttarget[((i64)(*pa).usertag)];
    }
;
    a = lower;
    b = ((length + lower) - (i64)1);
    q = (*pa).ptr;
    if (!!((u64)(*fmt).showtype)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#[#:#]A");
        msysc$m_print_str(qq_tables$ttname[(m)],NULL);
        msysc$m_print_i64(lower,NULL);
        msysc$m_print_str(qq_tables$ttname[(elemtype)],NULL);
        msysc$m_print_end();
        ;
        qq_print$addstring(dest,str,(i64)-1);
    }
;
    qq_print$addstring(dest,(byte*)"(",(i64)-1);
    for (i=a;i<=b;++i) {
L740 :;
        qq_packed$var_loadpacked(q,elemtype,&v,0);
        q += qq_tables$ttsize[(elemtype)];
        qq_print$tostr(&v,(struct qq_print$fmtrec *)fmt,dest);
        if ((i < b)) {
            qq_print$addstring(dest,(byte*)",",(i64)1);
        }
;
L741 :;
    }
L742 :;
    ;
    qq_print$addstring(dest,(byte*)")",(i64)1);
}

static void qq_print$tostr_bits(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 str[1024];
        byte *  q;
        i64 i;
        i64 m;
        i64 elemtype;
        i64 a;
        i64 b;
        i64 bitwidthx;
        i64 offset;
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  pa;
    m = (i64)(*p).tag;
    pa = (*p).objptr;
    a = (i64)(*pa).lower16;
    elemtype = (i64)(*pa).elemtag;
    b = (((*pa).length + a) - (i64)1);
    bitwidthx = (i64)qq_tables$ttbitwidth[(elemtype)];
    offset = ((i64)(*pa).indexoffset * bitwidthx);
    q = (*pa).ptr;
    if (!!((u64)(*fmt).showtype)) {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"#[#:#]A");
        msysc$m_print_str(qq_tables$ttname[(m)],NULL);
        msysc$m_print_i64((i64)(*pa).lower16,NULL);
        msysc$m_print_str(qq_tables$ttname[(elemtype)],NULL);
        msysc$m_print_end();
        ;
        qq_print$addstring(dest,str,(i64)-1);
    }
;
    qq_print$addstring(dest,(byte*)"(",(i64)-1);
    for (i=a;i<=b;++i) {
L743 :;
        qq_vars$var_loadbit(q,offset,elemtype,(i64)0,&v);
        offset += bitwidthx;
        if ((offset >= (i64)8)) {
            offset = (i64)0;
            ++(q);
        }
;
        qq_print$tostr(&v,(struct qq_print$fmtrec *)fmt,dest);
        if ((i < b)) {
            qq_print$addstring(dest,(byte*)",",(i64)1);
        }
;
L744 :;
    }
L745 :;
    ;
    qq_print$addstring(dest,(byte*)")",(i64)1);
}

static void qq_print$tostr_struct(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        i64 i;
        i64 m;
        i64 nfields;
        i64 needcomma;
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  pa;
        struct qq_decls$strec *  d;
        struct qq_decls$strec **  r;
    pa = (*p).objptr;
    m = (i64)(*pa).usertag;
    d = qq_tables$ttnamedef[(m)];
    r = (struct qq_decls$strec **)(*d).topfieldlist;
    nfields = qq_tables$ttlength[(m)];
    needcomma = (i64)0;
    qq_print$addstring(dest,(byte*)"(",(i64)-1);
    for (i=(i64)1;i<=nfields;++i) {
L746 :;
        qq_packed$var_loadpacked(((*pa).ptr + (i64)(*(*r)).fieldoffset),(i64)(*(*r)).mode,&v,0);
        if (!!(needcomma)) {
            qq_print$addstring(dest,(byte*)",",(i64)-1);
        }
;
        needcomma = (i64)1;
        qq_print$tostr(&v,(struct qq_print$fmtrec *)fmt,dest);
        ++(r);
L747 :;
    }
L748 :;
    ;
    qq_print$addstring(dest,(byte*)")",(i64)-1);
}

static void qq_print$tostr_set(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        i64 i;
        i64 j;
        i64 first;
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  s;
    if ((fmt == 0)) {
        fmt = (struct qq_print$fmtrec *)&qq_print$defaultfmt;
    }
;
    qq_print$addstring(dest,(byte*)"[",(i64)1);
    s = (*p).objptr;
    first = (i64)1;
    i = (i64)0;
    L749 :;
    while ((i < (*s).length)) {
        if (!!(qq_lib$testelem((byte (*)[])(*s).ptr,i))) {
            j = (i + (i64)1);
            L752 :;
            while (((j < (*s).length) && !!(qq_lib$testelem((byte (*)[])(*s).ptr,j)))) {
                ++(j);
L753 :;
            }
L754 :;
            ;
            --(j);
            if (!(!!(first))) {
                qq_print$addstring(dest,(byte*)",",(i64)1);
            }
;
            first = (i64)0;
            if ((i == j)) {
                v.tagx = (i64)1;
                v.value = i;
            }
            else {
                v.tagx = (i64)6;
                v.dummy = msysc$m_setdotslice(v.dummy,(i64)16,(i64)63,i);
                v.range_upper = (u64)j;
            }
;
            qq_print$tostr(&v,(struct qq_print$fmtrec *)fmt,dest);
            i = (j + (i64)1);
        }
        else {
            ++(i);
        }
;
L750 :;
    }
L751 :;
    ;
    qq_print$addstring(dest,(byte*)"]",(i64)1);
}

static void qq_print$tostr_dict(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        struct qq_decls$varrec *  q;
        i64 i;
        i64 length;
        i64 needcomma;
        struct qq_decls$objrec *  pa;
    needcomma = (i64)0;
    if ((fmt == 0)) {
        fmt = (struct qq_print$fmtrec *)&qq_print$defaultfmt;
    }
;
    qq_print$addstring(dest,(byte*)"[",(i64)-1);
    pa = (*p).objptr;
    q = (*pa).varptr;
    length = ((*pa).length / (i64)2);
    for (i=length;i>=(i64)1;--i) {
L755 :;
        if (((i64)(*q).tag == (i64)0)) {
            q += (i64)2;
            goto L756 ;
        }
;
        if (!!(needcomma)) {
            qq_print$addstring(dest,(byte*)",",(i64)1);
        }
;
        needcomma = (i64)1;
        qq_print$tostr(q,(struct qq_print$fmtrec *)fmt,dest);
        ++(q);
        qq_print$addstring(dest,(byte*)":",(i64)1);
        qq_print$tostr(q,(struct qq_print$fmtrec *)fmt,dest);
        ++(q);
L756 :;
    }
L757 :;
    ;
    qq_print$addstring(dest,(byte*)"]",(i64)1);
}

static void qq_print$tostr_decimal(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 *  s;
    s = qq_decimal$var_tostr_dec(p,(i64)0);
    qq_print$addstring(dest,s,(i64)-1);
    mlib$pcm_free((void *)s,qq_decimal$decstrsize);
}

static void qq_print$tostr(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        u8 str[1024];
    switch ((i64)(*p).tag) {
    case 1:;
        {
            qq_print$tostr_int(p,(struct qq_print$fmtrec *)fmt,dest);
        }
        break;
    case 2:;
        {
            qq_print$tostr_word(p,(struct qq_print$fmtrec *)fmt,dest);
        }
        break;
    case 3:;
        {
            qq_print$tostr_real(p,(struct qq_print$fmtrec *)fmt,dest);
        }
        break;
    case 12:;
        {
            qq_print$tostr_str(p,(struct qq_print$fmtrec *)fmt,dest);
        }
        break;
    case 6:;
        {
            qq_print$tostr_range(p,(struct qq_print$fmtrec *)fmt,dest);
        }
        break;
    case 13:;
        {
            qq_print$tostr_list(p,(struct qq_print$fmtrec *)fmt,dest);
        }
        break;
    case 15:;
        {
            qq_print$tostr_record(p,(struct qq_print$fmtrec *)fmt,dest);
        }
        break;
    case 14:;
    case 10:;
        {
            qq_print$tostr_array(p,(struct qq_print$fmtrec *)fmt,dest);
        }
        break;
    case 11:;
        {
            qq_print$tostr_bits(p,(struct qq_print$fmtrec *)fmt,dest);
        }
        break;
    case 8:;
        {
            qq_print$tostr_set(p,(struct qq_print$fmtrec *)fmt,dest);
        }
        break;
    case 16:;
        {
            qq_print$tostr_struct(p,(struct qq_print$fmtrec *)fmt,dest);
        }
        break;
    case 4:;
        {
            qq_print$tostr_decimal(p,(struct qq_print$fmtrec *)fmt,dest);
        }
        break;
    case 9:;
        {
            qq_print$tostr_dict(p,(struct qq_print$fmtrec *)fmt,dest);
        }
        break;
    case 0:;
        {
            qq_print$addstring(dest,(byte*)"<Void>",(i64)-1);
        }
        break;
    case 17:;
        {
            if (!!((u64)(*fmt).showtype)) {
                msysc$m_print_startstr(str);
                msysc$m_print_setfmt((byte*)"#<#>:");
                msysc$m_print_str(qq_tables$ttname[((i64)(*p).tag)],NULL);
                msysc$m_print_str((!!((*p).varptr) ? qq_tables$ttname[((i64)(*(*p).varptr).tag)] : (byte*)""),NULL);
                msysc$m_print_end();
                ;
                qq_print$addstring(dest,str,(i64)-1);
            }
;
            //showptr:
L758 :;
;
            if (((*p).varptr == 0)) {
                qq_print$addstring(dest,(byte*)"nil",(i64)-1);
            }
            else {
                qq_print$addstring(dest,msysc$strint((i64)(*p).varptr,(byte*)"H"),(i64)-1);
            }
;
        }
        break;
    case 24:;
        {
            if (!!((u64)(*fmt).showtype)) {
                msysc$m_print_startstr(str);
                msysc$m_print_setfmt((byte*)"#<#>:");
                msysc$m_print_str(qq_tables$ttname[((i64)(*p).tag)],NULL);
                msysc$m_print_str((!!((*p).varptr) ? qq_tables$ttname[((i64)(*p).elemtag)] : (byte*)""),NULL);
                msysc$m_print_end();
                ;
                qq_print$addstring(dest,str,(i64)-1);
            }
;
            goto L758 ;
;
        }
        break;
    case 18:;
        {
            if (!!((u64)(*fmt).showtype)) {
                msysc$m_print_startstr(str);
                msysc$m_print_setfmt((byte*)"#<#>(#,#):");
                msysc$m_print_str(qq_tables$ttname[((i64)(*p).tag)],NULL);
                msysc$m_print_str((!!((*p).varptr) ? qq_tables$ttname[((i64)(*p).elemtag)] : (byte*)""),NULL);
                msysc$m_print_i64((i64)(*p).bitoffset,NULL);
                msysc$m_print_i64((i64)(*p).bitlength,NULL);
                msysc$m_print_end();
                ;
                qq_print$addstring(dest,str,(i64)-1);
            }
;
            goto L758 ;
;
        }
        break;
    case 23:;
        {
            if (!!((*p).def)) {
                msysc$m_print_startstr(str);
                msysc$m_print_setfmt((byte*)"<#:\"#\">");
                msysc$m_print_str(qq_tables$namenames[((i64)(*(*p).def).nameid)],NULL);
                msysc$m_print_str((*(*p).def).name,NULL);
                msysc$m_print_end();
                ;
                qq_print$addstring(dest,str,(i64)-1);
            }
            else {
                qq_print$addstring(dest,(byte*)"<nil>",(i64)-1);
            }
;
        }
        break;
    case 19:;
        {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"#");
            msysc$m_print_str(qq_tables$ttname[((*p).value)],NULL);
            msysc$m_print_end();
            ;
            qq_print$addstring(dest,str,(i64)-1);
        }
        break;
    case 20:;
        {
            msysc$m_print_startstr(str);
            msysc$m_print_setfmt((byte*)"(#)");
            msysc$m_print_str((qq_tables$pclnames[((*p).value)] + (i64)1),NULL);
            msysc$m_print_end();
            ;
            qq_print$addstring(dest,str,(i64)-1);
        }
        break;
    case 7:;
        {
            qq_print$addstring(dest,qq_lib$getenumname((i64)(*p).elemtag,(*p).value),(i64)-1);
        }
        break;
    case 5:;
        {
            qq_print$addstring(dest,(!!((*p).value) ? (byte*)"True" : (byte*)"False"),(i64)-1);
        }
        break;
    case 25:;
        {
            qq_print$tostr_iterator(p,(struct qq_print$fmtrec *)fmt,dest);
        }
        break;
    default: {
        qq_lib$pcustype((byte*)"Tostr:",p);
    }
    } //SW
;
}

static void qq_print$tostr_record(struct qq_decls$varrec *p,struct qq_print$fmtrec *fmt,struct qq_decls$objrec *dest) {
        struct qq_decls$varrec *  q;
        i64 i;
        i64 n;
        struct qq_decls$objrec *  r;
        i64 $av_1;
    r = (*p).objptr;
    ++(qq_print$listdepth);
    if ((((i64)(*r).refcount < (i64)0) || (qq_print$listdepth > (i64)4))) {
        qq_print$addstring(dest,(byte*)"...",(i64)3);
        --(qq_print$listdepth);
        return;
    }
;
    (*r).refcount = -((i64)(*r).refcount);
    q = (*r).varptr;
    n = qq_tables$ttlength[((i64)(*r).usertag)];
    if (!!((u64)(*fmt).newline)) {
        $av_1 = n;
        while ($av_1-- > 0) {
L759 :;
            qq_print$tostr(q,(struct qq_print$fmtrec *)fmt,dest);
            qq_print$addstring(dest,(byte*)"\n",(i64)-1);
            ++(q);
L760 :;
        }
L761 :;
        ;
    }
    else {
        qq_print$addstring(dest,(byte*)"(",(i64)1);
        for (i=n;i>=(i64)1;--i) {
L762 :;
            qq_print$tostr(q,(struct qq_print$fmtrec *)fmt,dest);
            ++(q);
            if ((i != (i64)1)) {
                qq_print$addstring(dest,(byte*)",",(i64)1);
            }
;
L763 :;
        }
L764 :;
        ;
        qq_print$addstring(dest,(byte*)")",(i64)1);
    }
;
    (*r).refcount = -((i64)(*r).refcount);
    --(qq_print$listdepth);
}

// START
void qq_print$start(void) {

}

void qq_pclgen$evalunit(struct qq_decls$unitrec *p,i64 res) {
        struct qq_decls$unitrec *  a;
        struct qq_decls$unitrec *  b;
        struct qq_decls$strec *  d;
        i64 procflag;
        i64 index;
    qq_decls$qpos = (i64)(*p).pos;
    a = (*p).a;
    b = (*p).b;
    switch ((i64)(*p).tag) {
    case 50:;
        {
            qq_pcllib$genpc_int((i64)18,(*p).value);
        }
        break;
    case 51:;
        {
            qq_pcllib$genpc_int((i64)19,(i64)(*p).uvalue);
        }
        break;
    case 54:;
        {
            qq_pcllib$genpc_real((i64)22,(*p).xvalue);
        }
        break;
    case 55:;
        {
            qq_pcllib$genpc((!!((*p).value) ? (i64)24 : (i64)25));
        }
        break;
    case 56:;
        {
            qq_pcllib$genpc_int2((i64)27,(*p).value,(i64)(*p).mode);
        }
        break;
    case 0:;
        {
        }
        break;
    case 57:;
        {
            qq_pclgen$pushstring((*p).svalue,(i64)(*p).length);
        }
        break;
    case 47:;
        {
            d = (*p).def;
                        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)12)) {
                qq_pcllib$genpc_name((i64)10,(struct qq_decls$strec *)d);
            }
            else if (($temp==(i64)13)) {
                qq_pcllib$genpc_name((i64)10,(struct qq_decls$strec *)d);
                if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)5))) {
                    qq_pcllib$genpc((i64)31);
                }
;
            }
            else if (($temp==(i64)11)) {
                qq_pcllib$genpc_name((i64)9,(struct qq_decls$strec *)d);
            }
            else if (($temp==(i64)15)) {
                if (!(!!(res))) {
                    if (((*d).labelno == (i64)0)) {
                        (*d).labelno = qq_pcllib$createfwdlabel();
                    }
;
                    qq_pcllib$genpc_lab((i64)39,(*d).labelno);
                    return;
                }
                else {
                    qq_pcllib$genpc_name((i64)29,(struct qq_decls$strec *)d);
                }
;
            }
            else {
                qq_pcllib$genpc_name((i64)29,(struct qq_decls$strec *)d);
            }
            };
        }
        break;
    case 48:;
        {
            if (((i64)(*a).tag == (i64)47)) {
                qq_pcllib$genpc_name((i64)29,(struct qq_decls$strec *)(*a).def);
            }
            else {
                qq_lib$gerror((byte*)".$ name expected",0);
            }
;
        }
        break;
    case 49:;
        {
            qq_pcllib$genpc_name((i64)17,(struct qq_decls$strec *)(*p).def);
        }
        break;
    case 8:;
        {
            if (!!(a)) {
                L765 :;
                while ((!!(a) && !!((*a).nextunit))) {
                    qq_pclgen$evalunit(a,(i64)0);
                    a = (*a).nextunit;
L766 :;
                }
L767 :;
                ;
                if (!!(a)) {
                    qq_pclgen$evalunit(a,res);
                }
;
            }
            else {
            }
;
        }
        break;
    case 82:;
        {
            qq_pclgen$pushstring((*p).svalue,(i64)(*p).length);
            qq_pcllib$genpc((i64)88);
        }
        break;
    case 32:;
        {
            qq_pclgen$do_call(p,a,b,res,&procflag);
        }
        break;
    case 39:;
        {
            qq_pclgen$do_return(p,a);
        }
        break;
    case 33:;
        {
            qq_pclgen$do_callhost(p,a,res);
        }
        break;
    case 2:;
        {
            qq_pclgen$do_assign(a,b,res,(i64)0);
        }
        break;
    case 3:;
        {
            qq_pclgen$do_assign(a,b,res,(i64)1);
        }
        break;
    case 26:;
        {
            qq_pclgen$do_to(p,a,b);
        }
        break;
    case 9:;
        {
            qq_pclgen$do_if(p,a,b,(*b).nextunit,res);
        }
        break;
    case 17:;
    case 19:;
        {
            qq_pclgen$do_for(p,a,b);
        }
        break;
    case 18:;
    case 20:;
        {
            qq_pclgen$do_forx(p,a,b);
        }
        break;
    case 21:;
    case 22:;
        {
            qq_pclgen$do_forall(p,a,b);
        }
        break;
    case 23:;
        {
            qq_pclgen$do_forall(p,a,b);
        }
        break;
    case 27:;
        {
            qq_pclgen$do_while(p,a,b);
        }
        break;
    case 28:;
        {
            qq_pclgen$do_repeat(p,a,b);
        }
        break;
    case 37:;
        {
            if ((((i64)(*a).tag == (i64)47) && ((i64)(*(*a).def).nameid == (i64)15))) {
                d = (*a).def;
                if (((*d).labelno == (i64)0)) {
                    (*d).labelno = qq_pcllib$createfwdlabel();
                }
;
                qq_pcllib$genpc_lab((i64)39,(*d).labelno);
            }
            else {
                qq_pclgen$evalunit(a,(i64)1);
                qq_pcllib$genpc((i64)40);
            }
;
        }
        break;
    case 1:;
        {
            d = (*a).def;
            if (((*d).labelno == (i64)0)) {
                (*d).labelno = qq_pcllib$definelabel();
            }
            else {
                index = (*d).labelno;
                qq_pcllib$definefwdlabel(&index);
            }
;
        }
        break;
    case 63:;
        {
            qq_pclgen$do_exit(p,(i64)1);
        }
        break;
    case 64:;
        {
            qq_pclgen$do_exit(p,(i64)2);
        }
        break;
    case 65:;
        {
            qq_pclgen$do_exit(p,(i64)3);
        }
        break;
    case 24:;
    case 25:;
        {
            qq_pclgen$do_do(p,a);
        }
        break;
    case 12:;
    case 13:;
        {
            qq_pclgen$do_case(p,a,b,res);
        }
        break;
    case 14:;
    case 15:;
        {
            qq_pclgen$do_switch(p,a,b,res);
        }
        break;
    case 36:;
        {
            qq_pclgen$evalref(a);
            qq_pclgen$evalref(b);
            qq_pcllib$genpc((i64)37);
        }
        break;
    case 10:;
        {
            qq_pclgen$do_select(a,b,res);
        }
        break;
    case 70:;
    case 71:;
    case 74:;
        {
            qq_pclgen$do_print(p,a,b);
        }
        break;
    case 72:;
    case 73:;
    case 75:;
        {
            qq_pclgen$do_fprint(p,a,b,(*b).nextunit);
        }
        break;
    case 79:;
    case 80:;
        {
            qq_pclgen$do_read(p,a,b);
        }
        break;
    case 81:;
        {
            qq_pclgen$do_new(p);
        }
        break;
    case 38:;
        {
            if (!!(a)) {
                qq_pclgen$evalunit(a,(i64)1);
            }
            else {
                qq_pcllib$genpc_int((i64)18,(i64)0);
            }
;
            qq_pcllib$genpc((i64)77);
        }
        break;
    case 29:;
        {
            qq_pclgen$do_try(p,a,b);
        }
        break;
    case 40:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pcllib$genpc_int((i64)67,(-((qq_pclgen$nprocparams + (i64)2)) * (i64)16));
            qq_pcllib$genpc((i64)68);
        }
        break;
    case 165:;
        {
            qq_pclgen$do_andl(a,b);
        }
        break;
    case 166:;
        {
            qq_pclgen$do_orl(a,b);
        }
        break;
    case 197:;
        {
            qq_pclgen$do_pushlist(a,(i64)(*p).length);
            qq_pcllib$genpc_int2((i64)79,(i64)(*p).length,(i64)(*p).lower);
        }
        break;
    case 198:;
        {
            qq_pclgen$do_pushlist(a,(i64)(*p).length);
            qq_pcllib$genpc_int((i64)84,(i64)(*p).length);
        }
        break;
    case 199:;
        {
            qq_pclgen$do_makedict(a,(i64)(*p).length);
        }
        break;
    case 5:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$evalunit(b,(i64)1);
        }
        break;
    case 45:;
        {
            qq_pclgen$do_map(p,a,b);
        }
        break;
    case 149:;
    case 150:;
    case 151:;
    case 152:;
    case 155:;
    case 156:;
    case 157:;
    case 158:;
    case 159:;
    case 160:;
    case 161:;
    case 162:;
    case 163:;
    case 173:;
    case 174:;
    case 195:;
    case 196:;
    case 167:;
    case 168:;
    case 169:;
    case 170:;
    case 171:;
    case 172:;
    case 177:;
    case 175:;
    case 176:;
    case 146:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$evalunit(b,(i64)1);
            qq_pcllib$genpc((i64)qq_tables$jpclcodes[((i64)(*p).tag)]);
        }
        break;
    case 179:;
    case 180:;
    case 181:;
    case 182:;
    case 183:;
    case 186:;
    case 187:;
    case 188:;
    case 189:;
    case 190:;
    case 191:;
    case 192:;
    case 193:;
    case 194:;
    case 184:;
    case 185:;
        {
            qq_pclgen$evalref(a);
            qq_pclgen$evalunit(b,(i64)1);
            qq_pcllib$genpc((i64)qq_tables$jpclcodes[((i64)(*p).tag)]);
        }
        break;
    case 153:;
        {
            qq_pclgen$do_idiv(p,a,b);
        }
        break;
    case 154:;
        {
            qq_pclgen$do_irem(p,a,b);
        }
        break;
    case 89:;
    case 90:;
    case 119:;
    case 120:;
    case 118:;
    case 121:;
    case 91:;
    case 92:;
    case 141:;
    case 133:;
    case 134:;
    case 124:;
    case 145:;
    case 108:;
    case 144:;
    case 125:;
    case 123:;
    case 93:;
    case 97:;
    case 96:;
    case 138:;
    case 94:;
    case 95:;
    case 135:;
    case 143:;
    case 127:;
    case 128:;
    case 126:;
    case 140:;
    case 136:;
    case 139:;
    case 109:;
    case 110:;
    case 122:;
    case 137:;
    case 142:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 107:;
    case 104:;
    case 131:;
    case 132:;
    case 129:;
    case 147:;
    case 148:;
    case 130:;
        {
            qq_pclgen$do_unary(a,(i64)qq_tables$jpclcodes[((i64)(*p).tag)]);
        }
        break;
    case 114:;
    case 115:;
    case 117:;
    case 116:;
        {
            qq_pclgen$evalref(a);
            qq_pcllib$genpc((i64)qq_tables$jpclcodes[((i64)(*p).tag)]);
        }
        break;
    case 59:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pcllib$genpc_name((i64)209,(struct qq_decls$strec *)(*b).def);
        }
        break;
    case 60:;
        {
            qq_pclgen$do_bin(a,b,(i64)210);
        }
        break;
    case 61:;
        {
            qq_pclgen$do_bin(a,b,(i64)211);
        }
        break;
    case 62:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$evalunit(b,(i64)1);
            if (!!((*b).nextunit)) {
                qq_pclgen$evalunit((*b).nextunit,(i64)1);
            }
            else {
                qq_pcllib$genpc((i64)20);
            }
;
            qq_pcllib$genpc((i64)212);
        }
        break;
    case 66:;
        {
            qq_pclgen$do_unary(a,(i64)31);
        }
        break;
    case 68:;
        {
            if (((i64)(*a).tag == (i64)66)) {
                qq_pclgen$evalunit((*a).a,(i64)1);
            }
            else {
                qq_pclgen$evalref(a);
            }
;
        }
        break;
    case 67:;
        {
            qq_pclgen$evalref(a);
            qq_pcllib$genpc((i64)38);
        }
        break;
    case 43:;
        {
            qq_pclgen$do_convert(p);
        }
        break;
    case 44:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pcllib$genpc_int((i64)161,(i64)(*p).mode);
        }
        break;
    case 41:;
        {
            qq_pcllib$genpc_int((i64)28,(i64)(*p).mode);
        }
        break;
    case 7:;
        {
            qq_pcllib$genpc_int((i64)30,(*p).pclopcode);
        }
        break;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
        {
            qq_pclgen$do_incr(p,a,res);
        }
        break;
    case 34:;
        {
            qq_pcllib$genpc((i64)21);
        }
        break;
    case 31:;
        {
            qq_pclgen$do_unary(a,(i64)223);
        }
        break;
    case 6:;
        {
        }
        break;
    case 69:;
        {
            qq_pcllib$genpc((i64)20);
        }
        break;
    default: {
        qq_lib$gerror_s((byte*)"UNSUPPORTED TAG:",qq_tables$jtagnames[((i64)(*p).tag)],p);
    }
    } //SW
;
        {i64 $temp = (i64)qq_tables$jhasvalue[((i64)(*p).tag)];
if (($temp==(i64)0)) {
        if (!!(res)) {
            qq_lib$gerror_s((byte*)"Value expected:",qq_tables$jtagnames[((i64)(*p).tag)],0);
        }
;
    }
    else if (($temp==(i64)1)) {
        if (!(!!(res))) {
            if ((((i64)(*p).tag == (i64)32) && (procflag == (i64)1))) {
            }
            else if (((i64)(*p).tag == (i64)85 || (i64)(*p).tag == (i64)86 || (i64)(*p).tag == (i64)87 || (i64)(*p).tag == (i64)88)) {
            }
            else if ((((i64)(*p).tag == (i64)33) && ((i64)qq_tables$hostisfn[((*p).index)] == (i64)0))) {
            }
            else {
                qq_pcllib$genpc_int((i64)75,(i64)1);
            }
;
        }
;
    }
    };
}

void qq_pclgen$gencodemodule(i64 n) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
        i64 lab;
        i64 i;
    qq_decls$currmodule = (struct qq_decls$modulerec *)&qq_decls$moduletable[(n)];
    qq_decls$stcurrproc = (qq_decls$stcurrmodule = (*qq_decls$currmodule).def);
    qq_pcllib$resetpcl(qq_decls$sourcefilesizes[((i64)qq_decls$moduletable[(n)].fileno)-1]);
    qq_pcllib$gencomment((byte*)"Module data init code:");
    if ((n == (i64)1)) {
        lab = qq_pcllib$createfwdlabel();
        qq_pcllib$genpc_lab((i64)39,lab);
        qq_pcllib$genpc((i64)78);
        qq_decls$stopseq = qq_pcllib$pcllast;
        qq_decls$raiseseq = (qq_pcllib$pcllast + (i64)1);
        qq_pcllib$genpc_int((i64)18,(i64)0);
        qq_pcllib$genpc((i64)223);
        qq_pcllib$definefwdlabel(&lab);
    }
;
    d = (*qq_decls$stcurrmodule).deflist;
    L768 :;
    while (!!(d)) {
        if ((((i64)(*d).nameid == (i64)11) && !!((*d).code))) {
            qq_pclgen$evalunit((*d).code,(i64)1);
            if (((i64)msysc$m_getdotslice((i64)(*d).flags,(i64)11,(i64)12) == (i64)3)) {
                qq_pcllib$genpc((i64)36);
            }
;
            qq_pcllib$genpc_name((i64)33,(struct qq_decls$strec *)d);
        }
        else if (((i64)(*d).nameid == (i64)5)) {
            e = (*d).deflist;
            L771 :;
            while (!!(e)) {
                if ((((i64)(*e).nameid == (i64)11) && !!((*e).code))) {
                    qq_pclgen$evalunit((*e).code,(i64)1);
                    qq_pcllib$genpc_name((i64)33,(struct qq_decls$strec *)e);
                }
;
                e = (*e).nextdef;
L772 :;
            }
L773 :;
            ;
        }
;
        d = (*d).nextdef;
L769 :;
    }
L770 :;
    ;
    if ((n == qq_decls$mainmoduleno)) {
        for (i=qq_decls$nmodules;i>=(i64)1;--i) {
L774 :;
            if ((i != qq_decls$mainmoduleno)) {
                qq_pcllib$genpc_name((i64)69,(struct qq_decls$strec *)qq_decls$moduletable[(i)].def);
            }
;
L775 :;
        }
L776 :;
        ;
        for (i=qq_decls$nmodules;i>=(i64)1;--i) {
L777 :;
            if ((i != qq_decls$mainmoduleno)) {
                if (!!(qq_decls$moduletable[(i)].startfn)) {
                    qq_pcllib$genpc_name((i64)63,(struct qq_decls$strec *)qq_decls$moduletable[(i)].startfn);
                    qq_pcllib$genopnd_int((i64)0);
                }
;
            }
;
L778 :;
        }
L779 :;
        ;
        if (!!((*qq_decls$currmodule).startfn)) {
            qq_pcllib$genpc_name((i64)63,(struct qq_decls$strec *)(*qq_decls$currmodule).startfn);
            qq_pcllib$genopnd_int((i64)0);
        }
;
        if (!!((*qq_decls$currmodule).mainfn)) {
            qq_pcllib$genpc_name((i64)63,(struct qq_decls$strec *)(*qq_decls$currmodule).mainfn);
            qq_pcllib$genopnd_int((i64)0);
        }
;
        qq_pclgen$evalunit((*qq_decls$stcurrmodule).code,(i64)0);
        qq_pcllib$genpc_int((i64)18,(i64)0);
        qq_pcllib$genpc((i64)77);
    }
    else {
        qq_pclgen$evalunit((*qq_decls$stcurrmodule).code,(i64)0);
        qq_pcllib$genpc((i64)70);
    }
;
    qq_pcllib$gencomment((byte*)"Procs:");
    d = (*qq_decls$stcurrmodule).deflist;
    L780 :;
    while (!!(d)) {
        switch ((i64)(*d).nameid) {
        case 5:;
            {
                qq_pclgen$do_procdef(d);
            }
            break;
        case 11:;
            {
            }
            break;
        case 7:;
            {
                e = (*d).deflist;
                L783 :;
                while (!!(e)) {
                    if (((i64)(*e).nameid == (i64)5)) {
                        qq_pclgen$do_procdef(e);
                    }
;
L784 :;
                    e = (*e).nextdef;
L786 :;
                                    }
L785 :;
                ;
            }
            break;
        case 16:;
            {
            }
            break;
        case 17:;
            {
            }
            break;
        case 15:;
            {
            }
            break;
        case 8:;
            {
            }
            break;
        case 6:;
            {
            }
            break;
        case 18:;
            {
            }
            break;
        case 20:;
            {
            }
            break;
        default: {
            qq_lib$gerror_s((byte*)"?Module def:",qq_tables$namenames[((i64)(*d).nameid)],0);
        }
        } //SW
;
        d = (*d).nextdef;
L781 :;
    }
L782 :;
    ;
    qq_pcllib$genpc((i64)6);
    qq_pcllib$genpc((i64)6);
    qq_pcllib$genpc((i64)6);
    qq_decls$moduletable[(n)].pcstart = qq_pcllib$pclstart;
    qq_decls$moduletable[(n)].pcend = qq_pcllib$pclend;
    qq_decls$moduletable[(n)].pcsize = (qq_pcllib$pclend - qq_pcllib$pclstart);
    qq_decls$moduletable[(n)].pcsrcstart = qq_pcllib$pclsrcstart;
}

static void qq_pclgen$do_procdef(struct qq_decls$strec *p) {
        i64 nfreevars;
        i64 nnofreevars;
        i64 isfunc;
        struct qq_decls$strec *  oldcurrproc;
    oldcurrproc = qq_decls$stcurrproc;
    qq_decls$stcurrproc = p;
    qq_pclgen$retindex = qq_pcllib$createfwdlabel();
    isfunc = (i64)msysc$m_getdotindex((i64)(*p).flags,(i64)4);
    qq_pclgen$genprocentry(p,&nfreevars,&nnofreevars);
    if (((*p).code == 0)) {
        qq_lib$gerror_s((byte*)"Empty proc body",(*p).name,0);
    }
    else {
        qq_pclgen$evalunit((*p).code,isfunc);
    }
;
    qq_pcllib$definefwdlabel(&qq_pclgen$retindex);
    qq_pclgen$genprocexit(nfreevars,nnofreevars,isfunc);
    qq_pcllib$genpc((i64)5);
    if (((*qq_pclgen$pproclocals) == (i64)0)) {
        (*p).labelno = qq_pclgen$procskiplabel;
    }
;
    qq_decls$stcurrproc = oldcurrproc;
}

static void qq_pclgen$genprocentry(struct qq_decls$strec *p,i64 *nfreevars,i64 *nnofreevars) {
        i64 n;
        struct qq_decls$strec *  d;
    qq_pcllib$genpc_name((i64)3,(struct qq_decls$strec *)p);
    qq_pclgen$nprocparams = (qq_pclgen$nproclocals = (i64)0);
    d = (*p).deflist;
    L787 :;
    while (!!(d)) {
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)12)) {
            ++(qq_pclgen$nproclocals);
            (*d).index = qq_pclgen$nproclocals;
        }
        else if (($temp==(i64)13)) {
            ++(qq_pclgen$nprocparams);
        }
        };
        d = (*d).nextdef;
L788 :;
    }
L789 :;
    ;
    d = (*p).deflist;
    n = qq_pclgen$nprocparams;
    L790 :;
    while (!!(d)) {
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)13)) {
            --(n);
            (*d).index = -((n + (i64)1));
        }
        };
L791 :;
        d = (*d).nextdef;
L793 :;
            }
L792 :;
    ;
    qq_pclgen$retvaloffset = -((qq_pclgen$nprocparams + (i64)1));
    (*p).labelno = qq_pcllib$definelabel();
    qq_pcllib$genpc_int((i64)4,qq_pclgen$nproclocals);
    qq_pclgen$procskiplabel = qq_pcllib$definelabel();
    qq_pclgen$pproclocals = (qq_pcllib$pclnext - (i64)1);
    d = (*p).deflist;
    L794 :;
    while (!!(d)) {
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)12)) {
            if (!!((*d).code)) {
                qq_pclgen$evalunit((*d).code,(i64)1);
                if (((i64)msysc$m_getdotslice((i64)(*d).flags,(i64)11,(i64)12) == (i64)3)) {
                    qq_pcllib$genpc((i64)36);
                }
;
                qq_pcllib$genpc_name((i64)34,(struct qq_decls$strec *)d);
            }
;
        }
        };
        d = (*d).nextdef;
L795 :;
    }
L796 :;
    ;
}

static void qq_pclgen$genprocexit(i64 nfree,i64 nnofree,i64 isfunc) {
        i64 offset;
    if (!!(isfunc)) {
        offset = (-((qq_pclgen$nprocparams + (i64)1)) * (i64)16);
        qq_pcllib$genpc_int((i64)67,offset);
    }
;
    if (!!(qq_pclgen$nproclocals)) {
        qq_pcllib$genpc_int((i64)75,qq_pclgen$nproclocals);
    }
;
    if ((qq_pclgen$nprocparams == (i64)0)) {
        qq_pcllib$genpc((i64)65);
    }
    else {
        qq_pcllib$genpc_int((i64)66,qq_pclgen$nprocparams);
    }
;
}

static void qq_pclgen$evalref(struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  a;
        struct qq_decls$unitrec *  b;
        struct qq_decls$strec *  d;
        i64 lab1;
        i64 lab2;
    a = (*p).a;
    b = (*p).b;
    switch ((i64)(*p).tag) {
    case 47:;
        {
            d = (*p).def;
            if (((i64)(*d).nameid == (i64)5 || (i64)(*d).nameid == (i64)6)) {
                qq_lib$gerror((byte*)"^ not allowed",0);
            }
;
            if ((((i64)(*d).nameid == (i64)13) && !!(msysc$m_getdotindex((i64)(*d).flags,(i64)5)))) {
                qq_pcllib$genpc_name((i64)10,(struct qq_decls$strec *)d);
            }
            else {
                qq_pcllib$genpc_name(((i64)11 + (i64)msysc$m_getdotindex((i64)(*d).flags,(i64)9)),(struct qq_decls$strec *)d);
            }
;
        }
        break;
    case 59:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pcllib$genpc_name((i64)213,(struct qq_decls$strec *)(*b).def);
        }
        break;
    case 60:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$evalunit(b,(i64)1);
            qq_pcllib$genpc((i64)214);
        }
        break;
    case 61:;
        {
            qq_pclgen$evalref(a);
            qq_pclgen$evalunit(b,(i64)1);
            qq_pcllib$genpc((i64)215);
        }
        break;
    case 62:;
        {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$evalunit(b,(i64)1);
            if (!!((*b).nextunit)) {
                qq_lib$gerror((byte*)"Def val not allowed",0);
            }
;
            qq_pcllib$genpc((i64)216);
        }
        break;
    case 66:;
        {
            qq_pclgen$evalunit(a,(i64)1);
        }
        break;
    case 9:;
        {
            lab1 = qq_pcllib$createfwdlabel();
            lab2 = qq_pcllib$createfwdlabel();
            qq_pclgen$genjumpcond((i64)0,(*p).a,lab1);
            qq_pclgen$evalref((*p).b);
            qq_pclgen$genjumpl(lab2);
            qq_pcllib$definefwdlabel(&lab1);
            qq_pclgen$evalref((*(*p).b).nextunit);
            qq_pcllib$definefwdlabel(&lab2);
        }
        break;
    default: {
        qq_lib$gerror_s((byte*)"evalref",qq_tables$jtagnames[((i64)(*p).tag)],0);
    }
    } //SW
;
}

static void qq_pclgen$genjumpcond(i64 opc,struct qq_decls$unitrec *p,i64 lab) {
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
        i64 oldpos;
        i64 lab2;
        i64 i;
    q = (*p).a;
    r = (*p).b;
    switch ((i64)(*p).tag) {
    case 165:;
        {
            if ((opc==(i64)0)) {
                qq_pclgen$genjumpcond((i64)0,q,lab);
                qq_pclgen$genjumpcond((i64)0,r,lab);
            }
            else if ((opc==(i64)1)) {
                lab2 = qq_pcllib$createfwdlabel();
                qq_pclgen$genjumpcond((i64)0,q,lab2);
                qq_pclgen$genjumpcond((i64)1,r,lab);
                qq_pcllib$definefwdlabel(&lab2);
            }
;
        }
        break;
    case 166:;
        {
            if ((opc==(i64)0)) {
                lab2 = qq_pcllib$createfwdlabel();
                qq_pclgen$genjumpcond((i64)1,q,lab2);
                qq_pclgen$genjumpcond((i64)0,r,lab);
                qq_pcllib$definefwdlabel(&lab2);
            }
            else if ((opc==(i64)1)) {
                qq_pclgen$genjumpcond((i64)1,q,lab);
                qq_pclgen$genjumpcond((i64)1,r,lab);
            }
;
        }
        break;
    case 91:;
        {
            if ((opc==(i64)0)) {
                qq_pclgen$genjumpcond((i64)1,q,lab);
            }
            else if ((opc==(i64)1)) {
                qq_pclgen$genjumpcond((i64)0,q,lab);
            }
;
        }
        break;
    case 93:;
        {
            qq_pclgen$genjumpcond(opc,q,lab);
        }
        break;
    case 8:;
        {
            L797 :;
            while ((!!(q) && !!((*q).nextunit))) {
                qq_pclgen$evalunit(q,(i64)1);
                q = (*q).nextunit;
L798 :;
            }
L799 :;
            ;
            qq_pclgen$genjumpcond(opc,q,lab);
        }
        break;
    case 167:;
    case 168:;
    case 169:;
    case 170:;
    case 171:;
    case 172:;
        {
            qq_pclgen$evalunit(q,(i64)1);
            qq_pclgen$evalunit(r,(i64)1);
            qq_pclgen$gcomparejump(opc,(i64)(*p).tag,lab);
        }
        break;
    case 46:;
        {
            r = (*q).nextunit;
            i = (i64)1;
            if ((opc == (i64)0)) {
                L800 :;
                while (!!(r)) {
                    qq_pclgen$evalunit(q,(i64)1);
                    qq_pclgen$evalunit(r,(i64)1);
                    qq_pclgen$gcomparejump((i64)1,qq_pclgen$reversecond((i64)(*p).cmpgenop[(i)-1]),lab);
                    ++(i);
                    q = r;
                    r = (*r).nextunit;
L801 :;
                }
L802 :;
                ;
            }
            else {
                lab2 = qq_pcllib$createfwdlabel();
                L803 :;
                while (!!(r)) {
                    qq_pclgen$evalunit(q,(i64)1);
                    qq_pclgen$evalunit(r,(i64)1);
                    if (!!((*r).nextunit)) {
                        qq_pclgen$gcomparejump((i64)1,qq_pclgen$reversecond((i64)(*p).cmpgenop[(i)-1]),lab2);
                    }
                    else {
                        qq_pclgen$gcomparejump((i64)1,(i64)(*p).cmpgenop[(i)-1],lab);
                    }
;
                    ++(i);
                    q = r;
                    r = (*r).nextunit;
L804 :;
                }
L805 :;
                ;
                qq_pcllib$definefwdlabel(&lab2);
            }
;
        }
        break;
    default: {
        qq_pclgen$evalunit(p,(i64)1);
        qq_pcllib$genpc_lab(((opc == (i64)1) ? (i64)41 : (i64)42),lab);
    }
    } //SW
;
    qq_decls$qpos = oldpos;
}

static void qq_pclgen$gcomparejump(i64 jumpopc,i64 cond,i64 lab) {
        i64 opc;
    if ((jumpopc == (i64)0)) {
        cond = qq_pclgen$reversecond(cond);
    }
;
    if ((cond==(i64)167)) {
        opc = (i64)43;
    }
    else if ((cond==(i64)168)) {
        opc = (i64)44;
    }
    else if ((cond==(i64)169)) {
        opc = (i64)45;
    }
    else if ((cond==(i64)170)) {
        opc = (i64)46;
    }
    else if ((cond==(i64)171)) {
        opc = (i64)47;
    }
    else if ((cond==(i64)172)) {
        opc = (i64)48;
    }
    else {
        qq_lib$gerror((byte*)"GCOMP: no cond",0);
    }
;
    qq_pcllib$genpc_lab(opc,lab);
}

static void qq_pclgen$genjumpl(i64 lab) {
    qq_pcllib$genpc_lab((i64)39,lab);
}

static i64 qq_pclgen$reversecond(i64 op) {
    if ((op==(i64)167)) {
        return (i64)168;
    }
    else if ((op==(i64)168)) {
        return (i64)167;
    }
    else if ((op==(i64)169)) {
        return (i64)171;
    }
    else if ((op==(i64)170)) {
        return (i64)172;
    }
    else if ((op==(i64)171)) {
        return (i64)169;
    }
    else if ((op==(i64)172)) {
        return (i64)170;
    }
;
    return (i64)0;
}

void qq_pclgen$stacklooplabels(i64 *a,i64 *b,i64 *c) {
    if ((qq_pclgen$loopindex >= (i64)20)) {
        qq_lib$gerror((byte*)"Too many nested loops",0);
    }
;
    ++(qq_pclgen$loopindex);
    qq_pclgen$loopstack[(qq_pclgen$loopindex)-1][((i64)1)-1] = a;
    qq_pclgen$loopstack[(qq_pclgen$loopindex)-1][((i64)2)-1] = b;
    qq_pclgen$loopstack[(qq_pclgen$loopindex)-1][((i64)3)-1] = c;
}

void qq_pclgen$unstacklooplabels(void) {
    --(qq_pclgen$loopindex);
}

i64 qq_pclgen$findlooplabel(i64 k,i64 n) {
        i64 i;
    if ((n == (i64)0)) {
        i = (i64)1;
    }
    else {
        i = (qq_pclgen$loopindex - (n - (i64)1));
    }
;
    if (((i < (i64)1) || (i > qq_pclgen$loopindex))) {
        qq_lib$gerror((byte*)"Bad loop index",0);
    }
;
    qq_pclgen$looptrylevel = qq_pclgen$trylevelstack[(i)-1];
    return (*qq_pclgen$loopstack[(i)-1][(k)-1]);
}

static void qq_pclgen$do_assign(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 res,i64 deepcopy) {
    if (((i64)(*a).tag==(i64)(*b).tag && (i64)(*b).tag==(i64)197)) {
        if (!!(res)) {
            qq_lib$gerror((byte*)"mult/ass::=",0);
        }
;
        qq_pclgen$do_multassign(a,b,deepcopy,res);
        return;
    }
;
    qq_pclgen$evalunit(b,(i64)1);
    if (!!(deepcopy)) {
        qq_pcllib$genpc((i64)36);
    }
;
    qq_pclgen$do_store(a,res);
}

static void qq_pclgen$do_bin(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 opc) {
    qq_pclgen$evalunit(a,(i64)1);
    qq_pclgen$evalunit(b,(i64)1);
    qq_pcllib$genpc(opc);
}

static void qq_pclgen$do_binref(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 opc) {
    qq_pclgen$evalref(a);
    qq_pclgen$evalunit(b,(i64)1);
    qq_pcllib$genpc(opc);
}

static void qq_pclgen$do_unary(struct qq_decls$unitrec *a,i64 opc) {
    qq_pclgen$evalunit(a,(i64)1);
    qq_pcllib$genpc(opc);
}

static void qq_pclgen$do_unaryref(struct qq_decls$unitrec *a,i64 opc) {
    qq_pclgen$evalref(a);
    qq_pcllib$genpc(opc);
}

static void qq_pclgen$do_pushlist(struct qq_decls$unitrec *a,i64 n) {
    L806 :;
    while (!!(a)) {
        qq_pclgen$evalunit(a,(i64)1);
L807 :;
        a = (*a).nextunit;
L809 :;
            }
L808 :;
    ;
}

static void qq_pclgen$do_makedict(struct qq_decls$unitrec *a,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L810 :;
        if (((i64)(*a).tag == (i64)5)) {
            qq_pclgen$evalunit((*a).a,(i64)1);
            qq_pclgen$evalunit((*a).b,(i64)1);
        }
        else {
            qq_lib$gerror((byte*)"dict not key:val",0);
        }
;
        a = (*a).nextunit;
L811 :;
    }
L812 :;
    ;
    qq_pcllib$genpc_int((i64)87,n);
}

static void qq_pclgen$do_call(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 res,i64 *procflag) {
        i64 nargs;
        i64 nsimple;
        i64 isfunc;
        i64 kwdindex;
        struct qq_decls$strec *  d;
        struct qq_decls$unitrec *  c;
        struct qq_decls$unitrec *  arglist[100];
        i64 i;
    isfunc = (i64)1;
    nargs = (nsimple = (i64)0);
    kwdindex = (i64)0;
    c = b;
    L813 :;
    while (!!(c)) {
        arglist[(++(nargs))-1] = c;
        if (((i64)(*c).tag == (i64)50 || (i64)(*c).tag == (i64)54)) {
            ++(nsimple);
        }
;
        if (((i64)(*c).tag == (i64)4)) {
            if ((kwdindex == (i64)0)) {
                kwdindex = nargs;
            }
;
        }
        else if (!!(kwdindex)) {
            qq_lib$gerror((byte*)"Non-kwd follows kwd arg",0);
        }
;
        c = (*c).nextunit;
L814 :;
    }
L815 :;
    ;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)47)) {
        d = (*a).def;
        //retry:
L816 :;
;
                {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)5)) {
            if (!!(msysc$m_getdotindex((i64)(*d).flags,(i64)4))) {
                qq_pcllib$genpc((i64)20);
                nargs = qq_pclgen$pushparams(d,&arglist,nargs,kwdindex);
                qq_pcllib$genpc_name((i64)63,(struct qq_decls$strec *)d);
            }
            else {
                isfunc = (i64)0;
                nargs = qq_pclgen$pushparams(d,&arglist,nargs,kwdindex);
                qq_pcllib$genpc_name((i64)63,(struct qq_decls$strec *)d);
            }
;
            qq_pcllib$genopnd_int(nargs);
        }
        else if (($temp==(i64)6)) {
            if (!(!!(msysc$m_getdotindex((i64)(*d).flags,(i64)4)))) {
                isfunc = (i64)0;
            }
            else {
                qq_pcllib$genpc((i64)20);
            }
;
            nargs = qq_pclgen$pushparams(d,&arglist,nargs,kwdindex);
            qq_pcllib$genpc_name((i64)71,(struct qq_decls$strec *)d);
            qq_pcllib$genopnd_int(nargs);
        }
        else if (($temp==(i64)18)) {
            d = (*d).alias;
            goto L816 ;
;
        }
        else if (($temp==(i64)11) || ($temp==(i64)12) || ($temp==(i64)13)) {
            goto L817 ;
;
        }
        else {
            qq_lib$gerror_s((byte*)"CAN'T CALL:",qq_tables$namenames[((i64)(*d).nameid)],0);
        }
        };
    }
    else if (($temp==(i64)59)) {
        if (!!(kwdindex)) {
            goto L817 ;
;
        }
;
        qq_pcllib$genpc((i64)20);
        qq_pclgen$evalref((*a).a);
        for (i=(i64)1;i<=nargs;++i) {
L818 :;
            qq_pclgen$evalunit(arglist[(i)-1],(i64)1);
L819 :;
        }
L820 :;
        ;
        qq_pclgen$evalunit(a,(i64)1);
        qq_pcllib$genpc((i64)64);
        ++(nargs);
        qq_pcllib$genopnd_int(nargs);
        qq_pcllib$genopnd_int((i64)0);
    }
    else {
        //docallptr:
L817 :;
;
        if (!!(kwdindex)) {
            qq_lib$gerror((byte*)"Kwd params not allowed for fnptr",0);
        }
;
        qq_pcllib$genpc((i64)20);
        for (i=(i64)1;i<=nargs;++i) {
L821 :;
            qq_pclgen$evalunit(arglist[(i)-1],(i64)1);
L822 :;
        }
L823 :;
        ;
        qq_pclgen$evalunit(a,(i64)1);
        qq_pcllib$genpc((i64)64);
        qq_pcllib$genopnd_int(nargs);
        qq_pcllib$genopnd_int((i64)0);
    }
    };
    if ((!!(res) && !(!!(isfunc)))) {
        qq_lib$gerror((byte*)"Func ret value expected",0);
    }
;
    (*procflag) = (i64)!(!!(isfunc));
}

static i64 qq_pclgen$pushparams(struct qq_decls$strec *d,struct qq_decls$unitrec *(*arglist)[],i64 nargs,i64 kwdindex) {
        i64 nparams;
        i64 extra;
        i64 n;
        struct qq_decls$strec *  paramlist[100];
        byte byreflist[100];
        struct qq_decls$strec *  e;
        struct qq_decls$strec *  p;
        i64 i;
    nparams = (i64)(*d).nparams;
    e = (*d).deflist;
    n = (i64)0;
    L824 :;
    while (!!(e)) {
        ++(n);
        paramlist[(n)-1] = e;
        byreflist[(n)-1] = (i64)msysc$m_getdotindex((i64)(*e).flags,(i64)5);
        e = (*e).nextdef;
L825 :;
    }
L826 :;
    ;
    if (!!(kwdindex)) {
        qq_pclgen$pushkwdparams(d,arglist,nargs,kwdindex);
        return (i64)(*d).nparams;
    }
;
    extra = (i64)0;
    if ((nargs == nparams)) {
        for (i=(i64)1;i<=nargs;++i) {
L827 :;
            qq_pclgen$evalparam((*arglist)[(i)-1],(i64)byreflist[(i)-1]);
L828 :;
        }
L829 :;
        ;
        return nargs;
    }
    else if ((nargs < nparams)) {
        for (i=(i64)1;i<=nargs;++i) {
L830 :;
            qq_pclgen$evalparam((*arglist)[(i)-1],(i64)byreflist[(i)-1]);
L831 :;
        }
L832 :;
        ;
        for (i=(nargs + (i64)1);i<=nparams;++i) {
L833 :;
            p = paramlist[(i)-1];
            if ((!(!!((*p).code)) && !(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)7))))) {
                qq_lib$gerror_s((byte*)"Param not optional:",msysc$strint(i,0),0);
            }
;
            if (!!((*p).code)) {
                if (!!((i64)byreflist[(i)-1])) {
                    qq_lib$gerror((byte*)"byref with default val",0);
                }
;
                qq_pclgen$evalunit((*p).code,(i64)1);
            }
            else {
                qq_pcllib$genpc((i64)20);
            }
;
L834 :;
        }
L835 :;
        ;
        return nparams;
    }
    else {
        for (i=(i64)1;i<=nparams;++i) {
L836 :;
            qq_pclgen$evalparam((*arglist)[(i)-1],(i64)byreflist[(i)-1]);
L837 :;
        }
L838 :;
        ;
        if (!(!!(msysc$m_getdotindex((i64)(*d).flags,(i64)8)))) {
            qq_lib$gerror((byte*)"Too many args",0);
        }
;
        for (i=(nparams + (i64)1);i<=nargs;++i) {
L839 :;
            qq_pclgen$evalunit((*arglist)[(i)-1],(i64)1);
L840 :;
        }
L841 :;
        ;
        return nargs;
    }
;
}

static void qq_pclgen$evalparam(struct qq_decls$unitrec *a,i64 byref) {
    if (!!(byref)) {
        qq_pclgen$evalref(a);
    }
    else {
        qq_pclgen$evalunit(a,(i64)1);
    }
;
}

static void qq_pclgen$pushkwdparams(struct qq_decls$strec *d,struct qq_decls$unitrec *(*arglist)[],i64 nargs,i64 kwdindex) {
        i64 nparams;
        i64 i;
        i64 j;
        i64 k;
        struct qq_decls$strec *  paramlist[100];
        byte byreflist[100];
        struct qq_decls$unitrec *  keyunits[100];
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
        struct qq_decls$strec *  e;
        i64 $av_1;
    nparams = (i64)(*d).nparams;
    e = (*d).deflist;
    for (i=(i64)1;i<=nparams;++i) {
L842 :;
        paramlist[(i)-1] = e;
        byreflist[(i)-1] = (i64)msysc$m_getdotindex((i64)(*e).flags,(i64)5);
        e = (*e).nextdef;
L843 :;
    }
L844 :;
    ;
    if ((nargs > nparams)) {
        qq_lib$gerror((byte*)"Too many args",0);
    }
;
    for (i=kwdindex;i<=nparams;++i) {
L845 :;
        keyunits[(i)-1] = 0;
L846 :;
    }
L847 :;
    ;
        ($av_1 = (kwdindex - (i64)1));
    for (i=(i64)1;i<=$av_1;++i) {
L848 :;
        qq_pclgen$evalparam((*arglist)[(i)-1],(i64)byreflist[(i)-1]);
L849 :;
    }
L850 :;
    ;
    for (i=kwdindex;i<=nargs;++i) {
L851 :;
        p = (*arglist)[(i)-1];
        q = (*p).a;
        if (((i64)(*q).tag != (i64)47)) {
            qq_lib$gerror((byte*)"kwd not a name",0);
        }
;
        e = (*q).def;
        k = (i64)0;
        for (j=(i64)1;j<=nparams;++j) {
L854 :;
            if (!!(mlib$eqstring((*e).name,(*paramlist[(j)-1]).name))) {
                k = j;
                goto L856 ;
            }
;
L855 :;
        }
L856 :;
        ;
        if ((k == (i64)0)) {
            qq_lib$gerror_s((byte*)"Can't find kwd param:",(*e).name,0);
        }
;
        if ((k < kwdindex)) {
            qq_lib$gerror_s((byte*)"Kwd arg already positional:",(*e).name,0);
        }
;
        if (!!(keyunits[(k)-1])) {
            qq_lib$gerror_s((byte*)"Repeating kwd arg:",(*e).name,0);
        }
;
        keyunits[(k)-1] = (*p).b;
L852 :;
    }
L853 :;
    ;
    for (i=kwdindex;i<=nparams;++i) {
L857 :;
        if ((keyunits[(i)-1] == 0)) {
            q = (*paramlist[(i)-1]).code;
            if (((q == 0) && !(!!(msysc$m_getdotindex((i64)(*paramlist[(i)-1]).flags,(i64)7))))) {
                qq_lib$gerror_s((byte*)"Param not optional:",msysc$strint(i,0),0);
            }
;
            keyunits[(i)-1] = q;
        }
;
L858 :;
    }
L859 :;
    ;
    for (i=kwdindex;i<=nparams;++i) {
L860 :;
        if (!!(keyunits[(i)-1])) {
            qq_pclgen$evalparam(keyunits[(i)-1],(i64)byreflist[(i)-1]);
        }
        else if (!!((i64)byreflist[(i)-1])) {
            qq_lib$gerror((byte*)"byref param not optional",0);
        }
        else {
            qq_pcllib$genpc((i64)20);
        }
;
L861 :;
    }
L862 :;
    ;
}

static void qq_pclgen$do_if(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,struct qq_decls$unitrec *pelse,i64 res) {
        i64 lab1;
        i64 lab2;
    lab1 = qq_pcllib$createfwdlabel();
    if ((!!(pelse) || !!(res))) {
        lab2 = qq_pcllib$createfwdlabel();
    }
;
    qq_pclgen$genjumpcond((i64)0,a,lab1);
    qq_pclgen$evalunit(b,res);
    if ((!!(pelse) || !!(res))) {
        qq_pclgen$genjumpl(lab2);
        qq_pcllib$definefwdlabel(&lab1);
        if (!!(pelse)) {
            qq_pclgen$evalunit(pelse,res);
        }
        else {
            qq_pcllib$genpc((i64)20);
        }
;
        qq_pcllib$definefwdlabel(&lab2);
    }
    else {
        qq_pcllib$definefwdlabel(&lab1);
    }
;
}

static void qq_pclgen$do_do(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a) {
        i64 lab_abc;
        i64 lab_d;
    lab_abc = qq_pcllib$definelabel();
    lab_d = qq_pcllib$createfwdlabel();
    qq_pclgen$stacklooplabels(&lab_abc,&lab_abc,&lab_d);
    qq_pclgen$evalunit(a,(i64)0);
    if (((i64)(*p).tag == (i64)24)) {
        qq_pclgen$genjumpl(lab_abc);
    }
;
    qq_pcllib$definefwdlabel(&lab_d);
    qq_pclgen$unstacklooplabels();
}

static void qq_pclgen$do_exit(struct qq_decls$unitrec *p,i64 k) {
        i64 n;
        i64 index;
    index = (*(*p).a).value;
    if ((index == (i64)0)) {
        index = qq_pclgen$loopindex;
    }
;
    n = qq_pclgen$findlooplabel(k,index);
    if ((n == (i64)0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"BAD LOOP",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else {
        qq_pclgen$genjumpl(n);
    }
;
}

static void qq_pclgen$do_to(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pcount,struct qq_decls$unitrec *pbody) {
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        struct qq_decls$strec *  temp;
        struct qq_decls$unitrec *  pav;
    pav = (*pcount).nextunit;
    temp = (*pav).def;
    qq_pclgen$evalunit(pcount,(i64)1);
    qq_pcllib$genpc_name(((i64)33 + (i64)msysc$m_getdotindex((i64)(*temp).flags,(i64)9)),(struct qq_decls$strec *)temp);
    lab_b = qq_pcllib$createfwdlabel();
    lab_c = qq_pcllib$createfwdlabel();
    lab_d = qq_pcllib$createfwdlabel();
    qq_pclgen$stacklooplabels(&lab_b,&lab_c,&lab_d);
    if (((i64)(*pcount).tag != (i64)50)) {
        qq_pcllib$genpc_name(((i64)9 + (i64)msysc$m_getdotindex((i64)(*temp).flags,(i64)9)),(struct qq_decls$strec *)temp);
        qq_pcllib$genpc_int((i64)18,(i64)0);
        qq_pcllib$genpc_lab((i64)46,lab_d);
    }
    else if (((*pcount).value <= (i64)0)) {
        qq_pcllib$genpc_lab((i64)39,lab_d);
    }
;
    qq_pcllib$definefwdlabel(&lab_b);
    qq_pclgen$evalunit(pbody,(i64)0);
    qq_pcllib$definefwdlabel(&lab_c);
    qq_pcllib$genpc_lab(((i64)53 + (i64)msysc$m_getdotindex((i64)(*temp).flags,(i64)9)),lab_b);
    qq_pcllib$genopnd_name((struct qq_decls$strec *)temp);
    qq_pcllib$definefwdlabel(&lab_d);
    qq_pclgen$unstacklooplabels();
}

static void qq_pclgen$do_while(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pcond,struct qq_decls$unitrec *pbody) {
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        i64 lab_incr;
        struct qq_decls$unitrec *  pincr;
    pincr = (*pcond).nextunit;
    lab_b = qq_pcllib$createfwdlabel();
    lab_c = qq_pcllib$createfwdlabel();
    lab_d = qq_pcllib$createfwdlabel();
    if (!!(pincr)) {
        lab_incr = qq_pcllib$createfwdlabel();
    }
    else {
        lab_incr = lab_c;
    }
;
    qq_pclgen$stacklooplabels(&lab_b,&lab_c,&lab_d);
    qq_pclgen$genjumpl(lab_incr);
    qq_pcllib$definefwdlabel(&lab_b);
    qq_pclgen$evalunit(pbody,(i64)0);
    qq_pcllib$definefwdlabel(&lab_c);
    if (!!(pincr)) {
        qq_pclgen$evalunit(pincr,(i64)1);
        qq_pcllib$definefwdlabel(&lab_incr);
    }
;
    qq_pclgen$genjumpcond((i64)1,pcond,lab_b);
    qq_pcllib$definefwdlabel(&lab_d);
    --(qq_pclgen$loopindex);
}

static void qq_pclgen$do_repeat(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b) {
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
    lab_b = qq_pcllib$definelabel();
    lab_c = qq_pcllib$createfwdlabel();
    lab_d = qq_pcllib$createfwdlabel();
    qq_pclgen$stacklooplabels(&lab_b,&lab_c,&lab_d);
    qq_pclgen$evalunit(a,(i64)0);
    qq_pcllib$definefwdlabel(&lab_c);
    if (!((((i64)(*b).tag == (i64)50) && ((*b).value == (i64)0)))) {
        qq_pclgen$genjumpcond((i64)0,b,lab_b);
    }
;
    qq_pcllib$definefwdlabel(&lab_d);
    --(qq_pclgen$loopindex);
}

static void qq_pclgen$do_for(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pvar,struct qq_decls$unitrec *pbody) {
        struct qq_decls$unitrec *  pfrom;
        struct qq_decls$unitrec *  pto;
        struct qq_decls$unitrec *  pstep;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  pautovar;
        struct qq_decls$strec *  dvar;
        struct qq_decls$strec *  limitvar;
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        i64 lab_e;
        i64 opc;
        i64 oldqpos;
        i64 step;
        i64 fromval;
        i64 limit;
        i64 jumpinto;
    pfrom = (*pvar).nextunit;
    pto = (*pfrom).nextunit;
    pstep = (*pto).nextunit;
    pautovar = 0;
    if (!!(pstep)) {
        qq_lib$gerror((byte*)"By N not implem",0);
    }
;
    pelse = (*pbody).nextunit;
    dvar = (*pvar).def;
    if ((!(((i64)(*pto).tag == (i64)50 || (i64)(*pto).tag == (i64)47)) || (((i64)(*pto).tag == (i64)47) && (msysc$m_getdotindex((i64)(*(*pto).def).flags,(i64)9) != msysc$m_getdotindex((i64)(*dvar).flags,(i64)9))))) {
        pautovar = qq_lib$createavnamex(qq_decls$stcurrproc);
    }
;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)17)) {
        step = (i64)1;
    }
    else if (($temp==(i64)19)) {
        step = (i64)-1;
    }
    };
    jumpinto = (i64)1;
    lab_b = qq_pcllib$createfwdlabel();
    lab_c = qq_pcllib$createfwdlabel();
    lab_d = qq_pcllib$createfwdlabel();
    lab_e = (!!(pelse) ? qq_pcllib$createfwdlabel() : lab_d);
    qq_pclgen$stacklooplabels(&lab_b,&lab_c,&lab_d);
    if (((i64)(*pfrom).tag == (i64)50)) {
        fromval = (*pfrom).value;
        if (((i64)(*pto).tag == (i64)50)) {
            limit = (*pto).value;
            if ((((step == (i64)-1) && (fromval >= limit)) || ((step == (i64)1) && (fromval <= limit)))) {
                jumpinto = (i64)0;
            }
;
        }
;
        if (!!(jumpinto)) {
            if ((step < (i64)0)) {
                ++(fromval);
            }
            else {
                --(fromval);
            }
;
            (*pfrom).value = fromval;
        }
;
        qq_pcllib$genpc_int((i64)18,(*pfrom).value);
        qq_pcllib$genpc_name(((i64)13 + (i64)msysc$m_getdotindex((i64)(*dvar).flags,(i64)9)),(struct qq_decls$strec *)dvar);
    }
    else {
        qq_pclgen$evalunit(pfrom,(i64)1);
        qq_pcllib$genpc_name(((i64)13 + (i64)msysc$m_getdotindex((i64)(*dvar).flags,(i64)9)),(struct qq_decls$strec *)dvar);
        qq_pcllib$genpc_name((((step < (i64)0) ? (i64)90 : (i64)95) + (i64)msysc$m_getdotindex((i64)(*dvar).flags,(i64)9)),(struct qq_decls$strec *)dvar);
    }
;
    if (!!(pautovar)) {
        qq_pclgen$evalunit(pto,(i64)1);
        limitvar = (*pautovar).def;
        qq_pcllib$genpc_name(((i64)33 + (i64)msysc$m_getdotindex((i64)(*limitvar).flags,(i64)9)),(struct qq_decls$strec *)limitvar);
        pto = pautovar;
    }
    else {
        limitvar = (*pto).def;
    }
;
    if (!!(jumpinto)) {
        qq_pclgen$genjumpl(lab_c);
    }
;
    qq_pcllib$definefwdlabel(&lab_b);
    qq_pclgen$evalunit(pbody,(i64)0);
    qq_pcllib$definefwdlabel(&lab_c);
    if (((i64)(*pto).tag == (i64)50)) {
        opc = (((step < (i64)0) ? (i64)59 : (i64)55) + (i64)msysc$m_getdotindex((i64)(*dvar).flags,(i64)9));
    }
    else if ((msysc$m_getdotindex((i64)(*dvar).flags,(i64)9) == msysc$m_getdotindex((i64)(*limitvar).flags,(i64)9))) {
        opc = (((step < (i64)0) ? (i64)61 : (i64)57) + (i64)msysc$m_getdotindex((i64)(*dvar).flags,(i64)9));
    }
    else {
        qq_lib$gerror((byte*)"for:mixed m/f vars",0);
    }
;
    oldqpos = qq_decls$qpos;
    qq_decls$qpos = (i64)(*p).pos;
    qq_pcllib$genpc_lab(opc,lab_b);
    qq_decls$qpos = oldqpos;
    qq_pcllib$genopnd_name((struct qq_decls$strec *)dvar);
    if (((i64)(*pto).tag == (i64)50)) {
        qq_pcllib$genopnd_int((*pto).value);
    }
    else {
        qq_pcllib$genopnd_name((struct qq_decls$strec *)limitvar);
    }
;
    if (!!(pelse)) {
        qq_pcllib$definefwdlabel(&lab_e);
        qq_pclgen$evalunit(pelse,(i64)0);
    }
;
    qq_pcllib$definefwdlabel(&lab_d);
    qq_pclgen$unstacklooplabels();
}

static void qq_pclgen$do_forx(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pvar,struct qq_decls$unitrec *pbody) {
        struct qq_decls$unitrec *  pbounds;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  pautovar;
        struct qq_decls$strec *  dvar;
        struct qq_decls$strec *  limitvar;
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        i64 lab_e;
    pbounds = (*pvar).nextunit;
    pautovar = qq_lib$createavnamex(qq_decls$stcurrproc);
    pelse = (*pbody).nextunit;
    dvar = (*pvar).def;
    if (((i64)(*p).tag == (i64)20)) {
        qq_lib$gerror((byte*)"Can't down inrev yet",0);
    }
;
    lab_b = qq_pcllib$createfwdlabel();
    lab_c = qq_pcllib$createfwdlabel();
    lab_d = qq_pcllib$createfwdlabel();
    lab_e = (!!(pelse) ? qq_pcllib$createfwdlabel() : lab_d);
    qq_pclgen$stacklooplabels(&lab_b,&lab_c,&lab_d);
    qq_pclgen$evalunit(pbounds,(i64)1);
    limitvar = (*pautovar).def;
    qq_pcllib$genpc_name(((i64)33 + (i64)msysc$m_getdotindex((i64)(*limitvar).flags,(i64)9)),(struct qq_decls$strec *)limitvar);
    qq_pcllib$genpc((i64)100);
    qq_pcllib$genpc_name(((i64)13 + (i64)msysc$m_getdotindex((i64)(*dvar).flags,(i64)9)),(struct qq_decls$strec *)dvar);
    qq_pclgen$genjumpl(lab_c);
    qq_pcllib$definefwdlabel(&lab_b);
    qq_pclgen$evalunit(pbody,(i64)0);
    qq_pcllib$definefwdlabel(&lab_c);
    if ((msysc$m_getdotindex((i64)(*dvar).flags,(i64)9) == msysc$m_getdotindex((i64)(*limitvar).flags,(i64)9))) {
        qq_pcllib$genpc_lab(((i64)57 + (i64)msysc$m_getdotindex((i64)(*dvar).flags,(i64)9)),lab_b);
    }
    else {
        qq_lib$gerror((byte*)"forx:mixed m/f",0);
    }
;
    qq_pcllib$genopnd_name((struct qq_decls$strec *)dvar);
    qq_pcllib$genopnd_name((struct qq_decls$strec *)limitvar);
    if (!!(pelse)) {
        qq_pcllib$definefwdlabel(&lab_e);
        qq_pclgen$evalunit(pelse,(i64)0);
    }
;
    qq_pcllib$definefwdlabel(&lab_d);
    qq_pclgen$unstacklooplabels();
}

static void qq_pclgen$do_print(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b) {
        i64 issprint;
        struct qq_decls$unitrec *  x;
    issprint = (i64)((i64)(*p).tag == (i64)74);
    if (!!(issprint)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"//////ISSPRINT",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_pclgen$callhostfn((i64)3,(i64)0);
    }
    else {
        if (!!(a)) {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$callhostfn((i64)1,(i64)0);
        }
        else {
            qq_pclgen$callhostfn((i64)2,(i64)0);
        }
;
    }
;
    x = b;
    L863 :;
    while (!!(x)) {
                {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)78)) {
            qq_pclgen$evalunit((*x).b,(i64)1);
            qq_pclgen$evalunit((*x).a,(i64)1);
            qq_pclgen$callhostfn((i64)7,(i64)0);
        }
        else if (($temp==(i64)76)) {
            qq_pclgen$callhostfn((i64)11,(i64)0);
        }
        else if (($temp==(i64)77)) {
            qq_pclgen$callhostfn((i64)12,(i64)0);
        }
        else {
            qq_pclgen$evalunit(x,(i64)1);
            qq_pclgen$callhostfn((i64)8,(i64)0);
        }
        };
        x = (*x).nextunit;
L864 :;
    }
L865 :;
    ;
    if (((i64)(*p).tag == (i64)71)) {
        qq_pclgen$callhostfn((i64)10,(i64)0);
    }
;
    if (!!(issprint)) {
        qq_pcllib$genpc((i64)20);
        qq_pclgen$callhostfn((i64)6,(i64)0);
    }
    else {
        qq_pclgen$callhostfn((i64)5,(i64)0);
    }
;
}

static void qq_pclgen$do_fprint(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,struct qq_decls$unitrec *c) {
        i64 issfprint;
        struct qq_decls$unitrec *  x;
    issfprint = (i64)((i64)(*p).tag == (i64)75);
    if (!!(issfprint)) {
        qq_pclgen$callhostfn((i64)3,(i64)0);
    }
    else {
        if (!!(a)) {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$callhostfn((i64)1,(i64)0);
        }
        else {
            qq_pclgen$callhostfn((i64)2,(i64)0);
        }
;
    }
;
    qq_pclgen$evalunit(b,(i64)1);
    qq_pclgen$callhostfn((i64)4,(i64)0);
    x = c;
    L866 :;
    while (!!(x)) {
                {i64 $temp = (i64)(*x).tag;
if (($temp==(i64)78)) {
            qq_pclgen$evalunit((*x).b,(i64)1);
            qq_pclgen$evalunit((*x).a,(i64)1);
            qq_pclgen$callhostfn((i64)7,(i64)0);
        }
        else if (($temp==(i64)76)) {
            qq_pclgen$callhostfn((i64)11,(i64)0);
        }
        else {
            qq_pcllib$genpc((i64)20);
            qq_pclgen$evalunit(x,(i64)1);
            qq_pclgen$callhostfn((i64)7,(i64)0);
        }
        };
        x = (*x).nextunit;
L867 :;
    }
L868 :;
    ;
    if (((i64)(*p).tag == (i64)73)) {
        qq_pclgen$callhostfn((i64)10,(i64)0);
    }
;
    if (!!(issfprint)) {
        qq_pcllib$genpc((i64)20);
        qq_pclgen$callhostfn((i64)6,(i64)0);
    }
    else {
        qq_pclgen$callhostfn((i64)5,(i64)0);
    }
;
}

static void qq_pclgen$do_read(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b) {
        struct qq_decls$unitrec *  x;
        struct qq_decls$unitrec *  xloop;
    if (((i64)(*p).tag == (i64)80)) {
        if (!!(a)) {
            qq_pclgen$evalunit(a,(i64)1);
            qq_pclgen$callhostfn((i64)13,(i64)0);
        }
        else {
            qq_pcllib$genpc((i64)20);
            qq_pclgen$callhostfn((i64)13,(i64)0);
        }
;
    }
;
    xloop = b;
    L869 :;
    while (!!(xloop)) {
        x = xloop;
        qq_pcllib$genpc((i64)20);
        if (((i64)(*x).tag == (i64)78)) {
            qq_pclgen$evalunit((*x).b,(i64)1);
            qq_pclgen$callhostfn((i64)15,(i64)0);
            x = (*x).a;
        }
        else {
            qq_pcllib$genpc((i64)20);
            qq_pclgen$callhostfn((i64)15,(i64)0);
        }
;
        if (((i64)(*x).tag == (i64)47)) {
            qq_pcllib$genpc_name(((i64)13 + (i64)msysc$m_getdotindex((i64)(*(*x).def).flags,(i64)9)),(struct qq_decls$strec *)(*x).def);
        }
        else {
            qq_pclgen$evalref(x);
            qq_pcllib$genpc((i64)32);
        }
;
        xloop = (*xloop).nextunit;
L870 :;
    }
L871 :;
    ;
}

static void qq_pclgen$do_forall(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pbody) {
        i64 lab_b;
        i64 lab_c;
        i64 lab_d;
        i64 lab_e;
        struct qq_decls$unitrec *  ploopvar;
        struct qq_decls$unitrec *  plist;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  plimitvar;
        struct qq_decls$unitrec *  plistvar;
        struct qq_decls$strec *  indexvar;
        struct qq_decls$strec *  limitvar;
        struct qq_decls$strec *  loopvar;
        struct qq_decls$strec *  listvar;
    plist = (*pindex).nextunit;
    ploopvar = (*plist).nextunit;
    if ((ploopvar == 0)) {
        ploopvar = pindex;
        pindex = qq_lib$createavnamex(qq_decls$stcurrproc);
    }
;
    loopvar = (*ploopvar).def;
    plimitvar = qq_lib$createavnamex(qq_decls$stcurrproc);
    limitvar = (*plimitvar).def;
    indexvar = (*pindex).def;
    if ((((i64)(*plist).tag != (i64)47) || (msysc$m_getdotindex((i64)(*(*plist).def).flags,(i64)9) != msysc$m_getdotindex((i64)(*loopvar).flags,(i64)9)))) {
        plistvar = qq_lib$createavnamex(qq_decls$stcurrproc);
        listvar = (*plistvar).def;
        qq_pclgen$evalunit(plist,(i64)1);
        qq_pcllib$genpc_name(((i64)33 + (i64)msysc$m_getdotindex((i64)(*listvar).flags,(i64)9)),(struct qq_decls$strec *)listvar);
    }
    else {
        plistvar = plist;
        listvar = (*plistvar).def;
    }
;
    if (!((msysc$m_getdotindex((i64)(*indexvar).flags,(i64)9)==msysc$m_getdotindex((i64)(*loopvar).flags,(i64)9) && msysc$m_getdotindex((i64)(*loopvar).flags,(i64)9)==msysc$m_getdotindex((i64)(*listvar).flags,(i64)9)))) {
        qq_lib$gerror((byte*)"forall: mixed vars",0);
    }
;
    pelse = (*pbody).nextunit;
    if (((i64)(*p).tag == (i64)22)) {
        qq_lib$gerror((byte*)"Forall/rev not ready",0);
    }
;
    lab_b = qq_pcllib$createfwdlabel();
    lab_c = qq_pcllib$createfwdlabel();
    lab_d = qq_pcllib$createfwdlabel();
    lab_e = (!!(pelse) ? qq_pcllib$createfwdlabel() : lab_d);
    qq_pclgen$stacklooplabels(&lab_b,&lab_c,&lab_d);
    qq_pcllib$genpc_name(((i64)9 + (i64)msysc$m_getdotindex((i64)(*listvar).flags,(i64)9)),(struct qq_decls$strec *)listvar);
    qq_pcllib$genpc((i64)135);
    qq_pcllib$genpc_name(((i64)33 + (i64)msysc$m_getdotindex((i64)(*listvar).flags,(i64)9)),(struct qq_decls$strec *)limitvar);
    qq_pcllib$genpc((i64)100);
    qq_pcllib$genpc_name(((i64)33 + (i64)msysc$m_getdotindex((i64)(*indexvar).flags,(i64)9)),(struct qq_decls$strec *)indexvar);
    qq_pclgen$genjumpl(lab_c);
    qq_pcllib$definefwdlabel(&lab_b);
    qq_pcllib$genpc_name(((i64)9 + (i64)msysc$m_getdotindex((i64)(*listvar).flags,(i64)9)),(struct qq_decls$strec *)listvar);
    qq_pclgen$evalunit(pindex,(i64)1);
    if (((i64)(*p).tag == (i64)21 || (i64)(*p).tag == (i64)22)) {
        qq_pcllib$genpc((i64)210);
    }
    else {
        qq_pcllib$genpc((i64)211);
    }
;
    qq_pcllib$genpc_name(((i64)13 + (i64)msysc$m_getdotindex((i64)(*loopvar).flags,(i64)9)),(struct qq_decls$strec *)loopvar);
    qq_pclgen$evalunit(pbody,(i64)0);
    qq_pcllib$definefwdlabel(&lab_c);
    if ((msysc$m_getdotindex((i64)(*indexvar).flags,(i64)9) == msysc$m_getdotindex((i64)(*limitvar).flags,(i64)9))) {
        qq_pcllib$genpc_lab(((i64)57 + (i64)msysc$m_getdotindex((i64)(*indexvar).flags,(i64)9)),lab_b);
    }
    else {
        qq_lib$gerror((byte*)"forall:mixed m/f",0);
    }
;
    qq_pcllib$genopnd_name((struct qq_decls$strec *)indexvar);
    qq_pcllib$genopnd_name((struct qq_decls$strec *)limitvar);
    if (!!(pelse)) {
        qq_pcllib$definefwdlabel(&lab_e);
        qq_pclgen$evalunit(pelse,(i64)0);
    }
;
    qq_pcllib$definefwdlabel(&lab_d);
    qq_pclgen$unstacklooplabels();
}

static void qq_pclgen$do_case(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,i64 res) {
        i64 lab_a;
        i64 lab_d;
        i64 loopsw;
        i64 labnextwhen;
        i64 labstmtstart;
        i64 fmult;
        struct qq_decls$unitrec *  w;
        struct qq_decls$unitrec *  wt;
        struct qq_decls$unitrec *  pelse;
    if (((i64)(*pindex).tag == (i64)0)) {
        qq_pclgen$do_case_nc(p,pindex,pwhenthen,res);
        return;
    }
;
    loopsw = (i64)(((i64)(*p).tag == (i64)13) || ((i64)(*p).tag == (i64)15));
    pelse = (*pindex).nextunit;
    if (!!(loopsw)) {
        lab_a = qq_pcllib$definelabel();
        lab_d = qq_pcllib$createfwdlabel();
        qq_pclgen$stacklooplabels(&lab_a,&lab_a,&lab_d);
    }
    else {
        lab_d = qq_pcllib$createfwdlabel();
    }
;
    qq_pclgen$evalunit(pindex,(i64)1);
    wt = pwhenthen;
    L872 :;
    while (!!(wt)) {
        w = (*wt).a;
        fmult = (i64)((*w).nextunit != 0);
        labnextwhen = qq_pcllib$createfwdlabel();
        if (!!(fmult)) {
            labstmtstart = qq_pcllib$createfwdlabel();
        }
;
        L875 :;
        while (!!(w)) {
            qq_pclgen$evalunit(w,(i64)1);
            w = (*w).nextunit;
            if (!!(w)) {
                qq_pcllib$genpc_lab((i64)49,labstmtstart);
            }
            else {
                qq_pcllib$genpc_lab((i64)50,labnextwhen);
            }
;
L876 :;
        }
L877 :;
        ;
        if (!!(fmult)) {
            qq_pcllib$definefwdlabel(&labstmtstart);
        }
;
        qq_pclgen$evalunit((*wt).b,res);
        if (!(!!(loopsw))) {
            qq_pclgen$genjumpl(lab_d);
        }
        else {
            qq_pclgen$genjumpl(lab_a);
        }
;
        qq_pcllib$definefwdlabel(&labnextwhen);
        wt = (*wt).nextunit;
L873 :;
    }
L874 :;
    ;
    qq_pcllib$genpc_int((i64)75,(i64)1);
    if (!!(pelse)) {
        qq_pclgen$evalunit(pelse,res);
    }
    else if (!!(res)) {
        qq_pcllib$genpc((i64)20);
    }
;
    if (!!(loopsw)) {
        qq_pclgen$genjumpl(lab_a);
        qq_pcllib$definefwdlabel(&lab_d);
        qq_pclgen$unstacklooplabels();
    }
    else {
        qq_pcllib$definefwdlabel(&lab_d);
    }
;
}

static void qq_pclgen$do_case_nc(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,i64 res) {
        i64 lab_d;
        i64 labnextwhen;
        i64 labstmtstart;
        i64 fmult;
        struct qq_decls$unitrec *  w;
        struct qq_decls$unitrec *  wt;
        struct qq_decls$unitrec *  pelse;
    if (((i64)(*p).tag != (i64)12)) {
        qq_lib$gerror((byte*)"case-nc",0);
    }
;
    pelse = (*pindex).nextunit;
    lab_d = qq_pcllib$createfwdlabel();
    wt = pwhenthen;
    L878 :;
    while (!!(wt)) {
        w = (*wt).a;
        fmult = (i64)((*w).nextunit != 0);
        labnextwhen = qq_pcllib$createfwdlabel();
        if (!!(fmult)) {
            labstmtstart = qq_pcllib$createfwdlabel();
        }
;
        L881 :;
        while (!!(w)) {
            qq_pclgen$evalunit(w,(i64)1);
            w = (*w).nextunit;
            if (!!(w)) {
                qq_pcllib$genpc_lab((i64)41,labstmtstart);
            }
            else {
                qq_pcllib$genpc_lab((i64)42,labnextwhen);
            }
;
L882 :;
        }
L883 :;
        ;
        if (!!(fmult)) {
            qq_pcllib$definefwdlabel(&labstmtstart);
        }
;
        qq_pclgen$evalunit((*wt).b,res);
        qq_pclgen$genjumpl(lab_d);
        qq_pcllib$definefwdlabel(&labnextwhen);
        wt = (*wt).nextunit;
L879 :;
    }
L880 :;
    ;
    if (!!(pelse)) {
        qq_pclgen$evalunit(pelse,res);
    }
    else if (!!(res)) {
        qq_pcllib$genpc((i64)20);
    }
;
    qq_pcllib$definefwdlabel(&lab_d);
}

static void qq_pclgen$do_try(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b) {
        i64 labend;
        i64 labx;
        struct qq_decls$unitrec *  ptry;
        struct qq_decls$unitrec *  pexcept;
        struct qq_decls$unitrec *  pexcode;
    ++(qq_pclgen$trylevel);
    labend = qq_pcllib$createfwdlabel();
    ptry = a;
    labx = qq_pcllib$createfwdlabel();
    pexcept = b;
    if ((pexcept == 0)) {
        qq_lib$gerror((byte*)"try: no except",0);
    }
    else if (!!((*pexcept).nextunit)) {
        qq_lib$gerror((byte*)"Try:multiple except block not implemented",0);
    }
;
    L884 :;
    while (!!(pexcept)) {
        pexcode = (*pexcept).a;
        if (((pexcode == 0) || !!((*pexcode).nextunit))) {
            qq_lib$gerror((byte*)"Try:multiple except codes not implemented",0);
        }
;
        qq_pcllib$genpc_lab((i64)222,labx);
        qq_pcllib$genopnd_int(qq_pclgen$getconstvalue(pexcode));
        qq_pcllib$genopnd_int((i64)1);
        qq_pclgen$evalunit(ptry,(i64)0);
        qq_pclgen$genjumpl(labend);
        qq_pcllib$definefwdlabel(&labx);
        qq_pclgen$evalunit((*pexcept).b,(i64)0);
        qq_pcllib$definefwdlabel(&labend);
        pexcept = (*pexcept).nextunit;
L885 :;
    }
L886 :;
    ;
    qq_pcllib$genpc_int((i64)76,(i64)1);
    --(qq_pclgen$trylevel);
}

static i64 qq_pclgen$unitstoarray(struct qq_decls$unitrec *p,struct qq_decls$unitrec *(*plist)[],i64 maxunits) {
        i64 n;
    n = (i64)0;
    L887 :;
    while (!!(p)) {
        if ((n >= maxunits)) {
            qq_lib$gerror((byte*)"UTA Too many units",0);
        }
;
        (*plist)[(++(n))-1] = p;
        p = (*p).nextunit;
L888 :;
    }
L889 :;
    ;
    return n;
}

static void qq_pclgen$do_select(struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pplist,i64 res) {
        i64 n;
        i64 labend;
        i64 i;
        i64 lab;
        i64 elselab;
        struct qq_decls$unitrec *  x;
        struct qq_decls$unitrec *  pelse;
        struct qq_decls$unitrec *  plist[512];
        i64 labels[513];
    pelse = (*pindex).nextunit;
    n = qq_pclgen$unitstoarray(pplist,(struct qq_decls$unitrec *(*)[])&plist,(i64)512);
    if ((n > (i64)512)) {
        qq_lib$gerror((byte*)"Selectx too complex",0);
    }
;
    labend = qq_pcllib$createfwdlabel();
    qq_pclgen$evalunit(pindex,(i64)1);
    qq_pcllib$genpc_int2((i64)52,n,(i64)1);
    for (i=(i64)1;i<=n;++i) {
L890 :;
        labels[(i)-1] = (qq_pcllib$pclnext - qq_pcllib$pclstart);
        qq_pcllib$genpc_lab((i64)51,(i64)0);
L891 :;
    }
L892 :;
    ;
    labels[((n + (i64)1))-1] = (qq_pcllib$pclnext - qq_pcllib$pclstart);
    qq_pcllib$genpc_lab((i64)51,(i64)0);
    i = (i64)1;
    for (i=(i64)1;i<=n;++i) {
L893 :;
        x = plist[(i)-1];
        lab = qq_pcllib$definelabel();
        (*((qq_pcllib$pclstart + labels[(i)-1]) + (i64)1)) = lab;
        qq_pclgen$evalunit(x,res);
        qq_pclgen$genjumpl(labend);
L894 :;
    }
L895 :;
    ;
    elselab = qq_pcllib$definelabel();
    (*((qq_pcllib$pclstart + labels[((n + (i64)1))-1]) + (i64)1)) = elselab;
    if (!!(pelse)) {
        qq_pclgen$evalunit(pelse,res);
    }
    else if (!!(res)) {
        qq_pcllib$genpc((i64)20);
    }
;
    qq_pcllib$genpc((i64)1);
    qq_pcllib$definefwdlabel(&labend);
}

static void qq_pclgen$do_andl(struct qq_decls$unitrec *x,struct qq_decls$unitrec *y) {
        i64 a;
        i64 b;
    a = qq_pcllib$createfwdlabel();
    b = qq_pcllib$createfwdlabel();
    qq_pclgen$genjumpcond((i64)0,x,a);
    qq_pclgen$genjumpcond((i64)0,y,a);
    qq_pcllib$genpc_int((i64)18,(i64)1);
    qq_pclgen$genjumpl(b);
    qq_pcllib$definefwdlabel(&a);
    qq_pcllib$genpc_int((i64)18,(i64)0);
    qq_pcllib$genpc((i64)1);
    qq_pcllib$definefwdlabel(&b);
}

static void qq_pclgen$do_orl(struct qq_decls$unitrec *x,struct qq_decls$unitrec *y) {
        i64 a;
        i64 b;
    a = qq_pcllib$createfwdlabel();
    b = qq_pcllib$createfwdlabel();
    qq_pclgen$genjumpcond((i64)1,x,a);
    qq_pclgen$genjumpcond((i64)1,y,a);
    qq_pcllib$genpc_int((i64)18,(i64)0);
    qq_pclgen$genjumpl(b);
    qq_pcllib$definefwdlabel(&a);
    qq_pcllib$genpc_int((i64)18,(i64)1);
    qq_pcllib$genpc((i64)1);
    qq_pcllib$definefwdlabel(&b);
}

static void qq_pclgen$do_incr(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,i64 res) {
        struct qq_decls$strec *  d;
    if (!!(res)) {
        qq_pclgen$do_unaryref(a,(i64)qq_tables$jpclcodes[((i64)(*p).tag)]);
    }
    else if (((i64)(*a).tag == (i64)47)) {
        d = (*a).def;
        if ((((i64)(*d).nameid == (i64)13) && !!(msysc$m_getdotindex((i64)(*d).flags,(i64)5)))) {
            goto L896 ;
;
        }
        else {
            qq_pcllib$genpc_name(((((i64)(*p).tag == (i64)85 || (i64)(*p).tag == (i64)87) ? (i64)90 : (i64)95) + (i64)msysc$m_getdotindex((i64)(*(*a).def).flags,(i64)9)),(struct qq_decls$strec *)(*a).def);
        }
;
    }
    else {
        //dounary:
L896 :;
;
        qq_pclgen$do_unaryref(a,(((i64)(*p).tag == (i64)85 || (i64)(*p).tag == (i64)87) ? (i64)89 : (i64)94));
    }
;
}

static void qq_pclgen$do_new(struct qq_decls$unitrec *p) {
        i64 n;
        struct qq_decls$unitrec *  q;
        i64 $av_1;
        i64 $av_2;
    n = (i64)(*p).nparams;
    if (((n < (i64)1) || (n > (i64)3))) {
        qq_lib$gerror((byte*)"new args",0);
    }
;
    q = (*p).a;
    qq_pcllib$genpc((i64)20);
    $av_1 = n;
    while ($av_1-- > 0) {
L897 :;
        qq_pclgen$evalunit(q,(i64)1);
        q = (*q).nextunit;
L898 :;
    }
L899 :;
    ;
    $av_2 = ((i64)3 - n);
    while ($av_2-- > 0) {
L900 :;
        qq_pcllib$genpc((i64)20);
L901 :;
    }
L902 :;
    ;
    qq_pclgen$callhostfn((i64)41,(i64)0);
}

static i64 qq_pclgen$checkblockreturn(struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
    if ((p == 0)) {
        return (i64)0;
    }
;
    if (((i64)(*p).tag != (i64)8)) {
        qq_lib$gerror((byte*)"CBR?",0);
    }
;
    q = (struct qq_decls$unitrec *)(*p).a;
    if ((q == 0)) {
        return (i64)0;
    }
;
    L903 :;
    while (!!((r = (struct qq_decls$unitrec *)(*q).nextunit))) {
        q = r;
L904 :;
    }
L905 :;
    ;
        {i64 $temp = (i64)(*q).tag;
if (($temp==(i64)39)) {
        return (i64)1;
    }
    else if (($temp==(i64)9)) {
        return (i64)(!!(qq_pclgen$checkblockreturn((*q).b)) && !!(qq_pclgen$checkblockreturn((*(*q).b).nextunit)));
    }
    };
    return (i64)0;
}

static void qq_pclgen$do_callhost(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,i64 res) {
        i64 index;
        i64 isfunc;
        i64 nargs;
        i64 nparams;
        i64 fparams;
        struct qq_decls$unitrec *  plist[10];
        struct qq_decls$unitrec *  q;
        i64 $av_1;
        i64 i;
    index = (*p).index;
    isfunc = (i64)qq_tables$hostisfn[(index)];
    if ((!!(res) && !(!!(isfunc)))) {
        qq_lib$gerror((byte*)"Host proc not a function",0);
    }
;
    if (!!(isfunc)) {
        qq_pcllib$genpc((i64)20);
    }
;
    nargs = (i64)0;
    q = a;
    L906 :;
    while (!!(q)) {
        if ((nargs > (i64)10)) {
            qq_lib$gerror((byte*)"Too many host args",0);
        }
;
        plist[(++(nargs))-1] = q;
        q = (*q).nextunit;
L907 :;
    }
L908 :;
    ;
    if (((index == (i64)62) && (a == 0))) {
        nparams = (i64)1;
    }
    else {
        nparams = nargs;
    }
;
    if (((nparams == (i64)0) && !!((i64)qq_tables$hostlvset[(index)]))) {
        qq_lib$gerror((byte*)"LV hostfn: needs 1+ params",0);
    }
;
    fparams = (i64)qq_tables$hostnparams[(index)];
    if ((nparams > fparams)) {
        qq_lib$gerror((byte*)"Hostfn too many params",0);
    }
;
    $av_1 = (fparams - nparams);
    while ($av_1-- > 0) {
L909 :;
        qq_pcllib$genpc((i64)20);
L910 :;
    }
L911 :;
    ;
    for (i=nparams;i>=(i64)1;--i) {
L912 :;
        if (((i == (i64)1) && !!((i64)qq_tables$hostlvset[(index)]))) {
            qq_pclgen$evalref(plist[(i)-1]);
        }
        else if ((((i == (i64)1) && (index == (i64)62)) && (nargs == (i64)0))) {
            qq_pcllib$genpc_name((i64)11,(struct qq_decls$strec *)qq_decls$stcurrproc);
        }
        else {
            qq_pclgen$evalunit(plist[(i)-1],(i64)1);
        }
;
L913 :;
    }
L914 :;
    ;
    qq_pclgen$callhostfn(index,res);
}

static void qq_pclgen$callhostfn(i64 fnindex,i64 calledasfn) {
    qq_pcllib$genpc_int((i64)73,fnindex);
}

static void qq_pclgen$genfree(i64 n) {
    qq_pcllib$genpc_int((i64)75,n);
}

static void qq_pclgen$do_return(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a) {
    if (!!(a)) {
        qq_pclgen$evalunit(a,(i64)1);
    }
    else if ((qq_pclgen$currfunction == (i64)2)) {
        qq_lib$gerror((byte*)"function needs return value",0);
    }
;
    qq_pclgen$genjumpl(qq_pclgen$retindex);
}

static void qq_pclgen$do_multassign(struct qq_decls$unitrec *a,struct qq_decls$unitrec *b,i64 deepcopy,i64 res) {
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  plist[100];
        i64 n;
        i64 i;
    p = (*a).a;
    q = (*b).a;
    n = (i64)0;
    L915 :;
    while (!!(p)) {
        if ((q == 0)) {
            qq_lib$gerror((byte*)"Too few RHS elems",0);
        }
;
        qq_pclgen$evalunit(q,(i64)1);
        if ((n >= (i64)100)) {
            qq_lib$gerror((byte*)"Too many elems",0);
        }
;
        plist[(++(n))-1] = p;
        p = (*p).nextunit;
        q = (*q).nextunit;
L916 :;
    }
L917 :;
    ;
    if (!!(q)) {
        qq_lib$gerror((byte*)"Too few LHS elems",0);
    }
;
    for (i=n;i>=(i64)1;--i) {
L918 :;
        if (!!(deepcopy)) {
            qq_pcllib$genpc((i64)36);
        }
;
        qq_pclgen$do_store(plist[(i)-1],(i64)0);
L919 :;
    }
L920 :;
    ;
}

static void qq_pclgen$do_store(struct qq_decls$unitrec *a,i64 res) {
        struct qq_decls$strec *  d;
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  plist[100];
        i64 n;
        i64 i;
    if ((!!(res) && ((i64)(*a).tag != (i64)47))) {
        qq_pcllib$genpc((i64)35);
    }
;
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)47)) {
        d = (*a).def;
        if ((((i64)(*d).nameid == (i64)13) && !!(msysc$m_getdotindex((i64)(*d).flags,(i64)5)))) {
            if (!!(res)) {
                qq_pcllib$genpc((i64)35);
            }
;
            qq_pcllib$genpc_name((i64)10,(struct qq_decls$strec *)d);
            qq_pcllib$genpc((i64)32);
        }
        else if (!!(res)) {
            qq_pcllib$genpc_name(((i64)15 + (i64)msysc$m_getdotindex((i64)(*d).flags,(i64)9)),(struct qq_decls$strec *)d);
        }
        else {
            qq_pcllib$genpc_name(((i64)13 + (i64)msysc$m_getdotindex((i64)(*d).flags,(i64)9)),(struct qq_decls$strec *)d);
        }
;
    }
    else if (($temp==(i64)59)) {
        qq_pclgen$evalunit((*a).a,(i64)1);
        qq_pcllib$genpc_name((i64)217,(struct qq_decls$strec *)(*(*a).b).def);
    }
    else if (($temp==(i64)60)) {
        qq_pclgen$do_bin((*a).a,(*a).b,(i64)218);
    }
    else if (($temp==(i64)61)) {
        qq_pclgen$evalref((*a).a);
        qq_pclgen$evalunit((*a).b,(i64)1);
        qq_pcllib$genpc((i64)219);
    }
    else if (($temp==(i64)66)) {
        qq_pclgen$evalunit((*a).a,(i64)1);
        qq_pcllib$genpc((i64)32);
    }
    else if (($temp==(i64)62)) {
        qq_pclgen$do_bin((*a).a,(*a).b,(i64)220);
    }
    else if (($temp==(i64)197)) {
        n = (i64)0;
        p = (*a).a;
        L921 :;
        while (!!(p)) {
            if ((n >= (i64)100)) {
                qq_lib$gerror((byte*)"Too many elems",0);
            }
;
            plist[(++(n))-1] = p;
            p = (*p).nextunit;
L922 :;
        }
L923 :;
        ;
        if ((n == (i64)0)) {
            qq_lib$gerror((byte*)"Empty lhs list",0);
        }
;
        qq_pcllib$genpc_int((i64)221,n);
        for (i=(i64)1;i<=n;++i) {
L924 :;
            qq_pclgen$do_store(plist[(i)-1],(i64)0);
L925 :;
        }
L926 :;
        ;
    }
    else if (($temp==(i64)9)) {
        qq_pclgen$evalref(a);
        qq_pcllib$genpc((i64)32);
    }
    else {
        qq_lib$gerror_s((byte*)"Can't store to this unit yet:",qq_tables$jtagnames[((i64)(*a).tag)],a);
    }
    };
}

static i64 qq_pclgen$getconstvalue(struct qq_decls$unitrec *p) {
    if ((!!(p) && ((i64)(*p).tag == (i64)50))) {
        return (*p).value;
    }
;
    qq_lib$gerror((byte*)"gcv Not const",0);
    return (i64)0;
}

static void qq_pclgen$do_convert(struct qq_decls$unitrec *pconv) {
        i64 n;
        i64 elemmode;
        i64 i;
        i64 lowerx;
        i64 m;
        i64 mbase;
        i64 nfields;
        struct qq_decls$unitrec *  plist[400];
        struct qq_decls$unitrec *  p;
        i64 $av_1;
    m = (i64)(*pconv).mode;
    p = (*pconv).a;
    mbase = (i64)qq_tables$ttbasetype[(m)];
    if ((((i64)(*p).tag != (i64)197) || (mbase == (i64)24))) {
        if (((i64)(*p).tag == (i64)197)) {
            qq_lib$deleteunit(p,(*p).a);
        }
;
        qq_pclgen$evalunit(p,(i64)1);
        qq_pcllib$genpc_int((i64)160,m);
        return;
    }
;
    n = qq_pclgen$unitstoarray((*p).a,(struct qq_decls$unitrec *(*)[])&plist,(i64)400);
    if ((!!(n) && ((i64)(*plist[((i64)1)-1]).tag == (i64)5))) {
        if ((mbase==(i64)15) || (mbase==(i64)16)) {
            qq_pclgen$do_makerecordkv(m,n,&plist);
        }
        else {
            qq_lib$gerror((byte*)"key:value not allowed",0);
        }
;
        return;
    }
;
    for (i=(i64)1;i<=n;++i) {
L927 :;
        qq_pclgen$evalunit(plist[(i)-1],(i64)1);
L928 :;
    }
L929 :;
    ;
    if ((mbase==(i64)15) || (mbase==(i64)16)) {
        nfields = qq_tables$ttlength[(m)];
        if (!!(n)) {
            qq_pclgen$checkelems(n,nfields,p);
        }
        else {
            $av_1 = nfields;
            while ($av_1-- > 0) {
L930 :;
                qq_pcllib$genpc_int((i64)18,(i64)0);
L931 :;
            }
L932 :;
            ;
            n = nfields;
        }
;
        qq_pcllib$genpc_int2(((mbase == (i64)15) ? (i64)80 : (i64)83),n,m);
    }
    else if ((mbase==(i64)13)) {
        lowerx = (i64)(*p).lower;
        qq_pcllib$genpc_int2((i64)79,n,lowerx);
    }
    else if ((mbase==(i64)14)) {
        qq_pcllib$genpc_int4((i64)81,(i64)(*p).lower,n,(i64)14,(i64)(*p).elemtype);
    }
    else if ((mbase==(i64)10)) {
        elemmode = (i64)qq_tables$tttarget[(m)];
        lowerx = qq_tables$ttlower[(m)];
        qq_pclgen$checkelems(n,qq_tables$ttlength[(m)],p);
        qq_pcllib$genpc_int4((i64)81,lowerx,n,m,elemmode);
    }
    else if ((mbase==(i64)11)) {
        if ((m == (i64)11)) {
            qq_pcllib$genpc_int4((i64)82,(i64)(*p).lower,n,(i64)11,(((i64)(*p).elemtype == (i64)0) ? (i64)35 : (i64)(*p).elemtype));
        }
        else {
            qq_lib$gerror((byte*)"user-define bit array not ready",0);
        }
;
    }
    else if ((mbase==(i64)8)) {
        qq_pcllib$genpc_int((i64)84,n);
    }
    else {
        qq_lib$gerror_s((byte*)"Convert list",qq_dummyshow$strmode(mbase,(i64)0),0);
    }
;
}

static void qq_pclgen$checkelems(i64 n,i64 length,struct qq_decls$unitrec *p) {
    if ((n < length)) {
        qq_lib$gerror((byte*)"Too few elements",0);
    }
    else if ((n > length)) {
        qq_lib$gerror((byte*)"Too many elements",0);
    }
;
}

static void qq_pclgen$do_switch(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,i64 res) {
        i64 minlab;
        i64 maxlab;
        i64 x;
        i64 y;
        i64 i;
        i64 n;
        struct qq_decls$unitrec *  w;
        struct qq_decls$unitrec *  wt;
        struct qq_decls$unitrec *  pelse;
    pelse = (*pindex).nextunit;
    minlab = (i64)1000000;
    maxlab = (i64)-1000000;
    n = (i64)0;
    wt = pwhenthen;
    L933 :;
    while (!!(wt)) {
        w = (*wt).a;
        L936 :;
        while (!!(w)) {
                        {i64 $temp = (i64)(*w).tag;
if (($temp==(i64)195)) {
                x = qq_pclgen$getconstvalue((*w).a);
                y = qq_pclgen$getconstvalue((*w).b);
                //dorange:
L939 :;
;
                for (i=x;i<=y;++i) {
L940 :;
                    minlab = (minlab<i?minlab:i);
                    maxlab = (maxlab>i?maxlab:i);
L941 :;
                }
L942 :;
                ;
            }
            else if (($temp==(i64)50)) {
                x = (y = (*w).value);
                goto L939 ;
;
            }
            else if (($temp==(i64)41)) {
                x = (y = (i64)(*w).mode);
                goto L939 ;
;
            }
            else {
                qq_lib$gerror_s((byte*)"Switch when2: not const",(*qq_lib$strexpr(w)).strptr,0);
            }
            };
            w = (*w).nextunit;
L937 :;
        }
L938 :;
        ;
        wt = (*wt).nextunit;
L934 :;
    }
L935 :;
    ;
    if (((maxlab - minlab) <= (i64)512)) {
        qq_pclgen$do_simpleswitch(p,pindex,pwhenthen,pelse,minlab,maxlab,res);
        return;
    }
;
    qq_lib$gerror((byte*)"COMPLEX SWITCH/NOT COMPLETE",0);
}

static void qq_pclgen$do_simpleswitch(struct qq_decls$unitrec *p,struct qq_decls$unitrec *pindex,struct qq_decls$unitrec *pwhenthen,struct qq_decls$unitrec *pelse,i64 a,i64 b,i64 res) {
        struct qq_decls$unitrec *  w;
        struct qq_decls$unitrec *  wt;
        i64 loopsw;
        i64 n;
        i64 offset;
        i64 x;
        i64 y;
        i64 x0;
        i64 i;
        i64 labstmt;
        i64 elselab;
        i64 *  labels[513];
        i64 lab_a;
        i64 lab_d;
    loopsw = (i64)((i64)(*p).tag == (i64)15);
    n = ((b - a) + (i64)1);
    offset = (a - (i64)1);
    if (!!(loopsw)) {
        lab_a = qq_pcllib$definelabel();
        lab_d = qq_pcllib$createfwdlabel();
        qq_pclgen$stacklooplabels(&lab_a,&lab_a,&lab_d);
    }
    else {
        lab_d = qq_pcllib$createfwdlabel();
    }
;
    elselab = qq_pcllib$createfwdlabel();
    qq_pclgen$evalunit(pindex,(i64)1);
    qq_pcllib$genpc_int2((i64)52,n,a);
    for (i=(i64)1;i<=n;++i) {
L943 :;
        qq_pcllib$genpc_lab((i64)51,(i64)0);
        labels[(i)-1] = (qq_pcllib$pcllast + (i64)1);
L944 :;
    }
L945 :;
    ;
    qq_pcllib$genpc_lab((i64)51,(i64)0);
    labels[((n + (i64)1))-1] = (qq_pcllib$pcllast + (i64)1);
    wt = pwhenthen;
    L946 :;
    while (!!(wt)) {
        labstmt = qq_pcllib$definelabel();
        w = (*wt).a;
        L949 :;
        while (!!(w)) {
                        {i64 $temp = (i64)(*w).tag;
if (($temp==(i64)195)) {
                x0 = qq_pclgen$getconstvalue((*w).a);
                y = qq_pclgen$getconstvalue((*w).b);
            }
            else if (($temp==(i64)50)) {
                x0 = (y = (*w).value);
            }
            else if (($temp==(i64)41)) {
                x0 = (y = (i64)(*w).mode);
            }
            };
            for (x=x0;x<=y;++x) {
L952 :;
                i = (x - offset);
                if (!!((*labels[(i)-1]))) {
                    msysc$m_print_startcon();
                    msysc$m_print_i64(x,NULL);
                    msysc$m_print_c8((u64)(u8)x,NULL);
                    msysc$m_print_newline();
                    msysc$m_print_end();
                    ;
                    qq_lib$gerror((byte*)"Dupl switch value",0);
                }
;
                (*labels[(i)-1]) = labstmt;
L953 :;
            }
L954 :;
            ;
            w = (*w).nextunit;
L950 :;
        }
L951 :;
        ;
        qq_pclgen$evalunit((*wt).b,res);
        if (!(!!(loopsw))) {
            qq_pclgen$genjumpl(lab_d);
        }
        else {
            qq_pclgen$genjumpl(lab_a);
        }
;
        wt = (*wt).nextunit;
L947 :;
    }
L948 :;
    ;
    qq_pcllib$definefwdlabel(&elselab);
    if (!!(pelse)) {
        qq_pclgen$evalunit(pelse,res);
    }
;
    if (!!(loopsw)) {
        qq_pclgen$genjumpl(lab_a);
        qq_pcllib$definefwdlabel(&lab_d);
        qq_pclgen$unstacklooplabels();
    }
    else {
        qq_pcllib$definefwdlabel(&lab_d);
    }
;
    for (i=(i64)1;i<=n;++i) {
L955 :;
        if (((*labels[(i)-1]) == (i64)0)) {
            (*labels[(i)-1]) = elselab;
        }
;
L956 :;
    }
L957 :;
    ;
    (*labels[((n + (i64)1))-1]) = elselab;
}

static void qq_pclgen$do_makerecordkv(i64 m,i64 nkeyvals,struct qq_decls$unitrec *(*kvlist)[]) {
        struct qq_decls$unitrec *  p;
        struct qq_decls$unitrec *  plist[400];
        i64 nfields;
        i64 index;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
        struct qq_decls$strec *  f;
        struct qq_decls$strec *  k;
        i64 i;
    d = qq_tables$ttnamedef[(m)];
    e = (*d).deflist;
    nfields = (i64)0;
    L958 :;
    while (!!(e)) {
        if ((((i64)(*e).nameid == (i64)9 || (i64)(*e).nameid == (i64)10) && ((*e).atfield == 0))) {
            ++(nfields);
            plist[(nfields)-1] = 0;
        }
;
L959 :;
        e = (*e).nextdef;
L961 :;
            }
L960 :;
    ;
    for (i=(i64)1;i<=nkeyvals;++i) {
L962 :;
        k = (*(*(*kvlist)[(i)-1]).a).def;
        p = (*(*kvlist)[(i)-1]).b;
        e = (*d).deflist;
        f = 0;
        L965 :;
        while (!!(e)) {
            if ((((i64)(*e).nameid == (i64)9 || (i64)(*e).nameid == (i64)10) && ((*e).firstdupl == k))) {
                f = e;
                goto L967 ;
            }
;
L966 :;
            e = (*e).nextdef;
L968 :;
                    }
L967 :;
        ;
        if (!(!!(f))) {
            qq_lib$gerror_s((byte*)"Can't find field:",(*k).name,0);
        }
;
        index = (*f).index;
        if (!!(plist[(index)-1])) {
            qq_lib$gerror_s((byte*)"Dupl key:",(*k).name,0);
        }
;
        plist[(index)-1] = p;
L963 :;
    }
L964 :;
    ;
    for (i=(i64)1;i<=nfields;++i) {
L969 :;
        if (!!(plist[(i)-1])) {
            qq_pclgen$evalunit(plist[(i)-1],(i64)1);
        }
        else {
            qq_pcllib$genpc_int((i64)18,(i64)0);
        }
;
L970 :;
    }
L971 :;
    ;
    qq_pcllib$genpc_int2((i64)80,nfields,m);
}

static void qq_pclgen$do_idiv(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b) {
        i64 n;
    qq_pclgen$evalunit(a,(i64)1);
    if ((((i64)(*b).tag == (i64)50) && !!((n = qq_lib$ispoweroftwo((*b).value))))) {
        qq_pcllib$genpc_int((i64)18,n);
        qq_pcllib$genpc((i64)175);
    }
    else {
        qq_pclgen$evalunit(b,(i64)1);
        qq_pcllib$genpc((i64)168);
    }
;
}

static void qq_pclgen$do_irem(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b) {
        i64 n;
        u64 m;
    qq_pclgen$evalunit(a,(i64)1);
    if ((((i64)(*b).tag == (i64)50) && !!((n = qq_lib$ispoweroftwo((*b).value))))) {
        m = ~(((u64)18446744073709551615u << n));
        qq_pcllib$genpc_int((i64)18,(i64)m);
        qq_pcllib$genpc((i64)171);
    }
    else {
        qq_pclgen$evalunit(b,(i64)1);
        qq_pcllib$genpc((i64)169);
    }
;
}

static void qq_pclgen$do_map(struct qq_decls$unitrec *p,struct qq_decls$unitrec *popcode,struct qq_decls$unitrec *x) {
        i64 lab;
    qq_pclgen$evalunit(x,(i64)1);
    if (!!((*x).nextunit)) {
        qq_pclgen$evalunit((*x).nextunit,(i64)1);
    }
;
    qq_pclgen$evalunit(popcode,(i64)1);
    qq_pcllib$genpc((!!((*x).nextunit) ? (i64)225 : (i64)224));
    lab = qq_pcllib$createfwdlabel();
    qq_pcllib$genpc_lab((i64)39,lab);
    qq_pcllib$genpc((i64)1);
    qq_pcllib$definefwdlabel(&lab);
}

static void qq_pclgen$pushstring(u8 *s,i64 length) {
        struct qq_decls$stringrec *  ps;
    qq_pcllib$genpc((i64)26);
    ps = (struct qq_decls$stringrec *)mlib$pcm_alloc((i64)16);
    (*ps).svalue = s;
    (*ps).length = length;
    qq_pcllib$genopnd_int((i64)ps);
}

// START
void qq_pclgen$start(void) {

}

// START
void qq_pcllib$start(void) {

        i64 nn;
        i64 i;
        i64 j;
    for (i=(i64)1;i<=(i64)272;++i) {
L972 :;
        nn = (i64)0;
        for (j=(i64)1;j<=(i64)4;++j) {
L975 :;
            if (((i64)qq_tables$pclfmt[(i)][(j)-1] == (i64)0)) {
                goto L977 ;
            }
;
            ++(nn);
L976 :;
        }
L977 :;
        ;
        qq_pcllib$pclnopnds[(i)] = nn;
L973 :;
    }
L974 :;
    ;
    mlib$pcm_init();
    qq_pcllib$labelalloc = (i64)8192;
    qq_pcllib$labeloffsettable = (i64 (*)[])mlib$pcm_alloc(((i64)8 * qq_pcllib$labelalloc));
}

void qq_pcllib$resetpcl(i64 sourcesize) {
        i64 pclsize;
    qq_decls$qpos = (i64)0;
    qq_pcllib$nextlabelno = (i64)0;
    qq_pcllib$pclcurrlineno = (i64)0;
    pclsize = sourcesize;
    qq_pcllib$pclalloc = (i64)1024;
    L978 :;
    while ((qq_pcllib$pclalloc < pclsize)) {
        qq_pcllib$pclalloc <<= (i64)1;
L979 :;
    }
L980 :;
    ;
    qq_pcllib$pclstart = (i64 *)mlib$pcm_alloc((qq_pcllib$pclalloc * (i64)8));
    qq_pcllib$pclnext = qq_pcllib$pclstart;
    qq_pcllib$pclend = ((qq_pcllib$pclstart + qq_pcllib$pclalloc) - (i64)16);
    qq_pcllib$pcllast = 0;
    qq_pcllib$pclsrcstart = (i32 *)mlib$pcm_alloc((qq_pcllib$pclalloc * (i64)4));
    qq_pcllib$pclsrcnext = qq_pcllib$pclsrcstart;
}

void qq_pcllib$genpc(i64 opc) {
    if ((qq_pcllib$pclnext >= qq_pcllib$pclend)) {
        qq_pcllib$extendpcldata();
    }
;
    (*qq_pcllib$pclnext) = opc;
    qq_pcllib$pcllast = qq_pcllib$pclnext;
    (*qq_pcllib$pclsrcnext) = qq_decls$qpos;
    ++(qq_pcllib$pclnext);
    ++(qq_pcllib$pclsrcnext);
    qq_pcllib$labelflag = (i64)0;
}

void qq_pcllib$genopnd_int(i64 x) {
    (*(qq_pcllib$pclnext)++) = x;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genopnd_name(struct qq_decls$strec *d) {
    (*(qq_pcllib$pclnext)++) = *(i64*)&d;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genpc_int(i64 opc,i64 a) {
    qq_pcllib$genpc(opc);
    (*(qq_pcllib$pclnext)++) = a;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genpc_int2(i64 opc,i64 a,i64 b) {
    qq_pcllib$genpc(opc);
    (*(qq_pcllib$pclnext)++) = a;
    (*(qq_pcllib$pclnext)++) = b;
    qq_pcllib$pclsrcnext += (i64)2;
}

void qq_pcllib$genpc_int4(i64 opc,i64 a,i64 b,i64 c,i64 d) {
    qq_pcllib$genpc(opc);
    (*(qq_pcllib$pclnext)++) = a;
    (*(qq_pcllib$pclnext)++) = b;
    (*(qq_pcllib$pclnext)++) = c;
    (*(qq_pcllib$pclnext)++) = d;
    qq_pcllib$pclsrcnext += (i64)4;
}

void qq_pcllib$genpc_name(i64 opc,struct qq_decls$strec *d) {
    if ((((((*qq_pcllib$pcllast) == (i64)14) && (opc == (i64)10)) && !(!!(qq_pcllib$labelflag))) && ((*(qq_pcllib$pcllast + (i64)1)) == *(i64*)&d))) {
        (*qq_pcllib$pcllast) = (i64)16;
        return;
    }
;
    qq_pcllib$genpc(opc);
    (*(qq_pcllib$pclnext)++) = *(i64*)&d;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genopnd_strz(u8 *s) {
    (*(qq_pcllib$pclnext)++) = *(i64*)&s;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genopnd_str(struct qq_decls$objrec *s) {
    (*(qq_pcllib$pclnext)++) = *(i64*)&s;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genopnd_obj(struct qq_decls$objrec *p) {
    (*(qq_pcllib$pclnext)++) = *(i64*)&p;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genpc_real(i64 opc,r64 x) {
    qq_pcllib$genpc(opc);
    (*(qq_pcllib$pclnext)++) = *(i64*)&x;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$genpc_lab(i64 opc,i64 a) {
    qq_pcllib$genpc(opc);
    qq_pcllib$genopnd_lab(a);
}

void qq_pcllib$genopnd_lab(i64 a) {
        i64 lastpc;
    if ((a >= (i64)0)) {
        (*(qq_pcllib$pclnext)++) = a;
        ++(qq_pcllib$pclsrcnext);
        return;
    }
;
    a = -(a);
    lastpc = (*qq_pcllib$labeloffsettable)[(a)-1];
    (*qq_pcllib$labeloffsettable)[(a)-1] = (qq_pcllib$pclnext - qq_pcllib$pclstart);
    (*(qq_pcllib$pclnext)++) = lastpc;
    ++(qq_pcllib$pclsrcnext);
}

void qq_pcllib$gencomment(u8 *s) {
    qq_pcllib$genpc((i64)7);
    qq_pcllib$genopnd_strz(mlib$pcm_copyheapstring(s));
}

u8 *qq_pcllib$getdottedname(struct qq_decls$strec *p) {
        static u8 str[256];
    strcpy((u8 *)str,(*p).name);
    return (u8 *)str;
}

static void qq_pcllib$extendpcldata(void) {
        i64 newpclalloc;
        i64 *  newpclstart;
        i32 *  newpclsrcstart;
    newpclalloc = (qq_pcllib$pclalloc * (i64)2);
    newpclstart = (i64 *)mlib$pcm_alloc(((i64)8 * newpclalloc));
    newpclsrcstart = (i32 *)mlib$pcm_alloc(((i64)4 * newpclalloc));
    memcpy(newpclstart,qq_pcllib$pclstart,(u64)((qq_pcllib$pclnext - qq_pcllib$pclstart) * (i64)8));
    memcpy(newpclsrcstart,qq_pcllib$pclsrcstart,(u64)((qq_pcllib$pclnext - qq_pcllib$pclstart) * (i64)4));
    qq_pcllib$pclnext = (newpclstart + (qq_pcllib$pclnext - qq_pcllib$pclstart));
    qq_pcllib$pclend = ((newpclstart + newpclalloc) - (i64)10);
    qq_pcllib$pcllast = (newpclstart + (qq_pcllib$pcllast - qq_pcllib$pclstart));
    qq_pcllib$pclsrcnext = (newpclsrcstart + (qq_pcllib$pclsrcnext - qq_pcllib$pclsrcstart));
    mlib$pcm_free(qq_pcllib$pclstart,(qq_pcllib$pclalloc * (i64)8));
    mlib$pcm_free(qq_pcllib$pclsrcstart,(qq_pcllib$pclalloc * (i64)4));
    qq_pcllib$pclstart = newpclstart;
    qq_pcllib$pclalloc = newpclalloc;
    qq_pcllib$pclsrcstart = newpclsrcstart;
}

void qq_pcllib$extendlabeltable(void) {
        i64 newlabelalloc;
        i64 (*newlabeltable)[];
    newlabelalloc = (qq_pcllib$labelalloc * (i64)2);
    newlabeltable = (i64 (*)[])mlib$pcm_alloc(((i64)8 * newlabelalloc));
    memcpy(newlabeltable,qq_pcllib$labeloffsettable,(u64)(qq_pcllib$labelalloc * (i64)8));
    mlib$pcm_free(qq_pcllib$labeloffsettable,(qq_pcllib$labelalloc * (i64)8));
    qq_pcllib$labeloffsettable = newlabeltable;
    qq_pcllib$labelalloc = newlabelalloc;
}

void qq_pcllib$pushint(i64 a) {
    qq_pcllib$genpc_int((i64)18,a);
}

void qq_pcllib$pushreal(r64 x) {
    qq_pcllib$genpc_int((i64)22,*(i64*)&x);
}

i64 qq_pcllib$definelabel(void) {
    if ((qq_pcllib$nextlabelno >= qq_pcllib$labelalloc)) {
        qq_pcllib$extendlabeltable();
    }
;
    ++(qq_pcllib$nextlabelno);
    (*qq_pcllib$labeloffsettable)[(qq_pcllib$nextlabelno)-1] = (qq_pcllib$pclnext - qq_pcllib$pclstart);
    qq_pcllib$labelflag = (i64)1;
    return (qq_pcllib$pclnext - qq_pcllib$pclstart);
}

i64 qq_pcllib$createfwdlabel(void) {
    if ((qq_pcllib$nextlabelno >= qq_pcllib$labelalloc)) {
        qq_pcllib$extendlabeltable();
    }
;
    ++(qq_pcllib$nextlabelno);
    (*qq_pcllib$labeloffsettable)[(qq_pcllib$nextlabelno)-1] = (i64)0;
    return -(qq_pcllib$nextlabelno);
}

void qq_pcllib$definefwdlabel(i64 *lab) {
        i64 index;
        i64 laboffset;
        i64 pc;
        i64 nextpc;
    index = (*lab);
    if ((index >= (i64)0)) {
        qq_lib$gerror((byte*)"deffwdlabel?",0);
    }
;
    index = -(index);
    laboffset = (qq_pcllib$pclnext - qq_pcllib$pclstart);
    pc = (*qq_pcllib$labeloffsettable)[(index)-1];
    L981 :;
    while (!!(pc)) {
        nextpc = (*(qq_pcllib$pclstart + pc));
        (*(qq_pcllib$pclstart + pc)) = laboffset;
        pc = nextpc;
L982 :;
    }
L983 :;
    ;
    (*qq_pcllib$labeloffsettable)[(index)-1] = laboffset;
    (*lab) = laboffset;
    qq_pcllib$labelflag = (i64)1;
}

i64 qq_pcllib$isstatic(struct qq_decls$strec *d) {
    return (i64)((i64)(*d).nameid == (i64)11);
}

void qq_records$var_make_record(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 n,i64 rectype) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  b;
        i64 m;
        i64 $av_1;
    p = qq_records$obj_new_record(rectype,0);
    b = (*p).varptr;
    m = qq_tables$ttlength[(rectype)];
    if ((n < m)) {
        qq_lib$pcerror((byte*)"Too few elements");
    }
    else if ((n > m)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"N=",NULL);
        msysc$m_print_i64(n,NULL);
        msysc$m_print_str((byte*)"M=",NULL);
        msysc$m_print_i64(m,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$pcerror((byte*)"Too many elements");
    }
;
    $av_1 = n;
    while ($av_1-- > 0) {
L984 :;
        (*b) = (*a);
        ++(a);
        ++(b);
L985 :;
    }
L986 :;
    ;
    (*dest).tagx = (i64)271;
    (*p).usertag = rectype;
    (*dest).objptr = p;
}

struct qq_decls$objrec *qq_records$obj_new_record(i64 m,struct qq_decls$varrec *defval) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  a;
        i64 n;
        i64 $av_1;
        i64 $av_2;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    n = qq_tables$ttlength[(m)];
    (*p).objtype = (i64)0;
    if (!!(n)) {
        (*p).varptr = (a = (struct qq_decls$varrec *)mlib$pcm_alloc((n * (i64)16)));
        if ((!!(defval) && ((i64)(*defval).tag != (i64)0))) {
            a = (*p).varptr;
            $av_1 = n;
            while ($av_1-- > 0) {
L987 :;
                (*a) = (*defval);
                if (!!((i64)(*a).hasref)) {
                    ++((*(*a).objptr).refcount);
                }
;
                ++(a);
L988 :;
            }
L989 :;
            ;
        }
        else {
            $av_2 = n;
            while ($av_2-- > 0) {
L990 :;
                (*a).tagx = (i64)1;
                (*a).value = (i64)0;
                ++(a);
L991 :;
            }
L992 :;
            ;
        }
;
    }
;
    return p;
}

void qq_records$obj_free_record(struct qq_decls$objrec *p) {
        struct qq_decls$varrec *  q;
        i64 $av_1;
    q = (*p).varptr;
    $av_1 = (*p).length;
    while ($av_1-- > 0) {
L993 :;
        if (!!((i64)(*q).hasref)) {
            qq_vars$var_unshareu(q);
        }
;
        ++(q);
L994 :;
    }
L995 :;
    ;
    if (!!((*p).length)) {
        mlib$pcm_free((*p).varptr,((*p).length * (i64)16));
    }
;
    mlib$pcm_free32(p);
}

void qq_records$var_dupl_record(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        struct qq_decls$varrec *  plist;
        struct qq_decls$varrec *  qlist;
        i64 length;
        i64 $av_1;
    p = (*a).objptr;
    q = qq_vars$obj_new();
    (*q) = (*p);
    (*q).refcount = (i64)1;
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)1,(u64)1u);
    (*a).objptr = q;
    length = qq_tables$ttlength[((i64)(*p).usertag)];
    if ((length == (i64)0)) {
        return;
    }
;
    qlist = ((*q).varptr = (struct qq_decls$varrec *)mlib$pcm_alloc((length * (i64)16)));
    plist = (*p).varptr;
    $av_1 = length;
    while ($av_1-- > 0) {
L996 :;
        (*qlist) = (*plist);
        if (((i64)(*qlist).tag == (i64)15)) {
            if (!!((i64)(*qlist).hasref)) {
                ++((*(*qlist).objptr).refcount);
            }
;
        }
        else {
            if (!!((i64)(*qlist).hasref)) {
                qq_vars$var_duplu(qlist);
            }
;
        }
;
        ++(qlist);
        ++(plist);
L997 :;
    }
L998 :;
    ;
}

i64 qq_records$var_equal_record(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
        struct qq_decls$varrec *  a;
        struct qq_decls$varrec *  b;
        i64 $av_1;
    px = (*x).objptr;
    py = (*y).objptr;
    if (((i64)(*px).usertag != (i64)(*py).usertag)) {
        return (i64)0;
    }
;
    if ((px == py)) {
        return (i64)1;
    }
;
    a = (*px).varptr;
    b = (*py).varptr;
    $av_1 = qq_tables$ttlength[((i64)(*px).usertag)];
    while ($av_1-- > 0) {
L999 :;
        if ((qq_vars$var_equal(a,b) == (i64)0)) {
            return (i64)0;
        }
;
        ++(a);
        ++(b);
L1000 :;
    }
L1001 :;
    ;
    return (i64)1;
}

void qq_records$var_getix_record(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  q;
        u64 offset;
    q = (*a).objptr;
    offset = (u64)(index - (i64)1);
    if ((offset >= (u64)qq_tables$ttlength[((i64)(*q).usertag)])) {
        qq_lib$pcerror((byte*)"record[int] bounds");
    }
;
    (*a) = (*((*q).varptr + (i64)offset));
    if (!!((i64)(*a).hasref)) {
        ++((*(*a).objptr).refcount);
    }
;
}

void qq_records$var_putix_record(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        struct qq_decls$varrec *  dest;
        struct qq_decls$objrec *  q;
        u64 offset;
    q = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*q).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"Not mutable");
    }
;
    offset = (u64)(index - (i64)1);
    if ((offset >= (u64)qq_tables$ttlength[((i64)(*q).usertag)])) {
        qq_lib$pcerror((byte*)"rec[int] bounds");
    }
;
    dest = ((*q).varptr + (i64)offset);
    if (!!((i64)(*dest).hasref)) {
        qq_vars$var_unshareu(dest);
    }
;
    (*dest) = (*x);
}

void qq_records$var_getixref_record(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *dest) {
        struct qq_decls$varrec *  p;
        struct qq_decls$objrec *  q;
        u64 offset;
    q = (*a).objptr;
    offset = (u64)(index - (i64)1);
    if ((offset >= (u64)(*q).length)) {
        qq_lib$pcerror((byte*)"^rec[int] bounds");
    }
;
    p = ((*q).varptr + (i64)offset);
    (*dest).tagx = (i64)17;
    (*dest).varptr = p;
}

// START
void qq_records$start(void) {

}

void qq_resolve$rx_module(i64 n) {
    qq_decls$currmodule = (struct qq_decls$modulerec *)&qq_decls$moduletable[(n)];
    qq_decls$stcurrproc = (qq_decls$stcurrmodule = (*qq_decls$currmodule).def);
    qq_resolve$nprocs = (i64)0;
    qq_resolve$rx_passdef(qq_decls$stprogram,qq_decls$stcurrmodule);
    if ((qq_resolve$nprocs == (i64)0)) {
        qq_resolve$rx_unit(qq_decls$stcurrmodule,(*qq_decls$currmodule).ast);
    }
    else if (!!((*qq_decls$currmodule).ast)) {
        qq_resolve$rx_unit(qq_decls$stcurrmodule,(*qq_decls$currmodule).ast);
    }
;
}

void qq_resolve$rx_passdef(struct qq_decls$strec *owner,struct qq_decls$strec *p) {
        {i64 $temp = (i64)(*p).nameid;
if (($temp==(i64)3) || ($temp==(i64)4)) {
        qq_resolve$rx_deflist(p,(*p).deflist);
    }
    else if (($temp==(i64)5)) {
        ++(qq_resolve$nprocs);
        qq_resolve$fixmode((struct qq_decls$strec *)owner,(struct qq_decls$strec *)p);
        qq_resolve$rx_deflist(p,(*p).deflist);
        qq_decls$stcurrproc = p;
        qq_resolve$rx_unit(p,(*p).code);
        qq_decls$stcurrproc = qq_decls$stcurrmodule;
    }
    else if (($temp==(i64)6)) {
        qq_resolve$fixmode((struct qq_decls$strec *)owner,(struct qq_decls$strec *)p);
        qq_resolve$rx_deflist(p,(*p).deflist);
    }
    else if (($temp==(i64)16) || ($temp==(i64)11) || ($temp==(i64)12) || ($temp==(i64)13)) {
        qq_resolve$fixmode((struct qq_decls$strec *)owner,(struct qq_decls$strec *)p);
        if (!!((*p).code)) {
            qq_resolve$rx_unit(owner,(*p).code);
        }
;
    }
    else if (($temp==(i64)8) || ($temp==(i64)7)) {
        qq_resolve$fixmode((struct qq_decls$strec *)owner,(struct qq_decls$strec *)p);
        qq_resolve$rx_deflist(p,(*p).deflist);
    }
    };
}

void qq_resolve$rx_deflist(struct qq_decls$strec *owner,struct qq_decls$strec *p) {
    L1002 :;
    while (!!(p)) {
        qq_resolve$rx_passdef(owner,p);
        p = (*p).nextdef;
L1003 :;
    }
L1004 :;
    ;
}

void qq_resolve$rx_unit(struct qq_decls$strec *owner,struct qq_decls$unitrec *p) {
        struct qq_decls$strec *  d;
        struct qq_decls$unitrec *  a;
        struct qq_decls$unitrec *  b;
        i64 n;
        i64 flags;
        i64 oldnoexpand;
        i64 oldsymbolmode;
        i64 nk;
    a = (*p).a;
    b = (*p).b;
    qq_decls$qpos = (i64)(*p).pos;
    switch ((i64)(*p).tag) {
    case 47:;
        {
            qq_resolve$resolvename(owner,p,(i64)0);
            if (((((i64)(*p).tag == (i64)47) && ((i64)(*(*p).def).nameid == (i64)20)) && !(!!(qq_resolve$noexpand)))) {
                ++(qq_resolve$macrolevels);
                qq_resolve$expandmacro(p,p,0);
                qq_resolve$rx_unit(owner,p);
                --(qq_resolve$macrolevels);
            }
;
        }
        break;
    case 4:;
        {
            qq_resolve$rx_unit(owner,b);
        }
        break;
    case 59:;
        {
            qq_resolve$resolvedot(owner,p);
        }
        break;
    case 32:;
        {
            if (((i64)(*a).tag == (i64)47)) {
                oldnoexpand = qq_resolve$noexpand;
                qq_resolve$noexpand = (i64)1;
                qq_resolve$rx_unit(owner,a);
                qq_resolve$noexpand = oldnoexpand;
            }
            else {
                qq_resolve$rx_unit(owner,a);
            }
;
            qq_resolve$rx_unitlist(owner,b);
            if (((i64)(*a).tag == (i64)41)) {
                (*p).tag = (i64)43;
                (*p).a = b;
                (*p).b = 0;
                (*p).mode = (i64)(*a).mode;
                if (((i64)qq_tables$ttbasetype[((i64)(*a).mode)] == (i64)7)) {
                }
                else {
                    nk = (i64)0;
                    (*p).a = qq_lib$createunit1((i64)197,b);
                    n = (i64)0;
                    L1005 :;
                    while (!!(b)) {
                        if (((i64)(*b).tag == (i64)4)) {
                            ++(nk);
                            (*b).tag = (i64)5;
                        }
;
                        ++(n);
                        b = (*b).nextunit;
L1006 :;
                    }
L1007 :;
                    ;
                    if ((!!(nk) && (nk != n))) {
                        qq_lib$rxerror((byte*)"Mixed key:value",0);
                    }
;
                    if (!!((*a).nextunit)) {
                        n = -(n);
                    }
;
                    (*(*p).a).length = n;
                }
;
            }
            else if ((((i64)(*a).tag == (i64)47) && ((i64)(*(*a).def).nameid == (i64)20))) {
                ++(qq_resolve$macrolevels);
                qq_resolve$expandmacro(p,a,b);
                qq_resolve$rx_unit(owner,p);
                --(qq_resolve$macrolevels);
            }
;
        }
        break;
    case 149:;
    case 150:;
    case 151:;
    case 152:;
    case 153:;
    case 154:;
    case 156:;
    case 157:;
    case 158:;
    case 159:;
    case 160:;
    case 195:;
        {
            qq_resolve$rx_unit(owner,a);
            if (!(!!(b))) {
                qq_lib$rxerror((byte*)"Binop missing opnd",0);
            }
;
            qq_resolve$rx_unit(owner,b);
            qq_resolve$evalbinop(p,a,b);
        }
        break;
    case 89:;
    case 90:;
    case 118:;
    case 119:;
    case 120:;
    case 124:;
    case 96:;
        {
            qq_resolve$rx_unit(owner,a);
            qq_resolve$evalmonop(p);
        }
        break;
    case 17:;
    case 19:;
        {
            qq_resolve$resolvename(owner,a,(i64)1);
            a = (*a).nextunit;
            goto L1008 ;
;
        }
        break;
    case 43:;
        {
            qq_resolve$rx_unit(owner,a);
            qq_resolve$evalmonop(p);
        }
        break;
    case 48:;
        {
            oldnoexpand = qq_resolve$noexpand;
            oldsymbolmode = qq_resolve$symbolmode;
            qq_resolve$noexpand = (i64)1;
            qq_resolve$symbolmode = (i64)1;
            qq_resolve$rx_unit(owner,a);
            qq_resolve$noexpand = oldnoexpand;
            qq_resolve$symbolmode = oldsymbolmode;
                        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)47)) {
            }
            else if (($temp==(i64)41)) {
                d = qq_tables$ttnamedef[((i64)(*a).mode)];
                if (!!(d)) {
                    (*a).def = d;
                    (*a).tag = (i64)47;
                }
                else {
                    qq_lib$rxerror((byte*)"T.$?",0);
                }
;
            }
            else {
                qq_dummyshow$printunit((struct qq_decls$unitrec *)a,(i64)0,(byte*)"*",0);
                qq_lib$rxerror((byte*)".$ not name",0);
            }
            };
        }
        break;
    case 58:;
        {
            qq_resolve$rx_unit(owner,a);
            if (((i64)(*a).tag != (i64)57)) {
                qq_lib$rxerror((byte*)"Not strconst",0);
            }
;
            n = qq_modules$getsupportfile((*a).svalue,(byte*)"",qq_decls$sourcefilepaths[((i64)qq_decls$moduletable[(msysc$m_getdotslice((i64)(*p).pos,(i64)24,(i64)31))].fileno)-1],(i64)0,(i64)1);
            (*a).svalue = qq_decls$sourcefiletext[(n)-1];
            (*a).slength = qq_decls$sourcefilesizes[(n)-1];
            qq_lib$deleteunit(p,a);
        }
        break;
    default: {
        //doabc:
L1008 :;
;
        flags = (i64)qq_tables$jflags[((i64)(*p).tag)];
        if ((flags >= (i64)1)) {
            qq_resolve$rx_unitlist(owner,a);
        }
;
        if ((flags == (i64)2)) {
            qq_resolve$rx_unitlist(owner,b);
        }
;
    }
    } //SW
;
}

static void qq_resolve$rx_unitlist(struct qq_decls$strec *owner,struct qq_decls$unitrec *p) {
    L1009 :;
    while (!!(p)) {
        qq_resolve$rx_unit(owner,p);
        p = (*p).nextunit;
L1010 :;
    }
L1011 :;
    ;
}

static void qq_resolve$evalmonop(struct qq_decls$unitrec *p) {
        i64 a;
        i64 c;
        r64 x;
        r64 z;
        {i64 $temp = (i64)(*p).tag;
if (($temp==(i64)118) || ($temp==(i64)120) || ($temp==(i64)119)) {
    }
    else if (($temp==(i64)124)) {
        if (((i64)(*(*p).a).tag == (i64)41)) {
            c = qq_tables$ttsize[((i64)(*(*p).a).mode)];
            goto L1012 ;
;
        }
;
    }
    else {
                {i64 $temp = (i64)(*(*p).a).tag;
if (($temp==(i64)50)) {
            a = (*(*p).a).value;
            switch ((i64)(*p).tag) {
            case 89:;
                {
                    c = -(a);
                }
                break;
            case 90:;
                {
                    c = m$llabs(a);
                }
                break;
            default: {
                return;
            }
            } //SW
;
            //newint:
L1012 :;
;
            qq_resolve$makeintconst((struct qq_decls$unitrec *)p,c);
        }
        else if (($temp==(i64)54)) {
            x = (*(*p).a).xvalue;
            switch ((i64)(*p).tag) {
            case 89:;
                {
                    z = -(x);
                }
                break;
            case 90:;
                {
                    z = fabs(x);
                }
                break;
            default: {
                return;
            }
            } //SW
;
            qq_resolve$makerealconst((struct qq_decls$unitrec *)p,z);
        }
        else {
            return;
        }
        };
    }
    };
}

static void qq_resolve$evalbinop(struct qq_decls$unitrec *p,struct qq_decls$unitrec *lhs,struct qq_decls$unitrec *rhs) {
        i64 a;
        i64 b;
        i64 c;
        r64 x;
        r64 y;
        r64 z;
        {i64 $temp = (((i64)(*lhs).tag << (i64)16) | (i64)(*rhs).tag);
if (($temp==(i64)3276850)) {
        a = (*lhs).value;
        b = (*rhs).value;
        switch ((i64)(*p).tag) {
        case 149:;
            {
                c = (a + b);
            }
            break;
        case 150:;
            {
                c = (a - b);
            }
            break;
        case 151:;
            {
                c = (a * b);
            }
            break;
        case 153:;
            {
                c = (a / b);
            }
            break;
        default: {
            return;
        }
        } //SW
;
        qq_resolve$makeintconst((struct qq_decls$unitrec *)p,c);
    }
    else if (($temp==(i64)3538998)) {
        x = (*lhs).xvalue;
        y = (*rhs).xvalue;
        switch ((i64)(*p).tag) {
        case 149:;
            {
                z = (x + y);
            }
            break;
        case 150:;
            {
                z = (x - y);
            }
            break;
        case 151:;
            {
                z = (x * y);
            }
            break;
        case 152:;
            {
                z = (x / y);
            }
            break;
        default: {
            return;
        }
        } //SW
;
        qq_resolve$makerealconst((struct qq_decls$unitrec *)p,z);
    }
    else {
        return;
    }
    };
}

static void qq_resolve$makeintconst(struct qq_decls$unitrec *p,i64 value) {
    (*p).tag = (i64)50;
    (*p).a = ((*p).b = 0);
    (*p).value = value;
    (*p).mode = (i64)1;
}

static void qq_resolve$makerealconst(struct qq_decls$unitrec *p,r64 xvalue) {
    (*p).tag = (i64)54;
    (*p).a = ((*p).b = 0);
    (*p).xvalue = xvalue;
    (*p).mode = (i64)3;
}

void qq_resolve$resolvename(struct qq_decls$strec *owner,struct qq_decls$unitrec *p,i64 mode) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
        struct qq_decls$unitrec *  q;
        i64 moduleno;
    d = (*p).def;
    moduleno = msysc$m_getdotslice((i64)(*p).pos,(i64)24,(i64)31);
    if (((i64)(*d).nameid != (i64)0)) {
        return;
    }
;
    e = qq_resolve$resolvetopname(owner,d,moduleno,qq_resolve$allowmodname);
    if (!(!!(e))) {
                {i64 $temp = (i64)(*owner).nameid;
if (($temp==(i64)5)) {
            e = ((*p).def = qq_names$addsymbol(owner,d,(i64)12,(i64)0));
            (*e).mode = (i64)27;
        }
        else if (($temp==(i64)3)) {
            e = ((*p).def = qq_names$addsymbol(owner,d,(i64)11,(i64)0));
            (*e).mode = (i64)27;
        }
        else {
            qq_lib$rxerror_s((byte*)"Undefined: #",(*d).name,p);
        }
        };
    }
    else {
        //$else:
L1013 :;
;
        //retry:
L1014 :;
;
        (*p).def = e;
                {i64 $temp = (i64)(*e).nameid;
if (($temp==(i64)16)) {
            if (!!(qq_resolve$symbolmode)) {
                return;
            }
;
            q = (*e).code;
            qq_resolve$rx_unit(owner,q);
            if (!(((i64)(*q).tag == (i64)50 || (i64)(*q).tag == (i64)54 || (i64)(*q).tag == (i64)57))) {
                qq_lib$rxerror_s((byte*)"Not const expr: #",qq_tables$jtagnames[((i64)(*q).tag)],0);
            }
;
            (*e).mode = (i64)(*q).mode;
            (*p).tag = (i64)(*q).tag;
            (*p).value = (*q).value;
            (*p).mode = (i64)(*q).mode;
            (*p).slength = (*q).slength;
        }
        else if (($temp==(i64)17)) {
            if (!!(qq_resolve$symbolmode)) {
                return;
            }
;
            if (((i64)(*e).mode == (i64)0)) {
                (*p).tag = (i64)50;
                (*p).value = (*e).index;
                (*p).mode = (i64)1;
            }
            else {
                (*p).tag = (i64)56;
                (*p).value = (*e).index;
                (*p).mode = (i64)(*e).mode;
            }
;
        }
        else if (($temp==(i64)11)) {
        }
        else if (($temp==(i64)8) || ($temp==(i64)7)) {
            (*p).tag = (i64)41;
            (*p).mode = (i64)(*(*p).def).mode;
        }
        else if (($temp==(i64)19)) {
            qq_lib$rxerror((byte*)"FOUND LINK",p);
        }
        };
    }
;
}

struct qq_decls$strec *qq_resolve$resolvetopname(struct qq_decls$strec *owner,struct qq_decls$strec *stnewname,i64 moduleno,i64 allowmod) {
        i64 extcount;
        i64 subprogno;
        struct qq_decls$strec *  p;
        struct qq_decls$strec *  q;
        struct qq_decls$strec *  powner;
        struct qq_decls$strec *  extdef;
        struct qq_decls$strec *  moddef;
        struct qq_decls$strec *  ambiglist[10];
        i64 i;
    if (((i64)(*owner).nameid == (i64)5)) {
        q = (*owner).deflist;
        L1015 :;
        while (!!(q)) {
            if (((*q).firstdupl == stnewname)) {
                return q;
            }
;
L1016 :;
            q = (*q).nextdef;
L1018 :;
                    }
L1017 :;
        ;
    }
;
    p = (*stnewname).nextdupl;
    subprogno = (i64)qq_decls$moduletosub[(moduleno)];
    extcount = (i64)0;
    extdef = (moddef = 0);
    L1019 :;
    while (!!(p)) {
        powner = (*p).owner;
        switch ((i64)(*powner).nameid) {
        case 3:;
            {
                if (((i64)(*powner).moduleno == moduleno)) {
                    return p;
                }
                else if (!!(msysc$m_getdotslice((i64)(*p).flags,(i64)0,(i64)1))) {
                    if (((((i64)qq_decls$moduletosub[((i64)(*powner).moduleno)] == subprogno) || ((i64)msysc$m_getdotslice((i64)(*p).flags,(i64)0,(i64)1) == (i64)2)) || !!(msysc$m_getdotindex((i64)(*p).flags,(i64)2)))) {
                        ++(extcount);
                        extdef = p;
                        if ((extcount < (i64)10)) {
                            ambiglist[(extcount)-1] = extdef;
                        }
;
                    }
;
                }
;
            }
            break;
        case 8:;
            {
                if (((powner == owner) || (powner == (*owner).owner))) {
                    return p;
                }
;
            }
            break;
        case 1:;
            {
                                {i64 $temp = (i64)(*p).nameid;
if (($temp==(i64)3) || ($temp==(i64)2)) {
                    if (!!(allowmod)) {
                        moddef = p;
                    }
;
                }
                else if (($temp==(i64)20)) {
                    return p;
                }
                };
            }
            break;
        } //SW
;
L1020 :;
        p = (*p).nextdupl;
L1022 :;
            }
L1021 :;
    ;
    if (!!(extdef)) {
        if ((extcount > (i64)1)) {
            for (i=(i64)1;i<=extcount;++i) {
L1023 :;
                extdef = ambiglist[(i)-1];
                msysc$m_print_startcon();
                msysc$m_print_i64(i,NULL);
                msysc$m_print_str((*(*extdef).owner).name,NULL);
                msysc$m_print_str(qq_tables$namenames[((i64)(*(*extdef).owner).nameid)],NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
L1024 :;
            }
L1025 :;
            ;
            qq_lib$rxerror_s((byte*)"Ambiguous ext name: #",(*extdef).name,0);
        }
;
        return extdef;
    }
;
    return moddef;
}

static void qq_resolve$resolvedot(struct qq_decls$strec *owner,struct qq_decls$unitrec *p) {
        struct qq_decls$strec *  rdef;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  newd;
        struct qq_decls$strec *  e;
        struct qq_decls$strec *  fielddef;
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
        i64 nfields;
        i64 oldallowmod;
    if (!!(qq_resolve$symbolmode)) {
        qq_resolve$resolvedot_sym(owner,p);
        return;
    }
;
    q = (*p).a;
    r = (*p).b;
    rdef = (*r).def;
    oldallowmod = qq_resolve$allowmodname;
    qq_resolve$allowmodname = (i64)((i64)(*q).tag == (i64)47);
    qq_resolve$rx_unit(owner,q);
    qq_resolve$allowmodname = oldallowmod;
        {i64 $temp = (i64)(*q).tag;
if (($temp==(i64)47)) {
        d = (*q).def;
    }
    else if (($temp==(i64)41)) {
        d = (*q).def;
        goto L1026 ;
;
    }
    else {
        rdef = (*r).def;
        goto L1027 ;
;
    }
    };
    switch ((i64)(*d).nameid) {
    case 4:;
    case 3:;
    case 8:;
    case 5:;
    case 6:;
        {
            //dotype:
L1026 :;
;
            newd = qq_resolve$finddupl(d,rdef);
            if (!!(newd)) {
                switch ((i64)(*newd).nameid) {
                case 17:;
                    {
                        (*p).tag = (i64)50;
                        (*p).value = (*newd).index;
                        (*p).mode = (i64)1;
                    }
                    break;
                case 16:;
                    {
                        q = (*newd).code;
                                                {i64 $temp = (i64)(*q).tag;
if (($temp==(i64)50)) {
                            (*p).tag = (i64)50;
                            (*p).a = ((*p).b = 0);
                            (*p).value = (*q).value;
                            (*p).mode = (i64)(*newd).mode;
                        }
                        else {
                            qq_lib$rxerror((byte*)"Rxdot:const?",p);
                        }
                        };
                    }
                    break;
                case 8:;
                    {
                        (*p).tag = (i64)41;
                        (*p).mode = (i64)(*newd).mode;
                        (*p).def = newd;
                    }
                    break;
                case 11:;
                    {
                        (*p).tag = (i64)47;
                        (*p).def = newd;
                    }
                    break;
                case 5:;
                case 6:;
                    {
                        (*p).tag = (i64)47;
                        (*p).a = ((*p).b = 0);
                        (*p).def = newd;
                    }
                    break;
                case 20:;
                    {
                        if ((((i64)(*e).nameid == (i64)20) && !(!!(qq_resolve$noexpand)))) {
                            ++(qq_resolve$macrolevels);
                            qq_resolve$expandmacro(p,p,0);
                            qq_resolve$rx_unit(owner,p);
                            --(qq_resolve$macrolevels);
                        }
;
                    }
                    break;
                default: {
                    msysc$m_print_startcon();
                    msysc$m_print_str(qq_tables$namenames[((i64)(*newd).nameid)],NULL);
                    msysc$m_print_nogap();
                    msysc$m_print_str((byte*)".",NULL);
                    msysc$m_print_nogap();
                    msysc$m_print_str((*newd).name,NULL);
                    msysc$m_print_newline();
                    msysc$m_print_end();
                    ;
                    qq_lib$rxerror((byte*)"Rxdot:.name not allowed here",p);
                }
                } //SW
;
            }
            else {
                msysc$m_print_startcon();
                msysc$m_print_str((*d).name,NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((byte*)".",NULL);
                msysc$m_print_nogap();
                msysc$m_print_str((*rdef).name,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                qq_lib$rxerror((byte*)"Can't resolve",p);
            }
;
        }
        break;
    case 12:;
    case 11:;
    case 13:;
    case 9:;
    case 10:;
        {
            //doexprdot:
L1027 :;
;
            nfields = (i64)0;
            fielddef = 0;
            e = (*rdef).nextdupl;
            L1028 :;
            while (!!(e)) {
                                {i64 $temp = (i64)(*e).nameid;
if (($temp==(i64)9) || ($temp==(i64)10) || ($temp==(i64)16) || ($temp==(i64)5) || ($temp==(i64)8) || ($temp==(i64)11) || ($temp==(i64)6)) {
                    ++(nfields);
                    fielddef = e;
                }
                };
                e = (*e).nextdupl;
L1029 :;
            }
L1030 :;
            ;
            if ((nfields==(i64)0)) {
                msysc$m_print_startcon();
                msysc$m_print_str((*rdef).name,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                qq_lib$rxerror((byte*)"Can't find field",0);
            }
            else {
                if (((i64)(*rdef).nameid != (i64)0)) {
                    qq_lib$rxerror((byte*)"Field name not generic",0);
                }
;
            }
;
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_str(qq_tables$namenames[((i64)(*d).nameid)],NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$rxerror((byte*)"RXDOT:Unknown nameid",p);
    }
    } //SW
;
}

static void qq_resolve$resolvedot_sym(struct qq_decls$strec *owner,struct qq_decls$unitrec *p) {
        struct qq_decls$strec *  rdef;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  newd;
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  r;
        i64 oldallowmod;
    q = (*p).a;
    r = (*p).b;
    rdef = (*r).def;
    oldallowmod = qq_resolve$allowmodname;
    qq_resolve$allowmodname = (i64)((i64)(*q).tag == (i64)47);
    qq_resolve$rx_unit(owner,q);
    qq_resolve$allowmodname = oldallowmod;
        {i64 $temp = (i64)(*q).tag;
if (($temp==(i64)47)) {
        d = (*q).def;
    }
    else if (($temp==(i64)41)) {
        d = (*q).def;
        if (!!(qq_resolve$symbolmode)) {
            newd = qq_resolve$finddupl(d,rdef);
            if ((newd == 0)) {
                qq_lib$rxerror_s((byte*)"Can't resolve .",(*rdef).name,0);
            }
;
                        {i64 $temp = (i64)(*newd).nameid;
if (($temp==(i64)9) || ($temp==(i64)10)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"*******FIELD.$",NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
            }
            else {
                qq_lib$rxerror_s((byte*)".$ ON type:",qq_tables$namenames[((i64)(*newd).nameid)],0);
            }
            };
        }
;
        goto L1031 ;
;
    }
    else {
        qq_lib$rxerror((byte*)"RXDOTSYM?",0);
    }
    };
    switch ((i64)(*d).nameid) {
    case 4:;
    case 3:;
    case 8:;
    case 5:;
    case 6:;
        {
            //dotype:
L1031 :;
;
            newd = qq_resolve$finddupl(d,rdef);
            if (!!(newd)) {
                (*p).tag = (i64)47;
                (*p).a = ((*p).b = 0);
                (*p).def = newd;
            }
            else {
                qq_lib$rxerror_s((byte*)".$ Can't resolve",(*d).name,0);
            }
;
        }
        break;
    default: {
        qq_lib$rxerror_s((byte*)"RX.$: Unknown nameid:",qq_tables$namenames[((i64)(*d).nameid)],p);
    }
    } //SW
;
}

struct qq_decls$strec *qq_resolve$finddupl(struct qq_decls$strec *d,struct qq_decls$strec *pdupl) {
    if (((i64)(*pdupl).nameid != (i64)0)) {
        return pdupl;
    }
;
    pdupl = (*pdupl).nextdupl;
    L1032 :;
    while (!!(pdupl)) {
        if (((*pdupl).owner == d)) {
            return pdupl;
        }
;
        pdupl = (*pdupl).nextdupl;
L1033 :;
    }
L1034 :;
    ;
    return (struct qq_decls$strec *)0;
}

static void qq_resolve$expandmacro(struct qq_decls$unitrec *p,struct qq_decls$unitrec *a,struct qq_decls$unitrec *b) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  pm;
        struct qq_decls$unitrec *  pnew;
        i64 ignoreargs;
    if ((qq_resolve$macrolevels > (i64)10)) {
        qq_lib$rxerror((byte*)"Too many macro levels (recursive macro?)",0);
    }
;
    d = (*a).def;
    pm = (*d).deflist;
    qq_resolve$nmacroparams = (i64)0;
    L1035 :;
    while (!!(pm)) {
        if ((qq_resolve$nmacroparams >= (i64)50)) {
            qq_lib$rxerror((byte*)"macro param overflow",0);
        }
;
        qq_resolve$macroparams[(++(qq_resolve$nmacroparams))-1] = pm;
        qq_resolve$macroparamsgen[(qq_resolve$nmacroparams)-1] = (*pm).firstdupl;
        pm = (*pm).nextdef;
L1036 :;
    }
L1037 :;
    ;
    qq_resolve$nmacroargs = (i64)0;
    L1038 :;
    while (!!(b)) {
        if ((qq_resolve$nmacroargs >= (i64)50)) {
            qq_lib$rxerror((byte*)"macro arg overflow",0);
        }
;
        qq_resolve$macroargs[(++(qq_resolve$nmacroargs))-1] = b;
        b = (*b).nextunit;
L1039 :;
    }
L1040 :;
    ;
    if ((qq_resolve$nmacroargs < qq_resolve$nmacroparams)) {
        qq_lib$rxerror((byte*)"Too few macro args",0);
    }
;
    ignoreargs = (i64)0;
    if (((qq_resolve$nmacroargs > (i64)0) && (qq_resolve$nmacroparams == (i64)0))) {
        ignoreargs = (i64)1;
        qq_resolve$nmacroargs = (qq_resolve$nmacroparams = (i64)0);
    }
    else if ((qq_resolve$nmacroargs > qq_resolve$nmacroparams)) {
        qq_lib$rxerror((byte*)"Too many macro args",0);
    }
;
    pnew = qq_resolve$copyunit((*d).code);
    if (!(!!(ignoreargs))) {
        qq_resolve$replaceunit(p,pnew);
    }
    else {
        (*p).a = pnew;
    }
;
}

static struct qq_decls$unitrec *qq_resolve$copylistunit(struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  q;
        struct qq_decls$unitrec *  plist;
        struct qq_decls$unitrec *  plistx;
    plist = (plistx = 0);
    L1041 :;
    while (!!(p)) {
        q = qq_resolve$copyunit(p);
        qq_lib$addlistunit(&plist,&plistx,q);
        p = (*p).nextunit;
L1042 :;
    }
L1043 :;
    ;
    return plist;
}

static struct qq_decls$unitrec *qq_resolve$copyunit(struct qq_decls$unitrec *p) {
        struct qq_decls$unitrec *  q;
        struct qq_decls$strec *  d;
        i64 i;
    if ((p == 0)) {
        return 0;
    }
;
    if (((i64)(*p).tag == (i64)47)) {
        d = (*p).def;
        for (i=(i64)1;i<=qq_resolve$nmacroparams;++i) {
L1044 :;
            if ((qq_resolve$macroparamsgen[(i)-1] == d)) {
                return qq_resolve$copyunit(qq_resolve$macroargs[(i)-1]);
                goto L1046 ;
            }
;
L1045 :;
        }
L1046 :;
        ;
    }
;
    q = qq_lib$createunit0((i64)(*p).tag);
    (*q) = (*p);
    (*q).nextunit = 0;
    if (!!((i64)qq_tables$jflags[((i64)(*q).tag)])) {
        (*q).a = qq_resolve$copylistunit((*q).a);
        if (((i64)qq_tables$jflags[((i64)(*q).tag)] == (i64)2)) {
            (*q).b = qq_resolve$copylistunit((*q).b);
        }
;
    }
;
    return q;
}

static void qq_resolve$replaceunit(struct qq_decls$unitrec *p,struct qq_decls$unitrec *q) {
        struct qq_decls$unitrec *  pnext;
    pnext = (*p).nextunit;
    (*p) = (*q);
    (*p).nextunit = pnext;
}

static void qq_resolve$fixmode(struct qq_decls$strec *owner,struct qq_decls$strec *p) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
        i64 m;
    m = (i64)(*p).mode;
    if ((m >= (i64)0)) {
        return;
    }
;
    m = -(m);
    if (!!(qq_tables$ttxmap[(m)])) {
        (*p).mode = qq_tables$ttxmap[(m)];
        return;
    }
;
    if (!!(qq_tables$ttnamedefx2[(m)])) {
        qq_lib$rxerror((byte*)"Can't resolve a:b tentative types yet",0);
    }
;
    d = (struct qq_decls$strec *)qq_tables$ttnamedefx[(m)];
    e = (struct qq_decls$strec *)qq_resolve$resolvetopname((struct qq_decls$strec *)owner,(struct qq_decls$strec *)d,(i64)qq_tables$ttxmoduleno[(m)],(i64)0);
    if (!!(e)) {
        qq_tables$ttxmap[(m)] = (i64)(*e).mode;
        (*p).mode = (i64)(*e).mode;
    }
    else {
        qq_lib$rxerror_s((byte*)"Can't resolve tentative type: #",(*d).name,0);
    }
;
}

static i64 qq_resolve$fixmode2(struct qq_decls$strec *owner,i64 m) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
        u8 str[256];
    if ((m >= (i64)0)) {
        return m;
    }
;
    m = -(m);
    if (!!(qq_tables$ttxmap[(m)])) {
        return qq_tables$ttxmap[(m)];
    }
;
    if (!!(qq_tables$ttnamedefx2[(m)])) {
        qq_lib$rxerror((byte*)"2:Can't resolve a:b tentative types yet",0);
    }
;
    d = (struct qq_decls$strec *)qq_tables$ttnamedefx[(m)];
    if ((owner == 0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((*d).name,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$rxerror((byte*)"FIXMODE2 OWNER=0",0);
    }
;
    e = (struct qq_decls$strec *)qq_resolve$resolvetopname((struct qq_decls$strec *)owner,(struct qq_decls$strec *)d,(i64)qq_tables$ttxmoduleno[(m)],(i64)0);
    if (!!(e)) {
        qq_tables$ttxmap[(m)] = (i64)(*e).mode;
        return (i64)(*e).mode;
    }
    else {
        msysc$m_print_startstr(str);
        msysc$m_print_setfmt((byte*)"# in module #, line:#");
        msysc$m_print_str((*d).name,NULL);
        msysc$m_print_str(qq_decls$moduletable[((i64)qq_tables$ttxmoduleno[(m)])].name,NULL);
        msysc$m_print_end();
        ;
        qq_lib$rxerror_s((byte*)"2:Can't resolve tentative type: #",(u8 *)str,0);
    }
;
    return (i64)0;
}

void qq_resolve$fixusertypes(void) {
        struct qq_decls$userxrec *  p;
        i64 m;
        i64 rescan;
        i64 i;
    for (i=(i64)1;i<=(i64)2;++i) {
L1047 :;
        p = (struct qq_decls$userxrec *)qq_tables$userxmodelist;
        rescan = (i64)0;
        L1050 :;
        while (!!(p)) {
            m = (i64)(*(*p).pmode);
            if ((m < (i64)0)) {
                m = qq_resolve$fixmode2((struct qq_decls$strec *)(*p).owner,m);
                if ((((m < (i64)0) && (i == (i64)2)) && !!(qq_tables$ttxmap[(m$llabs(m))]))) {
                    m = qq_tables$ttxmap[(m$llabs(m))];
                }
;
                if ((m < (i64)0)) {
                    rescan = (i64)1;
                }
                else {
                    (*(*p).pmode) = m;
                    if (((i64)qq_tables$tttarget[(m)] == m)) {
                        msysc$m_print_startcon();
                        msysc$m_print_str((byte*)"TTNAME[M]=",NULL);
                        msysc$m_print_str(qq_tables$ttname[(m)],NULL);
                        msysc$m_print_newline();
                        msysc$m_print_end();
                        ;
                        qq_lib$rxerror((byte*)"RECURSIVE TYPE?",0);
                    }
;
                }
;
            }
;
            p = (struct qq_decls$userxrec *)(*p).nextmode;
L1051 :;
        }
L1052 :;
        ;
        if (!(!!(rescan))) {
            goto L1049 ;
        }
;
L1048 :;
    }
L1049 :;
    ;
    if (!!(rescan)) {
        qq_lib$rxerror((byte*)"FIXUSERTYPES PHASE ERROR",0);
    }
;
    for (i=(i64)1;i<=qq_decls$nbaseclasses;++i) {
L1053 :;
        qq_resolve$dobaseclass(i);
L1054 :;
    }
L1055 :;
    ;
}

void qq_resolve$tx_typetable(void) {
        i64 i;
    for (i=(i64)43;i<=qq_tables$ntypes;++i) {
L1056 :;
        qq_resolve$converttype(i);
L1057 :;
    }
L1058 :;
    ;
}

static i64 qq_resolve$getconstint(struct qq_decls$strec *owner,struct qq_decls$unitrec *a,i64 ownerid) {
    if ((a == 0)) {
        qq_lib$rxerror((byte*)"GETCONSTINT A=NIL",0);
    }
;
    qq_resolve$rx_unit(owner,a);
        {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)50)) {
        return (*a).value;
    }
    else if (($temp==(i64)54)) {
        return (i64)(*a).xvalue;
    }
    else if (($temp==(i64)119) || ($temp==(i64)120) || ($temp==(i64)118)) {
        goto L1059 ;
;
    }
    else {
        //$else:
L1059 :;
;
        qq_lib$rxerror_s((byte*)"Getconstint: not int/real",qq_tables$jtagnames[((i64)(*a).tag)],0);
    }
    };
    return (i64)0;
}

void qq_resolve$converttype(i64 m) {
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  f;
        struct qq_decls$strec *  owner;
        i64 index;
        i64 elemtype;
        i64 nbits;
        struct qq_decls$strec *  fieldlist[257];
        i64 ownerid;
        i64 maxalign;
        i64 nfields;
        i64 size;
        struct qq_decls$unitrec *  plength;
        struct qq_decls$unitrec *  plower;
    if (!!(qq_tables$ttsize[(m)])) {
        return;
    }
;
    owner = qq_tables$ttowner[(m)];
    if ((owner == 0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"TTNAMEDEF[M]=",NULL);
        msysc$m_print_ptr(qq_tables$ttnamedef[(m)],NULL);
        msysc$m_print_str(qq_dummyshow$strmode(m,(i64)0),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"CONVTYPE OWNER=NIL",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    plower = qq_tables$ttlowerexpr[(m)];
    plength = qq_tables$ttlengthexpr[(m)];
        {i64 $temp = (i64)qq_tables$ttbasetype[(m)];
if (($temp==(i64)38) || ($temp==(i64)39)) {
        qq_tables$ttsize[(m)] = (qq_tables$ttlength[(m)] = qq_resolve$getconstint(owner,plength,(i64)0));
    }
    else if (($temp==(i64)10)) {
        if ((m == (i64)14)) {
            msysc$m_print_startcon();
            msysc$m_print_str((byte*)"CT:ARRAY/ARRAY",NULL);
            msysc$m_print_newline();
            msysc$m_print_end();
            ;
        }
;
        if (!!(qq_tables$ttowner[(m)])) {
            ownerid = (i64)(*qq_tables$ttowner[(m)]).nameid;
        }
        else {
            ownerid = (i64)0;
        }
;
        if (!!(plower)) {
            qq_tables$ttlower[(m)] = qq_resolve$getconstint(owner,plower,ownerid);
        }
        else {
            qq_tables$ttlower[(m)] = (i64)1;
        }
;
        if (!!(plength)) {
            qq_tables$ttlength[(m)] = qq_resolve$getconstint(owner,plength,ownerid);
        }
        else {
            qq_tables$ttlength[(m)] = (i64)0;
        }
;
        elemtype = (i64)qq_tables$tttarget[(m)];
        if ((elemtype==(i64)35) || (elemtype==(i64)36) || (elemtype==(i64)37)) {
            nbits = (qq_tables$ttlength[(m)] * (i64)qq_tables$ttbitwidth[((i64)qq_tables$tttarget[(m)])]);
            qq_tables$ttsize[(m)] = (((nbits - (i64)1) / (i64)8) + (i64)1);
        }
        else {
            qq_resolve$converttype((i64)qq_tables$tttarget[(m)]);
            qq_tables$ttsize[(m)] = (qq_tables$ttlength[(m)] * qq_tables$ttsize[((i64)qq_tables$tttarget[(m)])]);
        }
;
    }
    else if (($temp==(i64)16)) {
        d = qq_tables$ttnamedef[(m)];
        f = (*d).deflist;
        nfields = (i64)0;
        L1060 :;
        while (!!(f)) {
            if ((nfields >= (i64)256)) {
                qq_lib$rxerror((byte*)"Too many fields",0);
            }
;
            fieldlist[(++(nfields))-1] = f;
            f = (*f).nextdef;
L1061 :;
        }
L1062 :;
        ;
        fieldlist[((nfields + (i64)1))-1] = 0;
        qq_resolve$ntopfields = (qq_resolve$nallfields = (i64)0);
        maxalign = (i64)1;
        index = (i64)1;
        qq_resolve$scanstruct((i64)1,&fieldlist,&index,&size,(i64)0,(i64)qq_tables$ttcaligned[(m)],&maxalign,(i64)2);
        if (!!((i64)qq_tables$ttcaligned[(m)])) {
            size = mlib$roundtoblock(size,maxalign);
            (*d).maxalign = maxalign;
        }
        else {
            (*d).maxalign = (i64)1;
        }
;
        qq_tables$ttsize[(m)] = size;
        qq_tables$ttlower[(m)] = (i64)1;
        qq_tables$ttlength[(m)] = qq_resolve$ntopfields;
        (*d).topfieldlist = (struct qq_decls$strec **)mlib$pcm_alloc(((i64)8 * qq_resolve$ntopfields));
        memcpy((*d).topfieldlist,&qq_resolve$structfields,(u64)((i64)8 * qq_resolve$ntopfields));
    }
    else if (($temp==(i64)15) || ($temp==(i64)7)) {
    }
    else {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"CAN'T DO:",NULL);
        msysc$m_print_str(qq_dummyshow$strmode(m,(i64)0),NULL);
        msysc$m_print_str(qq_dummyshow$strmode((i64)qq_tables$ttbasetype[(m)],(i64)0),NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    };
}

static void qq_resolve$scanstruct(i64 smode,struct qq_decls$strec *(*fields)[],i64 *index,i64 *isize,i64 offset,i64 calign,i64 *maxalign,i64 countmode) {
        struct qq_decls$strec *  f;
        i64 newoffset;
        i64 fieldsize;
        i64 alignment;
        i64 size;
    size = (i64)0;
    L1063 :;
    while (!!((f = (*fields)[(((*index))++)-1]))) {
                {i64 $temp = (i64)(*f).nameid;
if (($temp==(i64)10)) {
            qq_resolve$converttype((i64)(*f).mode);
            fieldsize = qq_tables$ttsize[((i64)(*f).mode)];
            if (!!(calign)) {
                alignment = qq_names$getalignment((i64)(*f).mode);
                (*maxalign)=((*maxalign)>alignment?(*maxalign):alignment);
;
                newoffset = mlib$roundtoblock(offset,alignment);
                size += (newoffset - offset);
            }
            else {
                newoffset = offset;
            }
;
            (*f).fieldoffset = newoffset;
            (*f).index = ((*index) - (i64)1);
            offset = newoffset;
            //countfields:
L1066 :;
;
            ++(qq_resolve$nallfields);
            if (!!(countmode)) {
                qq_resolve$structfields[(++(qq_resolve$ntopfields))-1] = f;
            }
;
        }
        else if (($temp==(i64)22)) {
            qq_resolve$scanstruct((i64)1,fields,index,&fieldsize,offset,calign,maxalign,countmode);
        }
        else if (($temp==(i64)23)) {
            qq_resolve$scanstruct((i64)0,fields,index,&fieldsize,offset,calign,maxalign,(!!(countmode) ? (i64)1 : (i64)0));
        }
        else if (($temp==(i64)24)) {
            (*isize) = size;
            return;
        }
        };
        if (!!(smode)) {
            offset += fieldsize;
            size += fieldsize;
        }
        else {
            size = (size>fieldsize?size:fieldsize);
            countmode = (i64)0;
        }
;
L1064 :;
    }
L1065 :;
    ;
    (*isize) = size;
}

static void qq_resolve$dobaseclass(i64 baseclassindex) {
        struct qq_decls$strec *  sttype;
        struct qq_decls$strec *  d;
        struct qq_decls$strec *  e;
        struct qq_decls$strec *  newd;
        i64 baseclass;
        i64 normalexit;
    baseclass = (i64)qq_decls$baseclasstable[(baseclassindex)];
    sttype = (struct qq_decls$strec *)qq_decls$baseclassdef[(baseclassindex)];
    d = (struct qq_decls$strec *)(*qq_tables$ttnamedef[(baseclass)]).deflist;
    L1067 :;
    while (!!(d)) {
        e = (struct qq_decls$strec *)(*sttype).deflist;
        normalexit = (i64)1;
        L1070 :;
        while (!!(e)) {
            if (!!(mlib$eqstring((*d).name,(*e).name))) {
                normalexit = (i64)0;
                goto L1072 ;
            }
;
            e = (struct qq_decls$strec *)(*e).nextdef;
L1071 :;
        }
L1072 :;
        ;
        if (!!(normalexit)) {
                        {i64 $temp = (i64)(*d).nameid;
if (($temp==(i64)5) || ($temp==(i64)19)) {
                newd = (struct qq_decls$strec *)qq_names$addsymbol((struct qq_decls$strec *)sttype,(*d).firstdupl,(i64)19,(i64)0);
                (*newd).alias = (struct qq_decls$strec *)d;
            }
            else {
                newd = (struct qq_decls$strec *)qq_names$addsymbol((struct qq_decls$strec *)sttype,(*d).firstdupl,(i64)(*d).nameid,(i64)0);
                qq_names$duplfield((struct qq_decls$strec *)d,(struct qq_decls$strec *)newd);
                ++((*sttype).nfields);
                qq_tables$ttlength[((i64)(*sttype).mode)] = (i64)(*sttype).nfields;
                (*newd).index = (i64)(*sttype).nfields;
                (*newd).fieldoffset = (((*newd).index - (i64)1) * (i64)16);
            }
            };
            qq_names$addgenfield((struct qq_decls$strec *)newd);
        }
;
        d = (struct qq_decls$strec *)(*d).nextdef;
L1068 :;
    }
L1069 :;
    ;
}

// START
void qq_resolve$start(void) {

}

void qq_sets$obj_free_set(struct qq_decls$objrec *p) {
    if (!!((*p).length)) {
        mlib$pcm_free((*p).ptr,qq_bits$getbitssize((*p).alloc64,(i64)35));
    }
;
    mlib$pcm_free32(p);
}

void qq_sets$var_dupl_set(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 nbits;
    p = (*a).objptr;
    nbits = (*p).length;
    q = qq_sets$obj_newset(nbits);
    if (!!(nbits)) {
        memcpy((*q).ptr,(*p).ptr,(u64)qq_bits$getbitssize(nbits,(i64)35));
    }
;
    (*a).objptr = q;
}

i64 qq_sets$var_equal_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 xbytes;
        i64 ybytes;
    xbytes = qq_sets$getsetbytes(x);
    ybytes = qq_sets$getsetbytes(y);
    if ((xbytes != ybytes)) {
        return (i64)0;
    }
;
    return mlib$eqbytes((*(*x).objptr).ptr,(*(*y).objptr).ptr,xbytes);
}

static i64 qq_sets$getsetbytes(struct qq_decls$varrec *x) {
        i64 nbits;
    nbits = (*(*x).objptr).length;
    if (!!(nbits)) {
        if (!!((nbits & (i64)7))) {
            return ((nbits / (i64)8) + (i64)1);
        }
        else {
            return (nbits / (i64)8);
        }
;
    }
    else {
        return (i64)0;
    }
;
}

void qq_sets$var_make_set(struct qq_decls$varrec *data,struct qq_decls$varrec *dest,i64 n) {
        struct qq_decls$varrec *  q;
        i64 top;
        i64 a;
        i64 b;
        struct qq_decls$objrec *  s;
        static i64 count = (i64)0;
        i64 $av_1;
        i64 $av_2;
    if ((n == (i64)0)) {
        qq_sets$var_emptyset(dest);
        return;
    }
;
    top = (i64)0;
    q = data;
    $av_1 = n;
    while ($av_1-- > 0) {
L1073 :;
        switch ((i64)(*q).tag) {
        case 6:;
            {
                a = msysc$m_getdotslice((*q).dummy,(i64)16,(i64)63);
                b = (i64)(*q).range_upper;
            }
            break;
        case 1:;
            {
                a = (*q).value;
                if ((a < (i64)0)) {
                    a = (-(a) - (i64)1);
                    if ((a > top)) {
                        top = a;
                    }
;
                    goto L1074 ;
                }
;
                b = a;
            }
            break;
        default: {
            b = (a = qq_vars$var_getintvalue(q));
        }
        } //SW
;
        if (((a < (i64)0) || (b < (i64)0))) {
            qq_lib$pcerror((byte*)"Neg range element");
        }
;
        top=(top>a?top:a);
;
        top=(top>b?top:b);
;
        ++(q);
L1074 :;
    }
L1075 :;
    ;
    s = qq_sets$obj_newset((top + (i64)1));
    q = data;
    $av_2 = n;
    while ($av_2-- > 0) {
L1076 :;
        switch ((i64)(*q).tag) {
        case 6:;
            {
                a = msysc$m_getdotslice((*q).dummy,(i64)16,(i64)63);
                b = (i64)(*q).range_upper;
                if ((a > b)) {
                    {i64 temp = a; a = b; b = temp; };
                }
;
            }
            break;
        case 1:;
            {
                b = (a = (*q).value);
                if ((a < (i64)0)) {
                    goto L1077 ;
                }
;
            }
            break;
        default: {
            b = (a = qq_vars$var_getintvalue(q));
        }
        } //SW
;
        qq_lib$setelemblock((byte (*)[])(*s).ptr,a,b);
        ++(q);
L1077 :;
    }
L1078 :;
    ;
    qq_vars$var_objtovar((i64)8,s,dest);
}

struct qq_decls$objrec *qq_sets$obj_newset(i64 length) {
        struct qq_decls$objrec *  p;
        i64 nbytes;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    (*p).length = length;
    nbytes = ((((length - (i64)1) / (i64)64) + (i64)1) * (i64)8);
    if (!!(length)) {
        (*p).ptr = (byte *)mlib$pcm_alloc(nbytes);
        (*p).alloc64 = ((i64)(u64)mlib$allocbytes * (i64)8);
        mlib$pcm_clearmem((*p).ptr,mlib$allocbytes);
    }
    else {
        (*p).ptr = 0;
    }
;
    return p;
}

void qq_sets$var_emptyset(struct qq_decls$varrec *dest) {
    qq_vars$var_objtovar((i64)8,qq_sets$obj_newset((i64)0),dest);
}

void qq_sets$var_getix_set(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  p;
    p = (*a).objptr;
    if (((u64)index >= (u64)(*p).length)) {
        qq_lib$pcerror((byte*)"set[int] bounds");
    }
;
    (*a).tagx = (i64)1;
    (*a).value = (i64)!!(((i64)(*((*p).ptr + (index >> (i64)3))) & ((i64)1 << (index & (i64)7))));
}

void qq_sets$var_putix_set(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        struct qq_decls$objrec *  p;
        byte *  q;
        i64 newoffset;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"Not Mutable");
    }
;
    if (((u64)index >= (u64)(*p).length)) {
        if ((index < (i64)0)) {
            qq_lib$pcerror((byte*)"lwb");
        }
        else {
            qq_lib$pcerror((byte*)"set[i]:=x bounds");
        }
;
    }
;
    q = qq_sets$getoffset((*p).ptr,index,&newoffset);
    qq_vars$var_storebit(q,newoffset,x,(i64)35,(i64)0);
}

void qq_sets$var_getixref_set(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  p;
        byte *  q;
        i64 newoffset;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"Not Mutable");
    }
;
    if (((u64)index >= (u64)(*p).length)) {
        qq_lib$pcerror((byte*)"&set[i] bounds");
    }
;
    q = qq_sets$getoffset((*p).ptr,index,&newoffset);
    (*a).tagx = (i64)18;
    (*a).elemtag = (i64)35;
    (*a).ptr = q;
    (*a).bitoffset = newoffset;
}

static byte *qq_sets$getoffset(byte *p,i64 index,i64 *newoffset) {
    p += (index >> (i64)3);
    (*newoffset) = (index & (i64)7);
    return p;
}

i64 qq_sets$var_in_set(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 i;
        static byte masks[8] = {(u8)1u,(u8)2u,(u8)4u,(u8)8u,(u8)16u,(u8)32u,(u8)64u,(u8)128u};
        struct qq_decls$objrec *  p;
    i = (*a).value;
    p = (*b).objptr;
    if (((u64)i >= (u64)(*p).length)) {
        return (i64)0;
    }
;
    if (!!(((i64)(*((*p).ptr + (i >> (i64)3))) & (i64)masks[((i & (i64)7))]))) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

void qq_sets$iresizeset(struct qq_decls$varrec *p,i64 n) {
        struct qq_decls$objrec *  pp;
    pp = (*p).objptr;
    if (((*pp).length >= n)) {
        return;
    }
;
    qq_sets$obj_resize_set(pp,n);
}

void qq_sets$obj_resize_set(struct qq_decls$objrec *p,i64 n) {
        byte *  q;
        i64 newsize;
        i64 elemtype;
    elemtype = (i64)(*p).elemtag;
    if ((n <= (*p).alloc64)) {
        (*p).length = n;
    }
    else {
        newsize = qq_bits$getbitssize(n,(i64)35);
        q = (byte *)mlib$pcm_allocz(newsize);
        if (!!((*p).length)) {
            memcpy(q,(*p).ptr,(u64)qq_bits$getbitssize((*p).length,(i64)35));
            mlib$pcm_free((*p).ptr,qq_bits$getbitssize((*p).alloc64,(i64)35));
        }
;
        (*p).ptr = q;
        (*p).length = n;
        (*p).alloc64 = (mlib$allocbytes * (i64)8);
    }
;
}

void qq_sets$iorsetbits(i64 *p,i64 *q,i64 n) {
        i64 $av_1;
    $av_1 = (((n - (i64)1) / (i64)64) + (i64)1);
    while ($av_1-- > 0) {
L1079 :;
        (*(p)++) |= (*(q)++);
L1080 :;
    }
L1081 :;
    ;
}

void qq_sets$ixorsetbits(i64 *p,i64 *q,i64 n) {
        i64 $av_1;
    $av_1 = (((n - (i64)1) / (i64)64) + (i64)1);
    while ($av_1-- > 0) {
L1082 :;
        (*(p)++) ^= (*(q)++);
L1083 :;
    }
L1084 :;
    ;
}

void qq_sets$iandsetbits(u64 *p,u64 *q,i64 n) {
        i64 $av_1;
    $av_1 = (((n - (i64)1) / (i64)64) + (i64)1);
    while ($av_1-- > 0) {
L1085 :;
        (*(p)++) &= (*(q)++);
L1086 :;
    }
L1087 :;
    ;
}

void qq_sets$inotsetbits(u64 *p,i64 n) {
        i64 $av_1;
    $av_1 = (((n - (i64)1) / (i64)64) + (i64)1);
    while ($av_1-- > 0) {
L1088 :;
        (*p) = ~((*p));
        ++(p);
L1089 :;
    }
L1090 :;
    ;
}

void qq_sets$var_iorto_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 xlen;
        i64 ylen;
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (*px).length;
    ylen = (*py).length;
    if ((ylen == (i64)0)) {
    }
    else if ((xlen == (i64)0)) {
        (*x) = (*y);
        qq_sets$var_dupl_set(x);
    }
    else {
        px = (*x).objptr;
        qq_sets$iresizeset(x,ylen);
        qq_sets$iorsetbits((i64 *)(*px).ptr,(i64 *)(*py).ptr,ylen);
    }
;
}

void qq_sets$var_iandto_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 xlen;
        i64 ylen;
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (*px).length;
    ylen = (*py).length;
    if ((ylen == (i64)0)) {
        qq_sets$var_emptyset(x);
    }
    else if ((xlen == (i64)0)) {
    }
    else {
        px = (*x).objptr;
        qq_sets$iresizeset(x,ylen);
        qq_sets$iandsetbits((u64 *)(*px).ptr,(u64 *)(*py).ptr,ylen);
    }
;
}

void qq_sets$var_ixorto_set(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 xlen;
        i64 ylen;
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (*px).length;
    ylen = (*py).length;
    if ((ylen == (i64)0)) {
        qq_sets$var_emptyset(x);
    }
    else if ((xlen == (i64)0)) {
        (*x) = (*y);
        qq_sets$var_dupl_set(x);
    }
    else {
        px = (*x).objptr;
        qq_sets$iresizeset(x,ylen);
        qq_sets$ixorsetbits((i64 *)(*px).ptr,(i64 *)(*py).ptr,ylen);
    }
;
}

void qq_sets$var_inotto_set(struct qq_decls$varrec *x) {
        i64 xlen;
        struct qq_decls$objrec *  px;
    px = (*x).objptr;
    xlen = (*px).length;
    if (!!(xlen)) {
        qq_sets$inotsetbits((u64 *)(*px).ptr,xlen);
    }
;
}

void qq_sets$var_checkiter_set(struct qq_decls$varrec *a,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  p;
        i64 x;
    p = (*a).objptr;
    (*dest).tagx = (i64)5;
    (*dest).value = (i64)0;
    if (((i64)(*p).iterpos >= (i64)(*p).iterupper)) {
        return;
    }
;
    ++((*p).iterpos);
    x = (i64)0;
    L1091 :;
    while (((i64)(*p).iterpos <= (i64)(*p).iterupper)) {
        x = qq_lib$testelem((byte (*)[])(*(*p).objptr2).ptr,(i64)(*p).iterpos);
        if (!!(x)) {
            --((*p).iterpos);
            (*dest).value = (i64)1;
            goto L1093 ;
        }
;
        ++((*p).iterpos);
L1092 :;
    }
L1093 :;
    ;
}

void qq_sets$var_nextiter_set(struct qq_decls$varrec *a,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    q = (*p).objptr2;
    if (((i64)(*p).iterpos >= (i64)(*p).iterupper)) {
        (*dest).tagx = (i64)0;
        return;
    }
;
    (*dest).tagx = (i64)1;
    (*dest).value = ++((*p).iterpos);
    if (!(!!(qq_lib$testelem((byte (*)[])(*q).ptr,(i64)(*p).iterpos)))) {
        qq_lib$pcerror((byte*)"nextiter/set?");
    }
;
}

// START
void qq_sets$start(void) {

}

// START
void qq_strings$start(void) {

    qq_strings$emptystring = qq_vars$obj_new();
    (*qq_strings$emptystring).refcount = (i64)1;
    (*qq_strings$emptystring).objtype = (i64)0;
}

void qq_strings$var_empty_string(struct qq_decls$varrec *dest,i64 mutable) {
    (*dest).tagx = (i64)268;
    if (!(!!(mutable))) {
        (*dest).objptr = qq_strings$emptystring;
        ++((*qq_strings$emptystring).refcount);
    }
    else {
        (*dest).objptr = qq_strings$obj_make_stringn(0,(i64)0,(i64)1);
    }
;
}

void qq_strings$var_make_string(u8 *s,struct qq_decls$varrec *dest,i64 mutable) {
    (*dest).tagx = (i64)268;
    (*dest).objptr = qq_strings$obj_make_string(s,mutable);
}

void qq_strings$var_make_stringn(u8 *s,i64 length,struct qq_decls$varrec *dest,i64 mutable) {
    (*dest).tagx = (i64)268;
    (*dest).objptr = qq_strings$obj_make_stringn(s,length,mutable);
}

struct qq_decls$objrec *qq_strings$obj_new_string(i64 n) {
        struct qq_decls$objrec *  p;
    p = qq_vars$obj_new();
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    (*p).length = n;
    (*p).objtype = (i64)0;
    if (!!(n)) {
        (*p).strptr = (u8 *)mlib$pcm_alloc(n);
        (*p).alloc64 = mlib$allocbytes;
    }
;
    return p;
}

struct qq_decls$objrec *qq_strings$obj_make_string(u8 *s,i64 mutable) {
        struct qq_decls$objrec *  p;
        i64 n;
    p = qq_strings$obj_new_string((n = strlen(s)));
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)mutable);
    if (!!(n)) {
        memcpy((void *)(*p).strptr,(void *)s,(u64)n);
    }
;
    return p;
}

struct qq_decls$objrec *qq_strings$obj_make_stringn(u8 *s,i64 length,i64 mutable) {
        struct qq_decls$objrec *  p;
    p = qq_strings$obj_new_string(length);
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)mutable);
    if (!!(length)) {
        if (!!(s)) {
            memcpy((void *)(*p).strptr,(void *)s,(u64)length);
        }
        else {
            memset((void *)(*p).strptr,(i32)(i64)0,(u64)length);
        }
;
    }
;
    return p;
}

void qq_strings$obj_free_string(struct qq_decls$objrec *p) {
    ++(qq_decls$nstringsx);
    qq_decls$nlengths += (*p).length;
    if (!!((*p).length)) {
        mlib$pcm_free((void *)(*p).strptr,(*p).alloc64);
    }
;
    mlib$pcm_free32(p);
}

void qq_strings$var_dupl_string(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    q = qq_strings$obj_new_string((*p).length);
    (*a).objptr = q;
    if (!!((*q).length)) {
        memcpy((void *)(*q).strptr,(void *)(*p).strptr,(u64)(*q).length);
    }
;
}

void qq_strings$var_getix_string(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  q;
    q = (*a).objptr;
    if (((u64)(index - (i64)1) >= (u64)(*q).length)) {
        qq_lib$pcerror((byte*)"getstring[int] bounds");
    }
;
    qq_strings$stringslice(a,index,index,a);
}

void qq_strings$var_getixref_string(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  q;
    q = (*a).objptr;
    if (((u64)(index - (i64)1) >= (u64)(*q).length)) {
        qq_lib$pcerror((byte*)"getixref[int] bounds");
    }
;
    (*a).tagx = (i64)24;
    (*a).elemtag = (i64)31;
    (*a).ptr = (byte *)(((*q).strptr + index) - (i64)1);
}

void qq_strings$var_getdotix_string(struct qq_decls$varrec *a,i64 index) {
        struct qq_decls$objrec *  q;
    q = (*a).objptr;
    if (((u64)(index - (i64)1) >= (u64)(*q).length)) {
        qq_lib$pcerror((byte*)"x.[] bounds");
    }
;
    (*a).tagx = (i64)1;
    (*a).value = (i64)(u64)(*(((*q).strptr + index) - (i64)1));
}

void qq_strings$var_getdotixref_string(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  q;
    q = (*a).objptr;
    --(index);
    if (((u64)index >= (u64)(*q).length)) {
        qq_lib$pcerror((byte*)"x.[] bounds");
    }
;
    (*dest).tagx = (i64)24;
    (*dest).elemtag = (i64)31;
    (*dest).ptr = (byte *)((*q).strptr + index);
}

void qq_strings$var_getslice_string(struct qq_decls$varrec *a,i64 i,i64 j) {
        struct qq_decls$objrec *  p;
    p = (*a).objptr;
    if ((((i < (i64)1) || (j > (*p).length)) || (i > j))) {
        qq_lib$pcerror((byte*)"string/slice bounds");
    }
;
    qq_strings$stringslice(a,i,j,a);
}

static void qq_strings$stringslice(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
    p = (*a).objptr;
    q = qq_vars$obj_new();
    (*q).flags = msysc$m_setdotindex((*q).flags,(i64)1,msysc$m_getdotindex((i64)(*p).flags,(i64)1));
    (*q).length = ((j - i) + (i64)1);
    (*q).objtype = (i64)1;
        {i64 $temp = (i64)(*p).objtype;
if (($temp==(i64)1)) {
        (*q).objptr2 = (*p).objptr2;
        ++((*(*q).objptr2).refcount);
    }
    else if (($temp==(i64)2)) {
        (*q).objptr2 = 0;
        (*q).objtype = (i64)2;
    }
    else {
        ++((*p).refcount);
        (*q).objptr2 = p;
    }
    };
    (*q).strptr = (((*p).strptr + i) - (i64)1);
    (*dest).tagx = (i64)(*a).tagx;
    (*dest).objptr = q;
}

void qq_strings$var_putix_string(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        u8 *  s;
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 length;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"Str not mutable");
    }
;
    length = (*p).length;
    if (!((index >= (i64)1 && index <= length))) {
        if ((index == (length + (i64)1))) {
            qq_strings$var_addto_string(a,x);
            return;
        }
        else {
            qq_lib$pcerror((byte*)"putstring[int] bounds");
        }
;
    }
;
    s = (((*p).strptr + index) - (i64)1);
    if (((i64)(*x).tag != (i64)12)) {
        qq_lib$pcerror((byte*)"s[i]:= not str");
    }
;
    q = (*x).objptr;
    if (((*q).length == (i64)0)) {
        qq_lib$pcerror((byte*)"s[i]:=\"\"");
    }
;
    (*s) = (u64)(*(*q).strptr);
}

void qq_strings$var_putslice_string(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x) {
        u8 *  s;
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 length;
        i64 sublength;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"Str not mutable");
    }
;
    length = (*p).length;
    if ((((i < (i64)1) || (j > (*p).length)) || (i > j))) {
        qq_lib$pcerror((byte*)"string/slice bounds");
    }
;
    sublength = ((j - i) + (i64)1);
    s = (((*p).strptr + i) - (i64)1);
    if (((i64)(*x).tag != (i64)12)) {
        qq_lib$pcerror((byte*)"s[i..j]:= not str");
    }
;
    q = (*x).objptr;
    if (((*q).length < sublength)) {
        qq_lib$pcerror((byte*)"substr too short");
    }
;
    memcpy((void *)s,(void *)(*q).strptr,(u64)sublength);
}

void qq_strings$var_putdotix_string(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
        struct qq_decls$objrec *  p;
        i64 length;
        i64 ch;
    if (((i64)(*x).tag != (i64)1)) {
        qq_lib$pcerror((byte*)"s.[i]:= not int");
    }
;
    ch = (*x).value;
    p = (*a).objptr;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"Str not mutable");
    }
;
    length = (*p).length;
    if (!((index >= (i64)1 && index <= length))) {
        if ((index == (length + (i64)1))) {
            qq_strings$var_addto_string_ch(a,ch);
            return;
        }
        else {
            qq_lib$pcerror((byte*)"str.[int] bounds");
        }
;
    }
;
    (*(((*p).strptr + index) - (i64)1)) = (u64)ch;
}

void qq_strings$obj_resize_string(struct qq_decls$objrec *p,i64 n) {
        u8 *  s;
        i64 oldalloc;
    if ((n <= (*p).alloc64)) {
        (*p).length = n;
    }
    else {
        oldalloc = (*p).alloc64;
        s = (u8 *)mlib$pcm_alloc(n);
        (*p).alloc64 = mlib$allocbytes;
        if (!!((*p).length)) {
            memcpy((void *)s,(void *)(*p).strptr,(u64)(*p).length);
            mlib$pcm_free((void *)(*p).strptr,oldalloc);
        }
;
        (*p).strptr = s;
        (*p).length = n;
    }
;
}

void qq_strings$var_add_string(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        struct qq_decls$objrec *  r;
        i64 alen;
        i64 blen;
        i64 newlen;
    p = (*a).objptr;
    q = (*b).objptr;
    alen = (*p).length;
    blen = (*q).length;
    if ((blen == (i64)0)) {
        ++((*(*a).objptr).refcount);
        return;
    }
    else if ((alen == (i64)0)) {
        qq_strings$var_make_stringn((*q).strptr,blen,a,(i64)1);
        return;
    }
;
    newlen = (alen + blen);
    r = qq_strings$obj_new_string(newlen);
    memcpy((void *)(*r).strptr,(void *)(*p).strptr,(u64)alen);
    memcpy((void *)((*r).strptr + alen),(void *)(*q).strptr,(u64)blen);
    (*a).objptr = r;
}

void qq_strings$var_addto_string(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 alen;
        i64 blen;
        i64 newlen;
    p = (*a).objptr;
    q = (*b).objptr;
    alen = (*p).length;
    blen = (*q).length;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"ADDTOSTR/NOT MUT");
    }
;
    if ((blen == (i64)0)) {
        return;
    }
    else if ((alen == (i64)0)) {
        qq_vars$var_unshareu(a);
        (*a) = (*b);
        qq_vars$var_duplu(a);
        return;
    }
;
    newlen = (alen + blen);
    qq_strings$obj_resize_string(p,newlen);
    memcpy((void *)((*p).strptr + alen),(void *)(*q).strptr,(u64)blen);
}

void qq_strings$var_addto_string_ch(struct qq_decls$varrec *a,i64 ch) {
        struct qq_decls$objrec *  p;
        i64 alen;
    p = (*a).objptr;
    alen = (*p).length;
    if (!(!!(msysc$m_getdotindex((i64)(*p).flags,(i64)1)))) {
        qq_lib$pcerror((byte*)"ADDTOSTR/ch/NOT MUT");
    }
;
    qq_strings$obj_resize_string(p,(alen + (i64)1));
    (*((*p).strptr + alen)) = (u64)ch;
}

i64 qq_strings$var_equal_string(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 n;
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    if ((px == py)) {
        return (i64)1;
    }
;
    n = (*px).length;
    if ((n != (*py).length)) {
        return (i64)0;
    }
    else if ((n == (i64)0)) {
        return (i64)1;
    }
    else {
        return mlib$eqbytes((void *)(*px).strptr,(void *)(*py).strptr,n);
    }
;
}

i64 qq_strings$var_compare_string(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 res;
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    res = qq_strings$cmpstring_len((*px).strptr,(*py).strptr,(*px).length,(*py).length);
    return res;
}

static i64 qq_strings$cmpstring_len(u8 *s,u8 *t,i64 slen,i64 tlen) {
    if ((slen == (i64)0)) {
        if ((tlen == (i64)0)) {
            return (i64)0;
        }
        else {
            return (i64)-1;
        }
;
    }
    else if ((tlen == (i64)0)) {
        return (i64)1;
    }
    else {
        if ((slen == tlen)) {
            if ((slen == (i64)1)) {
                if (((u64)(*s) < (u64)(*t))) {
                    return (i64)-1;
                }
                else if (((u64)(*s) > (u64)(*t))) {
                    return (i64)1;
                }
                else {
                    return (i64)0;
                }
;
            }
;
            return mlib$cmpstringn(s,t,slen);
        }
        else {
            return mlib$cmpstring(qq_lib$convtostringz(s,slen),qq_lib$convtostringz(t,tlen));
        }
;
    }
;
}

i64 qq_strings$var_inx_string(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
        i64 xlen;
        i64 ylen;
        i64 i;
        i64 j;
        i64 k;
        u8 *  sx;
        u8 *  sy;
        struct qq_decls$objrec *  px;
        struct qq_decls$objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (*px).length;
    ylen = (*py).length;
    if (((xlen == (i64)0) || (ylen == (i64)0))) {
        return (i64)(-9223372036854775807-1);
    }
;
    k = (ylen - xlen);
    for (i=(i64)0;i<=k;++i) {
L1094 :;
        sx = (*px).strptr;
        sy = ((*py).strptr + i);
        for (j=(i64)1;j<=xlen;++j) {
L1097 :;
            if (((u64)(*sx) != (u64)(*sy))) {
                goto L1100 ;
;
            }
;
            ++(sx);
            ++(sy);
L1098 :;
        }
L1099 :;
        ;
        return (i + (i64)1);
        //nextpos:
L1100 :;
;
L1095 :;
    }
L1096 :;
    ;
    return (i64)(-9223372036854775807-1);
}

void qq_strings$var_iconvcase(struct qq_decls$varrec *a,struct qq_decls$varrec *b,i64 upper) {
        i64 n;
        u8 *  s;
        struct qq_decls$objrec *  pa;
        i64 $av_1;
        i64 $av_2;
    pa = (*a).objptr;
    if (((i64)(*b).tag > (i64)0)) {
        n = qq_vars$var_getintvalue(b);
    }
    else {
        n = (*pa).length;
    }
;
    if (((i64)(*a).tag != (i64)12)) {
        qq_lib$pcerror((byte*)"convcase/notstr");
    }
;
    if ((n < (i64)0)) {
        qq_lib$pcerror((byte*)"CONVCASE N<0");
    }
;
    if ((n == (i64)0)) {
        return;
    }
;
    if ((n > (*pa).length)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"N=",NULL);
        msysc$m_print_i64(n,NULL);
        msysc$m_print_i64((*pa).length,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        qq_lib$pcerror((byte*)"convcase/N?");
    }
;
    s = (*pa).strptr;
    if (!!(upper)) {
        $av_1 = n;
        while ($av_1-- > 0) {
L1101 :;
            (*s) = (u64)toupper((i32)(u64)(*s));
            ++(s);
L1102 :;
        }
L1103 :;
        ;
    }
    else {
        $av_2 = n;
        while ($av_2-- > 0) {
L1104 :;
            (*s) = (u64)tolower((i32)(u64)(*s));
            ++(s);
L1105 :;
        }
L1106 :;
        ;
    }
;
}

void qq_strings$var_makestrslicexobj(u8 *s,i64 length,struct qq_decls$varrec *dest) {
    (*dest).tagx = (i64)268;
    (*dest).objptr = qq_strings$obj_make_strslicexobj(s,length);
}

struct qq_decls$objrec *qq_strings$obj_make_strslicexobj(u8 *s,i64 length) {
        struct qq_decls$objrec *  p;
    if ((length == (i64)0)) {
        s = 0;
    }
;
    p = qq_vars$obj_new();
    (*p).strptr = s;
    (*p).flags = msysc$m_setdotindex((*p).flags,(i64)1,(u64)1u);
    (*p).length = length;
    (*p).objtype = (i64)2;
    return p;
}

static i64 qq_strings$var_asc(struct qq_decls$varrec *a) {
        struct qq_decls$objrec *  p;
    if (((i64)(*a).tag != (i64)12)) {
        qq_lib$pcerror((byte*)"Asc:not str");
    }
;
    p = (*a).objptr;
    if (((*p).length < (i64)1)) {
        qq_lib$pcerror((byte*)"Asc:empty");
    }
;
    return (i64)(u64)(*(*p).strptr);
}

void qq_strings$var_new_string(struct qq_decls$varrec *a,struct qq_decls$varrec *b,struct qq_decls$varrec *dest) {
        i64 length;
        i64 ch;
    length = qq_vars$var_getintvalue(a);
    if ((length < (i64)0)) {
        qq_lib$pcerror((byte*)"Length<0");
    }
;
    qq_strings$var_make_stringn(0,length,dest,(i64)0);
        {i64 $temp = (i64)(*b).tag;
if (($temp==(i64)1)) {
        ch = (*b).value;
    }
    else if (($temp==(i64)12)) {
        ch = qq_strings$var_asc(b);
    }
    else if (($temp==(i64)0)) {
        ch = (i64)32;
    }
    else {
        qq_lib$pcerror((byte*)"Not int/str");
    }
    };
    if (!!(length)) {
        memset((void *)(*(*dest).objptr).strptr,(i32)ch,(u64)length);
    }
;
}

void qq_strings$var_new_stringn(i64 length,struct qq_decls$varrec *dest) {
    if ((length < (i64)0)) {
        qq_lib$pcerror((byte*)"Length<0");
    }
;
    qq_strings$var_make_stringn(0,length,dest,(i64)0);
}

void qq_strings$var_mul_string(struct qq_decls$varrec *a,i64 m) {
        i64 oldlen;
        i64 newlen;
        u8 *  p;
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  pa;
        i64 $av_1;
    if ((m < (i64)0)) {
        qq_lib$pcerror((byte*)"neg str mul");
    }
    else if ((m == (i64)0)) {
        qq_strings$var_empty_string(a,(i64)0);
        return;
    }
    else if ((m == (i64)1)) {
        ++((*(*a).objptr).refcount);
        return;
    }
    else {
        pa = (*a).objptr;
        oldlen = (*pa).length;
        if (!!(oldlen)) {
            newlen = (oldlen * m);
            v.objptr = qq_strings$obj_new_string(newlen);
            v.tagx = (i64)268;
            p = (*v.objptr).strptr;
            if ((oldlen == (i64)1)) {
                memset((void *)p,(i32)(u64)(*(*pa).strptr),(u64)m);
            }
            else {
                $av_1 = m;
                while ($av_1-- > 0) {
L1107 :;
                    memcpy((void *)p,(void *)(*pa).strptr,(u64)oldlen);
                    p += oldlen;
L1108 :;
                }
L1109 :;
                ;
            }
;
            (*a) = v;
        }
        else {
            qq_strings$var_empty_string(a,(i64)0);
            return;
        }
;
    }
;
}

void qq_strings$var_convert_string_list(struct qq_decls$varrec *a,i64 t,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  p;
        struct qq_decls$varrec *  q;
        i64 length;
        u8 *  s;
        i64 $av_1;
    p = (*a).objptr;
    length = (*p).length;
    qq_lists$var_make_list(0,dest,length,(i64)1);
    q = (*(*dest).objptr).varptr;
    s = (*p).strptr;
    $av_1 = length;
    while ($av_1-- > 0) {
L1110 :;
        qq_strings$var_make_stringn(s,(i64)1,q,(i64)1);
        ++(s);
        ++(q);
L1111 :;
    }
L1112 :;
    ;
}

void qq_strings$var_expand_string(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 m) {
        struct qq_decls$varrec *  b;
        struct qq_decls$objrec *  p;
        u8 *  s;
        i64 n;
        i64 $av_1;
    p = (*a).objptr;
    b = dest;
    s = (*p).strptr;
    n = (i64)1;
    $av_1 = m;
    while ($av_1-- > 0) {
L1113 :;
        if ((n > (*p).length)) {
            qq_strings$var_empty_string(dest,(i64)0);
        }
        else {
            qq_strings$var_make_stringn(s,(i64)1,dest,(i64)1);
            ++(s);
        }
;
        ++(n);
        --(dest);
L1114 :;
    }
L1115 :;
    ;
}

void qq_strings$var_makechar(i64 ch,struct qq_decls$varrec *dest) {
        struct qq_decls$varrec v;
        u8 str[8];
        struct qq_decls$objrec *  p;
    if (!((ch >= (i64)0 && ch <= (i64)255))) {
        qq_lib$pcerror((byte*)"chr range");
    }
;
    p = qq_decls$chrtable[(ch)];
    if ((p == 0)) {
        str[((i64)1)-1] = (u64)ch;
        str[((i64)2)-1] = (u64)0u;
        qq_strings$var_make_stringn(str,(i64)1,&v,(i64)0);
        qq_decls$chrtable[(ch)] = (p = v.objptr);
    }
;
    ++((*p).refcount);
    (*dest).tagx = (i64)268;
    (*dest).objptr = p;
}

void qq_strings$var_nextiter_string(struct qq_decls$varrec *a,struct qq_decls$varrec *dest) {
        struct qq_decls$objrec *  p;
        struct qq_decls$objrec *  q;
        i64 c;
    p = (*a).objptr;
    q = (*p).objptr2;
    if (((i64)(*p).iterpos >= (i64)(*p).iterupper)) {
        (*dest).tagx = (i64)0;
        return;
    }
;
    ++((*p).iterpos);
    c = (i64)(u64)(*(((*q).strptr + (i64)(*p).iterpos) - (i64)1));
    (*dest).tagx = (i64)1;
    (*dest).value = c;
}

i64 qq_syslibs$findsyslib(u8 *filename) {
        i64 i;
    if ((u64)0u) {
        return (i64)0;
    }
;
    filename = mlib$extractfile(filename);
    for (i=(i64)1;i<=(i64)12;++i) {
L1116 :;
        if (!!(mlib$eqstring(qq_syslibs$syslibnames[(i)-1],filename))) {
            if (!!((i64)qq_syslibs$syslibfileno[(i)-1])) {
                return (i64)qq_syslibs$syslibfileno[(i)-1];
            }
;
            if ((qq_decls$nsourcefiles >= (i64)200)) {
                qq_lib$loaderror((byte*)"fsl: too many files",(byte*)"",(byte*)"");
            }
;
            ++(qq_decls$nsourcefiles);
            qq_decls$sourcefilenames[(qq_decls$nsourcefiles)-1] = mlib$pcm_copyheapstring(filename);
            qq_decls$sourcefiletext[(qq_decls$nsourcefiles)-1] = mlib$pcm_copyheapstring(qq_syslibs$libtext[(i)-1]);
            qq_decls$sourcefilesizes[(qq_decls$nsourcefiles)-1] = strlen(qq_syslibs$libtext[(i)-1]);
            qq_decls$sourcefilepaths[(qq_decls$nsourcefiles)-1] = (byte*)"";
            qq_decls$sourcefilespecs[(qq_decls$nsourcefiles)-1] = (byte*)"";
            qq_decls$sourcefilesys[(qq_decls$nsourcefiles)-1] = (i64)1;
            qq_decls$sourcefilesupport[(qq_decls$nsourcefiles)-1] = (i64)0;
            qq_syslibs$syslibfileno[(i)-1] = qq_decls$nsourcefiles;
            return qq_decls$nsourcefiles;
        }
;
L1117 :;
    }
L1118 :;
    ;
    return (i64)0;
}

// START
void qq_syslibs$start(void) {

}

// START
void qq_tables$start(void) {

        i64 i;
    for (i=(i64)1;i<=(i64)28;++i) {
L1119 :;
        qq_tables$binopset[((i64)qq_tables$d_binopset[(i)-1])] = (i64)1;
        qq_tables$exprstarterset[((i64)qq_tables$d_binopset[(i)-1])] = (i64)1;
L1120 :;
    }
L1121 :;
    ;
    for (i=(i64)1;i<=(i64)9;++i) {
L1122 :;
        qq_tables$unaryopset[((i64)qq_tables$d_unaryopset[(i)-1])] = (i64)1;
        qq_tables$exprstarterset[((i64)qq_tables$d_unaryopset[(i)-1])] = (i64)1;
L1123 :;
    }
L1124 :;
    ;
    for (i=(i64)1;i<=(i64)33;++i) {
L1125 :;
        qq_tables$exprstarterset[(qq_tables$d_exprstarterset[(i)-1])] = (i64)1;
L1126 :;
    }
L1127 :;
    ;
    qq_tables$exprendset[((i64)6)] = (i64)1;
    qq_tables$exprendset[((i64)5)] = (i64)1;
    qq_tables$exprendset[((i64)16)] = (i64)1;
    qq_tables$exprendset[((i64)14)] = (i64)1;
    qq_tables$exprendset[((i64)100)] = (i64)1;
    qq_tables$exprendset[((i64)110)] = (i64)1;
    qq_tables$exprendset[((i64)108)] = (i64)1;
    for (i=(i64)1;i<=(i64)11;++i) {
L1128 :;
        qq_tables$addopset[((i64)qq_tables$d_addopset[(i)-1])] = (i64)1;
L1129 :;
    }
L1130 :;
    ;
    for (i=(i64)1;i<=(i64)6;++i) {
L1131 :;
        qq_tables$mulopset[((i64)qq_tables$d_mulopset[(i)-1])] = (i64)1;
L1132 :;
    }
L1133 :;
    ;
    for (i=(i64)1;i<=(i64)7;++i) {
L1134 :;
        qq_tables$cmpopset[((i64)qq_tables$d_cmpopset[(i)-1])] = (i64)1;
L1135 :;
    }
L1136 :;
    ;
    for (i=(i64)0;i<=(i64)42;++i) {
L1137 :;
        qq_tables$ttname[(i)] = qq_tables$stdtypenames[(i)];
        qq_tables$ttbasetype[(i)] = i;
        qq_tables$ttlower[(i)] = (i64)1;
        qq_tables$ttbitwidth[(i)] = (i64)qq_tables$stdtypewidths[(i)];
        qq_tables$ttsize[(i)] = ((i64)qq_tables$stdtypewidths[(i)] / (i64)8);
L1138 :;
    }
L1139 :;
    ;
    qq_tables$ntypes = (i64)42;
    qq_tables$hostlvset[((i64)24)] = (i64)1;
    qq_tables$hostlvset[((i64)25)] = (i64)1;
}

void qq_dummyshow$printunit(struct qq_decls$unitrec *p,i64 level,u8 *prefix,void *dev) {
}

void qq_dummyshow$writeallpcl(i64 n,i64 pass) {
}

void qq_dummyshow$printglobalsymbols(void *f) {
}

void qq_dummyshow$printst(void *f,struct qq_decls$strec *p,i64 level) {
}

void qq_dummyshow$printglobalsymbols_full(void *f) {
}

void qq_dummyshow$printstfull(void *f,struct qq_decls$strec *p,i64 level) {
}

void qq_dummyshow$printtypetables(void *f) {
}

u8 *qq_dummyshow$getpclname(void) {
    return (byte*)"<no show.m>";
}

void qq_dummyshow$showlogfile(void) {
}

void qq_dummyshow$showast(u8 *file) {
}

void qq_dummyshow$showpcl(i64 pass) {
}

void qq_dummyshow$showmpl(i64 pass) {
}

void qq_dummyshow$printsymbol(struct qq_decls$lexrec *lp) {
}

u8 *qq_dummyshow$strmode(i64 t,i64 expand) {
    return qq_tables$ttname[(t)];
}

// START
void qq_dummyshow$start(void) {

}

void qq_vars$var_unshareu(struct qq_decls$varrec *p) {
    if ((--((*(*p).objptr).refcount) <= (i64)0)) {
        qq_vars$var_free(p);
    }
;
}

void qq_vars$obj_shareu(struct qq_decls$objrec *p) {
    ++((*p).refcount);
}

struct qq_decls$varrec *qq_vars$void_new(void) {
        struct qq_decls$varrec *  p;
    p = (struct qq_decls$varrec *)mlib$pcm_alloc((i64)16);
    (*p).tagx = (i64)0;
    return p;
}

struct qq_decls$objrec *qq_vars$obj_new(void) {
        struct qq_decls$objrec *  p;
    p = (struct qq_decls$objrec *)mlib$pcm_alloc((i64)32);
    (*p) = qq_vars$zeroobj;
    (*p).refcount = (i64)1;
    return p;
}

i64 qq_vars$var_getintvalue(struct qq_decls$varrec *p) {
    switch ((i64)(*p).tag) {
    case 1:;
    case 19:;
    case 2:;
        {
            return (*p).value;
        }
        break;
    case 3:;
        {
            return (i64)(*p).xvalue;
        }
        break;
    default: {
        qq_lib$pcustype((byte*)"getintvalue",p);
    }
    } //SW
;
    return (i64)0;
}

void qq_vars$var_fromobj(i64 tag,struct qq_decls$objrec *p,struct qq_decls$varrec *dest) {
    (*dest).tagx = (tag | (i64)256);
    (*dest).objptr = p;
}

void qq_vars$var_free(struct qq_decls$varrec *a) {
        struct qq_decls$varrec v;
        struct qq_decls$objrec *  q;
    q = (*a).objptr;
        {i64 $temp = (i64)(*q).objtype;
if (($temp==(i64)0)) {
        switch ((i64)(*a).tag) {
        case 13:;
            {
                qq_lists$obj_free_list(q);
            }
            break;
        case 15:;
            {
                qq_records$obj_free_record(q);
            }
            break;
        case 12:;
            {
                qq_strings$obj_free_string(q);
            }
            break;
        case 14:;
            {
                qq_arrays$obj_free_array(q);
            }
            break;
        case 10:;
            {
                qq_arrays$obj_free_vector(q);
            }
            break;
        case 11:;
            {
                qq_bits$obj_free_bits(q,(i64)(*a).tag);
            }
            break;
        case 16:;
            {
                qq_packed$obj_free_struct(q);
            }
            break;
        case 9:;
            {
                qq_dicts$obj_free_dict(q,(i64)0);
            }
            break;
        case 8:;
            {
                qq_sets$obj_free_set(q);
            }
            break;
        case 4:;
            {
                qq_decimal$obj_free_dec(q);
            }
            break;
        case 25:;
            {
                qq_iterators$obj_free_iter(q);
            }
            break;
        default: {
            qq_lib$pcustype((byte*)"free",a);
        }
        } //SW
;
    }
    else if (($temp==(i64)1)) {
        v.tagx = (i64)(*a).tag;
        v.objptr = (*q).objptr2;
        qq_vars$var_unshareu(&v);
        mlib$pcm_free32(q);
    }
    else {
        mlib$pcm_free32(q);
    }
    };
}

void qq_vars$var_duplu(struct qq_decls$varrec *a) {
    switch ((i64)(*a).tag) {
    case 12:;
        {
            qq_strings$var_dupl_string(a);
        }
        break;
    case 8:;
        {
            qq_sets$var_dupl_set(a);
        }
        break;
    case 13:;
        {
            qq_lists$var_dupl_list(a);
        }
        break;
    case 9:;
        {
            qq_dicts$var_dupl_dict(a);
        }
        break;
    case 14:;
        {
            qq_arrays$var_dupl_array(a);
        }
        break;
    case 10:;
        {
            qq_arrays$var_dupl_vector(a);
        }
        break;
    case 11:;
        {
            qq_bits$var_dupl_bits(a);
        }
        break;
    case 15:;
        {
            qq_records$var_dupl_record(a);
        }
        break;
    case 16:;
        {
            qq_packed$var_dupl_struct(a);
        }
        break;
    case 4:;
        {
            qq_decimal$var_dupl_dec(a);
        }
        break;
    case 25:;
        {
            qq_iterators$var_dupl_iter(a);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"dupl",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_neg(struct qq_decls$varrec *a) {
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            (*a).value = -((*a).value);
        }
        break;
    case 3:;
        {
            (*a).xvalue = -((*a).xvalue);
        }
        break;
    case 4:;
        {
            qq_decimal$var_dupl_dec(a);
            qq_decimal$var_neg_dec(a);
        }
        break;
    case 8:;
        {
            qq_sets$var_dupl_set(a);
            qq_sets$var_inotto_set(a);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"neg",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_abs(struct qq_decls$varrec *a) {
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            (*a).value = m$llabs((*a).value);
        }
        break;
    case 3:;
        {
            (*a).xvalue = fabs((*a).xvalue);
        }
        break;
    case 4:;
        {
            qq_decimal$var_dupl_dec(a);
            qq_decimal$var_abs_dec(a);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"abs",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_inot(struct qq_decls$varrec *a) {
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            (*a).value = ~((*a).value);
        }
        break;
    case 8:;
        {
            qq_sets$var_dupl_set(a);
            qq_sets$var_inotto_set(a);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"inot",(i64)(*a).tag);
    }
    } //SW
;
}

i64 qq_vars$var_istruel(struct qq_decls$varrec *a) {
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
    case 17:;
    case 24:;
    case 18:;
    case 19:;
    case 23:;
    case 5:;
        {
            return (i64)!!((*a).value);
        }
        break;
    case 3:;
        {
            return (((*a).xvalue != (double)0.) ? (i64)1 : (i64)0);
        }
        break;
    case 12:;
    case 13:;
    case 14:;
    case 11:;
    case 10:;
        {
            return (i64)((*(*a).objptr).length != (i64)0);
        }
        break;
    case 8:;
        {
            return (i64)((*(*a).objptr).length != (i64)0);
        }
        break;
    case 15:;
    case 16:;
        {
            return (i64)1;
        }
        break;
    case 4:;
        {
            return (i64)!(!!(qq_decimal$bn_iszero((*a).objptr)));
        }
        break;
    case 0:;
        {
            return (i64)0;
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"istruel",(i64)(*a).tag);
    }
    } //SW
;
    return (i64)0;
}

i64 qq_vars$var_negto(struct qq_decls$varrec *p) {
        struct qq_decls$varrec *  a;
    a = (*p).varptr;
    if (((i64)(*p).tag != (i64)17)) {
        return (i64)0;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            (*a).value = -((*a).value);
        }
        break;
    case 3:;
        {
            (*a).xvalue = -((*a).xvalue);
        }
        break;
    case 8:;
        {
            qq_sets$var_inotto_set(a);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"negto",(i64)(*a).tag);
    }
    } //SW
;
    return (i64)1;
}

i64 qq_vars$var_absto(struct qq_decls$varrec *p) {
        struct qq_decls$varrec *  a;
    a = (*p).varptr;
    if (((i64)(*p).tag != (i64)17)) {
        return (i64)0;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            (*a).value = m$llabs((*a).value);
        }
        break;
    case 3:;
        {
            (*a).xvalue = fabs((*a).xvalue);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"absto",(i64)(*a).tag);
    }
    } //SW
;
    return (i64)1;
}

i64 qq_vars$var_inotto(struct qq_decls$varrec *p) {
        struct qq_decls$varrec *  a;
    a = (*p).varptr;
    if (((i64)(*p).tag != (i64)17)) {
        return (i64)0;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            (*a).value = ~((*a).value);
        }
        break;
    case 8:;
        {
            qq_sets$var_inotto_set(a);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"inotto",(i64)(*a).tag);
    }
    } //SW
;
    return (i64)1;
}

void qq_vars$var_add(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_addmixed(a,b);
        return;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            (*a).value += (*b).value;
        }
        break;
    case 3:;
        {
            (*a).xvalue += (*b).xvalue;
        }
        break;
    case 4:;
        {
            qq_decimal$var_add_dec(a,b);
        }
        break;
    case 12:;
        {
            qq_strings$var_add_string(a,b);
        }
        break;
    case 8:;
        {
            qq_sets$var_dupl_set(a);
            qq_sets$var_iorto_set(a,b);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"add",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_addmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65539)) {
        newtag = (i64)3;
        (*a).xvalue = ((r64)(*a).value + (*b).xvalue);
    }
    else if (($temp==(i64)196609)) {
        (*a).xvalue += (r64)(*b).value;
    }
    else if (($temp==(i64)65538)) {
        (*a).value += (*b).value;
    }
    else if (($temp==(i64)131073)) {
        newtag = (i64)1;
        (*a).value += (*b).value;
    }
    else if (($temp==(i64)65540) || ($temp==(i64)196612)) {
        newtag = (i64)4;
        qq_decimal$var_add_dec(qq_decimal$dectemp(a),b);
        qq_decimal$freedectemp();
    }
    else if (($temp==(i64)262145) || ($temp==(i64)262147)) {
        qq_decimal$var_add_dec(a,qq_decimal$dectemp(b));
    }
    else if (($temp==(i64)1572865)) {
        if (((*a).ptr == 0)) {
            qq_lib$pcerror((byte*)"Nil+x");
        }
;
        (*a).ptr += (qq_tables$ttsize[((i64)(*a).elemtag)] * (*b).value);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Addmixed",a,b);
    }
    };
    (*a).tag = newtag;
}

void qq_vars$var_sub(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        byte *  p;
        byte *  q;
        i64 elemsize;
        i64 x;
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_submixed(a,b);
        return;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            (*a).value -= (*b).value;
        }
        break;
    case 3:;
        {
            (*a).xvalue -= (*b).xvalue;
        }
        break;
    case 4:;
        {
            qq_decimal$var_sub_dec(a,b);
        }
        break;
    case 24:;
        {
            p = (*a).ptr;
            q = (*b).ptr;
                        {i64 $temp = (elemsize = qq_tables$ttsize[((i64)(*a).elemtag)]);
if (($temp==(i64)1)) {
                x = (p - q);
            }
            else if (($temp==(i64)2)) {
                x = ((p - q) >> (i64)1);
            }
            else if (($temp==(i64)4)) {
                x = ((p - q) >> (i64)2);
            }
            else {
                x = ((p - q) / elemsize);
            }
            };
            (*a).tagx = (i64)1;
            (*a).value = x;
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"sub",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_submixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65539)) {
        newtag = (i64)3;
        (*a).xvalue = ((r64)(*a).value - (*b).xvalue);
    }
    else if (($temp==(i64)196609)) {
        (*a).xvalue -= (r64)(*b).value;
    }
    else if (($temp==(i64)65538)) {
        (*a).value -= (*b).value;
    }
    else if (($temp==(i64)131073)) {
        newtag = (i64)1;
        (*a).value -= (*b).value;
    }
    else if (($temp==(i64)65540) || ($temp==(i64)196612)) {
        newtag = (i64)4;
        qq_decimal$var_sub_dec(qq_decimal$dectemp(a),b);
        qq_decimal$freedectemp();
    }
    else if (($temp==(i64)262145) || ($temp==(i64)262147)) {
        qq_decimal$var_sub_dec(a,qq_decimal$dectemp(b));
    }
    else if (($temp==(i64)1572865)) {
        (*a).ptr -= (qq_tables$ttsize[((i64)(*a).elemtag)] * (*b).value);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Submixed",a,b);
    }
    };
    (*a).tag = newtag;
}

void qq_vars$var_mul(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_mulmixed(a,b);
        return;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            (*a).value *= (*b).value;
        }
        break;
    case 3:;
        {
            (*a).xvalue *= (*b).xvalue;
        }
        break;
    case 4:;
        {
            qq_decimal$var_mul_dec(a,b);
        }
        break;
    case 8:;
        {
            qq_sets$var_dupl_set(a);
            qq_sets$var_iandto_set(a,b);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"mul",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_mulmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65539)) {
        newtag = (i64)3;
        (*a).xvalue = ((r64)(*a).value * (*b).xvalue);
    }
    else if (($temp==(i64)196609)) {
        (*a).xvalue *= (r64)(*b).value;
    }
    else if (($temp==(i64)65538)) {
        (*a).value *= (*b).value;
    }
    else if (($temp==(i64)131073)) {
        newtag = (i64)1;
        (*a).value *= (*b).value;
    }
    else if (($temp==(i64)65540) || ($temp==(i64)196612)) {
        newtag = (i64)4;
        qq_decimal$var_mul_dec(qq_decimal$dectemp(a),b);
        qq_decimal$freedectemp();
    }
    else if (($temp==(i64)262145) || ($temp==(i64)262147)) {
        qq_decimal$var_mul_dec(a,qq_decimal$dectemp(b));
    }
    else if (($temp==(i64)786433)) {
        qq_strings$var_mul_string(a,(*b).value);
    }
    else if (($temp==(i64)851969)) {
        qq_lists$var_mul_list(a,(*b).value);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Mulmixed",a,b);
    }
    };
    (*a).tag = newtag;
}

void qq_vars$var_div(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_divmixed(a,b);
        return;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
        {
            (*a).tagx = (i64)3;
            (*a).xvalue = ((r64)(*a).value / (r64)(*b).value);
        }
        break;
    case 3:;
        {
            (*a).xvalue /= (*b).xvalue;
        }
        break;
    case 4:;
        {
            qq_decimal$var_div_dec(a,b);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"div",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_divmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65539)) {
        newtag = (i64)3;
        (*a).xvalue = ((r64)(*a).value / (*b).xvalue);
    }
    else if (($temp==(i64)196609)) {
        (*a).xvalue /= (r64)(*b).value;
    }
    else if (($temp==(i64)65538)) {
        newtag = (i64)3;
        (*a).xvalue = ((r64)(*a).value / (r64)(*b).value);
    }
    else if (($temp==(i64)131073)) {
        newtag = (i64)3;
        (*a).xvalue = ((r64)(*a).value / (r64)(*b).value);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Divmixed",a,b);
    }
    };
    (*a).tag = newtag;
}

void qq_vars$var_idiv(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_idivmixed(a,b);
        return;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
        {
            if (!!((*b).value)) {
                (*a).value = ((*a).value / (*b).value);
            }
            else {
                qq_lib$pcerror((byte*)"Divide by 0");
            }
;
        }
        break;
    case 4:;
        {
            qq_decimal$var_idiv_dec(a,b);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"idiv",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_idivmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65538)) {
        (*a).value = ((*a).value / (i64)(*b).uvalue);
    }
    else if (($temp==(i64)131073)) {
        newtag = (i64)1;
        (*a).value = ((i64)(*a).uvalue / (*b).value);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Idivmixed",a,b);
    }
    };
    (*a).tag = newtag;
}

void qq_vars$var_irem(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_iremmixed(a,b);
        return;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
        {
            (*a).value = ((*a).value % (*b).value);
        }
        break;
    case 4:;
        {
            qq_decimal$var_irem_dec(a,b);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"irem",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_iremmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65538)) {
        (*a).value = ((*a).value % (i64)(*b).uvalue);
    }
    else if (($temp==(i64)131073)) {
        newtag = (i64)1;
        (*a).value = ((i64)(*a).uvalue % (*b).value);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Iremmixed",a,b);
    }
    };
    (*a).tag = newtag;
}

void qq_vars$var_iand(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_iandmixed(a,b);
        return;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            (*a).value &= (*b).value;
        }
        break;
    case 8:;
        {
            qq_sets$var_dupl_set(a);
            qq_sets$var_iandto_set(a,b);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"iand",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_iandmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65538) || ($temp==(i64)131073)) {
        newtag = (i64)1;
        (*a).value &= (*b).value;
    }
    else {
        qq_lib$pcmxtypes((byte*)"Iandmixed",a,b);
    }
    };
    (*a).tag = newtag;
}

void qq_vars$var_ior(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_iormixed(a,b);
        return;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            (*a).value |= (*b).value;
        }
        break;
    case 8:;
        {
            qq_sets$var_dupl_set(a);
            qq_sets$var_iorto_set(a,b);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"ior",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_iormixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65538) || ($temp==(i64)131073)) {
        newtag = (i64)1;
        (*a).value |= (*b).value;
    }
    else {
        qq_lib$pcmxtypes((byte*)"Iormixed",a,b);
    }
    };
    (*a).tag = newtag;
}

void qq_vars$var_ixor(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_ixormixed(a,b);
        return;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            (*a).value ^= (*b).value;
        }
        break;
    case 8:;
        {
            qq_sets$var_dupl_set(a);
            qq_sets$var_ixorto_set(a,b);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"ixor",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_ixormixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65538) || ($temp==(i64)131073)) {
        newtag = (i64)1;
        (*a).value &= (*b).value;
    }
    else {
        qq_lib$pcmxtypes((byte*)"Ixormixed",a,b);
    }
    };
    (*a).tag = newtag;
}

void qq_vars$var_shl(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_shlmixed(a,b);
        return;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
        {
            (*a).value <<= (*b).value;
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"shl",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_shlmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65538)) {
        (*a).value <<= (*b).value;
    }
    else if (($temp==(i64)131073)) {
        newtag = (i64)1;
        (*a).uvalue <<= (*b).value;
    }
    else {
        qq_lib$pcmxtypes((byte*)"shlmixed",a,b);
    }
    };
    (*a).tag = newtag;
}

void qq_vars$var_shr(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_shrmixed(a,b);
        return;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
        {
            (*a).value >>= (*b).value;
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"shr",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_shrmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
    {
        qq_lib$pcmxtypes((byte*)"shrmixed",a,b);
    }
;
    (*a).tag = newtag;
}

i64 qq_vars$var_in(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 n;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65544)) {
        return qq_sets$var_in_set(a,b);
    }
    else if (($temp==(i64)65542)) {
        return (((*a).value >= msysc$m_getdotslice((*b).dummy,(i64)16,(i64)63) && (*a).value <= (i64)(*b).range_upper) ? (i64)1 : (i64)0);
    }
    else {
                {i64 $temp = (i64)(*b).tag;
if (($temp==(i64)13) || ($temp==(i64)12) || ($temp==(i64)14) || ($temp==(i64)10)) {
            n = qq_vars$var_inx(a,b);
            return ((n != (i64)(-9223372036854775807-1)) ? (i64)1 : (i64)0);
        }
        else {
            qq_lib$pcmxtypes((byte*)"in",a,b);
        }
        };
    }
    };
    return (i64)0;
}

i64 qq_vars$var_inx(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)786444)) {
        return qq_strings$var_inx_string(a,b);
    }
    else if (($temp==(i64)65550) || ($temp==(i64)196622) || ($temp==(i64)131086)) {
        return qq_arrays$var_inx_array(a,b,(i64)0);
    }
    else if (($temp==(i64)65546) || ($temp==(i64)196618) || ($temp==(i64)131082)) {
        return qq_arrays$var_inx_array(a,b,(i64)(*(*b).objptr).usertag);
    }
    else {
                {i64 $temp = (i64)(*b).tag;
if (($temp==(i64)13)) {
            return qq_lists$var_inx_list(a,b);
        }
        else {
            qq_lib$pcmxtypes((byte*)"inx",a,b);
        }
        };
    }
    };
    return (i64)0;
}

i64 qq_vars$var_equal(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        return qq_vars$var_equalmixed(a,b);
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
    case 17:;
    case 24:;
    case 19:;
    case 23:;
    case 5:;
        {
            return (i64)((*a).value == (*b).value);
        }
        break;
    case 3:;
        {
            return (((*a).xvalue == (*b).xvalue) ? (i64)1 : (i64)0);
        }
        break;
    case 4:;
        {
            return qq_decimal$var_equal_dec(a,b);
        }
        break;
    case 12:;
        {
            return qq_strings$var_equal_string(a,b);
        }
        break;
    case 8:;
        {
            return qq_sets$var_equal_set(a,b);
        }
        break;
    case 13:;
        {
            return qq_lists$var_equal_list(a,b);
        }
        break;
    case 9:;
        {
            return qq_dicts$var_equal_dict(a,b);
        }
        break;
    case 14:;
    case 10:;
        {
            return qq_arrays$var_equal_array(a,b);
        }
        break;
    case 11:;
        {
            return qq_bits$var_equal_bits(a,b);
        }
        break;
    case 15:;
        {
            return qq_records$var_equal_record(a,b);
        }
        break;
    case 16:;
        {
            return qq_packed$var_equal_struct(a,b);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"equal",(i64)(*a).tag);
    }
    } //SW
;
    return (i64)0;
}

i64 qq_vars$var_equalmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 result;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65539)) {
        return (((r64)(*a).value == (*b).xvalue) ? (i64)1 : (i64)0);
    }
    else if (($temp==(i64)196609)) {
        return (((*a).xvalue == (r64)(*b).value) ? (i64)1 : (i64)0);
    }
    else if (($temp==(i64)65538)) {
        return (((*a).value == (i64)(*b).uvalue) ? (i64)1 : (i64)0);
    }
    else if (($temp==(i64)131073)) {
        return (((i64)(*a).uvalue == (*b).value) ? (i64)1 : (i64)0);
    }
    else if (($temp==(i64)65540) || ($temp==(i64)196612)) {
        result = qq_decimal$var_equal_dec(qq_decimal$dectemp(a),b);
        qq_decimal$freedectemp();
        return result;
    }
    else if (($temp==(i64)262145) || ($temp==(i64)262147)) {
        return qq_decimal$var_equal_dec(a,qq_decimal$dectemp(b));
    }
    else {
        return (i64)0;
    }
    };
    return (i64)0;
}

i64 qq_vars$var_compare(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        return qq_vars$var_comparemixed(a,b);
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
    case 24:;
        {
            return (((*a).value < (*b).value) ? (i64)-1 : (((*a).value > (*b).value) ? (i64)1 : (i64)0));
        }
        break;
    case 3:;
        {
            return (((*a).xvalue < (*b).xvalue) ? (i64)-1 : (((*a).xvalue > (*b).xvalue) ? (i64)1 : (i64)0));
        }
        break;
    case 4:;
        {
            return qq_decimal$var_compare_dec(a,b);
        }
        break;
    case 12:;
        {
            return qq_strings$var_compare_string(a,b);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"compare",(i64)(*a).tag);
    }
    } //SW
;
    return (i64)0;
}

i64 qq_vars$var_comparemixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65539)) {
        return (((r64)(*a).value < (*b).xvalue) ? (i64)-1 : (((r64)(*a).value > (*b).xvalue) ? (i64)1 : (i64)0));
    }
    else if (($temp==(i64)196609)) {
        return (((*a).xvalue < (r64)(*b).value) ? (i64)-1 : (((*a).xvalue > (r64)(*b).value) ? (i64)1 : (i64)0));
    }
    else {
        qq_lib$pcmxtypes((byte*)"comparemixed",a,b);
    }
    };
    return (i64)0;
}

void qq_vars$var_concat(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_lib$pcmxtypes((byte*)"Concat",a,b);
    }
;
    switch ((i64)(*a).tag) {
    case 12:;
        {
            qq_strings$var_add_string(a,b);
        }
        break;
    case 13:;
        {
            qq_lists$var_dupl_list(a);
            qq_lists$var_concatto_list(a,b);
        }
        break;
    case 14:;
        {
            qq_arrays$var_dupl_array(a);
            qq_arrays$var_concatto_array(a,b);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"concat",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_append(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
                {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)13)) {
            goto L1140 ;
;
        }
        else if (($temp==(i64)14)) {
            goto L1141 ;
;
        }
        else if (($temp==(i64)11)) {
            goto L1142 ;
;
        }
        };
        goto L1143 ;
;
    }
    else {
        switch ((i64)(*a).tag) {
        case 12:;
            {
                qq_strings$var_add_string(a,b);
                qq_vars$var_unshareu(b);
            }
            break;
        case 13:;
            {
                //dolist:
L1140 :;
;
                qq_lists$var_dupl_list(a);
                qq_lists$var_appendto_list(a,b);
            }
            break;
        case 14:;
            {
                //doarray:
L1141 :;
;
                qq_arrays$var_dupl_array(a);
                qq_arrays$var_appendto_array(a,b);
            }
            break;
        case 11:;
            {
                //dobits:
L1142 :;
;
                qq_bits$var_dupl_bits(a);
                qq_bits$var_appendto_bits(a,b);
            }
            break;
        default: {
            //error:
L1143 :;
;
            qq_lib$pcustype_t((byte*)"append",(i64)(*a).tag);
        }
        } //SW
;
    }
;
}

void qq_vars$var_min(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_minmixed(a,b);
        return;
    }
;
    qq_lib$pcerror((byte*)"VARMIN");
}

void qq_vars$var_minmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    qq_lib$pcerror((byte*)"VARMINMIX");
}

void qq_vars$var_max(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_maxmixed(a,b);
        return;
    }
;
    qq_lib$pcerror((byte*)"VARMAX");
}

void qq_vars$var_maxmixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    qq_lib$pcerror((byte*)"VARMAXMIX");
}

i64 qq_vars$var_addto(struct qq_decls$varrec *p,struct qq_decls$varrec *b) {
        struct qq_decls$varrec *  a;
        i64 newtag;
    a = (*p).varptr;
    if (((i64)(*p).tag != (i64)17)) {
        return (i64)0;
    }
;
    newtag = (i64)(*a).tag;
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        if (((newtag == (i64)12) && ((i64)(*b).tag == (i64)1))) {
            qq_strings$var_addto_string_ch(a,(*b).value);
            return (i64)1;
        }
;
        return (i64)0;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            (*a).value += (*b).value;
        }
        break;
    case 3:;
        {
            (*a).xvalue += (*b).xvalue;
        }
        break;
    case 12:;
        {
            qq_strings$var_addto_string(a,b);
        }
        break;
    case 8:;
        {
            qq_sets$var_iorto_set(a,b);
        }
        break;
    default: {
        return (i64)0;
    }
    } //SW
;
    (*a).tag = newtag;
    return (i64)1;
}

i64 qq_vars$var_multo(struct qq_decls$varrec *p,struct qq_decls$varrec *b) {
        struct qq_decls$varrec *  a;
        i64 newtag;
    a = (*p).varptr;
    if (((i64)(*p).tag != (i64)17)) {
        return (i64)0;
    }
;
    newtag = (i64)(*a).tag;
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        return (i64)0;
    }
;
    switch ((i64)(*a).tag) {
    case 8:;
        {
            qq_sets$var_iandto_set(a,b);
        }
        break;
    default: {
        return (i64)0;
    }
    } //SW
;
    (*a).tag = newtag;
    return (i64)1;
}

i64 qq_vars$var_iandto(struct qq_decls$varrec *p,struct qq_decls$varrec *b) {
        struct qq_decls$varrec *  a;
        i64 newtag;
    a = (*p).varptr;
    if (((i64)(*p).tag != (i64)17)) {
        return (i64)0;
    }
;
    newtag = (i64)(*a).tag;
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        return (i64)0;
    }
;
    switch ((i64)(*a).tag) {
    case 8:;
        {
            qq_sets$var_iandto_set(a,b);
        }
        break;
    default: {
        return (i64)0;
    }
    } //SW
;
    (*a).tag = newtag;
    return (i64)1;
}

i64 qq_vars$var_iorto(struct qq_decls$varrec *p,struct qq_decls$varrec *b) {
        struct qq_decls$varrec *  a;
        i64 newtag;
    a = (*p).varptr;
    if (((i64)(*p).tag != (i64)17)) {
        return (i64)0;
    }
;
    newtag = (i64)(*a).tag;
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        return (i64)0;
    }
;
    switch ((i64)(*a).tag) {
    case 8:;
        {
            qq_sets$var_iorto_set(a,b);
        }
        break;
    default: {
        return (i64)0;
    }
    } //SW
;
    (*a).tag = newtag;
    return (i64)1;
}

i64 qq_vars$var_ixorto(struct qq_decls$varrec *p,struct qq_decls$varrec *b) {
        struct qq_decls$varrec *  a;
        i64 newtag;
    a = (*p).varptr;
    if (((i64)(*p).tag != (i64)17)) {
        return (i64)0;
    }
;
    newtag = (i64)(*a).tag;
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        return (i64)0;
    }
;
    switch ((i64)(*a).tag) {
    case 8:;
        {
            qq_sets$var_ixorto_set(a,b);
        }
        break;
    default: {
        return (i64)0;
    }
    } //SW
;
    (*a).tag = newtag;
    return (i64)1;
}

i64 qq_vars$var_shlto(struct qq_decls$varrec *p,struct qq_decls$varrec *b) {
    return (i64)0;
}

i64 qq_vars$var_shrto(struct qq_decls$varrec *p,struct qq_decls$varrec *b) {
    return (i64)0;
}

i64 qq_vars$var_concatto(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_lib$pcerror((byte*)"concatto/mixed");
    }
;
    switch ((i64)(*a).tag) {
    case 12:;
        {
            qq_strings$var_addto_string(a,b);
        }
        break;
    case 13:;
        {
            qq_lists$var_concatto_list(a,b);
        }
        break;
    case 14:;
        {
            qq_arrays$var_concatto_array(a,b);
        }
        break;
    default: {
        qq_lib$pcustype((byte*)"concat",a);
    }
    } //SW
;
    return (i64)1;
}

i64 qq_vars$var_appendto(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
                {i64 $temp = (i64)(*a).tag;
if (($temp==(i64)13)) {
            goto L1144 ;
;
        }
        else if (($temp==(i64)14)) {
            goto L1145 ;
;
        }
        else if (($temp==(i64)11)) {
            goto L1146 ;
;
        }
        else {
            qq_lib$pcerror((byte*)"appendto/mixed");
        }
        };
    }
;
    switch ((i64)(*a).tag) {
    case 12:;
        {
            qq_strings$var_addto_string(a,b);
            qq_vars$var_unshareu(b);
        }
        break;
    case 13:;
        {
            //dolist:
L1144 :;
;
            qq_lists$var_appendto_list(a,b);
        }
        break;
    case 14:;
        {
            //doarray:
L1145 :;
;
            qq_arrays$var_appendto_array(a,b);
        }
        break;
    case 11:;
        {
            //dobits:
L1146 :;
;
            qq_bits$var_appendto_bits(a,b);
        }
        break;
    default: {
        qq_lib$pcustype((byte*)"append",a);
        return (i64)0;
    }
    } //SW
;
    return (i64)1;
}

void qq_vars$var_getix(struct qq_decls$varrec *a,i64 index) {
    switch ((i64)(*a).tag) {
    case 12:;
        {
            qq_strings$var_getix_string(a,index);
        }
        break;
    case 13:;
    case 9:;
        {
            qq_lists$var_getix_list(a,index);
        }
        break;
    case 14:;
    case 10:;
        {
            qq_arrays$var_getix_array(a,index);
        }
        break;
    case 11:;
        {
            qq_bits$var_getix_bits(a,index);
        }
        break;
    case 8:;
        {
            qq_sets$var_getix_set(a,index);
        }
        break;
    case 15:;
        {
            qq_records$var_getix_record(a,index);
        }
        break;
    case 6:;
        {
            if ((index >= msysc$m_getdotslice((*a).dummy,(i64)16,(i64)63) && index <= (i64)(*a).range_upper)) {
                (*a).tagx = (i64)1;
                (*a).value = index;
            }
            else {
                qq_lib$pcerror((byte*)"range/bounds");
            }
;
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"getix",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_putix(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *x) {
    switch ((i64)(*a).tag) {
    case 12:;
        {
            qq_strings$var_putix_string(a,index,x);
            qq_vars$var_unshareu(x);
        }
        break;
    case 13:;
        {
            qq_lists$var_putix_list(a,index,x);
        }
        break;
    case 14:;
    case 10:;
        {
            qq_arrays$var_putix_array(a,index,x);
        }
        break;
    case 11:;
        {
            qq_bits$var_putix_bits(a,index,x);
        }
        break;
    case 8:;
        {
            qq_sets$var_putix_set(a,index,x);
        }
        break;
    case 15:;
        {
            qq_records$var_putix_record(a,index,x);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"putix",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_getixref(struct qq_decls$varrec *a,i64 index) {
    switch ((i64)(*a).tag) {
    case 12:;
        {
            qq_strings$var_getixref_string(a,index);
        }
        break;
    case 13:;
        {
            qq_lists$var_getixref_list(a,index);
        }
        break;
    case 14:;
    case 10:;
        {
            qq_arrays$var_getixref_array(a,index);
        }
        break;
    case 11:;
        {
            qq_bits$var_getixref_bits(a,index);
        }
        break;
    case 8:;
        {
            qq_sets$var_getixref_set(a,index);
        }
        break;
    case 15:;
        {
            qq_records$var_getixref_record(a,index,a);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"getixref",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_getslice(struct qq_decls$varrec *a,i64 i,i64 j) {
    switch ((i64)(*a).tag) {
    case 12:;
        {
            qq_strings$var_getslice_string(a,i,j);
        }
        break;
    case 13:;
        {
            qq_lists$var_getslice_list(a,i,j);
        }
        break;
    case 14:;
        {
            qq_arrays$var_getslice_array(a,i,j);
        }
        break;
    case 11:;
        {
            qq_bits$var_getslice_bits(a,i,j);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"getslice",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_putslice(struct qq_decls$varrec *a,i64 i,i64 j,struct qq_decls$varrec *x) {
    if (((i64)(*a).tag != (i64)(*x).tag)) {
        qq_lib$pcerror((byte*)"putslice: not compatible");
    }
;
    switch ((i64)(*a).tag) {
    case 12:;
        {
            qq_strings$var_putslice_string(a,i,j,x);
        }
        break;
    case 13:;
        {
            qq_lists$var_putslice_list(a,i,j,x);
        }
        break;
    case 14:;
        {
            qq_arrays$var_putslice_array(a,i,j,x);
        }
        break;
    case 11:;
        {
            qq_bits$var_putslice_bits(a,i,j,x);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"putslice",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_getdotix(struct qq_decls$varrec *a,i64 index) {
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            if (!((index >= (i64)0 && index <= (i64)63))) {
                qq_lib$pcerror((byte*)"int.[int] bounds");
            }
;
            (*a).value = (((*a).value >> index) & (i64)1);
        }
        break;
    case 12:;
        {
            qq_strings$var_getdotix_string(a,index);
        }
        break;
    case 15:;
        {
            qq_records$var_getix_record(a,index);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"getdotix",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_putdotix(struct qq_decls$varrec *p,i64 index,struct qq_decls$varrec *x) {
        struct qq_decls$varrec *  a;
    if (((i64)(*p).tag == (i64)17)) {
        a = (*p).varptr;
        switch ((i64)(*a).tag) {
        case 1:;
        case 2:;
            {
                if (!((index >= (i64)0 && index <= (i64)63))) {
                    qq_lib$pcerror((byte*)"int.[int]:= bounds");
                }
;
                qq_vars$var_storebit((byte *)&(*a).value,index,x,(i64)35,(i64)1);
            }
            break;
        case 12:;
            {
                qq_strings$var_putdotix_string(a,index,x);
            }
            break;
        case 15:;
            {
                qq_records$var_putix_record(a,index,x);
            }
            break;
        default: {
            qq_lib$pcustype((byte*)"putdotix",a);
        }
        } //SW
;
    }
    else {
        qq_lib$pcustype((byte*)"putdotix",p);
    }
;
}

void qq_vars$var_getdotixref(struct qq_decls$varrec *p,i64 index) {
        struct qq_decls$varrec *  a;
    if (((i64)(*p).tag == (i64)17)) {
        a = (*p).varptr;
        switch ((i64)(*a).tag) {
        case 1:;
        case 2:;
            {
                if (!((index >= (i64)0 && index <= (i64)63))) {
                    qq_lib$pcerror((byte*)"&int.[int] bounds");
                }
;
                (*p).ptr = (byte *)&(*a).value;
                (*p).tagx = (i64)18;
                (*p).elemtag = (i64)35;
                (*p).bitoffset = index;
                (*p).bitlength = (i64)1;
            }
            break;
        case 12:;
            {
                qq_strings$var_getdotixref_string(a,index,p);
            }
            break;
        case 15:;
            {
                qq_records$var_getixref_record(a,index,p);
            }
            break;
        default: {
            qq_lib$pcustype_t((byte*)"getdotixref",(i64)(*a).tag);
        }
        } //SW
;
    }
    else {
        qq_lib$pcustype((byte*)"not refvar",p);
    }
;
}

void qq_vars$var_getdotslice(struct qq_decls$varrec *a,i64 i,i64 j) {
    switch ((i64)(*a).tag) {
    case 1:;
    case 2:;
        {
            if ((i > j)) {
                {i64 temp = i; i = j; j = temp; };
            }
;
            if (((i < (i64)0) || (j > (i64)63))) {
                qq_lib$pcerror((byte*)"int.[slice] bounds");
            }
;
            (*a).value = (((*a).value >> i) & (i64)~(((u64)18446744073709551615u << ((j - i) + (i64)1))));
        }
        break;
    case 12:;
        {
            qq_strings$var_getslice_string(a,i,j);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"getdotslice",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_putdotslice(struct qq_decls$varrec *p,i64 i,i64 j,struct qq_decls$varrec *x) {
        struct qq_decls$varrec *  a;
    if (((i64)(*p).tag == (i64)17)) {
        a = (*p).varptr;
        switch ((i64)(*a).tag) {
        case 1:;
        case 2:;
            {
                if ((i > j)) {
                    {i64 temp = i; i = j; j = temp; };
                }
;
                if (((i < (i64)0) || (j > (i64)63))) {
                    qq_lib$pcerror((byte*)"int.[slice]:= bounds");
                }
;
                qq_vars$var_storebit((byte *)&(*a).value,i,x,(i64)35,((j - i) + (i64)1));
            }
            break;
        case 12:;
            {
                qq_strings$var_putslice_string(a,i,j,x);
            }
            break;
        default: {
            qq_lib$pcustype((byte*)"putdotslice",a);
        }
        } //SW
;
    }
    else {
        qq_lib$pcustype((byte*)"not ref",p);
    }
;
}

void qq_vars$var_getdotsliceref(struct qq_decls$varrec *p,i64 i,i64 j) {
        struct qq_decls$varrec *  a;
    if (((i64)(*p).tag == (i64)17)) {
        a = (*p).varptr;
        switch ((i64)(*a).tag) {
        case 1:;
        case 2:;
            {
                if ((i > j)) {
                    {i64 temp = i; i = j; j = temp; };
                }
;
                if (((i < (i64)0) || (j > (i64)63))) {
                    qq_lib$pcerror((byte*)"&int.[slice] bounds");
                }
;
                (*p).ptr = (byte *)&(*a).value;
                (*p).tagx = (i64)18;
                (*p).elemtag = (i64)35;
                (*p).bitoffset = i;
                (*p).bitlength = ((j - i) + (i64)1);
            }
            break;
        default: {
            qq_lib$pcustype((byte*)"getdotsliceref",a);
        }
        } //SW
;
    }
    else {
        qq_lib$pcustype((byte*)"not ref",p);
    }
;
}

void qq_vars$var_expand(struct qq_decls$varrec *a,struct qq_decls$varrec *dest,i64 m) {
        struct qq_decls$varrec *  b;
        struct qq_decls$varrec *  c;
        struct qq_decls$objrec *  p;
        i64 n;
        i64 length;
        i64 $av_1;
        i64 $av_2;
    if ((m < (i64)2)) {
        qq_lib$pcerror((byte*)"Expand: LHS too few");
    }
;
    switch ((i64)(*a).tag) {
    case 13:;
        {
            p = (*a).objptr;
            length = (*p).length;
            //dolist:
L1147 :;
;
            b = dest;
            c = (*p).varptr;
            n = (i64)1;
            $av_1 = m;
            while ($av_1-- > 0) {
L1148 :;
                if ((n > length)) {
                    (*dest).tagx = (i64)0;
                }
                else {
                    (*dest) = (*c);
                    if (!!((i64)(*dest).hasref)) {
                        ++((*(*dest).objptr).refcount);
                    }
;
                    ++(c);
                }
;
                ++(n);
                --(dest);
L1149 :;
            }
L1150 :;
            ;
        }
        break;
    case 6:;
        {
            (*dest).tagx = (i64)1;
            (*dest).value = msysc$m_getdotslice((*a).dummy,(i64)16,(i64)63);
            --(dest);
            (*dest).tagx = (i64)1;
            (*dest).value = (i64)(*a).range_upper;
            $av_2 = (m - (i64)2);
            while ($av_2-- > 0) {
L1151 :;
                --(dest);
                (*dest).tagx = (i64)0;
L1152 :;
            }
L1153 :;
            ;
        }
        break;
    case 12:;
        {
            qq_strings$var_expand_string(a,dest,m);
        }
        break;
    case 15:;
        {
            p = (*a).objptr;
            length = qq_tables$ttlength[((i64)(*p).usertag)];
            goto L1147 ;
;
        }
        break;
    case 14:;
    case 10:;
        {
            qq_arrays$var_expand_array(a,dest,m);
        }
        break;
    default: {
        qq_lib$pcustype((byte*)"expand",a);
    }
    } //SW
;
}

i64 qq_vars$var_minto(struct qq_decls$varrec *p,struct qq_decls$varrec *b) {
        struct qq_decls$varrec *  a;
        i64 newtag;
    a = (*p).varptr;
    if (((i64)(*p).tag != (i64)17)) {
        return (i64)0;
    }
;
    if (!!((newtag = (i64)((i64)(*a).tag != (i64)(*b).tag)))) {
        return (i64)0;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
        {
            (*a).value=((*a).value<(*b).value?(*a).value:(*b).value);
;
        }
        break;
    case 4:;
        {
            if ((qq_decimal$var_compare_dec(a,b) > (i64)0)) {
                ++((*(*b).objptr).refcount);
                qq_vars$var_unshareu(a);
                (*a) = (*b);
            }
;
        }
        break;
    case 12:;
        {
            if ((qq_strings$var_compare_string(a,b) > (i64)0)) {
                ++((*(*b).objptr).refcount);
                qq_vars$var_unshareu(a);
                (*a) = (*b);
            }
;
        }
        break;
    default: {
        return (i64)0;
    }
    } //SW
;
    return (i64)1;
}

i64 qq_vars$var_maxto(struct qq_decls$varrec *p,struct qq_decls$varrec *b) {
        struct qq_decls$varrec *  a;
        i64 newtag;
    a = (*p).varptr;
    if (((i64)(*p).tag != (i64)17)) {
        return (i64)0;
    }
;
    if (!!((newtag = (i64)((i64)(*a).tag != (i64)(*b).tag)))) {
        return (i64)0;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
        {
            (*a).value=((*a).value>(*b).value?(*a).value:(*b).value);
;
        }
        break;
    case 4:;
        {
            if ((qq_decimal$var_compare_dec(a,b) < (i64)0)) {
                ++((*(*b).objptr).refcount);
                qq_vars$var_unshareu(a);
                (*a) = (*b);
            }
;
        }
        break;
    case 12:;
        {
            if ((qq_strings$var_compare_string(a,b) < (i64)0)) {
                ++((*(*b).objptr).refcount);
                qq_vars$var_unshareu(a);
                (*a) = (*b);
            }
;
        }
        break;
    default: {
        return (i64)0;
    }
    } //SW
;
    return (i64)1;
}

void qq_vars$var_inplace(struct qq_decls$varrec *px,struct qq_decls$varrec *y,void (*fnadd)(struct qq_decls$varrec *,struct qq_decls$varrec *),void (*fnaddmixed)(struct qq_decls$varrec *,struct qq_decls$varrec *)) {
        struct qq_decls$varrec x;
        struct qq_decls$varrec z;
    qq_vars$var_loadptr(px,&x);
    z = x;
    if (((i64)x.tag == (i64)(*y).tag)) {
        ((*fnadd))(&x,y);
    }
    else {
        ((*fnaddmixed))(&x,y);
    }
;
    if (!!((i64)z.hasref)) {
        qq_vars$var_unshareu(&z);
    }
;
    qq_vars$var_storeptr(px,&x);
}

void qq_vars$var_inplace_unary(struct qq_decls$varrec *px,void (*fnneg)(struct qq_decls$varrec *)) {
        struct qq_decls$varrec x;
    qq_vars$var_loadptr(px,&x);
    ((*fnneg))(&x);
    qq_vars$var_storeptr(px,&x);
}

void qq_vars$var_loadptr(struct qq_decls$varrec *x,struct qq_decls$varrec *y) {
    switch ((i64)(*x).tag) {
    case 17:;
        {
            (*y) = (*(*x).varptr);
            if (!!((i64)(*y).hasref)) {
                ++((*(*y).objptr).refcount);
            }
;
        }
        break;
    case 24:;
        {
            qq_packed$var_loadpacked((*x).ptr,(i64)(*x).elemtag,y,0);
        }
        break;
    case 18:;
        {
            qq_vars$var_loadbit((*x).ptr,(i64)(*x).bitoffset,(i64)(*x).elemtag,(i64)(*x).bitlength,y);
        }
        break;
    default: {
        qq_lib$pcustype((byte*)"var_loadptr",x);
    }
    } //SW
;
}

void qq_vars$var_storeptr(struct qq_decls$varrec *p,struct qq_decls$varrec *q) {
        struct qq_decls$varrec *  dest;
    switch ((i64)(*p).tag) {
    case 17:;
        {
            dest = (*p).varptr;
            if (!!((i64)(*dest).hasref)) {
                qq_vars$var_unshareu(dest);
            }
;
            (*dest) = (*q);
        }
        break;
    case 24:;
        {
            qq_packed$var_storepacked((*p).ptr,q,(i64)(*p).elemtag);
        }
        break;
    case 18:;
        {
            qq_vars$var_storebit((*p).ptr,(i64)(*p).bitoffset,q,(i64)(*p).elemtag,(i64)(*p).bitlength);
        }
        break;
    default: {
        qq_lib$pcustype((byte*)"var_popptr",p);
    }
    } //SW
;
}

void qq_vars$var_loadbit(byte *p,i64 shift,i64 t,i64 bitlength,struct qq_decls$varrec *dest) {
        u64 *  pd;
        u64 mask;
    (*dest).tagx = (i64)1;
    switch (t) {
    case 35:;
        {
            if ((bitlength == (i64)0)) {
                (*dest).value = (i64)!!(((i64)(*p) & ((i64)1 << shift)));
            }
            else {
                pd = (u64 *)p;
                mask = (u64)18446744073709551614u;
                if ((bitlength==(i64)1)) {
                }
                else if ((bitlength==(i64)64)) {
                    mask = (u64)0u;
                }
                else {
                    mask <<= (bitlength - (i64)1);
                }
;
                (*dest).value = (i64)(((*pd) >> shift) & ~(mask));
            }
;
        }
        break;
    case 36:;
        {
            (*dest).value = (((i64)(*p) & ((i64)3 << shift)) >> shift);
        }
        break;
    case 37:;
        {
            (*dest).value = (((i64)(*p) & ((i64)15 << shift)) >> shift);
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"loadbit",t);
    }
    } //SW
;
}

void qq_vars$var_storebit(byte *p,i64 shift,struct qq_decls$varrec *q,i64 t,i64 bitlength) {
        u64 *  pd;
        u64 mask1;
        u64 mask2;
        u64 newvalue;
    if (!(((i64)(*q).tag == (i64)1 || (i64)(*q).tag == (i64)2))) {
        qq_lib$pcerror((byte*)"storebit not int");
    }
;
    switch (t) {
    case 35:;
        {
            if ((bitlength == (i64)0)) {
                (*p) = (((i64)(*p) & ~(((i64)1 << shift))) | (((*q).value & (i64)1) << shift));
            }
            else {
                pd = (u64 *)p;
                mask1 = (u64)18446744073709551614u;
                if ((bitlength==(i64)1)) {
                }
                else if ((bitlength==(i64)64)) {
                    mask1 = (u64)0u;
                }
                else {
                    mask1 <<= (bitlength - (i64)1);
                }
;
                mask1 = ~(mask1);
                if (!!(shift)) {
                    mask1 <<= shift;
                }
;
                mask2 = ~(mask1);
                newvalue = (u64)(*q).value;
                if (!!(shift)) {
                    newvalue <<= shift;
                }
;
                (*pd) = (((*pd) & mask2) | (newvalue & mask1));
            }
;
        }
        break;
    case 36:;
        {
            (*p) = (((i64)(*p) & ~(((i64)3 << shift))) | (((*q).value & (i64)3) << shift));
        }
        break;
    case 37:;
        {
            (*p) = (((i64)(*p) & ~(((i64)15 << shift))) | (((*q).value & (i64)15) << shift));
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"storebit",t);
    }
    } //SW
;
}

void qq_vars$var_convert(struct qq_decls$varrec *x,i64 t,struct qq_decls$varrec *dest) {
        i64 s;
        i64 tbase;
        i64 aa;
    (*dest) = (*x);
    s = (i64)(*x).tag;
    if ((s == t)) {
        return;
    }
;
    tbase = t;
    (*dest).tag = t;
    switch (s) {
    case 1:;
        {
            switch (tbase) {
            case 1:;
                {
                }
                break;
            case 3:;
                {
                    (*dest).xvalue = (r64)(*x).value;
                }
                break;
            case 2:;
                {
                }
                break;
            case 4:;
                {
                    qq_decimal$var_make_dec_int((*qq_decls$sptr).value,dest);
                }
                break;
            default: {
                if (((i64)qq_tables$ttbasetype[(t)] == (i64)7)) {
                    (*dest).tag = (i64)7;
                    (*dest).elemtag = t;
                }
                else {
                    qq_lib$pcustype_t((byte*)"conv int=>",t);
                }
;
            }
            } //SW
;
        }
        break;
    case 2:;
        {
            switch (tbase) {
            case 1:;
                {
                }
                break;
            case 2:;
                {
                }
                break;
            case 3:;
                {
                }
                break;
            default: {
                qq_lib$pcustype_t((byte*)"conv dint=>",t);
            }
            } //SW
;
        }
        break;
    case 3:;
        {
            switch (tbase) {
            case 1:;
                {
                    (*dest).value = (i64)(*x).xvalue;
                }
                break;
            default: {
                qq_lib$pcustype_t((byte*)"conv real=>",t);
            }
            } //SW
;
        }
        break;
    case 24:;
    case 17:;
    case 18:;
        {
            switch ((i64)qq_tables$ttbasetype[(tbase)]) {
            case 1:;
            case 2:;
                {
                }
                break;
            case 24:;
                {
                    (*dest).tag = (i64)24;
                    (*dest).elemtag = (i64)qq_tables$tttarget[(t)];
                }
                break;
            default: {
                qq_lib$pcustype_t((byte*)"conv ptr=>",t);
            }
            } //SW
;
        }
        break;
    case 12:;
        {
            switch (tbase) {
            case 13:;
                {
                    qq_strings$var_convert_string_list(x,t,dest);
                }
                break;
            case 4:;
                {
                    qq_decimal$var_make_dec_str((*(*x).objptr).strptr,(*(*x).objptr).length,dest);
                }
                break;
            case 12:;
                {
                }
                break;
            default: {
                qq_lib$pcustype_t((byte*)"string=>",t);
            }
            } //SW
;
        }
        break;
    case 19:;
        {
            if ((tbase != (i64)1)) {
                qq_lib$pcustype_t((byte*)"type=>",t);
            }
;
        }
        break;
    case 4:;
        {
            switch (tbase) {
            case 1:;
                {
                    aa = qq_decimal$var_convert_dec_int(x);
                    (*dest).tagx = (i64)1;
                    (*dest).value = aa;
                }
                break;
            default: {
                qq_lib$pcustype_t((byte*)"decimal=>",t);
            }
            } //SW
;
        }
        break;
    case 7:;
        {
            switch (tbase) {
            case 1:;
                {
                    (*dest).tagx = (i64)1;
                }
                break;
            case 7:;
                {
                    (*dest).elemtag = (i64)(*x).elemtag;
                }
                break;
            default: {
                qq_lib$pcustype_t((byte*)"conv enum=>",t);
            }
            } //SW
;
        }
        break;
    default: {
        qq_lib$pcmxtypestt((byte*)"Convert s.t",s,t);
    }
    } //SW
;
}

i64 qq_vars$var_gethashvalue(struct qq_decls$varrec *p) {
        i64 hsum;
        i64 c;
        i64 n;
        i64 result;
        u8 *  s;
        struct qq_decls$objrec *  q;
        i64 $av_1;
    switch ((i64)(*p).tag) {
    case 12:;
        {
            n = (*(*p).objptr).length;
            if (!(!!(n))) {
                return (i64)0;
            }
;
            hsum = (i64)0;
            s = (*(*p).objptr).strptr;
            $av_1 = n;
            while ($av_1-- > 0) {
L1154 :;
                c = (i64)(u64)(*(s)++);
                hsum = (((hsum << (i64)4) - hsum) + c);
L1155 :;
            }
L1156 :;
            ;
            result = ((hsum << (i64)5) - hsum);
            return (result & (i64)9223372036854775807);
        }
        break;
    case 1:;
    case 2:;
    case 3:;
    case 6:;
        {
            return (*p).value;
        }
        break;
    case 4:;
        {
            q = (*p).objptr;
            if (((*q).length == (i64)0)) {
                return (i64)0;
            }
            else {
                return (i64)(*(*q).num)[((i64)0)];
            }
;
        }
        break;
    default: {
        qq_lib$pcustype((byte*)"Can't hash:",p);
    }
    } //SW
;
    return (i64)0;
}

void qq_vars$var_objtovar(i64 tag,struct qq_decls$objrec *p,struct qq_decls$varrec *q) {
    (*q).tagx = (tag | (i64)256);
    (*q).objptr = p;
}

void qq_vars$var_putdotix_intint(struct qq_decls$varrec *a,i64 index,struct qq_decls$varrec *b) {
        u64 x;
        u64 y;
    x = (u64)(*a).value;
    y = (u64)(*b).value;
    if (!((index >= (i64)0 && index <= (i64)63))) {
        qq_lib$pcerror((byte*)"int.[int]:= bounds");
    }
;
    (*a).value = (((i64)x & ~(((i64)1 << index))) | (i64)(y << index));
}

void qq_vars$var_power(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
    if (((i64)(*a).tag != (i64)(*b).tag)) {
        qq_vars$var_powermixed(a,b);
        return;
    }
;
    switch ((i64)(*a).tag) {
    case 1:;
        {
            (*a).value = msysc$m_power_i64((*b).value,(*a).value);
        }
        break;
    case 3:;
        {
            (*a).xvalue = pow((*a).xvalue,(*b).xvalue);
        }
        break;
    case 4:;
        {
            qq_decimal$var_power_dec(a,qq_decimal$var_convert_dec_int(b));
        }
        break;
    default: {
        qq_lib$pcustype_t((byte*)"power",(i64)(*a).tag);
    }
    } //SW
;
}

void qq_vars$var_powermixed(struct qq_decls$varrec *a,struct qq_decls$varrec *b) {
        i64 newtag;
    newtag = (i64)(*a).tag;
        {i64 $temp = (((i64)(*a).tag << (i64)16) | (i64)(*b).tag);
if (($temp==(i64)65539)) {
        newtag = (i64)3;
        (*a).xvalue = pow((r64)(*a).value,(*b).xvalue);
    }
    else if (($temp==(i64)196609)) {
        (*a).xvalue = pow((*a).xvalue,(r64)(*b).value);
    }
    else if (($temp==(i64)262145)) {
        qq_decimal$var_power_dec(a,(*b).value);
    }
    else {
        qq_lib$pcmxtypes((byte*)"Powermixed",a,b);
    }
    };
    (*a).tag = newtag;
}

// START
void qq_vars$start(void) {

}

void msysc$m_init(i64 nargs,u8 *(*args)[],u8 *(*envstrings)[]) {
        i64 j;
        i64 i;
    msysc$nsysparams = nargs;
    if ((msysc$nsysparams > (i64)128)) {
        printf((byte*)"Too many params\n");
        exit((i64)1);
    }
;
    for (i=(i64)1;i<=nargs;++i) {
L1157 :;
        msysc$sysparams[(i)-1] = (*args)[(i)-1];
L1158 :;
    }
L1159 :;
    ;
    msysc$ncmdparams = (msysc$nsysparams - (msysc$$cmdskip + (i64)1));
    msysc$cmdparams = (u8 *(*)[])&msysc$sysparams[((msysc$$cmdskip + (i64)1))-1];
    j = (i64)1;
    msysc$nenvstrings = (i64)0;
    L1160 :;
    while (!!((*envstrings)[(j)-1])) {
        ++(msysc$nenvstrings);
        ++(j);
L1161 :;
    }
L1162 :;
    ;
}

i64 msysc$m_getdotindex(u64 a,i64 i) {
    return (((i64)a & ((i64)1 << i)) >> i);
}

u64 msysc$m_setdotindex(u64 a,i64 i,i64 x) {
    return (u64)(((i64)a & ~(((i64)1 << i))) | (i64)((u64)x << i));
}

i64 msysc$m_getdotslice(u64 a,i64 i,i64 j) {
    if ((i >= j)) {
        return (i64)((a >> j) & ~(((u64)18446744073709551615u << ((i - j) + (i64)1))));
    }
    else {
        return (i64)((a >> i) & ~(((u64)18446744073709551615u << ((j - i) + (i64)1))));
    }
;
}

u64 msysc$m_setdotslice(u64 a,i64 i,i64 j,u64 x) {
        u64 mask64;
    if ((i > j)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"SETDOTSLICE?",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)52);
    }
;
    mask64 = (~(((u64)18446744073709551615u << ((j - i) + (i64)1))) << i);
    return ((a & ~(mask64)) | (x << i));
}

i64 msysc$m_get_nprocs(void) {
    return msysc$_fnnprocs;
}

i64 msysc$m_get_nexports(void) {
    return msysc$_fnnexports;
}

u8 *msysc$m_get_procname(i64 n) {
    return msysc$_fnnames[(n)-1];
}

void *msysc$m_get_procaddr(i64 n) {
    return msysc$_fnaddresses[(n)-1];
}

void *msysc$m_get_procexport(i64 n) {
    return 0;
}

static void msysc$pushio(void) {
    if ((msysc$niostack >= (i64)10)) {
        printf((byte*)"Too many io levels\n");
        exit((i64)53);
    }
;
    ++(msysc$niostack);
    msysc$outchan_stack[(msysc$niostack)-1] = msysc$outchan;
    msysc$outdev_stack[(msysc$niostack)-1] = msysc$outdev;
    msysc$fmtstr_stack[(msysc$niostack)-1] = msysc$fmtstr;
    msysc$needgap_stack[(msysc$niostack)-1] = msysc$needgap;
    msysc$needgap = (i64)0;
    msysc$fmtstr = 0;
    msysc$outchan = 0;
}

void msysc$m_print_startfile(void *dev) {
    msysc$pushio();
    msysc$outchan = dev;
    if (!!(dev)) {
        msysc$outdev = (i64)2;
    }
    else {
        msysc$outdev = (i64)1;
    }
;
}

void msysc$m_print_startstr(u8 *s) {
        u8 **  p;
    msysc$pushio();
    msysc$ptr_stack[(msysc$niostack)-1] = s;
    p = &msysc$ptr_stack[(msysc$niostack)-1];
    msysc$outchan = p;
    msysc$outdev = (i64)3;
}

void msysc$m_print_startptr(u8 **p) {
    msysc$pushio();
    msysc$outchan = p;
    msysc$outdev = (i64)3;
}

void msysc$m_print_startcon(void) {
    msysc$pushio();
    msysc$outdev = (i64)1;
}

void msysc$m_print_setfmt(u8 *format) {
    msysc$fmtstr = format;
}

void msysc$m_print_end(void) {
    msysc$needgap = (i64)0;
    msysc$nextfmtchars((i64)1);
    if ((msysc$niostack == (i64)0)) {
        return;
    }
;
    msysc$outchan = msysc$outchan_stack[(msysc$niostack)-1];
    msysc$outdev = msysc$outdev_stack[(msysc$niostack)-1];
    msysc$fmtstr = msysc$fmtstr_stack[(msysc$niostack)-1];
    msysc$needgap = (i64)msysc$needgap_stack[(msysc$niostack)-1];
    --(msysc$niostack);
}

void msysc$m_print_ptr(void *a,u8 *fmtstyle) {
    msysc$nextfmtchars((i64)0);
    msysc$printstr(msysc$strword((u64)a,(byte*)"z8h"));
    msysc$needgap = (i64)1;
}

void msysc$m_print_i64(i64 a,u8 *fmtstyle) {
        u8 s[40];
        struct msysc$fmtrec fmt;
        i64 n;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        if ((a >= (i64)0)) {
            n = msysc$u64tostr((u64)a,(u8 *)s,(u64)10u,(i64)0);
        }
        else {
            s[((i64)1)-1] = '-';
            n = (msysc$u64tostr((u64)-(a),(u8 *)&s[((i64)2)-1],(u64)10u,(i64)0) + (i64)1);
        }
;
        msysc$printstr_n((u8 *)s,n);
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        if (((u64)fmt.param == 'V')) {
            msysc$fmtparam = a;
            msysc$needgap = (i64)0;
        }
        else {
            msysc$tostr_i64(a,(struct msysc$fmtrec *)&fmt);
        }
;
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_u64(u64 a,u8 *fmtstyle) {
        struct msysc$fmtrec fmt;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        msysc$printstr(msysc$strword(a,0));
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        msysc$tostr_u64(a,(struct msysc$fmtrec *)&fmt);
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_r64(r64 x,u8 *fmtstyle) {
        u8 s[360];
        struct msysc$fmtrec fmt;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        sprintf((u8 *)s,(byte*)"%f",x);
        msysc$printstr((u8 *)s);
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        msysc$tostr_r64(x,(struct msysc$fmtrec *)&fmt);
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_r32(r32 x,u8 *fmtstyle) {
    msysc$m_print_r64((r64)x,fmtstyle);
}

void msysc$m_print_c8(i64 a,u8 *fmtstyle) {
        u8 s[40];
    msysc$nextfmtchars((i64)0);
    s[((i64)1)-1] = (u64)a;
    s[((i64)2)-1] = (u64)0u;
    msysc$printstr((u8 *)s);
    msysc$needgap = (i64)1;
}

void msysc$m_print_str(u8 *s,u8 *fmtstyle) {
        struct msysc$fmtrec fmt;
    msysc$nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        msysc$printstr(s);
    }
    else {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        msysc$tostr_str(s,(struct msysc$fmtrec *)&fmt);
    }
;
    msysc$needgap = (i64)1;
}

void msysc$m_print_newline(void) {
    msysc$needgap = (i64)0;
    msysc$nextfmtchars((i64)1);
    msysc$printstr((byte*)"\r\n");
}

void msysc$m_print_nogap(void) {
    msysc$needgap = (i64)0;
}

void msysc$m_print_space(void) {
    msysc$needgap = (i64)0;
    msysc$printstr((byte*)" ");
}

void msysc$printstr(u8 *s) {
        u8 **  p;
    if ((msysc$outdev==(i64)1)) {
        printf((byte*)"%s",s);
    }
    else if ((msysc$outdev==(i64)2)) {
        fprintf(msysc$outchan,(byte*)"%s",s);
    }
    else if ((msysc$outdev==(i64)3)) {
        p = (u8 **)msysc$outchan;
        strcpy((*p),s);
        (*p) += strlen(s);
    }
;
}

void msysc$printstr_n(u8 *s,i64 n) {
        u8 str[256];
        u8 **  p;
    if ((n==(i64)-1)) {
        n = strlen(s);
    }
    else if ((n==(i64)0)) {
        return;
    }
;
    if ((msysc$outdev==(i64)3)) {
        p = (u8 **)msysc$outchan;
        memcpy((void *)(*p),(void *)s,(u64)n);
        (*p) += n;
        (*(*p)) = (u64)0u;
    }
    else if ((msysc$outdev==(i64)2)) {
        s = msysc$makezstring(s,n,(u8 *)str);
        fprintf(msysc$outchan,(byte*)"%s",s);
        msysc$freezstring(s,n);
    }
    else if ((msysc$outdev==(i64)1)) {
        s = msysc$makezstring(s,n,(u8 *)str);
        printf((byte*)"%s",s);
        msysc$freezstring(s,n);
    }
;
}

void msysc$printstrn_app(u8 *s,i64 length,void *f) {
    if (!!(length)) {
        if ((f == 0)) {
            printf((u8*)"%.*s",(i32)length,s);;
        }
        else {
            fprintf(f,(u8*)"%.*s",(i32)length,s);;
        }
;
    }
;
}

static u8 *msysc$makezstring(u8 *s,i64 n,u8 *local) {
        u8 *  t;
    if ((n < (i64)256)) {
        memcpy((void *)local,(void *)s,(u64)n);
        (*(local + n)) = (u64)0u;
        return local;
    }
    else {
        t = (u8 *)mlib$pcm_alloc((n + (i64)1));
        memcpy((void *)t,(void *)s,(u64)n);
        (*(t + n)) = (u64)0u;
        return t;
    }
;
}

static void msysc$freezstring(u8 *t,i64 n) {
    if ((n >= (i64)256)) {
        mlib$pcm_free((void *)t,(n + (i64)1));
    }
;
}

static void msysc$printchar(i64 ch) {
        u8 **  p;
    if ((msysc$outdev==(i64)1)) {
        printf((u8*)"%c",(int)ch);
    }
    else if ((msysc$outdev==(i64)2)) {
        fprintf(msysc$outchan,(u8*)"%c",(int)ch);
    }
    else if ((msysc$outdev==(i64)3)) {
        p = (u8 **)msysc$outchan;
        (*(*p)) = (u64)ch;
        (*p) += (i64)1;
        (*(*p)) = (u64)0u;
    }
;
}

void msysc$nextfmtchars(i64 lastx) {
        u8 c;
        u8 *  pstart;
        i64 n;
    if (!(!!(msysc$fmtstr))) {
        if (!!(msysc$needgap)) {
            msysc$printchar((i64)32);
        }
;
        msysc$needgap = (i64)0;
        return;
    }
;
    pstart = msysc$fmtstr;
    n = (i64)0;
    L1163 :;
    while (1) {
        c = (u64)(*msysc$fmtstr);
        switch ((i64)(u64)c) {
        case 35:;
            {
                if (!!(lastx)) {
                    goto L1165 ;
;
                }
;
                ++(msysc$fmtstr);
                if (!!(n)) {
                    msysc$printstr_n(pstart,n);
                }
;
                return;
            }
            break;
        case 0:;
            {
                if (!!(n)) {
                    msysc$printstr_n(pstart,n);
                }
                else if (!(!!(lastx))) {
                    msysc$printstr_n((byte*)"|",(i64)1);
                }
;
                return;
            }
            break;
        case 126:;
            {
                if (!!(n)) {
                    msysc$printstr_n(pstart,n);
                    n = (i64)0;
                }
;
                ++(msysc$fmtstr);
                c = (u64)(*msysc$fmtstr);
                if (!!((u64)c)) {
                    ++(msysc$fmtstr);
                    msysc$printchar((i64)(u64)c);
                }
;
                pstart = msysc$fmtstr;
            }
            break;
        default: {
            //skip:
L1165 :;
;
            ++(n);
            ++(msysc$fmtstr);
        }
        } //SW
;
    }
L1164 :;
    ;
}

void msysc$strtofmt(u8 *s,i64 slen,struct msysc$fmtrec *fmt) {
        u8 c;
        byte wset;
        i64 n;
        u8 str[100];
    (*fmt) = msysc$defaultfmt;
    if ((s == 0)) {
        return;
    }
;
    if ((slen == (i64)-1)) {
        slen = strlen(s);
    }
;
    memcpy(str,(void *)s,(u64)slen);
    str[(slen)] = (u64)0u;
    s = (u8 *)str;
    wset = (i64)0;
    L1166 :;
    while (!!((u64)(*s))) {
        c = (u64)(*s);
        ++(s);
        switch ((i64)(u64)c) {
        case 66:;
        case 98:;
            {
                (*fmt).base = (i64)2;
            }
            break;
        case 72:;
        case 104:;
            {
                (*fmt).base = (i64)16;
            }
            break;
        case 79:;
        case 111:;
            {
                (*fmt).base = (i64)8;
            }
            break;
        case 88:;
        case 120:;
            {
                c = (u64)(*s);
                if (!!((u64)c)) {
                    switch ((i64)(u64)c) {
                    case 48:;
                    case 49:;
                    case 50:;
                    case 51:;
                    case 52:;
                    case 53:;
                    case 54:;
                    case 55:;
                    case 56:;
                    case 57:;
                        {
                            c = ((u64)c - '0');
                        }
                        break;
                    case 65:;
                    case 66:;
                    case 67:;
                    case 68:;
                    case 69:;
                    case 70:;
                        {
                            c = (u64)((i64)((u64)c - 'A') + (i64)10);
                        }
                        break;
                    case 97:;
                    case 98:;
                    case 99:;
                    case 100:;
                    case 101:;
                    case 102:;
                        {
                            c = (u64)((i64)((u64)c - 'a') + (i64)10);
                        }
                        break;
                    default: {
                        c = (u64)10u;
                    }
                    } //SW
;
                    (*fmt).base = (i64)(u64)c;
                    ++(s);
                }
;
            }
            break;
        case 81:;
        case 113:;
            {
                (*fmt).quotechar = '"';
            }
            break;
        case 126:;
            {
                (*fmt).quotechar = '~';
            }
            break;
        case 74:;
        case 106:;
            {
                (*fmt).justify = (u64)toupper((i32)(u64)(*s));
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 65:;
            {
                (*fmt).lettercase = 'A';
            }
            break;
        case 97:;
            {
                (*fmt).lettercase = 'a';
            }
            break;
        case 90:;
        case 122:;
            {
                (*fmt).padchar = '0';
            }
            break;
        case 83:;
        case 115:;
            {
                (*fmt).sepchar = (u64)(*s);
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 80:;
        case 112:;
            {
                (*fmt).padchar = (u64)(*s);
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 84:;
        case 116:;
            {
                (*fmt).suffix = (u64)(*s);
                if (!!((u64)(*s))) {
                    ++(s);
                }
;
            }
            break;
        case 87:;
        case 119:;
            {
                (*fmt).usigned = 'W';
            }
            break;
        case 69:;
        case 101:;
            {
                (*fmt).realfmt = 'e';
            }
            break;
        case 70:;
        case 102:;
            {
                (*fmt).realfmt = 'f';
            }
            break;
        case 71:;
        case 103:;
            {
                (*fmt).realfmt = 'g';
            }
            break;
        case 46:;
            {
                wset = (i64)1;
            }
            break;
        case 44:;
        case 95:;
            {
                (*fmt).sepchar = (u64)c;
            }
            break;
        case 43:;
            {
                (*fmt).plus = '+';
            }
            break;
        case 68:;
        case 100:;
            {
                (*fmt).charmode = 'D';
            }
            break;
        case 67:;
        case 99:;
            {
                (*fmt).charmode = 'C';
            }
            break;
        case 77:;
        case 109:;
            {
                (*fmt).heapmode = 'M';
            }
            break;
        case 86:;
        case 118:;
            {
                (*fmt).param = 'V';
            }
            break;
        case 42:;
            {
                n = msysc$fmtparam;
                goto L1169 ;
;
            }
            break;
        default: {
            if ((((u64)c >= '0') && ((u64)c <= '9'))) {
                n = (i64)((u64)c - '0');
                L1170 :;
                while (1) {
                    c = (u64)(*s);
                    if (((i64)(u64)(*s) == (i64)0)) {
                        goto L1171 ;
                    }
;
                    if ((((u64)c >= '0') && ((u64)c <= '9'))) {
                        ++(s);
                        n = (((n * (i64)10) + (i64)(u64)c) - (i64)48);
                    }
                    else {
                        goto L1171 ;
                    }
;
                }
L1171 :;
                ;
                //gotwidth:
L1169 :;
;
                if (!(!!((i64)wset))) {
                    (*fmt).minwidth = n;
                    wset = (i64)1;
                }
                else {
                    (*fmt).precision = n;
                }
;
            }
;
        }
        } //SW
;
L1167 :;
    }
L1168 :;
    ;
}

static i64 msysc$domultichar(u8 *p,i64 n,u8 *dest,struct msysc$fmtrec *fmt) {
        u8 str[20];
        u8 *  q;
        i64 nchars;
        i64 $av_1;
    q = (u8 *)str;
    nchars = n;
    $av_1 = n;
    while ($av_1-- > 0) {
L1172 :;
        if (((i64)(u64)(*p) == (i64)0)) {
            goto L1174 ;
        }
;
        (*q) = (u64)(*p);
        ++(q);
        ++(p);
L1173 :;
    }
L1174 :;
    ;
    (*q) = (u64)0u;
    return msysc$expandstr((u8 *)str,dest,strlen((u8 *)str),(struct msysc$fmtrec *)fmt);
}

static i64 msysc$expandstr(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt) {
        i64 i;
        i64 w;
        i64 m;
        i64 $av_1;
        i64 $av_2;
        i64 $av_3;
        i64 $av_4;
        i64 $av_5;
    w = (i64)(*fmt).minwidth;
    if (((w == (i64)0) || (w <= n))) {
        strncpy(t,s,(u64)n);
        (*(t + n)) = (u64)0u;
        return n;
    }
;
    if (((u64)(*fmt).justify == 'L')) {
        strncpy(t,s,(u64)n);
        t += n;
                ($av_1 = (w - n));
        for (i=(i64)1;i<=$av_1;++i) {
L1175 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L1176 :;
        }
L1177 :;
        ;
        (*t) = (u64)0u;
    }
    else if (((u64)(*fmt).justify == 'R')) {
        if (((((u64)(*fmt).padchar == '0') && !!((i64)(*fmt).base)) && (((u64)(*s) == '-') || ((u64)(*s) == '+')))) {
            (*t) = (u64)(*s);
            ++(t);
            $av_2 = (w - n);
            while ($av_2-- > 0) {
L1178 :;
                (*t) = (u64)(*fmt).padchar;
                ++(t);
L1179 :;
            }
L1180 :;
            ;
            strncpy(t,(s + (i64)1),(u64)(n - (i64)1));
            (*((t + n) - (i64)1)) = (u64)0u;
        }
        else {
            $av_3 = (w - n);
            while ($av_3-- > 0) {
L1181 :;
                (*t) = (u64)(*fmt).padchar;
                ++(t);
L1182 :;
            }
L1183 :;
            ;
            strncpy(t,s,(u64)n);
            (*(t + n)) = (u64)0u;
        }
;
    }
    else {
        m = (((w - n) + (i64)1) / (i64)2);
        $av_4 = m;
        while ($av_4-- > 0) {
L1184 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L1185 :;
        }
L1186 :;
        ;
        strncpy(t,s,(u64)n);
        t += n;
        $av_5 = ((w - n) - m);
        while ($av_5-- > 0) {
L1187 :;
            (*t) = (u64)(*fmt).padchar;
            ++(t);
L1188 :;
        }
L1189 :;
        ;
        (*t) = (u64)0u;
    }
;
    return w;
}

static i64 msysc$u64tostr(u64 aa,u8 *s,u64 base,i64 sep) {
        u8 t[1024];
        i64 i;
        i64 j;
        i64 k;
        i64 g;
        u8 *  s0;
    i = (i64)0;
    k = (i64)0;
    g = (((i64)base == (i64)10) ? (i64)3 : (i64)4);
    L1190 :;
    do {
        t[(++(i))] = (u64)msysc$digits[((i64)(aa % base))];
        aa = (aa / base);
        ++(k);
        if (((!!(sep) && ((i64)aa != (i64)0)) && (k == g))) {
            t[(++(i))] = (u64)sep;
            k = (i64)0;
        }
;
L1191 :;
    }
    while (!((i64)aa == (i64)0));
L1192 :;
    ;
    j = i;
    s0 = s;
    L1193 :;
    while (!!(i)) {
        (*s) = (u64)t[((i)--)];
        ++(s);
L1194 :;
    }
L1195 :;
    ;
    (*s) = (u64)0u;
    return j;
}

static i64 msysc$i64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt) {
        u8 str[1024];
        i64 n;
        i64 usigned;
        static u64 mindint = (u64)9223372036854775808u;
    usigned = (i64)0;
    if (!!((u64)(*fmt).usigned)) {
        usigned = (i64)1;
    }
;
    if (((aa == (i64)mindint) && !(!!(usigned)))) {
        str[((i64)0)] = '-';
        n = (msysc$i64mintostr((u8 *)&str[((i64)1)],(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar) + (i64)1);
    }
    else {
        if (((!(!!(usigned)) && (aa < (i64)0)) || !!((u64)(*fmt).plus))) {
            if ((aa < (i64)0)) {
                aa = -(aa);
                str[((i64)0)] = '-';
            }
            else {
                str[((i64)0)] = '+';
            }
;
            n = (msysc$u64tostr((u64)aa,(u8 *)&str[((i64)1)],(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar) + (i64)1);
        }
        else {
            n = msysc$u64tostr((u64)aa,(u8 *)str,(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar);
        }
;
    }
;
    if (!!((u64)(*fmt).suffix)) {
        str[(n)] = (u64)(*fmt).suffix;
        str[(++(n))] = (u64)0u;
    }
;
    if (((((i64)(*fmt).base > (i64)10) || !!((u64)(*fmt).suffix)) && ((u64)(*fmt).lettercase == 'a'))) {
        msysc$convlcstring((u8 *)str);
    }
;
    return msysc$expandstr((u8 *)str,s,n,(struct msysc$fmtrec *)fmt);
}

static i64 msysc$u64tostrfmt(i64 aa,u8 *s,struct msysc$fmtrec *fmt) {
        u8 str[1024];
        i64 n;
    n = msysc$u64tostr((u64)aa,(u8 *)str,(u64)(i64)(*fmt).base,(i64)(u64)(*fmt).sepchar);
    if (!!((u64)(*fmt).suffix)) {
        str[(n)] = (u64)(*fmt).suffix;
        str[(++(n))] = (u64)0u;
    }
;
    if ((((i64)(*fmt).base > (i64)10) || (!!((u64)(*fmt).suffix) && ((u64)(*fmt).lettercase == 'a')))) {
        msysc$convlcstring((u8 *)str);
    }
;
    return msysc$expandstr((u8 *)str,s,n,(struct msysc$fmtrec *)fmt);
}

static i64 msysc$i64mintostr(u8 *s,i64 base,i64 sep) {
        u8 t[1024];
        i64 i;
        i64 j;
        i64 k;
        i64 g;
    switch (base) {
    case 10:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"9223372036854775808");
            j = (i64)3;
        }
        break;
    case 16:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"8000000000000000");
            j = (i64)1;
        }
        break;
    case 2:;
        {
            strcpy((u8 *)&t[((i64)0)],(byte*)"1000000000000000000000000000000000000000000000000000000000000000");
            j = (i64)7;
        }
        break;
    default: {
        strcpy((u8 *)&t[((i64)0)],(byte*)"<mindint>");
    }
    } //SW
;
    i = strlen((u8 *)&t[((i64)0)]);
    s += i;
    if (!!(sep)) {
        s += j;
    }
;
    (*s) = (u64)0u;
    k = (i64)0;
    g = ((base == (i64)10) ? (i64)3 : (i64)4);
    L1196 :;
    while (!!(i)) {
        --(s);
        (*s) = (u64)t[(((i)-- - (i64)1))];
        if (((!!(sep) && !!(i)) && (++(k) == g))) {
            --(s);
            (*s) = (u64)sep;
            k = (i64)0;
        }
;
L1197 :;
    }
L1198 :;
    ;
    return strlen(s);
}

static i64 msysc$strtostrfmt(u8 *s,u8 *t,i64 n,struct msysc$fmtrec *fmt) {
        u8 *  u;
        u8 *  v;
        u8 str[256];
        i64 w;
        i64 nheap;
    nheap = (i64)0;
    if ((!!((u64)(*fmt).quotechar) || !!((u64)(*fmt).lettercase))) {
        if ((n < (i64)256)) {
            u = (u8 *)str;
        }
        else {
            nheap = (n + (i64)3);
            u = (u8 *)mlib$pcm_alloc(nheap);
        }
;
        if (!!((u64)(*fmt).quotechar)) {
            v = u;
            (*v) = (u64)(*fmt).quotechar;
            ++(v);
            if (!!(n)) {
                strcpy(v,s);
                v += n;
            }
;
            (*v) = (u64)(*fmt).quotechar;
            ++(v);
            (*v) = (u64)0u;
            n += (i64)2;
        }
        else {
            memcpy((void *)u,(void *)s,(u64)n);
        }
;
        switch ((i64)(u64)(*fmt).lettercase) {
        case 97:;
            {
                msysc$convlcstring(u);
            }
            break;
        case 65:;
            {
                msysc$convucstring(u);
            }
            break;
        } //SW
;
        s = u;
    }
;
    w = (i64)(*fmt).minwidth;
    if ((w > n)) {
        n = msysc$expandstr(s,t,n,(struct msysc$fmtrec *)fmt);
    }
    else {
        memcpy((void *)t,(void *)s,(u64)n);
    }
;
    if (!!(nheap)) {
        mlib$pcm_free((void *)u,nheap);
    }
;
    return n;
}

static void msysc$tostr_i64(i64 a,struct msysc$fmtrec *fmt) {
        u8 str[360];
        i64 n;
        {u64 $temp = (u64)(*fmt).charmode;
if (($temp==(u64)0u)) {
        n = msysc$i64tostrfmt(a,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    else if (($temp=='D') || ($temp=='d')) {
        n = msysc$domultichar((u8 *)&a,(i64)8,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    else {
        msysc$printchar(a);
        return;
    }
    };
    msysc$printstr_n((u8 *)str,n);
}

static void msysc$tostr_u64(u64 a,struct msysc$fmtrec *fmt) {
        u8 str[360];
        i64 n;
        {u64 $temp = (u64)(*fmt).charmode;
if (($temp=='D') || ($temp=='d')) {
        n = msysc$domultichar((u8 *)&a,(i64)8,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    else if (($temp=='C') || ($temp=='c')) {
        msysc$printchar((i64)a);
        return;
    }
    else {
        n = msysc$u64tostrfmt((i64)a,(u8 *)str,(struct msysc$fmtrec *)fmt);
    }
    };
    msysc$printstr_n((u8 *)str,n);
}

static void msysc$tostr_r64(r64 x,struct msysc$fmtrec *fmt) {
        u8 str[360];
        u8 str2[360];
        u8 cfmt[10];
        i64 n;
    cfmt[((i64)0)] = '%';
    if (!!((i64)(*fmt).precision)) {
        cfmt[((i64)1)] = '.';
        cfmt[((i64)2)] = '*';
        cfmt[((i64)3)] = (u64)(*fmt).realfmt;
        cfmt[((i64)4)] = (u64)0u;
        sprintf((u8 *)str,(u8 *)cfmt,(i64)(*fmt).precision,x);
    }
    else {
        cfmt[((i64)1)] = (u64)(*fmt).realfmt;
        cfmt[((i64)2)] = (u64)0u;
        sprintf((u8 *)str,(u8 *)cfmt,x);
    }
;
    n = strlen((u8 *)str);
    if ((n < (i64)(*fmt).minwidth)) {
        n = msysc$expandstr((u8 *)str,(u8 *)str2,n,(struct msysc$fmtrec *)fmt);
        strcpy((u8 *)str,(u8 *)str2);
    }
;
    msysc$printstr_n((u8 *)str,n);
}

static void msysc$tostr_str(u8 *s,struct msysc$fmtrec *fmt) {
        i64 oldlen;
        i64 newlen;
        i64 n;
        u8 *  t;
    oldlen = strlen(s);
    newlen = oldlen;
    if (((!!((u64)(*fmt).quotechar) || ((i64)(*fmt).minwidth > newlen)) || !!((u64)(*fmt).lettercase))) {
        if (!!((u64)(*fmt).quotechar)) {
            newlen += (i64)2;
        }
;
        if (((i64)(*fmt).minwidth > newlen)) {
            newlen = (i64)(*fmt).minwidth;
        }
;
        t = (u8 *)mlib$pcm_alloc((newlen + (i64)1));
        n = msysc$strtostrfmt(s,t,oldlen,(struct msysc$fmtrec *)fmt);
        msysc$printstr_n(t,n);
        mlib$pcm_free((void *)t,(newlen + (i64)1));
    }
    else {
        msysc$printstr_n(s,oldlen);
    }
;
}

static struct msysc$fmtrec *msysc$getfmt(u8 *fmtstyle) {
        static struct msysc$fmtrec fmt;
    if (!!(fmtstyle)) {
        msysc$strtofmt(fmtstyle,(i64)-1,&fmt);
        return (struct msysc$fmtrec *)&fmt;
    }
    else {
        return (struct msysc$fmtrec *)&msysc$defaultfmt;
    }
;
}

u8 *msysc$strint(i64 a,u8 *fmtstyle) {
        static u8 str[100];
        struct msysc$fmtrec *  fmt;
    msysc$m_print_startstr((u8 *)str);
    msysc$tostr_i64(a,(struct msysc$fmtrec *)(fmt = (struct msysc$fmtrec *)msysc$getfmt(fmtstyle)));
    msysc$m_print_end();
    return msysc$getstr((u8 *)str,(struct msysc$fmtrec *)fmt);
}

void msysc$getstrint(i64 a,u8 *dest) {
    msysc$m_print_startstr(dest);
    msysc$tostr_i64(a,(struct msysc$fmtrec *)msysc$getfmt(0));
    msysc$m_print_end();
}

u8 *msysc$strword(u64 a,u8 *fmtstyle) {
        static u8 str[100];
        struct msysc$fmtrec *  fmt;
    msysc$m_print_startstr((u8 *)str);
    msysc$tostr_u64(a,(struct msysc$fmtrec *)(fmt = (struct msysc$fmtrec *)msysc$getfmt(fmtstyle)));
    msysc$m_print_end();
    return msysc$getstr((u8 *)str,(struct msysc$fmtrec *)fmt);
}

u8 *msysc$strreal(r64 a,u8 *fmtstyle) {
        static u8 str[320];
        struct msysc$fmtrec *  fmt;
    msysc$m_print_startstr((u8 *)str);
    msysc$tostr_r64(a,(struct msysc$fmtrec *)(fmt = (struct msysc$fmtrec *)msysc$getfmt(fmtstyle)));
    msysc$m_print_end();
    return msysc$getstr((u8 *)str,(struct msysc$fmtrec *)fmt);
}

static u8 *msysc$getstr(u8 *s,struct msysc$fmtrec *fmt) {
    if (!!((u64)(*fmt).heapmode)) {
        return mlib$pcm_copyheapstring(s);
    }
    else {
        return s;
    }
;
}

static void msysc$initreadbuffer(void) {
    if (!!(msysc$rd_buffer)) {
        return;
    }
;
    msysc$rd_buffer = (u8 *)mlib$pcm_alloc((i64)16384);
    (*msysc$rd_buffer) = (u64)0u;
    msysc$rd_pos = (msysc$rd_lastpos = msysc$rd_buffer);
}

void msysc$m_read_conline(void) {
    msysc$initreadbuffer();
    mlib$readlinen(0,msysc$rd_buffer,(i64)16384);
    msysc$rd_length = strlen(msysc$rd_buffer);
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = 0;
}

void msysc$m_read_fileline(void *f) {
    msysc$initreadbuffer();
    mlib$readlinen(f,msysc$rd_buffer,(i64)16384);
    msysc$rd_length = strlen(msysc$rd_buffer);
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = 0;
}

void msysc$m_read_strline(u8 *s) {
        i64 n;
    msysc$initreadbuffer();
    n = strlen(s);
    if ((n < (i64)16384)) {
        strcpy(msysc$rd_buffer,s);
    }
    else {
        memcpy((void *)msysc$rd_buffer,(void *)s,(u64)16383u);
        (*((msysc$rd_buffer + (i64)16384) - (i64)1)) = (u64)0u;
    }
;
    msysc$rd_length = n;
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = 0;
}

static u8 *msysc$readitem(i64 *itemlength) {
        u8 *  p;
        u8 *  s;
        u8 *  itemstr;
        u8 quotechar;
        u8 c;
    if (!(!!(msysc$rd_buffer))) {
        msysc$initreadbuffer();
    }
;
    s = msysc$rd_pos;
    L1199 :;
    while ((((u64)(*s) == ' ') || ((i64)(u64)(*s) == (i64)9))) {
        ++(s);
L1200 :;
    }
L1201 :;
    ;
    itemstr = s;
    msysc$rd_lastpos = (msysc$rd_pos = s);
    if (((i64)(u64)(*s) == (i64)0)) {
        msysc$termchar = (i64)0;
        (*itemlength) = (i64)0;
        return s;
    }
;
    quotechar = (u64)0u;
    if (((u64)(*s) == '"')) {
        quotechar = '"';
        ++(s);
    }
    else if (((u64)(*s) == (u64)39u)) {
        quotechar = (u64)39u;
        ++(s);
    }
;
    p = (itemstr = s);
    L1202 :;
    while (!!((u64)(*s))) {
        c = (u64)(*(s)++);
        switch ((i64)(u64)c) {
        case 32:;
        case 9:;
        case 44:;
        case 61:;
            {
                if ((!!((u64)quotechar) || (p == s))) {
                    goto L1205 ;
;
                }
;
                msysc$termchar = (i64)(u64)c;
                goto L1204 ;
            }
            break;
        default: {
            //normalchar:
L1205 :;
;
            if (((u64)c == (u64)quotechar)) {
                if (((u64)(*s) == (u64)quotechar)) {
                    (*p) = (u64)c;
                    ++(s);
                    ++(p);
                }
                else {
                    msysc$termchar = (i64)(u64)(*s);
                    if (((msysc$termchar == (i64)44) || (msysc$termchar == (i64)61))) {
                        ++(s);
                        msysc$termchar = (i64)(u64)(*s);
                    }
;
                    goto L1204 ;
                }
;
            }
            else {
                (*p) = (u64)c;
                ++(p);
            }
;
        }
        } //SW
;
L1203 :;
    }
L1204 :;
    ;
    if (((i64)(u64)(*s) == (i64)0)) {
        msysc$termchar = (i64)0;
    }
;
    (*itemlength) = (p - itemstr);
    msysc$rd_pos = s;
    return itemstr;
}

i64 msysc$strtoint(u8 *s,i64 length,i64 base) {
        byte signd;
        u64 aa;
        u8 c;
        u8 d;
    msysc$itemerror = (i64)0;
    if ((length == (i64)-1)) {
        length = strlen(s);
    }
;
    signd = (i64)0;
    if ((!!(length) && ((u64)(*s) == '-'))) {
        signd = (i64)1;
        ++(s);
        --(length);
    }
    else if ((!!(length) && ((u64)(*s) == '+'))) {
        ++(s);
        --(length);
    }
;
    aa = (u64)0u;
    L1206 :;
    while (!!(length)) {
        c = (u64)(*(s)++);
        --(length);
        switch ((i64)(u64)c) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
            {
                d = (u64)((i64)((u64)c - 'A') + (i64)10);
            }
            break;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
            {
                d = (u64)((i64)((u64)c - 'a') + (i64)10);
            }
            break;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            {
                d = ((u64)c - '0');
            }
            break;
        case 95:;
        case 39:;
            {
                goto L1207 ;
            }
            break;
        default: {
            msysc$itemerror = (i64)1;
            goto L1208 ;
        }
        } //SW
;
        if (((i64)(u64)d >= base)) {
            msysc$itemerror = (i64)1;
            goto L1208 ;
        }
;
        aa = (u64)(((i64)aa * base) + (i64)(u64)d);
L1207 :;
    }
L1208 :;
    ;
    if (!!((i64)signd)) {
        return (i64)-(aa);
    }
    else {
        return (i64)aa;
    }
;
}

i64 msysc$m_read_i64(i64 fmt) {
        u8 *  s;
        i64 length;
    if ((fmt==(i64)67) || (fmt==(i64)99)) {
        msysc$rd_lastpos = msysc$rd_pos;
        if (!!((u64)(*msysc$rd_pos))) {
            return (i64)(u64)(*(msysc$rd_pos)++);
        }
        else {
            return (i64)0;
        }
;
    }
    else if ((fmt==(i64)84) || (fmt==(i64)116)) {
        return msysc$termchar;
    }
    else if ((fmt==(i64)69) || (fmt==(i64)101)) {
        return msysc$itemerror;
    }
;
    s = msysc$readitem(&length);
    if ((fmt==(i64)0) || (fmt==(i64)73) || (fmt==(i64)105)) {
        return msysc$strtoint(s,length,(i64)10);
    }
    else if ((fmt==(i64)66) || (fmt==(i64)98)) {
        return msysc$strtoint(s,length,(i64)2);
    }
    else if ((fmt==(i64)72) || (fmt==(i64)104)) {
        return msysc$strtoint(s,length,(i64)16);
    }
;
    return (i64)0;
}

r64 msysc$m_read_r64(i64 fmt) {
        u8 str[512];
        u8 *  s;
        i64 length;
        i32 numlength;
        r64 x;
    s = msysc$readitem(&length);
    if (((length == (i64)0) || (length >= (i64)512))) {
        return (double)0.;
    }
;
    memcpy(str,(void *)s,(u64)length);
    str[((length + (i64)1))-1] = (u64)0u;
    msysc$itemerror = (i64)0;
    if (((sscanf((u8 *)str,(byte*)"%lf%n",&x,&numlength) == (i64)0) || ((i64)numlength != length))) {
        x = (double)0.;
        msysc$itemerror = (i64)1;
    }
;
    return x;
}

void msysc$m_read_str(u8 *dest,i64 destlen,i64 fmt) {
        u8 *  s;
        i64 length;
    msysc$itemerror = (i64)0;
    if (((fmt == (i64)76) || (fmt == (i64)108))) {
        s = msysc$rd_pos;
        length = ((msysc$rd_buffer + msysc$rd_length) - msysc$rd_pos);
    }
    else {
        s = msysc$readitem(&length);
        if (((fmt == (i64)78) || (fmt == (i64)110))) {
            msysc$iconvlcn(s,length);
        }
;
    }
;
    if ((destlen > (i64)0)) {
        if ((length >= destlen)) {
            length = (destlen - (i64)1);
            msysc$itemerror = (i64)1;
        }
;
    }
;
    memcpy((void *)dest,(void *)s,(u64)length);
    (*(dest + length)) = (u64)0u;
}

void msysc$readstr(u8 *dest,i64 fmt,i64 destlen) {
    msysc$m_read_str(dest,destlen,fmt);
}

void msysc$rereadln(void) {
    msysc$rd_pos = msysc$rd_buffer;
    msysc$rd_lastpos = msysc$rd_pos;
}

void msysc$reread(void) {
    msysc$rd_pos = msysc$rd_lastpos;
}

i64 msysc$valint(u8 *s,i64 fmt) {
        u8 *  old_pos;
        u8 *  old_lastpos;
        i64 aa;
    msysc$initreadbuffer();
    old_pos = msysc$rd_pos;
    old_lastpos = msysc$rd_lastpos;
    msysc$rd_pos = s;
    aa = msysc$m_read_i64(fmt);
    msysc$rd_pos = old_pos;
    msysc$rd_lastpos = old_lastpos;
    return aa;
}

r64 msysc$valreal(u8 *s) {
        u8 *  old_pos;
        u8 *  old_lastpos;
        r64 x;
    msysc$initreadbuffer();
    old_pos = msysc$rd_pos;
    old_lastpos = msysc$rd_lastpos;
    msysc$rd_pos = s;
    x = msysc$m_read_r64((i64)0);
    msysc$rd_pos = old_pos;
    msysc$rd_lastpos = old_lastpos;
    return x;
}

static void msysc$iconvlcn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1209 :;
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1210 :;
    }
L1211 :;
    ;
}

static void msysc$iconvucn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1212 :;
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1213 :;
    }
L1214 :;
    ;
}

static void msysc$convlcstring(u8 *s) {
    L1215 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1216 :;
    }
L1217 :;
    ;
}

static void msysc$convucstring(u8 *s) {
    L1218 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1219 :;
    }
L1220 :;
    ;
}

i64 msysc$m_power_i64(i64 n,i64 a) {
    if ((n < (i64)0)) {
        return (i64)0;
    }
    else if ((n == (i64)0)) {
        return (i64)1;
    }
    else if ((n == (i64)1)) {
        return a;
    }
    else if (((n & (i64)1) == (i64)0)) {
        return msysc$m_power_i64((n / (i64)2),(a*a));
    }
    else {
        return (msysc$m_power_i64(((n - (i64)1) / (i64)2),(a*a)) * a);
    }
;
}

void msysc$m_intoverflow(void) {
    mlib$abortprogram((byte*)"Integer overflow detected");
}

void msysc$m_dotindex(u64 i,u64 a) {
    mlib$abortprogram((byte*)"DOT INDEX");
}

void msysc$m_dotslice(u64 j,u64 i,u64 a) {
    mlib$abortprogram((byte*)"DOT SLICE");
}

void msysc$m_popdotindex(u64 i,u64 *p,u64 x) {
    mlib$abortprogram((byte*)"POP DOT INDEX");
}

void msysc$m_popdotslice(u64 j,u64 i,u64 *p,u64 x) {
    mlib$abortprogram((byte*)"POP DOT SLICE");
}

i64 msysc$m_imin(i64 a,i64 b) {
    return (a<b?a:b);
}

i64 msysc$m_imax(i64 a,i64 b) {
    return (a>b?a:b);
}

r64 msysc$m_sign(r64 x) {
    if ((x > (double)0.)) {
        return (double)1.;
    }
    else if ((x < (double)0.)) {
        return (double)-1.;
    }
    else {
        return (double)0.;
    }
;
}

r64 msysc$m_tp_i64tor64(i64 a) {
        r64 x;
    memcpy(&x,&a,(u64)8u);
    return x;
}

i64 msysc$m_tp_r64toi64(r64 x) {
        i64 a;
    memcpy(&a,&x,(u64)8u);
    return a;
}

i64 msysc$m_tp_reftoi64(void *p) {
        i64 a;
    memcpy(&a,&p,(u64)8u);
    return a;
}

void *msysc$m_tp_i64toref(i64 a) {
        void *  p;
    memcpy(&p,&a,(u64)8u);
    return p;
}

// START
void msysc$start(void) {
    mlib$start();
    mclib$start();
    mwindows$start();
    mwindllc$start();

}

void *mlib$pcm_alloc(i64 n) {
        byte *  p;
    if (!(!!((i64)mlib$pcm_setup))) {
        mlib$pcm_init();
    }
;
    if ((n > (i64)2048)) {
        mlib$alloccode = mlib$pcm_getac(n);
        mlib$allocbytes = (i64)mlib$allocupper[(mlib$alloccode)];
        p = (byte *)mlib$allocmem(mlib$allocbytes);
        if (!(!!(p))) {
            mlib$abortprogram((byte*)"pcm_alloc failure");
        }
;
        return p;
    }
;
    mlib$alloccode = (i64)mlib$sizeindextable[(n)];
    mlib$allocbytes = (i64)mlib$allocupper[(mlib$alloccode)];
    mlib$smallmemtotal += mlib$allocbytes;
    if (!!((p = (byte *)mlib$freelist[(mlib$alloccode)]))) {
        mlib$freelist[(mlib$alloccode)] = (u64 *)(i64)(*mlib$freelist[(mlib$alloccode)]);
        return p;
    }
;
    p = mlib$pcheapptr;
    mlib$pcheapptr += mlib$allocbytes;
    if ((mlib$pcheapptr >= mlib$pcheapend)) {
        p = (byte *)mlib$pcm_newblock(mlib$allocbytes);
        return p;
    }
;
    return p;
}

void mlib$pcm_free(void *p,i64 n) {
        i64 acode;
    if ((n == (i64)0)) {
        return;
    }
;
    if ((n > (i64)2048)) {
        free(p);
        return;
    }
;
    if (!!(p)) {
        acode = (i64)mlib$sizeindextable[(n)];
        mlib$smallmemtotal -= (i64)mlib$allocupper[(acode)];
        (*(u64 *)p) = (u64)(i64)mlib$freelist[(acode)];
        mlib$freelist[(acode)] = (u64 *)p;
    }
;
}

void mlib$pcm_freeac(void *p,i64 alloc) {
    mlib$pcm_free(p,(i64)mlib$allocupper[(alloc)]);
}

void mlib$pcm_clearmem(void *p,i64 n) {
    memset(p,(i32)(i64)0,(u64)n);
}

void mlib$pcm_init(void) {
        i64 j;
        i64 k;
        i64 size;
        i64 i;
    mlib$alloccode = (i64)0;
    if (!!((i64)mlib$pcm_setup)) {
        return;
    }
;
    mlib$pcm_newblock((i64)0);
    for (i=(i64)1;i<=(i64)2048;++i) {
L1221 :;
        j = (i64)1;
        k = (i64)16;
        L1224 :;
        while ((i > k)) {
            k = (k << (i64)1);
            ++(j);
L1225 :;
        }
L1226 :;
        ;
        mlib$sizeindextable[(i)] = j;
L1222 :;
    }
L1223 :;
    ;
    mlib$allocupper[((i64)1)] = (u64)16u;
    size = (i64)16;
    for (i=(i64)2;i<=(i64)27;++i) {
L1227 :;
        size *= (i64)2;
        mlib$allocupper[(i)] = (u64)size;
        if ((size >= (i64)33554432)) {
            k = i;
            goto L1229 ;
        }
;
L1228 :;
    }
L1229 :;
    ;
    for (i=(k + (i64)1);i<=(i64)300;++i) {
L1230 :;
        size += (i64)33554432;
        if ((size < (i64)8589934592)) {
            mlib$allocupper[(i)] = (u64)size;
            mlib$maxmemory = (u64)size;
        }
        else {
            mlib$maxalloccode = (i - (i64)1);
            goto L1232 ;
        }
;
L1231 :;
    }
L1232 :;
    ;
    mlib$pcm_setup = (i64)1;
}

i64 mlib$pcm_getac(i64 size) {
    if ((size <= (i64)2048)) {
        return (i64)mlib$sizeindextable[(size)];
    }
;
    size = ((size + (i64)255) >> (i64)8);
    if ((size <= (i64)2048)) {
        return ((i64)mlib$sizeindextable[(size)] + (i64)8);
    }
;
    size = ((size + (i64)63) >> (i64)6);
    if ((size <= (i64)2048)) {
        return ((i64)mlib$sizeindextable[(size)] + (i64)14);
    }
;
    size = ((((size - (i64)2048) + (i64)2047) / (i64)2048) + (i64)22);
    return size;
}

void *mlib$pcm_newblock(i64 itemsize) {
        static i64 totalheapsize;
        byte *  p;
    totalheapsize += (i64)2097152;
    mlib$alloccode = (i64)0;
    p = (byte *)mlib$allocmem((i64)2097152);
    if ((p == 0)) {
        mlib$abortprogram((byte*)"Can't alloc pc heap");
    }
;
    mlib$pcheapptr = p;
    mlib$pcheapend = (p + (i64)2097152);
    if ((mlib$pcheapstart == 0)) {
        mlib$pcheapstart = p;
    }
;
    mlib$pcheapptr += itemsize;
    return (u32 *)p;
}

i64 mlib$pcm_round(i64 n) {
        static i32 allocbytes[9] = {(i32)(i64)0,(i32)(i64)16,(i32)(i64)32,(i32)(i64)64,(i32)(i64)128,(i32)(i64)256,(i32)(i64)512,(i32)(i64)1024,(i32)(i64)2048};
    if ((n > (i64)2048)) {
        return n;
    }
    else {
        return (i64)allocbytes[((i64)mlib$sizeindextable[(n)])];
    }
;
}

void *mlib$pcm_allocz(i64 n) {
        void *  p;
    p = mlib$pcm_alloc(n);
    memset(p,(i32)(i64)0,(u64)n);
    return p;
}

u8 *mlib$pcm_copyheapstring(u8 *s) {
        u8 *  q;
        i64 n;
    if ((s == 0)) {
        return 0;
    }
;
    n = (strlen(s) + (i64)1);
    q = (u8 *)mlib$pcm_alloc(n);
    memcpy((void *)q,(void *)s,(u64)n);
    return q;
}

u8 *mlib$pcm_copyheapstringn(u8 *s,i64 n) {
        u8 *  q;
    if ((s == 0)) {
        return 0;
    }
;
    q = (u8 *)mlib$pcm_alloc((n + (i64)1));
    memcpy((void *)q,(void *)s,(u64)n);
    (*(q + n)) = (u64)0u;
    return q;
}

u8 *mlib$pcm_copyheapblock(u8 *s,i64 length) {
        u8 *  q;
    if ((length == (i64)0)) {
        return 0;
    }
;
    q = (u8 *)mlib$pcm_alloc(length);
    memcpy((void *)q,(void *)s,(u64)length);
    return q;
}

void *mlib$allocmem(i64 n) {
        void *  p;
    p = malloc((u64)n);
    if (!!(p)) {
        return p;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_i64(n,NULL);
    msysc$m_print_i64(mlib$memtotal,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlib$abortprogram((byte*)"Alloc mem failure");
    return 0;
}

void *mlib$reallocmem(void *p,i64 n) {
    p = realloc(p,(u64)n);
    if (!!(p)) {
        return p;
    }
;
    msysc$m_print_startcon();
    msysc$m_print_i64(n,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    mlib$abortprogram((byte*)"Realloc mem failure");
    return 0;
}

void mlib$abortprogram(u8 *s) {
    msysc$m_print_startcon();
    msysc$m_print_str(s,NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_str((byte*)"ABORTING: Press key...",NULL);
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    msysc$m_print_startcon();
    msysc$m_print_newline();
    msysc$m_print_end();
    ;
    exit((i64)5);
}

i64 mlib$getfilesize(void *handlex) {
        u32 p;
        u32 size;
    p = ftell(handlex);
    fseek(handlex,(i32)(i64)0,(i32)(i64)2);
    size = ftell(handlex);
    fseek(handlex,(i32)(i64)p,(i32)(i64)0);
    return (i64)size;
}

void mlib$readrandom(void *handlex,byte *mem,i64 offset,i64 size) {
        i64 a;
    fseek(handlex,(i32)offset,(i32)(i64)0);
    a = (i64)fread(mem,(u64)1u,(u64)size,handlex);
}

i64 mlib$writerandom(void *handlex,byte *mem,i64 offset,i64 size) {
    fseek(handlex,(i32)offset,(i32)(i64)0);
    return (i64)fwrite(mem,(u64)1u,(u64)size,handlex);
}

i64 mlib$setfilepos(void *file,i64 offset) {
    return fseek(file,(i32)offset,(i32)(i64)0);
}

i64 mlib$getfilepos(void *file) {
    return ftell(file);
}

byte *mlib$readfile(u8 *filename) {
        void *  f;
        i64 size;
        byte *  m;
        byte *  p;
    f = fopen(filename,(byte*)"rb");
    if ((f == 0)) {
        return 0;
    }
;
    mlib$rfsize = (size = mlib$getfilesize(f));
    m = (byte *)mlib$pcm_alloc((size + (i64)2));
    if ((m == 0)) {
        return 0;
    }
;
    mlib$readrandom(f,m,(i64)0,size);
    p = (m + size);
    (*(u16 *)p) = (i64)0;
    fclose(f);
    return m;
}

i64 mlib$writefile(u8 *filename,byte *data,i64 size) {
        void *  f;
        i64 n;
    f = fopen(filename,(byte*)"wb");
    if ((f == 0)) {
        return (i64)0;
    }
;
    n = mlib$writerandom(f,data,(i64)0,size);
    fclose(f);
    return n;
}

i64 mlib$checkfile(u8 *file) {
        void *  f;
    if (!!((f = fopen(file,(byte*)"rb")))) {
        fclose(f);
        return (i64)1;
    }
;
    return (i64)0;
}

void mlib$readlinen(void *handlex,u8 *buffer,i64 size) {
        i64 ch;
        u8 *  p;
        i64 n;
        byte crseen;
    if ((handlex == 0)) {
        handlex = mwindows$os_getstdin();
    }
;
    if ((handlex == 0)) {
        n = (i64)0;
        p = buffer;
        L1233 :;
        while (1) {
            ch = getchar();
            if ((((ch == (i64)13) || (ch == (i64)10)) || (ch == (i64)-1))) {
                (*p) = (u64)0u;
                return;
            }
;
            (*(p)++) = (u64)ch;
            ++(n);
            if ((n >= (size - (i64)2))) {
                (*p) = (u64)0u;
                return;
            }
;
        }
L1234 :;
        ;
    }
;
    (*buffer) = (u64)0u;
    if ((fgets(buffer,(size - (i64)2),handlex) == 0)) {
        return;
    }
;
    n = strlen(buffer);
    if ((n == (i64)0)) {
        return;
    }
;
    p = ((buffer + n) - (i64)1);
    crseen = (i64)0;
    L1235 :;
    while (((p >= buffer) && (((i64)(u64)(*p) == (i64)13) || ((i64)(u64)(*p) == (i64)10)))) {
        if ((((i64)(u64)(*p) == (i64)13) || ((i64)(u64)(*p) == (i64)10))) {
            crseen = (i64)1;
        }
;
        (*(p)--) = (u64)0u;
L1236 :;
    }
L1237 :;
    ;
    if ((!(!!((i64)crseen)) && ((n + (i64)4) > size))) {
        msysc$m_print_startcon();
        msysc$m_print_i64(size,NULL);
        msysc$m_print_i64(n,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        mlib$abortprogram((byte*)"line too long");
    }
;
}

void mlib$iconvlcn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1238 :;
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1239 :;
    }
L1240 :;
    ;
}

void mlib$iconvucn(u8 *s,i64 n) {
        i64 $av_1;
    $av_1 = n;
    while ($av_1-- > 0) {
L1241 :;
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1242 :;
    }
L1243 :;
    ;
}

u8 *mlib$convlcstring(u8 *s) {
        u8 *  s0;
    s0 = s;
    L1244 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)tolower((i32)(u64)(*s));
        ++(s);
L1245 :;
    }
L1246 :;
    ;
    return s0;
}

u8 *mlib$convucstring(u8 *s) {
        u8 *  s0;
    s0 = s;
    L1247 :;
    while (!!((u64)(*s))) {
        (*s) = (u64)toupper((i32)(u64)(*s));
        ++(s);
L1248 :;
    }
L1249 :;
    ;
    return s0;
}

u8 *mlib$changeext(u8 *s,u8 *newext) {
        static u8 newfile[260];
        u8 newext2[32];
        u8 *  sext;
        i64 n;
    strcpy((u8 *)&newfile[((i64)1)-1],s);
        {u64 $temp = (u64)(*newext);
if (($temp==(u64)0u)) {
        newext2[((i64)1)-1] = (u64)0u;
        newext2[((i64)2)-1] = (u64)0u;
    }
    else if (($temp=='.')) {
        strcpy((u8 *)&newext2[((i64)1)-1],newext);
    }
    else {
        strcpy((u8 *)&newext2[((i64)1)-1],(byte*)".");
        strcat((u8 *)&newext2[((i64)1)-1],newext);
    }
    };
    sext = mlib$extractext(s,(i64)1);
        {u64 $temp = (u64)(*sext);
if (($temp==(u64)0u)) {
        strcat((u8 *)&newfile[((i64)1)-1],(u8 *)&newext2[((i64)1)-1]);
    }
    else if (($temp=='.')) {
        strcat((u8 *)&newfile[((i64)1)-1],(u8 *)&newext2[((i64)2)-1]);
    }
    else {
        n = ((sext - s) - (i64)2);
        strcpy((u8 *)((&newfile[((i64)1)-1] + n) + (i64)1),(u8 *)&newext2[((i64)1)-1]);
    }
    };
    return (u8 *)&newfile[((i64)1)-1];
}

u8 *mlib$extractext(u8 *s,i64 period) {
        u8 *  t;
        u8 *  u;
    t = mlib$extractfile(s);
    if (((i64)(u64)(*t) == (i64)0)) {
        return (byte*)"";
    }
;
    u = ((t + strlen(t)) - (i64)1);
    L1250 :;
    while ((u >= t)) {
        if (((u64)(*u) == '.')) {
            if (((i64)(u64)(*(u + (i64)1)) == (i64)0)) {
                return (!!(period) ? (byte*)"." : (byte*)"");
            }
;
            return (u + (i64)1);
        }
;
        --(u);
L1251 :;
    }
L1252 :;
    ;
    return (byte*)"";
}

u8 *mlib$extractpath(u8 *s) {
        static u8 str[260];
        u8 *  t;
        i64 n;
    t = ((s + strlen(s)) - (i64)1);
    L1253 :;
    while ((t >= s)) {
        switch ((i64)(u64)(*t)) {
        case 92:;
        case 47:;
        case 58:;
            {
                n = ((t - s) + (i64)1);
                memcpy(str,(void *)s,(u64)n);
                str[(n)] = (u64)0u;
                return (u8 *)str;
            }
            break;
        } //SW
;
        --(t);
L1254 :;
    }
L1255 :;
    ;
    return (byte*)"";
}

u8 *mlib$extractfile(u8 *s) {
        u8 *  t;
    t = mlib$extractpath(s);
    if (((i64)(u64)(*t) == (i64)0)) {
        return s;
    }
;
    return (s + strlen(t));
}

u8 *mlib$extractbasefile(u8 *s) {
        static u8 str[100];
        u8 *  f;
        u8 *  e;
        i64 n;
        i64 flen;
    f = mlib$extractfile(s);
    flen = strlen(f);
    if ((flen == (i64)0)) {
        return (byte*)"";
    }
;
    e = mlib$extractext(f,(i64)0);
    if (!!((u64)(*e))) {
        n = ((flen - strlen(e)) - (i64)1);
        memcpy(&str,(void *)f,(u64)n);
        str[(n)] = (u64)0u;
        return (u8 *)str;
    }
;
    if (((u64)(*((f + flen) - (i64)1)) == '.')) {
        memcpy(&str,(void *)f,(u64)(flen - (i64)1));
        str[((flen - (i64)1))] = (u64)0u;
        return (u8 *)str;
    }
;
    return f;
}

u8 *mlib$addext(u8 *s,u8 *newext) {
        u8 *  sext;
    sext = mlib$extractext(s,(i64)1);
    if (((i64)(u64)(*sext) == (i64)0)) {
        return mlib$changeext(s,newext);
    }
;
    return s;
}

void *mlib$pcm_alloc32(void) {
        byte *  p;
    mlib$allocbytes = (i64)32;
    mlib$smallmemtotal += (i64)32;
    if (!!((p = (byte *)mlib$freelist[((i64)2)]))) {
        mlib$freelist[((i64)2)] = (u64 *)(i64)(*mlib$freelist[((i64)2)]);
        return p;
    }
;
    return mlib$pcm_alloc((i64)32);
}

void mlib$pcm_free32(void *p) {
    mlib$smallmemtotal -= (i64)32;
    (*(u64 *)p) = (u64)(i64)mlib$freelist[((i64)2)];
    mlib$freelist[((i64)2)] = (u64 *)p;
}

void mlib$outbyte(void *f,i64 x) {
    fwrite(&x,(u64)1u,(u64)1u,f);
}

void mlib$outword16(void *f,u64 x) {
    fwrite(&x,(u64)2u,(u64)1u,f);
}

void mlib$outword32(void *f,u64 x) {
    fwrite(&x,(u64)4u,(u64)1u,f);
}

void mlib$outword64(void *f,u64 x) {
    fwrite(&x,(u64)8u,(u64)1u,f);
}

void mlib$outstring(void *f,u8 *s) {
    fwrite((void *)s,(u64)(strlen(s) + (i64)1),(u64)1u,f);
}

void mlib$outblock(void *f,void *p,i64 n) {
    fwrite(p,(u64)n,(u64)1u,f);
}

i64 mlib$myeof(void *f) {
        i64 c;
    c = fgetc(f);
    if ((c == (i64)-1)) {
        return (i64)1;
    }
;
    ungetc((i32)c,f);
    return (i64)0;
}

void mlib$strbuffer_add(struct mlib$strbuffer *dest,u8 *s,i64 n) {
        i64 newlen;
        i64 oldlen;
        u8 *  newptr;
    if ((n == (i64)0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"N=0",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
    if ((n == (i64)-1)) {
        n = strlen(s);
    }
;
    oldlen = (i64)(*dest).length;
    if ((oldlen == (i64)0)) {
        (*dest).strptr = (u8 *)mlib$pcm_alloc((n + (i64)1));
        (*dest).allocated = mlib$allocbytes;
        (*dest).length = n;
        memcpy((void *)(*dest).strptr,(void *)s,(u64)n);
        (*((*dest).strptr + n)) = (u64)0u;
        return;
    }
;
    newlen = (oldlen + n);
    if (((newlen + (i64)1) > (i64)(*dest).allocated)) {
        newptr = (u8 *)mlib$pcm_alloc((newlen + (i64)1));
        memcpy((void *)newptr,(void *)(*dest).strptr,(u64)oldlen);
        (*dest).strptr = newptr;
        (*dest).allocated = mlib$allocbytes;
    }
;
    memcpy((void *)((*dest).strptr + oldlen),(void *)s,(u64)n);
    (*((*dest).strptr + newlen)) = (u64)0u;
    (*dest).length = newlen;
}

void mlib$gs_init(struct mlib$strbuffer *dest) {
    mlib$pcm_clearmem(dest,(i64)16);
}

void mlib$gs_free(struct mlib$strbuffer *dest) {
    if (!!((i64)(*dest).allocated)) {
        mlib$pcm_free((void *)(*dest).strptr,(i64)(*dest).allocated);
    }
;
}

void mlib$gs_str(struct mlib$strbuffer *dest,u8 *s) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,s,(i64)-1);
}

void mlib$gs_char(struct mlib$strbuffer *dest,i64 c) {
        u8 s[16];
    s[((i64)1)-1] = (u64)c;
    s[((i64)2)-1] = (u64)0u;
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,(u8 *)s,(i64)1);
}

void mlib$gs_strn(struct mlib$strbuffer *dest,u8 *s,i64 length) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,s,length);
}

void mlib$gs_strvar(struct mlib$strbuffer *dest,struct mlib$strbuffer *s) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,(*s).strptr,(i64)-1);
}

void mlib$gs_strint(struct mlib$strbuffer *dest,i64 a) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,msysc$strint(a,0),(i64)-1);
}

void mlib$gs_strln(struct mlib$strbuffer *dest,u8 *s) {
    mlib$gs_str((struct mlib$strbuffer *)dest,s);
    mlib$gs_line((struct mlib$strbuffer *)dest);
}

void mlib$gs_strsp(struct mlib$strbuffer *dest,u8 *s) {
    mlib$gs_str((struct mlib$strbuffer *)dest,s);
    mlib$gs_str((struct mlib$strbuffer *)dest,(byte*)" ");
}

void mlib$gs_line(struct mlib$strbuffer *dest) {
    mlib$strbuffer_add((struct mlib$strbuffer *)dest,(byte*)"\r\n",(i64)-1);
}

i64 mlib$gs_getcol(struct mlib$strbuffer *dest) {
    return (i64)(*dest).length;
}

void mlib$gs_leftstr(struct mlib$strbuffer *dest,u8 *s,i64 w,i64 padch) {
        i64 col;
        i64 i;
        i64 n;
        i64 slen;
        u8 str[2560];
    col = (i64)(*dest).length;
    strcpy((u8 *)str,s);
    slen = strlen(s);
    n = (w - slen);
    if ((n > (i64)0)) {
        for (i=(i64)1;i<=n;++i) {
L1256 :;
            str[((slen + i))-1] = (u64)padch;
L1257 :;
        }
L1258 :;
        ;
        str[(((slen + n) + (i64)1))-1] = (u64)0u;
    }
;
    mlib$gs_str((struct mlib$strbuffer *)dest,(u8 *)str);
}

void mlib$gs_leftint(struct mlib$strbuffer *dest,i64 a,i64 w,i64 padch) {
    mlib$gs_leftstr((struct mlib$strbuffer *)dest,msysc$strint(a,0),w,padch);
}

void mlib$gs_padto(struct mlib$strbuffer *dest,i64 col,i64 ch) {
        i64 n;
        u8 str[2560];
        i64 i;
    n = (col - (i64)(*dest).length);
    if ((n <= (i64)0)) {
        return;
    }
;
    for (i=(i64)1;i<=n;++i) {
L1259 :;
        str[(i)-1] = (u64)ch;
L1260 :;
    }
L1261 :;
    ;
    str[((n + (i64)1))-1] = (u64)0u;
    mlib$gs_str((struct mlib$strbuffer *)dest,(u8 *)str);
}

void mlib$gs_println(struct mlib$strbuffer *dest,void *f) {
    if (((i64)(*dest).length == (i64)0)) {
        return;
    }
;
    (*((*dest).strptr + (i64)(*dest).length)) = (u64)0u;
    if ((f == 0)) {
        msysc$m_print_startcon();
        msysc$m_print_str((*dest).strptr,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
    else {
        msysc$m_print_startfile(f);
        msysc$m_print_str((*dest).strptr,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
    }
;
}

i64 mlib$nextcmdparamnew(i64 *paramno,u8 **name,u8 **value,u8 *defext) {
        static i64 infile = (i64)0;
        static u8 *  filestart = 0;
        static u8 *  fileptr = 0;
        static byte colonseen = (byte)(i64)0;
        u8 *  q;
        u8 *  item;
        u8 *  fileext;
        i64 length;
        i64 atsize;
        static u8 str[300];
    //reenter:
L1262 :;
;
    (*value) = 0;
    (*name) = 0;
    if (!!(infile)) {
        if ((mlib$readnextfileitem(&fileptr,&item) == (i64)0)) {
            mlib$pcm_free((void *)filestart,atsize);
            infile = (i64)0;
            goto L1262 ;
;
        }
;
    }
    else {
        if (((*paramno) > msysc$ncmdparams)) {
            return (i64)0;
        }
;
        item = (*msysc$cmdparams)[((*paramno))];
        ++((*paramno));
        length = strlen(item);
        if (((u64)(*item) == '@')) {
            if (!!(infile)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Nested @",NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)1);
            }
;
            filestart = (fileptr = (u8 *)mlib$readfile((item + (i64)1)));
            if ((filestart == 0)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Can't open",NULL);
                msysc$m_print_str(item,NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)7);
            }
;
            infile = (i64)1;
            atsize = mlib$allocbytes;
            goto L1262 ;
;
        }
;
        if (((u64)(*item) == ':')) {
            colonseen = (i64)1;
            return (i64)4;
        }
;
    }
;
    (*value) = 0;
    if (((u64)(*item) == '-')) {
        (*name) = (item + (!!((i64)colonseen) ? (i64)0 : (i64)1));
        q = strchr(item,(i32)':');
        if (!(!!(q))) {
            q = strchr(item,(i32)'=');
        }
;
        if (!!(q)) {
            (*value) = (q + (i64)1);
            (*q) = (u64)0u;
        }
;
        return (!!((i64)colonseen) ? (i64)5 : (i64)1);
    }
;
    fileext = mlib$extractext(item,(i64)0);
    (*name) = item;
    if (((i64)(u64)(*fileext) == (i64)0)) {
        strcpy((u8 *)str,(*name));
        if ((!!(defext) && !(!!((i64)colonseen)))) {
            (*name) = mlib$addext((u8 *)str,defext);
        }
;
    }
    else if ((!!(mlib$eqstring(fileext,(byte*)"dll")) || !!(mlib$eqstring(fileext,(byte*)"mcx")))) {
        return (!!((i64)colonseen) ? (i64)5 : (i64)3);
    }
;
    if (!!((i64)colonseen)) {
        return (i64)5;
    }
    else {
        return (i64)2;
    }
;
}

static i64 mlib$readnextfileitem(u8 **fileptr,u8 **item) {
        u8 *  p;
        u8 *  pstart;
        u8 *  pend;
        i64 n;
        static u8 str[256];
    p = (*fileptr);
    //reenter:
L1263 :;
;
    L1264 :;
    while (1) {
                {u64 $temp = (u64)(*p);
if (($temp==' ') || ($temp==(u64)9u) || ($temp==(u64)13u) || ($temp==(u64)10u)) {
            ++(p);
        }
        else if (($temp==(u64)26u) || ($temp==(u64)0u)) {
            return (i64)0;
        }
        else {
            goto L1265 ;
        }
        };
    }
L1265 :;
    ;
        {u64 $temp = (u64)(*p);
if (($temp=='!') || ($temp=='#')) {
        ++(p);
        L1266 :;
                {u64 $temp = (u64)(*(p)++);
if (($temp==(u64)10u)) {
            goto L1263 ;
;
        }
        else if (($temp==(u64)26u) || ($temp==(u64)0u)) {
            (*fileptr) = (p - (i64)1);
            return (i64)0;
        }
        else {
        }
        }goto L1266 ;
L1267 :;
        ;
    }
    };
        {u64 $temp = (u64)(*p);
if (($temp=='"')) {
        pstart = ++(p);
        L1268 :;
        while (1) {
                        {u64 $temp = (u64)(*p);
if (($temp==(u64)0u) || ($temp==(u64)26u)) {
                msysc$m_print_startcon();
                msysc$m_print_str((byte*)"Unexpected EOF in @file",NULL);
                msysc$m_print_newline();
                msysc$m_print_end();
                ;
                exit((i64)8);
            }
            else if (($temp=='"')) {
                pend = (p)++;
                if (((u64)(*p) == ',')) {
                    ++(p);
                }
;
                goto L1269 ;
            }
            };
            ++(p);
        }
L1269 :;
        ;
    }
    else {
        pstart = p;
        L1270 :;
        while (1) {
                        {u64 $temp = (u64)(*p);
if (($temp==(u64)0u) || ($temp==(u64)26u)) {
                pend = p;
                goto L1271 ;
            }
            else if (($temp==' ') || ($temp==(u64)9u) || ($temp==',') || ($temp==(u64)13u) || ($temp==(u64)10u)) {
                pend = (p)++;
                goto L1271 ;
            }
            };
            ++(p);
        }
L1271 :;
        ;
    }
    };
    n = (pend - pstart);
    if ((n >= (i64)256)) {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"@file item too long",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)9);
    }
;
    memcpy(str,(void *)pstart,(u64)n);
    str[((n + (i64)1))-1] = (u64)0u;
    (*item) = (u8 *)str;
    (*fileptr) = p;
    return (i64)1;
}

void mlib$ipadstr(u8 *s,i64 width,u8 *padchar) {
        i64 n;
        i64 $av_1;
    n = strlen(s);
    $av_1 = (width - n);
    while ($av_1-- > 0) {
L1272 :;
        strcat(s,padchar);
L1273 :;
    }
L1274 :;
    ;
}

u8 *mlib$padstr(u8 *s,i64 width,u8 *padchar) {
        static u8 str[256];
    strcpy((u8 *)str,s);
    mlib$ipadstr((u8 *)str,width,padchar);
    return (u8 *)str;
}

u8 *mlib$chr(i64 c) {
        static u8 str[8];
    str[((i64)1)-1] = (u64)c;
    str[((i64)2)-1] = (u64)0u;
    return (u8 *)str;
}

i64 mlib$cmpstring(u8 *s,u8 *t) {
        i64 res;
    if (((res = strcmp(s,t)) < (i64)0)) {
        return (i64)-1;
    }
    else if ((res > (i64)0)) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

i64 mlib$cmpstringn(u8 *s,u8 *t,i64 n) {
        i64 res;
    if (((res = strncmp(s,t,(u64)n)) < (i64)0)) {
        return (i64)-1;
    }
    else if ((res > (i64)0)) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

i64 mlib$eqstring(u8 *s,u8 *t) {
    return (i64)(strcmp(s,t) == (i64)0);
}

i64 mlib$cmpbytes(void *p,void *q,i64 n) {
        i64 res;
    if (((res = memcmp(p,q,(u64)n)) < (i64)0)) {
        return (i64)-1;
    }
    else if ((res > (i64)0)) {
        return (i64)1;
    }
    else {
        return (i64)0;
    }
;
}

i64 mlib$eqbytes(void *p,void *q,i64 n) {
    return (i64)(memcmp(p,q,(u64)n) == (i64)0);
}

void mlib$mseed(u64 a,u64 b) {
    mlib$seed[((i64)1)-1] = a;
    if (!!(b)) {
        mlib$seed[((i64)2)-1] = b;
    }
    else {
        mlib$seed[((i64)2)-1] ^= a;
    }
;
}

u64 mlib$mrandom(void) {
        i64 x;
        i64 y;
    x = (i64)mlib$seed[((i64)1)-1];
    y = (i64)mlib$seed[((i64)2)-1];
    mlib$seed[((i64)1)-1] = (u64)y;
    x ^= (x << (i64)23);
    mlib$seed[((i64)2)-1] = (u64)(((x ^ y) ^ (x >> (i64)17)) ^ (y >> (i64)26));
    return (u64)((i64)mlib$seed[((i64)2)-1] + y);
}

i64 mlib$mrandomp(void) {
    return ((i64)mlib$mrandom() & (i64)9223372036854775807);
}

i64 mlib$mrandomint(i64 n) {
    return (mlib$mrandomp() % n);
}

i64 mlib$mrandomrange(i64 a,i64 b) {
        i64 span;
    span = ((b - a) + (i64)1);
    if ((span <= (i64)0)) {
        return (i64)0;
    }
;
    return ((mlib$mrandomp() % span) + a);
}

r64 mlib$mrandomreal(void) {
        r64 x;
    L1275 :;
    do {
        x = ((r64)mlib$mrandomp() / (double)9223372036854775800.);
L1276 :;
    }
    while (!(x != (double)1.));
L1277 :;
    ;
    return x;
}

r64 mlib$mrandomreal1(void) {
    return (r64)(mlib$mrandomp() / (i64)9223372036854775807);
}

u8 *mlib$readline(void) {
    msysc$m_read_conline();
    ;
    return msysc$rd_buffer;
}

void *mlib$findfunction(u8 *name) {
        i64 $av_1;
        i64 i;
        ($av_1 = msysc$m_get_nprocs());
    for (i=(i64)1;i<=$av_1;++i) {
L1278 :;
        if (!!(mlib$eqstring(msysc$m_get_procname(i),name))) {
            return msysc$m_get_procaddr(i);
        }
;
L1279 :;
    }
L1280 :;
    ;
    return 0;
}

i64 mlib$roundtoblock(i64 n,i64 align) {
    if (((n & (align - (i64)1)) == (i64)0)) {
        return n;
    }
;
    return (n + (align - (n & (align - (i64)1))));
}

// START
void mlib$start(void) {

}

// START
void mclib$start(void) {

}

void mwindows$os_init(void) {
    mwindows$hconsole = GetStdHandle((u32)(i64)(u32)(i64)-11);
    mwindows$hconsolein = GetStdHandle((u32)(i64)(u32)(i64)-10);
    mwindows$lastkey.repeatcount = (i64)0;
    mwindows$keypending = (i64)0;
    SetConsoleCtrlHandler(0,(i64)1);
    SetConsoleMode(mwindows$hconsole,(u32)(i64)3);
    mwindows$init_flag = (i64)1;
}

i64 mwindows$os_execwait(u8 *cmdline,i64 newconsole,u8 *workdir) {
        u32 exitcode;
        i64 status;
        i64 cflags;
        struct mwindows$rstartupinfo si;
        struct mwindows$rprocess_information xpi;
    cflags = (i64)0;
    memset(&(si),0,104);
    memset(&(xpi),0,24);
    switch (newconsole) {
    case 0:;
        {
            cflags = (i64)32;
        }
        break;
    case 1:;
        {
            cflags = (i64)48;
        }
        break;
    case 2:;
        {
            cflags = (i64)48;
        }
        break;
    } //SW
;
    si.size = (i64)104;
    status = CreateProcessA(0,cmdline,0,0,(i64)1,(u32)cflags,0,0,&si,&xpi);
    if ((status == (i64)0)) {
        status = GetLastError();
        printf((byte*)"Winexec error: %lld\n",status);
        return (i64)-1;
    }
;
    WaitForSingleObject(xpi.process,(u32)(i64)4294967295);
    GetExitCodeProcess(xpi.process,&exitcode);
    CloseHandle(xpi.process);
    CloseHandle(xpi.thread);
    return (i64)exitcode;
}

i64 mwindows$os_execcmd(u8 *cmdline,i64 newconsole) {
        struct mwindows$rstartupinfo si;
        struct mwindows$rprocess_information xpi;
    memset(&(si),0,104);
    memset(&(xpi),0,24);
    si.size = (i64)104;
    CreateProcessA(0,cmdline,0,0,(i64)1,(u32)((i64)32 | (!!(newconsole) ? (i64)16 : (i64)0)),0,0,&si,&xpi);
    CloseHandle(xpi.process);
    CloseHandle(xpi.thread);
    return (i64)1;
}

i64 mwindows$os_getch(void) {
        i64 k;
    k = (mwindows$os_getchx() & (i64)255);
    return k;
}

i64 mwindows$os_kbhit(void) {
        u32 count;
    if (!(!!(mwindows$init_flag))) {
        mwindows$os_init();
    }
;
    GetNumberOfConsoleInputEvents(mwindows$hconsolein,&count);
    return (i64)((i64)count > (i64)1);
}

u64 mwindows$os_getdllinst(u8 *name) {
        void *  hinst;
    hinst = LoadLibraryA(name);
    return (u64)hinst;
}

void *mwindows$os_getdllprocaddr(i64 hinst,u8 *name) {
    return GetProcAddress((void *)hinst,name);
}

void mwindows$os_initwindows(void) {
    mwindows$os_init();
    mwindows$os_gxregisterclass((byte*)"pcc001");
}

void mwindows$os_gxregisterclass(u8 *classname) {
        struct mwindows$rwndclassex r;
        static byte registered;
    if (!!((i64)registered)) {
        return;
    }
;
    memset(&(r),0,80);
    r.size = (i64)80;
    r.style = (i64)40;
    r.wndproc = (void (*)(void))&mwindows$mainwndproc;
    r.instance = 0;
    r.icon = 0;
    r.cursor = LoadCursorA(0,(u8 *)(void *)(i64)32512);
    r.background = (void *)(i64)16;
    r.menuname = 0;
    r.classname = classname;
    r.iconsm = 0;
    if ((RegisterClassExA(&r) == (i64)0)) {
        printf((byte*)"Regclass error: %lld %lld\n",classname,GetLastError());
        exit((i64)1);
    }
;
    registered = (i64)1;
}

i64 mwindows$mainwndproc(void *hwnd,u32 message,u64 wparam,u64 lparam) {
        struct mwindows$rmsg m;
        i64 result;
        static i64 count = (i64)0;
    m.hwnd = hwnd;
    m.message = (i64)message;
    m.wparam = wparam;
    m.lparam = lparam;
    m.pt.x = (i64)0;
    m.pt.y = (i64)0;
    if (!!(mwindows$wndproc_callbackfn)) {
        result = ((*mwindows$wndproc_callbackfn))(&m);
    }
    else {
        result = (i64)0;
    }
;
    if (((i64)m.message == (i64)2)) {
        return (i64)0;
    }
;
    if (!(!!(result))) {
        return DefWindowProcA(hwnd,(u32)(i64)message,wparam,lparam);
    }
    else {
        return (i64)0;
    }
;
}

void mwindows$os_setmesshandler(void *addr) {
    mwindows$wndproc_callbackfn = (i64 (*)(void *))addr;
}

i64 mwindows$os_getchx(void) {
        i64 count;
        i64 charcode;
        i64 keyshift;
        i64 keycode;
        i64 altdown;
        i64 ctrldown;
        i64 shiftdown;
        i64 capslock;
    if (!(!!(mwindows$init_flag))) {
        mwindows$os_init();
    }
;
    if (!!(mwindows$keypending)) {
        mwindows$lastkey = mwindows$pendkey;
        mwindows$keypending = (i64)0;
    }
    else {
        if (((i64)mwindows$lastkey.repeatcount == (i64)0)) {
            L1281 :;
            do {
                count = (i64)0;
                ReadConsoleInputA(mwindows$hconsolein,&mwindows$lastkey,(u32)(i64)1,&count);
L1282 :;
            }
            while (!(((i64)mwindows$lastkey.eventtype == (i64)1) && ((i64)mwindows$lastkey.keydown == (i64)1)));
L1283 :;
            ;
        }
;
    }
;
    altdown = (!!(((i64)mwindows$lastkey.controlkeystate & (i64)3)) ? (i64)1 : (i64)0);
    ctrldown = (!!(((i64)mwindows$lastkey.controlkeystate & (i64)12)) ? (i64)1 : (i64)0);
    shiftdown = (!!(((i64)mwindows$lastkey.controlkeystate & (i64)16)) ? (i64)1 : (i64)0);
    capslock = (!!(((i64)mwindows$lastkey.controlkeystate & (i64)128)) ? (i64)1 : (i64)0);
    --(mwindows$lastkey.repeatcount);
    charcode = (i64)mwindows$lastkey.asciichar;
    keycode = ((i64)mwindows$lastkey.virtualkeycode & (i64)255);
    if ((charcode < (i64)0)) {
        if ((charcode < (i64)-128)) {
            charcode = (i64)0;
        }
        else {
            charcode += (i64)256;
        }
;
    }
;
    if (((!!(altdown) && !!(ctrldown)) && (charcode == (i64)166))) {
        altdown = (ctrldown = (i64)0);
    }
    else {
        if ((!!(altdown) || !!(ctrldown))) {
            charcode = (i64)0;
            if (((keycode >= (i64)65) && (keycode <= (i64)90))) {
                charcode = (keycode - (i64)64);
            }
;
        }
;
    }
;
    keyshift = ((((capslock << (i64)3) | (altdown << (i64)2)) | (ctrldown << (i64)1)) | shiftdown);
    return (((keyshift << (i64)24) | (keycode << (i64)16)) | charcode);
}

u8 *mwindows$os_getos(void) {
    if (((i64)64 == (i64)32)) {
        return (byte*)"W32";
    }
    else {
        return (byte*)"W64";
    }
;
}

i64 mwindows$os_gethostsize(void) {
    return (i64)64;
}

i64 mwindows$os_shellexec(u8 *opc,u8 *file) {
    return system(file);
}

void mwindows$os_sleep(i64 a) {
    Sleep((u32)a);
}

void *mwindows$os_getstdin(void) {
    return fopen((byte*)"con",(byte*)"rb");
}

void *mwindows$os_getstdout(void) {
    return fopen((byte*)"con",(byte*)"wb");
}

u8 *mwindows$os_gethostname(void) {
        static u8 name[300];
    GetModuleFileNameA(0,(u8 *)name,(u32)(i64)300);
    return (u8 *)name;
}

u8 *mwindows$os_getmpath(void) {
    return (byte*)"C:\\m\\";
}

i64 mwindows$os_clock(void) {
    return clock();
}

i64 mwindows$os_ticks(void) {
    return (i64)GetTickCount64();
}

i64 mwindows$os_hptimer(void) {
        i64 t;
    QueryPerformanceCounter(&t);
    return t;
}

i64 mwindows$os_iswindows(void) {
    return (i64)1;
}

void mwindows$os_getsystime(struct mwindows$rsystemtime *tm) {
    GetLocalTime((struct mwindows$rsystemtime *)tm);
}

void mwindows$os_peek(void) {
        i64 ticks;
        static i64 lastticks;
        byte m[100];
    ticks = (i64)GetTickCount64();
    if (((ticks - lastticks) >= (i64)1000)) {
        lastticks = ticks;
        PeekMessageA(&m,0,(u32)(i64)0,(u32)(i64)0,(u32)(i64)0);
    }
;
}

byte *mwindows$os_allocexecmem(i64 n) {
        byte *  p;
        u32 oldprot;
        i64 status;
    p = (byte *)VirtualAlloc(0,(u32)n,(u32)(i64)12288,(u32)(i64)1);
    if ((p == 0)) {
        return 0;
    }
;
    status = VirtualProtect(p,(u32)n,(u32)(i64)64,(u32 *)&oldprot);
    if ((status == (i64)0)) {
        return 0;
    }
;
    return p;
}

// START
void mwindows$start(void) {

}

u64 mwindllc$os_calldllfunction(void (*fnaddr)(void),i64 retcode,i64 nargs,i64 (*args)[],byte (*argcodes)[]) {
    if ((retcode == (i64)73)) {
        return (u64)mwindllc$calldll_cint((void (*)(void))fnaddr,args,nargs);
    }
    else {
        return (u64)mwindllc$calldll_creal((void (*)(void))fnaddr,args,nargs);
    }
;
}

u64 mwindllc$os_pushargs(u64 (*args)[],i64 nargs,i64 nextra,void (*fnaddr)(void),i64 isfloat) {
    return mwindllc$os_calldllfunction((void (*)(void))fnaddr,(!!(isfloat) ? (i64)0 : (i64)73),nargs,(i64 (*)[])args,0);
}

static i64 mwindllc$calldll_cint(void (*fnaddr)(void),i64 (*params)[],i64 nparams) {
    switch (nparams) {
    case 0:;
        {
            return ((*(i64 (*)(void))fnaddr))();
        }
        break;
    case 1:;
        {
            return ((*(i64 (*)(i64))fnaddr))((*params)[((i64)1)-1]);
        }
        break;
    case 2:;
        {
            return ((*(i64 (*)(i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1]);
        }
        break;
    case 3:;
        {
            return ((*(i64 (*)(i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1]);
        }
        break;
    case 4:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1]);
        }
        break;
    case 5:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1]);
        }
        break;
    case 6:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1]);
        }
        break;
    case 9:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1]);
        }
        break;
    case 10:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1]);
        }
        break;
    case 11:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1],(*params)[((i64)11)-1]);
        }
        break;
    case 12:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1],(*params)[((i64)11)-1],(*params)[((i64)12)-1]);
        }
        break;
    case 14:;
        {
            return ((*(i64 (*)(i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1],(*params)[((i64)3)-1],(*params)[((i64)4)-1],(*params)[((i64)5)-1],(*params)[((i64)6)-1],(*params)[((i64)7)-1],(*params)[((i64)8)-1],(*params)[((i64)9)-1],(*params)[((i64)10)-1],(*params)[((i64)11)-1],(*params)[((i64)12)-1],(*params)[((i64)13)-1],(*params)[((i64)14)-1]);
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_i64(nparams,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"calldll/c/int unsupported # of params",NULL);
        msysc$m_print_i64(nparams,NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)1);
    }
    } //SW
;
    return (i64)0;
}

static i64 mwindllc$calldll_creal(void (*fnaddr)(void),i64 (*params)[],i64 nparams) {
        r64 x;
    switch (nparams) {
    case 0:;
        {
            return (i64)((*(r64 (*)(void))fnaddr))();
        }
        break;
    case 1:;
        {
            mwindllc$os_dummycall((r64)(*params)[((i64)1)-1],(r64)(*params)[((i64)2)-1],(r64)(*params)[((i64)3)-1],(r64)(*params)[((i64)4)-1]);
            x = ((*(r64 (*)(i64))fnaddr))((*params)[((i64)1)-1]);
        }
        break;
    case 2:;
        {
            x = ((*(r64 (*)(i64,i64))fnaddr))((*params)[((i64)1)-1],(*params)[((i64)2)-1]);
        }
        break;
    default: {
        msysc$m_print_startcon();
        msysc$m_print_str((byte*)"calldll/c/real too many params",NULL);
        msysc$m_print_newline();
        msysc$m_print_end();
        ;
        exit((i64)1);
    }
    } //SW
;
    return *(i64*)&x;
}

void mwindllc$os_dummycall(r64 a,r64 b,r64 c,r64 d) {
}

// START
void mwindllc$start(void) {

}


/* ********** End of C Code ********** */

